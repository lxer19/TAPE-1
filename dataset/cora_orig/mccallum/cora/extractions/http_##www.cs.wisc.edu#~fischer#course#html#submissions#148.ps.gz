URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/148.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Title: Strictness analysis for concurrent logic programs  
Author: Moreno Falaschi Patrick Hicks William Winsborough 
Note: Corresponding author: William Winsborough, winsboro@cse.psu.edu, (814) 863-3600,  
Address: Via Delle Scienze, 206 33100 Udine, Italy  Park, PA 16802  Park, PA 16802  
Affiliation: Dipartimento di Matematica e Informatica,  Department of Computer Science and Engineering, Pennsylvania State University, University  Department of Computer Science and Engineering, Pennsylvania State University, University  
Date: October 23, 1995  
Abstract: Concurrent and functional languages need strictness for different, but related reasons. In functional programming, strictness analysis is used to identify arguments that must be evaluated by a function call, so that the efficient call-by-value reduction strategy can be applied without jeopardizing termination. In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. We have created an analysis for concurrent constraint logic programs which maps output demands to input demands. We believe that this analysis will enable optimizations on these programs including runtime and compile-time scheduling optimizations, which promise to greatly increase the efficiency of these programs by increasing computation to communication ratios and reducing the runtime complexities of scheduling. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Codish, M. Falaschi, K. Marriott, and W. Winsborough. </author> <title> Efficient Analysis of Concurrent Constraint Logic Programs. </title> <editor> In A. Lingas, R. Karlsson, and S. Carlsson, editors, </editor> <booktitle> Proc. of the 20th International Colloquium on Automata, Languages, and Programming, volume 700 of Lecture Notes in Computer Science, </booktitle> <pages> pages 633-644, </pages> <year> 1993. </year>
Reference-contexts: It also can eliminate tests for suspension by reasoning at compile time about what data will be available at runtime. It is likely that compile-time scheduling can be based on the abstract transition systems developed in <ref> [1] </ref> for suspension analysis. This is a subject for future work. 3. Strictness analysis finds out how much input is necessary for a procedure to generate a certain amount of output. This information can be used to increase message size. <p> In the following, we use + as a shorthand for P 2 2.3 Analysis of concurrent constraint languages Previous works on analysis of concurrent logic languages include <ref> [1, 3, 13, 22] </ref>. [1] considers a suspension analysis for a goal (or an agent) in a given program. If the analysis infers that a goal will not suspend, then non-suspension is guaranteed for any runtime scheduling rule. <p> In the following, we use + as a shorthand for P 2 2.3 Analysis of concurrent constraint languages Previous works on analysis of concurrent logic languages include [1, 3, 13, 22]. <ref> [1] </ref> considers a suspension analysis for a goal (or an agent) in a given program. If the analysis infers that a goal will not suspend, then non-suspension is guaranteed for any runtime scheduling rule. The analysis also can determine at compile time a fair scheduling of the goal.
Reference: [2] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In 4th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252. </pages> <publisher> ACM, </publisher> <year> 1977. </year>
Reference-contexts: The concrete interpretation is related to an operational semantics for the purpose of verification. The abstract interpretation specifies the analysis, and is related to the concrete interpretation in a standard way <ref> [2] </ref>. 3.1 Domains The concrete interpretation gives a semantics expressed in terms of equations over Herbrand terms. It is easily related to the reduction (operational) semantics of ccp and is shown to be safely approximating. The abstract interpretation defines the dataflow analysis. <p> Existential quantification is modeled by simple projection. The join operation introduces _ into type terms. These three operations are slight variants of those described and verified in [10]. The abstract operations must upper approximate the concrete operations, in the standard way <ref> [2] </ref>. The operator is introduced into type terms by using a widening operation [2] proposed in [20]. <p> The join operation introduces _ into type terms. These three operations are slight variants of those described and verified in [10]. The abstract operations must upper approximate the concrete operations, in the standard way <ref> [2] </ref>. The operator is introduced into type terms by using a widening operation [2] proposed in [20]. Widening introduces approximation into the fixpoint calculation, allowing a safe upper approximation of the least fixpoint to be found finitely, even in a domain that contains infinite increasing chains. 3.3 Modes The correctness of the collecting semantics relies on programs being well moded [12].
Reference: [3] <author> S. K. Debray, D. Gudeman, and P. Bigot. </author> <title> Optimization of suspension-free logic programs. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 International Symposium, </booktitle> <pages> pages 487-501. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: In the following, we use + as a shorthand for P 2 2.3 Analysis of concurrent constraint languages Previous works on analysis of concurrent logic languages include <ref> [1, 3, 13, 22] </ref>. [1] considers a suspension analysis for a goal (or an agent) in a given program. If the analysis infers that a goal will not suspend, then non-suspension is guaranteed for any runtime scheduling rule. <p> The analysis also can determine at compile time a fair scheduling of the goal. As such, it is likely to form a reasonable basis for compile-time scheduling, as discussed in the introduction. Debray, Gudeman and Bigot <ref> [3] </ref> present an analysis that identifies concurrent logic programs that can be executed according to a Prolog-like, left-to-right scheduling rule without danger of suspension. When the compiler finds this common scheduling to be safe, several optimizations, which they present, are enabled.
Reference: [4] <author> S. K. Debray, N.-W. Lin, and M. Hermenegildo. </author> <title> Task Granularity Analysis in Logic Programs. </title> <booktitle> In Proceedings of the ACM Sigplan'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 174-188. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Similarly, messages are so fine-grained that unless larger messages are composed, the high communication latencies of these platforms will make parallelization impractical. We believe that three tools would begin to address these problems. 1. Computational cost estimation <ref> [4, 19] </ref> gives a lower bound estimate of the computational cost of a procedure as a function of its input size. This is useful in establishing a threshold on input size above which it is economical to execute the computation remotely. 2.
Reference: [5] <author> Peter Dybjer. </author> <title> Inverse image analysis generalises strictness analysis. </title> <journal> Information and Computation, </journal> <volume> 90(2) </volume> <pages> 194-216, </pages> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. Strictness has been studied extensively in the context of functional programming <ref> [5, 7, 9, 11, 14, 16, 18, 21] </ref>. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output. <p> Strictness has been studied extensively in the context of functional programming [5, 7, 9, 11, 14, 16, 18, 21]. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output. For instance, <ref> [5] </ref> gives a very theoretical treatment based on open set expressions, which denote upwards closed (Scott open) sets of partial data structures.
Reference: [6] <author> N. Heintze and J. Jaffar. </author> <title> An Engine for Logic Program Analysis. </title> <booktitle> In Seventh IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 318-328. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Input and output demands are measures of data, which in our context means how constrained the shared data structures must be. The current approach quantifies such a demand by specifying a nonground type, rather than for instance a term size. (A nonground type <ref> [6, 10, 20] </ref> is a regular set of terms that possibly contain unbound variables.) The safety requirement of the analysis is that if the input provided to the process is less determined than required by the input demand, the output provided by the process will be less determined than required by
Reference: [7] <author> Fritz Henglein. </author> <title> Iterative fixed point computation for type-based strictness analysis. </title> <booktitle> In Proceedings from SAS '94, number 864 in Lecture Notes in Computer Science, </booktitle> <pages> pages 395-407, </pages> <year> 1994. </year>
Reference-contexts: In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. Strictness has been studied extensively in the context of functional programming <ref> [5, 7, 9, 11, 14, 16, 18, 21] </ref>. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output.
Reference: [8] <editor> L. Henkin, J.D. Monk, , and A. Tarski. Cylindric Algebras (Part I). </editor> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: General ccp is based on the notion of cylindric constraint systems <ref> [8] </ref>. Here we restrict our attention to existentially quantified conjunctions of equations over Herbrand terms. It is a matter for future research to determine whether our analysis can be generalized.
Reference: [9] <author> John Hughes. </author> <title> Analysing Strictness by Abstract Interpretation of Continuations, </title> <booktitle> chapter 4, </booktitle> <pages> pages 63-102. </pages> <booktitle> Ellis Horwood Series in Computers and Their Applications. </booktitle> <publisher> Ellis Horwood Limited, </publisher> <year> 1987. </year>
Reference-contexts: In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. Strictness has been studied extensively in the context of functional programming <ref> [5, 7, 9, 11, 14, 16, 18, 21] </ref>. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output.
Reference: [10] <author> G. Janssens and M. Bruynooghe. </author> <title> Deriving Descriptions of Possible Values of Program Variables by means of Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(1, 2, 3 and </volume> 4):205-258, 1992. 
Reference-contexts: Input and output demands are measures of data, which in our context means how constrained the shared data structures must be. The current approach quantifies such a demand by specifying a nonground type, rather than for instance a term size. (A nonground type <ref> [6, 10, 20] </ref> is a regular set of terms that possibly contain unbound variables.) The safety requirement of the analysis is that if the input provided to the process is less determined than required by the input demand, the output provided by the process will be less determined than required by <p> For the domain we experimented with, intersection of downwards closed sets of constraints corresponds to (abstract) unification of named type terms. Existential quantification is modeled by simple projection. The join operation introduces _ into type terms. These three operations are slight variants of those described and verified in <ref> [10] </ref>. The abstract operations must upper approximate the concrete operations, in the standard way [2]. The operator is introduced into type terms by using a widening operation [2] proposed in [20]. <p> The operations of unification, join, and less than are based on those described in <ref> [10] </ref>. Termination is ensured by using widening as described in [20]. Our analyzer analyzes programs that are written in ask/tell syntax and that have mode declarations. Arbitrary output demands can be analyzed. Since we are working with equations, simplifying the abstract constraints is equivalent to performing abstract unification.
Reference: [11] <author> Kristian Damm Jensen, Peter Hjresen, and Mads Rosendahl. </author> <title> Efficient strictness analysis. </title> <booktitle> In Proceedings from SAS '94, number 864 in Lecture Notes in Computer Science, </booktitle> <pages> pages 346-362, </pages> <year> 1994. </year>
Reference-contexts: In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. Strictness has been studied extensively in the context of functional programming <ref> [5, 7, 9, 11, 14, 16, 18, 21] </ref>. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output.
Reference: [12] <author> Masao Morita Kazunoria Ueda. </author> <title> Moded flat ghc and its message-oriented implementaton technique. </title> <journal> New Generation Computing, </journal> <year> 1994. </year>
Reference-contexts: Widening introduces approximation into the fixpoint calculation, allowing a safe upper approximation of the least fixpoint to be found finitely, even in a domain that contains infinite increasing chains. 3.3 Modes The correctness of the collecting semantics relies on programs being well moded <ref> [12] </ref>. In the present development, we assume a coarse form of modes that divides arguments into input and output. We assume that program atoms have the form B (x; y), where x is a vector in input variables and y is a vector of output variables. <p> It would be necessary to generalize this to richer modes if we were going to handle two-way streams. The more expressive notion of moding found in <ref> [12] </ref> would be perfectly suited to our technique. However, we use the coarser form here, as it is adequate for presentation of our technique. Below it is occasionally necessary to refer to the output variables of an agent in the program. We let Out (B (x; y)) = y.
Reference: [13] <author> A. King and P. Soper. </author> <title> Schedule Analysis of Concurrent Logic Programs. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 478-492. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: In the following, we use + as a shorthand for P 2 2.3 Analysis of concurrent constraint languages Previous works on analysis of concurrent logic languages include <ref> [1, 3, 13, 22] </ref>. [1] considers a suspension analysis for a goal (or an agent) in a given program. If the analysis infers that a goal will not suspend, then non-suspension is guaranteed for any runtime scheduling rule. <p> Zaffanella et al. [22] conduct a theoretical investigation of analysis of suspension-free concurrent constraint programs. They provide two transformations of suspension-free ccp programs that allow standard constraint-logic-program dataflow analysis techniques to be applied to the transformed programs. King and Soper <ref> [13] </ref> present an analysis for concurrent logic programs that allows a division of processes into threads, within which execution sequential. This work is related to load distribution and the possibilities of reciprocal benefits should be exploited. 3 Our approach The analysis maps output demands to input demands.
Reference: [14] <author> T-M Kuo and P Mishra. </author> <title> Strictness analysis: a new perspective based on type inference. </title> <booktitle> In FPCA'89, </booktitle> <address> London, England, </address> <pages> pages 260-272. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. Strictness has been studied extensively in the context of functional programming <ref> [5, 7, 9, 11, 14, 16, 18, 21] </ref>. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output.
Reference: [15] <author> M.J. Maher. </author> <title> Complete Axiomatizations of the Algebras of Finite, Rational and Infinite Trees. </title> <booktitle> In Proc. of Third IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 348-357. </pages> <publisher> IEEE Press, </publisher> <year> 1988. </year>
Reference-contexts: We let Out (B (x; y)) = y. For compound agents, we presume a consistent moding exists and similarly refer to output variables of agent A by Out (A). 3.4 Collecting semantics In the collecting semantics it is helpful to use first order existential quantification over the Herbrand equations <ref> [15] </ref>. It serves to project the constraints onto variables of interest. We let C denote the set of possibly existentially quantified sets of equations over terms. Elements of C are regarded as (quantified) conjunctions of equations and treated modulo logical equivalence.
Reference: [16] <author> A. Mycroft. </author> <title> The theory and practice of transforming call-by-need into call-by-value. </title> <booktitle> In Proceedings of the 4th International Symposium on Programming, number 83 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. Strictness has been studied extensively in the context of functional programming <ref> [5, 7, 9, 11, 14, 16, 18, 21] </ref>. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output.

Reference: [18] <author> R C Sekar, Prateel Mishra, and I V Ramakrishnan. </author> <title> On the power and limitation of strictness analysis based on abstract interpretation. </title> <booktitle> In 18th POPL, </booktitle> <address> Orlando, Florida, </address> <pages> pages 37-48. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. Strictness has been studied extensively in the context of functional programming <ref> [5, 7, 9, 11, 14, 16, 18, 21] </ref>. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output.
Reference: [19] <author> N.-W. Lin S.K. Debray. </author> <title> Cost analysis of logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(5) </volume> <pages> 826-875, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Similarly, messages are so fine-grained that unless larger messages are composed, the high communication latencies of these platforms will make parallelization impractical. We believe that three tools would begin to address these problems. 1. Computational cost estimation <ref> [4, 19] </ref> gives a lower bound estimate of the computational cost of a procedure as a function of its input size. This is useful in establishing a threshold on input size above which it is economical to execute the computation remotely. 2.
Reference: [20] <author> P. Van Hentenryck, A. Cortesi, and B. Le Charlier. </author> <title> Type Analysis of Prolog using Type Graphs. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, volume 29 of SIGPLAN Notices, </booktitle> <pages> pages 337-348. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year> <note> also Tech. Report CS-93-52 at Brown University. </note>
Reference-contexts: Input and output demands are measures of data, which in our context means how constrained the shared data structures must be. The current approach quantifies such a demand by specifying a nonground type, rather than for instance a term size. (A nonground type <ref> [6, 10, 20] </ref> is a regular set of terms that possibly contain unbound variables.) The safety requirement of the analysis is that if the input provided to the process is less determined than required by the input demand, the output provided by the process will be less determined than required by <p> These three operations are slight variants of those described and verified in [10]. The abstract operations must upper approximate the concrete operations, in the standard way [2]. The operator is introduced into type terms by using a widening operation [2] proposed in <ref> [20] </ref>. Widening introduces approximation into the fixpoint calculation, allowing a safe upper approximation of the least fixpoint to be found finitely, even in a domain that contains infinite increasing chains. 3.3 Modes The correctness of the collecting semantics relies on programs being well moded [12]. <p> The operations of unification, join, and less than are based on those described in [10]. Termination is ensured by using widening as described in <ref> [20] </ref>. Our analyzer analyzes programs that are written in ask/tell syntax and that have mode declarations. Arbitrary output demands can be analyzed. Since we are working with equations, simplifying the abstract constraints is equivalent to performing abstract unification.
Reference: [21] <author> Philip Wadler. </author> <title> Strictness Analysis on Non-Flat Domains (by Abstract Interpretation over Finite Domains, </title> <booktitle> chapter 11, </booktitle> <pages> pages 266-275. </pages> <booktitle> Ellis Horwood Series in Computers and Their Applications. </booktitle> <publisher> Ellis Horwood Limited, </publisher> <year> 1987. </year>
Reference-contexts: In concurrent evaluation an analogous issue arises. In both contexts, the issue concerns how much information is required in a procedure's input to enable it to generate output information. Strictness has been studied extensively in the context of functional programming <ref> [5, 7, 9, 11, 14, 16, 18, 21] </ref>. Some of these studies have considered partial data structures and the question of how much input is necessary to generate a given amount of output.
Reference: [22] <author> E. Zaffanella, G. Levi, and R. Giacobazzi. </author> <title> Abstracting Synchronization in Concurrent Constraint Programming. </title> <booktitle> In Proc. 5th Int'l Symposium on Programming Language Implementation and Logic Pro gramming, volume 844 of Lecture Notes in Computer Science, </booktitle> <pages> pages 57-72. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In the following, we use + as a shorthand for P 2 2.3 Analysis of concurrent constraint languages Previous works on analysis of concurrent logic languages include <ref> [1, 3, 13, 22] </ref>. [1] considers a suspension analysis for a goal (or an agent) in a given program. If the analysis infers that a goal will not suspend, then non-suspension is guaranteed for any runtime scheduling rule. <p> Debray, Gudeman and Bigot [3] present an analysis that identifies concurrent logic programs that can be executed according to a Prolog-like, left-to-right scheduling rule without danger of suspension. When the compiler finds this common scheduling to be safe, several optimizations, which they present, are enabled. Zaffanella et al. <ref> [22] </ref> conduct a theoretical investigation of analysis of suspension-free concurrent constraint programs. They provide two transformations of suspension-free ccp programs that allow standard constraint-logic-program dataflow analysis techniques to be applied to the transformed programs.
References-found: 21

