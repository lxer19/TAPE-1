URL: http://www.cs.utah.edu/~ratan/papers/ieee.ps.gz
Refering-URL: http://www.cs.utah.edu/~ratan/res.html
Root-URL: 
Email: fratan,ganeshg@cs.utah.edu,  
Title: An Automated Framework for Developing Efficient Hardware DSM Protocols  
Author: Ratan Nalumasu Ganesh Gopalakrishnan 
Web: http://www.cs.utah.edu/~fratan,ganeshg  
Address: Salt Lake City, UT 84112, USA,  
Affiliation: University of Utah,  
Abstract: We address the problem of developing efficient cache coherence protocols implementing distributed shared memory (DSM) using message passing. A serious drawback of traditional approaches to this problem is that designers are required to state the desired coherence protocol at the level of asynchronous message interactions. We propose a method in which designers express the desired protocol at a high-level using rendezvous communication. These descriptions are much easier to understand and compu-tationally more efficient to verify than asynchronous protocols due to their small state spaces. The rendezvous protocol can also be synthesized into efficient asynchronous protocols. We present our protocol refinement procedure, prove its soundness, and illustrate its efficacy.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.S. Boyer and J. S. Moore. </author> <title> A computation Logic Handbook. </title> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference-contexts: Since the rendezvous protocol is equivalent to the asynchronous protocol obtained by the refinement rules, the designers can analyze the rendezvous protocol for correct operation but need not analyze the asynchronous protocol. Formal verification techniques such as theorem proving <ref> [1, 16] </ref> and model-checking [5] can be used to verify the protocol. We used the SPIN model-checker to verify the migratory and invalidate, another protocol developed for use in Avalanche. Model-checking is based on the idea of fully exploring the state space of the protocol to establish its correctness.
Reference: [2] <author> G. N. Buckley and A. Silberschatz. </author> <title> An effective implementation for the generalized input-output construct of CSP. </title> <journal> ACM TOPLAS, </journal> <volume> 5(2):223235, </volume> <month> April </month> <year> 1983. </year>
Reference-contexts: In contrast, in our approach, user writes the rendezvous protocol using only the rendezvous primitive, verifies the protocol at this level with great efficiency and compiles it into an efficient asynchronous protocol or object code. Our work closely resembles that of Buckley and Silberschatz <ref> [2] </ref>. Buckley and Silberschatz consider the problem of implementing rendezvous using message passing when the processes use generalized input/output guard to be implemented in software. Their solution is too expensive for DSM protocol implementations.
Reference: [3] <author> S. Chandra, B. Richards, and J. R. Larus. Teapot: </author> <title> Language support for writing memory coherency protocols. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Section 6 presents an example protocol developed using the refinement rules. Section 7 compares the efficiency of formally verifying the rendezvous protocols and the asynchronous protocols. Finally, Section 8 concludes the paper. Related Work Chandra et al <ref> [3] </ref> use a model based on continuations to help reduce the complexity of specifying the coherency protocols. The specification can then be model checked and compiled into an efficient object code.
Reference: [4] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Their solution is too expensive for DSM protocol implementations. In contrast, we focus on a star configuration of processes with suitable syntactic restrictions on the high-level specification language, so that an efficient asynchronous protocol can be automatically generated. Chandy and Misra <ref> [4] </ref> showed that under a strict condition called asynchrony, shared variables can be implemented by message passing. Unfortunately, this condition is not met in many practical protocols.
Reference: [5] <author> Edmund Clarke, Allen Emerson, and Arvind Sistla. </author> <title> Automatic verification of finite-state concurent systems using temporal logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2):244263, </volume> <year> 1986. </year>
Reference-contexts: Since the rendezvous protocol is equivalent to the asynchronous protocol obtained by the refinement rules, the designers can analyze the rendezvous protocol for correct operation but need not analyze the asynchronous protocol. Formal verification techniques such as theorem proving [1, 16] and model-checking <ref> [5] </ref> can be used to verify the protocol. We used the SPIN model-checker to verify the migratory and invalidate, another protocol developed for use in Avalanche. Model-checking is based on the idea of fully exploring the state space of the protocol to establish its correctness.
Reference: [6] <author> Cray Research, Inc. </author> <title> CRAY T3D System Architecture Overview, </title> <address> hr-04033 edition, </address> <month> September </month> <year> 1993. </year> <month> 12 </month>
Reference: [7] <author> E. P. </author> <title> Gribo mont. From synchronous to asynchronous communication. </title> <editor> In C. Rattay, editor, </editor> <booktitle> Specification and Verification of Concurrent Systems, </booktitle> <pages> pages 368383. </pages> <institution> Springer-Verilog, University of Stirling, </institution> <address> Scotland, </address> <year> 1990. </year>
Reference-contexts: Chandy and Misra [4] showed that under a strict condition called asynchrony, shared variables can be implemented by message passing. Unfortunately, this condition is not met in many practical protocols. Gribo mont <ref> [7] </ref> explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way. In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication.
Reference: [8] <author> J. L. Hennessy and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Apporach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year> <note> Second Edition, Appendix E. </note>
Reference-contexts: DSM systems have been widely researched as the next logical step in parallel processing [6,10,11,13,15]. A central problem in DSM systems is the design and implementation of distributed coherence protocols for shared cache lines using message passing <ref> [8] </ref>. The present-day approach to this problem consists of specifying the detailed interactions possible between the nodes in terms of (low-level) requests, acknowledges, negative acknowledges, and dealing with unexpected messages. This is motivated by a transaction shown in Figure 1. <p> We also assume that the network has infinite buffering, in the sense that the network can always accept new messages to be delivered. Without this assumption, the asynchronous protocol generated may deadlock. If the assumption is not satisfied, then the solution proposed by Hennessy and Patterson in <ref> [8] </ref> can be used as a post-processing step of the refined protocol. They divide the messages into two categories: request and acknowledge. A request message may cause the recipient to generate more messages in order to complete the transactions, while an acknowledge message does not.
Reference: [9] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> CACM, </journal> <volume> 21(8):666677, </volume> <year> 1978. </year>
Reference-contexts: This is shown with the aid of Figure 2. The dotted lines show the transitions that did not take place in the following scenario. The logical specification, shown in Figure 2 (a), uses Communicating Sequential Processes (CSP) <ref> [9] </ref> syntax for indicating the the communication: when process P executes Q!msg, and Q executes P?msg, they exchange the message atomically (rendezvous communication). Process P is said to be active and process Q is said to be passive in the rendezvous. <p> As we shall see in Section 3, asynchronous protocol has two acknowledge messages: ack and nack. 2.2 Rendezvous Communication We use rendezvous communication primitives of Communicating Sequential Processes (CSP) <ref> [9] </ref> to specify the home node and the remote nodes to simplify the DSM protocol design.
Reference: [10] <author> R. Kuramkote, J. Carter, A. Davis, C. Kuo, L. Stoller, and M. Swanson. </author> <title> Analysis of avalanche's shared memory architecture. </title> <type> Technical Report UUCS-97-008, </type> <institution> University of Utah Computer Science Department, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: Another important advantage of specifying the protocol at a high-level is that formal verification becomes much more tractable due to fewer interleavings present. For example, we verified migratory, a DSM protocol developed to be used in Available <ref> [10] </ref>, for 64 nodes with in 32 MB memory. The detailed specification of the protocol can be verified for at most 2 nodes in 64 MB memory. The details of the protocol and the verification are provied in Sections 6 and 7. <p> This decision helps synthesizing more efficient asynchronous protocols, as we shall see later. 2.1 Communication Model We assume that the network that connects the nodes in the systems provides reliable, point-to-point in-order delivery of messages. This assumption is justified in many machines, e.g., DASH [13], and Avalanche <ref> [10] </ref>. We also assume that the network has infinite buffering, in the sense that the network can always accept new messages to be delivered. Without this assumption, the asynchronous protocol generated may deadlock.
Reference: [11] <author> J. Kuskin and D. Ofelt et al. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 302313, </pages> <month> May </month> <year> 1994. </year>
Reference: [12] <author> L. Lamport and F. B. Schneider. </author> <note> Pretending atomicity. In Research Report 44, </note> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Gribo mont [7] explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way. In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication. Lamport and Schneider <ref> [12] </ref> have explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous communication) and split transactions (e.g., asynchronous communication), based on left and right movers [14], but have not considered specific refinement rules. 3 2 Cache Coherency in Distributed Systems In directory based cache coherent multiprocessor systems, the coherency of each
Reference: [13] <author> D. Lenoski, J. Laudon, K. Gharachorloo, W.-D. Weber, A. Gupta, J. Hennessy, M. Horowitz, and M. S. Lam. </author> <title> The Stanford DASH multiprocessor. </title> <journal> IEEE Computer, </journal> <volume> 25(3):6379, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: This decision helps synthesizing more efficient asynchronous protocols, as we shall see later. 2.1 Communication Model We assume that the network that connects the nodes in the systems provides reliable, point-to-point in-order delivery of messages. This assumption is justified in many machines, e.g., DASH <ref> [13] </ref>, and Avalanche [10]. We also assume that the network has infinite buffering, in the sense that the network can always accept new messages to be delivered. Without this assumption, the asynchronous protocol generated may deadlock.
Reference: [14] <author> R. J. Lipton. </author> <title> Reduction: A method of proving properties of parallel programs. </title> <journal> CACM, </journal> <volume> 18(12):717721, </volume> <month> December </month> <year> 1975. </year>
Reference-contexts: In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication. Lamport and Schneider [12] have explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous communication) and split transactions (e.g., asynchronous communication), based on left and right movers <ref> [14] </ref>, but have not considered specific refinement rules. 3 2 Cache Coherency in Distributed Systems In directory based cache coherent multiprocessor systems, the coherency of each line of shared memory is managed by a CPU node, called home node, or simply home 2 .
Reference: [15] <author> A. Nowatzyk, G. Aybay, M. Browne, E. Kelly, M. Parkin, B. Radke, and S. Vishin. </author> <title> The S3.mp scalable shared memory multiprocessor. </title> <booktitle> In Proceedings of the 1995 International Conference on Parallel Processing, </booktitle> <year> 1995. </year>
Reference-contexts: The first observation is that, in a typical DSM protocol, the shared memory cache lines are insulated from each other; for example, actions related to one line do not affect the actions related to another line <ref> [15] </ref>. The second observation is that a given node cannot suffer cache miss for an unbounded number of lines. For example, a typical modern CPU processor can have about 10 outstanding cache misses.
Reference: [16] <author> S. Owre, S. Rajan, J. M. Rushby, N. Shankar, and M. Srivas. PVS: </author> <title> Combining specification, proof checking and model checking. </title> <booktitle> In CAV, </booktitle> <pages> pages 411414, </pages> <address> New Brunswick, NJ, USA, </address> <year> 1996. </year> <month> 13 </month>
Reference-contexts: An ack is generated only in case 2 which completes a rendezvous in asynchronous protocol. This rendezvous is also allowed by the rendezvous protocol. We formalized above argument in a theorem prover called PVS <ref> [16] </ref> and proved that the refinement rules are safety preserving. <p> Since the rendezvous protocol is equivalent to the asynchronous protocol obtained by the refinement rules, the designers can analyze the rendezvous protocol for correct operation but need not analyze the asynchronous protocol. Formal verification techniques such as theorem proving <ref> [1, 16] </ref> and model-checking [5] can be used to verify the protocol. We used the SPIN model-checker to verify the migratory and invalidate, another protocol developed for use in Avalanche. Model-checking is based on the idea of fully exploring the state space of the protocol to establish its correctness.
References-found: 16

