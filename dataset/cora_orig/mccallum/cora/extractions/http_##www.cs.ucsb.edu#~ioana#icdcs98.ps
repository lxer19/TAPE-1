URL: http://www.cs.ucsb.edu/~ioana/icdcs98.ps
Refering-URL: http://www.cs.ucsb.edu/~ioana/
Root-URL: http://www.cs.ucsb.edu
Title: Using Broadcast Primitives in Replicated Databases  
Author: I. Stanoi D. Agrawal A. El Abbadi 
Date: October 8, 1997  
Address: Santa Barbara, CA 93106  
Affiliation: Dept. of Computer Science University of California  
Abstract: In this paper, we explore the use of the simple variants of broadcast protocols for managing replicated databases. In particular, we start with the simplest broadcast primitive, the reliable broadcast protocol, and show how it can be used to ensure correct transaction execution. The protocol is simple, and has several advantages, including prevention of deadlocks. However, it requires a two-phase commitment protocol for ensuring correctness. We then develop a second protocol that uses causal broadcast and avoids the overhead of two-phase commit by exploiting the causal delivery properties of the broadcast primitives to implicitly collect the relevant information used in two-phase commit. Finally, we present a protocol that employs atomic broadcast and completely eliminates the need for acknowledgements during transaction commitment.
Abstract-found: 1
Intro-found: 1
Reference: [AAES97] <author> D. Agrawal, G. Alonso, A. El Abbadi, and I. Stanoi. </author> <title> Exploiting Atomic Broadcast in Replicated Databases. </title> <booktitle> In Proceedings of the 1997 EURO-PAR International Conference on Parallel Processing, </booktitle> <pages> pages 496-503, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: Recently, there has been increasing interest in the management of replicated databases, where the unit of activity is a transaction consisting of multiple operations that need to be executed atomically as a unit [SR96]. Two proposals that do consider the semantics of transactions are <ref> [BBD94, AAES97] </ref>. In both cases, the replication management protocols require, in addition to the broadcast primitives, additional techniques to ensure correct transaction execution. Furthermore, they are based on atomic broadcast primitives, which are both expensive and complex to implement in asynchronous systems that are subject to failures.
Reference: [ACBMT96] <author> E. Anceaume, B. Charron-Bost, P. Minet, and S. Toueg. </author> <title> On the Formal Specification of Group Membership Services. </title> <type> Technical Report, </type> <year> 1996. </year>
Reference-contexts: 1 Introduction Recently there has been increasing interest in the development of broadcast protocols for disseminating information in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, ACBMT96] </ref>. Several broadcast protocols with varying properties have been proposed and implemented in different distributed systems. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system.
Reference: [ADKM92a] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In Proceedings of the 6th International Workshop on Distributed Algorithm, WDAG '92, Lecture Notes in Computer Science, </booktitle> <pages> pages 292-312. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Various implementations of these protocols have been proposed for different underlying hardware, including Amoeba [KT91], ISIS [Bv94], Trans [MMA90], Transis <ref> [ADKM92b, ADKM92a] </ref>, Total [MAMSA94], and Totem [AMMS + 95, MMSA + 96]. In general, the weaker the ordering requirements the more efficient the protocol. The ISIS system is a clear example where this is the case. <p> Atomic broadcast has been implemented in Amoeba [KT91], ISIS [Bv94], Transis <ref> [ADKM92b, ADKM92a] </ref>, Total [MAMSA94] and Totem [AMMS + 95, MMSA + 96]. 3 Reliable Broadcast-Based Protocol Reliable broadcast is a simple communication primitive that is relatively straightforward to implement when compared to ordered broadcast primitives such as causal or atomic broadcast.
Reference: [ADKM92b] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> a communication sub-system for high availability. </title> <booktitle> In Proceedings of the Twenty-Second International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 76-84, </pages> <year> 1992. </year>
Reference-contexts: Various implementations of these protocols have been proposed for different underlying hardware, including Amoeba [KT91], ISIS [Bv94], Trans [MMA90], Transis <ref> [ADKM92b, ADKM92a] </ref>, Total [MAMSA94], and Totem [AMMS + 95, MMSA + 96]. In general, the weaker the ordering requirements the more efficient the protocol. The ISIS system is a clear example where this is the case. <p> Causal broadcast protocols have been implemented in several systems such as ISIS [Bv94], Trans [MMA90], and Transis <ref> [ADKM92b] </ref>. <p> Atomic broadcast has been implemented in Amoeba [KT91], ISIS [Bv94], Transis <ref> [ADKM92b, ADKM92a] </ref>, Total [MAMSA94] and Totem [AMMS + 95, MMSA + 96]. 3 Reliable Broadcast-Based Protocol Reliable broadcast is a simple communication primitive that is relatively straightforward to implement when compared to ordered broadcast primitives such as causal or atomic broadcast.
Reference: [AE90] <author> D. Agrawal and A. El Abbadi. </author> <title> Locks with Constrained Sharing. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 85-93, </pages> <month> April </month> <year> 1990. </year> <note> To appear in Journal of Computer and System Sciences. </note>
Reference-contexts: A commonly accepted correctness criterion in databases is the serializable execution of transactions [EGLT76]. Serializable executions are guaranteed by employing a concurrency control mechanism, e.g., locking <ref> [EGLT76, SK80, AE90] </ref>, timestamp ordering [Ree78], or optimistic concurrency control [KR81] protocols. Since strict two-phase locking 1 is widely used, we assume in this paper that concurrency control is locally enforced by strict two-phase locking at all database sites.
Reference: [AE91] <author> D. Agrawal and A. El Abbadi. </author> <title> An Efficient and Fault-tolerant Solution for Distributed Mutual Exclusion. </title> <journal> ACM Transactions on Computer Systems, </journal> <pages> pages 1-20, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: There are numerous replica control protocols such as the read-one write-all protocol, the majority quorum protocol [Gif79], as well as the variants of the majority quorum protocol <ref> [Mae85, AE91] </ref>. All these protocols have been studied in the context of a point-to-point communication environment. In this paper, we start by adapting the read-one write-all protocol for broadcast environments. In fact, many of the broadcast primitives incorporate in their implementation various techniques for fault-tolerance including the majority quorum approach.
Reference: [AMMS + 95] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal, and P. Ciarfella. </author> <title> The Totem Single-Ring Ordering and Membership Protocol. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(4) </volume> <pages> 311-342, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Recently there has been increasing interest in the development of broadcast protocols for disseminating information in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, ACBMT96] </ref>. Several broadcast protocols with varying properties have been proposed and implemented in different distributed systems. <p> Various implementations of these protocols have been proposed for different underlying hardware, including Amoeba [KT91], ISIS [Bv94], Trans [MMA90], Transis [ADKM92b, ADKM92a], Total [MAMSA94], and Totem <ref> [AMMS + 95, MMSA + 96] </ref>. In general, the weaker the ordering requirements the more efficient the protocol. The ISIS system is a clear example where this is the case. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system. <p> Atomic broadcast has been implemented in Amoeba [KT91], ISIS [Bv94], Transis [ADKM92b, ADKM92a], Total [MAMSA94] and Totem <ref> [AMMS + 95, MMSA + 96] </ref>. 3 Reliable Broadcast-Based Protocol Reliable broadcast is a simple communication primitive that is relatively straightforward to implement when compared to ordered broadcast primitives such as causal or atomic broadcast.
Reference: [BBD94] <author> O. Babaoglu, A. Bartoli, and G. Dini. </author> <title> Replicated file management in large-scale distributed systems. </title> <booktitle> In Proceedings of the 8th International Workshop on Distributed Algorithms, WDAG'94, Lecture Notes in Computer Science, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: Recently, there has been increasing interest in the management of replicated databases, where the unit of activity is a transaction consisting of multiple operations that need to be executed atomically as a unit [SR96]. Two proposals that do consider the semantics of transactions are <ref> [BBD94, AAES97] </ref>. In both cases, the replication management protocols require, in addition to the broadcast primitives, additional techniques to ensure correct transaction execution. Furthermore, they are based on atomic broadcast primitives, which are both expensive and complex to implement in asynchronous systems that are subject to failures.
Reference: [BG87] <author> P. A. Bernstein and N. Goodman. </author> <title> A Proof Technique for Concurrency Control and Recovery Algorithms for Replicated Databases. Distributed Computing, </title> <publisher> Springer-Verlag, </publisher> <pages> 2(1) 32-44, </pages> <month> January </month> <year> 1987. </year> <month> 16 </month>
Reference-contexts: Multiple copies of an object must appear as a single 1 In strict two-phase locking, transactions hold all locks until termination. 2 logical object to the transactions. This is termed as one-copy equivalence and is enforced by a replica control protocol <ref> [BG87] </ref>. The correctness criterion for replicated databases is one-copy serializability [BG87], which ensures both one-copy equivalence and the serializable execution of transactions. In this paper we will use the notion of one-copy serialization graphs, which is based on serialization graphs to prove correctness of executions in replicated databases [BHG87]. <p> This is termed as one-copy equivalence and is enforced by a replica control protocol <ref> [BG87] </ref>. The correctness criterion for replicated databases is one-copy serializability [BG87], which ensures both one-copy equivalence and the serializable execution of transactions. In this paper we will use the notion of one-copy serialization graphs, which is based on serialization graphs to prove correctness of executions in replicated databases [BHG87].
Reference: [BHG87] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: The correctness criterion for replicated databases is one-copy serializability [BG87], which ensures both one-copy equivalence and the serializable execution of transactions. In this paper we will use the notion of one-copy serialization graphs, which is based on serialization graphs to prove correctness of executions in replicated databases <ref> [BHG87] </ref>. For simplicity, in this paper, we assume that the database is fully replicated, i.e., every site stores a copy of all objects in the databases. Furthermore, we assume that a transaction performs all its read operations before initiating any write operations.
Reference: [Bir85] <author> K. P. Birman. </author> <title> Replication and Fault-tolerance in the ISIS System. </title> <booktitle> In Proceedings of the Tenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 79-86, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Recently there has been increasing interest in the development of broadcast protocols for disseminating information in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, ACBMT96] </ref>. Several broadcast protocols with varying properties have been proposed and implemented in different distributed systems. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system.
Reference: [Bv94] <author> K. P. Birman and R. van Renesse. </author> <title> Reliable Distributed Computing with the ISIS Toolkit. </title> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Recently there has been increasing interest in the development of broadcast protocols for disseminating information in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, ACBMT96] </ref>. Several broadcast protocols with varying properties have been proposed and implemented in different distributed systems. <p> Various implementations of these protocols have been proposed for different underlying hardware, including Amoeba [KT91], ISIS <ref> [Bv94] </ref>, Trans [MMA90], Transis [ADKM92b, ADKM92a], Total [MAMSA94], and Totem [AMMS + 95, MMSA + 96]. In general, the weaker the ordering requirements the more efficient the protocol. The ISIS system is a clear example where this is the case. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system. <p> Causal broadcast protocols have been implemented in several systems such as ISIS <ref> [Bv94] </ref>, Trans [MMA90], and Transis [ADKM92b]. <p> However, due to the FIFO assumption about the communication links, if a process atomically (or for that matter reliably or causally) broadcasts a message m 1 before message m 2 then all processes receive m 1 before m 2 . Atomic broadcast has been implemented in Amoeba [KT91], ISIS <ref> [Bv94] </ref>, Transis [ADKM92b, ADKM92a], Total [MAMSA94] and Totem [AMMS + 95, MMSA + 96]. 3 Reliable Broadcast-Based Protocol Reliable broadcast is a simple communication primitive that is relatively straightforward to implement when compared to ordered broadcast primitives such as causal or atomic broadcast. <p> In particular, the communication layer maintains a view of the current system configuration. As site failures and recovery occur, the view is dynamically restructured using the notion of majority quorums. As long as the view has majority membership, the system remains operational <ref> [Bv94, SS94] </ref>. Given a view of the current configuration, we use the notion of read-one write-all in that context. This avoids duplication of efforts to provide fault tolerance at multiple levels. In the point-to-point communication model, transactions in the read-one write-all protocol execute as follows. <p> On the other hand, if the site receives a negative acknowledgment the transaction is aborted. Note that in order to implement this protocol, the communication layer must expose the mechanism used for determining causal relationships among messages, e.g., the vector clocks associated with the messages <ref> [Bv94] </ref>. Furthermore, if this information is available to the application layer, it can be also used for early detection of conflict among transactions. In particular, we can detect that two conflicting operations are concurrent and hence will be aborted. We now describe the protocol in more detail. <p> To order the commit requests while at the same time use causal broadcast to disseminate write operations, the system must support both atomic as well as causal broadcast primitives. For example, ISIS provides both primitives for application design <ref> [Bv94] </ref>. While commit requests are delivered in total order by atomic broadcasts, the operations that are 12 in the Causal Broadcast-Based Protocol. sent through causal broadcast may be concurrent.
Reference: [CHTCB96] <author> T. D. Chandra, V. Hadzilacos, S. Toueg, and B. Charron-Bost. </author> <title> On the Impossibility of Group Membership. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1996. </year>
Reference-contexts: The ISIS system is a clear example where this is the case. In addition to being expensive to implement atomic broadcasts, it has been shown that there are no deterministic atomic broadcast protocols for asynchronous systems even when at most one site can fail by crashing <ref> [HT93, CT96, CHTCB96] </ref>. 1 An important and often cited application of broadcast protocols is the management of replicated data. The underlying intuition is that a reliable broadcast with an ordering guarantee should be easy to use for the correct management of such replicated data. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system.
Reference: [CT96] <author> T. Chandra and S. Toueg. </author> <title> Unreliable Failure Detectors for Reliable Distributed Systems. </title> <journal> Journal of the ACM, </journal> <volume> 43(2) </volume> <pages> 225-267, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: The ISIS system is a clear example where this is the case. In addition to being expensive to implement atomic broadcasts, it has been shown that there are no deterministic atomic broadcast protocols for asynchronous systems even when at most one site can fail by crashing <ref> [HT93, CT96, CHTCB96] </ref>. 1 An important and often cited application of broadcast protocols is the management of replicated data. The underlying intuition is that a reliable broadcast with an ordering guarantee should be easy to use for the correct management of such replicated data.
Reference: [DM96] <author> D. Dolev and D. Malki. </author> <title> The Transis approach to High Availability Cluster Communication. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 64-70, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Recently there has been increasing interest in the development of broadcast protocols for disseminating information in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, ACBMT96] </ref>. Several broadcast protocols with varying properties have been proposed and implemented in different distributed systems. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system.
Reference: [EGLT76] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in a Database System. </title> <journal> Communications of the ACM, </journal> 19(11) 624-633, November 1976. 
Reference-contexts: Users interact with the database by invoking transactions. A transaction is a sequence of read and write operations that are executed atomically, i.e., a transaction either commits or aborts [Gra78] the results of all its operations. A commonly accepted correctness criterion in databases is the serializable execution of transactions <ref> [EGLT76] </ref>. Serializable executions are guaranteed by employing a concurrency control mechanism, e.g., locking [EGLT76, SK80, AE90], timestamp ordering [Ree78], or optimistic concurrency control [KR81] protocols. <p> A commonly accepted correctness criterion in databases is the serializable execution of transactions [EGLT76]. Serializable executions are guaranteed by employing a concurrency control mechanism, e.g., locking <ref> [EGLT76, SK80, AE90] </ref>, timestamp ordering [Ree78], or optimistic concurrency control [KR81] protocols. Since strict two-phase locking 1 is widely used, we assume in this paper that concurrency control is locally enforced by strict two-phase locking at all database sites.
Reference: [Gif79] <author> D. K. Gifford. </author> <title> Weighted Voting for Replicated Data. </title> <booktitle> In Proceedings of the Seventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 150-159, </pages> <month> December </month> <year> 1979. </year>
Reference-contexts: Since reliable broadcast guarantees eventual delivery, one of the motivations for our protocol is to remove the need for explicit acknowledgment after every remote interaction. There are numerous replica control protocols such as the read-one write-all protocol, the majority quorum protocol <ref> [Gif79] </ref>, as well as the variants of the majority quorum protocol [Mae85, AE91]. All these protocols have been studied in the context of a point-to-point communication environment. In this paper, we start by adapting the read-one write-all protocol for broadcast environments.
Reference: [Gra78] <author> J. N. Gray. </author> <title> Notes on database systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seeg-muller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, volume 60 of Lecture Notes in Computer Science, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: A distributed database consists of a set of objects stored at the different sites. Users interact with the database by invoking transactions. A transaction is a sequence of read and write operations that are executed atomically, i.e., a transaction either commits or aborts <ref> [Gra78] </ref> the results of all its operations. A commonly accepted correctness criterion in databases is the serializable execution of transactions [EGLT76]. Serializable executions are guaranteed by employing a concurrency control mechanism, e.g., locking [EGLT76, SK80, AE90], timestamp ordering [Ree78], or optimistic concurrency control [KR81] protocols.
Reference: [HT93] <author> V. Hadzilacos and S. Toueg. </author> <title> Fault-Tolerant Broadcast and Related Problems. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, chapter 5, </booktitle> <pages> pages 97-147. </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Recently there has been increasing interest in the development of broadcast protocols for disseminating information in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, ACBMT96] </ref>. Several broadcast protocols with varying properties have been proposed and implemented in different distributed systems. <p> The ISIS system is a clear example where this is the case. In addition to being expensive to implement atomic broadcasts, it has been shown that there are no deterministic atomic broadcast protocols for asynchronous systems even when at most one site can fail by crashing <ref> [HT93, CT96, CHTCB96] </ref>. 1 An important and often cited application of broadcast protocols is the management of replicated data. The underlying intuition is that a reliable broadcast with an ordering guarantee should be easy to use for the correct management of such replicated data. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system. <p> Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system. However, most of the protocols have the following properties, which can also be used to define the simplest primitive, the reliable broadcast protocol <ref> [HT93] </ref>: 1. Validity: If a correct process broadcasts a message m, then all correct processes eventually deliver m. 2. Agreement: If a correct process delivers a message m, then all correct processes eventually deliver m. 3.
Reference: [KR81] <author> H. T. Kung and J. T. Robinson. </author> <title> On Optimistic Methods for Concurrency Control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(2) </volume> <pages> 213-226, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: A commonly accepted correctness criterion in databases is the serializable execution of transactions [EGLT76]. Serializable executions are guaranteed by employing a concurrency control mechanism, e.g., locking [EGLT76, SK80, AE90], timestamp ordering [Ree78], or optimistic concurrency control <ref> [KR81] </ref> protocols. Since strict two-phase locking 1 is widely used, we assume in this paper that concurrency control is locally enforced by strict two-phase locking at all database sites. In a replicated database, copies of an object may be stored at several sites in the network.
Reference: [KT91] <author> M. Frans Kaashoek and A. S. Tanenbaum. </author> <title> Group Communication in the Amoeba Distributed Operating Systems. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 222-230, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Various implementations of these protocols have been proposed for different underlying hardware, including Amoeba <ref> [KT91] </ref>, ISIS [Bv94], Trans [MMA90], Transis [ADKM92b, ADKM92a], Total [MAMSA94], and Totem [AMMS + 95, MMSA + 96]. In general, the weaker the ordering requirements the more efficient the protocol. The ISIS system is a clear example where this is the case. <p> However, due to the FIFO assumption about the communication links, if a process atomically (or for that matter reliably or causally) broadcasts a message m 1 before message m 2 then all processes receive m 1 before m 2 . Atomic broadcast has been implemented in Amoeba <ref> [KT91] </ref>, ISIS [Bv94], Transis [ADKM92b, ADKM92a], Total [MAMSA94] and Totem [AMMS + 95, MMSA + 96]. 3 Reliable Broadcast-Based Protocol Reliable broadcast is a simple communication primitive that is relatively straightforward to implement when compared to ordered broadcast primitives such as causal or atomic broadcast.
Reference: [Mae85] <author> M. Maekawa. </author> <title> A p n algorithm for mutual exclusion in decentralized systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(2) </volume> <pages> 145-159, </pages> <month> May </month> <year> 1985. </year> <month> 17 </month>
Reference-contexts: There are numerous replica control protocols such as the read-one write-all protocol, the majority quorum protocol [Gif79], as well as the variants of the majority quorum protocol <ref> [Mae85, AE91] </ref>. All these protocols have been studied in the context of a point-to-point communication environment. In this paper, we start by adapting the read-one write-all protocol for broadcast environments. In fact, many of the broadcast primitives incorporate in their implementation various techniques for fault-tolerance including the majority quorum approach.
Reference: [MAMSA94] <author> L. E. Moser, Y. Amir, P. M. Melliar-Smith, and D. A. Agarwal. </author> <title> Extended virtual syn-chrony. </title> <booktitle> In Proceedings of the 14th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 56-65, </pages> <year> 1994. </year>
Reference-contexts: Various implementations of these protocols have been proposed for different underlying hardware, including Amoeba [KT91], ISIS [Bv94], Trans [MMA90], Transis [ADKM92b, ADKM92a], Total <ref> [MAMSA94] </ref>, and Totem [AMMS + 95, MMSA + 96]. In general, the weaker the ordering requirements the more efficient the protocol. The ISIS system is a clear example where this is the case. <p> Atomic broadcast has been implemented in Amoeba [KT91], ISIS [Bv94], Transis [ADKM92b, ADKM92a], Total <ref> [MAMSA94] </ref> and Totem [AMMS + 95, MMSA + 96]. 3 Reliable Broadcast-Based Protocol Reliable broadcast is a simple communication primitive that is relatively straightforward to implement when compared to ordered broadcast primitives such as causal or atomic broadcast.
Reference: [MMA90] <author> P. M. Melliar-Smith, L. Moser, and V. Agrawala. </author> <title> Broadcast Protocols for Distributed Systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 17-25, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Various implementations of these protocols have been proposed for different underlying hardware, including Amoeba [KT91], ISIS [Bv94], Trans <ref> [MMA90] </ref>, Transis [ADKM92b, ADKM92a], Total [MAMSA94], and Totem [AMMS + 95, MMSA + 96]. In general, the weaker the ordering requirements the more efficient the protocol. The ISIS system is a clear example where this is the case. <p> Causal broadcast protocols have been implemented in several systems such as ISIS [Bv94], Trans <ref> [MMA90] </ref>, and Transis [ADKM92b].
Reference: [MMSA + 96] <author> L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal, R. K. Budhia, and C. A. Lingley-Papadopoulos. Totem: </author> <title> A Fault-Tolerant Multicast Group Communication System. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 54-63, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Various implementations of these protocols have been proposed for different underlying hardware, including Amoeba [KT91], ISIS [Bv94], Trans [MMA90], Transis [ADKM92b, ADKM92a], Total [MAMSA94], and Totem <ref> [AMMS + 95, MMSA + 96] </ref>. In general, the weaker the ordering requirements the more efficient the protocol. The ISIS system is a clear example where this is the case. <p> Atomic broadcast has been implemented in Amoeba [KT91], ISIS [Bv94], Transis [ADKM92b, ADKM92a], Total [MAMSA94] and Totem <ref> [AMMS + 95, MMSA + 96] </ref>. 3 Reliable Broadcast-Based Protocol Reliable broadcast is a simple communication primitive that is relatively straightforward to implement when compared to ordered broadcast primitives such as causal or atomic broadcast.
Reference: [Nei96] <author> G. Neiger. </author> <title> A New Look at Membership Services. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1996. </year>
Reference-contexts: 1 Introduction Recently there has been increasing interest in the development of broadcast protocols for disseminating information in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, ACBMT96] </ref>. Several broadcast protocols with varying properties have been proposed and implemented in different distributed systems. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system.
Reference: [Ree78] <author> D. P. Reed. </author> <title> Naming and Synchronization in a Decentralized Computer System. </title> <type> Technical Report MIT-LCS-TR-205, </type> <institution> Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> September </month> <year> 1978. </year>
Reference-contexts: A commonly accepted correctness criterion in databases is the serializable execution of transactions [EGLT76]. Serializable executions are guaranteed by employing a concurrency control mechanism, e.g., locking [EGLT76, SK80, AE90], timestamp ordering <ref> [Ree78] </ref>, or optimistic concurrency control [KR81] protocols. Since strict two-phase locking 1 is widely used, we assume in this paper that concurrency control is locally enforced by strict two-phase locking at all database sites.
Reference: [Ric93] <author> A. Ricciardi. </author> <title> The Group Membership Problem in Asynchronous Systems. </title> <type> PhD thesis, </type> <institution> Depratment of Computer Science, Cornell University, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Recently there has been increasing interest in the development of broadcast protocols for disseminating information in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, ACBMT96] </ref>. Several broadcast protocols with varying properties have been proposed and implemented in different distributed systems. <p> In this paper, we investigate the potential advantages of broadcast communication on synchronization protocols for transaction management in replicated databases. Numerous proposals have been made to specify broadcast communication models in distributed systems <ref> [Ric93, Bir85, Bv94, HT93, AMMS + 95, DM96, Nei96, CHTCB96, ACBMT96] </ref>. Each of these broadcast primitives has subtle differences in its specifications as well as the assumptions it makes regarding the underlying system.
Reference: [RTKA96] <author> M. Raynal, G. Thia-Kime, and M Ahamad. </author> <title> From Serializable to causal Transactions for Collaborative Applications. </title> <type> Technical report, </type> <institution> IRISA, </institution> <year> 1996. </year> <note> Publication Interne No. 983. </note>
Reference-contexts: In particular, some of our protocols rely 15 on the underlying layer providing the mechanism for detecting the causality relationships among broadcast messages. Unlike our approach which remains in the confines of serializability, there have been proposals to exploit broadcast primitives while relaxing the correctness criterion <ref> [RTKA96] </ref>.
Reference: [SAE97] <author> I. Stanoi, D. Agrawal, and A. El Abbadi. </author> <title> Using Broadcast Primitives in Replicated Databases. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Califor-nia at Santa Barbara, </institution> <year> 1997. </year>
Reference-contexts: Read-only transactions do not broadcast their commit decisions, and are not aborted in this protocol. A detailed proof of correctness requires a case analysis of the different conflict cases between a pair of transactions <ref> [SAE97] </ref>. The causal broadcast protocol with implicit positive acknowledgment presented above is most appropriate for situations where all sites broadcast messages fairly frequently; otherwise the wait for "implicit" acknowledgments can become a drawback resulting in substantial delays for transaction commitment.
Reference: [SK80] <author> A. Silberschatz and Z. Kedem. </author> <title> Consistency in Hierarchical Databases Systems. </title> <journal> Journal of the ACM, </journal> <volume> 27(1) </volume> <pages> 72-80, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: A commonly accepted correctness criterion in databases is the serializable execution of transactions [EGLT76]. Serializable executions are guaranteed by employing a concurrency control mechanism, e.g., locking <ref> [EGLT76, SK80, AE90] </ref>, timestamp ordering [Ree78], or optimistic concurrency control [KR81] protocols. Since strict two-phase locking 1 is widely used, we assume in this paper that concurrency control is locally enforced by strict two-phase locking at all database sites.
Reference: [Ske82] <author> D. Skeen. </author> <title> Non-blocking commit protocols. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 133-147, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: The transaction issuing the write operation remains blocked until acknowledgments have been received from all sites. After all operations are executed, the transaction commits using a commit protocol, e.g., two-phase commit. We consider a decentralized commit protocol since it is more appropriate for a broadcast-based system <ref> [Ske82] </ref>. This requires the initiating site to send out commit requests to all sites. A site responds to a commit request by sending either positive or negative responses to all sites. If all responses are positive, the transaction commits, otherwise it is aborted. <p> Since the votes of all participants are broadcast to every participant, the commit protocol is the decentralized two-phase commit protocol <ref> [Ske82] </ref>. The commit decision of read-only transactions is not broadcast and because read operations are not aborted due to read-write conflicts, read-only transactions are never aborted. The above protocol is simple and is in fact a fairly straightforward extension of the traditional read-one write-all protocol that uses point-to-point communication primitives.
Reference: [SR96] <author> A. Schiper and M. Raynal. </author> <title> From Group Communication to Transactions in Distributed Systems. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 84-87, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Recently, there has been increasing interest in the management of replicated databases, where the unit of activity is a transaction consisting of multiple operations that need to be executed atomically as a unit <ref> [SR96] </ref>. Two proposals that do consider the semantics of transactions are [BBD94, AAES97]. In both cases, the replication management protocols require, in addition to the broadcast primitives, additional techniques to ensure correct transaction execution.
Reference: [SS82] <author> R. Schlichting and F. B. Schneider. </author> <title> Fail-Stop Processors: An Approach to Designing Fault-Tolerant Computing Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1982. </year> <month> 18 </month>
Reference: [SS94] <author> A. Schiper and A. Sandoz. </author> <title> Primary Partition "Virtually-synchronous Communica--tion" harder than Consensus. </title> <booktitle> In Proceedings of the 8th International Workshop on Distributed Algorithms, WDAG'94, Lecture Notes in Computer Science, </booktitle> <pages> pages 39-52. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1994. </year> <month> 19 </month>
Reference-contexts: In particular, the communication layer maintains a view of the current system configuration. As site failures and recovery occur, the view is dynamically restructured using the notion of majority quorums. As long as the view has majority membership, the system remains operational <ref> [Bv94, SS94] </ref>. Given a view of the current configuration, we use the notion of read-one write-all in that context. This avoids duplication of efforts to provide fault tolerance at multiple levels. In the point-to-point communication model, transactions in the read-one write-all protocol execute as follows.
References-found: 35

