URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR356.ps.Z
Refering-URL: http://www.cs.indiana.edu/ftp/techreports/index.html
Root-URL: http://www.cs.indiana.edu
Author: R. Kent Dybvig 
Note: Copyright c 1992  
Abstract: Writing Hygienic Macros in Scheme with Syntax-Case R. Kent Dybvig dyb@cs.indiana.edu Indiana University Computer Science Department Technical Report #356 June 1992 (Revised July 3, 1992) 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William Clinger and Jonathan Rees. </author> <title> Macros that work. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 155-162, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Macros defined using these facilities are automatically hygienic [6]. If a macro transformer inserts a binding for an identifier (variable or keyword), the new binding will not capture other identifiers (even of the same name) introduced elsewhere. Macros defined using these facilities are also referentially transparent <ref> [1] </ref>. If a macro transformer inserts a free reference to an identifier, the reference refers to the binding that was visible where the transformer was specified, regardless of any local bindings that may surround the use of the macro.
Reference: [2] <editor> William Clinger, Jonathan A. Rees, et al. </editor> <title> The revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <type> 4(3), </type> <year> 1991. </year>
Reference-contexts: If you do not have ftp access, contact me and I will get the implementation to you somehow. The implementation is based on an earlier implementation by Bob and myself of the system described in an appendix to the "Revised 4 Report on the Algorithmic Language Scheme" <ref> [2] </ref>. The present implementation, however, is more robust and significantly more efficient. I would like to thank Carl Bruggeman for his detailed and thoughtful comments on drafts of this report, and also for the use of his "Scheme TeXer," with which the examples contained within this report were formatted. <p> I would like to thank David Eby, George Springer, and Dan Friedman as well for their helpful comments. 2 Introduction This document describes a hygienic macro system for Scheme that is similar to the one documented in an appendix to the "Revised 4 Report on the Algorithmic Language Scheme" <ref> [2] </ref>, with several important differences. Most importantly, there is no practical distinction in this system between "high level" and "low level" macros.
Reference: [3] <author> R. Kent Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: In order to fully understand the examples in this document, it is necessary to have a good understanding of Scheme, and helpful but not necessary to have studied or used extend-syntax <ref> [5, 3] </ref> or the high-level system documented in the Revised 4 Report. This document is intended to instruct potential macro-system users how to use the system; there is no attempt at justification or comparison with other systems. <p> template ) : : : ) (with-syntax (((dummy : : : ) (generate-temporaries (syntax (keyword : : : ))))) (syntax (lambda (x ) (syntax-case x (k : : : ) ((dummy . pattern ) (syntax template )) : : : )))))))) Many versions of Scheme provide a version of extend-syntax <ref> [5, 3] </ref>, which is one of the forerunners to the system described in this document. <p> Another common use for implicit identifiers is in the definition of structure facilities. The following definition for define-structure is an adaptation of one that appeared in The Scheme Programming Language <ref> [3] </ref>. This system represents structures as vectors of length n + 1, where n is the number of fields, the first element is the name of the structure, and the remaining elements contain the fields' values.
Reference: [4] <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Syntactic abstraction in scheme. </title> <type> Technical Report 355, </type> <institution> Indiana Computer Science Department, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: This report is intended not to justify the macro system, but to help potential users learn how to write macros using it. A companion report, "Syntactic Abstraction in Scheme" <ref> [4] </ref>, which was mostly written before Bob's death, does attempt to justify the macro system and to place it within the context of other work. The companion report also contains more detail on the algorithms used by our implementation of the macro system. <p> This document is intended to instruct potential macro-system users how to use the system; there is no attempt at justification or comparison with other systems. A more formal treatment of this macro system and its implementation, along with background information on this and other macro systems is given in <ref> [4] </ref>. 3 Syntactic forms and primitives New macros are defined to extend the set of syntactic forms available within a program or subprogram. All extended syntactic forms, also referred to as "macro calls," take the form: (keyword . subform ) where keyword is an identifier that names a macro.
Reference: [5] <author> Eugene Kohlbecker. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> PhD thesis, </type> <institution> Indiana University, Bloomington, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: In order to fully understand the examples in this document, it is necessary to have a good understanding of Scheme, and helpful but not necessary to have studied or used extend-syntax <ref> [5, 3] </ref> or the high-level system documented in the Revised 4 Report. This document is intended to instruct potential macro-system users how to use the system; there is no attempt at justification or comparison with other systems. <p> template ) : : : ) (with-syntax (((dummy : : : ) (generate-temporaries (syntax (keyword : : : ))))) (syntax (lambda (x ) (syntax-case x (k : : : ) ((dummy . pattern ) (syntax template )) : : : )))))))) Many versions of Scheme provide a version of extend-syntax <ref> [5, 3] </ref>, which is one of the forerunners to the system described in this document.
Reference: [6] <author> Eugene Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and Bruce Duba. </author> <title> Hygienic macro expansion. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-161, </pages> <year> 1986. </year> <month> 30 </month>
Reference-contexts: The mechanisms for establishing new keyword bindings and for writing macros are described in the remainder of this section. Extensive examples demonstrating the use of each of the features described in this section are given in the following section. Macros defined using these facilities are automatically hygienic <ref> [6] </ref>. If a macro transformer inserts a binding for an identifier (variable or keyword), the new binding will not capture other identifiers (even of the same name) introduced elsewhere. Macros defined using these facilities are also referentially transparent [1].
References-found: 6

