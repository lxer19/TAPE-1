URL: ftp://ftp.cs.vu.nl/pub/papers/theory/IR-333.ps.Z
Refering-URL: http://www.cs.vu.nl/vakgroepen/ti/ftpindex.html
Root-URL: 
Title: Comparing Combinatory Reduction Systems and Higher-Order Rewrite Systems  
Author: Vincent van Oostrom and Femke van Raamsdonk flfl 
Keyword: Phrases: higher-order rewriting, -calculus, developments, confluence  
Web: F1.1, F4.1, F4.2  
Note: AMS Subject Classification (1991): 68Q42 CR Subject Classification (1991):  Note: The research of the second author is supported by NWO/SION project 612-316-606  
Address: CWI, P.O. Box 4079, 1009 AB Amsterdam  
Affiliation: Department of Mathematics and Computer Science, Vrije Universiteit, De Boelelaan 1081a, 1081 HV Amsterdam flfl  
Abstract: In this paper two formats of higher-order rewriting are compared: Combinatory Reduction Systems introduced by Klop [Klo80] and Higher-order Rewrite Systems defined by Nipkow [Nipa]. Although it always has been obvious that both formats are closely related to each other, up to now the exact relationship between them has not been clear. This was an unsatisfying situation since it meant that proofs for much related frameworks were given twice. We present two translations, one from Combinatory Reduction Systems into Higher-Order Rewrite Systems and one vice versa, based on a detailed comparison of both formats. Since the translations are very `neat' in the sense that the rewrite relation is preserved and (almost) reflected, we can conclude that as far as rewrite theory is concerned, Combinatory Reduction Systems and Higher-Order Rewrite Systems are equivalent, the only difference being that Combinatory Reduction Systems employ a more `lazy' evaluation strategy. Moreover, due to this result it is the case that some syntactic properties derived for the one class also hold for the other. 
Abstract-found: 1
Intro-found: 1
Reference: [ACCL90] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Proceedings of the ACM Conference on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <year> 1990. </year>
Reference-contexts: As noted above the translation the other way around is not that nice. The HRS is simulated by a more refined CRS; `giant' HRS-steps are simulated by many `small' CRS-steps. This is analogous to the way in which -calculus is simulated by the -calculus defined in <ref> [ACCL90] </ref>. Of course, not every step in the refined system is reflected in the original HRS, but still we can say something: every rewrite sequence between encodings of HRS-terms is reflected in the original HRS.
Reference: [Acz78] <author> P. Aczel. </author> <title> A general Church-Rosser theorem. </title> <type> Technical report, </type> <institution> University of Manch-ester, </institution> <year> 1978. </year>
Reference: [Bar84] <author> H.P. Barendregt. </author> <title> The Lambda Calculus, its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland Publishing Company, </publisher> <address> revised edition, </address> <year> 1984. </year> <note> (Second printing 1985). </note>
Reference-contexts: 1. Introduction 2 Sec. I.3.5] (cf. also indexed -calculus of <ref> [Bar84, x11.1.3] </ref>), i.e. the language of developments (or let-expressions). Once we have made the meta-language of CRSs explicit, we can compare both formats by comparing their respective meta-languages. Comparing is done by giving encodings of one system into the other and vice versa.
Reference: [BG93] <editor> M. Bezem and J.F. Groote, editors. </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, volume 664 of Lecture Notes in Computer Science, </booktitle> <address> Utrecht, The Netherlands, March 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference: [BTG89] <author> V. Breazu-Tannen and J. Gallier. </author> <title> Polymorphic rewriting conserves algebraic strong normalization and confluence. </title> <booktitle> In Proceedings of the 16th International Colloquium on Automata, Languages and Programming, volume 372 of Lecture Notes in Computer Science, </booktitle> <pages> pages 137-150, </pages> <year> 1989. </year>
Reference-contexts: On the other hand, the method employed here seems to be quite flexible, since it makes use only of completeness of (typed) fi. For example, the confluence result of <ref> [BTG89] </ref> should be an easy consequence. Corollary 4.22 Orthogonal HRSs are confluent. Proof. Suppose we have two coinitial rewrites, s H t 1 and s H t 2 , we can lift them by Theorem 4.10 to rewrites hsi Cfi ht 1 i and hsi Cfi ht 2 i.
Reference: [Kah92] <author> S. Kahrs. </author> <title> Context rewriting. </title> <editor> In M. Rusinowitch and J.L. Remy, editors, </editor> <booktitle> Proceedings of the Third International Workshop on Conditional and Typed Rewriting Systems, </booktitle> <pages> pages 21-35, </pages> <year> 1992. </year> <title> A. Induction Proofs of the CRS to HRS translation 22 </title>
Reference-contexts: In this case, substitution is well-defined since in t -calculus all fi-rewrite sequences eventually terminate. 2.3.1 CRS Rewrite Steps In order to define assignments for CRSs we first introduce a new concept: the so-called substitutes (cf. <ref> [Kah92] </ref>).
Reference: [Kha90] <author> Z.O. Khasidashvili. </author> <title> Expression reduction systems. In Proceedings of I. </title> <journal> Vekua Institute of Applied Mathematics, </journal> <volume> volume 36, </volume> <pages> pages 200-220, </pages> <address> Tbilisi, </address> <year> 1990. </year>
Reference-contexts: For the moment being, we have only considered use of our translation for confluence results. Our comparison only considers CRSs versus HRSs. There are some more alternatives such as Khasidashvili's Expression Reduction Systems <ref> [Kha90] </ref> and Takahashi's Conditional Lambda Calculi [Tak]. We claim that the main differences between these and CRSs (or HRSs) are of a syntactic nature. However, an exact comparison is left to future work. The paper is organised as follows. <p> The -calculus can be viewed as a `calculus of (de)composing', so seems to be basic to any meta-language. If we look at other higher order rewrite formalisms, such as the Expression Reduction Systems of Khasidashvili <ref> [Kha90] </ref> and the Conditional Lambda Calculi of Takahashi [Tak], this claim seems to be supported. The precise interrelation is left to future work. We do note however that the similarities between these systems are obfuscated by the surprisingly large syntactical differences.
Reference: [Klo80] <author> J.W. Klop. </author> <title> Combinatory Reduction Systems. </title> <publisher> Mathematical Centre Tracts Nr. 127. CWI, </publisher> <address> Amsterdam, </address> <year> 1980. </year> <type> PhD Thesis. </type>
Reference-contexts: The encoding of CRSs into HRSs is straightforward because -calculus can be encoded into t -calculus. The encoding of HRSs into CRSs is somewhat more involved; t -calculus cannot be encoded directly into -calculus. For example, the latter does enjoy the disjointness property (rewriting preserves disjointness, cf. <ref> [Klo80, pg. 38] </ref>), while the former doesn't. In general, in t -calculus rewrite sequences can be longer than in -calculus. Our solution is to add an explicit fi-rule (and the corresponding symbols) to the encoding of an HRS. <p> Since their introduction both formats have been subject to some change and we will use their most recent presentations, viz. [KOR93] for CRSs and [Nipb] for HRSs. The most notable change is the use of the functional format for CRSs instead of the applicative one of <ref> [Klo80] </ref>. The reason for choosing the functional format is that it is closer to the usual notation for term 2. Comparing the Syntax 3 rewriting systems. <p> Combining this with the fact that orthogonality is preserved, we obtain a confluence proof for orthogonal CRSs via confluence of their associated HRS. For the definition of orthogonality of CRSs and HRSs we refer the reader to <ref> [Klo80] </ref> and [Nipb]. Corollary 3.12 Orthogonal CRSs are confluent. Proof. Let s C t 1 and s C t 2 be rewrites in an orthogonal CRS C. <p> The proof follows the strategy employed for proving j= WCR + in <ref> [Klo80, pp. 144-148] </ref>. However, some difficulties arise. First, because of the possible non-left-linearity of the rules. Second, because simply typed -calculus doesn't satisfy the disjointness property in contrast to underlined -calculus. The main property to be proved is that fi-reductions to normal form do not interfere with rewrite steps. <p> The idea of freezing is the one of [Lan93], postponing both duplication of the metavariables and substitution into the metavariables. It is more extensive than the one in <ref> [Klo80] </ref>, where only substitution is postponed. Both postponed actions can be performed by fi-reduction: Proposition 4.16 a s ! Cfi t is a development. b Let s be equal to s after removal of underlinings. If s ! Rfi t, then s ! Cfi t. <p> Proof. Suppose we have two coinitial rewrites, s H t 1 and s H t 2 , we can lift them by Theorem 4.10 to rewrites hsi Cfi ht 1 i and hsi Cfi ht 2 i. Because C is an orthogonal CRS we can find by <ref> [Klo80, Thm. II.3.11] </ref> (or [Raa93]), convergent rewrites ht 1 i C t 0 and ht 2 i C t 0 , for some t 0 .
Reference: [KOR93] <author> J.W. Klop, V. van Oostrom, and F. van Raamsdonk. </author> <title> Combinatory reduction systems, introduction and survey. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Notation. We adhere mostly to the notations introduced by Klop for CRSs, and Nipkow for HRSs. Since their introduction both formats have been subject to some change and we will use their most recent presentations, viz. <ref> [KOR93] </ref> for CRSs and [Nipb] for HRSs. The most notable change is the use of the functional format for CRSs instead of the applicative one of [Klo80]. The reason for choosing the functional format is that it is closer to the usual notation for term 2. <p> These problems can be avoided by renaming bound variables. In the following we will assume that this is done whenever necessary. Notation. In this paper we stick to the definition of <ref> [KOR93] </ref> of substitution as a one-stage process. If we would use -calculus as a meta-language, we would obtain substitution as a 2. Comparing the Syntax 8 two-stage process: first replacing the metavariables by the terms assigned to them, and then explicitly developing the fi-redexes.
Reference: [Lan93] <author> C. Laneve. </author> <title> Optimality and Concurrency in Interaction Systems. </title> <type> PhD thesis, </type> <institution> diparti-mento di informatica universita di pisa, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: The underlining of R is the rule R = -([x]Z (x); [x]Z 0 (x)) ! @([z; z 0 ]@(z; -[x]@(z; x)); [x]Z (x); [x]Z 0 (x)) if Z Z 0 . The idea of freezing is the one of <ref> [Lan93] </ref>, postponing both duplication of the metavariables and substitution into the metavariables. It is more extensive than the one in [Klo80], where only substitution is postponed.
Reference: [LIC91] <author> Amsterdam, </author> <booktitle> The Netherlands. Proceedings of the sixth annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> Los Alamitos, July 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Mil] <author> D. Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <booktitle> In [Sie91]. </booktitle>
Reference-contexts: Comparing the Syntax 7 the pattern-condition. By that condition only names (simple objects), not values (compound objects) can occur as arguments of free variables. Both in the case of CRSs and of HRSs it establishes decidability of unification of patterns, and computability of the rewrite relation, a result of <ref> [Mil] </ref>.
Reference: [Nipa] <author> T. Nipkow. </author> <title> Higher-order critical pairs. </title> <booktitle> In [LIC91]. </booktitle>
Reference: [Nipb] <author> T. Nipkow. </author> <title> Orthogonal Higher-Order Rewrite Systems are Confluent. </title> <booktitle> In [BG93]. </booktitle>
Reference-contexts: Notation. We adhere mostly to the notations introduced by Klop for CRSs, and Nipkow for HRSs. Since their introduction both formats have been subject to some change and we will use their most recent presentations, viz. [KOR93] for CRSs and <ref> [Nipb] </ref> for HRSs. The most notable change is the use of the functional format for CRSs instead of the applicative one of [Klo80]. The reason for choosing the functional format is that it is closer to the usual notation for term 2. Comparing the Syntax 3 rewriting systems. <p> Combining this with the fact that orthogonality is preserved, we obtain a confluence proof for orthogonal CRSs via confluence of their associated HRS. For the definition of orthogonality of CRSs and HRSs we refer the reader to [Klo80] and <ref> [Nipb] </ref>. Corollary 3.12 Orthogonal CRSs are confluent. Proof. Let s C t 1 and s C t 2 be rewrites in an orthogonal CRS C. <p> By Theorem 3.8, we can lift these to rewrites hsi H ht 1 i and hti H ht 2 i in the HRS H associated to C. Because H is easily seen to be orthogonal, we conclude from <ref> [Nipb, Cor. 4.9] </ref> that it is confluent, hence there exist rewrites ht 1 i H r 0 and ht 2 i H r 0 , for some r 0 . These sequences can be projected again to 4.
Reference: [NM88] <author> G. Nadathur and D. Miller. </author> <title> An overview of Prolog. </title> <editor> In R.A. Kowalski and K.A. Bowen, editors, </editor> <booktitle> Proc. 5th Int. Logic Programming Conference, </booktitle> <pages> pages 810-827. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference: [Oos93] <author> V. van Oostrom. </author> <title> Confluence by decreasing diagrams. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Translating a HRS into a CRS plus explicit fi 19 Proposition 4.19 fi commutes with R + fi. That is R + fi fi fi Proof. By termination of R + fi (Proposition 4.17) and Newman's Lemma (see e.g. <ref> [Oos93] </ref>) it suffices to consider only local divergences in proving commutativity. The case of a local divergence of fi-steps is covered by confluence of fi. The other case follows by considering the relative positions of the fi- and R-redex.
Reference: [Pau90] <author> L.C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-385. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference: [Raa93] <editor> F. van Raamsdonk. Confluence and superdevelopments. In C. Kirchner, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Rewrite Techniques and Applications, </booktitle> <year> 1993. </year>
Reference-contexts: This redex is `created downwards', so for this process to end, we cannot rely on termination of developments or even superdevelopments (cf. <ref> [Raa93] </ref>), but really need strong normalisation of simply typed -calculus. On the other hand, the corresponding CRS rule F ([y]Z (y)) ! Z ([x]x) and assignment : Z 7! (u):@(u; K), act more lazily: F ([y]@(y; K)) = (F ([y]Z (y))) 3. <p> Because C is an orthogonal CRS we can find by [Klo80, Thm. II.3.11] (or <ref> [Raa93] </ref>), convergent rewrites ht 1 i C t 0 and ht 2 i C t 0 , for some t 0 .
Reference: [Sie91] <editor> J. Siekmann, editor. </editor> <booktitle> Extensions of Logic Programming, volume 475 of Lecture Notes in Artificial Intelligence. Tubingen, </booktitle> <address> FRG, </address> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1991. </year>
Reference: [Tak] <author> M. Takahashi. </author> <title> -calculi with conditional rules. </title> <booktitle> In [BG93]. </booktitle>
Reference-contexts: For the moment being, we have only considered use of our translation for confluence results. Our comparison only considers CRSs versus HRSs. There are some more alternatives such as Khasidashvili's Expression Reduction Systems [Kha90] and Takahashi's Conditional Lambda Calculi <ref> [Tak] </ref>. We claim that the main differences between these and CRSs (or HRSs) are of a syntactic nature. However, an exact comparison is left to future work. The paper is organised as follows. <p> The -calculus can be viewed as a `calculus of (de)composing', so seems to be basic to any meta-language. If we look at other higher order rewrite formalisms, such as the Expression Reduction Systems of Khasidashvili [Kha90] and the Conditional Lambda Calculi of Takahashi <ref> [Tak] </ref>, this claim seems to be supported. The precise interrelation is left to future work. We do note however that the similarities between these systems are obfuscated by the surprisingly large syntactical differences.

References-found: 20

