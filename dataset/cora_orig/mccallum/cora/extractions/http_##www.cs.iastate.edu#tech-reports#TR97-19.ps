URL: http://www.cs.iastate.edu/tech-reports/TR97-19.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Enhancing the Pre- and Postcondition Technique for More Expressive Specifications  
Author: Gary T. Leavens and Albert L. Baker Gary T. Leavens and Albert L. Baker 
Keyword: formal methods, liberal specification, redundancy, debugging, history constraint. 1997 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications languages, human factors; D.2.m [Software Engineering] Miscellaneous reusable software; F.3.1 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs Pre- and post-conditions, specification techniques.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: TR #97-19 September 1997  Submitted for publication Copyright c 1997 by  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Alex Borgida, John Mylopoulos, and Raymond Reiter. </author> `... <title> and nothing else changes': The frame problem in procedure specification. </title> <booktitle> In Proceedings Fifteenth International Conference on Software Engineering, </booktitle> <address> Baltimore, </address> <month> May </month> <year> 1993. </year> <note> Preliminary version obtained from the authors. </note>
Reference-contexts: Extracting common parts of preconditions like this also highlights them for the reader. (We attach no special semantics to such common preconditions, unlike Poetzsch-Heffter [29, pages 96-97].) 5 Framing A frame axiom in a procedure specification says that "nothing else changes" <ref> [1] </ref>. VDM and Z both have features to permit the specification of frame axioms (write permissions in VDM, and in Z). <p> This can be used to collect common parts of the postconditions of several operations in one place. This idea is advocated by Borgida et al. as an approach to dealing with frame axioms <ref> [1] </ref>. It is also useful in specifying history constraints for types that are intended as supertypes of weak behavioral subtypes [4] [22, Section 7.8]. 8 Conclusions In this paper we have described several enhancements to the pre- and postcondition technique for specifications.
Reference: [2] <author> Patrice Chalin. </author> <title> On the Language Design and Semantic Foundation of LCL, a Larch/C Interface Specification Language. </title> <type> PhD thesis, </type> <institution> Con-cordia University, 1455 de Maisonneuve Blvd. West, </institution> <address> Montreal, Quebec, Canada, </address> <month> October </month> <year> 1995. </year> <note> Available as CU/DCS TR 95-12, from the URL ftp://ftp.cs.concordia.ca/pub/chalin/tr.ps.Z. </note>
Reference-contexts: Since these actions are not considered modifications, they are not covered by the modifies clause. However, without additional support from the specification language, specifiers would have to make assertions about which objects remain allocated and assigned in each postcon-dition <ref> [2] </ref>, which would be inconvenient and verbose. To avoid having users write such assertions about what is not trashed in postconditions, Chalin argued for a second part to the frame axiom in Larch interface specifications. In Larch/C ++ this is called the trashes clause.
Reference: [3] <author> Patrice Chalin, Peter Grogono, and T. Radhakr-ishnan. </author> <title> Identification of and solutions to shortcomings of LCL, a Larch/C interface specification language. </title> <editor> In Marie-Claude Gaudel and James Woodcock, editors, </editor> <booktitle> FME '96: Industrial Benefit and Advances in Formal Methods, volume 1051 of Lecture Notes in Computer Science, </booktitle> <pages> pages 385-404, </pages> <address> New York, N.Y., March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: If this is not done, then logical problems may occur <ref> [18, 3] </ref>.
Reference: [4] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <pages> pages 258-267. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: Larch/C ++ manual's specification of a class Person [22, Section 7.1.1], includes the following history constraint, which expresses the inexorable arrow of time. //@ constraint age^ &lt;= age'; An innovation in Larch/C ++ is that one can limit a history constraint so that it only applies to various named operations <ref> [4] </ref> [22, Section 7.4]. This can be used to collect common parts of the postconditions of several operations in one place. This idea is advocated by Borgida et al. as an approach to dealing with frame axioms [1]. <p> This idea is advocated by Borgida et al. as an approach to dealing with frame axioms [1]. It is also useful in specifying history constraints for types that are intended as supertypes of weak behavioral subtypes <ref> [4] </ref> [22, Section 7.8]. 8 Conclusions In this paper we have described several enhancements to the pre- and postcondition technique for specifications. These enhancements contribute to the expressiveness of Larch/C ++ , and could be adapted to other specification languages.
Reference: [5] <author> E. W. Dijkstra, </author> <title> editor. Formal Development of Programs and Proofs. </title> <booktitle> University of Texas at Austin Year of Programming series. </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1990. </year>
Reference-contexts: We believe that our enhancements apply equally well to other specification languages, even those outside the Larch family. Our emphasis on expressiveness in specifications can be seen as following the emphasis on expressive notation in the "calculational school" of Dijkstra, Gries, and others (see, e.g., <ref> [5, 7, 10, 11] </ref>). These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and postcondition technique itself.
Reference: [6] <author> Edsger W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1976. </year>
Reference-contexts: In addition, various enhancements to specifications can increase their quality. This is particularly true of the redundancy enhancements described in Section 6, which can be used to check that the specification says what is intended [33, 32, 34]. 3 Liberal Specifications Most specification languages have a total correctness <ref> [6] </ref> semantics. That is, a specification such as satisfied. (In Figure 1, the first line gives the C++ function's interface. It says that inc takes an integer argument passed by reference, returns nothing, and may not throw any exceptions. The behavior of inc is specified in the remaining lines. <p> In Larch/C ++ , one can combine total and partial correctness specifications for the same procedure, and thus more precisely specify both when a call must terminate and what must be true on termination in any case. The semantics of such combinations uses the ideas of Dijkstra and others <ref> [6, 27, 16] </ref>. void abort (); //@ behavior - //@ ensures liberally false; //@ - Another way out of the difficulty with allocation routines would be to change the meaning of total correctness.
Reference: [7] <author> Edsger W. Dijkstra and Carel S. Scholten. </author> <title> Predicate Calculus and program semantics. </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1990. </year>
Reference-contexts: We believe that our enhancements apply equally well to other specification languages, even those outside the Larch family. Our emphasis on expressiveness in specifications can be seen as following the emphasis on expressive notation in the "calculational school" of Dijkstra, Gries, and others (see, e.g., <ref> [5, 7, 10, 11] </ref>). These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and postcondition technique itself.
Reference: [8] <author> L. M. G. Feijs and H. B. M. Jonkers. </author> <title> Formal Specification and Design, </title> <booktitle> volume 35 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cam-bridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference-contexts: Keywords: formal methods, liberal specification, redundancy, debugging, history constraint. 1 Related Work The pre- and postcondition technique was described by Hoare in his classic article [17]. This technique forms the basis of most contemporary specification languages for sequential systems <ref> [19, 15, 30, 8, 14, 28] </ref>. We take as our starting point an excellent article by Jonkers [20], which says (page 428): "Nowadays the pre- and postcondition technique is considered a standard technique in software development as it is being taught in almost every basic software engineering course. <p> The fact that this is not really the case is camouflaged by the sloppy and informal way pre- and postconditions are gener ally used in practice." Besides reconstructing the pre- and postcondition technique, Jonkers describes several enhancements. These enhancements are found in the specification language COLD-1 <ref> [8] </ref>. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM [19], Z [15, 30], and languages in the Larch family [14]: * Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified.
Reference: [9] <author> Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Debugging Larch Shared Language specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(6) </volume> <pages> 1044-1057, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The Larch family has emphasized the benefit of checking how well a specification captures the specifier's intuition by comparing the redundant parts against the main parts; such checking is called "debugging" a specification <ref> [9] </ref>. For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories [14, Chapter 7].
Reference: [10] <author> David Gries. </author> <title> Teaching calculation and discrimination: A more effective curriculum. </title> <journal> Communications of the ACM, </journal> <volume> 34(3) </volume> <pages> 44-55, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: We believe that our enhancements apply equally well to other specification languages, even those outside the Larch family. Our emphasis on expressiveness in specifications can be seen as following the emphasis on expressive notation in the "calculational school" of Dijkstra, Gries, and others (see, e.g., <ref> [5, 7, 10, 11] </ref>). These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and postcondition technique itself.
Reference: [11] <author> David Gries and Fred B. Schneider. </author> <title> A Logical Approach to Discrete Math. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: We believe that our enhancements apply equally well to other specification languages, even those outside the Larch family. Our emphasis on expressiveness in specifications can be seen as following the emphasis on expressive notation in the "calculational school" of Dijkstra, Gries, and others (see, e.g., <ref> [5, 7, 10, 11] </ref>). These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and postcondition technique itself.
Reference: [12] <author> David Gries and Fred B. Schneider. </author> <title> Avoiding the undefined by underspecification. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, number 1000 in Lecture Notes in Computer Science, </booktitle> <pages> pages 366-373. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: The modifies clause gives considerable notational abbreviation, because it asserts that all objects not mentioned retain their values. 5.1 Trashing In the Larch family, predicates use the logic of the Larch Shared Language, which is a logic of total functions <ref> [12, 23] </ref>. In such a logic, the pre- and post-states, which are modeled by functions, will return proper values for objects that are not allocated or that are not assigned a proper value.
Reference: [13] <author> M. Gurski and A. L. Baker. </author> <title> Testing SPECS-C++: A first step in validating distributed systems. </title> <booktitle> In Intellegent Information Management Systems, </booktitle> <pages> pages 105-108, </pages> <address> Anaheim, </address> <year> 1994. </year> <booktitle> The International Society for Mini and Microcomputers - ISMM. </booktitle>
Reference-contexts: In addition to their potential use in debugging specifications, we have found them to be a great aid in understanding specifications. We are also excited about their potential for automatic generation of test cases <ref> [13] </ref>. Besides examples, the enhancement we use most often is case analysis [37, Section 4.1.4] [35]. This is helpful in stating specifications of procedures that may throw exceptions, and also in breaking up the logic of a specification into more easily understood parts.
Reference: [14] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: Keywords: formal methods, liberal specification, redundancy, debugging, history constraint. 1 Related Work The pre- and postcondition technique was described by Hoare in his classic article [17]. This technique forms the basis of most contemporary specification languages for sequential systems <ref> [19, 15, 30, 8, 14, 28] </ref>. We take as our starting point an excellent article by Jonkers [20], which says (page 428): "Nowadays the pre- and postcondition technique is considered a standard technique in software development as it is being taught in almost every basic software engineering course. <p> These enhancements are found in the specification language COLD-1 [8]. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM [19], Z [15, 30], and languages in the Larch family <ref> [14] </ref>: * Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified. <p> This technique is useful in precisely specifying reuse contracts for procedures written for languages (or compilers) without exception handling. This idea appears in sugared form in the LCL checks clause <ref> [14, 33, 32, 34] </ref>. Partial correctness is also useful for specifying procedures for which there is no known totally correct implementation. <p> For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories <ref> [14, Chapter 7] </ref>. Improving the quality of specifications in this way can only help reuse. 6.1 Claims Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions [33, 32, 34].
Reference: [15] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: Keywords: formal methods, liberal specification, redundancy, debugging, history constraint. 1 Related Work The pre- and postcondition technique was described by Hoare in his classic article [17]. This technique forms the basis of most contemporary specification languages for sequential systems <ref> [19, 15, 30, 8, 14, 28] </ref>. We take as our starting point an excellent article by Jonkers [20], which says (page 428): "Nowadays the pre- and postcondition technique is considered a standard technique in software development as it is being taught in almost every basic software engineering course. <p> These enhancements are found in the specification language COLD-1 [8]. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM [19], Z <ref> [15, 30] </ref>, and languages in the Larch family [14]: * Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified. <p> These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and postcondition technique itself. Similarly, the specification language Z <ref> [15, 30] </ref> has a great variety of notational refinements, but these refinements are not aimed at the pre- and postcondition technique. 2 Overview In this paper we describe several further enhancements to the pre- and postcondition technique.
Reference: [16] <author> Wim H. Hesselink. </author> <title> Programs, Recursion, and Unbounded Choice, </title> <booktitle> volume 27 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: In Larch/C ++ , one can combine total and partial correctness specifications for the same procedure, and thus more precisely specify both when a call must terminate and what must be true on termination in any case. The semantics of such combinations uses the ideas of Dijkstra and others <ref> [6, 27, 16] </ref>. void abort (); //@ behavior - //@ ensures liberally false; //@ - Another way out of the difficulty with allocation routines would be to change the meaning of total correctness.
Reference: [17] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: However, we hope that such enhancements will make any specification language a more effective tool for reuse. Keywords: formal methods, liberal specification, redundancy, debugging, history constraint. 1 Related Work The pre- and postcondition technique was described by Hoare in his classic article <ref> [17] </ref>. This technique forms the basis of most contemporary specification languages for sequential systems [19, 15, 30, 8, 14, 28]. <p> In Larch/C ++ users can specify procedures using either the total or partial correctness semantics. Specifications that use just the keyword ensures have a total correctness semantics, and those that use ensures liberally have a partial correctness semantics. One use for partial correctness specifications, as in Hoare's original work <ref> [17] </ref>, is to avoid finiteness issues. For example, instead of specifying inc as in i^ &lt; INT_MAX and use ensures liberally in the postcondition.
Reference: [18] <author> C.B. Jones. </author> <title> Partial functions and logics: A warning. </title> <journal> Information Processing Letters, </journal> <volume> 54(2) </volume> <pages> 65-67, </pages> <year> 1995. </year>
Reference-contexts: If this is not done, then logical problems may occur <ref> [18, 3] </ref>.
Reference: [19] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Keywords: formal methods, liberal specification, redundancy, debugging, history constraint. 1 Related Work The pre- and postcondition technique was described by Hoare in his classic article [17]. This technique forms the basis of most contemporary specification languages for sequential systems <ref> [19, 15, 30, 8, 14, 28] </ref>. We take as our starting point an excellent article by Jonkers [20], which says (page 428): "Nowadays the pre- and postcondition technique is considered a standard technique in software development as it is being taught in almost every basic software engineering course. <p> These enhancements are found in the specification language COLD-1 [8]. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM <ref> [19] </ref>, Z [15, 30], and languages in the Larch family [14]: * Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified.
Reference: [20] <author> H. B. M. Jonkers. </author> <title> Upgrading the pre- and post-condition technique. </title> <editor> In S. Prehn and W. J. Toetenel, editors, </editor> <booktitle> VDM '91 Formal Software Development Methods 4th International Symposium of VDM Europe Noordwijkerhout, The Nether-lands, Volume 1: Conference Contributions, volume 551 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-456. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> October </month> <year> 1991. </year>
Reference-contexts: This technique forms the basis of most contemporary specification languages for sequential systems [19, 15, 30, 8, 14, 28]. We take as our starting point an excellent article by Jonkers <ref> [20] </ref>, which says (page 428): "Nowadays the pre- and postcondition technique is considered a standard technique in software development as it is being taught in almost every basic software engineering course.
Reference: [21] <author> Gary T. Leavens. </author> <title> An overview of Larch/C++: Behavioral specifications for C++ modules. </title> <editor> In Hiam Kilov and William Harvey, editors, </editor> <booktitle> Specification of Behavioral Semantics in Object-Oriented Information Modeling, chapter 8, </booktitle> <pages> pages 121-142. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1996. </year> <note> An extended version is TR #96-01d, </note> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011. </month>
Reference-contexts: unsigned int isqrt (unsigned int & x) throw (); //@ behavior - //@ requires assigned (x, pre); //@ ensures (result-1)*(result-1) &lt; x^ //@ /" x^ &lt; (result+1)*(result+1); //@ example x^ = 31 /" result = 6; //@ example x^ = 31 /" result = 5; //@ - in Larch/C ++ <ref> [21] </ref>.) For instance, in Figure 7, examples are used to show that isqrt is underspecified; the two examples given show different approximations that may be returned for the square root of 31.
Reference: [22] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.13. Available from the URL ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or http://www.cs.iastate.edu/~leavens/larchc++.html, September 1997. </note>
Reference-contexts: In Larch/C ++ , the meaning of the modifies clause "modifies i;" is translated by a predicate like the following (see <ref> [22, Section 6.2.3.4] </ref> for exact details), which can be thought of as conjoined to the postcon-dition. ModifiedObjects (pre, post) "subseteq -i, residue_i In the above, ModifiedObjects (pre, post) is the set of all objects modified in the transition from the pre-state to the post-state, and "subseteq is a subset operator. <p> As with the modifies clause, the trashes clause is a permission, not a requirement to trash the objects mentioned. Consider the example in Figure 5 <ref> [22, Section 6.3.2.1] </ref>. The object pointed to by cp may be trashed, since it is mentioned in the trashes clause. The postcondition says that it must be trashed when the value of ref_count drops to 0, but may not be otherwise. <p> The postcondition says that it must be trashed when the value of ref_count drops to 0, but may not be otherwise. In Larch/C ++ , the meaning of the trashes clause "trashes *cp;" is translated by a predicate like the following (see <ref> [22, Section 6.2.3.4] </ref> for details), which can be thought of as conjoined to the postcondition. <p> To use claims in debugging a specification, for each claim, one would try to prove the following, where Pre is the case's precondition, Frame is the predicate that translates its frame axioms, Post is its postcondition, and Claim is the claimed predicate [33, 32, 34] <ref> [22, Section 6.8] </ref>. (All of these should be in their desugared forms.) Pre ^ Frame ^ Post ) Claim (1) 6.2 Examples When we give problem statements to students, we observe that many students primarily focus on examples. <p> The input example predicates would be used in debugging the specification by checking that they are consistent with the precondition. Eam-ple inputs are not included in the current version of Larch/C ++ <ref> [22] </ref>. 6.4 Redundant Frames One could also extend the idea of redundancy to the modifies and trashes clauses. One use for this would be to highlight objects that are implicitly allowed to be modified or trashed because some explicitly named object has been declared to depend on them [24]. <p> History constraints can also be used to succinctly express monotonic relationships between pre- and post-states. For example, the Larch/C ++ manual's specification of a class Person <ref> [22, Section 7.1.1] </ref>, includes the following history constraint, which expresses the inexorable arrow of time. //@ constraint age^ &lt;= age'; An innovation in Larch/C ++ is that one can limit a history constraint so that it only applies to various named operations [4] [22, Section 7.4]. <p> ++ manual's specification of a class Person [22, Section 7.1.1], includes the following history constraint, which expresses the inexorable arrow of time. //@ constraint age^ &lt;= age'; An innovation in Larch/C ++ is that one can limit a history constraint so that it only applies to various named operations [4] <ref> [22, Section 7.4] </ref>. This can be used to collect common parts of the postconditions of several operations in one place. This idea is advocated by Borgida et al. as an approach to dealing with frame axioms [1]. <p> This idea is advocated by Borgida et al. as an approach to dealing with frame axioms [1]. It is also useful in specifying history constraints for types that are intended as supertypes of weak behavioral subtypes [4] <ref> [22, Section 7.8] </ref>. 8 Conclusions In this paper we have described several enhancements to the pre- and postcondition technique for specifications. These enhancements contribute to the expressiveness of Larch/C ++ , and could be adapted to other specification languages.
Reference: [23] <author> Gary T. Leavens and Jeannette M. Wing. </author> <title> Protective interface specifications. </title> <editor> In Michel Bidoit and Max Dauchet, editors, </editor> <booktitle> TAPSOFT '97: Theory and Practice of Software Development, 7th International Joint Conference CAAP/FASE, Lille, France, volume 1214 of Lecture Notes in Computer Science, </booktitle> <pages> pages 520-534. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1997. </year>
Reference-contexts: The modifies clause gives considerable notational abbreviation, because it asserts that all objects not mentioned retain their values. 5.1 Trashing In the Larch family, predicates use the logic of the Larch Shared Language, which is a logic of total functions <ref> [12, 23] </ref>. In such a logic, the pre- and post-states, which are modeled by functions, will return proper values for objects that are not allocated or that are not assigned a proper value.
Reference: [24] <author> K. Rustan M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1995. </year> <note> Available as Technical Report Caltech-CS-TR-95-03. </note>
Reference-contexts: Dependent variables can be specified either directly, or indirectly using pre- and postconditions. (See also Leino's work on dependencies <ref> [24] </ref>.) * Fine-grained frame axioms using wild cards and expressions, which allow one to specify the variables that can be changed more concisely and pre cisely. * Let clauses, which allow the introduction of local named abbreviations. * Some extensions for the specification of reactive systems. <p> The object residue_i stands for whatever objects i may depend on that are not in scope <ref> [24, Section 11.3] </ref>. The modifies clause gives considerable notational abbreviation, because it asserts that all objects not mentioned retain their values. 5.1 Trashing In the Larch family, predicates use the logic of the Larch Shared Language, which is a logic of total functions [12, 23]. <p> //@ then trashed (*cp) //@ else ~trashed (*cp)); //@ example ref_count^ = 1 //@ /" ref_count' = 0 /" trashed (*cp); //@ claims ref_count^ &gt; 1 =&gt; ~trashed (*cp); //@ - 5 As above, the object residue_star_cp stands for whatever objects *cp may depend on that are not in scope <ref> [24, Section 11.3] </ref>. 6 Redundancy A redundant part of a specification does not itself form part of the reuse contract, but instead is a formalized commentary on it. By allowing a specifier to state redundant properties explicitly, a specification language becomes more expressive. <p> One use for this would be to highlight objects that are implicitly allowed to be modified or trashed because some explicitly named object has been declared to depend on them <ref> [24] </ref>.
Reference: [25] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: However, invariants are not mere notational abbreviations, because they apply to all operations, even when new ones are added to an ADT. Liskov and Wing introduced a similar idea as an aid to specifying OO programs that use behavioral subtyping <ref> [26, 25] </ref>. A history constraint for a type describes a property of objects of that type (or any subtype) that must hold for any ordered pair of visible states in a computation, where the first state occurs before the second.
Reference: [26] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and their use in defining subtypes. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 16-28, </pages> <month> October </month> <year> 1993. </year> <booktitle> OOPSLA '93 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: However, invariants are not mere notational abbreviations, because they apply to all operations, even when new ones are added to an ADT. Liskov and Wing introduced a similar idea as an aid to specifying OO programs that use behavioral subtyping <ref> [26, 25] </ref>. A history constraint for a type describes a property of objects of that type (or any subtype) that must hold for any ordered pair of visible states in a computation, where the first state occurs before the second.
Reference: [27] <author> Greg Nelson. </author> <title> A generalization of Dijkstra's calculus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 517-561, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: In Larch/C ++ , one can combine total and partial correctness specifications for the same procedure, and thus more precisely specify both when a call must terminate and what must be true on termination in any case. The semantics of such combinations uses the ideas of Dijkstra and others <ref> [6, 27, 16] </ref>. void abort (); //@ behavior - //@ ensures liberally false; //@ - Another way out of the difficulty with allocation routines would be to change the meaning of total correctness.
Reference: [28] <author> William F. Ogden, Murali Sitaraman, Bruce W. Weide, and Stuart H. </author> <title> Zweben. Part I: The RESOLVE framework and discipline | a research synopsis. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 23-28, </pages> <month> Oct </month> <year> 1994. </year>
Reference-contexts: Keywords: formal methods, liberal specification, redundancy, debugging, history constraint. 1 Related Work The pre- and postcondition technique was described by Hoare in his classic article [17]. This technique forms the basis of most contemporary specification languages for sequential systems <ref> [19, 15, 30, 8, 14, 28] </ref>. We take as our starting point an excellent article by Jonkers [20], which says (page 428): "Nowadays the pre- and postcondition technique is considered a standard technique in software development as it is being taught in almost every basic software engineering course. <p> Reuse bears an interesting relation to formal specification techniques. Following the Resolve group <ref> [28] </ref>, we believe that precise yet abstract specifications of software components are important for reuse. Indeed if a commercial reuse market is to be effective, the code itself cannot be the primary vehicle for documentation of reusable components.
Reference: [29] <author> Arnd Poetzsch-Heffter. </author> <title> Specification and Verification of Object-Oriented Programs. </title> <type> PhD thesis, </type> <institution> Technische Universitat Munchen, </institution> <year> 1997. </year> <month> (Habili-tationsschrift). </month>
Reference-contexts: For example, one could use a variation on Poetzsch-Heffter's semantics <ref> [29, page 48] </ref> and require termination only if no memory allocation errors occur. However, there are other uses for partial correctness. A prime use is in specifying when a procedure must not terminate. A simple example is the C ++ abort procedure, which can be specified as in Figure 2. <p> For example, in Figure 6, the precondition assigned (s, pre) applies to both cases. Extracting common parts of preconditions like this also highlights them for the reader. (We attach no special semantics to such common preconditions, unlike Poetzsch-Heffter <ref> [29, pages 96-97] </ref>.) 5 Framing A frame axiom in a procedure specification says that "nothing else changes" [1]. VDM and Z both have features to permit the specification of frame axioms (write permissions in VDM, and in Z).
Reference: [30] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: Keywords: formal methods, liberal specification, redundancy, debugging, history constraint. 1 Related Work The pre- and postcondition technique was described by Hoare in his classic article [17]. This technique forms the basis of most contemporary specification languages for sequential systems <ref> [19, 15, 30, 8, 14, 28] </ref>. We take as our starting point an excellent article by Jonkers [20], which says (page 428): "Nowadays the pre- and postcondition technique is considered a standard technique in software development as it is being taught in almost every basic software engineering course. <p> These enhancements are found in the specification language COLD-1 [8]. The following briefly summarizes the enhancements in COLD-1 over previous specification languages, such as VDM [19], Z <ref> [15, 30] </ref>, and languages in the Larch family [14]: * Dependent variables, the declaration of which allows the dependent variable to be modified whenever the variables it depends on are modified. <p> These authors have considerably adapted standard mathematical notations to be more consistent and communicative. However, they have not directed much attention to the pre- and postcondition technique itself. Similarly, the specification language Z <ref> [15, 30] </ref> has a great variety of notational refinements, but these refinements are not aimed at the pre- and postcondition technique. 2 Overview In this paper we describe several further enhancements to the pre- and postcondition technique.
Reference: [31] <author> Susan Stepney, Rosalind Barden, and David Cooper, </author> <title> editors. Object Orientation in Z. Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference: [32] <author> Yang Meng Tan. </author> <title> Formal specification techniques for promoting software modularity, enhancing documentation, and testing specifications. </title> <type> Technical Report 619, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, Mass., </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In addition, various enhancements to specifications can increase their quality. This is particularly true of the redundancy enhancements described in Section 6, which can be used to check that the specification says what is intended <ref> [33, 32, 34] </ref>. 3 Liberal Specifications Most specification languages have a total correctness [6] semantics. That is, a specification such as satisfied. (In Figure 1, the first line gives the C++ function's interface. <p> This technique is useful in precisely specifying reuse contracts for procedures written for languages (or compilers) without exception handling. This idea appears in sugared form in the LCL checks clause <ref> [14, 33, 32, 34] </ref>. Partial correctness is also useful for specifying procedures for which there is no known totally correct implementation. <p> For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories [14, Chapter 7]. Improving the quality of specifications in this way can only help reuse. 6.1 Claims Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions <ref> [33, 32, 34] </ref>. Of particular relevance here are Tan's "procedure claims," which state redundant properties that follow from the main part of a specification. <p> To use claims in debugging a specification, for each claim, one would try to prove the following, where Pre is the case's precondition, Frame is the predicate that translates its frame axioms, Post is its postcondition, and Claim is the claimed predicate <ref> [33, 32, 34] </ref> [22, Section 6.8]. (All of these should be in their desugared forms.) Pre ^ Frame ^ Post ) Claim (1) 6.2 Examples When we give problem statements to students, we observe that many students primarily focus on examples.
Reference: [33] <author> Yang Meng Tan. </author> <title> Interface language for supporting programming styles. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(8) </volume> <pages> 74-83, </pages> <month> August </month> <year> 1994. </year> <booktitle> Proceedings of the Workshop on Interface Definition Languages. </booktitle>
Reference-contexts: In addition, various enhancements to specifications can increase their quality. This is particularly true of the redundancy enhancements described in Section 6, which can be used to check that the specification says what is intended <ref> [33, 32, 34] </ref>. 3 Liberal Specifications Most specification languages have a total correctness [6] semantics. That is, a specification such as satisfied. (In Figure 1, the first line gives the C++ function's interface. <p> This technique is useful in precisely specifying reuse contracts for procedures written for languages (or compilers) without exception handling. This idea appears in sugared form in the LCL checks clause <ref> [14, 33, 32, 34] </ref>. Partial correctness is also useful for specifying procedures for which there is no known totally correct implementation. <p> For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories [14, Chapter 7]. Improving the quality of specifications in this way can only help reuse. 6.1 Claims Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions <ref> [33, 32, 34] </ref>. Of particular relevance here are Tan's "procedure claims," which state redundant properties that follow from the main part of a specification. <p> To use claims in debugging a specification, for each claim, one would try to prove the following, where Pre is the case's precondition, Frame is the predicate that translates its frame axioms, Post is its postcondition, and Claim is the claimed predicate <ref> [33, 32, 34] </ref> [22, Section 6.8]. (All of these should be in their desugared forms.) Pre ^ Frame ^ Post ) Claim (1) 6.2 Examples When we give problem statements to students, we observe that many students primarily focus on examples.
Reference: [34] <author> Yang Meng Tan. </author> <title> Formal Specification Techniques for Engineering Modular C Programs, </title> <booktitle> volume 1 of Kluwer International Series in Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: In addition, various enhancements to specifications can increase their quality. This is particularly true of the redundancy enhancements described in Section 6, which can be used to check that the specification says what is intended <ref> [33, 32, 34] </ref>. 3 Liberal Specifications Most specification languages have a total correctness [6] semantics. That is, a specification such as satisfied. (In Figure 1, the first line gives the C++ function's interface. <p> This technique is useful in precisely specifying reuse contracts for procedures written for languages (or compilers) without exception handling. This idea appears in sugared form in the LCL checks clause <ref> [14, 33, 32, 34] </ref>. Partial correctness is also useful for specifying procedures for which there is no known totally correct implementation. <p> For example, the Larch Shared Language incorporates features that can be used to state redundant claims about theories [14, Chapter 7]. Improving the quality of specifications in this way can only help reuse. 6.1 Claims Tan's work on LCL introduced redundancy into a specification language with pre- and postconditions <ref> [33, 32, 34] </ref>. Of particular relevance here are Tan's "procedure claims," which state redundant properties that follow from the main part of a specification. <p> To use claims in debugging a specification, for each claim, one would try to prove the following, where Pre is the case's precondition, Frame is the predicate that translates its frame axioms, Post is its postcondition, and Claim is the claimed predicate <ref> [33, 32, 34] </ref> [22, Section 6.8]. (All of these should be in their desugared forms.) Pre ^ Frame ^ Post ) Claim (1) 6.2 Examples When we give problem statements to students, we observe that many students primarily focus on examples.
Reference: [35] <author> Alan Wills. </author> <title> Specification in Fresco. </title> <editor> In Stepney et al. </editor> <volume> [31], chapter 11, </volume> <pages> pages 127-135. </pages>
Reference-contexts: This sugar was pioneered by Wing [37, Section 4.1.4]. The idea is that a specification can be split into several cases, all of which must be satisfied by a correct implementation. This concept was independently reinvented by Wills <ref> [35] </ref>. Wills called specification cases "capsules", and used them effectively in OO specifications. In Larch/C ++ , specification cases are separated by the keyword also. Consider the example of Figure 3. This example shows a specification with two cases. <p> In addition to their potential use in debugging specifications, we have found them to be a great aid in understanding specifications. We are also excited about their potential for automatic generation of test cases [13]. Besides examples, the enhancement we use most often is case analysis [37, Section 4.1.4] <ref> [35] </ref>. This is helpful in stating specifications of procedures that may throw exceptions, and also in breaking up the logic of a specification into more easily understood parts.
Reference: [36] <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: VDM and Z both have features to permit the specification of frame axioms (write permissions in VDM, and in Z). In the Larch family, interface specifications languages have followed Wing's design for Larch/CLU <ref> [36] </ref> in using the modifies clause to say that only the objects listed may have their abstract values changed.
Reference: [37] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year> <month> 10 </month>
Reference-contexts: Interpreters for Turing-complete languages are examples. 4 Case Analysis A simple syntactic sugar, which we call case analysis, is helpful in breaking up specifications into more manageable chunks, and in specifying procedures that can throw exceptions. This sugar was pioneered by Wing <ref> [37, Section 4.1.4] </ref>. The idea is that a specification can be split into several cases, all of which must be satisfied by a correct implementation. This concept was independently reinvented by Wills [35]. Wills called specification cases "capsules", and used them effectively in OO specifications. <p> In addition to their potential use in debugging specifications, we have found them to be a great aid in understanding specifications. We are also excited about their potential for automatic generation of test cases [13]. Besides examples, the enhancement we use most often is case analysis <ref> [37, Section 4.1.4] </ref> [35]. This is helpful in stating specifications of procedures that may throw exceptions, and also in breaking up the logic of a specification into more easily understood parts.
References-found: 37

