URL: http://www.cs.wisc.edu/wpis/papers/diku-tr94-14.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Interprocedural Dataow Analysis via Graph Reachability  
Author: Thomas Reps, Mooly Sagiv, and Susan Horwitz 
Keyword: General Terms: Algorithms, Theory Additional Key Words and Phrases: demand dataow a nalysis, distributive dataow f ramework, ow-sensitive side-effect analysis, function representation, graph reachability, interprocedural dataow analysis, interprocedural program slicing, inter-procedurally realizable path, interprocedurally valid path, meet-over-all-valid-paths solution  
Affiliation: University of Copenhagen  
Abstract: This paper shows how a large class of interprocedural dataow-analysis problems can be solved precisely in polynomial time. The only restrictions are that the set of dataow facts is a finite set, and that the dataow functions distribute over the conu-ence operator (either union or intersection). This class of problems includesbut is not limited tothe classical separable problems (also known as gen/kill or bit-vector problems)e.g., reaching definitions, available expressions, and live variables. In addition, the class of problems that our techniques handle includes many non-separable problems, including truly-live variables, copy constant propagation, and possibly-uninitialized variables. A novel aspect of our approach is that an interprocedural dataow-analysis problem is transformed into a special kind of graph-reachability problem (reachability along interprocedurally realizable paths). The paper presents three polynomial-time algorithms for the realizable-path reachability problem: an exhaustive version, a second exhaustive version that may be more appropriate in the incremental and/or interactive context, and a demand version. The first and third of these algorithms are asymptotically faster than the best previously known realizable-path reachability algorithm. An additional benefit of our techniques is that they lead to improved algorithms for two other kinds of interprocedural-analysis problems: interprocedural ow-sensitive side-effect problems (as studied by Callahan) and interprocedural program slicing (as studied by Horwitz, Reps, and Binkley). CR Categories and Subject Descriptors: D.3.4 [Programming Languages]: Processors compilers, optimization; E.1 [Data Structures] graphs; F.2.2 [Analysis of Algorithms and Problem Complexity]: Complexity of Algorithms, Nonnumerical Algorithms and Problems computations on discrete structures; G.2.2 [Discrete Mathematics]: Graph Theory graph algorithms 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Babich, W.A. and Jazayeri, M., </author> <title> The method of attributes for data ow analysis: Part II. Demand analysis, </title> <note> Acta Informatica 10(3) pp. </note> <month> 265-272 (October </month> <year> 1978). </year>
Reference-contexts: (lines [10]-[12]) is to create values X n , for each n N * , by gather ing up the set of nodes associated with n in G # IP that are targets of path edges discovered by procedure For - 16 - procedure SolveViaTabulation (G # IP ) begin <ref> [1] </ref> Let (N # , E # , C # ) = G # [2] PathEdge := [3] SummaryEdge := [4] WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), <p> It carries out three steps: Compress: Compress the Problem (lines <ref> [1] </ref>, [7]-[24]) The first step is to transform the original problem to one that deals only with the original program's start, exit, call, and return-site nodes. Procedure Compress is a worklist algorithm that solves a collection of purely intraprocedural reachability problems. <p> Procedure Compress is a worklist algorithm that solves a collection of purely intraprocedural reachability problems. Compress follows only the edges of E # that correspond to E 0 edges - 26 - procedure SolveViaCompression (G # IP ) begin <ref> [1] </ref> G := Compress (G # IP ) [2] SolveViaTabulation (G) [3] RealizablePath := FindRealizablePaths () [4] /* Values for X n , for all n (Start Exit Call Ret) hav e already been determined by SolveViaTabulation */ [5] for m N * - (Start Exit Call Ret) do [6] X <p> dataow-analysis problem is actually a single-source-single-sink realizable-path reachability problem: Is there a realizable path from a given point q to a given point p? However, it i s not known how to solve such problems more efficiently than the single-sink realizable-path reachability problem. - 32 - procedure BackwardTabulateSLRPs (WorkList) begin <ref> [1] </ref> while WorkList do [2] Select and remove an edge ((n, d 2 ), (e p , d 1 )) from WorkList [3] switch n [4] case n Ret p : [5] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) <p> Before the first call on IsMemberOfSolution is performed, the C # nodes are marked Reachable, all nodes with no predecessors are marked NotReachable, and all other nodes are marked Unknown. - 37 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin <ref> [1] </ref> RealizablePath := - ((x, d 1 ), (x, d 1 )) - [2] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [3]* ReachableNodes := ; UnreachableNodes := [4]* VisitedNodes := ; VisitedEdges := [5] while RPWorkList do [6] Select and remove an edge ((n, d 2 <p> Surprisingly, in each case, when the total cost is consideredthe cost of constructing the program summary graph, plus the cost of solving the problem on the program summary graphCallahan's algorithms are less efficient than the procedure SolveViaSLRPTabulation (G # IP ) begin <ref> [1] </ref> ForwardTabulateAllSLRPs (G # IP ) [2] for each p - 0, . . . , k do [3] X p : = - (d 1 , d 2 ) ((D p - L -) (D p - L -)) | ((s p , d 1 ), (e p , d
Reference: 2. <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J., </author> <title> Magic sets and other strange ways to implement logic programs, </title> <booktitle> i n Proceedings of the Fifth ACM Symposium on Principles of Database Systems, </booktitle> <year> (1986). </year>
Reference-contexts: , by gather ing up the set of nodes associated with n in G # IP that are targets of path edges discovered by procedure For - 16 - procedure SolveViaTabulation (G # IP ) begin [1] Let (N # , E # , C # ) = G # <ref> [2] </ref> PathEdge := [3] SummaryEdge := [4] WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) [10] for each <p> PathEdge is first initialized to in line <ref> [2] </ref>. Then, in lines [5]-[8], all edge of the form ((s main , c), (s main , c)), where (s main , c) C # , are inserted into PathEdge. All such edges meet the conditions of the invariant, and so the invariant holds when ForwardTabulateSLRPs is first called. <p> Procedure Compress is a worklist algorithm that solves a collection of purely intraprocedural reachability problems. Compress follows only the edges of E # that correspond to E 0 edges - 26 - procedure SolveViaCompression (G # IP ) begin [1] G := Compress (G # IP ) <ref> [2] </ref> SolveViaTabulation (G) [3] RealizablePath := FindRealizablePaths () [4] /* Values for X n , for all n (Start Exit Call Ret) hav e already been determined by SolveViaTabulation */ [5] for m N * - (Start Exit Call Ret) do [6] X m : = - d D fg (m) <p> end case [48] end switch [49] od [50] return (RealizablePath) end IP are reachable from a node in C # via a realizable path. (See also Figure 6.) of the super-graph (cf. line [18]), and returns a compressed version of exploded super-graph G # Solve: Solve the Compressed Problem (line <ref> [2] </ref>) The second phase is to solve the compressed problem by invoking the Tabulation Algorithm on the com pressed graph. <p> a single-source-single-sink realizable-path reachability problem: Is there a realizable path from a given point q to a given point p? However, it i s not known how to solve such problems more efficiently than the single-sink realizable-path reachability problem. - 32 - procedure BackwardTabulateSLRPs (WorkList) begin [1] while WorkList do <ref> [2] </ref> Select and remove an edge ((n, d 2 ), (e p , d 1 )) from WorkList [3] switch n [4] case n Ret p : [5] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [6] <p> IsMemberOfSolution is performed, the C # nodes are marked Reachable, all nodes with no predecessors are marked NotReachable, and all other nodes are marked Unknown. - 37 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [1] RealizablePath := - ((x, d 1 ), (x, d 1 )) - <ref> [2] </ref> RPWorkList := - ((x, d 1 ), (x, d 1 )) - [3]* ReachableNodes := ; UnreachableNodes := [4]* VisitedNodes := ; VisitedEdges := [5] while RPWorkList do [6] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [7]* Insert (n, d 2 ) <p> Surprisingly, in each case, when the total cost is consideredthe cost of constructing the program summary graph, plus the cost of solving the problem on the program summary graphCallahan's algorithms are less efficient than the procedure SolveViaSLRPTabulation (G # IP ) begin [1] ForwardTabulateAllSLRPs (G # IP ) <ref> [2] </ref> for each p - 0, . . . , k do [3] X p : = - (d 1 , d 2 ) ((D p - L -) (D p - L -)) | ((s p , d 1 ), (e p , d 2 )) PathEdge - [4] od
Reference: 3. <author> Beeri, C. and Ramakrishnan, R., </author> <title> On the power of magic, pp. </title> <booktitle> 269-293 in Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <address> (San Diego, CA, </address> <month> March </month> <year> 1987), (1987). </year>
Reference-contexts: ing up the set of nodes associated with n in G # IP that are targets of path edges discovered by procedure For - 16 - procedure SolveViaTabulation (G # IP ) begin [1] Let (N # , E # , C # ) = G # [2] PathEdge := <ref> [3] </ref> SummaryEdge := [4] WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) [10] for each n N * <p> Compress follows only the edges of E # that correspond to E 0 edges - 26 - procedure SolveViaCompression (G # IP ) begin [1] G := Compress (G # IP ) [2] SolveViaTabulation (G) <ref> [3] </ref> RealizablePath := FindRealizablePaths () [4] /* Values for X n , for all n (Start Exit Call Ret) hav e already been determined by SolveViaTabulation */ [5] for m N * - (Start Exit Call Ret) do [6] X m : = - d D fg (m) | $ c <p> point p? However, it i s not known how to solve such problems more efficiently than the single-sink realizable-path reachability problem. - 32 - procedure BackwardTabulateSLRPs (WorkList) begin [1] while WorkList do [2] Select and remove an edge ((n, d 2 ), (e p , d 1 )) from WorkList <ref> [3] </ref> switch n [4] case n Ret p : [5] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [6] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d <p> no predecessors are marked NotReachable, and all other nodes are marked Unknown. - 37 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [1] RealizablePath := - ((x, d 1 ), (x, d 1 )) - [2] RPWorkList := - ((x, d 1 ), (x, d 1 )) - <ref> [3] </ref>* ReachableNodes := ; UnreachableNodes := [4]* VisitedNodes := ; VisitedEdges := [5] while RPWorkList do [6] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [7]* Insert (n, d 2 ) into VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert <p> cost of constructing the program summary graph, plus the cost of solving the problem on the program summary graphCallahan's algorithms are less efficient than the procedure SolveViaSLRPTabulation (G # IP ) begin [1] ForwardTabulateAllSLRPs (G # IP ) [2] for each p - 0, . . . , k do <ref> [3] </ref> X p : = - (d 1 , d 2 ) ((D p - L -) (D p - L -)) | ((s p , d 1 ), (e p , d 2 )) PathEdge - [4] od procedure ForwardTabulateAllSLRPs (G # IP ) begin [5] Let (N # ,
Reference: 4. <author> Cai, J. and Paige, R., </author> <title> Program derivation by fixed point computation, </title> <note> Science of Computer Programming 11 pp. 197-261 (1988/89). </note>
Reference-contexts: Theorem 3.3. 1 [[R f ]] = f . 1 This is similar to Lemma 14 of Cai and Paige <ref> [4] </ref>, but the notion of representation relation defined in Definition 3.1 is different from the one that Cai and Paige use. - 9 - Proof. <p> set of nodes associated with n in G # IP that are targets of path edges discovered by procedure For - 16 - procedure SolveViaTabulation (G # IP ) begin [1] Let (N # , E # , C # ) = G # [2] PathEdge := [3] SummaryEdge := <ref> [4] </ref> WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) [10] for each n N * do [11] X <p> Compress follows only the edges of E # that correspond to E 0 edges - 26 - procedure SolveViaCompression (G # IP ) begin [1] G := Compress (G # IP ) [2] SolveViaTabulation (G) [3] RealizablePath := FindRealizablePaths () <ref> [4] </ref> /* Values for X n , for all n (Start Exit Call Ret) hav e already been determined by SolveViaTabulation */ [5] for m N * - (Start Exit Call Ret) do [6] X m : = - d D fg (m) | $ c such that ((s main , <p> Extend: Determine Values for the Nodes of the Full Problem (lines <ref> [4] </ref>-[7] of Figure 6, lines [26]-[50] of Figure 7) As noted in the comment on line [4], at the end of Step 2 values in the meet-over-all-valid-paths solution of the dataow-analysis problem are already known for the original program's start, exit, call, and return-site nodes. The third and final step is to determine solution values for all other nodes of the super-graph. <p> it i s not known how to solve such problems more efficiently than the single-sink realizable-path reachability problem. - 32 - procedure BackwardTabulateSLRPs (WorkList) begin [1] while WorkList do [2] Select and remove an edge ((n, d 2 ), (e p , d 1 )) from WorkList [3] switch n <ref> [4] </ref> case n Ret p : [5] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [6] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) <p> all other nodes are marked Unknown. - 37 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [1] RealizablePath := - ((x, d 1 ), (x, d 1 )) - [2] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [3]* ReachableNodes := ; UnreachableNodes := <ref> [4] </ref>* VisitedNodes := ; VisitedEdges := [5] while RPWorkList do [6] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [7]* Insert (n, d 2 ) into VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes <p> d) NotReachable od [52]* return (ReachableNodes ) end The lines changed from Figure 11 are marked with *. - 38 - During a given inv ocation of IsMemberOfSolution, the algorithm uses the sets VisitedNodes and VisitedEdges to keep track of all nodes and edges visited by IsMemberOfSolution itself (see lines <ref> [4] </ref>, [7], [19], [26], and [33]). (Nodes and edges visited by BackwardTabulateSLRPs are not recorded in these sets; as pointed out above, it is not the time spent in BackwardTabulateSLRPs that prevents the Demand-Tabulation Algorithm from having the same-total-cost property with respect to the Tabulation Algorithm.) IsMemberOfSolution also collects the set <p> ) [2] for each p - 0, . . . , k do [3] X p : = - (d 1 , d 2 ) ((D p - L -) (D p - L -)) | ((s p , d 1 ), (e p , d 2 )) PathEdge - <ref> [4] </ref> od procedure ForwardTabulateAllSLRPs (G # IP ) begin [5] Let (N # , E # , C # ) = G # [6] PathEdge := [7] SummaryEdge := [8] WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do
Reference: 5. <author> Callahan, D., Cooper, K.D., Kennedy, K., and Torczon, L., </author> <title> Interprocedural constant propagation, </title> <booktitle> Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <address> (Palo Alto, CA, </address> <month> June 25-27, </month> <year> 1986), </year> <journal> ACM SIGPLAN Notices 21(7) pp. </journal> <month> 152-161 (July </month> <year> 1986). </year>
Reference-contexts: associated with n in G # IP that are targets of path edges discovered by procedure For - 16 - procedure SolveViaTabulation (G # IP ) begin [1] Let (N # , E # , C # ) = G # [2] PathEdge := [3] SummaryEdge := [4] WorkList := <ref> [5] </ref> for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) [10] for each n N * do [11] X n : = <p> 0 edges - 26 - procedure SolveViaCompression (G # IP ) begin [1] G := Compress (G # IP ) [2] SolveViaTabulation (G) [3] RealizablePath := FindRealizablePaths () [4] /* Values for X n , for all n (Start Exit Call Ret) hav e already been determined by SolveViaTabulation */ <ref> [5] </ref> for m N * - (Start Exit Call Ret) do [6] X m : = - d D fg (m) | $ c such that ((s main , c), (m, d)) RealizablePath - [7] od function Compress (G # IP ) returns exploded super-graph begin [8] Let (N # , <p> to solve such problems more efficiently than the single-sink realizable-path reachability problem. - 32 - procedure BackwardTabulateSLRPs (WorkList) begin [1] while WorkList do [2] Select and remove an edge ((n, d 2 ), (e p , d 1 )) from WorkList [3] switch n [4] case n Ret p : <ref> [5] </ref> for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [6] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [7] od [8] for each d <p> - 37 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [1] RealizablePath := - ((x, d 1 ), (x, d 1 )) - [2] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [3]* ReachableNodes := ; UnreachableNodes := [4]* VisitedNodes := ; VisitedEdges := <ref> [5] </ref> while RPWorkList do [6] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [7]* Insert (n, d 2 ) into VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 <p> . , k do [3] X p : = - (d 1 , d 2 ) ((D p - L -) (D p - L -)) | ((s p , d 1 ), (e p , d 2 )) PathEdge - [4] od procedure ForwardTabulateAllSLRPs (G # IP ) begin <ref> [5] </ref> Let (N # , E # , C # ) = G # [6] PathEdge := [7] SummaryEdge := [8] WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do [10] Insert ((s p , d), (s p , <p> This feature of the algorithm is, in fact, vitally important; it is the feature that enables the Demand-Tabulation Algorithm to have the same-total-cost property with respect to the Tabulation Algorithm. Constant Propagation Several different algorithms for interprocedural constant propagation were presented by Callahan, Cooper, Kennedy, and Torczon in <ref> [5] </ref>. It is interesting to compare the accuracy and costs of their methods with the con stant-propagation problems that fit into the IFDS framework. 10 The most powerful method considered in [5], symbolic interpretation, does not fit into the IFDS framework, both because the functions are not distributive, and because the <p> Constant Propagation Several different algorithms for interprocedural constant propagation were presented by Callahan, Cooper, Kennedy, and Torczon in <ref> [5] </ref>. It is interesting to compare the accuracy and costs of their methods with the con stant-propagation problems that fit into the IFDS framework. 10 The most powerful method considered in [5], symbolic interpretation, does not fit into the IFDS framework, both because the functions are not distributive, and because the domain is infinite. Their next best method is pass-through constant propagation enhanced with return jump functions [14]. <p> Our algorithms can be applied whenever a correspondence between solutions to bidirectional dataow-analysis problems and realizable-path reachability problems can be established. Once a realizable-path reachability 10 There is no discussion of aliasing in <ref> [5] </ref>, and in this comparison, we will assume that programs are alias-free. - 45 - problem is in hand, the Tabulation, Compressed-Tabulation, and Demand-Tabulation algorithms (or perhaps slight notational variants of them) can be used to solve it.
Reference: 6. <author> Callahan, D., </author> <title> The program summary graph and ow-sensitive interprocedural data ow analysis, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> A CM SIGPLAN Notices 23(7) pp. </journal> <month> 47-56 (July </month> <year> 1988). </year>
Reference-contexts: In the incremental and/or interactive context changes are ordinar ily made to no more than a small percentage of a program's procedures. Callahan has given algorithms for several interprocedural ow-sensitive side-effect problems <ref> [6] </ref>. As we will see in Section 7, these problems are (from a certain technical standpoint) of a slightly different character from the IFDS dataow-analysis problems. However, with small adaptations the algorithms from Sections 4, 5, and 6 can be applied to these problems. <p> of path edges discovered by procedure For - 16 - procedure SolveViaTabulation (G # IP ) begin [1] Let (N # , E # , C # ) = G # [2] PathEdge := [3] SummaryEdge := [4] WorkList := [5] for each (s main , c) C # do <ref> [6] </ref> Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) [10] for each n N * do [11] X n : = - d 2 D fg (n) | $ d 1 <p> This compression step is similar to the kind of problem transformations implicit in the creation of the program summary graph that is used by Callahan for solving ow-sensitive side-effect problems <ref> [6] </ref> and the system dependence graph that is used by Horwitz, Reps, and Binkley for interprocedural program slicing [18]. <p> begin [1] G := Compress (G # IP ) [2] SolveViaTabulation (G) [3] RealizablePath := FindRealizablePaths () [4] /* Values for X n , for all n (Start Exit Call Ret) hav e already been determined by SolveViaTabulation */ [5] for m N * - (Start Exit Call Ret) do <ref> [6] </ref> X m : = - d D fg (m) | $ c such that ((s main , c), (m, d)) RealizablePath - [7] od function Compress (G # IP ) returns exploded super-graph begin [8] Let (N # , E # , C # ) = G # [9] CompressedEdges <p> [2] Select and remove an edge ((n, d 2 ), (e p , d 1 )) from WorkList [3] switch n [4] case n Ret p : [5] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do <ref> [6] </ref> Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [7] od [8] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [9] Propagate (PathEdge, (( pred <p> IsMemberOfSolution (x, d 1 ) returns Boolean begin [1] RealizablePath := - ((x, d 1 ), (x, d 1 )) - [2] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [3]* ReachableNodes := ; UnreachableNodes := [4]* VisitedNodes := ; VisitedEdges := [5] while RPWorkList do <ref> [6] </ref> Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [7]* Insert (n, d 2 ) into VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 ) is marked NotReachable <p> We also describe how to obtain demand algorithms for the two problems, which have no analog in previous papers on these problems. 7.1. Flow-Sensitive Side-Effect Analysis Callahan gav e algorithms for solving two ow-sensitive side-effect problems: must-modify and may-use <ref> [6] </ref>. The must-modify problem is to identify, for each procedure p, which variables must be modified during a call on p; the may-use problem is to identify, for each procedure p, which variables may be used before being modified during a call on p. <p> 2 ) ((D p - L -) (D p - L -)) | ((s p , d 1 ), (e p , d 2 )) PathEdge - [4] od procedure ForwardTabulateAllSLRPs (G # IP ) begin [5] Let (N # , E # , C # ) = G # <ref> [6] </ref> PathEdge := [7] SummaryEdge := [8] WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do [10] Insert ((s p , d), (s p , d)) into PathEdge [11] Insert ((s p , d), (s p , d)) into <p> By coincidence, the original paper describing the Horwitz-Reps-Binkley slicing algorithm [17]. and the paper by Callahan describing how the program summary graph could be used to solve ow-sensitive side-effect analysis problems <ref> [6] </ref> were published back-to-back in the Proceedings of the 1988 Conference on Programming Language Design and Implementation. While it was thought at that time that the techniques presented in the two papers must be related, it was not entirely clear what the relationship was.
Reference: 7. <author> Cocke, J., </author> <title> Global common subexpression elimination, </title> <journal> ACM SIGPLAN Notices 5(7) pp. </journal> <month> 20-24 </month> <year> (1970). </year>
Reference-contexts: (G # IP ) begin [1] Let (N # , E # , C # ) = G # [2] PathEdge := [3] SummaryEdge := [4] WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge <ref> [7] </ref> Insert ((s main , c), (s main , c)) into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) [10] for each n N * do [11] X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , <p> , for all n (Start Exit Call Ret) hav e already been determined by SolveViaTabulation */ [5] for m N * - (Start Exit Call Ret) do [6] X m : = - d D fg (m) | $ c such that ((s main , c), (m, d)) RealizablePath - <ref> [7] </ref> od function Compress (G # IP ) returns exploded super-graph begin [8] Let (N # , E # , C # ) = G # [9] CompressedEdges := [10] WorkList := [11] for each p - 0, . . . , k and d (D p L) do [12] Insert <p> case n Ret p : [5] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [6] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) <ref> [7] </ref> od [8] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [9] Propagate (PathEdge, (( pred 1 (n), d 3 ), (e p , d 1 )), WorkList) [10] od [11] end case [12] case n = s <p> (x, d 1 )) - [2] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [3]* ReachableNodes := ; UnreachableNodes := [4]* VisitedNodes := ; VisitedEdges := [5] while RPWorkList do [6] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList <ref> [7] </ref>* Insert (n, d 2 ) into VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 ) is marked NotReachable then Insert (n, d 2 ) into UnreachableNodes [10]* else /* (n, d 2 ) is <p> NotReachable od [52]* return (ReachableNodes ) end The lines changed from Figure 11 are marked with *. - 38 - During a given inv ocation of IsMemberOfSolution, the algorithm uses the sets VisitedNodes and VisitedEdges to keep track of all nodes and edges visited by IsMemberOfSolution itself (see lines [4], <ref> [7] </ref>, [19], [26], and [33]). (Nodes and edges visited by BackwardTabulateSLRPs are not recorded in these sets; as pointed out above, it is not the time spent in BackwardTabulateSLRPs that prevents the Demand-Tabulation Algorithm from having the same-total-cost property with respect to the Tabulation Algorithm.) IsMemberOfSolution also collects the set of <p> p - L -) (D p - L -)) | ((s p , d 1 ), (e p , d 2 )) PathEdge - [4] od procedure ForwardTabulateAllSLRPs (G # IP ) begin [5] Let (N # , E # , C # ) = G # [6] PathEdge := <ref> [7] </ref> SummaryEdge := [8] WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do [10] Insert ((s p , d), (s p , d)) into PathEdge [11] Insert ((s p , d), (s p , d)) into WorkList [12] od
Reference: 8. <author> Cooper, K.D. and Kennedy, K., </author> <title> Interprocedural side-effect analysis in linear time, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 57-66 (July </month> <year> 1988). </year>
Reference-contexts: , C # ) = G # [2] PathEdge := [3] SummaryEdge := [4] WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList <ref> [8] </ref> od [9] ForwardTabulateSLRPs (WorkList) [10] for each n N * do [11] X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - [12] od procedure <p> determined by SolveViaTabulation */ [5] for m N * - (Start Exit Call Ret) do [6] X m : = - d D fg (m) | $ c such that ((s main , c), (m, d)) RealizablePath - [7] od function Compress (G # IP ) returns exploded super-graph begin <ref> [8] </ref> Let (N # , E # , C # ) = G # [9] CompressedEdges := [10] WorkList := [11] for each p - 0, . . . , k and d (D p L) do [12] Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s <p> Ret p : [5] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [6] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [7] od <ref> [8] </ref> for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [9] Propagate (PathEdge, (( pred 1 (n), d 3 ), (e p , d 1 )), WorkList) [10] od [11] end case [12] case n = s p : <p> - ((x, d 1 ), (x, d 1 )) - [3]* ReachableNodes := ; UnreachableNodes := [4]* VisitedNodes := ; VisitedEdges := [5] while RPWorkList do [6] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [7]* Insert (n, d 2 ) into VisitedNodes <ref> [8] </ref>* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 ) is marked NotReachable then Insert (n, d 2 ) into UnreachableNodes [10]* else /* (n, d 2 ) is marked Unknown */ [11] switch n [12] case <p> -) (D p - L -)) | ((s p , d 1 ), (e p , d 2 )) PathEdge - [4] od procedure ForwardTabulateAllSLRPs (G # IP ) begin [5] Let (N # , E # , C # ) = G # [6] PathEdge := [7] SummaryEdge := <ref> [8] </ref> WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do [10] Insert ((s p , d), (s p , d)) into PathEdge [11] Insert ((s p , d), (s p , d)) into WorkList [12] od [13] ForwardTabulateSLRPs (WorkList)
Reference: 9. <author> Cooper, K.D. and Kennedy, K., </author> <title> Fast interprocedural alias analysis, pp. </title> <booktitle> 49-59 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: # ) = G # [2] PathEdge := [3] SummaryEdge := [4] WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList [8] od <ref> [9] </ref> ForwardTabulateSLRPs (WorkList) [10] for each n N * do [11] X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - [12] od procedure Propagate (EdgeSet, <p> do [6] X m : = - d D fg (m) | $ c such that ((s main , c), (m, d)) RealizablePath - [7] od function Compress (G # IP ) returns exploded super-graph begin [8] Let (N # , E # , C # ) = G # <ref> [9] </ref> CompressedEdges := [10] WorkList := [11] for each p - 0, . . . , k and d (D p L) do [12] Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList [13] for each m Ret <p> )) E # do [6] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [7] od [8] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do <ref> [9] </ref> Propagate (PathEdge, (( pred 1 (n), d 3 ), (e p , d 1 )), WorkList) [10] od [11] end case [12] case n = s p : [13] for each c callers ( p) do [14] for each d 4 , d 5 such that ((c, d 5 ), <p> VisitedNodes := ; VisitedEdges := [5] while RPWorkList do [6] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [7]* Insert (n, d 2 ) into VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes <ref> [9] </ref>* else if (n, d 2 ) is marked NotReachable then Insert (n, d 2 ) into UnreachableNodes [10]* else /* (n, d 2 ) is marked Unknown */ [11] switch n [12] case n Ret p : [13] WorkList := [14] for each d 3 such that ((e calledProc (pred <p> - L -)) | ((s p , d 1 ), (e p , d 2 )) PathEdge - [4] od procedure ForwardTabulateAllSLRPs (G # IP ) begin [5] Let (N # , E # , C # ) = G # [6] PathEdge := [7] SummaryEdge := [8] WorkList := <ref> [9] </ref> for each p - 0, . . . , k and d (D p - L -) do [10] Insert ((s p , d), (s p , d)) into PathEdge [11] Insert ((s p , d), (s p , d)) into WorkList [12] od [13] ForwardTabulateSLRPs (WorkList) end must-modify by
Reference: 10. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven program analysis, </title> <type> Technical Report TR-93-15, </type> <institution> Department of Computer Science, University of Pittsburgh, </institution> <address> Pittsburgh, PA (October 1993). </address>
Reference-contexts: G # [2] PathEdge := [3] SummaryEdge := [4] WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) <ref> [10] </ref> for each n N * do [11] X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - [12] od procedure Propagate (EdgeSet, e, WorkList) begin <p> m : = - d D fg (m) | $ c such that ((s main , c), (m, d)) RealizablePath - [7] od function Compress (G # IP ) returns exploded super-graph begin [8] Let (N # , E # , C # ) = G # [9] CompressedEdges := <ref> [10] </ref> WorkList := [11] for each p - 0, . . . , k and d (D p L) do [12] Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList [13] for each m Ret p do [14] <p> calledProc (pred 1 (n)) , d 3 )), WorkList) [7] od [8] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [9] Propagate (PathEdge, (( pred 1 (n), d 3 ), (e p , d 1 )), WorkList) <ref> [10] </ref> od [11] end case [12] case n = s p : [13] for each c callers ( p) do [14] for each d 4 , d 5 such that ((c, d 5 ), (s p , d 2 )) E # and ((e p , d 1 ), (succ 1 <p> ), (x, d 1 )) from RPWorkList [7]* Insert (n, d 2 ) into VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 ) is marked NotReachable then Insert (n, d 2 ) into UnreachableNodes <ref> [10] </ref>* else /* (n, d 2 ) is marked Unknown */ [11] switch n [12] case n Ret p : [13] WorkList := [14] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [15] Propagate (PathEdge, ((e calledProc <p> od procedure ForwardTabulateAllSLRPs (G # IP ) begin [5] Let (N # , E # , C # ) = G # [6] PathEdge := [7] SummaryEdge := [8] WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do <ref> [10] </ref> Insert ((s p , d), (s p , d)) into PathEdge [11] Insert ((s p , d), (s p , d)) into WorkList [12] od [13] ForwardTabulateSLRPs (WorkList) end must-modify by determining whether certain same-level realizable paths exist in G # IP . - 40 - algorithms given above! 7 <p> A recent paper by Duesterwald, Gupta, and Soffa discusses a very different approach to (intraprocedural) demand dataow analysis <ref> [10] </ref>. For each query of the form Is fact d in the solution set at node x?, a set of dataow equations is set up on the ow graph (but as if all edges were reversed).
Reference: 11. <author> Fischer, C.N. and LeBlanc, </author> <title> R.J., Crafting a Compiler, </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Menlo Park, CA (1988). </address>
Reference-contexts: interprocedural, finite, distributive, subset problems, or IFDS problems, for shortincludes, but is not limited to, the classical separable problems (also known as gen/kill or bit-vector problems)e.g., reaching definitions, available expressions, and live variables; however, the class also includes many n on-separable problems, including truly-live variables [12], copy c onstant propagation <ref> [11, pp. 660] </ref>, and possibly uninitialized variables. (These problems are defined in Appendix A.) On sabbatical leave from the University of Wisconsin-Madison, Madison, WI, USA. On leave from IBM Israel, Haifa Research Laboratory. <p> := [4] WorkList := [5] for each (s main , c) C # do [6] Insert ((s main , c), (s main , c)) into PathEdge [7] Insert ((s main , c), (s main , c)) into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) [10] for each n N * do <ref> [11] </ref> X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - [12] od procedure Propagate (EdgeSet, e, WorkList) begin [13] if e EdgeSet then Insert e <p> E # do [39] Propagate (PathEdge, ((s p , d 1 ), (m, d 3 )), WorkList) [40] od [41] end case [42] end switch [43] od same-level realizable paths exist in G # IP . - 17 - Lines [18]-[20] Lines [21]-[23] Line [29] Lines [30]-[32] Lines [38]-[40] wardTabulateSLRPs: <ref> [11] </ref> X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - At first glance, this may not appear to be correct. According to line [11], d <p> wardTabulateSLRPs: <ref> [11] </ref> X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - At first glance, this may not appear to be correct. According to line [11], d 2 is put into X n if there is a same-level realizable path (i.e., a path edge) from (s fg (n) , d 1 ) to (n, d 2 ), rather than a realizable path from some c # # (n, d 2 ). <p> To show t hat X n = MVP n , for all n N * , we appeal to Theorem 3.10. Because the value of X n is defined in line <ref> [11] </ref> of Figure 4 by the assignment: X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge -, we know from Theorem 3.10 that X n = <p> - d D fg (m) | $ c such that ((s main , c), (m, d)) RealizablePath - [7] od function Compress (G # IP ) returns exploded super-graph begin [8] Let (N # , E # , C # ) = G # [9] CompressedEdges := [10] WorkList := <ref> [11] </ref> for each p - 0, . . . , k and d (D p L) do [12] Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList [13] for each m Ret p do [14] Insert ((m, d), <p> 1 (n)) , d 3 )), WorkList) [7] od [8] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [9] Propagate (PathEdge, (( pred 1 (n), d 3 ), (e p , d 1 )), WorkList) [10] od <ref> [11] </ref> end case [12] case n = s p : [13] for each c callers ( p) do [14] for each d 4 , d 5 such that ((c, d 5 ), (s p , d 2 )) E # and ((e p , d 1 ), (succ 1 (c), d <p> 2 ) into VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 ) is marked NotReachable then Insert (n, d 2 ) into UnreachableNodes [10]* else /* (n, d 2 ) is marked Unknown */ <ref> [11] </ref> switch n [12] case n Ret p : [13] WorkList := [14] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [15] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 <p> , E # , C # ) = G # [6] PathEdge := [7] SummaryEdge := [8] WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do [10] Insert ((s p , d), (s p , d)) into PathEdge <ref> [11] </ref> Insert ((s p , d), (s p , d)) into WorkList [12] od [13] ForwardTabulateSLRPs (WorkList) end must-modify by determining whether certain same-level realizable paths exist in G # IP . - 40 - algorithms given above! 7 The cost of Callahan's approach has two parts: (i) The cost of <p> Therefore, a variable is only discovered to be constant if it is assigned a literal value, or it is assigned the value of another variable that is known to be constant <ref> [11, pp. 660] </ref>. The natural way to specify the problem is to use intersection as the meet operator (the must-be-constant problem). To solve the problem using the algorithms described in this paper, it must be transformed into the corresponding -distributive problem: the may-not-be-constant problem.
Reference: 12. <author> Giegerich, R., Moncke, U., and Wilhelm, R., </author> <title> Invariance of approximative semantics with respect to program transformation, pp. </title> <booktitle> 1-10 in Informatik-Fachberichte 50, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1981). </address>
Reference-contexts: problemswhich we will call the interprocedural, finite, distributive, subset problems, or IFDS problems, for shortincludes, but is not limited to, the classical separable problems (also known as gen/kill or bit-vector problems)e.g., reaching definitions, available expressions, and live variables; however, the class also includes many n on-separable problems, including truly-live variables <ref> [12] </ref>, copy c onstant propagation [11, pp. 660], and possibly uninitialized variables. (These problems are defined in Appendix A.) On sabbatical leave from the University of Wisconsin-Madison, Madison, WI, USA. On leave from IBM Israel, Haifa Research Laboratory. <p> into WorkList [8] od [9] ForwardTabulateSLRPs (WorkList) [10] for each n N * do [11] X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - <ref> [12] </ref> od procedure Propagate (EdgeSet, e, WorkList) begin [13] if e EdgeSet then Insert e into EdgeSet; Insert e into WorkList fi end procedure ForwardTabulateSLRPs (WorkList) begin [14] while WorkList do [15] Select and remove an edge ((s p , d 1 ), (n, d 2 )) from WorkList [16] switch <p> - [7] od function Compress (G # IP ) returns exploded super-graph begin [8] Let (N # , E # , C # ) = G # [9] CompressedEdges := [10] WorkList := [11] for each p - 0, . . . , k and d (D p L) do <ref> [12] </ref> Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList [13] for each m Ret p do [14] Insert ((m, d), (m, d)) into CompressedEdges; Insert ((m, d), (m, d)) into WorkList [15] od [17] while WorkList do <p> d 3 )), WorkList) [7] od [8] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [9] Propagate (PathEdge, (( pred 1 (n), d 3 ), (e p , d 1 )), WorkList) [10] od [11] end case <ref> [12] </ref> case n = s p : [13] for each c callers ( p) do [14] for each d 4 , d 5 such that ((c, d 5 ), (s p , d 2 )) E # and ((e p , d 1 ), (succ 1 (c), d 4 )) E <p> VisitedNodes [8]* if (n, d 2 ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 ) is marked NotReachable then Insert (n, d 2 ) into UnreachableNodes [10]* else /* (n, d 2 ) is marked Unknown */ [11] switch n <ref> [12] </ref> case n Ret p : [13] WorkList := [14] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [15] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d <p> := [7] SummaryEdge := [8] WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do [10] Insert ((s p , d), (s p , d)) into PathEdge [11] Insert ((s p , d), (s p , d)) into WorkList <ref> [12] </ref> od [13] ForwardTabulateSLRPs (WorkList) end must-modify by determining whether certain same-level realizable paths exist in G # IP . - 40 - algorithms given above! 7 The cost of Callahan's approach has two parts: (i) The cost of doing the dataow analysis (computing reaches information) needed to construct the program <p> Thus, the outgoing edges of node n for a backward problem are the incoming edges for a forward problem.) Truly-Live Variables The truly-live variables problem is a variation on the standard live-variables problem; every truly-live variable is also live, but not vice versa <ref> [12] </ref>.
Reference: 13. <author> Graham, S.L. and Wegman, M., </author> <title> A fast and usually linear algorithm for global data ow analysis, </title> <journal> J. ACM 23(1) pp. </journal> <month> 172-202 </month> <year> (1976). </year>
Reference-contexts: for each n N * do [11] X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - [12] od procedure Propagate (EdgeSet, e, WorkList) begin <ref> [13] </ref> if e EdgeSet then Insert e into EdgeSet; Insert e into WorkList fi end procedure ForwardTabulateSLRPs (WorkList) begin [14] while WorkList do [15] Select and remove an edge ((s p , d 1 ), (n, d 2 )) from WorkList [16] switch n [17] case n Call p : [18] <p> PathEdge is initially empty, and there are only a finite number of possible path edges. A path edge is inserted into WorkList exactly once, when it is inserted into PathEdge (see lines [6]-[7] and line <ref> [13] </ref> of Figure 4). Consequently, the outermost loop of procedure ForwardTabulateSLRPs (lines [14]-[43]) can execute at most a finite number of times, and the Tabulation Algorithm is guaranteed to halt. <p> ) = G # [9] CompressedEdges := [10] WorkList := [11] for each p - 0, . . . , k and d (D p L) do [12] Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList <ref> [13] </ref> for each m Ret p do [14] Insert ((m, d), (m, d)) into CompressedEdges; Insert ((m, d), (m, d)) into WorkList [15] od [17] while WorkList do [18] Select and remove an edge ((a, d 1 ), (n, d 2 )) from WorkList [19] for each (m, d 3 ) <p> for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [9] Propagate (PathEdge, (( pred 1 (n), d 3 ), (e p , d 1 )), WorkList) [10] od [11] end case [12] case n = s p : <ref> [13] </ref> for each c callers ( p) do [14] for each d 4 , d 5 such that ((c, d 5 ), (s p , d 2 )) E # and ((e p , d 1 ), (succ 1 (c), d 4 )) E # do [15] if ((c, d 5 <p> ) is marked Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 ) is marked NotReachable then Insert (n, d 2 ) into UnreachableNodes [10]* else /* (n, d 2 ) is marked Unknown */ [11] switch n [12] case n Ret p : <ref> [13] </ref> WorkList := [14] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [15] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [16] od [17] <p> SummaryEdge := [8] WorkList := [9] for each p - 0, . . . , k and d (D p - L -) do [10] Insert ((s p , d), (s p , d)) into PathEdge [11] Insert ((s p , d), (s p , d)) into WorkList [12] od <ref> [13] </ref> ForwardTabulateSLRPs (WorkList) end must-modify by determining whether certain same-level realizable paths exist in G # IP . - 40 - algorithms given above! 7 The cost of Callahan's approach has two parts: (i) The cost of doing the dataow analysis (computing reaches information) needed to construct the program summary graph,
Reference: 14. <author> Grove, D. and Torczon, L., </author> <title> Interprocedural constant propagation: A study of jump function implementation, pp. </title> <booktitle> 90-99 in Proceedings of the ACM SIGPLAN 93 Conference on Programming Language Design and Implementation, </booktitle> <address> (Albuquerque, NM, June 23-25, 1993), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - [12] od procedure Propagate (EdgeSet, e, WorkList) begin [13] if e EdgeSet then Insert e into EdgeSet; Insert e into WorkList fi end procedure ForwardTabulateSLRPs (WorkList) begin <ref> [14] </ref> while WorkList do [15] Select and remove an edge ((s p , d 1 ), (n, d 2 )) from WorkList [16] switch n [17] case n Call p : [18] for each d 3 such that ((n, d 2 ), (s calledProc (n) , d 3 )) E # <p> [10] WorkList := [11] for each p - 0, . . . , k and d (D p L) do [12] Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList [13] for each m Ret p do <ref> [14] </ref> Insert ((m, d), (m, d)) into CompressedEdges; Insert ((m, d), (m, d)) into WorkList [15] od [17] while WorkList do [18] Select and remove an edge ((a, d 1 ), (n, d 2 )) from WorkList [19] for each (m, d 3 ) N # fg (a) such that (n, <p> 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [9] Propagate (PathEdge, (( pred 1 (n), d 3 ), (e p , d 1 )), WorkList) [10] od [11] end case [12] case n = s p : [13] for each c callers ( p) do <ref> [14] </ref> for each d 4 , d 5 such that ((c, d 5 ), (s p , d 2 )) E # and ((e p , d 1 ), (succ 1 (c), d 4 )) E # do [15] if ((c, d 5 ), (succ 1 (c), d 4 )) SummaryEdge <p> Reachable then Insert (n, d 2 ) into ReachableNodes [9]* else if (n, d 2 ) is marked NotReachable then Insert (n, d 2 ) into UnreachableNodes [10]* else /* (n, d 2 ) is marked Unknown */ [11] switch n [12] case n Ret p : [13] WorkList := <ref> [14] </ref> for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [15] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [16] od [17] BackwardTabulateSLRPs (WorkList) [18] <p> Their next best method is pass-through constant propagation enhanced with return jump functions <ref> [14] </ref>. This method is of particular interest because experimental evidence indicates that pass-through constant propagation may be as good as symbolic interpretation in practice [14]. A similarbut slightly more accurateproblem can be expressed as a locally separable IFDS problem. (The IFDS version is also more general because it handles recursion. <p> Their next best method is pass-through constant propagation enhanced with return jump functions <ref> [14] </ref>. This method is of particular interest because experimental evidence indicates that pass-through constant propagation may be as good as symbolic interpretation in practice [14]. A similarbut slightly more accurateproblem can be expressed as a locally separable IFDS problem. (The IFDS version is also more general because it handles recursion.
Reference: 15. <author> Hecht, </author> <title> M.S., Flow Analysis of Computer Programs, </title> <publisher> North-Holland, </publisher> <address> New York, NY (1977). </address>
Reference-contexts: (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - [12] od procedure Propagate (EdgeSet, e, WorkList) begin [13] if e EdgeSet then Insert e into EdgeSet; Insert e into WorkList fi end procedure ForwardTabulateSLRPs (WorkList) begin [14] while WorkList do <ref> [15] </ref> Select and remove an edge ((s p , d 1 ), (n, d 2 )) from WorkList [16] switch n [17] case n Call p : [18] for each d 3 such that ((n, d 2 ), (s calledProc (n) , d 3 )) E # do [19] Propagate (PathEdge, <p> Now assume that the invariant holds true after j iterations. Because a path edge is inserted into WorkList only when it is inserted into PathEdge, when edge ((s p , d 1 ), (n, d 2 )) is removed from WorkList in line <ref> [15] </ref> at the beginning of iteration j + 1, we know that ((s p , d 1 ), (n, d 2 )) PathEdge. <p> inserted into PathEdge it is also inserted into WorkList, we know that at some point during the execution of procedure ForwardTabu-lateSLRPs, the edge ((s fg (n j + 1 ) , d), (n j + 1 , d j + 1 )) was the edge removed from WorkList in line <ref> [15] </ref>. There are three cases to consider, depending on the type of node n j + 1 . These correspond to the three cases of the switch statement of procedure ForwardTabulateSLRPs. <p> Asymptotic running time of the Tabulation Algorithm for six different classes of dataow-analysis problems. Some of these bounds have been achieved p reviously: For intraprocedural problems, the algorithms of Hecht <ref> [15] </ref>, Kou [23], and Khedker and Dhamdhere [19] have the same time bounds as are shown in column three. 2 For locally separable problems (both intraprocedural and interprocedural), the algorithm of Knoop and Steffen [22] also runs in time O (ED). <p> In a true intraprocedural problem the program consists of only a single ow graph G 0 ; howev er, when an interprocedural dataow-analysis 4 The bounds in column three on the cost of obtaining imprecise answers apply not only to the Tabulation Algorithm but also to the algorithms of Hecht <ref> [15] </ref>, Kou [23], and Khedker and Dhamdhere [19], which can all be viewed as linear-time graph-reachability algorithms. - 25 - problem is treated as if it were one large intraprocedural problem, the ow graph is the super-graph, which consists of multiple ow graphs connected by edges from set E 2 . <p> d (D p L) do [12] Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList [13] for each m Ret p do [14] Insert ((m, d), (m, d)) into CompressedEdges; Insert ((m, d), (m, d)) into WorkList <ref> [15] </ref> od [17] while WorkList do [18] Select and remove an edge ((a, d 1 ), (n, d 2 )) from WorkList [19] for each (m, d 3 ) N # fg (a) such that (n, m) E 0 fg (a) and ((n, d 2 ), (m, d 3 )) E <p> = s p : [13] for each c callers ( p) do [14] for each d 4 , d 5 such that ((c, d 5 ), (s p , d 2 )) E # and ((e p , d 1 ), (succ 1 (c), d 4 )) E # do <ref> [15] </ref> if ((c, d 5 ), (succ 1 (c), d 4 )) SummaryEdge then [16] Insert ((c, d 5 ), (succ 1 (c), d 4 )) into SummaryEdge [17] for each d 3 such that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do [18] <p> 2 ) into UnreachableNodes [10]* else /* (n, d 2 ) is marked Unknown */ [11] switch n [12] case n Ret p : [13] WorkList := [14] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do <ref> [15] </ref> Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [16] od [17] BackwardTabulateSLRPs (WorkList) [18] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [19]* Insert
Reference: 16. <author> Horwitz, S. and Teitelbaum, T., </author> <title> Generating editing environments based on relations and attributes, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 8(4) pp. </pages> <month> 577-608 (October </month> <year> 1986). </year>
Reference-contexts: - [12] od procedure Propagate (EdgeSet, e, WorkList) begin [13] if e EdgeSet then Insert e into EdgeSet; Insert e into WorkList fi end procedure ForwardTabulateSLRPs (WorkList) begin [14] while WorkList do [15] Select and remove an edge ((s p , d 1 ), (n, d 2 )) from WorkList <ref> [16] </ref> switch n [17] case n Call p : [18] for each d 3 such that ((n, d 2 ), (s calledProc (n) , d 3 )) E # do [19] Propagate (PathEdge, ((s calledProc (n) , d 3 ), (s calledProc (n) , d 3 )), WorkList) [20] od [21] <p> The configurations that are used by BackwardTabulateSLRPs to deduce the existence of additional path edges are depicted in Figure 10; the five diagrams of Figure 10 correspond to lines [5]-[7], [8]-[10], <ref> [16] </ref>, [17]-[19], and [25]-[27] of Figure 9. In Figure 10, the bold dotted arrows represent edges that are inserted into set PathEdge if they were not previously in that set. <p> each d 4 , d 5 such that ((c, d 5 ), (s p , d 2 )) E # and ((e p , d 1 ), (succ 1 (c), d 4 )) E # do [15] if ((c, d 5 ), (succ 1 (c), d 4 )) SummaryEdge then <ref> [16] </ref> Insert ((c, d 5 ), (succ 1 (c), d 4 )) into SummaryEdge [17] for each d 3 such that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do [18] Propagate (PathEdge, ((c, d 5 ), (e fg (c) , d 3 )), WorkList) <p> All summary edges found are accumulated in set SummaryEdge. (See also Figure 11.) - 33 - Lines [5]-[7] Lines [8]-[10] Line <ref> [16] </ref> Lines [17]-[19] Lines [25]-[27] - 34 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [31] RealizablePath := - ((x, d 1 ), (x, d 1 )) - [32] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [33] while RPWorkList do [34] Select and remove <p> p : [13] WorkList := [14] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [15] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) <ref> [16] </ref> od [17] BackwardTabulateSLRPs (WorkList) [18] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3
Reference: 17. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> A CM SIGPLAN Notices 23(7) pp. </journal> <month> 35-46 (July </month> <year> 1988). </year>
Reference-contexts: procedure Propagate (EdgeSet, e, WorkList) begin [13] if e EdgeSet then Insert e into EdgeSet; Insert e into WorkList fi end procedure ForwardTabulateSLRPs (WorkList) begin [14] while WorkList do [15] Select and remove an edge ((s p , d 1 ), (n, d 2 )) from WorkList [16] switch n <ref> [17] </ref> case n Call p : [18] for each d 3 such that ((n, d 2 ), (s calledProc (n) , d 3 )) E # do [19] Propagate (PathEdge, ((s calledProc (n) , d 3 ), (s calledProc (n) , d 3 )), WorkList) [20] od [21] for each d <p> p L) do [12] Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList [13] for each m Ret p do [14] Insert ((m, d), (m, d)) into CompressedEdges; Insert ((m, d), (m, d)) into WorkList [15] od <ref> [17] </ref> while WorkList do [18] Select and remove an edge ((a, d 1 ), (n, d 2 )) from WorkList [19] for each (m, d 3 ) N # fg (a) such that (n, m) E 0 fg (a) and ((n, d 2 ), (m, d 3 )) E # do <p> , d 2 )) E # and ((e p , d 1 ), (succ 1 (c), d 4 )) E # do [15] if ((c, d 5 ), (succ 1 (c), d 4 )) SummaryEdge then [16] Insert ((c, d 5 ), (succ 1 (c), d 4 )) into SummaryEdge <ref> [17] </ref> for each d 3 such that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do [18] Propagate (PathEdge, ((c, d 5 ), (e fg (c) , d 3 )), WorkList) [19] od [21] od [23] end case [24] case n (N p Ret p <p> [13] WorkList := [14] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [15] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [16] od <ref> [17] </ref> BackwardTabulateSLRPs (WorkList) [18] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, <p> By coincidence, the original paper describing the Horwitz-Reps-Binkley slicing algorithm <ref> [17] </ref>. and the paper by Callahan describing how the program summary graph could be used to solve ow-sensitive side-effect analysis problems [6] were published back-to-back in the Proceedings of the 1988 Conference on Programming Language Design and Implementation.
Reference: 18. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, ACM T rans. Program. </title> <journal> Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: In Sections 4, 5, and 6, we present three new polynomial-time algorithms for the realizable-path reachability problem. Two of t he algorithms are asymptotically faster than the best previously known algorithm for the problem <ref> [18] </ref>. One of these algorithms permits demand interprocedural dataow analysis to be carried out. The remaining algorithm, although asymptotically not as fast in all cases as the other two, may be the pre ferred method in the incremental and/or interactive context (see below). <p> The realizable-path reachability problem is also the heart of the problem of interprocedural program slicing, and the fastest previously known algorithm for the problem is the one given by Horwitz, Reps, and Binkley <ref> [18] </ref>. The realizable-path reachability algorithms described in this paper yield improved interprocedural-slicing algorithmsones whose running times are asymptotically faster than the Horwitz-Reps-Binkley algorithm. - 3 - The remainder of the paper is organized as follows: Section 2 defines the IFDS framework for distributive interprocedural dataow-analysis problems. <p> [13] if e EdgeSet then Insert e into EdgeSet; Insert e into WorkList fi end procedure ForwardTabulateSLRPs (WorkList) begin [14] while WorkList do [15] Select and remove an edge ((s p , d 1 ), (n, d 2 )) from WorkList [16] switch n [17] case n Call p : <ref> [18] </ref> for each d 3 such that ((n, d 2 ), (s calledProc (n) , d 3 )) E # do [19] Propagate (PathEdge, ((s calledProc (n) , d 3 ), (s calledProc (n) , d 3 )), WorkList) [20] od [21] for each d 3 such that ((n, d 2 <p> Cost of the Tabulation Algorithm In this section, we show that the running time of the Tabulation Algorithm is polynomial in various parameters of a problem instance. We also show t hat the algorithm is asymptotically faster than the best previously known algorithm for the realizable-path reachability problem <ref> [18] </ref>. In this section, as well as in later sections in which we derive bounds on the running times of algorithms, we use the name of a set to denote the set's size. <p> This compression step is similar to the kind of problem transformations implicit in the creation of the program summary graph that is used by Callahan for solving ow-sensitive side-effect problems [6] and the system dependence graph that is used by Horwitz, Reps, and Binkley for interprocedural program slicing <ref> [18] </ref>. As we shall see, for a one-shot solution of a dataow-analysis problem, the compression-based algorithm is probably not the algorithm of choice since the cost of the initial compression step could be more expensive than the cost of the best algorithm for solving the problem. <p> Insert ((s p , d), (s p , d)) into CompressedEdges; Insert ((s p , d), (s p , d)) into WorkList [13] for each m Ret p do [14] Insert ((m, d), (m, d)) into CompressedEdges; Insert ((m, d), (m, d)) into WorkList [15] od [17] while WorkList do <ref> [18] </ref> Select and remove an edge ((a, d 1 ), (n, d 2 )) from WorkList [19] for each (m, d 3 ) N # fg (a) such that (n, m) E 0 fg (a) and ((n, d 2 ), (m, d 3 )) E # do [20] Propagate (CompressedEdges, ((a, <p> # do [45] Propagate (RealizablePath, ((s main , c), (m, d 2 )), WorkList) [46] od [47] end case [48] end switch [49] od [50] return (RealizablePath) end IP are reachable from a node in C # via a realizable path. (See also Figure 6.) of the super-graph (cf. line <ref> [18] </ref>), and returns a compressed version of exploded super-graph G # Solve: Solve the Compressed Problem (line [2]) The second phase is to solve the compressed problem by invoking the Tabulation Algorithm on the com pressed graph. <p> Cost of the Compressed-Tabulation Algorithm Table 5.1 compares the asymptotic running times of the the Tabulation Algorithm, the Compressed-Tabulation - 28 - Lines [36]-[38] Lines [39]-[41] Lines [44]-[46] Algorithm, and the Horwitz-Reps-Binkley algorithm. 5 5 The Horwitz-Reps-Binkley algorithm is presented in <ref> [18] </ref> as an algorithm for interprocedural slicing. To use it for interprocedural dataow analysis, only minor changes are necessary. Graph G # IP takes the place of the system dependence graph (before characteristic-graph edges are added). <p> This problem asks What are all the points q for which there exists a realizable path from q to a given point p?. 6 Although the Horwitz-Reps-Binkley algorithm (for backward slicing) can be applied to the single-sink realizable-path reachability problem, as described in <ref> [18] </ref> that algorithm has a phase in which certain auxiliary information is computed by a preliminary exhaustive algorithm. In other words, although the single-sink realizable-path reachability problem is a demand problem the Horwitz-Reps-Binkley algorithm is not a true demand algorithm for that problem. <p> [15] if ((c, d 5 ), (succ 1 (c), d 4 )) SummaryEdge then [16] Insert ((c, d 5 ), (succ 1 (c), d 4 )) into SummaryEdge [17] for each d 3 such that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do <ref> [18] </ref> Propagate (PathEdge, ((c, d 5 ), (e fg (c) , d 3 )), WorkList) [19] od [21] od [23] end case [24] case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) <p> [14] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [15] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [16] od [17] BackwardTabulateSLRPs (WorkList) <ref> [18] </ref> for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, d 1 )), <p> The fastest previously known algorithm for the problem is the one given by Horwitz, Reps, and Binkley; in this section, we assume familiarity with the terminology used in the paper that describes that algorithm <ref> [18] </ref>. 7 On reection, this is less surprising: The step of constructing the program summary graph corresponds to the step of compression in the al gorithm presented in Section 5. <p> Add these edges to the SDG. (iii) Perform the actual slicing operations as usual (i.e., using the backward-slicing algorithm of Figure 9 of ref erence <ref> [18] </ref>). <p> p , Call, and the following additional parameters: E max the largest number of edges in any procedure's dependence graph Params the largest number of formal parameters in any procedure Globals the number of global variables in the program X Globals + Params Call max p max Call p In <ref> [18] </ref>, it is shown that the cost of the Horwitz-Reps-Binkley algorithm is bounded by O (Call XE max + Call Call 2 4 ). <p> A demand algorithm can be obtained from function ReachedFromViaRealizablePath, described in Section 7.1. When ReachedFromViaRealizablePath is called with an SDG node n as its argument, it returns the set of SDG nodes that are identified by Pass 1 of the Horwitz-Reps-Binkley backward-slicing algo rithm (Figure 9 of reference <ref> [18] </ref>).
Reference: 19. <author> Khedker, </author> <title> U.P. and Dhamdhere, D.M., A generalized theory of data ow analysis, </title> <journal> ACM Trans. Program. Lang. Syst., </journal> (). <note> (To appear.) </note>
Reference-contexts: WorkList do [15] Select and remove an edge ((s p , d 1 ), (n, d 2 )) from WorkList [16] switch n [17] case n Call p : [18] for each d 3 such that ((n, d 2 ), (s calledProc (n) , d 3 )) E # do <ref> [19] </ref> Propagate (PathEdge, ((s calledProc (n) , d 3 ), (s calledProc (n) , d 3 )), WorkList) [20] od [21] for each d 3 such that ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do [22] Propagate (PathEdge, ((s p , d 1 ), (succ <p> Propagate is called from four places in procedure ForwardTabulateSLRPs (lines <ref> [19] </ref>, [22], [31], and [39]). In each case, we can demonstrate that if the call on Propagate actually does insert a new edge into PathEdge, then there is a realizable path q ## and a same-level realizable path s ## as required to re-establish the invariant. <p> Asymptotic running time of the Tabulation Algorithm for six different classes of dataow-analysis problems. Some of these bounds have been achieved p reviously: For intraprocedural problems, the algorithms of Hecht [15], Kou [23], and Khedker and Dhamdhere <ref> [19] </ref> have the same time bounds as are shown in column three. 2 For locally separable problems (both intraprocedural and interprocedural), the algorithm of Knoop and Steffen [22] also runs in time O (ED). <p> Instead of calculating the worst-case cost-per-iteration of the loop on lines [14]-[43] of Figure 4 and multiplying by the number of iterations, we break the cost of the algorithm down into three contributing aspects and bound 2 The intraprocedural dataow-analysis algorithms of Kou [23] and Khedker and Dhamdhere <ref> [19] </ref> are described as algorithms for separable problems; however, the ideas described in Section 3.2 concerning the representation of distributive functions can be used to immediately extend those algorithms to all distributive and h-sparse intraprocedural problems. - 21 - the total cost of the operations performed for each aspect. <p> consists of only a single ow graph G 0 ; howev er, when an interprocedural dataow-analysis 4 The bounds in column three on the cost of obtaining imprecise answers apply not only to the Tabulation Algorithm but also to the algorithms of Hecht [15], Kou [23], and Khedker and Dhamdhere <ref> [19] </ref>, which can all be viewed as linear-time graph-reachability algorithms. - 25 - problem is treated as if it were one large intraprocedural problem, the ow graph is the super-graph, which consists of multiple ow graphs connected by edges from set E 2 . <p> (s p , d)) into WorkList [13] for each m Ret p do [14] Insert ((m, d), (m, d)) into CompressedEdges; Insert ((m, d), (m, d)) into WorkList [15] od [17] while WorkList do [18] Select and remove an edge ((a, d 1 ), (n, d 2 )) from WorkList <ref> [19] </ref> for each (m, d 3 ) N # fg (a) such that (n, m) E 0 fg (a) and ((n, d 2 ), (m, d 3 )) E # do [20] Propagate (CompressedEdges, ((a, d 1 ), (m, d 3 )), WorkList) [21] od [23] N := - (n, d) <p> Insert ((c, d 5 ), (succ 1 (c), d 4 )) into SummaryEdge [17] for each d 3 such that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do [18] Propagate (PathEdge, ((c, d 5 ), (e fg (c) , d 3 )), WorkList) <ref> [19] </ref> od [21] od [23] end case [24] case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 <p> do [15] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 (n)) , d 3 )), WorkList) [16] od [17] BackwardTabulateSLRPs (WorkList) [18] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do <ref> [19] </ref>* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, d 1 )), RPWorkList) [21] od [22] end case [23] case n = s p : [24] for each c callers ( p) do [25] <p> od [52]* return (ReachableNodes ) end The lines changed from Figure 11 are marked with *. - 38 - During a given inv ocation of IsMemberOfSolution, the algorithm uses the sets VisitedNodes and VisitedEdges to keep track of all nodes and edges visited by IsMemberOfSolution itself (see lines [4], [7], <ref> [19] </ref>, [26], and [33]). (Nodes and edges visited by BackwardTabulateSLRPs are not recorded in these sets; as pointed out above, it is not the time spent in BackwardTabulateSLRPs that prevents the Demand-Tabulation Algorithm from having the same-total-cost property with respect to the Tabulation Algorithm.) IsMemberOfSolution also collects the set of visited <p> Thus, the representation described in Section 3.1 also has applications for repre senting distributive functions in conjunction with standard elimination algorithms. (ii) Recently, Khedker and Dhamdhere <ref> [19] </ref> have put forward a theory of bidirectional dataow-analysis problems. In bidirectional problems, information is permitted to ow both forwards and backwards along ow-graph edges. Khedker and Dhamdhere confine their attention to intraprocedural separable bidirectional problems.
Reference: 20. <author> Kildall, G., </author> <title> A unified approach to global program optimization, pp. </title> <booktitle> 194-206 in Conference Record of the First ACM Symposium on Principles of Programming Languages, ACM, </booktitle> <address> New York, NY (1973). </address>
Reference-contexts: These frameworks generalize Kildall's c on-cept of the meet-over-all-paths solution of an intraprocedural dataow-analysis problem <ref> [20] </ref> to the meet-over-all-valid-paths solution of an interprocedural dataow-analysis problem. The IFDS framework is designed to be as general as possible (in particular, to support languages with procedure calls, parameters, and both global and local variables). <p> from WorkList [16] switch n [17] case n Call p : [18] for each d 3 such that ((n, d 2 ), (s calledProc (n) , d 3 )) E # do [19] Propagate (PathEdge, ((s calledProc (n) , d 3 ), (s calledProc (n) , d 3 )), WorkList) <ref> [20] </ref> od [21] for each d 3 such that ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do [22] Propagate (PathEdge, ((s p , d 1 ), (succ 1 (n), d 3 )), WorkList) [23] od [24] end case [25] case n = e p : <p> while WorkList do [18] Select and remove an edge ((a, d 1 ), (n, d 2 )) from WorkList [19] for each (m, d 3 ) N # fg (a) such that (n, m) E 0 fg (a) and ((n, d 2 ), (m, d 3 )) E # do <ref> [20] </ref> Propagate (CompressedEdges, ((a, d 1 ), (m, d 3 )), WorkList) [21] od [23] N := - (n, d) N # | n (Start Exit Call Ret) - [24] E := - ((m, d 1 ), (n, d 2 )) | m, n (Start Exit Call Ret) and ((m, d <p> (pred 1 (n)) , d 3 )), WorkList) [16] od [17] BackwardTabulateSLRPs (WorkList) [18] for each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges <ref> [20] </ref> Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, d 1 )), RPWorkList) [21] od [22] end case [23] case n = s p : [24] for each c callers ( p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2
Reference: 21. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proceedings of the Fourth International Conference on Compiler Construction, (Paderborn, </booktitle> <address> FRG, </address> <month> October 5-7, </month> <year> 1992), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler, </editor> <address> S pringer-Verlag, New York, NY (1992). </address>
Reference-contexts: Our techniques also apply to the extension of the Sharir-Pnueli framework proposed by Knoop and Steffen, which covers programs in which recursive procedures may have local variables and call-by-value parameters <ref> [21] </ref>. Our techniques apply to all problem instances in the above-mentioned interprocedural frameworks in which the set of dataow facts D is a finite set, and where the dataow functions (which are in 2 D D ) distribute over the conuence operator (either union or intersection, depending on the problem). <p> Framework for Distributive Interprocedural Dataow-Analysis Problems The IFDS framework is a variant of Sharir and Pnueli's functional approach to interprocedural dataow analysis [31], with an extension similar to the one given by Knoop and Steffen in order to handle programs in which recursive procedures may have local variables and parameters <ref> [21] </ref>. These frameworks generalize Kildall's c on-cept of the meet-over-all-paths solution of an intraprocedural dataow-analysis problem [20] to the meet-over-all-valid-paths solution of an interprocedural dataow-analysis problem. <p> [16] switch n [17] case n Call p : [18] for each d 3 such that ((n, d 2 ), (s calledProc (n) , d 3 )) E # do [19] Propagate (PathEdge, ((s calledProc (n) , d 3 ), (s calledProc (n) , d 3 )), WorkList) [20] od <ref> [21] </ref> for each d 3 such that ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do [22] Propagate (PathEdge, ((s p , d 1 ), (succ 1 (n), d 3 )), WorkList) [23] od [24] end case [25] case n = e p : [26] for <p> ), (n, d 2 )) from WorkList [19] for each (m, d 3 ) N # fg (a) such that (n, m) E 0 fg (a) and ((n, d 2 ), (m, d 3 )) E # do [20] Propagate (CompressedEdges, ((a, d 1 ), (m, d 3 )), WorkList) <ref> [21] </ref> od [23] N := - (n, d) N # | n (Start Exit Call Ret) - [24] E := - ((m, d 1 ), (n, d 2 )) | m, n (Start Exit Call Ret) and ((m, d 1 ), (n, d 2 )) CompressedEdges - - ((m, d 1 <p> d 5 ), (succ 1 (c), d 4 )) into SummaryEdge [17] for each d 3 such that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do [18] Propagate (PathEdge, ((c, d 5 ), (e fg (c) , d 3 )), WorkList) [19] od <ref> [21] </ref> od [23] end case [24] case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) <p> each d 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, d 1 )), RPWorkList) <ref> [21] </ref> od [22] end case [23] case n = s p : [24] for each c callers ( p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 <p> In the remainder of this section, we summarize how these ideas relate to previous work. Previous Interprocedural Dataow-Analysis Frameworks The IFDS framework is based on earlier interprocedural dataow-analysis frameworks defined by Sharir and Pnueli [31] and Knoop and Steffen <ref> [21] </ref>. <p> It can be shown that for distributive problems, condition (iii) is a generalization of a previous extensionby Knoop and Steffento the Sharir-Pnueli framework in order to permit it to cover programming languages in which recursive procedures have local variables and call-by-value parameters <ref> [21] </ref>. (Knoop and Steffen observed that the summary function for a return-site node must combine the dataow information that holds at the corresponding call node with the dataow information that holds at the exit node of the called procedure. <p> However, for general IFDS problems both the iterative and call-strings algorithms can take e xponential time in the worst case. Knoop and Steffen give an a lgo-rithm similar to Sharir and Pnueli's elimination algorithm <ref> [21] </ref>. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in [31] and [21]. <p> Knoop and Steffen give an a lgo-rithm similar to Sharir and Pnueli's elimination algorithm <ref> [21] </ref>. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in [31] and [21]. However, even i f representation relations (as defined in Section 3.1) are used, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather than element-wise, for distributive and h-sparse problems, they are not as efficient as the algorithms given in Sections 4 and 6.
Reference: 22. <author> Knoop, J. and Steffen, B., </author> <title> Efficient and optimal bit-vector data ow analyses: A uniform interprocedural framework, </title> <type> Bericht Nr. 9309, </type> <institution> Institut fuer Informatik und Praktische Mathematik, Christian-Albrechts-Universitaet zu Kiel, Kiel, </institution> <address> Germany (April 1993). </address>
Reference-contexts: calledProc (n) , d 3 )) E # do [19] Propagate (PathEdge, ((s calledProc (n) , d 3 ), (s calledProc (n) , d 3 )), WorkList) [20] od [21] for each d 3 such that ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do <ref> [22] </ref> Propagate (PathEdge, ((s p , d 1 ), (succ 1 (n), d 3 )), WorkList) [23] od [24] end case [25] case n = e p : [26] for each c callers ( p) do [27] for each d 4 , d 5 such that ((c, d 4 ), (s <p> Propagate is called from four places in procedure ForwardTabulateSLRPs (lines [19], <ref> [22] </ref>, [31], and [39]). In each case, we can demonstrate that if the call on Propagate actually does insert a new edge into PathEdge, then there is a realizable path q ## and a same-level realizable path s ## as required to re-establish the invariant. <p> We know that this happens eventually.) At this point, a call is generated at line <ref> [22] </ref> of the form Propagate (PathEdge, ((s fg (n) , d), (n, d)), WorkList). <p> Some of these bounds have been achieved p reviously: For intraprocedural problems, the algorithms of Hecht [15], Kou [23], and Khedker and Dhamdhere [19] have the same time bounds as are shown in column three. 2 For locally separable problems (both intraprocedural and interprocedural), the algorithm of Knoop and Steffen <ref> [22] </ref> also runs in time O (ED). <p> I n the case of locally separable problems, there is no penalty at allboth kinds of solutions can be obtained in time O (ED). The fact that there is no penalty for finding the more precise answers for locally separable problems was observed by Knoop and Steffen <ref> [22] </ref>. What we have shown is that this can also be achieved by an algorithm that handles the more general distributive and h-sparse problem classes; when applied to locally separable problems, the algorithm adapts to exhibit O (ED) behavior. <p> 3 such that (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, d 1 )), RPWorkList) [21] od <ref> [22] </ref> end case [23] case n = s p : [24] for each c callers ( p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into
Reference: 23. <author> Kou, L.T., </author> <title> On live-dead analysis for global data ow problems, </title> <journal> Journal of the ACM 24(3) pp. </journal> <month> 473-483 (July </month> <year> 1977). </year>
Reference-contexts: d 3 ), (s calledProc (n) , d 3 )), WorkList) [20] od [21] for each d 3 such that ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do [22] Propagate (PathEdge, ((s p , d 1 ), (succ 1 (n), d 3 )), WorkList) <ref> [23] </ref> od [24] end case [25] case n = e p : [26] for each c callers ( p) do [27] for each d 4 , d 5 such that ((c, d 4 ), (s p , d 1 )) E # and ((e p , d 2 ), (succ 1 <p> Asymptotic running time of the Tabulation Algorithm for six different classes of dataow-analysis problems. Some of these bounds have been achieved p reviously: For intraprocedural problems, the algorithms of Hecht [15], Kou <ref> [23] </ref>, and Khedker and Dhamdhere [19] have the same time bounds as are shown in column three. 2 For locally separable problems (both intraprocedural and interprocedural), the algorithm of Knoop and Steffen [22] also runs in time O (ED). <p> Instead of calculating the worst-case cost-per-iteration of the loop on lines [14]-[43] of Figure 4 and multiplying by the number of iterations, we break the cost of the algorithm down into three contributing aspects and bound 2 The intraprocedural dataow-analysis algorithms of Kou <ref> [23] </ref> and Khedker and Dhamdhere [19] are described as algorithms for separable problems; however, the ideas described in Section 3.2 concerning the representation of distributive functions can be used to immediately extend those algorithms to all distributive and h-sparse intraprocedural problems. - 21 - the total cost of the operations performed <p> true intraprocedural problem the program consists of only a single ow graph G 0 ; howev er, when an interprocedural dataow-analysis 4 The bounds in column three on the cost of obtaining imprecise answers apply not only to the Tabulation Algorithm but also to the algorithms of Hecht [15], Kou <ref> [23] </ref>, and Khedker and Dhamdhere [19], which can all be viewed as linear-time graph-reachability algorithms. - 25 - problem is treated as if it were one large intraprocedural problem, the ow graph is the super-graph, which consists of multiple ow graphs connected by edges from set E 2 . <p> d 2 )) from WorkList [19] for each (m, d 3 ) N # fg (a) such that (n, m) E 0 fg (a) and ((n, d 2 ), (m, d 3 )) E # do [20] Propagate (CompressedEdges, ((a, d 1 ), (m, d 3 )), WorkList) [21] od <ref> [23] </ref> N := - (n, d) N # | n (Start Exit Call Ret) - [24] E := - ((m, d 1 ), (n, d 2 )) | m, n (Start Exit Call Ret) and ((m, d 1 ), (n, d 2 )) CompressedEdges - - ((m, d 1 ), (n, <p> ), (succ 1 (c), d 4 )) into SummaryEdge [17] for each d 3 such that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do [18] Propagate (PathEdge, ((c, d 5 ), (e fg (c) , d 3 )), WorkList) [19] od [21] od <ref> [23] </ref> end case [24] case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) [27] od <p> (( pred 1 (n), d 3 ), (n, d 2 )) (E # SummaryEdge) do [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, d 1 )), RPWorkList) [21] od [22] end case <ref> [23] </ref> case n = s p : [24] for each c callers ( p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges [27] Propagate <p> Our work shows that a large subclass of the problems in the Sharir-Pnueli and Knoop-Steffen frameworks can also be posed as graph-reachability problems. Other work on solving dataow-analysis problems by reducing them to reachability problems has been done by Kou <ref> [23] </ref> and Cooper and Kennedy [8,9]. <p> first building a graphderived from the program's ow graph and the dataow functions to be solvedand then performing a reachability analysis on the graph by propagating simple marks. (This contrasts with standard iterative techniques, which propagate sets of values over the ow graph.) Kou's paper addresses the intraprocedural live-variable problem <ref> [23] </ref>, although his ideas immediately carry over to all the intraprocedural separable problems. Cooper and Kennedy showed how certain ow-insensitive interprocedural dataow-analysis problems could be converted to reachability problems [9,8].
Reference: 24. <author> Landi, W. and Ryder, B .G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference-contexts: ), (s calledProc (n) , d 3 )), WorkList) [20] od [21] for each d 3 such that ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do [22] Propagate (PathEdge, ((s p , d 1 ), (succ 1 (n), d 3 )), WorkList) [23] od <ref> [24] </ref> end case [25] case n = e p : [26] for each c callers ( p) do [27] for each d 4 , d 5 such that ((c, d 4 ), (s p , d 1 )) E # and ((e p , d 2 ), (succ 1 (c), d <p> (a) such that (n, m) E 0 fg (a) and ((n, d 2 ), (m, d 3 )) E # do [20] Propagate (CompressedEdges, ((a, d 1 ), (m, d 3 )), WorkList) [21] od [23] N := - (n, d) N # | n (Start Exit Call Ret) - <ref> [24] </ref> E := - ((m, d 1 ), (n, d 2 )) | m, n (Start Exit Call Ret) and ((m, d 1 ), (n, d 2 )) CompressedEdges - - ((m, d 1 ), (n, d 2 )) E # | (m, n) (E 1 E 2 ) - [25] <p> (c), d 4 )) into SummaryEdge [17] for each d 3 such that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do [18] Propagate (PathEdge, ((c, d 5 ), (e fg (c) , d 3 )), WorkList) [19] od [21] od [23] end case <ref> [24] </ref> case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) [27] od [28] end case <p> (n, d 2 )) (E # SummaryEdge) do [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, d 1 )), RPWorkList) [21] od [22] end case [23] case n = s p : <ref> [24] </ref> for each c callers ( p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges [27] Propagate (RealizablePath, ((c, d 3 ), (x, d <p> The table given below is for the -distributive version of the problem (the may-not-be-aliased problem). The E edge functions, the transfer functions, and the constants B and h are the same as for the may-alias-pairs problem. 11 Landi and Ryder <ref> [24] </ref> gav e an algorithm to find the meet-over-all-valid-paths solution to the may-alias-pairs problem in the presence of local variables and parameters; however, their solution involves non-distributive functions, and thus does not fit into the IFDS framework. - 48 - statement a : = b a : = &x function l
Reference: 25. <author> Linton, M.A., </author> <title> Implementing relational views of programs, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 132-140 (May </month> <year> 1984). </year>
Reference-contexts: (n) , d 3 )), WorkList) [20] od [21] for each d 3 such that ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do [22] Propagate (PathEdge, ((s p , d 1 ), (succ 1 (n), d 3 )), WorkList) [23] od [24] end case <ref> [25] </ref> case n = e p : [26] for each c callers ( p) do [27] for each d 4 , d 5 such that ((c, d 4 ), (s p , d 1 )) E # and ((e p , d 2 ), (succ 1 (c), d 5 )) E <p> [24] E := - ((m, d 1 ), (n, d 2 )) | m, n (Start Exit Call Ret) and ((m, d 1 ), (n, d 2 )) CompressedEdges - - ((m, d 1 ), (n, d 2 )) E # | (m, n) (E 1 E 2 ) - <ref> [25] </ref> return (N , E, C # ) end start, exit, call, and return-site nodes. <p> that ((succ 1 (c), d 4 ), (e fg (c) , d 3 )) PathEdge do [18] Propagate (PathEdge, ((c, d 5 ), (e fg (c) , d 3 )), WorkList) [19] od [21] od [23] end case [24] case n (N p Ret p - s p -) : <ref> [25] </ref> for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) [27] od [28] end case [29] end switch [30] od from WorkList. <p> [19]* Insert (( pred 1 (n), d 3 ), (n, d 2 )) into VisitedEdges [20] Propagate (RealizablePath, (( pred 1 (n), d 3 ), (x, d 1 )), RPWorkList) [21] od [22] end case [23] case n = s p : [24] for each c callers ( p) do <ref> [25] </ref> for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges [27] Propagate (RealizablePath, ((c, d 3 ), (x, d 1 )), RPWorkList) [28] od [30] end case
Reference: 26. <author> Masinter, L.M., </author> <title> Global program analysis in an interactive environment, </title> <type> Tech. Rep. </type> <institution> SSL-80-1, Xerox Palo Alto Research Center, Palo Alto, </institution> <note> CA (January 1980). </note>
Reference-contexts: od [21] for each d 3 such that ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do [22] Propagate (PathEdge, ((s p , d 1 ), (succ 1 (n), d 3 )), WorkList) [23] od [24] end case [25] case n = e p : <ref> [26] </ref> for each c callers ( p) do [27] for each d 4 , d 5 such that ((c, d 4 ), (s p , d 1 )) E # and ((e p , d 2 ), (succ 1 (c), d 5 )) E # do [28] if ((c, d 4 <p> From these, answers for the nodes of the full problem are determined. (See also Figure 7.) - 27 - function FindRealizablePaths () returns set of edges begin <ref> [26] </ref> RealizablePath := [27] WorkList := [28] for each (s main , c) C # do [29] Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList [31] od [32] while WorkList do [33] Select and remove an <p> d 5 ), (e fg (c) , d 3 )), WorkList) [19] od [21] od [23] end case [24] case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do <ref> [26] </ref> Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) [27] od [28] end case [29] end switch [30] od from WorkList. <p> 1 (n), d 3 ), (x, d 1 )), RPWorkList) [21] od [22] end case [23] case n = s p : [24] for each c callers ( p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do <ref> [26] </ref>* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges [27] Propagate (RealizablePath, ((c, d 3 ), (x, d 1 )), RPWorkList) [28] od [30] end case [31] case n (N p Ret p - s p -) : [32] for each (m, d 3 ) such <p> [52]* return (ReachableNodes ) end The lines changed from Figure 11 are marked with *. - 38 - During a given inv ocation of IsMemberOfSolution, the algorithm uses the sets VisitedNodes and VisitedEdges to keep track of all nodes and edges visited by IsMemberOfSolution itself (see lines [4], [7], [19], <ref> [26] </ref>, and [33]). (Nodes and edges visited by BackwardTabulateSLRPs are not recorded in these sets; as pointed out above, it is not the time spent in BackwardTabulateSLRPs that prevents the Demand-Tabulation Algorithm from having the same-total-cost property with respect to the Tabulation Algorithm.) IsMemberOfSolution also collects the set of visited nodes
Reference: 27. <author> Reps, T., </author> <title> Solving demand versions of interprocedural analysis problems, </title> <type> Unpublished report, </type> <institution> Datalogisk Institut, University of Copen-hagen, Copenhagen, </institution> <address> Denmark (October 1993). </address>
Reference-contexts: ((n, d 2 ), (succ 1 (n), d 3 )) (E # SummaryEdge) do [22] Propagate (PathEdge, ((s p , d 1 ), (succ 1 (n), d 3 )), WorkList) [23] od [24] end case [25] case n = e p : [26] for each c callers ( p) do <ref> [27] </ref> for each d 4 , d 5 such that ((c, d 4 ), (s p , d 1 )) E # and ((e p , d 2 ), (succ 1 (c), d 5 )) E # do [28] if ((c, d 4 ), (succ 1 (c), d 5 )) SummaryEdge <p> This assumption permits us to assume that the time required to identify the &lt;d 4 , d 5 &gt; pairs used in the for-loop on line <ref> [27] </ref> is proportional to the number of such pairs. One way to satisfy assumptions (i)-(v) is to use arrays to support unit-time membership testing, and one or more linked-lists for each N # node (to support iteration over predecessors and successors). <p> From these, answers for the nodes of the full problem are determined. (See also Figure 7.) - 27 - function FindRealizablePaths () returns set of edges begin [26] RealizablePath := <ref> [27] </ref> WorkList := [28] for each (s main , c) C # do [29] Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList [31] od [32] while WorkList do [33] Select and remove an edge ((s main <p> In other words, although the single-sink realizable-path reachability problem is a demand problem the Horwitz-Reps-Binkley algorithm is not a true demand algorithm for that problem. One way to obtain an improved demand algorithm for the single-sink realizable-path reachability problem has been described by Reps <ref> [27] </ref>. Another demand algorithm for this problem has been developed by Rosay [30]. The next section presents a third demand algorithm. Because Reps's and Rosay's algorithms are based on the Horwitz-Reps-Binkley algorithm, their running times are asymptotically worse than the running time of the algorithm presented in Section 6.1. 6.1. <p> od [23] end case [24] case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) <ref> [27] </ref> od [28] end case [29] end switch [30] od from WorkList. All summary edges found are accumulated in set SummaryEdge. (See also Figure 11.) - 33 - Lines [5]-[7] Lines [8]-[10] Line [16] Lines [17]-[19] Lines [25]-[27] - 34 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [31] <p> case [23] case n = s p : [24] for each c callers ( p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges <ref> [27] </ref> Propagate (RealizablePath, ((c, d 3 ), (x, d 1 )), RPWorkList) [28] od [30] end case [31] case n (N p Ret p - s p -) : [32] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [33]* Insert
Reference: 28. <author> Reps, T., </author> <title> Solving demand versions of interprocedural analysis problems, pp. </title> <booktitle> 389-403 in Proceedings of the Fifth International Conference on Compiler Construction, </booktitle> <address> (Edinburgh, Scotland, </address> <month> April 7-9, </month> <year> 1994), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 786, </volume> <editor> ed. P. Fritzson, </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1994). </address>
Reference-contexts: = e p : [26] for each c callers ( p) do [27] for each d 4 , d 5 such that ((c, d 4 ), (s p , d 1 )) E # and ((e p , d 2 ), (succ 1 (c), d 5 )) E # do <ref> [28] </ref> if ((c, d 4 ), (succ 1 (c), d 5 )) SummaryEdge then [29] Insert ((c, d 4 ), (succ 1 (c), d 5 )) into SummaryEdge [30] for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do [31] Propagate (PathEdge, <p> For each summary edge ((c, d 4 ), (succ 1 (c), d 5 )), the conditional statement on lines <ref> [28] </ref>-[33] will be executed some number of times (on different iterations of the loop on lines [14]-[43]). In particular, line [28] will be executed every time the Tabulation Algorithm finds a three-edge path of the form [((c, d 4 ), (s p , d 1 )), ((s p , d 1 ), (e p , d 2 )), ((e p , d 2 ), (succ 1 as shown in the diagram <p> When we consider the set of all summary edges at a given call site c: - ((c, d 4 ), (succ 1 (c), d 5 )) -, the executions of line <ref> [28] </ref> can be placed in three categories: d 4 L and d 5 L There are at most D 2 choices for a &lt;d 4 , d 5 &gt; pair, and for each such pair at most B 2 possible three-edge paths of the form (). d 4 = L and <p> Thus, the total cost of all executions of line <ref> [28] </ref> is bounded by O (Call B 2 2 Because of the test on line [28], the code on lines [29]-[32] will be executed exactly once for each possible summary edge. In particular, for each summary edge the cost of the loop on lines [30]-[32] is bounded by O (D). <p> Thus, the total cost of all executions of line <ref> [28] </ref> is bounded by O (Call B 2 2 Because of the test on line [28], the code on lines [29]-[32] will be executed exactly once for each possible summary edge. In particular, for each summary edge the cost of the loop on lines [30]-[32] is bounded by O (D). <p> For locally separable problems, we can give a better bound on the number of times line <ref> [28] </ref> is executed. Again, we consider the set of all summary edges at a given call site c: - ((c, d 4 ), (succ 1 (c), d 5 )) -, and place the executions of line [28] in three categories: d 4 L and d 5 L Because summary edges represent <p> separable problems, we can give a better bound on the number of times line <ref> [28] </ref> is executed. Again, we consider the set of all summary edges at a given call site c: - ((c, d 4 ), (succ 1 (c), d 5 )) -, and place the executions of line [28] in three categories: d 4 L and d 5 L Because summary edges represent same-level realizable paths, it must be that d 4 = d 5 , and thus there are at most D choices for a &lt;d 4 , d 5 &gt; pair. <p> Thus, the total number of executions of line <ref> [28] </ref> is bounded by O (Call D). Again, because of the test on line [28], the code on lines [29]-[32] will be executed exactly once for each pos sible summary edge, but for locally separable problems there will be at most two calls on Propagate generated at line [31]: [31] Propagate <p> Thus, the total number of executions of line <ref> [28] </ref> is bounded by O (Call D). Again, because of the test on line [28], the code on lines [29]-[32] will be executed exactly once for each pos sible summary edge, but for locally separable problems there will be at most two calls on Propagate generated at line [31]: [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), <p> From these, answers for the nodes of the full problem are determined. (See also Figure 7.) - 27 - function FindRealizablePaths () returns set of edges begin [26] RealizablePath := [27] WorkList := <ref> [28] </ref> for each (s main , c) C # do [29] Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList [31] od [32] while WorkList do [33] Select and remove an edge ((s main , c), (n, <p> end case [24] case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) [27] od <ref> [28] </ref> end case [29] end switch [30] od from WorkList. <p> callers ( p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges [27] Propagate (RealizablePath, ((c, d 3 ), (x, d 1 )), RPWorkList) <ref> [28] </ref> od [30] end case [31] case n (N p Ret p - s p -) : [32] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [33]* Insert ((m, d 3 ), (n, d 2 )) into VisitedEdges [34] Propagate <p> This idea falls out naturally from the algorithms of Sharir and Pnueli. Logic-Programming Implementations of Interprocedural Dataow-Analysis Algorithms The work described in the present paper was originally motivated by the desire to generalize to a broader class of dataow-analysis problems the ideas described by Reps in <ref> [28] </ref>. <p> Suffice it to say that, using the transformation of IFDS problems to realizable-path reachability problems described in Section - 43 - 3.2, the algorithms from Sections 4, 5, 6, and 7 have implementations as logic programs similar to the algorithms given in <ref> [28] </ref>. Thus, the work reported in this paper shows how to extend the logic-programming-based approach to implementing dataow-analysis algorithms to all IFDS problems. One advantage of the approach adopted in the present paper is that it makes our results more accessible to people who implement in imperative programming languages. <p> Because they deal only with ow-insensitive problems, the solution method involves ordinary reachability rather than the more difficult question of reachability along realizable paths. Demand Dataow Analysis With the exception of the paper by Reps discussed above <ref> [28] </ref>, previous work on demand-driven dataow analysis has dealt only with the intraprocedural case [1,35]. The work reported in the present paper complements previous work on the intraprocedural case in the sense that our approach to obtaining algorithms for demand-driven dataow-analysis problems applies equally well to intraprocedural dataow analysis.
Reference: 29. <author> Rohmer, R., Lescoeur, R., and Kersit, J.-M., </author> <title> The Alexander method, a technique for the processing of recursive axioms in deductive databases, </title> <journal> New Generation Computing 4(3) pp. </journal> <month> 273-285 </month> <year> (1986). </year>
Reference-contexts: The configurations that are used by the Tabulation Algorithm to deduce the existence of additional path edges are depicted in Figure 5; the five diagrams of Figure 5 correspond to lines [18]-[20], [21]-[23], <ref> [29] </ref>, [30]-[32], and [38]-[40] of Figure 4. In Figure 5, the bold dotted arrows represent edges that are inserted into set PathEdge if they were not previously in that set. <p> each d 4 , d 5 such that ((c, d 4 ), (s p , d 1 )) E # and ((e p , d 2 ), (succ 1 (c), d 5 )) E # do [28] if ((c, d 4 ), (succ 1 (c), d 5 )) SummaryEdge then <ref> [29] </ref> Insert ((c, d 4 ), (succ 1 (c), d 5 )) into SummaryEdge [30] for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) <p> 2 ), (m, d 3 )) E # do [39] Propagate (PathEdge, ((s p , d 1 ), (m, d 3 )), WorkList) [40] od [41] end case [42] end switch [43] od same-level realizable paths exist in G # IP . - 17 - Lines [18]-[20] Lines [21]-[23] Line <ref> [29] </ref> Lines [30]-[32] Lines [38]-[40] wardTabulateSLRPs: [11] X n : = - d 2 D fg (n) | $ d 1 (D fg (n) - L -) such that ((s fg (n) , d 1 ), (n, d 2 )) PathEdge - At first glance, this may not appear to be <p> executed every time the Tabulation Algorithm finds a three-edge path of the form [((c, d 4 ), (s p , d 1 )), ((s p , d 1 ), (e p , d 2 )), ((e p , d 2 ), (succ 1 as shown in the diagram marked Line <ref> [29] </ref> of Figure 5. <p> From these, answers for the nodes of the full problem are determined. (See also Figure 7.) - 27 - function FindRealizablePaths () returns set of edges begin [26] RealizablePath := [27] WorkList := [28] for each (s main , c) C # do <ref> [29] </ref> Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList [31] od [32] while WorkList do [33] Select and remove an edge ((s main , c), (n, d 1 )) from WorkList [34] switch n [35] case <p> case n (N p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) [27] od [28] end case <ref> [29] </ref> end switch [30] od from WorkList.
Reference: 30. <author> Rosay, G., </author> <type> Personal communication. </type> <month> October </month> <year> 1993. </year>
Reference-contexts: In Figure 5, the bold dotted arrows represent edges that are inserted into set PathEdge if they were not previously in that set. It is important to note the role of lines <ref> [30] </ref>-[32] of Figure 4, which are executed only when a new summary edge is discovered: [30] for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) [32] od Unlike edges in E # , edges are inserted into SummaryEdge on-the-y. <p> , d 1 )) E # and ((e p , d 2 ), (succ 1 (c), d 5 )) E # do [28] if ((c, d 4 ), (succ 1 (c), d 5 )) SummaryEdge then [29] Insert ((c, d 4 ), (succ 1 (c), d 5 )) into SummaryEdge <ref> [30] </ref> for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) [32] od [34] od [36] end case [37] case n (N p Call p <p> nodes of the full problem are determined. (See also Figure 7.) - 27 - function FindRealizablePaths () returns set of edges begin [26] RealizablePath := [27] WorkList := [28] for each (s main , c) C # do [29] Insert ((s main , c), (s main , c)) into RealizablePath <ref> [30] </ref> Insert ((s main , c), (s main , c)) into WorkList [31] od [32] while WorkList do [33] Select and remove an edge ((s main , c), (n, d 1 )) from WorkList [34] switch n [35] case n Call p : [36] for each d 2 such that ((n, <p> One way to obtain an improved demand algorithm for the single-sink realizable-path reachability problem has been described by Reps [27]. Another demand algorithm for this problem has been developed by Rosay <ref> [30] </ref>. The next section presents a third demand algorithm. Because Reps's and Rosay's algorithms are based on the Horwitz-Reps-Binkley algorithm, their running times are asymptotically worse than the running time of the algorithm presented in Section 6.1. 6.1. <p> p Ret p - s p -) : [25] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [26] Propagate (PathEdge, ((m, d 3 ), (e p , d 1 )), WorkList) [27] od [28] end case [29] end switch <ref> [30] </ref> od from WorkList. <p> p) do [25] for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges [27] Propagate (RealizablePath, ((c, d 3 ), (x, d 1 )), RPWorkList) [28] od <ref> [30] </ref> end case [31] case n (N p Ret p - s p -) : [32] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [33]* Insert ((m, d 3 ), (n, d 2 )) into VisitedEdges [34] Propagate (RealizablePath, ((m,
Reference: 31. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data ow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones, </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: 1. Introduction This paper shows how to find precise (i.e., meet-over-all-valid-paths) solutions to a large class of interprocedural dataow-analysis problems in polynomial time. We giv e several efficient algorithms for solving a large subclass of interprocedural dataow-analysis problems in the framework proposed by Sharir and Pnueli <ref> [31] </ref>. Our techniques also apply to the extension of the Sharir-Pnueli framework proposed by Knoop and Steffen, which covers programs in which recursive procedures may have local variables and call-by-value parameters [21]. <p> Appendix B provides an index of the terms and notation used in the paper. 2. The IFDS Framework for Distributive Interprocedural Dataow-Analysis Problems The IFDS framework is a variant of Sharir and Pnueli's functional approach to interprocedural dataow analysis <ref> [31] </ref>, with an extension similar to the one given by Knoop and Steffen in order to handle programs in which recursive procedures may have local variables and parameters [21]. <p> It is important to note the role of lines [30]-[32] of Figure 4, which are executed only when a new summary edge is discovered: [30] for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do <ref> [31] </ref> Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) [32] od Unlike edges in E # , edges are inserted into SummaryEdge on-the-y. The purpose of line [31] is to restart the processing that finds same-level realizable paths from (s fg (c) , <p> such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do <ref> [31] </ref> Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) [32] od Unlike edges in E # , edges are inserted into SummaryEdge on-the-y. The purpose of line [31] is to restart the processing that finds same-level realizable paths from (s fg (c) , d 3 ) as if summary edge ((c, d 4 ), (succ 1 been in place all along. <p> # do [28] if ((c, d 4 ), (succ 1 (c), d 5 )) SummaryEdge then [29] Insert ((c, d 4 ), (succ 1 (c), d 5 )) into SummaryEdge [30] for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do <ref> [31] </ref> Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) [32] od [34] od [36] end case [37] case n (N p Call p - e p -) : [38] for each (m, d 3 ) such that ((n, d 2 ), (m, d <p> Propagate is called from four places in procedure ForwardTabulateSLRPs (lines [19], [22], <ref> [31] </ref>, and [39]). In each case, we can demonstrate that if the call on Propagate actually does insert a new edge into PathEdge, then there is a realizable path q ## and a same-level realizable path s ## as required to re-establish the invariant. <p> For example, in the call in line [39], q ## # extended with edge ((n, d 2 ), (m, d 3 )), and s ## # extended with edge ((n, d 2 ), (m, d 3 )). For the call on Propagate in line <ref> [31] </ref>, the argument is more subtle. <p> Then there will be a call at line <ref> [31] </ref> of the form Propagate (PathEdge, ((s fg (n) , d), (n, d)), WorkList), (ii) Suppose that at the time edge ((s fg (n j + 1 ) , d), (n j + 1 , d j + 1 )) is processed, ((s fg (c) , d), (c, d)) PathEdge. <p> Again, because of the test on line [28], the code on lines [29]-[32] will be executed exactly once for each pos sible summary edge, but for locally separable problems there will be at most two calls on Propagate generated at line <ref> [31] </ref>: [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList). In one call, d 3 = d 5 ; in the other, d 3 = L. <p> Again, because of the test on line [28], the code on lines [29]-[32] will be executed exactly once for each pos sible summary edge, but for locally separable problems there will be at most two calls on Propagate generated at line <ref> [31] </ref>: [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList). In one call, d 3 = d 5 ; in the other, d 3 = L. <p> 27 - function FindRealizablePaths () returns set of edges begin [26] RealizablePath := [27] WorkList := [28] for each (s main , c) C # do [29] Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList <ref> [31] </ref> od [32] while WorkList do [33] Select and remove an edge ((s main , c), (n, d 1 )) from WorkList [34] switch n [35] case n Call p : [36] for each d 2 such that ((n, d 1 ), (s calledProc (n) , d 2 )) E # <p> All summary edges found are accumulated in set SummaryEdge. (See also Figure 11.) - 33 - Lines [5]-[7] Lines [8]-[10] Line [16] Lines [17]-[19] Lines [25]-[27] - 34 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin <ref> [31] </ref> RealizablePath := - ((x, d 1 ), (x, d 1 )) - [32] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [33] while RPWorkList do [34] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [35] switch n [36] case <p> for each d 3 such that ((c, d 3 ), (s p , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges [27] Propagate (RealizablePath, ((c, d 3 ), (x, d 1 )), RPWorkList) [28] od [30] end case <ref> [31] </ref> case n (N p Ret p - s p -) : [32] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [33]* Insert ((m, d 3 ), (n, d 2 )) into VisitedEdges [34] Propagate (RealizablePath, ((m, d 3 ), <p> In the remainder of this section, we summarize how these ideas relate to previous work. Previous Interprocedural Dataow-Analysis Frameworks The IFDS framework is based on earlier interprocedural dataow-analysis frameworks defined by Sharir and Pnueli <ref> [31] </ref> and Knoop and Steffen [21]. <p> to the called procedure and therefore cannot be affected by the callwith the information about global variables that holds at the end of the called procedure.) The IFDS problems can be solved by a number of previous algorithms, including the elimination, iterative, and call-strings algorithms given by Sharir and Pnueli <ref> [31] </ref>. However, for general IFDS problems both the iterative and call-strings algorithms can take e xponential time in the worst case. Knoop and Steffen give an a lgo-rithm similar to Sharir and Pnueli's elimination algorithm [21]. <p> Knoop and Steffen give an a lgo-rithm similar to Sharir and Pnueli's elimination algorithm [21]. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in <ref> [31] </ref> and [21]. However, even i f representation relations (as defined in Section 3.1) are used, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather than element-wise, for distributive and h-sparse problems, they are not as efficient as the algorithms given in Sections 4 and 6. <p> Dataow Analysis and Graph-Reachability Problems Many dataow-analysis algorithms can be classified as either iterative algorithms [32,20], elimination algorithms [7,13], or reachability algorithms [8,9,6]. Sharir and Pnueli presented two iterative algorithms for the problems in their framework <ref> [31] </ref>. Our work shows that a large subclass of the problems in the Sharir-Pnueli and Knoop-Steffen frameworks can also be posed as graph-reachability problems. Other work on solving dataow-analysis problems by reducing them to reachability problems has been done by Kou [23] and Cooper and Kennedy [8,9].
Reference: 32. <author> Vyssotsky, V. a nd Wegner, P., </author> <title> A graph theoretical Fortran source language analyzer, </title> <type> Unpublished report, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ (1963). </address> <note> (As cited in Aho, </note> <author> Sethi, and Ullman, </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> - <month> 51 </month> - 
Reference-contexts: Figure 4, which are executed only when a new summary edge is discovered: [30] for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) <ref> [32] </ref> od Unlike edges in E # , edges are inserted into SummaryEdge on-the-y. <p> Insert ((c, d 4 ), (succ 1 (c), d 5 )) into SummaryEdge [30] for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) <ref> [32] </ref> od [34] od [36] end case [37] case n (N p Call p - e p -) : [38] for each (m, d 3 ) such that ((n, d 2 ), (m, d 3 )) E # do [39] Propagate (PathEdge, ((s p , d 1 ), (m, d 3 <p> function FindRealizablePaths () returns set of edges begin [26] RealizablePath := [27] WorkList := [28] for each (s main , c) C # do [29] Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList [31] od <ref> [32] </ref> while WorkList do [33] Select and remove an edge ((s main , c), (n, d 1 )) from WorkList [34] switch n [35] case n Call p : [36] for each d 2 such that ((n, d 1 ), (s calledProc (n) , d 2 )) E # do [37] <p> summary edges found are accumulated in set SummaryEdge. (See also Figure 11.) - 33 - Lines [5]-[7] Lines [8]-[10] Line [16] Lines [17]-[19] Lines [25]-[27] - 34 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [31] RealizablePath := - ((x, d 1 ), (x, d 1 )) - <ref> [32] </ref> RPWorkList := - ((x, d 1 ), (x, d 1 )) - [33] while RPWorkList do [34] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [35] switch n [36] case n Ret p : [37] WorkList := [38] for each d 3 such <p> , d 2 )) E # do [26]* Insert ((c, d 3 ), (s p , d 2 )) into VisitedEdges [27] Propagate (RealizablePath, ((c, d 3 ), (x, d 1 )), RPWorkList) [28] od [30] end case [31] case n (N p Ret p - s p -) : <ref> [32] </ref> for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [33]* Insert ((m, d 3 ), (n, d 2 )) into VisitedEdges [34] Propagate (RealizablePath, ((m, d 3 ), (x, d 1 )), RPWorkList) [35] od [36] end case [37] end
Reference: 33. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: set of edges begin [26] RealizablePath := [27] WorkList := [28] for each (s main , c) C # do [29] Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList [31] od [32] while WorkList do <ref> [33] </ref> Select and remove an edge ((s main , c), (n, d 1 )) from WorkList [34] switch n [35] case n Call p : [36] for each d 2 such that ((n, d 1 ), (s calledProc (n) , d 2 )) E # do [37] Propagate (RealizablePath, ((s main <p> 33 - Lines [5]-[7] Lines [8]-[10] Line [16] Lines [17]-[19] Lines [25]-[27] - 34 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [31] RealizablePath := - ((x, d 1 ), (x, d 1 )) - [32] RPWorkList := - ((x, d 1 ), (x, d 1 )) - <ref> [33] </ref> while RPWorkList do [34] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [35] switch n [36] case n Ret p : [37] WorkList := [38] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 <p> VisitedEdges [27] Propagate (RealizablePath, ((c, d 3 ), (x, d 1 )), RPWorkList) [28] od [30] end case [31] case n (N p Ret p - s p -) : [32] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do <ref> [33] </ref>* Insert ((m, d 3 ), (n, d 2 )) into VisitedEdges [34] Propagate (RealizablePath, ((m, d 3 ), (x, d 1 )), RPWorkList) [35] od [36] end case [37] end switch [38]* fi [40]* /* Find all reachable nodes that are reachable along visited edges */ [41]* WorkList := ReachableNodes <p> (ReachableNodes ) end The lines changed from Figure 11 are marked with *. - 38 - During a given inv ocation of IsMemberOfSolution, the algorithm uses the sets VisitedNodes and VisitedEdges to keep track of all nodes and edges visited by IsMemberOfSolution itself (see lines [4], [7], [19], [26], and <ref> [33] </ref>). (Nodes and edges visited by BackwardTabulateSLRPs are not recorded in these sets; as pointed out above, it is not the time spent in BackwardTabulateSLRPs that prevents the Demand-Tabulation Algorithm from having the same-total-cost property with respect to the Tabulation Algorithm.) IsMemberOfSolution also collects the set of visited nodes that are
Reference: 34. <author> Yellin, </author> <title> D.M., Speeding up dynamic transitive closure for bounded degree graphs, </title> <note> Acta Informatica 30 pp. </note> <month> 369-384 </month> <year> (1993). </year>
Reference-contexts: d 4 ), (succ 1 (c), d 5 )) into SummaryEdge [30] for each d 3 such that ((s fg (c) , d 3 ), (c, d 4 )) PathEdge do [31] Propagate (PathEdge, ((s fg (c) , d 3 ), (succ 1 (c), d 5 )), WorkList) [32] od <ref> [34] </ref> od [36] end case [37] case n (N p Call p - e p -) : [38] for each (m, d 3 ) such that ((n, d 2 ), (m, d 3 )) E # do [39] Propagate (PathEdge, ((s p , d 1 ), (m, d 3 )), WorkList) <p> the Tabula tion Algorithm is bounded by O (Call B 2 2 + Call D 3 To bound the total cost of the closure steps, we use a variation on the argument used by Yellin to obtain a bound for the running time of an algorithm for dynamic transitive closure <ref> [34] </ref>. 3 The essential observation is that there are only a certain number of attempts the Tabulation Algorithm makes to acquire a path edge ((s p , d 1 ), (n, d 2 )). <p> c) C # do [29] Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList [31] od [32] while WorkList do [33] Select and remove an edge ((s main , c), (n, d 1 )) from WorkList <ref> [34] </ref> switch n [35] case n Call p : [36] for each d 2 such that ((n, d 1 ), (s calledProc (n) , d 2 )) E # do [37] Propagate (RealizablePath, ((s main , c), (s calledProc (n) , d 2 )), WorkList) [38] od [39] for each d <p> Lines [8]-[10] Line [16] Lines [17]-[19] Lines [25]-[27] - 34 - function IsMemberOfSolution (x, d 1 ) returns Boolean begin [31] RealizablePath := - ((x, d 1 ), (x, d 1 )) - [32] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [33] while RPWorkList do <ref> [34] </ref> Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList [35] switch n [36] case n Ret p : [37] WorkList := [38] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do <p> RPWorkList) [28] od [30] end case [31] case n (N p Ret p - s p -) : [32] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [33]* Insert ((m, d 3 ), (n, d 2 )) into VisitedEdges <ref> [34] </ref> Propagate (RealizablePath, ((m, d 3 ), (x, d 1 )), RPWorkList) [35] od [36] end case [37] end switch [38]* fi [40]* /* Find all reachable nodes that are reachable along visited edges */ [41]* WorkList := ReachableNodes [42]* while WorkList do [43]* Select and remove a node (m, d)
Reference: 35. <author> Zadeck, F.K., </author> <title> Incremental data ow analysis in a structured program editor, </title> <booktitle> Proceedings of the SIGPLAN 84 Symposium on Compiler Construction, </booktitle> <address> (Montreal, Can., </address> <month> June 20-22, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(6) pp. </journal> <month> 132-143 (June </month> <year> 1984). </year>
Reference-contexts: do [29] Insert ((s main , c), (s main , c)) into RealizablePath [30] Insert ((s main , c), (s main , c)) into WorkList [31] od [32] while WorkList do [33] Select and remove an edge ((s main , c), (n, d 1 )) from WorkList [34] switch n <ref> [35] </ref> case n Call p : [36] for each d 2 such that ((n, d 1 ), (s calledProc (n) , d 2 )) E # do [37] Propagate (RealizablePath, ((s main , c), (s calledProc (n) , d 2 )), WorkList) [38] od [39] for each d 2 such that <p> ) returns Boolean begin [31] RealizablePath := - ((x, d 1 ), (x, d 1 )) - [32] RPWorkList := - ((x, d 1 ), (x, d 1 )) - [33] while RPWorkList do [34] Select and remove an edge ((n, d 2 ), (x, d 1 )) from RPWorkList <ref> [35] </ref> switch n [36] case n Ret p : [37] WorkList := [38] for each d 3 such that ((e calledProc (pred 1 (n)) , d 3 ), (n, d 2 )) E # do [39] Propagate (PathEdge, ((e calledProc (pred 1 (n)) , d 3 ), (e calledProc (pred 1 <p> p - s p -) : [32] for each (m, d 3 ) such that ((m, d 3 ), (n, d 2 )) E # do [33]* Insert ((m, d 3 ), (n, d 2 )) into VisitedEdges [34] Propagate (RealizablePath, ((m, d 3 ), (x, d 1 )), RPWorkList) <ref> [35] </ref> od [36] end case [37] end switch [38]* fi [40]* /* Find all reachable nodes that are reachable along visited edges */ [41]* WorkList := ReachableNodes [42]* while WorkList do [43]* Select and remove a node (m, d) from WorkList [44]* for each successor (n, d) of (m, d) such
References-found: 35

