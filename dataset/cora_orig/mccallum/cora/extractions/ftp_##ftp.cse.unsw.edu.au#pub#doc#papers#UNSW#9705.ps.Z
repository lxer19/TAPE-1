URL: ftp://ftp.cse.unsw.edu.au/pub/doc/papers/UNSW/9705.ps.Z
Refering-URL: http://www.cse.unsw.edu.au/school/research/tr.html
Root-URL: http://www.cse.unsw.edu.au
Email: E-mail: G.Heiser@unsw.edu.au,  
Title: Resource Management in the Mungi Single-Address-Space Operating System  
Author: Gernot Heiser, Fondy Lam and Stephen Russell 
Date: August 1997  
Note: UNSW-CSE-TR-9705  
Web: WWW: http://www.cse.unsw.edu.au/ disy  
Address: NSW, Sydney 2052, Australia  Sydney 2052, Australia  
Affiliation: Department of Computer Systems School of Computer Science and Engineering, University of  School of Computer Science and Engineering The University of New South Wales  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Gernot Heiser, Kevin Elphinstone, Stephen Russell, and Jerry Vochteloo. Mungi: </author> <title> A distributed single address-space operating system. </title> <booktitle> In Proceedings of the 17th Australasian Computer Science Conference, </booktitle> <pages> pages 27180, </pages> <address> Christchurch, New Zealand, </address> <month> January </month> <year> 1994. </year> <note> REFERENCES 15 </note>
Reference-contexts: This paper examines the problem of managing the allocation of secondary storage. It does so in the specific context of the Mungi operating system developed at UNSW. 2 Overview of Mungi Mungi <ref> [1] </ref> is a single-address-space operating system (SASOS); i.e., all processes throughout all computing nodes in the system share the same virtual address space. That address space contains all data, transient as well as persistent. Within this single-level store data are identified through their (64-bit) addresses.
Reference: [2] <author> M. Anderson, Ronald Pose, and Chris S. Wallace. </author> <title> A password-capability system. </title> <journal> The Computer Journal, </journal> <volume> 29:18, </volume> <year> 1986. </year>
Reference-contexts: the past to use an economic approach for internal resource allocation in a context where real money is not necessarily an issue. 3.4.1 Money and rent in the Monash Password Capability System Possibly the earliest use of an economic model for resource management was in the Monash Password Capability System <ref> [2] </ref>. That system charges size-dependent rent for each object, and defines an object as garbage when it cannot pay its rent. To this end, every object is associated with some amount of money, where money is defined as a transferable right to use system services.
Reference: [3] <author> Sape J. Mullender and Andrew S. Tanenbaum. </author> <title> The design of a capability-based distributed operating system. </title> <journal> The Computer Journal, </journal> <volume> 29:289299, </volume> <year> 1986. </year>
Reference-contexts: capability system is also used to purchase services other than storage, in particular processor time. 1 Note that this problem cannot be solved by garbage collection: The files are not garbage, as they are linked to A's directory. 6 3 PREVIOUS APPROACHES 3.4.2 Amoeba's bank accounts Amoeba's resource management system <ref> [3] </ref> was developed at about the same time as that of the Password Capability System. It is also based on the idea that money is used to pay for resources.
Reference: [4] <author> B. Clifford Neumann. </author> <title> Proxy-based authorisation and accounting for distributed systems. </title> <booktitle> In Proceedings of the 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 283291, </pages> <address> Pittsburgh, Penn, USA, </address> <month> May </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: The client needs to trust the server to provide as much of a resource as the client has paid for. A similar system was presented by Neuman <ref> [4] </ref>. 3.4.3 Drexler and Miller's market model Drexler and Miller [5] present a detailed discussion of various ecological models for resource management. Their models of storage management envision storage providers optimised to maximise storage usage, by adjusting the price of storage to market demand, determined by a bidding process.
Reference: [5] <author> K. Eric Drexler and Mark S. Miller. </author> <title> Incentive engineering for computational resource management. </title> <editor> In Bernardo A. Huberman, editor, </editor> <booktitle> The Ecology of Computation, </booktitle> <pages> pages 231266. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: The client needs to trust the server to provide as much of a resource as the client has paid for. A similar system was presented by Neuman [4]. 3.4.3 Drexler and Miller's market model Drexler and Miller <ref> [5] </ref> present a detailed discussion of various ecological models for resource management. Their models of storage management envision storage providers optimised to maximise storage usage, by adjusting the price of storage to market demand, determined by a bidding process.
Reference: [6] <author> Jeffrey S. Chase, Henry M. Levy, Michael J. Feeley, and Edward D. Lazowska. </author> <title> Sharing and protection in a single-address-space operating system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12:271307, </volume> <month> November </month> <year> 1994. </year>
Reference-contexts: However, the main drawback for our purposes is that the system does not operate off-line, but requires accounting operations whenever storage is allocated or freed. 3.4.4 Opal's resource groups The Opal SASOS <ref> [6] </ref> uses a form of bank accounts called resource groups. Objects are created with a reference to a resource group, which is charged for the resource use.
Reference: [7] <author> Carl A. Waldspurger and William E. Weihl. </author> <title> An object-oriented framework for modular resource management. </title> <booktitle> In Proceedings of the 5th International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 138143, </pages> <address> Seattle, WA, USA, </address> <month> October </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: Objects are created with a reference to a resource group, which is charged for the resource use. This is combined with reference 7 counting based on entities explicitly registering an interest in a particular object; objects are deleted when that reference count becomes zero. 3.4.5 Min-funding revocation Waldspurger <ref> [7] </ref> presents the min-funding revocation algorithm, where agents hold tickets which represent relative rights to resources, that is the amount of a resource a particular ticket can buy depends on the value of the ticket as well as on the total value of tickets which are bidding for the particular resource.
Reference: [8] <author> Fondy F.Y. Lam. </author> <title> Resource accounting in Mungi. </title> <type> BE thesis, </type> <institution> School of Computer Science and Engineering, University of NSW, </institution> <address> Sydney 2052, Australia, </address> <year> 1995. </year>
Reference-contexts: In particular we do not want to require users to maintain explicit reference to persistent objects, as these tend to be unreliable (due to cycles, or users forgetting references). 4.2 Basic model Our model <ref> [8] </ref> is also based on bank accounts. Whenever an object is created, a reference to a bank account, which is to pay for the object's backing store, is supplied to the system and recorded in the OT.
Reference: [9] <author> Jerry Vochteloo, Kevin Elphinstone, Stephen Russell, and Gernot Heiser. </author> <title> Protection domain extensions in Mungi. </title> <booktitle> In Proceedings of the 5th International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 161165, </pages> <address> Seattle, WA, USA, </address> <month> October </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: The system only confirms that a valid bank account has been supplied. This is like validating access to any other object; validation information is cached and hence validations are very fast <ref> [9, 10] </ref>. Object creation (or destruction) is therefore not slowed down significantly by accounting. Furthermore, no accounting operations are performed when backing store is allocated to, or removed from, an object. <p> There is a special root account with infinite income from which all first-order accounts receive their income. The paymaster on each run first 4 Both flags are part of the access information kept in the validation cache [10]. 5 This call uses PDX, Mungi's protected procedure call mechanism <ref> [9] </ref>, to execute in the owner's protection context. 5.3 Lost and found objects 13 typedef struct - address object; int size; - BA_charge; typedef struct - Cap_t parent; float salary; float balance; time_t last_deposit; float alert_thresh; void (*alert)(); float total_charge; int n_charges; BA_charge charges []; - Bank_account; updates the timestamp of
Reference: [10] <author> Gernot Heiser, Kevin Elphinstone, Jerry Vochteloo, Stephen Russell, and Jochen Liedtke. </author> <title> Implementation and performance of the Mungi single-address-space operating system. </title> <institution> School of Computer Science and Engineering Report 9704, University of NSW, University of NSW, </institution> <address> Sydney 2052, Australia, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: The system only confirms that a valid bank account has been supplied. This is like validating access to any other object; validation information is cached and hence validations are very fast <ref> [9, 10] </ref>. Object creation (or destruction) is therefore not slowed down significantly by accounting. Furthermore, no accounting operations are performed when backing store is allocated to, or removed from, an object. <p> There is a special root account with infinite income from which all first-order accounts receive their income. The paymaster on each run first 4 Both flags are part of the access information kept in the validation cache <ref> [10] </ref>. 5 This call uses PDX, Mungi's protected procedure call mechanism [9], to execute in the owner's protection context. 5.3 Lost and found objects 13 typedef struct - address object; int size; - BA_charge; typedef struct - Cap_t parent; float salary; float balance; time_t last_deposit; float alert_thresh; void (*alert)(); float total_charge;
Reference: [11] <author> Dave Presotto, Rob Pike, Ken Thompson, and Howard Trickey. </author> <title> Plan 9, a distributed system. </title> <booktitle> In European Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 4350, </pages> <address> Troms, Norway, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: In most cases the user will want to remove such objects. This makes it important to be able to distinguish between lost and known objects. User-level naming in Mungi is based on the Plan 9 naming service <ref> [11] </ref>, which allows users to tailor their own name spaces. There is no system-wide human-readable name for objects, lost objects in this context are those who do not appear in a user's name space.
References-found: 11

