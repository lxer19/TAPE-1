URL: http://www.cs.gatech.edu/reverse/repository/serf.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Title: ABSTRACT  
Abstract: In todays continually changing world of computing, many old and outdated systems are being migrated to newer, faster, and less proprietary platforms. Reengineering strategies have traditionally concentrated on the functional design of the program itself. User interfaces, however, present some unique problems for migration, since often the user interface changes drastically -- for example, migrating from a text-based interface to a graphical user interface. Here we present work that identifies the important issues in effectively migrating user interfaces between heterogeneous platforms and different display technologies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Willson, Jane R. </author> <title> Making a Move Off Mainframes, </title> <booktitle> Open Systems Today, </booktitle> <month> April 26, </month> <year> 1993. </year>
Reference-contexts: INTRODUCTION The term rightsizing <ref> [1] </ref> has been coined to describe the practice of reengineering and updating an information system to better fit its environment, to improve business processes, and to reduce cost.
Reference: [2] <author> Rugaber, Spencer. </author> <title> Reverse Engineering Projects at Georgia Tech, Reverse Engineering Newsletter, </title> <booktitle> Subcommittee on Reverse Engineering of the Technical Committee on Software Engineering of the IEEE, </booktitle> <month> October 2, </month> <year> 1992. </year>
Reference-contexts: Detection A large part of the difficulty in migrating systems is in comprehending the existing design <ref> [2] </ref>. In user interface migration, an important task is detecting modules or components of the application that implement the user interface, especially if the user interface technology dictates complete reengineering or replacement of the user interface. Detection can be accomplished in several ways.
Reference: [3] <author> Kamper, Kit, and Rugaber, Spencer. </author> <title> A Reverse Engineering Methodology for Data Processing Applications, </title> <institution> College of Computing and Software Engineering Research Center, Georgia Institute of Technology, Tech Report number GIT-SERC-90/02, </institution> <month> March </month> <year> 1990. </year>
Reference: [4] <author> Rugaber, Spencer, and Clayton, Richard. </author> <title> The Representation Problem in Reverse Engineering, </title> <booktitle> Proceedings of the Working Conference on Reverse Engineering, </booktitle> <address> May 21-23 1993, Baltimore, MD. </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Solving this representation problem and building a model is key to understanding the process of reengineering <ref> [4] </ref>. Devising an abstract representation is also the foundation for developing further reengineering support, such as automated tools [5].
Reference: [5] <author> Selfridge, Peter G., Waters, Richard C., and Chikofsky, Elliot J. </author> <title> Challenges to the Field of Reverse Engineering, </title> <booktitle> Proceedings of the Working Conference on Reverse Engineering, </booktitle> <address> May 21-23 1993, Baltimore, MD. </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Solving this representation problem and building a model is key to understanding the process of reengineering [4]. Devising an abstract representation is also the foundation for developing further reengineering support, such as automated tools <ref> [5] </ref>. Several methods for representing the generic level of abstraction have been studied: Abstract Description language - In [6], Merlo et. al. describe an intermediate representation for a user interface specification using Abstract User Interface Design Language (AUIDL).
Reference: [6] <author> Merlo, E., Girard, J.F., Kontogiannis, K., Panangaden, P., and De Mori, R. </author> <title> Reverse Engineering of User Interfaces, </title> <booktitle> Proceedings of the Working Conference on Reverse Engineering, </booktitle> <address> May 21-23 1993, Baltimore, MD. </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Manual detection - Without automation, detection is a labor-intensive, time consuming, and error-prone task. It involves analyzing code to locate user interface calls and also studying documentation and system manuals for areas of user interaction. Pattern Matching - In <ref> [6] </ref>, Merlo et. al. describe a toolkit that detects user interface components from an Abstract Syntax Tree (AST) produced by a parser. The systems detects anchor points for code fragments by matching user interface syntactic patterns in the code. <p> Devising an abstract representation is also the foundation for developing further reengineering support, such as automated tools [5]. Several methods for representing the generic level of abstraction have been studied: Abstract Description language - In <ref> [6] </ref>, Merlo et. al. describe an intermediate representation for a user interface specification using Abstract User Interface Design Language (AUIDL). AIUDL describes user interface structure based on an object-oriented paradigm, and specifies user interface behavior based on process algebra.
Reference: [7] <author> Moore, M., Rugaber, Spencer, et al, </author> <title> Transitioning to the Open Systems Environment, </title> <type> (TRANSOPEN) Final Report, </type> <institution> College of Computing, Georgia Institute of Technology. Prepared for The Software Technology Branch of the Army Research Laboratory under contract number DAKF11-91-D-0004-0014. </institution>
Reference-contexts: For example, a text-based user interface might require the user to type information that could simply be selected from a scrolling list with a graphical user interface <ref> [7] </ref>. On the other hand, a graphical interface that makes heavy use of color might not migrate well to a system with only a monochrome monitor, since information could be conveyed in the color scheme [9]. <p> Finite State Machines - Since most user interfaces involve system states and transtitions that are caused by user inputs, finite state machines (FSMs) have been used extensively to describe user interfaces <ref> [7] </ref>. FSMs are effective for showing transitions between menus, for example, or systems that change state on user selections. The FSM representation breaks down when the user interface becomes less structured, such as during text entry. <p> State machine mappings - Systems that have been described by Finite State Machines (FSMs) can be transformed by devising mappings between the states and transitions to specific components and actions of a user interface environment <ref> [7] </ref>. The states of the FSM represent menus and choices for the user, and the transitions or edges represent selections or user input. VALIDATION -- CASE STUDIES We are currently in the process of validating this work with case studies: The TRANSOPEN project [7], sponsored by the U.S. <p> and actions of a user interface environment <ref> [7] </ref>. The states of the FSM represent menus and choices for the user, and the transitions or edges represent selections or user input. VALIDATION -- CASE STUDIES We are currently in the process of validating this work with case studies: The TRANSOPEN project [7], sponsored by the U.S. Army Research Laboratories, has studied migration of user interfaces from a DOS-based interface to Open Systems interfaces (Open Look using Unix/POSIX). This work entailed upsizing an information system application from a MS-DOS implementation to an Open Systems platform.
Reference: [8] <author> Foley, James, Kim, Won Chul, Kovacevic, Srdjan, and Murry, Kevin. </author> <title> UIDE - An Intelligent User Interface Design Environment, Intelligent User Interfaces, edited by Sullivan & Tyler, </title> <publisher> ACM Press 1991. </publisher>
Reference-contexts: The Prolog is then restructured and manipulated to provide control ow information, data structure information, and high level descriptions of the user interface. Object oriented representations - In <ref> [8] </ref>, Foley et. al. describe the User Interface Design Environment (UIDE), which incorporates an object-oriented data model to represent user interfaces. A knowledge-based representation is used to describe user interface objects and attributes. Preconditions and postconditions can be defined to specify user interface actions.
Reference: [9] <author> Moore, Melody, Rugaber, Spencer, et al., </author> <title> Knowledge Worker Platform Analysis Final Report, </title> <institution> College of Computing, Georgia Institute of Technology. Sponsored by the U.S. Army Construction Engineering Research Laboratory, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: This raises a philosophical question: when migrating an application, is it better to retain the look and feel of the original platform or to reengineer the application to conform to the look and feel of the new target platform? <ref> [9] </ref> Functionality changes may be necessary when migrating across platforms. Some of these changes may be improvements offered by new display capabilities, but some changes may be required because certain functionality is not provided on the new target platform. <p> On the other hand, a graphical interface that makes heavy use of color might not migrate well to a system with only a monochrome monitor, since information could be conveyed in the color scheme <ref> [9] </ref>. Integration of the user interface can vary drastically depending on the design of the system. In many older functionally decomposed information systems, the user interface is the central component that drives the rest of the system. Also, insensitivity to modularization makes it difficult to isolate the user interface components. <p> We then prototyped the new system using Suns dev/guide Graphical User Interface tool. Currently, the TRANSOPEN project is supporting our experiments with knowledge based representation and transformation for user interface migration. Knowledge Worker Platform Analysis <ref> [9] </ref>, sponsored by the U.S. Army Construction Engineering Research Laboratory, is an upsizing study, examining migration of interfaces from MS-Windows platform to Open Systems interfaces (X Windows and MOTIF) on multiple platforms. We considered many options for this migration, including Portable GUI Builders such as XVT.
Reference: [10] <author> Chikofsky, Elliot J., and Cross, James H. </author> <title> Reverse Engineering and Design Recovery: A Taxonomy, </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: TERMINOLOGY The terms associated with reengineering are often overloaded and misused. This section will serve to define the terminology to establish a common ground for discussion. Chikofsky and Cross present a a taxonomy of reengineering terminology in <ref> [10] </ref>, which we have used as a basis for generating our definitions:. Migration is the activity of moving software from its original environment, including hardware platform, operating environment, or implementation language to a new environment. Reengineering includes restructuring, redesigning, or reimplementing software.
Reference: [11] <author> UniNews, Uniforum Research Released: </author> <title> 93 to be the Year of Change, </title> <journal> Uniforum International Association of Open Systems Professionals, </journal> <volume> Vol VII, Number 6, </volume> <month> April 7, </month> <year> 1993. </year>
Reference-contexts: A recent Uniforum survey showed that of the 1,100 companies that were surveyed, 85% of them were migrating large systems to rightsize them <ref> [11] </ref>. We can surmise from this number that reengineering will be a significant activity in many software organizations in the coming years.
Reference: [12] <author> McClure, Carma, </author> <title> The Three Rs of Software Automation: Re-engineering, Repositories, Reusability, </title> <booktitle> Extended Intelligence, </booktitle> <year> 1990. </year>
Reference-contexts: Migration is the activity of moving software from its original environment, including hardware platform, operating environment, or implementation language to a new environment. Reengineering includes restructuring, redesigning, or reimplementing software. In <ref> [12] </ref>, McClure defines reengineering as improving existing systems by applying new technologies to improve maintainability, upgrade Issues in User Interface Migration Melody M. Moore Spencer Rugaber College of Computing Open Systems Laboratory Georgia Institute of Technology technology, extend life expectancy, and to adhere to standards. <p> Reverse Engineering is the activity of analyzing an existing (legacy) system to describe its original design by an abstract representation. The abstraction is derived from analysis of the code and existing documentation. The goal of reverse engineering is to redocument the system and aid in understanding the program <ref> [12] </ref>. Forward Engineering entails moving from abstraction and design level to the system implementation level. WHY USER INTERFACES ARE DIFFICULT TO MIGRATE There are many factors that contribute to the difficulty of migrating user interfaces: Display technologies have become increasingly sophisticated and have more capabilities.
Reference: [13] <author> Arnold, Robert S., </author> <title> Software Reengineering, </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> California, </address> <year> 1993. </year>
Reference-contexts: Research in reengineering technology to date has focused on abstracting the functionality of existing systems by using techniques such as program understanding, data transformation, and source code analysis <ref> [13] </ref>. However, there has been little concentration on the general problem of reengineering user interfaces. This paper examines the issues inherent in migrating user interfaces, and presents a reengineering strategy and initial case study results. TERMINOLOGY The terms associated with reengineering are often overloaded and misused.
Reference: [14] <editor> Salisin, John. </editor> <booktitle> The Design Record: Keystone of Software Engineering, Keynote Speech of the Third Reverse Engineering Forum, </booktitle> <year> 1992. </year>
Reference-contexts: We can surmise from this number that reengineering will be a significant activity in many software organizations in the coming years. Since reengineering techniques have been shown to save up to 35% of the total cost of software maintenance <ref> [14] </ref>, there is much to be gained in researching this process. The information systems domain presents some unique problems in migration. These systems are typically data-oriented, and often include an integral user interface.
Reference: [15] <author> Brachman, Ronald J, McGuiness, Deborah L, Patel-Schneider, Peter F., and Resnick, Lori A., </author> <title> Living with CLASSIC: When and How to Use a KL-ONE-Like Language, Principles of Semantic Networks, </title> <editor> J. Sowa, </editor> <publisher> Morgan Kaufmann Inc., </publisher> <year> 1990. </year>
Reference-contexts: We have experimented with this method, collecting data on various user interface components and then describing them in the knowledge representation language CLASSIC <ref> [15] </ref>. Our goal is to build a knowledge base that describes different user interface technologies (for example, MS-Windows and Motif) to aid in automating the mapping process.
Reference: [16] <author> Van Sickle, Larry, Liu, Zheng Yang, and Ballantyne, Michael, </author> <title> Recovering User Interface Specifications for Porting Transaction Processing Applications, </title> <institution> EDS Research, Austin Laboratory, 1601 Rio Grande, </institution> <address> Suite 500, Austin TX 78701, </address> <year> 1993. </year>
Reference-contexts: The systems detects anchor points for code fragments by matching user interface syntactic patterns in the code. Using the anchor points as a basis, details about modes of interaction and conditions of activation are identified using control ow analysis. Syntactic/Semantic Analysis - In <ref> [16] </ref>, Van Sickle et. al. describe a method for detecting user input blocks from COBOL code by analyzing the code against a set of criteria for input and output. The recognition algorithm identifies an ACCEPT statement and attempts to incorporate the entire user exchange from that point by detecting groupings. <p> FSMs are effective for showing transitions between menus, for example, or systems that change state on user selections. The FSM representation breaks down when the user interface becomes less structured, such as during text entry. Prolog Abstract Syntax Tree - In <ref> [16] </ref>, Van Sickle et. al. represent user interface structure by translating COBOL code into Prolog, which then acts as an abstract syntax tree. The Prolog is then restructured and manipulated to provide control ow information, data structure information, and high level descriptions of the user interface.
Reference: [17] <author> Gan, Yee Huat. </author> <title> User Interface Knowledge Base, Special Problem Report for Dr. </title> <type> Spencer Rugaber, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Knowledge based transformation - We have experimented with knowledge based representations for user interface components (ie, MS-Windows push buttons as compared to Motif buttons). We used the CLASSIC knowledge representation system to describe the components, and then devised mappings using inferencing queries on the collected data <ref> [17] </ref>. State machine mappings - Systems that have been described by Finite State Machines (FSMs) can be transformed by devising mappings between the states and transitions to specific components and actions of a user interface environment [7].
References-found: 17

