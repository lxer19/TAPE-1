URL: http://www.cs.unc.edu/~anderson/papers/dc94.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Multi-Writer Composite Registers  
Author: James H. Anderson 
Keyword: atomicity, atomic register, composite register, concurrency, interleaving semantics, lineariz-ability, shared variable, snapshot CR Categories: D.4.1, D.4.2, F.3.1  
Note: Preliminary version was presented at the Ninth Annual ACM Symposium on Principles of Distributed Computing [2]. Much of the work described herein was completed while the author was with the  This work was supported at the University of Texas by ONR Contract N00014-89-J-1913, and at the University of Maryland by NSF Contract CCR 9109497 and by an award from the  
Date: July 1989 Revised March 1991, December 1992, August 1993  
Address: Chapel Hill, NC 27599-3175  College Park.  
Affiliation: Department of Computer Science University of North Carolina at Chapel Hill  University of Texas at Austin and the University of Maryland at  University of Maryland General Research Board.  
Abstract: A composite register is an array-like shared data object that is partitioned into a number of components. An operation of such a register either writes a value to a single component, or reads the values of all components. A composite register reduces to an ordinary atomic register when there is only one component. In this paper, we show that a composite register with multiple writers per component can be implemented in a wait-free manner from a composite register with a single writer per component. It has been previously shown that registers of the latter kind can be implemented from atomic registers without waiting. Thus, our results establish that any composite register can be implemented in a wait-free manner from atomic registers. We show that our construction has comparable space complexity and better time complexity than other constructions that have been presented in the literature. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt, and N. Shavit, </author> <title> "Atomic Snapshots of Shared Memory," </title> <booktitle> Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing , 1990, </booktitle> <pages> pp. 1-14. </pages>
Reference-contexts: In this paper, we consider a shared data object, called a composite register, that extends the notion of an atomic register. The notion of a composite register was first introduced by Anderson [2, 3, 4], and is similar to the atomic snapshot memory of Afek et al. <ref> [1] </ref>. A composite register is an array-like shared data object that is partitioned into a number of components. An operation of a composite register either writes a value to a single component, or reads the values of all components. <p> The problem of constructing a composite register from atomic registers was first considered by us in [2, 3, 4] and by Afek et al. in <ref> [1] </ref>. The construction given in this paper is based on the multi-writer construction 1 of [2, 4]. More recently, several constructions have been presented by Kirousis et al. [22, 23], for the special case in which there is only one reader. <p> As such, our construction solves the problem of implementing a multi-writer atomic register (the case in which there is only one component) from single-writer ones. The construction of this paper and the multi-writer construction of Afek et al. also differ in complexity. It is assumed in <ref> [1] </ref> that the constructed composite register is shared by N processes, and that each process may read the register or write any component. Under these assumptions, our multi-writer construction has comparable space complexity and better time complexity than the multi-writer construction of Afek et al. <p> In fact, the time complexity of our construction is (asymptotically) the same as the single-writer composite register used in the construction. Thus, because the time complexity of the single-writer construction in <ref> [1] </ref> is fi (N 2 ), our construction shows that multi-writer composite registers can also be implemented with time complexity that is fi (N 2 ). 1 The multi-writer construction of Afek et al. has time complexity that is fi (N 3 ). <p> Let us now compare the complexity of our construction with the multi-writer construction of Afek et al. <ref> [1] </ref>. In [1], the assumption is made that each of the processes that share the constructed register can both read the register and write each component. Under this assumption, it is possible to reduce the complexity 13 of our construction. <p> Let us now compare the complexity of our construction with the multi-writer construction of Afek et al. <ref> [1] </ref>. In [1], the assumption is made that each of the processes that share the constructed register can both read the register and write each component. Under this assumption, it is possible to reduce the complexity 13 of our construction. <p> If the single-writer composite register construction of <ref> [1] </ref> is used to implement Q, then we have S (N; B 00 ; 1; N ) = fi (B 00 N 3 ) and T R (N; B 00 ; 1; N ) = T W (N; B 00 ; 1; N ) = fi (N 2 ). <p> Thus, for our construction, S (C; B; N; N ) = fi (BCN 3 + CN 4 log N ) and T R (C; B; N; N ) = T R (C; B; N; N ) = fi (N 2 ). 5 The multi-writer construction given in <ref> [1] </ref> has space complexity that is fi (BCN 2 + CN 3 + N 4 ) and time complexity that is fi (N 3 ). (Note that Afek et al. incorrectly state that the time complexity of our construction is fi (N 4 )). 4.3 Correctness Proof To prove that the <p> from atomic registers in a wait-free manner [5, 16, 18, 27]. 34 Our construction shows that multi-writer composite registers can be implemented with space and time complexity that is very close to that required for implementing single-writer composite registers. (The time complexity is asymptotically the same, given the assumption of <ref> [1] </ref> that each process that shares the constructed register can both read the register and write each component.) Thus, in the quest for optimal composite register constructions, it probably suffices to focus on the single-writer case: using our multi-writer construction, any improvement in complexity in the single-writer case yields a corresponding
Reference: [2] <author> J. Anderson, </author> <title> "Composite Registers (Extended Abstract)," </title> <booktitle> Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1990, </year> <pages> pp. 15-30. </pages>
Reference-contexts: In this paper, we consider a shared data object, called a composite register, that extends the notion of an atomic register. The notion of a composite register was first introduced by Anderson <ref> [2, 3, 4] </ref>, and is similar to the atomic snapshot memory of Afek et al. [1]. A composite register is an array-like shared data object that is partitioned into a number of components. <p> It follows from this result that atomic registers can be used to implement a shared memory that can be read in its entirety in a single "snapshot" operation, without using mutual exclusion. The problem of constructing a composite register from atomic registers was first considered by us in <ref> [2, 3, 4] </ref> and by Afek et al. in [1]. The construction given in this paper is based on the multi-writer construction 1 of [2, 4]. More recently, several constructions have been presented by Kirousis et al. [22, 23], for the special case in which there is only one reader. <p> The problem of constructing a composite register from atomic registers was first considered by us in [2, 3, 4] and by Afek et al. in [1]. The construction given in this paper is based on the multi-writer construction 1 of <ref> [2, 4] </ref>. More recently, several constructions have been presented by Kirousis et al. [22, 23], for the special case in which there is only one reader. Our approach in constructing a composite register from atomic registers differs from that of Afek et al. in several respects. <p> We have also given constructions for both the single- and multi-writer cases. Like that of Afek et al., our single-writer composite register construction, which is given in <ref> [2, 3] </ref>, is based on multi-reader, single-writer atomic registers. However, our multi-writer construction differs from theirs in that it is based on a single-writer composite register. By employing the single-writer constructions previously mentioned, our multi-writer construction shows that a multi-writer composite register can be implemented using only single-writer atomic registers.
Reference: [3] <author> J. Anderson, </author> <title> "Composite Registers," </title> <journal> Distributed Computing, </journal> <volume> Vol. 6, </volume> <pages> pp. 141-154, </pages> <year> 1993. </year> <note> First appeared as Technical Report TR.89.25, </note> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <year> 1989. </year>
Reference-contexts: In this paper, we consider a shared data object, called a composite register, that extends the notion of an atomic register. The notion of a composite register was first introduced by Anderson <ref> [2, 3, 4] </ref>, and is similar to the atomic snapshot memory of Afek et al. [1]. A composite register is an array-like shared data object that is partitioned into a number of components. <p> It follows from this result that atomic registers can be used to implement a shared memory that can be read in its entirety in a single "snapshot" operation, without using mutual exclusion. The problem of constructing a composite register from atomic registers was first considered by us in <ref> [2, 3, 4] </ref> and by Afek et al. in [1]. The construction given in this paper is based on the multi-writer construction 1 of [2, 4]. More recently, several constructions have been presented by Kirousis et al. [22, 23], for the special case in which there is only one reader. <p> We have also given constructions for both the single- and multi-writer cases. Like that of Afek et al., our single-writer composite register construction, which is given in <ref> [2, 3] </ref>, is based on multi-reader, single-writer atomic registers. However, our multi-writer construction differs from theirs in that it is based on a single-writer composite register. By employing the single-writer constructions previously mentioned, our multi-writer construction shows that a multi-writer composite register can be implemented using only single-writer atomic registers. <p> The correctness proof for the Shrinking Lemma is given in <ref> [3] </ref>. The proof is somewhat tedious, but is not hard. First, the precedence relation on operations in history h is augmented by adding pairs of operations. These added pairs of operations are defined based upon the five conditions of the lemma.
Reference: [4] <author> J. Anderson, </author> <title> "Multi-Writer Composite Registers," </title> <type> Technical Report, </type> <institution> Department of Computer Science, The University of Maryland at College Park, </institution> <year> 1991. </year> <note> First appeared as Technical Report TR.89.26, </note> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <year> 1989. </year> <month> 35 </month>
Reference-contexts: In this paper, we consider a shared data object, called a composite register, that extends the notion of an atomic register. The notion of a composite register was first introduced by Anderson <ref> [2, 3, 4] </ref>, and is similar to the atomic snapshot memory of Afek et al. [1]. A composite register is an array-like shared data object that is partitioned into a number of components. <p> It follows from this result that atomic registers can be used to implement a shared memory that can be read in its entirety in a single "snapshot" operation, without using mutual exclusion. The problem of constructing a composite register from atomic registers was first considered by us in <ref> [2, 3, 4] </ref> and by Afek et al. in [1]. The construction given in this paper is based on the multi-writer construction 1 of [2, 4]. More recently, several constructions have been presented by Kirousis et al. [22, 23], for the special case in which there is only one reader. <p> The problem of constructing a composite register from atomic registers was first considered by us in [2, 3, 4] and by Afek et al. in [1]. The construction given in this paper is based on the multi-writer construction 1 of <ref> [2, 4] </ref>. More recently, several constructions have been presented by Kirousis et al. [22, 23], for the special case in which there is only one reader. Our approach in constructing a composite register from atomic registers differs from that of Afek et al. in several respects.
Reference: [5] <author> J. Anderson and M. Gouda, </author> <title> "The Virtue of Patience: Concurrent Programming With and Without Waiting," </title> <type> Technical Report TR.90.23, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1990. </year>
Reference-contexts: As explained in Section 5, these results have been recently extended in [9], where it is shown that composite registers can be used to implement an even larger class of objects. Such results stand in sharp contrast to those of <ref> [5, 18] </ref>, where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. The rest of the paper is organized as follows. <p> Writer (i; 0) Writer (i; W 1) component i component 0 component C 1 . . * Wait-Freedom Restriction: As mentioned in the introduction, each procedure is required to be "wait-free," i.e., idle-waiting primitives and unbounded busy-waiting loops are not allowed. (A more formal definition of wait-freedom is given in <ref> [5] </ref>.) We now define several concepts that are needed to state the correctness condition for a construction. These definitions apply to a given construction. A state is an assignment of values to all variables (private and shared) of the construction. One or more states are designated as initial states. <p> By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner <ref> [5, 16, 18, 27] </ref>. 34 Our construction shows that multi-writer composite registers can be implemented with space and time complexity that is very close to that required for implementing single-writer composite registers. (The time complexity is asymptotically the same, given the assumption of [1] that each process that shares the constructed
Reference: [6] <author> J. Anderson and M. Gouda, </author> <title> "A Criterion for Atomicity," </title> <journal> Formal Aspects of Computing: The International Journal of Formal Methods, </journal> <volume> Vol. 4, No. 3, </volume> <month> May </month> <year> 1992, </year> <pages> pp. 273-298. </pages>
Reference: [7] <author> J. Anderson and B. Groselj, </author> <title> "Pseudo Read-Modify-Write Operations: Bounded Wait-Free Implementations," </title> <booktitle> Proceedings of the Fifth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 579, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 52-70. </pages>
Reference-contexts: Composite registers are quite powerful and can be used to implement a number of interesting shared data objects without waiting. For example, as shown in <ref> [7, 8, 10] </ref>, composite registers can be used to implement wait-free shared data objects with "pseudo" read-modify-write (PRMW) operations. A PRMW operation is similar to a "true" read-modify-write (RMW) operation in that it modifies the value of a shared variable 2 based upon the original value of that variable. <p> However, unlike RMW operations, a PRMW operation does not return the value of the variable that it modifies. An operation that increments a shared variable without returning its value is an example of a PRMW operation. It is shown in <ref> [7, 8, 10] </ref> that composite registers can be used to implement without waiting any shared data object that can either be read, written, or modified by a commutative PRMW operation. <p> The results of <ref> [7, 8, 10] </ref> show that composite registers are quite powerful and can be used to implement a variety of other nontrivial shared data objects without waiting.
Reference: [8] <author> J. Anderson and B. Groselj, </author> <title> "Beyond Atomic Registers: Bounded Wait-Free Implementations of Nontrivial Objects," </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Vol. 19, No. 3, </volume> <month> December </month> <year> 1992, </year> <pages> pp. 197-237. </pages>
Reference-contexts: Composite registers are quite powerful and can be used to implement a number of interesting shared data objects without waiting. For example, as shown in <ref> [7, 8, 10] </ref>, composite registers can be used to implement wait-free shared data objects with "pseudo" read-modify-write (PRMW) operations. A PRMW operation is similar to a "true" read-modify-write (RMW) operation in that it modifies the value of a shared variable 2 based upon the original value of that variable. <p> However, unlike RMW operations, a PRMW operation does not return the value of the variable that it modifies. An operation that increments a shared variable without returning its value is an example of a PRMW operation. It is shown in <ref> [7, 8, 10] </ref> that composite registers can be used to implement without waiting any shared data object that can either be read, written, or modified by a commutative PRMW operation. <p> The results of <ref> [7, 8, 10] </ref> show that composite registers are quite powerful and can be used to implement a variety of other nontrivial shared data objects without waiting.
Reference: [9] <author> J. Anderson and M. Moir, </author> <title> "Towards a Necessary and Sufficient Condition for Wait-Free Synchronization," </title> <booktitle> Proceedings of the Seventh International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 725, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993, </year> <pages> pp. 39-53. </pages>
Reference-contexts: It is shown in [7, 8, 10] that composite registers can be used to implement without waiting any shared data object that can either be read, written, or modified by a commutative PRMW operation. As explained in Section 5, these results have been recently extended in <ref> [9] </ref>, where it is shown that composite registers can be used to implement an even larger class of objects. Such results stand in sharp contrast to those of [5, 18], where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. <p> A complete characterization of the class of shared data objects that can be implemented in a wait-free manner from composite registers (and hence atomic registers) remains an important open question. An initial step towards answering this question is given in <ref> [9] </ref>, where a necessary and sufficient condition for wait-free implementation is established for a class of objects called "snapshot objects." A snapshot object can be modified by a set of operations that do not return values, or can be read in its entirety by any process by means of a "snapshot" <p> A bounded-space construction for a large subclass of snapshot objects is given in <ref> [9] </ref>. It is further shown in [9] that no snapshot object that fails to satisfy the commutes/overwrites condition has a wait-free implementation from atomic registers. Acknowledgements: Special thanks go to Mohamed Gouda for his help and encouragement. <p> A bounded-space construction for a large subclass of snapshot objects is given in <ref> [9] </ref>. It is further shown in [9] that no snapshot object that fails to satisfy the commutes/overwrites condition has a wait-free implementation from atomic registers. Acknowledgements: Special thanks go to Mohamed Gouda for his help and encouragement. I am grateful to Fred Schneider for his comments on this work as it appeared in my Ph.D. dissertation.
Reference: [10] <author> J. Aspnes and M. Herlihy, </author> <title> "Wait-Free Data Structures in the Asynchronous PRAM Model," </title> <booktitle> Proceedings of the Second Annual ACM Symposium on Parallel Architectures and Algorithms, </booktitle> <month> July, </month> <year> 1990, </year> <pages> pp. 340-349. </pages>
Reference-contexts: Composite registers are quite powerful and can be used to implement a number of interesting shared data objects without waiting. For example, as shown in <ref> [7, 8, 10] </ref>, composite registers can be used to implement wait-free shared data objects with "pseudo" read-modify-write (PRMW) operations. A PRMW operation is similar to a "true" read-modify-write (RMW) operation in that it modifies the value of a shared variable 2 based upon the original value of that variable. <p> However, unlike RMW operations, a PRMW operation does not return the value of the variable that it modifies. An operation that increments a shared variable without returning its value is an example of a PRMW operation. It is shown in <ref> [7, 8, 10] </ref> that composite registers can be used to implement without waiting any shared data object that can either be read, written, or modified by a commutative PRMW operation. <p> The results of <ref> [7, 8, 10] </ref> show that composite registers are quite powerful and can be used to implement a variety of other nontrivial shared data objects without waiting. <p> The condition for wait-free implementation requires that for any pair of operation invocations, either the two invocations commute or one overwrites the other. Assuming unbounded space, the sufficiency of this condition follows from previous results given in <ref> [10] </ref>, where composite registers are used to obtain a wait-free construction with unbounded space complexity that implements any snapshot object satisfying the commutes/overwrites condition. A bounded-space construction for a large subclass of snapshot objects is given in [9].
Reference: [11] <author> H. Attiya and O. Rachman, </author> <title> "Atomic Snapshots in O(n log n) Operations," </title> <booktitle> Proceedings of the 12th Annual Symposium on Principles of Distributed Computing , 1993, </booktitle> <pages> pp. 29-40. </pages>
Reference-contexts: constructing a composite register of one type from a composite register of a simpler type, and in Section 3 we present a 1 At about the same time as this paper was accepted for publication, a fi (N log N ) single-writer construction was presented by Attiya and Rachman in <ref> [11] </ref>. By using their construction as the basis for ours, we get a multi-writer construction with time complexity fi (N log N ).
Reference: [12] <author> B. Awerbuch, L. Kirousis, E. Kranakis, P. Vitanyi, </author> <title> "On Proving Register Atomicity," </title> <type> Report CS-R8707, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1987. </year> <title> A shorter version appeared as: "A Proof Technique for Register Atomicity," </title> <booktitle> Proceedings of the Eighth Conference on Foundations of Software Techniques and Theoretical Computer Science, Lecture Notes in Computer Science 338, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988, </year> <pages> pp. 286-303. </pages>
Reference-contexts: Conditions similar to Integrity, Proximity, and Read Precedence have been used elsewhere as a correctness condition for atomic register constructions; see, for example, the Integrity, Safety, and Precedence conditions in [32], Proposition 3 in [25], and the definition of an atomic run and the Shrinking Function Theorem in <ref> [12] </ref>. The correctness proof for the Shrinking Lemma is given in [3]. The proof is somewhat tedious, but is not hard. First, the precedence relation on operations in history h is augmented by adding pairs of operations.
Reference: [13] <author> B. Bloom, </author> <title> "Constructing Two-Writer Atomic Registers," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 37, No. 12, </volume> <month> December </month> <year> 1988, </year> <pages> pp. 1506-1514. </pages>
Reference: [14] <author> J. Burns and G. Peterson, </author> <title> "Constructing Multi-Reader Atomic Values from Non-Atomic Values," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 222-231. </pages>
Reference: [15] <author> K. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Whenever we say that a given assertion holds without referring to a particular state, we mean that the assertion is an invariant ; i.e., it is true at each state of every history. Let E and F be two expressions over the variables of a construction. Following <ref> [15] </ref>, we say that the assertion E unless F holds iff for every pair of consecutive states in any history, if E ^ :F holds in the first state, then E _ F holds in the second state. An assertion E is stable iff E unless false holds.
Reference: [16] <author> B. Chor, A. Israeli, and M. Li, </author> <title> "On Processor Coordination Using Asynchronous Hardware," </title> <booktitle> Principles of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 86-97. </pages>
Reference-contexts: By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner <ref> [5, 16, 18, 27] </ref>. 34 Our construction shows that multi-writer composite registers can be implemented with space and time complexity that is very close to that required for implementing single-writer composite registers. (The time complexity is asymptotically the same, given the assumption of [1] that each process that shares the constructed
Reference: [17] <author> P. Courtois, F. Heymans, and D. Parnas, </author> <title> "Concurrent Control with Readers and Writers," </title> <journal> Communications of the ACM , Vol. </journal> <volume> 14, No. 10, </volume> <month> October </month> <year> 1971, </year> <pages> pp. 667-668. </pages>
Reference-contexts: This work shows that, using only atomic registers of the simplest kind, the classical readers-writers problem <ref> [17] </ref> can be solved without requiring either readers or writers to wait. In this paper, we consider a shared data object, called a composite register, that extends the notion of an atomic register.
Reference: [18] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <month> January </month> <year> 1991, </year> <pages> pp. 124-149. 36 </pages>
Reference-contexts: As explained in Section 5, these results have been recently extended in [9], where it is shown that composite registers can be used to implement an even larger class of objects. Such results stand in sharp contrast to those of <ref> [5, 18] </ref>, where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. The rest of the paper is organized as follows. <p> By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner <ref> [5, 16, 18, 27] </ref>. 34 Our construction shows that multi-writer composite registers can be implemented with space and time complexity that is very close to that required for implementing single-writer composite registers. (The time complexity is asymptotically the same, given the assumption of [1] that each process that shares the constructed
Reference: [19] <author> M. Herlihy and J. Wing, </author> <title> "Linearizability: A Correctness Condition for Concurrent Objects," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 3, </volume> <month> July </month> <year> 1990, </year> <pages> pp. 463-492. </pages>
Reference-contexts: Intuitively, a history is linearizable if every operation in the history "appears" to take effect at some point between its first and last events. It can be shown that the following definition is equivalent to the more general definition of linearizability given by Herlihy and Wing in <ref> [19] </ref>, when restricted to the special case of constructing a composite register. Linearizable Histories: Let h be a well-formed history of a construction.
Reference: [20] <author> A. Israeli and M. Li, </author> <title> "Bounded time-stamps," </title> <booktitle> Proceedings of the 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 371-382. </pages>
Reference: [21] <author> L. Kirousis, E. Kranakis, and P. Vitanyi, </author> <title> "Atomic Multireader Register," </title> <booktitle> Proceedings of the Second International Workshop on Distributed Computing , Lecture Notes in Computer Science 312, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987, </year> <pages> pp. 278-296. </pages>
Reference: [22] <author> L. Kirousis, P. Spirakis, and P. Tsigas, </author> <title> "Simple Atomic Snapshots: A Solution With Unbounded Time Stamps," </title> <booktitle> Proceedings of the International Conference on Computing and Information, Lecture Notes in Computer Science 497, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 582-587. </pages>
Reference-contexts: The construction given in this paper is based on the multi-writer construction 1 of [2, 4]. More recently, several constructions have been presented by Kirousis et al. <ref> [22, 23] </ref>, for the special case in which there is only one reader. Our approach in constructing a composite register from atomic registers differs from that of Afek et al. in several respects.
Reference: [23] <author> L. Kirousis, P. Spirakis, and P. Tsigas, </author> <title> "Reading Many Variables in One Atomic Operation: Solutions with Linear or Sublinear Complexity," </title> <booktitle> Proceedings of the Fifth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 579, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 229-241. </pages>
Reference-contexts: The construction given in this paper is based on the multi-writer construction 1 of [2, 4]. More recently, several constructions have been presented by Kirousis et al. <ref> [22, 23] </ref>, for the special case in which there is only one reader. Our approach in constructing a composite register from atomic registers differs from that of Afek et al. in several respects.
Reference: [24] <author> L. Lamport, </author> <title> "Concurrent Reading and Writing," </title> <journal> Communications of the ACM , Vol. </journal> <volume> 20, No. 11, </volume> <month> Novem-ber </month> <year> 1977, </year> <pages> pp. 806-811. </pages>
Reference-contexts: Also, because such an object can be accessed concurrently by any number of the processes that share it, wait-free implementations allow processes to execute with maximum parallelism. The notion of an atomic register is of fundamental importance in the study of wait-free shared data objects <ref> [24, 25, 28, 30] </ref>. An atomic register is a shared data object that can either be read or written (but not both) in a single operation.
Reference: [25] <author> L. Lamport, </author> <title> "On Interprocess Communication, Parts I and II," </title> <journal> Distributed Computing, </journal> <volume> Vol. 1, </volume> <year> 1986, </year> <pages> pp. 77-101. </pages>
Reference-contexts: Also, because such an object can be accessed concurrently by any number of the processes that share it, wait-free implementations allow processes to execute with maximum parallelism. The notion of an atomic register is of fundamental importance in the study of wait-free shared data objects <ref> [24, 25, 28, 30] </ref>. An atomic register is a shared data object that can either be read or written (but not both) in a single operation. <p> Conditions similar to Integrity, Proximity, and Read Precedence have been used elsewhere as a correctness condition for atomic register constructions; see, for example, the Integrity, Safety, and Precedence conditions in [32], Proposition 3 in <ref> [25] </ref>, and the definition of an atomic run and the Shrinking Function Theorem in [12]. The correctness proof for the Shrinking Lemma is given in [3]. The proof is somewhat tedious, but is not hard.
Reference: [26] <author> M. Li, J. Tromp, and P. Vitanyi, </author> <title> "How to Construct Wait-Free Variables," </title> <booktitle> Proceedings of International Colloquium on Automata, Languages, and Programming, Lecture Notes in Computer Science 372, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 488-505. </pages>
Reference-contexts: The method described above for bounding the tag fields is very similar to the one employed in the atomic register construction of Li, Tromp, and Vitanyi in <ref> [26] </ref>. This construction is also based on the protocol of Vitanyi and Awerbuch described above. The method for bounding the tag fields employed by Li et al. is similar to the one described above in that "newer" operations mark the tag values of "older" ones.
Reference: [27] <author> M. Loui and H. Abu-Amara, </author> <title> "Memory Requirements for Agreement Among Unreliable Asynchronous Processes," </title> <booktitle> Advances in Computing Research, </booktitle> <volume> Vol. 4, </volume> <publisher> JAI Press, </publisher> <year> 1987, </year> <pages> pp. 163-183. </pages>
Reference-contexts: By contrast, operations that either write several shared variables, or that both read and write shared variables cannot, in general, be implemented from atomic registers in a wait-free manner <ref> [5, 16, 18, 27] </ref>. 34 Our construction shows that multi-writer composite registers can be implemented with space and time complexity that is very close to that required for implementing single-writer composite registers. (The time complexity is asymptotically the same, given the assumption of [1] that each process that shares the constructed
Reference: [28] <author> J. Misra, </author> <title> "Axioms for Memory Access in Asynchronous Hardware Systems," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 8, No. 1, </volume> <month> January </month> <year> 1986, </year> <pages> pp. 142-153. </pages>
Reference-contexts: Also, because such an object can be accessed concurrently by any number of the processes that share it, wait-free implementations allow processes to execute with maximum parallelism. The notion of an atomic register is of fundamental importance in the study of wait-free shared data objects <ref> [24, 25, 28, 30] </ref>. An atomic register is a shared data object that can either be read or written (but not both) in a single operation.
Reference: [29] <author> R. Newman-Wolfe, </author> <title> "A Protocol for Wait-Free, Atomic, Multi-Reader Shared Variables," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 232-248. </pages>
Reference: [30] <author> G. Peterson, </author> <title> "Concurrent Reading While Writing," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 5, </volume> <year> 1983, </year> <pages> pp. 46-55. </pages>
Reference-contexts: Also, because such an object can be accessed concurrently by any number of the processes that share it, wait-free implementations allow processes to execute with maximum parallelism. The notion of an atomic register is of fundamental importance in the study of wait-free shared data objects <ref> [24, 25, 28, 30] </ref>. An atomic register is a shared data object that can either be read or written (but not both) in a single operation.
Reference: [31] <author> G. Peterson and J. Burns, </author> <title> "Concurrent Reading While Writing II: The Multi-Writer Case," </title> <booktitle> Proceedings of the 28th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 383-392. </pages>
Reference: [32] <author> A. Singh, J. Anderson, and M. Gouda, </author> <title> "The Elusive Atomic Register, Revisited," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 206-221. </pages> <note> Expanded version to appear in Journal of the ACM . 37 </note>
Reference-contexts: Write Precedence orders Write operations of one component with respect to Write operations of another component. Conditions similar to Integrity, Proximity, and Read Precedence have been used elsewhere as a correctness condition for atomic register constructions; see, for example, the Integrity, Safety, and Precedence conditions in <ref> [32] </ref>, Proposition 3 in [25], and the definition of an atomic run and the Shrinking Function Theorem in [12]. The correctness proof for the Shrinking Lemma is given in [3]. The proof is somewhat tedious, but is not hard.
Reference: [33] <author> J. Tromp, </author> <title> "How to Construct an Atomic Variable," </title> <booktitle> Proceedings of the Third International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 392, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 292-302. </pages>
Reference: [34] <author> P. Vitanyi and B. Awerbuch, </author> <title> "Atomic Shared Register Access by Asynchronous Hardware," </title> <booktitle> Proceedings of the 27th IEEE Symposium on the Foundations of Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 233-243. 38 </pages>
Reference-contexts: The Write operations for a given component follow a protocol that is similar to that used in the multi-writer atomic register construction of Vitanyi and Awerbuch <ref> [34] </ref>. Each Write operation for a particular component appends a "tag" to its input value; a Write operation computes its tag by incrementing the value of the maximum tag that it reads from the elements of Q corresponding to its component.
References-found: 34

