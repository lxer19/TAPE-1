URL: http://www.cs.pitt.edu/~suew/boehlen.ps
Refering-URL: http://www.cs.pitt.edu/~suew/dbwshop2.html
Root-URL: 
Email: fboehlen, busatto, csjg@cs.auc.dk  
Title: Point- Versus Interval-based Temporal Data Models  
Author: M. H. Bohlen R. Busatto C. S. Jensen 
Address: Fredrik Bajers Vej 7E, DK9220 Aalborg st, Denmark  
Affiliation: Department of Computer Science Aalborg University  
Abstract: The association of timestamps with various data items such as tuples or attribute values is fundamental to the management of time-varying information. Using intervals in timestamps, as do most data models, leaves a data model with a variety of choices for giving a meaning to timestamps. Specifically, some such data models claim to be point-based while other data models claim to be interval-based. The meaning chosen for timestamps is importantit has a pervasive effect on most aspects of a data model, including database design, a variety of query language properties, and query processing techniques, e.g., the availability of query optimization opportunities. This paper precisely defines the notions of point-based and interval-based temporal data models, thus providing a new, formal basis for characterizing temporal data models and obtaining new insights into the properties of their query languages. Queries in point-based models treat snapshot equivalent argument relations identically. This renders point-based models insensitive to coalescing. In contrast, queries in interval-based models give significance to the actual intervals used in the timestamps, thus generally treating non-identical, but possibly snapshot equivalent, relations differently. The paper identifies the notion of time-fragment preservation as the essential defining property of an interval-based data model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul, L. Herr, and J. Van den Bussche. </author> <title> Temporal Con-nectives Versus Explicit Timestamps in Temporal Query Languages. </title> <booktitle> Recent Advances in Temporal Databases, </booktitle> <pages> pages 4357. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: We term x 1 ; : : : ; x n the non-temporal (or explicit) attribute values, and ts is the (tuple) timestamp. A finite set of such relations may be referred to as the times-tamp representation of a temporal database <ref> [1] </ref>. An operator is temporal if and only if it generates a temporal relation whenever applied to temporal relations. When designing a temporal data model, an important and central aspect is the choice of appropriate timestamps of the database facts. <p> Example 5.1 Assume a temporal difference operator. Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak [2; 10]ig and r 2 = fhak <ref> [1; 4] </ref>i; hak [8; 11]i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; <p> Assume r 1 = fhak [2; 10]ig and r 2 = fhak <ref> [1; 4] </ref>i; hak [8; 11]i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; r 0 D (r 00 2 ; hai; f5; 6; 7g) The set of relevant argument tuples for the result tuple is S 00 <p> Assume r 1 = fhak [2; 10]ig and r 2 = fhak <ref> [1; 4] </ref>i; hak [8; 11]i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; r 0 D (r 00 2 ; hai; f5; 6; 7g) The set of relevant argument tuples for the result tuple is S 00 = r 00 2 . <p> , union compatible (r 1 ; r 2 )^ 8p (9I 1 (hxkI 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak [4; 8]i; hak <ref> [1; 6] </ref>i; hak [7; 10]ig and r 2 = fhak [1; 3]i; hak [9; 10]ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> (9I 1 (hxkI 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak [4; 8]i; hak [1; 6]i; hak [7; 10]ig and r 2 = fhak <ref> [1; 3] </ref>i; hak [9; 10]ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak <ref> [1; 6] </ref>i; hak [7; 10]ig [ fhak [1; 3]i; hak [9; 10]ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak [1; 6]i; hak [7; 10]ig [ fhak <ref> [1; 3] </ref>i; hak [9; 10]ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies .
Reference: [2] <author> J. van Benthem. </author> <title> The Logic of Time A Model-Theoretic Investigation into the Varieties of Temporal Ontology and Temporal Discourse. </title> <publisher> Kluwer, </publisher> <year> 1991. </year>
Reference-contexts: When designing a temporal data model, an important and central aspect is the choice of appropriate timestamps of the database facts. Time points and time intervals, defined below, provide the most common choices. Intervals may be built from time points <ref> [2] </ref>, [14, ch. 21]. Definition 3.1 (Time-point and Time-interval Domains) Let T be an infinite set. 1. T p = hT; &lt;i is a time point domain over T iff &lt; defines a total order on T . <p> To exemplify this, assume that the integers with the &lt; order is our time point domain. Then it seems reasonable to claim that the relations r 1 = fhak2i; hak3i; hak4ig and r 2 = fhak <ref> [2; 4] </ref>ig have the same information contents, i.e., that hai is valid at instants 2, 3, and 4, and nothing more. <p> Two argument tuples with identical explicit join attribute values contribute to the result if their timestamps overlap. Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak <ref> [2; 5] </ref>i; hak [7; 11]ig and r 2 = fhak [3; 9]ig then r 1 ./ t r 2 = fhak [3; 5]i; hak [7; 9]ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. <p> The merged tuple then 1 In this sense, temporal logic can be also said to be point-based, as the temporal domain consists of points [5]. has this union as its new timestamp. Thus, if r 1 = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig then coal (r 1 ) = fhak [2; 11]ig. <p> Thus, if r 1 = fhak [2; 5]i; hak [6; 11]ig then coal (r 1 ) = fhak <ref> [2; 11] </ref>ig. Like temporal intersection natural join, this operation is point-based because snapshot equivalent arguments will yield snapshot equivalent results: for snapshot-equivalent arguments, the result will always be the exact same, which is a trivial case of snapshot equivalence. <p> Example 5.1 Assume a temporal difference operator. Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak <ref> [2; 10] </ref>ig and r 2 = fhak [1; 4]i; hak [8; 11]i; hak [12; 17]i; hbk [2; 6]ig. <p> Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak [2; 10]ig and r 2 = fhak [1; 4]i; hak [8; 11]i; hak [12; 17]i; hbk <ref> [2; 6] </ref>ig. <p> Example 5.5 A selection operator that constrains the times-tamp and returns a temporal relation is interval-based, but not point-based. For example, consider I BEFORE [7;9] (r) with r = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig. The result is fhak [2; 5]ig. Using r 0 = fhak [2; 11]ig, which is snapshot equivalent to r, as the argument would yield an empty result. Since selection does not preserve snapshot-equivalence, it is not point-based. <p> Example 5.5 A selection operator that constrains the times-tamp and returns a temporal relation is interval-based, but not point-based. For example, consider I BEFORE [7;9] (r) with r = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig. The result is fhak [2; 5]ig. Using r 0 = fhak [2; 11]ig, which is snapshot equivalent to r, as the argument would yield an empty result. Since selection does not preserve snapshot-equivalence, it is not point-based. On the other hand, it is easy to see that selection is interval-based. <p> Example 5.5 A selection operator that constrains the times-tamp and returns a temporal relation is interval-based, but not point-based. For example, consider I BEFORE [7;9] (r) with r = fhak [2; 5]i; hak [6; 11]ig. The result is fhak [2; 5]ig. Using r 0 = fhak <ref> [2; 11] </ref>ig, which is snapshot equivalent to r, as the argument would yield an empty result. Since selection does not preserve snapshot-equivalence, it is not point-based. On the other hand, it is easy to see that selection is interval-based. <p> Two such operators are described in Examples 6.1 and 6.2, below. Example 6.1 Assume a regular time-shift operator o rts that returns all tuples of the argument relation with the times-tamps being shifted one time unit to the right. Assume r 1 = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak [3; 6]i; hak [7; 12]ig and o rts (r 2 ) = fhak [3; 12]ig. <p> Example 6.1 Assume a regular time-shift operator o rts that returns all tuples of the argument relation with the times-tamps being shifted one time unit to the right. Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak <ref> [2; 11] </ref>ig. Then o rts (r 1 ) = fhak [3; 6]i; hak [7; 12]ig and o rts (r 2 ) = fhak [3; 12]ig. <p> Example 6.2 Assume an irregular time-shift operator o its that, for any tuple of the argument relation, shifts the start time by two units to the right and the end time by one unit to the right. Assume r 1 = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak [4; 6]i; hak [8; 12]ig and o its (r 2 ) = fhak [4; 12]ig. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak <ref> [2; 11] </ref>ig. Then o its (r 1 ) = fhak [4; 6]i; hak [8; 12]ig and o its (r 2 ) = fhak [4; 12]ig. The time-shift operators are faithful to their argument intervals in the sense that they dislocate each single interval present in the input relation.
Reference: [3] <author> M. H. Bohlen and C. S. Jensen. </author> <title> Seamless Integration of Time into SQL. </title> <type> TR R-96-2049, </type> <institution> Aalborg University, Department of Computer, Fredrik Bajers Vej 7, DK-9220 Aalborg, </institution> <month> Dec </month> <year> 1996. </year>
Reference-contexts: Two argument tuples with identical explicit join attribute values contribute to the result if their timestamps overlap. Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak [2; 5]i; hak [7; 11]ig and r 2 = fhak <ref> [3; 9] </ref>ig then r 1 ./ t r 2 = fhak [3; 5]i; hak [7; 9]ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. <p> Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak [2; 5]i; hak [7; 11]ig and r 2 = fhak [3; 9]ig then r 1 ./ t r 2 = fhak <ref> [3; 5] </ref>i; hak [7; 9]ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. Example 4.2 The coalescing operator (coal) is a unary operator that merges value-equivalent tuples (tuples with mutually identical explicit attribute values) if the union of their timestamps is an interval. <p> (9I 1 (hxkI 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak [4; 8]i; hak [1; 6]i; hak [7; 10]ig and r 2 = fhak <ref> [1; 3] </ref>i; hak [9; 10]ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak [1; 6]i; hak [7; 10]ig <ref> [ fhak [1; 3] </ref>i; hak [9; 10]ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak [1; 6]i; hak [7; 10]ig [ fhak <ref> [1; 3] </ref>i; hak [9; 10]ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies . <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak <ref> [3; 6] </ref>i; hak [7; 12]ig and o rts (r 2 ) = fhak [3; 12]ig. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak [3; 6]i; hak [7; 12]ig and o rts (r 2 ) = fhak <ref> [3; 12] </ref>ig. Example 6.2 Assume an irregular time-shift operator o its that, for any tuple of the argument relation, shifts the start time by two units to the right and the end time by one unit to the right. <p> Our current definition of interval-based comprises all operators and models that do not interpret timestamps in any special way. Examples are relational operators in SQL-92 [11] (extended with a period data type), relational operations in IXSQL [10], and non-sequenced operations in AT-SQL <ref> [3] </ref>. In all these cases, standard relational operators are applied to timestamps. Such an approach is trivially faithful to argument intervalsthe operators have no special temporal semantics. One can argue that such operators do not provide (enhanced) temporal support. <p> This is achieved by enforcing a canonical representation based on temporal elements. Thus, TSQL2 is clearly not interval-based. On the other hand, all operators preserve snapshot equivalence because they are defined over the canonical representation of a database. This makes TSQL2 a point-based data model. ATSQL <ref> [3] </ref> ATSQL introduces sequenced and nonse-quenced statements together with corresponding algebras. Nonsequenced statements provide the power of regular SQL-92 statements and are, like SQL-92 and IXSQL statements, interval-based. Sequenced statements are also interval-based. In addition, most sequenced statements are point-based.
Reference: [4] <author> M. H. Bohlen, R. T. Snodgrass, and M. D. Soo. </author> <title> Coalescing in Temporal Databases. </title> <booktitle> Proc. of the 22nd VLDB Conf., </booktitle> <pages> pages 180191. </pages> <publisher> Morgan Kaufmann, </publisher> <month> Sep </month> <year> 1996. </year>
Reference-contexts: The reason for this is that it is possible to derive the coalesced relation instance from an uncoalesced one, e.g., using a regular SQL statement <ref> [4] </ref>. These considerations indicate that a model that is able to tell coalesced and uncoalesced relation instances apart, and in this sense is interval-based, is in some sense more powerful than a model that cannot tell them apart, i.e., a point-based model. <p> In favor of an interval-based language, it can be said that a point-based database system must guarantee that the result of queries do not depend on the specific choice of timestamp values. This guarantee is met by performing coalescing operations, which can be expensive <ref> [4] </ref>. <p> To exemplify this, assume that the integers with the &lt; order is our time point domain. Then it seems reasonable to claim that the relations r 1 = fhak2i; hak3i; hak4ig and r 2 = fhak <ref> [2; 4] </ref>ig have the same information contents, i.e., that hai is valid at instants 2, 3, and 4, and nothing more. <p> Example 5.1 Assume a temporal difference operator. Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak [2; 10]ig and r 2 = fhak <ref> [1; 4] </ref>i; hak [8; 11]i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; <p> Assume r 1 = fhak [2; 10]ig and r 2 = fhak <ref> [1; 4] </ref>i; hak [8; 11]i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; r 0 D (r 00 2 ; hai; f5; 6; 7g) The set of relevant argument tuples for the result tuple is S 00 <p> Assume r 1 = fhak [2; 10]ig and r 2 = fhak <ref> [1; 4] </ref>i; hak [8; 11]i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; r 0 D (r 00 2 ; hai; f5; 6; 7g) The set of relevant argument tuples for the result tuple is S 00 = r 00 2 . <p> by the formula , union compatible (r 1 ; r 2 )^ 8p (9I 1 (hxkI 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak <ref> [4; 8] </ref>i; hak [1; 6]i; hak [7; 10]ig and r 2 = fhak [1; 3]i; hak [9; 10]ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak <ref> [4; 8] </ref>ig [ f g and S 2 = fhak [1; 6]i; hak [7; 10]ig [ fhak [1; 3]i; hak [9; 10]ig. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak <ref> [4; 6] </ref>i; hak [8; 12]ig and o its (r 2 ) = fhak [4; 12]ig. The time-shift operators are faithful to their argument intervals in the sense that they dislocate each single interval present in the input relation. Therefore, they could be classified as interval-based. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak [4; 6]i; hak [8; 12]ig and o its (r 2 ) = fhak <ref> [4; 12] </ref>ig. The time-shift operators are faithful to their argument intervals in the sense that they dislocate each single interval present in the input relation. Therefore, they could be classified as interval-based.
Reference: [5] <author> J. Chomicki. </author> <title> Temporal Query Languages: a Survey. </title> <booktitle> Proc. of the First Intern. Conf. on Temporal Logic, </booktitle> <pages> pages 506534, </pages> <year> 1994. </year>
Reference-contexts: Chomicki states that It is important to see that the data model of TQuel is point-based, not interval-based. Intervals serve only as a representational device. The truth values of facts are associated with points, not intervals <ref> [5, p. 521] </ref> and that . . . a model is point-based if facts are associated with single time points, interval-based if they are associated with intervals (represented as pairs of points) [6, p. x+7]. <p> Two argument tuples with identical explicit join attribute values contribute to the result if their timestamps overlap. Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak <ref> [2; 5] </ref>i; hak [7; 11]ig and r 2 = fhak [3; 9]ig then r 1 ./ t r 2 = fhak [3; 5]i; hak [7; 9]ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. <p> Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak [2; 5]i; hak [7; 11]ig and r 2 = fhak [3; 9]ig then r 1 ./ t r 2 = fhak <ref> [3; 5] </ref>i; hak [7; 9]ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. Example 4.2 The coalescing operator (coal) is a unary operator that merges value-equivalent tuples (tuples with mutually identical explicit attribute values) if the union of their timestamps is an interval. <p> The merged tuple then 1 In this sense, temporal logic can be also said to be point-based, as the temporal domain consists of points <ref> [5] </ref>. has this union as its new timestamp. Thus, if r 1 = fhak [2; 5]i; hak [6; 11]ig then coal (r 1 ) = fhak [2; 11]ig. <p> The merged tuple then 1 In this sense, temporal logic can be also said to be point-based, as the temporal domain consists of points [5]. has this union as its new timestamp. Thus, if r 1 = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig then coal (r 1 ) = fhak [2; 11]ig. <p> Example 5.5 A selection operator that constrains the times-tamp and returns a temporal relation is interval-based, but not point-based. For example, consider I BEFORE [7;9] (r) with r = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig. The result is fhak [2; 5]ig. Using r 0 = fhak [2; 11]ig, which is snapshot equivalent to r, as the argument would yield an empty result. Since selection does not preserve snapshot-equivalence, it is not point-based. <p> Example 5.5 A selection operator that constrains the times-tamp and returns a temporal relation is interval-based, but not point-based. For example, consider I BEFORE [7;9] (r) with r = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig. The result is fhak [2; 5]ig. Using r 0 = fhak [2; 11]ig, which is snapshot equivalent to r, as the argument would yield an empty result. Since selection does not preserve snapshot-equivalence, it is not point-based. On the other hand, it is easy to see that selection is interval-based. <p> Two such operators are described in Examples 6.1 and 6.2, below. Example 6.1 Assume a regular time-shift operator o rts that returns all tuples of the argument relation with the times-tamps being shifted one time unit to the right. Assume r 1 = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak [3; 6]i; hak [7; 12]ig and o rts (r 2 ) = fhak [3; 12]ig. <p> Example 6.2 Assume an irregular time-shift operator o its that, for any tuple of the argument relation, shifts the start time by two units to the right and the end time by one unit to the right. Assume r 1 = fhak <ref> [2; 5] </ref>i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak [4; 6]i; hak [8; 12]ig and o its (r 2 ) = fhak [4; 12]ig.
Reference: [6] <author> J. Chomicki. </author> <title> Temporal Query Languages: a Survey. </title> <note> 1995. Submitted to IEEE TKDE (available via URL http://www.cis.ksu.edu/chomicki). </note>
Reference-contexts: The truth values of facts are associated with points, not intervals [5, p. 521] and that . . . a model is point-based if facts are associated with single time points, interval-based if they are associated with intervals (represented as pairs of points) <ref> [6, p. x+7] </ref>. Finally, Toman states that In this paper we establish the correspondence between the point- and interval-based views of temporal databases and the corresponding first-order temporal languages. <p> The merged tuple then 1 In this sense, temporal logic can be also said to be point-based, as the temporal domain consists of points [5]. has this union as its new timestamp. Thus, if r 1 = fhak [2; 5]i; hak <ref> [6; 11] </ref>ig then coal (r 1 ) = fhak [2; 11]ig. Like temporal intersection natural join, this operation is point-based because snapshot equivalent arguments will yield snapshot equivalent results: for snapshot-equivalent arguments, the result will always be the exact same, which is a trivial case of snapshot equivalence. <p> Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak [2; 10]ig and r 2 = fhak [1; 4]i; hak [8; 11]i; hak [12; 17]i; hbk <ref> [2; 6] </ref>ig. <p> , union compatible (r 1 ; r 2 )^ 8p (9I 1 (hxkI 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak [4; 8]i; hak <ref> [1; 6] </ref>i; hak [7; 10]ig and r 2 = fhak [1; 3]i; hak [9; 10]ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig <ref> [ f g and S 2 = fhak [1; 6] </ref>i; hak [7; 10]ig [ fhak [1; 3]i; hak [9; 10]ig. <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak <ref> [1; 6] </ref>i; hak [7; 10]ig [ fhak [1; 3]i; hak [9; 10]ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies . <p> Example 5.5 A selection operator that constrains the times-tamp and returns a temporal relation is interval-based, but not point-based. For example, consider I BEFORE [7;9] (r) with r = fhak [2; 5]i; hak <ref> [6; 11] </ref>ig. The result is fhak [2; 5]ig. Using r 0 = fhak [2; 11]ig, which is snapshot equivalent to r, as the argument would yield an empty result. Since selection does not preserve snapshot-equivalence, it is not point-based. <p> Two such operators are described in Examples 6.1 and 6.2, below. Example 6.1 Assume a regular time-shift operator o rts that returns all tuples of the argument relation with the times-tamps being shifted one time unit to the right. Assume r 1 = fhak [2; 5]i; hak <ref> [6; 11] </ref>ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak [3; 6]i; hak [7; 12]ig and o rts (r 2 ) = fhak [3; 12]ig. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak <ref> [3; 6] </ref>i; hak [7; 12]ig and o rts (r 2 ) = fhak [3; 12]ig. <p> Example 6.2 Assume an irregular time-shift operator o its that, for any tuple of the argument relation, shifts the start time by two units to the right and the end time by one unit to the right. Assume r 1 = fhak [2; 5]i; hak <ref> [6; 11] </ref>ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak [4; 6]i; hak [8; 12]ig and o its (r 2 ) = fhak [4; 12]ig. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak <ref> [4; 6] </ref>i; hak [8; 12]ig and o its (r 2 ) = fhak [4; 12]ig. The time-shift operators are faithful to their argument intervals in the sense that they dislocate each single interval present in the input relation. Therefore, they could be classified as interval-based.
Reference: [7] <author> S. K. Gadia. </author> <title> Weak Temporal Relations. </title> <booktitle> Proc. of the 5th PODS Symposium, </booktitle> <year> 1986. </year>
Reference-contexts: This section defines the notion of a point-based data model. In a point-based data model, two interval-timestamped relations that correspond to the same point-timestamped relation are considered equivalent, in the sense that they record the same information. The notion of snapshot equivalence <ref> [7, 9] </ref> formalizes this. Definition 4.1 (Snapshot Equivalence) Let T p = hT; &lt;i be a time point domain. 1. <p> Two argument tuples with identical explicit join attribute values contribute to the result if their timestamps overlap. Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak [2; 5]i; hak <ref> [7; 11] </ref>ig and r 2 = fhak [3; 9]ig then r 1 ./ t r 2 = fhak [3; 5]i; hak [7; 9]ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. <p> Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak [2; 5]i; hak [7; 11]ig and r 2 = fhak [3; 9]ig then r 1 ./ t r 2 = fhak [3; 5]i; hak <ref> [7; 9] </ref>ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. Example 4.2 The coalescing operator (coal) is a unary operator that merges value-equivalent tuples (tuples with mutually identical explicit attribute values) if the union of their timestamps is an interval. <p> (r 1 ; r 2 )^ 8p (9I 1 (hxkI 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak [4; 8]i; hak [1; 6]i; hak <ref> [7; 10] </ref>ig and r 2 = fhak [1; 3]i; hak [9; 10]ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak [1; 6]i; hak <ref> [7; 10] </ref>ig [ fhak [1; 3]i; hak [9; 10]ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies . <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak [3; 6]i; hak <ref> [7; 12] </ref>ig and o rts (r 2 ) = fhak [3; 12]ig. Example 6.2 Assume an irregular time-shift operator o its that, for any tuple of the argument relation, shifts the start time by two units to the right and the end time by one unit to the right.
Reference: [8] <author> S. K. Gadia. </author> <title> A Homogeneous Relational Model and Query Languages for Temporal Databases. </title> <journal> ACM TODS, </journal> <volume> 13 (4):418 448, </volume> <year> 1988. </year>
Reference-contexts: Example 5.1 Assume a temporal difference operator. Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak [2; 10]ig and r 2 = fhak [1; 4]i; hak <ref> [8; 11] </ref>i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; r 0 D <p> Assume r 1 = fhak [2; 10]ig and r 2 = fhak [1; 4]i; hak <ref> [8; 11] </ref>i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; r 0 D (r 00 2 ; hai; f5; 6; 7g) The set of relevant argument tuples for the result tuple is S 00 = r 00 2 . <p> by the formula , union compatible (r 1 ; r 2 )^ 8p (9I 1 (hxkI 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak <ref> [4; 8] </ref>i; hak [1; 6]i; hak [7; 10]ig and r 2 = fhak [1; 3]i; hak [9; 10]ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak <ref> [4; 8] </ref>ig [ f g and S 2 = fhak [1; 6]i; hak [7; 10]ig [ fhak [1; 3]i; hak [9; 10]ig. <p> All four alternatives represent satisfactory solutions with respect to snapshot-equivalence preservation. As a fragment-preserving operator, the temporal union operator is superfluousit amounts to its standard set-theoretical coun terpart. 2 The usage of temporal elements, defined e.g., in <ref> [8] </ref>, would lead to a single result tuple of the form hxkI 1 [ : : : [ I m i. Example 5.4 The temporal join operator from Example 4.1 is not only point-based, but also interval-based, because its intersecting of argument intervals satisfies fragment preser vation. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak [4; 6]i; hak <ref> [8; 12] </ref>ig and o its (r 2 ) = fhak [4; 12]ig. The time-shift operators are faithful to their argument intervals in the sense that they dislocate each single interval present in the input relation. Therefore, they could be classified as interval-based.
Reference: [9] <author> C. Jensen, M. Soo, and R. T. Snodgrass. </author> <title> Unifying Temporal Models via a Conceptual Model. </title> <journal> Information Systems, </journal> <volume> 19(7):513547, </volume> <year> 1994. </year>
Reference-contexts: This section defines the notion of a point-based data model. In a point-based data model, two interval-timestamped relations that correspond to the same point-timestamped relation are considered equivalent, in the sense that they record the same information. The notion of snapshot equivalence <ref> [7, 9] </ref> formalizes this. Definition 4.1 (Snapshot Equivalence) Let T p = hT; &lt;i be a time point domain. 1. <p> r 2 , are snapshot equivalent, i.e., r 1 p 8p (p 2 T ) t p (r 1 ) = t p (r 2 )) The notion of snapshot equivalence allows us to characterize operators that, when applied to snapshot equivalent relations, yield results that are also snapshot equivalent <ref> [9] </ref>. Such operators are faithful to the point-based nature of the timestamps of their argument relations, and we will use them to define point-based data models. <p> Two argument tuples with identical explicit join attribute values contribute to the result if their timestamps overlap. Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak [2; 5]i; hak [7; 11]ig and r 2 = fhak <ref> [3; 9] </ref>ig then r 1 ./ t r 2 = fhak [3; 5]i; hak [7; 9]ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. <p> Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak [2; 5]i; hak [7; 11]ig and r 2 = fhak [3; 9]ig then r 1 ./ t r 2 = fhak [3; 5]i; hak <ref> [7; 9] </ref>ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. Example 4.2 The coalescing operator (coal) is a unary operator that merges value-equivalent tuples (tuples with mutually identical explicit attribute values) if the union of their timestamps is an interval. <p> 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak [4; 8]i; hak [1; 6]i; hak [7; 10]ig and r 2 = fhak [1; 3]i; hak <ref> [9; 10] </ref>ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak [1; 6]i; hak [7; 10]ig [ fhak [1; 3]i; hak <ref> [9; 10] </ref>ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies . <p> Throughout the paper, we have explored the properties of point-based and interval-based data models. Several promising directions for further research may be identified. First, the mapping of instances in one temporal data model to instances in another has already been explored in a point-based framework <ref> [9] </ref>, but this mapping has not been explored in the context of interval-based data models. Next, we have argued that interval-based data models are in some sense more expressive than point-based data models.
Reference: [10] <author> N. A. Lorentzos and Y. G. Mitsopoulos. </author> <title> SQL Extension for Interval Data. </title> <journal> IEEE TKDE, </journal> <volume> 9(3):480499, </volume> <month> May </month> <year> 1997. </year>
Reference-contexts: Example 5.1 Assume a temporal difference operator. Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak <ref> [2; 10] </ref>ig and r 2 = fhak [1; 4]i; hak [8; 11]i; hak [12; 17]i; hbk [2; 6]ig. <p> (r 1 ; r 2 )^ 8p (9I 1 (hxkI 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak [4; 8]i; hak [1; 6]i; hak <ref> [7; 10] </ref>ig and r 2 = fhak [1; 3]i; hak [9; 10]ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> 1 i 2 r 1 ^ p 2 I 1 ^ 8I 2 (hxkI 2 i 2 r 2 ) p 62 I 2 )) , p 2 A) Assume r 1 = fhak [4; 8]i; hak [1; 6]i; hak [7; 10]ig and r 2 = fhak [1; 3]i; hak <ref> [9; 10] </ref>ig. Then A = f4; 5; 6; 7; 8g satis fies the minimum requirements for temporal difference for the explicit attribute hai and the input relations r 1 and r 2 . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak [1; 6]i; hak <ref> [7; 10] </ref>ig [ fhak [1; 3]i; hak [9; 10]ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies . <p> Concerning the relevant argument tuples of r 1 and r 2 for hai, there are two sets that satisfy the definition, S 1 = fhak [4; 8]ig [ f g and S 2 = fhak [1; 6]i; hak [7; 10]ig [ fhak [1; 3]i; hak <ref> [9; 10] </ref>ig. Note that r 1 [ r 2 does not qualify as a set of relevant argument tuples, since there are subrela-tions of r 1 and r 2 whose union also satisfies . <p> It can make sense to make the definition of interval-based more restrictive. Our current definition of interval-based comprises all operators and models that do not interpret timestamps in any special way. Examples are relational operators in SQL-92 [11] (extended with a period data type), relational operations in IXSQL <ref> [10] </ref>, and non-sequenced operations in AT-SQL [3]. In all these cases, standard relational operators are applied to timestamps. Such an approach is trivially faithful to argument intervalsthe operators have no special temporal semantics. One can argue that such operators do not provide (enhanced) temporal support. <p> This means that all operators are time-fragment preserving. Therefore, SQL-92 is an interval-based data model. It also follows that SQL-92 is not point-based. IXSQL <ref> [10] </ref> IXSQL operators are timestamp-preserving because they inherit the standard SQL-92 semantics. In addition, IXSQL provides normalize and unnormalize operations in order to convert between time points and intervals. These special operations are point-based, but not interval-based: snapshot equivalence is preserved, but interval fragments are not.
Reference: [11] <author> J. Melton and A. R. Simon. </author> <title> Understanding the new SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Two argument tuples with identical explicit join attribute values contribute to the result if their timestamps overlap. Timestamps of result tuples are the intersections of the timestamps of argument tuples. Thus, if r 1 = fhak [2; 5]i; hak <ref> [7; 11] </ref>ig and r 2 = fhak [3; 9]ig then r 1 ./ t r 2 = fhak [3; 5]i; hak [7; 9]ig. It can be shown that this operator preserves snapshot equivalence, hence it is point-based. <p> The merged tuple then 1 In this sense, temporal logic can be also said to be point-based, as the temporal domain consists of points [5]. has this union as its new timestamp. Thus, if r 1 = fhak [2; 5]i; hak <ref> [6; 11] </ref>ig then coal (r 1 ) = fhak [2; 11]ig. Like temporal intersection natural join, this operation is point-based because snapshot equivalent arguments will yield snapshot equivalent results: for snapshot-equivalent arguments, the result will always be the exact same, which is a trivial case of snapshot equivalence. <p> Thus, if r 1 = fhak [2; 5]i; hak [6; 11]ig then coal (r 1 ) = fhak <ref> [2; 11] </ref>ig. Like temporal intersection natural join, this operation is point-based because snapshot equivalent arguments will yield snapshot equivalent results: for snapshot-equivalent arguments, the result will always be the exact same, which is a trivial case of snapshot equivalence. <p> Example 5.1 Assume a temporal difference operator. Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak [2; 10]ig and r 2 = fhak [1; 4]i; hak <ref> [8; 11] </ref>i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; r 0 D <p> Assume r 1 = fhak [2; 10]ig and r 2 = fhak [1; 4]i; hak <ref> [8; 11] </ref>i; hak [12; 17]i; hbk [2; 6]ig. If r 00 1 = r 1 , r 0 2 = fhak [1; 4]ig, and r 00 2 = fhak [1; 4]i; hak [8; 11]ig, then D (r 1 ; r 2 ; hai; f5; 6; 7g) 1 ; r 0 D (r 00 2 ; hai; f5; 6; 7g) The set of relevant argument tuples for the result tuple is S 00 = r 00 2 . <p> Example 5.5 A selection operator that constrains the times-tamp and returns a temporal relation is interval-based, but not point-based. For example, consider I BEFORE [7;9] (r) with r = fhak [2; 5]i; hak <ref> [6; 11] </ref>ig. The result is fhak [2; 5]ig. Using r 0 = fhak [2; 11]ig, which is snapshot equivalent to r, as the argument would yield an empty result. Since selection does not preserve snapshot-equivalence, it is not point-based. <p> Example 5.5 A selection operator that constrains the times-tamp and returns a temporal relation is interval-based, but not point-based. For example, consider I BEFORE [7;9] (r) with r = fhak [2; 5]i; hak [6; 11]ig. The result is fhak [2; 5]ig. Using r 0 = fhak <ref> [2; 11] </ref>ig, which is snapshot equivalent to r, as the argument would yield an empty result. Since selection does not preserve snapshot-equivalence, it is not point-based. On the other hand, it is easy to see that selection is interval-based. <p> Two such operators are described in Examples 6.1 and 6.2, below. Example 6.1 Assume a regular time-shift operator o rts that returns all tuples of the argument relation with the times-tamps being shifted one time unit to the right. Assume r 1 = fhak [2; 5]i; hak <ref> [6; 11] </ref>ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak [3; 6]i; hak [7; 12]ig and o rts (r 2 ) = fhak [3; 12]ig. <p> Example 6.1 Assume a regular time-shift operator o rts that returns all tuples of the argument relation with the times-tamps being shifted one time unit to the right. Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak <ref> [2; 11] </ref>ig. Then o rts (r 1 ) = fhak [3; 6]i; hak [7; 12]ig and o rts (r 2 ) = fhak [3; 12]ig. <p> Example 6.2 Assume an irregular time-shift operator o its that, for any tuple of the argument relation, shifts the start time by two units to the right and the end time by one unit to the right. Assume r 1 = fhak [2; 5]i; hak <ref> [6; 11] </ref>ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak [4; 6]i; hak [8; 12]ig and o its (r 2 ) = fhak [4; 12]ig. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak <ref> [2; 11] </ref>ig. Then o its (r 1 ) = fhak [4; 6]i; hak [8; 12]ig and o its (r 2 ) = fhak [4; 12]ig. The time-shift operators are faithful to their argument intervals in the sense that they dislocate each single interval present in the input relation. <p> Narrowing the set of interval-based operators. It can make sense to make the definition of interval-based more restrictive. Our current definition of interval-based comprises all operators and models that do not interpret timestamps in any special way. Examples are relational operators in SQL-92 <ref> [11] </ref> (extended with a period data type), relational operations in IXSQL [10], and non-sequenced operations in AT-SQL [3]. In all these cases, standard relational operators are applied to timestamps. Such an approach is trivially faithful to argument intervalsthe operators have no special temporal semantics. <p> Note that we only consider proper temporal algebraic operators, i.e., operators that take temporal relations as arguments and return a temporal relation (cf. Section 3). SQL-92 <ref> [11] </ref> SQL-92 (extended with an interval data type) is based on the relational algebra and treats intervals as atomic values without any special temporal semantics. This means that all operators are time-fragment preserving. Therefore, SQL-92 is an interval-based data model. It also follows that SQL-92 is not point-based.
Reference: [12] <author> R. T. Snodgrass. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM TODS, </journal> <volume> 12(2):247298, </volume> <month> Jun </month> <year> 1987. </year>
Reference-contexts: Intervals may simply be employed for reasons of practicality, i.e., as syntactical shorthands for time points, as has been done in some data models (e.g., <ref> [12] </ref>, [14, ch. 1]). Thus, terming a data model interval-based simply if it employs interval timestamps bears little real significanceit says little about the qualities of the data model. Rather the notions of point- and interval-based data models must be defined on a semantic level. <p> The last result is similar to the first one: it also contains the times associated with value a in r 1 that are not associated with value a in r 2 . Put precisely, R 1 and R 4 are snapshot equivalent <ref> [12] </ref>. The difference is that the second tuple in R 1 is represented by two tuples in R 4 . In other words, R 1 is the coalesced version of R 4 . <p> For example, Snodgrass states that A temporal query language should have a canonical model, in which relations are identical if and only if all of their snapshots are identical <ref> [12, p. 288] </ref>. Chomicki states that It is important to see that the data model of TQuel is point-based, not interval-based. Intervals serve only as a representational device. <p> Example 5.1 Assume a temporal difference operator. Let the integers with the &lt; order be the underlying time point domain, and D denote the minimum requirements for this operator. Assume r 1 = fhak [2; 10]ig and r 2 = fhak [1; 4]i; hak [8; 11]i; hak <ref> [12; 17] </ref>i; hbk [2; 6]ig. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak [3; 6]i; hak <ref> [7; 12] </ref>ig and o rts (r 2 ) = fhak [3; 12]ig. Example 6.2 Assume an irregular time-shift operator o its that, for any tuple of the argument relation, shifts the start time by two units to the right and the end time by one unit to the right. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o rts (r 1 ) = fhak [3; 6]i; hak [7; 12]ig and o rts (r 2 ) = fhak <ref> [3; 12] </ref>ig. Example 6.2 Assume an irregular time-shift operator o its that, for any tuple of the argument relation, shifts the start time by two units to the right and the end time by one unit to the right. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak [4; 6]i; hak <ref> [8; 12] </ref>ig and o its (r 2 ) = fhak [4; 12]ig. The time-shift operators are faithful to their argument intervals in the sense that they dislocate each single interval present in the input relation. Therefore, they could be classified as interval-based. <p> Assume r 1 = fhak [2; 5]i; hak [6; 11]ig and r 2 = fhak [2; 11]ig. Then o its (r 1 ) = fhak [4; 6]i; hak [8; 12]ig and o its (r 2 ) = fhak <ref> [4; 12] </ref>ig. The time-shift operators are faithful to their argument intervals in the sense that they dislocate each single interval present in the input relation. Therefore, they could be classified as interval-based.
Reference: [13] <author> R. T. Snodgrass. </author> <title> The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic, </publisher> <year> 1995. </year>
Reference-contexts: This guarantee is met by performing coalescing operations, which can be expensive [4]. While it is possible to sometimes eliminate coalescing during query optimization, there remain situations where coalescing has to be performed <ref> [13, ch. 27] </ref>. 3 Temporal Data Models and Time Domains A relational data model M = hD; Ai is composed of a set of data structures, D, and a set A of algebraic operations defined on the data structures. <p> Predicates and operations for points and intervals are described in almost all definitions of temporal data models [14] <ref> [13, ch. 10] </ref>. <p> In addition, IXSQL provides normalize and unnormalize operations in order to convert between time points and intervals. These special operations are point-based, but not interval-based: snapshot equivalence is preserved, but interval fragments are not. Thus, IXSQL is a mixed data model. TSQL2 <ref> [13] </ref> Unlike the two previous models, TSQL2 employs a temporal algebra that gives a special meaning to timestamps. It was one of the design goals of TSQL2 to make the format of timestamps irrelevant. This is achieved by enforcing a canonical representation based on temporal elements.
Reference: [14] <author> A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass. </author> <title> Temporal Databases: Theory, Design, and Implementation. </title> <address> Benjamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: Intervals may simply be employed for reasons of practicality, i.e., as syntactical shorthands for time points, as has been done in some data models (e.g., [12], <ref> [14, ch. 1] </ref>). Thus, terming a data model interval-based simply if it employs interval timestamps bears little real significanceit says little about the qualities of the data model. Rather the notions of point- and interval-based data models must be defined on a semantic level. <p> When designing a temporal data model, an important and central aspect is the choice of appropriate timestamps of the database facts. Time points and time intervals, defined below, provide the most common choices. Intervals may be built from time points [2], <ref> [14, ch. 21] </ref>. Definition 3.1 (Time-point and Time-interval Domains) Let T be an infinite set. 1. T p = hT; &lt;i is a time point domain over T iff &lt; defines a total order on T . <p> Hence, we would timestamp a tuple such as hai with intervals if the end points bear some meaning, and use time points as timestamps if the notion of end points is meaningless. Predicates and operations for points and intervals are described in almost all definitions of temporal data models <ref> [14] </ref> [13, ch. 10].
Reference: [15] <author> D. Toman. </author> <title> Point-based vs Interval-based Temporal Query Languages. </title> <booktitle> Proc. of the 15th ACM PODS Symposium, </booktitle> <pages> pages 5867, </pages> <month> Jun </month> <year> 1996. </year>
Reference-contexts: This correspondence shows that all first-order queries can be conveniently asked using the point-based query language (. . . ) and then mechanically translated to an interval-based query language . . . <ref> [15, p. 59] </ref>. The literature reveals that different researchers perceive the notions of point-based and interval-based data models quite differently. In particular, the notion of interval-based data model remains to be given a formal definition, alongside a rigorous semantics.
References-found: 15

