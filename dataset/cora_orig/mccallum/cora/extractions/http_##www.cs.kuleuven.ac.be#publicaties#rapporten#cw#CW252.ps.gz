URL: http://www.cs.kuleuven.ac.be/publicaties/rapporten/cw/CW252.ps.gz
Refering-URL: http://www.cs.kuleuven.ac.be/publicaties/rapporten/CW1997.html
Root-URL: 
Title: Extending Homeomorphic Embedding in the Context of Logic Programming  
Author: Michael Leuschel 
Keyword: Termination, Well-quasi orders, Logic Programming, Program Transformation, Program Analysis, Partial Deduction.  
Note: CR Subject Classification I.2.3, I.2.2, F.4.1, D.1.6.  
Affiliation: Department of Computing Science, K.U.Leuven  
Date: 252, June 1997 (Revised August 1997)  
Pubnum: Report CW  
Abstract: Recently well-quasi orders in general, and homeomorphic embedding in particular, have gained popularity to ensure the termination of program analysis, specialisation and transformation techniques. However, as we illustrate in the paper, the homeomorphic embedding relation as it is usually defined suffers from several inadequacies which make it less suitable in a logic programming context. We present several increasingly refined ways to remedy this problem by providing more sophisticated treatments of variables and present a new, extended homeomorphic embedding relation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Alpuente, M. Falaschi, P. Julian, and G. Vidal. </author> <title> Spezialisation of lazy functional logic programs. </title> <booktitle> In Proceedings of PEPM'97, the ACM Sigplan Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context. <p> We believe that fi fl can be of value in other contexts and for other languages (such as in the context of partial evaluation of functional-logic programs <ref> [1] </ref> or of supercompilation [45] of functional programming languages, where | at specialisation time variables also appear).
Reference: [2] <author> K. R. Apt. </author> <title> Introduction to logic programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, chapter 10, </booktitle> <pages> pages 495-574. </pages> <publisher> North-Holland Amsterdam, </publisher> <year> 1990. </year>
Reference-contexts: Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context. We start examining them in the next section. 2 Well-quasi orders and homeomorphic embedding From now on, we suppose familiarity with basic notions in logic programming <ref> [2, 29] </ref>. We also define an expression to be either a term, an atom, a literal, a conjunction, a disjunction or a program clause. Formally, well-quasi orders can be defined as follows.
Reference: [3] <author> R. Bol. </author> <title> Loop checking in partial deduction. </title> <journal> The Journal of Logic Programming, </journal> 16(1&2):25-46, 1993. 
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context.
Reference: [4] <author> M. Bruynooghe, D. De Schreye, and B. Martens. </author> <title> A general criterion for avoiding infinite unfolding during partial deduction. </title> <journal> New Generation Computing, </journal> <volume> 11(1) </volume> <pages> 47-79, </pages> <year> 1992. </year>
Reference-contexts: This is why, contrary to maybe functional programming, measures in addition to determinacy have to be adopted to ensure local termination. Luckily, more refined approaches to ensure termination of unfolding exist. The methods in <ref> [4, 34, 33, 32] </ref> are based on well-founded orders, inspired by their usefulness in the context of static termination analysis (see e.g. [8, 5]). <p> Much more elaborate techniques based upon well-founded orders, which e.g. split the expressions into classes or continuously refine the orders during the unfolding process, exist and we refer the reader to <ref> [4, 34, 33, 32] </ref> for further details. These works also present a further refinement which, instead of requiring a decrease wrt every ancestor, only requires a decrease wrt the covering ancestors, i.e. one only compares with the ancestor atoms from which the current atom descends (via resolution).
Reference: [5] <author> D. De Schreye and S. Decorte. </author> <title> Termination of logic programs: The never ending story. </title> <journal> The Journal of Logic Programming, </journal> <volume> 19 & 20 </volume> <pages> 199-260, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The problem of ensuring termination arises in a lot of different contexts in computer science. For instance a lot of work has been devoted to proving termination of term rewriting systems (e.g. [7] and references therein) or of logic programs (e.g. <ref> [5, 38] </ref> and references therein). It is also an important issue within all areas of program analysis, specialisation and transformation: one usually strives for methods which are guaranteed to terminate. <p> For instance static termination analysis of logic programs <ref> [5, 38] </ref> falls within the former context, while termination of e.g. partial deduction | an automatic technique for specialising logic programs | is usually ensured in an on-line manner. Let us examine the case of partial deduction in more detail. <p> Luckily, more refined approaches to ensure termination of unfolding exist. The methods in [4, 34, 33, 32] are based on well-founded orders, inspired by their usefulness in the context of static termination analysis (see e.g. <ref> [8, 5] </ref>). These techniques ensure termination, while at the same time allowing unfolding related to the structural aspect of the program and goal to be partially deduced, e.g. permitting the consumption of static input within the atoms of A.
Reference: [6] <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3 </volume> <pages> 69-116, </pages> <year> 1987. </year>
Reference-contexts: An interesting wqo is the homeomorphic embedding relation fi, which derives from results by Higman [15] and Kruskal [19]. It has been used in the context of term rewriting systems in <ref> [6, 7] </ref>, and adapted for use in supercompilation ([45]) in [43]. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. Some complexity results can be found in [44] and [14] (also summarised in [31]).
Reference: [7] <author> N. Dershowitz and J.-P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, </volume> <pages> pages 243-320. </pages> <publisher> Elsevier, MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction The problem of ensuring termination arises in a lot of different contexts in computer science. For instance a lot of work has been devoted to proving termination of term rewriting systems (e.g. <ref> [7] </ref> and references therein) or of logic programs (e.g. [5, 38] and references therein). It is also an important issue within all areas of program analysis, specialisation and transformation: one usually strives for methods which are guaranteed to terminate. <p> An interesting wqo is the homeomorphic embedding relation fi, which derives from results by Higman [15] and Kruskal [19]. It has been used in the context of term rewriting systems in <ref> [6, 7] </ref>, and adapted for use in supercompilation ([45]) in [43]. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. Some complexity results can be found in [44] and [14] (also summarised in [31]). <p> Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. Some complexity results can be found in [44] and [14] (also summarised in [31]). The following is the definition from [43], which adapts the pure homeomorphic embedding from <ref> [7] </ref> by adding a rudimentary treatment of variables. Definition 2.6 (fi) The (pure) homeomorphic embedding relation fi on expressions is defined inductively as follows: 1. <p> One point is the restriction to a finite alphabet. Indeed, for a lot of practical logic programs, using e.g. arithmetic built-ins or even = ::=2, a finite alphabet is no longer sufficient. Luckily, the fully general definition of homeomorphic embedding as in <ref> [19, 7] </ref> remedies this aspect. It even allows functors with variable arity 4 (the result of [15] can only be applied when the arities are fixed). We will show below how this definition can be adapted to a logic programming context. <p> If we have a finite alphabet, then equality is a wqo (and this is actually the way the pure homeomorphic embedding of <ref> [7] </ref> is obtained from the fully general homeomorphic embedding). In the context of e.g. partial deduction, we know that the functors occurring within the program (text) and goal to be analysed are of finite number. One might call these functors static and all others dynamic.
Reference: [8] <author> N. Dershowitz and Z. Manna. </author> <title> Proving termination with multiset orderings. </title> <journal> Communications of the ACM, </journal> <volume> 22(8) </volume> <pages> 465-476, </pages> <year> 1979. </year>
Reference-contexts: Luckily, more refined approaches to ensure termination of unfolding exist. The methods in [4, 34, 33, 32] are based on well-founded orders, inspired by their usefulness in the context of static termination analysis (see e.g. <ref> [8, 5] </ref>). These techniques ensure termination, while at the same time allowing unfolding related to the structural aspect of the program and goal to be partially deduced, e.g. permitting the consumption of static input within the atoms of A.
Reference: [9] <author> J. Gallagher. </author> <title> Tutorial on specialisation of logic programs. </title> <booktitle> In Proceedings of PEPM'93, the ACM Sigplan Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 88-98. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: the SLDNF-trees | often also referred to as unfolding steps | are those that have been performed beforehand, justifying the hope that the specialised program be more efficient. fl Supported by the Belgian GOA "Non-Standard Applications of Abstract Interpretation" 1 Now, to ensure termination of partial deduction two issues arise <ref> [9, 35] </ref> (cf. Figure 1). One is called the local termination problem, corresponding to the fact that each generated SLDNF-tree should be finite. The other is called the global termination problem, meaning that the set A should contain only a finite number of atoms.
Reference: [10] <author> J. Gallagher and M. Bruynooghe. </author> <title> Some low-level transformations for logic programs. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of Meta90 Workshop on Meta Programming in Logic, </booktitle> <pages> pages 229-244, </pages> <address> Leuven, Belgium, </address> <year> 1990. </year>
Reference-contexts: The well-founded measure function h has the property that h (t) 0 for any expression t and h (t) &gt; 0 for any non-variable expression t. The following important lemma is proven for h (:) in <ref> [10] </ref> (see also [35]).
Reference: [11] <author> J. Gallagher and M. Bruynooghe. </author> <title> The derivation of an algorithm for program specialisation. </title> <journal> New Generation Computing, </journal> <volume> 9(3 </volume> & 4):305-333, 1991. 
Reference-contexts: A 1 fi fl A 2 (but not A 0 fi fl A 1 or A 0 fi fl A 2 ). Theorem 4.2 fi fl is a wqo on expressions. To prove Theorem 4.2 we need the following machinery. First we take a well-founded measure function from <ref> [11] </ref> (also in the extended version of [35]): Definition 4.3 (s (:), h (:)) Let Expr denote the sets of expressions.
Reference: [12] <author> J. H. Gallier. </author> <title> What's so special about Kruskal's theorem and the ordinal 0 ? A survey of some results in proof theory. </title> <type> Technical report, </type> <institution> University of Pennsylvania, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: Proposition 2.8 The relation fi is a wqo on the set of expressions over a finite alphabet. For a complete proof, reusing Higman's Lemma [15, 19] in a straightforward manner, see e.g. [24]. (For constructive proofs of Higman's Lemma [15] see [42, 36]. See also <ref> [12] </ref> and [40].
Reference: [13] <author> R. Gluck, J. Jtrgensen, B. Martens, and M. H. Strensen. </author> <title> Controlling conjunctive partial deduction of definite logic programs. </title> <editor> In H. Kuchen and S. Swierstra, editors, </editor> <booktitle> Proceedings of the International Symposium on Programming Languages, Implementations, Logics and Programs (PLILP'96), </booktitle> <volume> LNCS 1140, </volume> <pages> pages 152-166, </pages> <address> Aachen, Germany, </address> <month> September </month> <year> 1996. </year> <note> Springer-Verlag. Extended version as Technical Report CW 226, K.U. Leuven. Accessible via http://www.cs.kuleuven.ac.be/~lpai. </note>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context.
Reference: [14] <author> J. Gustedt. </author> <title> Algorithmic Aspects of Ordered Structures. </title> <type> PhD thesis, </type> <institution> Technische Universitat Berlin, </institution> <year> 1992. </year>
Reference-contexts: It has been used in the context of term rewriting systems in [6, 7], and adapted for use in supercompilation ([45]) in [43]. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. Some complexity results can be found in [44] and <ref> [14] </ref> (also summarised in [31]). The following is the definition from [43], which adapts the pure homeomorphic embedding from [7] by adding a rudimentary treatment of variables. Definition 2.6 (fi) The (pure) homeomorphic embedding relation fi on expressions is defined inductively as follows: 1.
Reference: [15] <author> G. Higman. </author> <title> Ordering by divisibility in abstract algebras. </title> <journal> Proceedings of the London Mathematical Society, </journal> <volume> 2 </volume> <pages> 326-336, </pages> <year> 1952. </year>
Reference-contexts: We also say that V is a well-quasi order (wqo) on V . 3 Note that e.g. Higman <ref> [15] </ref> used an alternate definition of well-quasi orders in terms of the "finite basis property" (or "finite generating set" in [19]). However, the above definition is the one most often used in the context of termination. Both definitions are equivalent by Theorem 2.1 in [15]. <p> Higman <ref> [15] </ref> used an alternate definition of well-quasi orders in terms of the "finite basis property" (or "finite generating set" in [19]). However, the above definition is the one most often used in the context of termination. Both definitions are equivalent by Theorem 2.1 in [15]. A different (but equivalent) definition of a wqo is given in [21, 47]: A quasi-order V is a wqo iff for all quasi-orders V which contain V (i.e. v V v 0 ) v V v 0 ) the corresponding strict partial order V is a wfo. <p> Then the quasi order V defined by v 1 V v 2 iff v 1 1 V v 2 and v 1 2 V v 2 , is also a wqo on V . An interesting wqo is the homeomorphic embedding relation fi, which derives from results by Higman <ref> [15] </ref> and Kruskal [19]. It has been used in the context of term rewriting systems in [6, 7], and adapted for use in supercompilation ([45]) in [43]. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. <p> E.g. 10 divides 30 and 2 fi 5 can be obtained from 2 fi 3 fi 5 by striking out the 3. Proposition 2.8 The relation fi is a wqo on the set of expressions over a finite alphabet. For a complete proof, reusing Higman's Lemma <ref> [15, 19] </ref> in a straightforward manner, see e.g. [24]. (For constructive proofs of Higman's Lemma [15] see [42, 36]. See also [12] and [40]. <p> Proposition 2.8 The relation fi is a wqo on the set of expressions over a finite alphabet. For a complete proof, reusing Higman's Lemma [15, 19] in a straightforward manner, see e.g. [24]. (For constructive proofs of Higman's Lemma <ref> [15] </ref> see [42, 36]. See also [12] and [40]. <p> Indeed, for a lot of practical logic programs, using e.g. arithmetic built-ins or even = ::=2, a finite alphabet is no longer sufficient. Luckily, the fully general definition of homeomorphic embedding as in [19, 7] remedies this aspect. It even allows functors with variable arity 4 (the result of <ref> [15] </ref> can only be applied when the arities are fixed). We will show below how this definition can be adapted to a logic programming context. However, there is another unsatisfactory aspect of fi + .
Reference: [16] <author> N. D. Jones. </author> <title> An introduction to partial evaluation. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(3) </volume> <pages> 480-503, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: The depth bound will therefore lead either to too little or too much unfolding in a lot of interesting cases. Another approach, often used in partial evaluation of functional programs <ref> [17, 16] </ref>, is to only expand a tree while it is determinate (i.e. it only has one non-failing branch). However, this in itself does not guarantee termination, as there can be infinitely failing determinate computations.
Reference: [17] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: The depth bound will therefore lead either to too little or too much unfolding in a lot of interesting cases. Another approach, often used in partial evaluation of functional programs <ref> [17, 16] </ref>, is to only expand a tree while it is determinate (i.e. it only has one non-failing branch). However, this in itself does not guarantee termination, as there can be infinitely failing determinate computations.
Reference: [18] <author> J. Jtrgensen, M. Leuschel, and B. Martens. </author> <title> Conjunctive partial deduction in practice. </title> <editor> In J. Gal-lagher, editor, </editor> <booktitle> Proceedings of the International Workshop on Logic Program Synthesis and Transformation (LOPSTR'96), </booktitle> <volume> LNCS 1207, </volume> <pages> pages 59-82, </pages> <address> Stockholm, Sweden, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. Also in the Proceedings of BENELOG'96. Extended version as Technical Report CW 242, K.U. Leuven. </note>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context. <p> on its own, fi fl (as well as fi + and fi) will sometimes allow too much unfolding than desirable for efficiency concerns (i.e. more unfolding does not always imply a better specialised program) and additional considerations, like determinacy, have to be taken into account (see e.g. the experiments in <ref> [24, 27, 18] </ref>). For some applications, fi as well as fi + and fi fl remain too restrictive. In particular, they do not always deal satisfactorily with fluctuating structure (arising e.g. for certain meta-interpretation tasks) [46].
Reference: [19] <author> J. B. Kruskal. </author> <title> Well-quasi ordering, the tree theorem, and Vazsonyi's conjecture. </title> <journal> Tansactions of the American Mathematical Society, </journal> <volume> 95 </volume> <pages> 210-225, </pages> <year> 1960. </year>
Reference-contexts: We also say that V is a well-quasi order (wqo) on V . 3 Note that e.g. Higman [15] used an alternate definition of well-quasi orders in terms of the "finite basis property" (or "finite generating set" in <ref> [19] </ref>). However, the above definition is the one most often used in the context of termination. Both definitions are equivalent by Theorem 2.1 in [15]. <p> An interesting wqo is the homeomorphic embedding relation fi, which derives from results by Higman [15] and Kruskal <ref> [19] </ref>. It has been used in the context of term rewriting systems in [6, 7], and adapted for use in supercompilation ([45]) in [43]. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. <p> E.g. 10 divides 30 and 2 fi 5 can be obtained from 2 fi 3 fi 5 by striking out the 3. Proposition 2.8 The relation fi is a wqo on the set of expressions over a finite alphabet. For a complete proof, reusing Higman's Lemma <ref> [15, 19] </ref> in a straightforward manner, see e.g. [24]. (For constructive proofs of Higman's Lemma [15] see [42, 36]. See also [12] and [40]. <p> One point is the restriction to a finite alphabet. Indeed, for a lot of practical logic programs, using e.g. arithmetic built-ins or even = ::=2, a finite alphabet is no longer sufficient. Luckily, the fully general definition of homeomorphic embedding as in <ref> [19, 7] </ref> remedies this aspect. It even allows functors with variable arity 4 (the result of [15] can only be applied when the arities are fixed). We will show below how this definition can be adapted to a logic programming context. <p> The latter will always be satisfied if n 6= m. 8 It follows that, for every expression A, there are no infinite chains of strictly more general expressions. We can now prove Theorem 4.2 as follows. Proof of Theorem 4.2. We know by Higman-Kruskal's theorem <ref> [19] </ref> that without the extra condition of point 3 requiring hs 1 ; : : :; s m i not to be a strict instance of ht 1 ; : : :; t n i we have a wqo. Let us refer to this wqo by fi.
Reference: [20] <author> L. Lafave and J. Gallagher. </author> <title> Constraint-based partial evaluation of rewriting-based functional logic programs. </title> <editor> In N. Fuchs, editor, </editor> <booktitle> Pre-Proceedings of the International Workshop on Logic Program Synthesis and Transformation (LOPSTR'97), </booktitle> <address> Leuven, Belgium, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context.
Reference: [21] <author> P. Lescanne. </author> <title> Rewrite orderings and termination of rewrite systems. </title> <editor> In A. Tarlecki, editor, </editor> <booktitle> Mathematical Foundations of Computer Science 1991, </booktitle> <volume> LNCS 520, </volume> <pages> pages 17-27, </pages> <address> Kazimierz Dolny, Poland, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: However, the above definition is the one most often used in the context of termination. Both definitions are equivalent by Theorem 2.1 in [15]. A different (but equivalent) definition of a wqo is given in <ref> [21, 47] </ref>: A quasi-order V is a wqo iff for all quasi-orders V which contain V (i.e. v V v 0 ) v V v 0 ) the corresponding strict partial order V is a wfo.
Reference: [22] <author> P. Lescanne. </author> <title> Well rewrite orderings and well quasi-orderings. </title> <type> Technical Report N o 1385, </type> <institution> INRIA-Lorraine, France, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: The use of characteristic trees [24, 27] remedies this problem to some extent, but not totally. A further step towards a solution is presented in [46]. In that light, it might be of interest to study whether the extensions of the homeomorphic embedding relation proposed in [39] and <ref> [22] </ref> (in the context of static termination analysis of term rewrite systems) can be useful in an on-line setting.
Reference: [23] <author> M. Leuschel. </author> <title> The ecce partial deduction system and the dppd library of benchmarks. </title> <note> Obtainable via http://www.cs.kuleuven.ac.be/~lpai, 1996. </note>
Reference-contexts: We also believe that fi fl provides both a theoretically and practically more satisfactory basis 9 than fi + or fi and we will incorporate it into the automatic partial deduction system ecce <ref> [23] </ref> in the near future. Acknowledgments I would like to thank Jesper Jtrgensen, Bern Martens, Jacques Riche and Morten Heine Strensen for all the discussions, comments and joint research which led to this paper. Bern Martens also provided very useful comments on a draft of this paper.
Reference: [24] <author> M. Leuschel. </author> <title> Advanced Techniques for Logic Program Specialisation. </title> <type> PhD thesis, K.U. </type> <institution> Leuven, </institution> <month> May </month> <year> 1997. </year> <note> Accessible via http://www.cs.kuleuven.ac.be/~michael. </note>
Reference-contexts: Proposition 2.8 The relation fi is a wqo on the set of expressions over a finite alphabet. For a complete proof, reusing Higman's Lemma [15, 19] in a straightforward manner, see e.g. <ref> [24] </ref>. (For constructive proofs of Higman's Lemma [15] see [42, 36]. See also [12] and [40]. <p> The homeomorphic embedding relation is also useful for handling structures other than expressions. It has e.g. been successfully applied in <ref> [26, 24, 27] </ref> to detect (potentially) non-terminating sequences of characteristic trees. Also, fi seems to have the desired property that very often only "real" loops are detected and that they are detected at the earliest possible moment (see [31]). <p> Secondly, fi behaves in quite unexpected ways in the context of generalisation, where it can pose some subtle problems wrt the termination of a generalisation process. Example 3.1 Take for instance the following generalisation algorithm, which appears (in disguise) in a lot of partial deduction algorithms (e.g. <ref> [26, 24, 27] </ref>). (In that context A stands for the set of atoms for which SLDNF-trees have already been constructed while B are the atoms in the leaves of these trees. <p> We therefore calculate the msg (fp (X ; X ); p (X ; Y )g) = p (X ; Y ) and we have a loop (we get B 0 = fp (X; Y )g). 6 To remedy these problems, <ref> [26, 24, 27] </ref> introduced the so called strict homeomorphic embedding as follows: Definition 3.2 (fi + ) Let A; B be expressions. Then B (strictly homeomorphically) embeds A, written as A fi + B, iff A fi B and A is not a strict instance of B. <p> Note that still X fi + Y and X fi + X. Also notice that, if we replace fi of Example 3.1 by fi + we no longer have a problem with termination (see Section 6.2.4 of <ref> [24, 27] </ref> for a termination proof of an Algorithm containing the one of Example 3.1). <p> For particular types of functors for which e.g. a natural well-founded order exists (e.g. the natural numbers) one can use more refined wqo constructed from Lemma 2.3. The reason why this recursive use of the "not strict instance" test was not incorporated in <ref> [26, 24, 27] </ref> was that the authors were not sure that fi fl is actually a wqo (no proof was found yet). In fact, recursively applying the "not strict instance" looks very dangerous. <p> on its own, fi fl (as well as fi + and fi) will sometimes allow too much unfolding than desirable for efficiency concerns (i.e. more unfolding does not always imply a better specialised program) and additional considerations, like determinacy, have to be taken into account (see e.g. the experiments in <ref> [24, 27, 18] </ref>). For some applications, fi as well as fi + and fi fl remain too restrictive. In particular, they do not always deal satisfactorily with fluctuating structure (arising e.g. for certain meta-interpretation tasks) [46]. <p> For some applications, fi as well as fi + and fi fl remain too restrictive. In particular, they do not always deal satisfactorily with fluctuating structure (arising e.g. for certain meta-interpretation tasks) [46]. The use of characteristic trees <ref> [24, 27] </ref> remedies this problem to some extent, but not totally. A further step towards a solution is presented in [46].
Reference: [25] <author> M. Leuschel. </author> <title> Extending homeomorphic embedding in the context of logic programming. </title> <type> Technical Report CW 252, </type> <institution> Departement Computerwetenschappen, K.U. Leuven, Belgium, </institution> <month> June (revised August) </month> <year> 1997. </year>
Reference: [26] <author> M. Leuschel and B. Martens. </author> <title> Global control for partial deduction through characteristic atoms and global trees. </title> <editor> In O. Danvy, R. Gluck, and P. Thiemann, editors, </editor> <booktitle> Proceedings of the 1996 Dagstuhl Seminar on Partial Evaluation, </booktitle> <volume> LNCS 1110, </volume> <pages> pages 263-283, </pages> <publisher> Schlo Dagstuhl, </publisher> <year> 1996. </year> <note> Springer-Verlag. Extended version as Technical Report CW 220, K.U. Leuven. Accessible via http://www.cs.kuleuven.ac.be/~lpai. </note>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context. <p> The homeomorphic embedding relation is also useful for handling structures other than expressions. It has e.g. been successfully applied in <ref> [26, 24, 27] </ref> to detect (potentially) non-terminating sequences of characteristic trees. Also, fi seems to have the desired property that very often only "real" loops are detected and that they are detected at the earliest possible moment (see [31]). <p> Secondly, fi behaves in quite unexpected ways in the context of generalisation, where it can pose some subtle problems wrt the termination of a generalisation process. Example 3.1 Take for instance the following generalisation algorithm, which appears (in disguise) in a lot of partial deduction algorithms (e.g. <ref> [26, 24, 27] </ref>). (In that context A stands for the set of atoms for which SLDNF-trees have already been constructed while B are the atoms in the leaves of these trees. <p> We therefore calculate the msg (fp (X ; X ); p (X ; Y )g) = p (X ; Y ) and we have a loop (we get B 0 = fp (X; Y )g). 6 To remedy these problems, <ref> [26, 24, 27] </ref> introduced the so called strict homeomorphic embedding as follows: Definition 3.2 (fi + ) Let A; B be expressions. Then B (strictly homeomorphically) embeds A, written as A fi + B, iff A fi B and A is not a strict instance of B. <p> For particular types of functors for which e.g. a natural well-founded order exists (e.g. the natural numbers) one can use more refined wqo constructed from Lemma 2.3. The reason why this recursive use of the "not strict instance" test was not incorporated in <ref> [26, 24, 27] </ref> was that the authors were not sure that fi fl is actually a wqo (no proof was found yet). In fact, recursively applying the "not strict instance" looks very dangerous.
Reference: [27] <author> M. Leuschel, B. Martens, and D. De Schreye. </author> <title> Controlling generalisation and polyvariance in partial deduction of normal logic programs. </title> <type> Technical Report CW 248, </type> <institution> Departement Computer-wetenschappen, K.U. Leuven, Belgium, </institution> <month> February </month> <year> 1996. </year> <note> Submitted to ACM Toplas. </note>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context. <p> The homeomorphic embedding relation is also useful for handling structures other than expressions. It has e.g. been successfully applied in <ref> [26, 24, 27] </ref> to detect (potentially) non-terminating sequences of characteristic trees. Also, fi seems to have the desired property that very often only "real" loops are detected and that they are detected at the earliest possible moment (see [31]). <p> Secondly, fi behaves in quite unexpected ways in the context of generalisation, where it can pose some subtle problems wrt the termination of a generalisation process. Example 3.1 Take for instance the following generalisation algorithm, which appears (in disguise) in a lot of partial deduction algorithms (e.g. <ref> [26, 24, 27] </ref>). (In that context A stands for the set of atoms for which SLDNF-trees have already been constructed while B are the atoms in the leaves of these trees. <p> We therefore calculate the msg (fp (X ; X ); p (X ; Y )g) = p (X ; Y ) and we have a loop (we get B 0 = fp (X; Y )g). 6 To remedy these problems, <ref> [26, 24, 27] </ref> introduced the so called strict homeomorphic embedding as follows: Definition 3.2 (fi + ) Let A; B be expressions. Then B (strictly homeomorphically) embeds A, written as A fi + B, iff A fi B and A is not a strict instance of B. <p> Note that still X fi + Y and X fi + X. Also notice that, if we replace fi of Example 3.1 by fi + we no longer have a problem with termination (see Section 6.2.4 of <ref> [24, 27] </ref> for a termination proof of an Algorithm containing the one of Example 3.1). <p> For particular types of functors for which e.g. a natural well-founded order exists (e.g. the natural numbers) one can use more refined wqo constructed from Lemma 2.3. The reason why this recursive use of the "not strict instance" test was not incorporated in <ref> [26, 24, 27] </ref> was that the authors were not sure that fi fl is actually a wqo (no proof was found yet). In fact, recursively applying the "not strict instance" looks very dangerous. <p> on its own, fi fl (as well as fi + and fi) will sometimes allow too much unfolding than desirable for efficiency concerns (i.e. more unfolding does not always imply a better specialised program) and additional considerations, like determinacy, have to be taken into account (see e.g. the experiments in <ref> [24, 27, 18] </ref>). For some applications, fi as well as fi + and fi fl remain too restrictive. In particular, they do not always deal satisfactorily with fluctuating structure (arising e.g. for certain meta-interpretation tasks) [46]. <p> For some applications, fi as well as fi + and fi fl remain too restrictive. In particular, they do not always deal satisfactorily with fluctuating structure (arising e.g. for certain meta-interpretation tasks) [46]. The use of characteristic trees <ref> [24, 27] </ref> remedies this problem to some extent, but not totally. A further step towards a solution is presented in [46].
Reference: [28] <author> N. Lindenstrauss, Y. Sagiv, and A. Serebrenik. </author> <title> Unfolding the mystery of mergesort. </title> <editor> In N. Fuchs, editor, </editor> <booktitle> Pre-Proceedings of the International Workshop on Logic Program Synthesis and Transformation (LOPSTR'97), </booktitle> <address> Leuven, Belgium, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: The homeomorphic embedding relation is very generous. It will for example, without further refinement, permit the full unfolding of most terminating Datalog programs, the quicksort or even the mergesort program (the latter poses problems to some static termination analysis methods <ref> [38, 28] </ref>) | when the list to be sorted is known (see Appendix B). Also, it will allow a process to go from p ([]; [a]) to p ([a]; []) but also the other way around.
Reference: [29] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context. We start examining them in the next section. 2 Well-quasi orders and homeomorphic embedding From now on, we suppose familiarity with basic notions in logic programming <ref> [2, 29] </ref>. We also define an expression to be either a term, an atom, a literal, a conjunction, a disjunction or a program clause. Formally, well-quasi orders can be defined as follows.
Reference: [30] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> The Journal of Logic Programming, </journal> <volume> 11(3& </volume> 4):217-242, 1991. 
Reference-contexts: Let us examine the case of partial deduction in more detail. Partial deduction based upon the Lloyd and Shepherdson framework <ref> [30] </ref> generates (possibly incomplete) SLDNF-trees for a set A of atoms. The specialised program is extracted from these trees by producing one clause (called a resultant) for every non-failing branch.
Reference: [31] <author> R. Marlet. </author> <title> Vers une Formalisation de l' Evaluation Partielle. </title> <type> PhD thesis, </type> <institution> Universite de Nice - Sophia Antipolis, </institution> <month> December </month> <year> 1994. </year> <month> 11 </month>
Reference-contexts: It has been used in the context of term rewriting systems in [6, 7], and adapted for use in supercompilation ([45]) in [43]. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in <ref> [31] </ref>. Some complexity results can be found in [44] and [14] (also summarised in [31]). The following is the definition from [43], which adapts the pure homeomorphic embedding from [7] by adding a rudimentary treatment of variables. <p> Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in <ref> [31] </ref>. Some complexity results can be found in [44] and [14] (also summarised in [31]). The following is the definition from [43], which adapts the pure homeomorphic embedding from [7] by adding a rudimentary treatment of variables. Definition 2.6 (fi) The (pure) homeomorphic embedding relation fi on expressions is defined inductively as follows: 1. <p> It has e.g. been successfully applied in [26, 24, 27] to detect (potentially) non-terminating sequences of characteristic trees. Also, fi seems to have the desired property that very often only "real" loops are detected and that they are detected at the earliest possible moment (see <ref> [31] </ref>). To conclude this section, we conjecture that the homeomorphic embedding relation might also be useful within debuggers to spot potential loops and alert the user. 3 A more refined treatment of variables While fi has a lot of desirable properties it still suffers from some drawbacks. <p> An alternate approach to Definition 3.2 | at least for the aspect of treating variables in a more refined way | might be based on numbering variables using some mapping #(:) and then stipulating that X fi # Y iff #(X) #(Y ). For instance in <ref> [31] </ref> a de Bruijn numbering of the variables is proposed. Such an approach, however, has a somewhat ad hoc flavour to it. Take for instance the terms p (X; Y; X) and p (X; Y; Y ). <p> The following, new and more refined embedding relation remedies this somewhat ad hoc aspect of fi + . Definition 4.1 (fi fl ) Given a wqo on the functors, we define the extended homeomorphic embedding on expressions by the following rules: 3 <ref> [31] </ref> also proposes to consider all possible numberings, but (leading to n! complexity, where n is the number of variables in the terms to be compared).
Reference: [32] <author> B. Martens. </author> <title> On the Semantics of Meta-Programming and the Control of Partial Deduction in Logic Programming. </title> <type> PhD thesis, K.U. </type> <institution> Leuven, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: This is why, contrary to maybe functional programming, measures in addition to determinacy have to be adopted to ensure local termination. Luckily, more refined approaches to ensure termination of unfolding exist. The methods in <ref> [4, 34, 33, 32] </ref> are based on well-founded orders, inspired by their usefulness in the context of static termination analysis (see e.g. [8, 5]). <p> Much more elaborate techniques based upon well-founded orders, which e.g. split the expressions into classes or continuously refine the orders during the unfolding process, exist and we refer the reader to <ref> [4, 34, 33, 32] </ref> for further details. These works also present a further refinement which, instead of requiring a decrease wrt every ancestor, only requires a decrease wrt the covering ancestors, i.e. one only compares with the ancestor atoms from which the current atom descends (via resolution). <p> However, wfo are usually extended to incorporate variant checking and then require inspecting every predecessor anyway (though only when there is no strict weight decrease, see e.g. <ref> [32, 33] </ref>). 5 the head strictly larger than the body atom). As already mentioned, for any extension of a wqo we have that &lt; is a wfo. Thus we know that the program just consisting of C 1 is terminating.
Reference: [33] <author> B. Martens and D. De Schreye. </author> <title> Automatic finite unfolding using well-founded measures. </title> <journal> The Journal of Logic Programming, </journal> <volume> 28(2) </volume> <pages> 89-146, </pages> <month> August </month> <year> 1996. </year> <note> Abridged and revised version of Technical Report CW180, Departement Computerwetenschappen, K.U.Leuven, October 1993, accessible via http://www.cs.kuleuven.ac.be/~lpai. </note>
Reference-contexts: This is why, contrary to maybe functional programming, measures in addition to determinacy have to be adopted to ensure local termination. Luckily, more refined approaches to ensure termination of unfolding exist. The methods in <ref> [4, 34, 33, 32] </ref> are based on well-founded orders, inspired by their usefulness in the context of static termination analysis (see e.g. [8, 5]). <p> Much more elaborate techniques based upon well-founded orders, which e.g. split the expressions into classes or continuously refine the orders during the unfolding process, exist and we refer the reader to <ref> [4, 34, 33, 32] </ref> for further details. These works also present a further refinement which, instead of requiring a decrease wrt every ancestor, only requires a decrease wrt the covering ancestors, i.e. one only compares with the ancestor atoms from which the current atom descends (via resolution). <p> Now, if in another context we want to go from p ([a]; []) to p ([]; [a]) this is clearly impossible (using &lt;) because we cannot have p ([a]; []) &gt; p ([]; [a]). 2 When using a wfo one has to compare only to the closest predecessor <ref> [33] </ref>, because of the transitivity of the order and the strict decrease enforced at each step. <p> However, wfo are usually extended to incorporate variant checking and then require inspecting every predecessor anyway (though only when there is no strict weight decrease, see e.g. <ref> [32, 33] </ref>). 5 the head strictly larger than the body atom). As already mentioned, for any extension of a wqo we have that &lt; is a wfo. Thus we know that the program just consisting of C 1 is terminating.
Reference: [34] <author> B. Martens, D. De Schreye, and T. Horvath. </author> <title> Sound and complete partial deduction with unfolding based on well-founded measures. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 122(1-2):97-117, </address> <year> 1994. </year>
Reference-contexts: This is why, contrary to maybe functional programming, measures in addition to determinacy have to be adopted to ensure local termination. Luckily, more refined approaches to ensure termination of unfolding exist. The methods in <ref> [4, 34, 33, 32] </ref> are based on well-founded orders, inspired by their usefulness in the context of static termination analysis (see e.g. [8, 5]). <p> Much more elaborate techniques based upon well-founded orders, which e.g. split the expressions into classes or continuously refine the orders during the unfolding process, exist and we refer the reader to <ref> [4, 34, 33, 32] </ref> for further details. These works also present a further refinement which, instead of requiring a decrease wrt every ancestor, only requires a decrease wrt the covering ancestors, i.e. one only compares with the ancestor atoms from which the current atom descends (via resolution).
Reference: [35] <author> B. Martens and J. Gallagher. </author> <title> Ensuring global termination of partial deduction while allowing flexible polyvariance. </title> <editor> In L. Sterling, editor, </editor> <booktitle> Proceedings ICLP'95, </booktitle> <pages> pages 597-613, </pages> <address> Kanagawa, Japan, </address> <month> June </month> <year> 1995. </year> <note> MIT Press. Extended version as Technical Report CSTR-94-16, </note> <institution> University of Bristol. </institution>
Reference-contexts: the SLDNF-trees | often also referred to as unfolding steps | are those that have been performed beforehand, justifying the hope that the specialised program be more efficient. fl Supported by the Belgian GOA "Non-Standard Applications of Abstract Interpretation" 1 Now, to ensure termination of partial deduction two issues arise <ref> [9, 35] </ref> (cf. Figure 1). One is called the local termination problem, corresponding to the fact that each generated SLDNF-tree should be finite. The other is called the global termination problem, meaning that the set A should contain only a finite number of atoms. <p> A n A 1 ? @ @R ? ? local termination: each tree is finite global termination: n &lt; 1 Below, in a first approach, we concentrate on local termination. But as shown in <ref> [35] </ref> the atoms in A can be structured into a global tree and methods similar to the one for local termination can be used to ensure global termination One, albeit ad-hoc, way to solve the local termination problem is to simply impose an arbitrary depth bound. <p> Theorem 4.2 fi fl is a wqo on expressions. To prove Theorem 4.2 we need the following machinery. First we take a well-founded measure function from [11] (also in the extended version of <ref> [35] </ref>): Definition 4.3 (s (:), h (:)) Let Expr denote the sets of expressions. <p> The well-founded measure function h has the property that h (t) 0 for any expression t and h (t) &gt; 0 for any non-variable expression t. The following important lemma is proven for h (:) in [10] (see also <ref> [35] </ref>).
Reference: [36] <author> C. R. Murthy and J. R. Russel. </author> <title> A constructive proof of Higman's lemma. </title> <booktitle> In Proceedings, Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 257-267, </pages> <address> Alamitos, California, 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Proposition 2.8 The relation fi is a wqo on the set of expressions over a finite alphabet. For a complete proof, reusing Higman's Lemma [15, 19] in a straightforward manner, see e.g. [24]. (For constructive proofs of Higman's Lemma [15] see <ref> [42, 36] </ref>. See also [12] and [40].
Reference: [37] <author> C. Nash-Williams. </author> <title> On well-quasi-ordering finite trees. </title> <journal> Proc. Cambridge Phil. Soc, </journal> <volume> 59 </volume> <pages> 833-835, </pages> <year> 1963. </year>
Reference-contexts: For a complete proof, reusing Higman's Lemma [15, 19] in a straightforward manner, see e.g. [24]. (For constructive proofs of Higman's Lemma [15] see [42, 36]. See also [12] and [40]. Another, non-constructive one can be found in <ref> [37] </ref>.) To ensure e.g. local termination of partial deduction, we have to ensure that the constructed SLDNF-trees are such that the selected atoms do not embed any of their ancestors (when using a well-founded order as in Example 1.3, we had to require a strict decrease at every step).
Reference: [38] <author> L. Plumer. </author> <title> Termination Proofs for Logic Programs. </title> <publisher> LNCS 446. Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction The problem of ensuring termination arises in a lot of different contexts in computer science. For instance a lot of work has been devoted to proving termination of term rewriting systems (e.g. [7] and references therein) or of logic programs (e.g. <ref> [5, 38] </ref> and references therein). It is also an important issue within all areas of program analysis, specialisation and transformation: one usually strives for methods which are guaranteed to terminate. <p> For instance static termination analysis of logic programs <ref> [5, 38] </ref> falls within the former context, while termination of e.g. partial deduction | an automatic technique for specialising logic programs | is usually ensured in an on-line manner. Let us examine the case of partial deduction in more detail. <p> The homeomorphic embedding relation is very generous. It will for example, without further refinement, permit the full unfolding of most terminating Datalog programs, the quicksort or even the mergesort program (the latter poses problems to some static termination analysis methods <ref> [38, 28] </ref>) | when the list to be sorted is known (see Appendix B). Also, it will allow a process to go from p ([]; [a]) to p ([a]; []) but also the other way around.
Reference: [39] <author> L. Puel. </author> <title> Using unavoidable set of trees to generalize Kruskal's theorem. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8 </volume> <pages> 335-382, </pages> <year> 1989. </year>
Reference-contexts: The use of characteristic trees [24, 27] remedies this problem to some extent, but not totally. A further step towards a solution is presented in [46]. In that light, it might be of interest to study whether the extensions of the homeomorphic embedding relation proposed in <ref> [39] </ref> and [22] (in the context of static termination analysis of term rewrite systems) can be useful in an on-line setting.
Reference: [40] <author> J. Riche. </author> <title> Decidability, Complexity and Automated Reasoning in Relevant Logic. </title> <type> PhD thesis, </type> <institution> Australian National University, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Proposition 2.8 The relation fi is a wqo on the set of expressions over a finite alphabet. For a complete proof, reusing Higman's Lemma [15, 19] in a straightforward manner, see e.g. [24]. (For constructive proofs of Higman's Lemma [15] see [42, 36]. See also [12] and <ref> [40] </ref>.
Reference: [41] <author> D. Sahlin. Mixtus: </author> <title> An automatic partial evaluator for full Prolog. </title> <journal> New Generation Computing, </journal> <volume> 12(1) </volume> <pages> 7-51, </pages> <year> 1993. </year>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context.
Reference: [42] <author> S. G. Simpson. </author> <title> Ordinal numbers and the Hilbert basis theorem. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 53(3) </volume> <pages> 961-974, </pages> <year> 1988. </year>
Reference-contexts: Proposition 2.8 The relation fi is a wqo on the set of expressions over a finite alphabet. For a complete proof, reusing Higman's Lemma [15, 19] in a straightforward manner, see e.g. [24]. (For constructive proofs of Higman's Lemma [15] see <ref> [42, 36] </ref>. See also [12] and [40].
Reference: [43] <author> M. H. Strensen and R. Gluck. </author> <title> An algorithm of generalization in positive supercompilation. </title> <editor> In J. W. Lloyd, editor, </editor> <booktitle> Proceedings of ILPS'95, the International Logic Programming Symposium, </booktitle> <pages> pages 465-479, </pages> <address> Portland, USA, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context. <p> An interesting wqo is the homeomorphic embedding relation fi, which derives from results by Higman [15] and Kruskal [19]. It has been used in the context of term rewriting systems in [6, 7], and adapted for use in supercompilation ([45]) in <ref> [43] </ref>. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. Some complexity results can be found in [44] and [14] (also summarised in [31]). The following is the definition from [43], which adapts the pure homeomorphic embedding from [7] by adding a rudimentary treatment <p> rewriting systems in [6, 7], and adapted for use in supercompilation ([45]) in <ref> [43] </ref>. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. Some complexity results can be found in [44] and [14] (also summarised in [31]). The following is the definition from [43], which adapts the pure homeomorphic embedding from [7] by adding a rudimentary treatment of variables. Definition 2.6 (fi) The (pure) homeomorphic embedding relation fi on expressions is defined inductively as follows: 1.
Reference: [44] <author> J. Stillman. </author> <title> Computational Problems in Equational Theorem Proving. </title> <type> PhD thesis, </type> <institution> State University of New York at Albany, </institution> <year> 1988. </year>
Reference-contexts: It has been used in the context of term rewriting systems in [6, 7], and adapted for use in supercompilation ([45]) in [43]. Its usefulness as a stop criterion for partial evaluation is also discussed and advocated in [31]. Some complexity results can be found in <ref> [44] </ref> and [14] (also summarised in [31]). The following is the definition from [43], which adapts the pure homeomorphic embedding from [7] by adding a rudimentary treatment of variables. Definition 2.6 (fi) The (pure) homeomorphic embedding relation fi on expressions is defined inductively as follows: 1.
Reference: [45] <author> V. F. Turchin. </author> <title> The concept of a supercompiler. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(3) </volume> <pages> 292-325, </pages> <year> 1986. </year>
Reference-contexts: We believe that fi fl can be of value in other contexts and for other languages (such as in the context of partial evaluation of functional-logic programs [1] or of supercompilation <ref> [45] </ref> of functional programming languages, where | at specialisation time variables also appear).
Reference: [46] <author> W. Vanhoof and B. Martens. </author> <title> To parse or not to parse. </title> <editor> In N. Fuchs, editor, </editor> <booktitle> Pre-Proceedings of the International Workshop on Logic Program Synthesis and Transformation (LOPSTR'97), </booktitle> <address> Leuven, Belgium, </address> <month> July </month> <year> 1997. </year> <note> Also as Technical Report CW 251, K.U.Leuven. </note>
Reference-contexts: However, in an on-line setting, well-founded orders are sometimes too rigid or too complex. Recently, well-quasi orders have therefore gained popularity to ensure on-line termination of program manipulation techniques <ref> [3, 41, 43, 26, 27, 13, 18, 1, 20, 46] </ref>. Indeed, as we will see below, well-quasi orders are often much more flexible than well-founded orders in an on-line context. <p> For some applications, fi as well as fi + and fi fl remain too restrictive. In particular, they do not always deal satisfactorily with fluctuating structure (arising e.g. for certain meta-interpretation tasks) <ref> [46] </ref>. The use of characteristic trees [24, 27] remedies this problem to some extent, but not totally. A further step towards a solution is presented in [46]. <p> In particular, they do not always deal satisfactorily with fluctuating structure (arising e.g. for certain meta-interpretation tasks) <ref> [46] </ref>. The use of characteristic trees [24, 27] remedies this problem to some extent, but not totally. A further step towards a solution is presented in [46]. In that light, it might be of interest to study whether the extensions of the homeomorphic embedding relation proposed in [39] and [22] (in the context of static termination analysis of term rewrite systems) can be useful in an on-line setting.
Reference: [47] <author> A. Weiermann. </author> <title> Complexity bounds for some finite forms of Kruskal's theorem. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 18(5) </volume> <pages> 463-488, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: However, the above definition is the one most often used in the context of termination. Both definitions are equivalent by Theorem 2.1 in [15]. A different (but equivalent) definition of a wqo is given in <ref> [21, 47] </ref>: A quasi-order V is a wqo iff for all quasi-orders V which contain V (i.e. v V v 0 ) v V v 0 ) the corresponding strict partial order V is a wfo.
References-found: 47

