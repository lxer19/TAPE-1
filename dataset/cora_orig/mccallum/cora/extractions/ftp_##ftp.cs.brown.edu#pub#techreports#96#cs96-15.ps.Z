URL: ftp://ftp.cs.brown.edu/pub/techreports/96/cs96-15.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-96-15.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Chin, N., and Feiner, S. </author> <title> Near real-time shadow generation using BSP trees. </title> <booktitle> In Computer Graphics (SIGGRAPH '89 Conference Proceedings) (July 1989), ACM SIGGRAPH, </booktitle> <pages> pp. 99-106. </pages>
Reference-contexts: BSP trees may also be used for many other purposes not considered here; for examples, see <ref> [1, 2, 5, 8-10, 12-14, 17] </ref>. 3 Graph-based summary The idea of the graph-based approach [4, 11] to hidden-surface removal for static polygonal scenes with backface removal is to note the potential-obscuration relationship between two one-sided polygons, A and B, indicating whether there is some viewpoint from which A and B
Reference: [2] <author> Chin, N., and Feiner, S. </author> <title> Fast object-precision shadow generation for area light sources using BSP trees. </title> <booktitle> In 1992 Symposium on Interactive 3D Graphics (Special Issue of Computer Graphics) (1992), ACM SIGGRAPH, </booktitle> <pages> pp. 21-30, 220. </pages>
Reference-contexts: BSP trees may also be used for many other purposes not considered here; for examples, see <ref> [1, 2, 5, 8-10, 12-14, 17] </ref>. 3 Graph-based summary The idea of the graph-based approach [4, 11] to hidden-surface removal for static polygonal scenes with backface removal is to note the potential-obscuration relationship between two one-sided polygons, A and B, indicating whether there is some viewpoint from which A and B

Reference: [4] <author> Fuchs, H., Kedem, Z. M., and Naylor, B. </author> <title> Predetermining visibility priority in 3-D scenes. </title> <booktitle> In Computer Graphics (SIGGRAPH '79 Conference Proceedings) (August 1979), </booktitle> <editor> B. W. Pollack, Ed., </editor> <booktitle> ACM SIG-GRAPH, </booktitle> <pages> pp. 175-181. </pages>
Reference-contexts: BSP trees may also be used for many other purposes not considered here; for examples, see [1, 2, 5, 8-10, 12-14, 17]. 3 Graph-based summary The idea of the graph-based approach <ref> [4, 11] </ref> to hidden-surface removal for static polygonal scenes with backface removal is to note the potential-obscuration relationship between two one-sided polygons, A and B, indicating whether there is some viewpoint from which A and B are both front-facing, A's projection onto a film plane overlaps B's, and at some point <p> Thus, to apply the method to general static one-sided-polygonal scenes, one must form the topological sort of the strongly connected components and then do something else with strong components of more than one polygon. Several possibilities for the "something else" are covered in the literature: 1. <ref> [4, 11] </ref> Don't handle them: restrict the input to those scenes without multipolygon strong components. 2. [4] Handle some of them: restrict the input to those scenes without multipolygon strong components even if polygons may be split by planes of other polygons. 3. [11] Use a non-graph algorithm like Newell's or <p> Several possibilities for the "something else" are covered in the literature: 1. [4, 11] Don't handle them: restrict the input to those scenes without multipolygon strong components. 2. <ref> [4] </ref> Handle some of them: restrict the input to those scenes without multipolygon strong components even if polygons may be split by planes of other polygons. 3. [11] Use a non-graph algorithm like Newell's or War nock's on the strong components. 4. [11] Remove all 2-cycles by splitting one of the
Reference: [5] <author> Fuchs, H., Kedem, Z. M., and Naylor, B. F. </author> <title> On visible surface generation by a priori tree structures. </title> <booktitle> In Computer Graphics (SIGGRAPH '80 Conference Proceedings) (July 1980), ACM SIGGRAPH, </booktitle> <pages> pp. 124-133. </pages>
Reference-contexts: when z-buffering would be preferable, sorting front-to-back via a priority scheme in addition to doing z-buffering may produce a small run-time speedup over z-buffering alone, since no new z-buffer and pixel values are written for those pixels already written from the same object. 2 BSP tree summary The BSP tree <ref> [3, 5, 11] </ref> is a recursive partitioning of a space by hyperplanes. <p> This approach has the drawback that it may require splitting a significant number of polygons, particularly since efficient algorithms for determining trees with minimal numbers of splits do not seem to be known, although work has been done on finding good trees efficiently <ref> [3, 5, 7, 9, 11, 14] </ref>. The variant run-time algorithm [6] that processes polygons nearer to the viewpoint first, combined with a different clipping and scan-conversion method, may also be applied with suitable modifications to the algorithm presented in this paper. <p> BSP trees may also be used for many other purposes not considered here; for examples, see <ref> [1, 2, 5, 8-10, 12-14, 17] </ref>. 3 Graph-based summary The idea of the graph-based approach [4, 11] to hidden-surface removal for static polygonal scenes with backface removal is to note the potential-obscuration relationship between two one-sided polygons, A and B, indicating whether there is some viewpoint from which A and B
Reference: [6] <author> Gordon, D., and Chin, S. </author> <title> Front-to-back display of BSP trees. </title> <journal> IEEE Computer Graphics and Applications (September 1991), </journal> <pages> 79-85. </pages>
Reference-contexts: The variant run-time algorithm <ref> [6] </ref> that processes polygons nearer to the viewpoint first, combined with a different clipping and scan-conversion method, may also be applied with suitable modifications to the algorithm presented in this paper.
Reference: [7] <author> Morer, P., Garcia-Alonso, A. M., and Flaquer, J. </author> <title> Optimization of a priority list algorithm for 3-D rendering of buildings. </title> <journal> Computer Graphics Forum 14, </journal> <volume> 4 (1995), </volume> <pages> 217|227. </pages>
Reference-contexts: Furthermore, z-buffering may not be preferable if transparency is used <ref> [7] </ref>. <p> This approach has the drawback that it may require splitting a significant number of polygons, particularly since efficient algorithms for determining trees with minimal numbers of splits do not seem to be known, although work has been done on finding good trees efficiently <ref> [3, 5, 7, 9, 11, 14] </ref>. The variant run-time algorithm [6] that processes polygons nearer to the viewpoint first, combined with a different clipping and scan-conversion method, may also be applied with suitable modifications to the algorithm presented in this paper. <p> Details do not merit inclusion here as they could probably be improved a great deal (see <ref> [7] </ref> and also Section 6). <p> Experiments should be done to see to what extent this affects the practical improvement Q yields over plain BSP, in particular trying the heuristics in both <ref> [7] </ref> and [9]. 7 Acknowledgements Thanks to Steven Dollins, John Hughes, Robert Zeleznik, Katrina Avery, and Andries van Dam for reading this paper and making suggestions. This work was supported in part by grants from NSF, Microsoft, Sun Microsystems, Taco, and HP.
Reference: [8] <author> Naylor, B. SCULPT: </author> <title> An interactive solid modeling tool. </title> <booktitle> In Graphics Interface '90 (1990), </booktitle> <pages> pp. 138-148. </pages>
Reference: [9] <author> Naylor, B. </author> <title> Constructing good partitioning trees. </title> <booktitle> In Graphics Interface '93 (1993), </booktitle> <pages> pp. 181-191. </pages>
Reference-contexts: This approach has the drawback that it may require splitting a significant number of polygons, particularly since efficient algorithms for determining trees with minimal numbers of splits do not seem to be known, although work has been done on finding good trees efficiently <ref> [3, 5, 7, 9, 11, 14] </ref>. The variant run-time algorithm [6] that processes polygons nearer to the viewpoint first, combined with a different clipping and scan-conversion method, may also be applied with suitable modifications to the algorithm presented in this paper. <p> Experiments should be done to see to what extent this affects the practical improvement Q yields over plain BSP, in particular trying the heuristics in both [7] and <ref> [9] </ref>. 7 Acknowledgements Thanks to Steven Dollins, John Hughes, Robert Zeleznik, Katrina Avery, and Andries van Dam for reading this paper and making suggestions. This work was supported in part by grants from NSF, Microsoft, Sun Microsystems, Taco, and HP.
Reference: [10] <author> Naylor, B., Amanatides, J., and Thibault, W. </author> <title> Merging BSP trees yields polyhedral set operations. </title> <booktitle> In Computer Graphics (SIGGRAPH '90 Conference Proceedings) (August 1990), ACM SIGGRAPH, </booktitle> <pages> pp. 115-124. </pages>
Reference: [11] <author> Naylor, B. F. </author> <title> A Priori Based Techniques for Determining Visibility Priority for 3-D Scenes. </title> <type> PhD thesis, </type> <institution> The University of Texas at Dallas, </institution> <month> May </month> <year> 1981. </year>
Reference-contexts: when z-buffering would be preferable, sorting front-to-back via a priority scheme in addition to doing z-buffering may produce a small run-time speedup over z-buffering alone, since no new z-buffer and pixel values are written for those pixels already written from the same object. 2 BSP tree summary The BSP tree <ref> [3, 5, 11] </ref> is a recursive partitioning of a space by hyperplanes. <p> This approach has the drawback that it may require splitting a significant number of polygons, particularly since efficient algorithms for determining trees with minimal numbers of splits do not seem to be known, although work has been done on finding good trees efficiently <ref> [3, 5, 7, 9, 11, 14] </ref>. The variant run-time algorithm [6] that processes polygons nearer to the viewpoint first, combined with a different clipping and scan-conversion method, may also be applied with suitable modifications to the algorithm presented in this paper. <p> BSP trees may also be used for many other purposes not considered here; for examples, see [1, 2, 5, 8-10, 12-14, 17]. 3 Graph-based summary The idea of the graph-based approach <ref> [4, 11] </ref> to hidden-surface removal for static polygonal scenes with backface removal is to note the potential-obscuration relationship between two one-sided polygons, A and B, indicating whether there is some viewpoint from which A and B are both front-facing, A's projection onto a film plane overlaps B's, and at some point <p> However, not all such graphs are acyclic. There are even scenes for which the corresponding graph is not acyclic even if the input polygons can be split arbitrarily <ref> [11] </ref>. Thus, to apply the method to general static one-sided-polygonal scenes, one must form the topological sort of the strongly connected components and then do something else with strong components of more than one polygon. <p> Thus, to apply the method to general static one-sided-polygonal scenes, one must form the topological sort of the strongly connected components and then do something else with strong components of more than one polygon. Several possibilities for the "something else" are covered in the literature: 1. <ref> [4, 11] </ref> Don't handle them: restrict the input to those scenes without multipolygon strong components. 2. [4] Handle some of them: restrict the input to those scenes without multipolygon strong components even if polygons may be split by planes of other polygons. 3. [11] Use a non-graph algorithm like Newell's or <p> else" are covered in the literature: 1. [4, 11] Don't handle them: restrict the input to those scenes without multipolygon strong components. 2. [4] Handle some of them: restrict the input to those scenes without multipolygon strong components even if polygons may be split by planes of other polygons. 3. <ref> [11] </ref> Use a non-graph algorithm like Newell's or War nock's on the strong components. 4. [11] Remove all 2-cycles by splitting one of the member polygons and use a z-buffer-like algorithm on the priorities, per-pixel, as dynamically discovered at run-time from the graph. 5. [11, p. 53] Consider each of a <p> to those scenes without multipolygon strong components. 2. [4] Handle some of them: restrict the input to those scenes without multipolygon strong components even if polygons may be split by planes of other polygons. 3. <ref> [11] </ref> Use a non-graph algorithm like Newell's or War nock's on the strong components. 4. [11] Remove all 2-cycles by splitting one of the member polygons and use a z-buffer-like algorithm on the priorities, per-pixel, as dynamically discovered at run-time from the graph. 5. [11, p. 53] Consider each of a potentially exponential number of simple cycles in the component and manipulate them by adding indicator <p> by planes of other polygons. 3. [11] Use a non-graph algorithm like Newell's or War nock's on the strong components. 4. [11] Remove all 2-cycles by splitting one of the member polygons and use a z-buffer-like algorithm on the priorities, per-pixel, as dynamically discovered at run-time from the graph. 5. <ref> [11, p. 53] </ref> Consider each of a potentially exponential number of simple cycles in the component and manipulate them by adding indicator nodes and possibly splitting polygons so that at run-time all that need be done is prune backfacing polygons from the component's sub graph and then topologically sort the subgraph. <p> 53] Consider each of a potentially exponential number of simple cycles in the component and manipulate them by adding indicator nodes and possibly splitting polygons so that at run-time all that need be done is prune backfacing polygons from the component's sub graph and then topologically sort the subgraph. 6. <ref> [11, p. 67] </ref> Approximate the simple-cycle method (5) by a linear manipulation of the component as a whole instead of each cycle individually. <p> last is only a difference from (5).) Naylor observes that the BSP data structure "is on the order of the number of polygons remaining after the partitioning process while the above outlined approximation method using a directed graph is on the order of the number of edges between these polygons" <ref> [11, p. 74] </ref>. Algorithm Q also has run-time space requirements on the order of the number of resulting polygons. <p> For BSP trees, Naylor notes that the tree can be compressed when there is a chain of nodes with no children on one side (the same side for each node) <ref> [11] </ref>. The constant-order list L resulting from such a compression can be seen to be guaranteed to be part of a list from the graph algorithm given the polygons P of the BSP subtree rooted at the top node of the chain.
Reference: [12] <author> Naylor, B. F. </author> <title> Interactive solid geometry via partitioning trees. </title> <booktitle> In Graphics Interface '92 (1992), </booktitle> <pages> pp. 11-18. </pages>
Reference: [13] <author> Naylor, B. F. </author> <title> Partitioning tree image representation and generation from 3D geometric models. </title> <booktitle> In Graphics Interface '92 (1992), </booktitle> <pages> pp. 201-212. </pages>
Reference: [14] <author> Paterson, M. S., and Yao, F. F. </author> <title> Efficient binary space partitions for hidden-surface removal and solid modeling. Discrete & Computational Geometry 5, </title> <booktitle> 5 (1990), </booktitle> <pages> 485-503. </pages>
Reference-contexts: This approach has the drawback that it may require splitting a significant number of polygons, particularly since efficient algorithms for determining trees with minimal numbers of splits do not seem to be known, although work has been done on finding good trees efficiently <ref> [3, 5, 7, 9, 11, 14] </ref>. The variant run-time algorithm [6] that processes polygons nearer to the viewpoint first, combined with a different clipping and scan-conversion method, may also be applied with suitable modifications to the algorithm presented in this paper.
Reference: [15] <author> Schumacker, R. A., Brand, R., Gilliland, M., and Sharp, W. </author> <title> Study for applying computer-generated images to visual simulation. </title> <type> Tech. Rep. </type> <institution> AFHRL-TR-69-14, U.S. Air Force Human Resources Laboratory, </institution> <month> September </month> <year> 1969. </year>
Reference-contexts: The essential idea is that a linear ordering of the "cluster priorities" of <ref> [15] </ref> as described in [16] can be found for each view (where a "cluster" is what is called here an "object").
Reference: [16] <author> Sutherland, I. E., Sproull, R. F., and Schu-macker, R. A. </author> <title> A characterization of ten hidden-surface algorithms. </title> <journal> Computing Surveys 6, </journal> <month> 1 (March </month> <year> 1974), </year> <pages> 1-55. </pages>
Reference-contexts: The essential idea is that a linear ordering of the "cluster priorities" of [15] as described in <ref> [16] </ref> can be found for each view (where a "cluster" is what is called here an "object"). <p> In many such applications preprocessing time is irrelevant. On machines in which z-buffering is not implemented in hardware, such as many PCs, and for relatively low complexity scenes with the above properties, as in many games, it is better to do hidden-surface elimination using priority ordering than z-buffering <ref> [16] </ref>.
Reference: [17] <author> Thibault, W. C., and Naylor, B. F. </author> <title> Set operations on polyhedra using binary space partitioning trees. </title> <booktitle> In Computer Graphics (SIGGRAPH '87 Conference Proceedings) (July 1992), ACM SIGGRAPH, </booktitle> <pages> pp. 153-162. </pages>
Reference-contexts: BSP trees may also be used for many other purposes not considered here; for examples, see <ref> [1, 2, 5, 8-10, 12-14, 17] </ref>. 3 Graph-based summary The idea of the graph-based approach [4, 11] to hidden-surface removal for static polygonal scenes with backface removal is to note the potential-obscuration relationship between two one-sided polygons, A and B, indicating whether there is some viewpoint from which A and B
References-found: 16

