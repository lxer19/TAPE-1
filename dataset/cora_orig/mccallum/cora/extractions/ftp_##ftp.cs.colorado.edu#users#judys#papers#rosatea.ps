URL: ftp://ftp.cs.colorado.edu/users/judys/papers/rosatea.ps
Refering-URL: ftp://ftp.cs.colorado.edu/users/judys/papers/INDEX.html
Root-URL: http://www.cs.colorado.edu
Email: fjudys,alwg@cs.colorado.edu djr@ics.uci.edu  
Phone: +1.303.492.5263 +1.714.824.7353  
Title: Architecture-level Dependence Analysis for Software Systems  
Author: Judith A. Stafford Debra J. Richardson and Alexander L. Wolf 
Keyword: Dependence Analysis, Software Architecture, Architecture Description Languages  
Address: Boulder, CO 80309 USA Irvine, CA 92697 USA  
Affiliation: Department of Computer Science Dept. of Information and Computer Science University of Colorado University of California  
Abstract: Software architecture description languages provide a means to formally describe software systems at a high level of abstraction. They capture the high-level structure and/or behavior of the system, thus providing a basis for course-grain static analyses. Dependence analysis has been used as a basis for program optimization, debugging, and testing. We are developing a dependence analysis technique, called chaining, for use with formal architectural descriptions, and implementing the technique in a tool called Aladdin. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers principles, techniques, and tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Representation schemes for program/system dependencies that are similar to our tabular representation have been used in program optimization and for system requirements analysis. Aho, Sethi and Ullman <ref> [1] </ref> describe a program representation where bit vectors are used to compactly represent "gen" and "kill" sets for each statement in the program and logical operations are performed on these bit sets to determine statement dependencies.
Reference: [2] <author> F.E. Allen. </author> <title> Control Flow Analysis. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 1-19, </pages> <month> July </month> <year> 1970. </year>
Reference-contexts: The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables (e.g., [13]). This type of analysis was originally applied to compiler optimization <ref> [2] </ref> in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9, 13]).
Reference: [3] <author> R. Allen and D. Garlan. </author> <title> A Formal Basis for Architectural Connection. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 6(3) </volume> <pages> 213-249, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: Formal software architecture description languages (ADLs) allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [3, 15, 17, 20] </ref>. In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as reuse, reverse engineering, fault localization, impact analysis, regression testing, and workspace management. <p> Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. In particular, both the structural and the behavioral relationships among components expressed in current-day formal ADLs, such as Rapide [16] and Wright <ref> [3] </ref> are considered. We are developing an architecture-level dependence analysis technique, called chaining, and implementing the technique in a tool called Aladdin. Aladdin is similar in concept to ProDAG [24], which is an implementation-level dependence analysis tool for Ada and C++ programs. <p> We intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM [14], Acme [8], and Wright <ref> [3] </ref>), and to test our approach against more complex architectures. Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process.
Reference: [4] <author> D.F. Bacon, S.L. Graham, and O.J. Sharp. </author> <title> Compiler Transformations for High-Performance Computing. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(4) </volume> <pages> 345-420, </pages> <month> Decem-ber </month> <year> 1994. </year>
Reference-contexts: This type of analysis was originally applied to compiler optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., <ref> [4, 9, 13] </ref>). The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., [19, 21, 23]). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., [28, 30]).
Reference: [5] <author> J. Chang and D. J. Richardson. </author> <title> Static and Dynamic Specification Slicing. </title> <booktitle> In Proceedings of the Fourth Irvine Software Symposium, </booktitle> <address> Irvine, CA, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: They present syntactically based generalized slicing for analysis of non-imperative programs. We agree with the spirit of this work and are pursuing a similar goal, but in the particular context of software architectures. Chang and Richardson <ref> [5] </ref> introduced techniques for cre ating dynamic specification slices. This approach use traditional slicing criteria, whereas our work involves exploring relationships at the architectural level, where additional criteria are defined. Zhao [32] is investigating the use of a system dependence net to slice architectural descriptions written in the Wright ADL.
Reference: [6] <author> J.R. Cordy and K.A. Schneider. </author> <title> Architectural Design Recovery Using Source Transformations. </title> <booktitle> In CASE'95: Workshop on Software Architecture, </booktitle> <address> Toronto, Canada, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Architectures erode due to changes in a system's implementation that are not reflected in the documentation and higher-level specifications. Two approaches to providing precise mappings are code generation [27, 29, 31] and architecture recovery <ref> [6, 19] </ref>. 4 Creating and Using Chains As mentioned earlier, chains represent dependence relationships in an architectural specification. The individual chain links within a chain associate elements of an architecture that are directly related, while a chain of dependencies includes associations among architectural elements that are indirectly related.
Reference: [7] <author> J. Ferrante, K.J. Ottenstein, and J.D. Warren. </author> <title> The Program Dependence Graph and Its Use in Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Our approach applies this concept to architecture description languages and combines the information with behavioral dependencies. Considerable work has been done in the study and use of dependence relationships among variables and statements at the implementation level. For example, Fer-rante, Ottenstein, and Warren <ref> [7] </ref> introduced the program dependence graph (PDG) for use in compiler optimization; Harrold and Soffa [11] have studied alias and interprocedural analysis of C and C++ programs. Representation schemes for program/system dependencies that are similar to our tabular representation have been used in program optimization and for system requirements analysis.
Reference: [8] <author> D. Garlan, R. Monroe, and D. Wile. ACME: </author> <title> An Architecture Description Interchange Language. </title> <booktitle> In Proceedings of CASCON '97. </booktitle> <institution> IBM Center for Advanced Studies, </institution> <month> November </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: We intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM [14], Acme <ref> [8] </ref>, and Wright [3]), and to test our approach against more complex architectures. Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process.
Reference: [9] <author> D.W. Goodwin. </author> <title> Interprocedural Dataflow Analysis in an Executable Optimizer. </title> <booktitle> In Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 122-133, </pages> <address> Las Vegas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: This type of analysis was originally applied to compiler optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., <ref> [4, 9, 13] </ref>). The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., [19, 21, 23]). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., [28, 30]).
Reference: [10] <author> J.O. Grady. </author> <title> System Requirements Analysis. </title> <publisher> McGraw-Hill, Inc., </publisher> <year> 1993. </year>
Reference-contexts: Aho, Sethi and Ullman [1] describe a program representation where bit vectors are used to compactly represent "gen" and "kill" sets for each statement in the program and logical operations are performed on these bit sets to determine statement dependencies. Grady <ref> [10] </ref> uses an N-square representation to examine system coupling when assigning functionalities to components during initial system decomposition. Po-makis and Atlee [22] use a tabular notation similar to the one found in SCR [12] to specify feature behaviors.
Reference: [11] <author> M.J. Harrold and M.L. Soffa. </author> <title> Efficient Computation of Interprocedural Definition Use Chains. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(2) </volume> <pages> 175-204, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Considerable work has been done in the study and use of dependence relationships among variables and statements at the implementation level. For example, Fer-rante, Ottenstein, and Warren [7] introduced the program dependence graph (PDG) for use in compiler optimization; Harrold and Soffa <ref> [11] </ref> have studied alias and interprocedural analysis of C and C++ programs. Representation schemes for program/system dependencies that are similar to our tabular representation have been used in program optimization and for system requirements analysis.
Reference: [12] <author> K. Heninger. </author> <title> Specifying Software Requirements for Complex Systems: New Techniques and Their Applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(1) </volume> <pages> 2-12, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Grady [10] uses an N-square representation to examine system coupling when assigning functionalities to components during initial system decomposition. Po-makis and Atlee [22] use a tabular notation similar to the one found in SCR <ref> [12] </ref> to specify feature behaviors. This is used in conjunction with a graphical representation to study possible feature interactions. While all of these methods use a representation similar to our tabular representation, the analyses applied to the representations are different and are for different purposes.
Reference: [13] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural Slicing Using Dependence Graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 22(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables (e.g., <ref> [13] </ref>). This type of analysis was originally applied to compiler optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9, 13]). <p> This type of analysis was originally applied to compiler optimization [2] in order to determine safe code restructuring. The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., <ref> [4, 9, 13] </ref>). The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., [19, 21, 23]). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., [28, 30]).
Reference: [14] <author> P. Inverardi and A.L. Wolf. </author> <title> Formal Specification and Analysis of Software Architectures using the Chemical Abstract Machine Model. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: We intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM <ref> [14] </ref>, Acme [8], and Wright [3]), and to test our approach against more complex architectures. Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process.
Reference: [15] <author> P. Inverardi, A.L. Wolf, and D. Yankelevich. </author> <title> Checking Assumptions in Component Dynamics at the Architectural Level. </title> <booktitle> In Proceedings of the Second International Conference on Coordination Models and Languages, number 1282 in Lecture Notes in Computer Science, </booktitle> <pages> pages 46-63. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1997. </year>
Reference-contexts: Formal software architecture description languages (ADLs) allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [3, 15, 17, 20] </ref>. In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as reuse, reverse engineering, fault localization, impact analysis, regression testing, and workspace management.
Reference: [16] <author> D.C. Luckham, J.J. Kenney, L.M. Augustin, J. Vera, D. Bryan, and W. Mann. </author> <title> Specification and Analysis of System Architecture Using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. In particular, both the structural and the behavioral relationships among components expressed in current-day formal ADLs, such as Rapide <ref> [16] </ref> and Wright [3] are considered. We are developing an architecture-level dependence analysis technique, called chaining, and implementing the technique in a tool called Aladdin. Aladdin is similar in concept to ProDAG [24], which is an implementation-level dependence analysis tool for Ada and C++ programs.
Reference: [17] <author> J. Magee, N. Dulay, S. Eisenbach, and J. Kramer. </author> <title> Distributed Software Architectures. </title> <booktitle> In Proceedings of the Fifth European Software Engineering Conference, number 989 in Lecture Notes in Computer Science, </booktitle> <pages> pages 137-153. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: Formal software architecture description languages (ADLs) allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [3, 15, 17, 20] </ref>. In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as reuse, reverse engineering, fault localization, impact analysis, regression testing, and workspace management.
Reference: [18] <author> W. Mann, F. C. Belz, and P. Corneil. </author> <title> A Rapide-1.0 Definition of the ADAGE Avionics System. </title> <type> Technical Report CSL-TR-93-585, </type> <institution> Stanford University, </institution> <year> 1993. </year>
Reference-contexts: Chaining is the process of applying dependence algorithms to architectural descriptions in order to create these sets of related components and/or elements. The chaining method was inspired by a study of an architectural description of the ADAGE avionics architecture given in Rapide <ref> [18] </ref>. The ADAGE example is large and complex, containing three levels of architecture and built from 30 components communicating through over 300 ports. The study involved the intentional introduction of a fault into the specification and the development of a (manual) process for uncovering the fault.
Reference: [19] <author> G.C. Murhpy and D.N. Notkin. </author> <title> Lightweight Lexical Source Model Extraction. </title> <journal> TOSEM, </journal> <volume> 5(3) </volume> <pages> 262-292, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9, 13]). The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., <ref> [19, 21, 23] </ref>). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., [28, 30]). Sloane and Holdsworth [25] suggest generalizing the concept of program slicing and suggest the potential for slicing non-imperative programs. <p> Architectures erode due to changes in a system's implementation that are not reflected in the documentation and higher-level specifications. Two approaches to providing precise mappings are code generation [27, 29, 31] and architecture recovery <ref> [6, 19] </ref>. 4 Creating and Using Chains As mentioned earlier, chains represent dependence relationships in an architectural specification. The individual chain links within a chain associate elements of an architecture that are directly related, while a chain of dependencies includes associations among architectural elements that are indirectly related. <p> Structural dependencies are investigated at the source level for use in tools such as makedepend that examines code to automatically derive the file dependencies (e.g., #include in the C environment) used in Make files. Murphy and Notkin <ref> [19] </ref> make use of source structure information as well as call graphs to extract a source model of a system. Our approach applies this concept to architecture description languages and combines the information with behavioral dependencies.
Reference: [20] <author> G. Naumovich, G.S. Avrunin, L.A. Clarke, and L.J. Osterweil. </author> <title> Applying Static Analysis to Software Architectures. </title> <booktitle> In Proceedings of the Sixth European Software Engineering Conference. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Formal software architecture description languages (ADLs) allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [3, 15, 17, 20] </ref>. In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as reuse, reverse engineering, fault localization, impact analysis, regression testing, and workspace management. <p> The work described in this initial paper is similar in nature to our work on chaining but is preliminary and the details of his method for determining related components are unstated. Naumovich et al. <ref> [20] </ref> apply INCA and FLAVERS, two static concurrency analysis tools used for proving behavioral properties of concurrent programs, to an Ada translation of a description of the gas station problem that was written in the Wright ADL.
Reference: [21] <author> A. Podgurski and L.A. Clarke. </author> <title> A Formal Model of Program Dependencies and its Implications for Software Testing, Debugging, and Maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 965-979, </pages> <month> Septem-ber </month> <year> 1990. </year>
Reference-contexts: The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9, 13]). The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., <ref> [19, 21, 23] </ref>). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., [28, 30]). Sloane and Holdsworth [25] suggest generalizing the concept of program slicing and suggest the potential for slicing non-imperative programs.
Reference: [22] <author> K.P. Pomakis and J.M. Atlee. </author> <title> Reachability Analysis of Feature Interactions: A Progress Report. </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA '96), </booktitle> <pages> pages 216-223. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Grady [10] uses an N-square representation to examine system coupling when assigning functionalities to components during initial system decomposition. Po-makis and Atlee <ref> [22] </ref> use a tabular notation similar to the one found in SCR [12] to specify feature behaviors. This is used in conjunction with a graphical representation to study possible feature interactions.
Reference: [23] <author> D.J. Richardson. TAOS: </author> <title> Testing with Analysis and Oracle Support. </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA '94), </booktitle> <pages> pages 138-153. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: The development of efficient and precise dependence analysis algorithms continues as an active area of research among compiler designers (e.g., [4, 9, 13]). The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., <ref> [19, 21, 23] </ref>). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., [28, 30]). Sloane and Holdsworth [25] suggest generalizing the concept of program slicing and suggest the potential for slicing non-imperative programs. <p> Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process. Eventually, we intend to incorporate chaining into a complete life cycle software analysis and testing environment, such as the TAOS environment <ref> [23] </ref>. TAOS includes dependence analysis and testing at the implementation level, with some support for specification-based test case generation and result checking. Integrating architecture analysis techniques such as chaining would round out the life cycle support for analysis and testing.
Reference: [24] <author> D.J. Richardson, </author> <title> T.O. O'Malley, C.T. Moore, and S.L. Aha. Developing and Integrating ProDAG in the Arcadia Environment. </title> <booktitle> In SIGSOFT '92: Proceedings of the Fifth Symposium on Software Development Environments, </booktitle> <pages> pages 109-119. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: We are developing an architecture-level dependence analysis technique, called chaining, and implementing the technique in a tool called Aladdin. Aladdin is similar in concept to ProDAG <ref> [24] </ref>, which is an implementation-level dependence analysis tool for Ada and C++ programs. Dependence analysis is performed by both ProDAG and Al-addin in a two-step process. First, an intermediate representation is created, and then language-independent analysis is performed over this representation.
Reference: [25] <author> A.M. Sloane and J. Holdsworth. </author> <title> Beyond Traditional Program Slicing. </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA '96), </booktitle> <pages> pages 180-186. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., [19, 21, 23]). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., [28, 30]). Sloane and Holdsworth <ref> [25] </ref> suggest generalizing the concept of program slicing and suggest the potential for slicing non-imperative programs. Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. <p> This is used in conjunction with a graphical representation to study possible feature interactions. While all of these methods use a representation similar to our tabular representation, the analyses applied to the representations are different and are for different purposes. Sloane and Holdsworth <ref> [25] </ref> suggest new applications for program slicing, in which the basis for analysis includes aspects other than traditional data and control flow. They present syntactically based generalized slicing for analysis of non-imperative programs.
Reference: [26] <author> J.A. Stafford, D.J. Richardson, and A.L. Wolf. </author> <title> Chaining: A Software Architecture Dependence Analysis Technique. </title> <type> Technical Report CU-CS-845-97, </type> <institution> University of Colorado, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: Aladdin implements the portion of the process that derives chains from an architectural specification. It also provides a set of queries over the chains that aid in debugging the architecture. We have used Aladdin in the analysis of a Rapide specification for the gas station example <ref> [26] </ref>. 2 We define three types of chains: affected-by, affects, and related. These are illustrated in Figure 2 and represent the directionality of the relationship. An affected-by relationship indicates that the element of interest could be affected by the elements linked together in the chain.
Reference: [27] <author> RAPIDE Design Team. </author> <title> Draft: Rapide 1.0 Architecture Language Reference Manual. </title> <month> July </month> <year> 1997. </year>
Reference-contexts: Architectures erode due to changes in a system's implementation that are not reflected in the documentation and higher-level specifications. Two approaches to providing precise mappings are code generation <ref> [27, 29, 31] </ref> and architecture recovery [6, 19]. 4 Creating and Using Chains As mentioned earlier, chains represent dependence relationships in an architectural specification.
Reference: [28] <author> P. Tonella, G. Antoniol, R. Fiutem, and E. Merlo. </author> <title> Flow Insensitive C++ Pointers and Polymorphism Analysis and its Application to Slicing. </title> <booktitle> In 19th International Conference on Software Engineering, </booktitle> <pages> pages 433-443, </pages> <address> Boston, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., [19, 21, 23]). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., <ref> [28, 30] </ref>). Sloane and Holdsworth [25] suggest generalizing the concept of program slicing and suggest the potential for slicing non-imperative programs. Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [29] <author> S. Vestal. </author> <title> MetaH Programmer's Manual. Honeywell, </title> <publisher> Inc., </publisher> <address> Minneapolis, MN, </address> <year> 1996. </year>
Reference-contexts: Architectures erode due to changes in a system's implementation that are not reflected in the documentation and higher-level specifications. Two approaches to providing precise mappings are code generation <ref> [27, 29, 31] </ref> and architecture recovery [6, 19]. 4 Creating and Using Chains As mentioned earlier, chains represent dependence relationships in an architectural specification.
Reference: [30] <author> M. Weiser. </author> <title> Program Slicing. </title> <booktitle> In Proceedings of the 5th International Conference on Software Engineering, </booktitle> <pages> pages 439-449. </pages> <publisher> IEEE Computer Society, </publisher> <month> March </month> <year> 1981. </year>
Reference-contexts: The application of dependence analysis techniques to aid program understanding and impact analysis has been widely studied (e.g., [19, 21, 23]). The creation of both static and dynamic program slices has been a focus for many researchers (e.g., <ref> [28, 30] </ref>). Sloane and Holdsworth [25] suggest generalizing the concept of program slicing and suggest the potential for slicing non-imperative programs. Our research takes a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [31] <author> G. Zelesnik. </author> <title> Unicon Reference Manual. </title> <type> Technical Report CMU-CS-97-TBD, </type> <institution> Carnagie Mellon Univeristy, </institution> <year> 1997. </year>
Reference-contexts: Architectures erode due to changes in a system's implementation that are not reflected in the documentation and higher-level specifications. Two approaches to providing precise mappings are code generation <ref> [27, 29, 31] </ref> and architecture recovery [6, 19]. 4 Creating and Using Chains As mentioned earlier, chains represent dependence relationships in an architectural specification.
Reference: [32] <author> J. Zhao. </author> <title> Using Dependence Analysis to Support Software Architecture Understanding. </title> <booktitle> New Technologies on Computer Software, </booktitle> <pages> pages 135-142, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: Chang and Richardson [5] introduced techniques for cre ating dynamic specification slices. This approach use traditional slicing criteria, whereas our work involves exploring relationships at the architectural level, where additional criteria are defined. Zhao <ref> [32] </ref> is investigating the use of a system dependence net to slice architectural descriptions written in the Wright ADL. The work described in this initial paper is similar in nature to our work on chaining but is preliminary and the details of his method for determining related components are unstated.
References-found: 32

