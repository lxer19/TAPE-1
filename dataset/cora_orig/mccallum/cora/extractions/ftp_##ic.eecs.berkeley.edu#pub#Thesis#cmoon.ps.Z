URL: ftp://ic.eecs.berkeley.edu/pub/Thesis/cmoon.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/Respep/Research/Thesis/thesis.html
Root-URL: http://www.cs.berkeley.edu
Title: Synthesis and Verification of Asynchronous Circuits from Graphical Specifications  
Author: by Cho Woo Moon 
Degree: M.S. (University of California at Berkeley) 1988 A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Engineering Electrical Engineering and Computer Sciences in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Robert K. Brayton, Chair Professor A. Richard Newton Professor Dorit Hochbaum  
Date: 1985  1992  
Address: Berkeley)  
Affiliation: B.S. (University of California at  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. B. Armstrong, A. D. Friedman, and P. R. Menon. </author> <title> "Realization of Asynchronous Sequential Circuits Without Inserted Delay Elements". </title> <journal> IEEE Tran. Computers, </journal> <volume> C-17(2):129 - 134, </volume> <month> February </month> <year> 1968. </year>
Reference-contexts: An example of an essential hazard is shown in Fig. 2.5. The flow table in Fig. 2.5 <ref> [1] </ref> has 2 state variables (y1, y2) and 1 input variable (x). As can be seen from this flow table, applying input sequences x, x, x to state 1, we reach state 4, not state 2, which is reached by applying x to state 1. <p> Essential hazards can be removed by adding feedback delays [63] or by using special factoring techniques <ref> [1] </ref>. All combinational hazards, critical races and essential hazards should be avoided because they can cause a circuit to malfunction.
Reference: [2] <author> D. B. Armstrong, A. D. Friedman, and P. R. Menon. </author> <title> "Design of Asynchronous Circuits Assuming Unbounded Gate Delays". </title> <journal> IEEE Tran. Computers, </journal> <volume> C-18(12):1110 - 1120, </volume> <month> December </month> <year> 1969. </year>
Reference-contexts: If the environment applies inputs too quickly, then a delay-hazard can occur <ref> [2] </ref>. In this thesis, we assume that the environment is well-behaved.
Reference: [3] <author> C. Berthet and E. Cerny. </author> <title> "Synthesis of Speed-independent Circuits Using Set-Memory Elements". </title> <editor> In G. Saucier, editor, </editor> <booktitle> Proc. Int'l. Workshop Logic and Arch. Synthesis for Silicon Compilers. </booktitle> <address> Grenoble, France, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: Thus, the following latches can be used to implement the feedback loop: * SM latch : Q = S + M Q <ref> [3] </ref> * SR latch : Q = S + RQ, where R = M . * C-element : Q = AB + (A + B)Q [60] where S = AB and M = A + B.
Reference: [4] <author> Gregor V. Bochmann. </author> <title> "Hardware Specification with Temporal Logic: An Example". </title> <journal> IEEE Tran. Computers, </journal> <volume> C-31(3):223 - 231, </volume> <month> March </month> <year> 1982. </year>
Reference-contexts: To overcome the insufficiency of simulation, many analysis and verification methods have been proposed. Some methods rely on proving some set of properties [13] [35] or invariants <ref> [4] </ref> to verify the correctness of the implementations. Such properties or invariants are very important and useful, but the burden of finding such properties usually rests on the designer, and the verification is incomplete in that not all errors, or deviations of implementation from specification, are covered.
Reference: [5] <author> G. Borriello. </author> <title> "A New Interface Specification Methodology and Its Application to Transducer Synthesis". </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1988. </year>
Reference-contexts: Introduction Asynchronous circuits have always been part of digital systems. The design of asynchronous circuits, however, have been thought to be difficult, and the main application of asynchronous circuits has been limited to interface circuits (or interface transducers <ref> [5] </ref>). Recently there has been a surge of interest on asynchronous circuits [18] [43] [46] [65] [39] due to numerous problems which arise from the design of high-speed synchronous circuits. This chapter reviews the problems with high-speed synchronous circuits and gives motivation for using asynchronous circuits. <p> This overhead becomes zero for asynchronous circuits. CHAPTER 1. INTRODUCTION 7 Rule-based Synthesis Given an event-based specification, there are many methods to synthesize an implementation from it. One intuitive method proposed by Borriello <ref> [5] </ref> is rule-based. First, a "skeleton" circuit is built by examining the paths in the specification which are responsible for the rising and falling transitions of each output. The skeleton circuit corresponding to the specification of Fig. 1.1 is given in Fig. 1.2 (a). <p> The refinements are performed through a set of rules which handle state assignment, logic minimization and hazard removal. Like <ref> [5] </ref> this method does not guarantee a globally optimal solution, but provides a higher level of specification than the event graph of [5] because both data path and control behaviors can be specified [43]. The specification consists of a set of communicating processes similar to Hoare's CSP [29]. <p> The refinements are performed through a set of rules which handle state assignment, logic minimization and hazard removal. Like <ref> [5] </ref> this method does not guarantee a globally optimal solution, but provides a higher level of specification than the event graph of [5] because both data path and control behaviors can be specified [43]. The specification consists of a set of communicating processes similar to Hoare's CSP [29]. The CSP-like specification corresponding to Fig 1.1 is shown in Fig. 1.3. CHAPTER 1. <p> The use of STGs as specification for formal verification will be discussed in chapter 3. The early work on STGs focused on analysis techniques at the specification level to satisfy some syntactic constraints [18] [46] [66] and relied on some particular types of latches to remove hazards [66] <ref> [5] </ref>. Unfortunately, such approaches do not produce implementations CHAPTER 1. INTRODUCTION 10 which are hazard-free under gate delay variations caused by operating conditions or process variations. <p> Since the set-reset (SR) latches implemented with cross-coupled NOR gates are immune to 1-hazards, some methods rely on SR latches to remove 1-hazards <ref> [5] </ref> [66]. Fig. 2.8 shows the basic structure of the two-level implementation using SR latches. The asterisk after S indicates that the SR latch is set-dominant :i.e., when both S and R inputs are 1, the output is determined by the S input. <p> To solve the inherent race problem associated with the SR latches, methods to synthesize S and R inputs separately have been proposed (for instance, <ref> [5] </ref>). Such methods allocate an SR latch to every output, synthesize logic to derive S and R inputs, and later rely on some peep-hole optimizations to remove unnecessary SR latches.
Reference: [6] <author> R. S. Boyer and J. S. Moore. "Proof-Checking, </author> <title> Theorem-Proving, and Program Verification". </title> <journal> Contemporary Mathematics, </journal> <volume> 29:119 - 131, </volume> <year> 1984. </year>
Reference-contexts: Also, some methods are not fully automatic and require manual intervention (like supplying hints to the verifier during theorem proving <ref> [6] </ref>). In this thesis we propose a new verification method which is fully automatic and complete: i.e., it covers all the deviations of implementations from the specified behavior given by the STG.
Reference: [7] <author> R. Brayton, G. Hachtel, C. McMullen, and A. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: The complexity of this algorithm is O (n), where n is the number of states in the state graph. The absence of 1-hazards under the MSC 6 Refer to <ref> [7] </ref> for the definition of the consensus operation. CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 33 condition is proven in the following theorem. Theorem 2.4.1 An SOP implementation from a well-formed STG G produced by the algorithm of Fig. 2.10 is free of logic 1-hazards under the MSC condition.
Reference: [8] <author> Jon G. Bredeson. </author> <title> "On Multiple Input Change Hazard-Free Combinational Switching Circuits Without Feedback". </title> <booktitle> In 14 th Annual Symposium on Switching and Automata Theory, </booktitle> <pages> pages 56-63, </pages> <month> October </month> <year> 1973. </year> <note> BIBLIOGRAPHY 129 </note>
Reference-contexts: In [9], Bredeson and Hulina proposed a technique to remove dynamic hazards by using set/reset (SR) latches. Only combinational circuits were considered; after hazards were removed, the circuits were transformed into sequential circuits which must satisfy some delay constraints. Bredeson later proposed a decomposition technique <ref> [8] </ref> which can remove hazards without using SR CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 35 latches, but again only combinational circuits were considered; the method did not exploit any signal ordering relations. As a result, many combinational circuits were not decomposable. <p> The decomposition technique of Bredeson fails to remove this dynamic hazard because there exists only one total stable set 8 (as defined in <ref> [8] </ref>). Also, the reduction technique of [48] 8 During the total stable set computation, we assumed that all the don't-care vertices belong to the off-set since the method of [8] assumes a fully specified function with no don't-care set. CHAPTER 2. <p> technique of Bredeson fails to remove this dynamic hazard because there exists only one total stable set 8 (as defined in <ref> [8] </ref>). Also, the reduction technique of [48] 8 During the total stable set computation, we assumed that all the don't-care vertices belong to the off-set since the method of [8] assumes a fully specified function with no don't-care set. CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 37 fails despite the presence of two signals z 1 and z 3 whose values remain at 0 during the concurrent firings of z 4 and z 2 +.
Reference: [9] <author> Jon G. Bredeson and Paul T. Hulina. </author> <title> "Elimination of Static and Dynamic Hazards for Multiple Input Changes in Combinational Switching Circuits". </title> <journal> Information and Control, </journal> <volume> 20 </volume> <pages> 114-124, </pages> <year> 1972. </year>
Reference-contexts: The following section discusses methods to remove the remaining logic hazards: dynamic hazards. 2.5 Elimination of Dynamic Hazards Out of many possible deviations (or hazards), dynamic hazards are the most difficult to remove when multiple signals are allowed to change simultaneously. In <ref> [9] </ref>, Bredeson and Hulina proposed a technique to remove dynamic hazards by using set/reset (SR) latches. Only combinational circuits were considered; after hazards were removed, the circuits were transformed into sequential circuits which must satisfy some delay constraints.
Reference: [10] <author> Erik Brunvand and Robert F. Sproull. </author> <title> "Translating Concurrent Programs into Delay-insensitive Circuits". </title> <booktitle> In Proc. Int'l. Conf. Computer-Aided Design, </booktitle> <pages> pages 262 - 265, </pages> <year> 1989. </year>
Reference-contexts: Then some rule-based local optimizations are performed to remove hazards and simplify the logic. The optimized circuit is shown in Fig. 1.2 (b). This method is fast and intuitive, but does not guarantee globally optimal solutions in general. Another rule-based method uses a technique called syntax-directed translation [15] <ref> [10] </ref>. Given the specification and a set of primitive elements (arbiters, AND gates, OR gates, etc.), the specification is successively refined until it can be implemented with the given set of primitive elements.
Reference: [11] <author> R. Bryant. </author> <title> Graph-Based Algorithms for Boolean Function Manipulation. </title> <journal> In IEEE Transactions on Computers, </journal> <volume> volume C-35, </volume> <pages> pages 677-691, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: The properties of ordinary Boolean functions (where all the variables have S i = f0; 1g) can be directly extended to Boolean functions of multi-valued variables ([41]). Definition 4.2.12 A multi-valued decision diagram (MDD, see <ref> [11] </ref> and [32]) is a rooted directed acyclic graph where: * every leaf node is labeled with either the value 1 or 0. * every non-leaf node is labeled with a multi-valued Boolean variable. * every edge is labeled with one value of the variable corresponding to its source node. 2
Reference: [12] <author> J.A. Brzozowski and C-J.H. Seger. </author> <title> "Advances in Asynchronous Circuit Theory Part I: Gate and Unbounded Inertial Delay Models". </title> <journal> In Bulletin of European Association of Theoretical Computer Science, </journal> <month> October </month> <year> 1990. </year>
Reference-contexts: These are used to define a ternary function, which can be determined from a binary function by using the uncertainty partial orders and the least upper bound operators. The following definitions are from <ref> [12] </ref>. The uncertainty partial order on f0; 1; Xg is defined as follows : 0 v 0; 1 v 1; X v X; 0 &lt; X; and 1 &lt; X: CHAPTER 3. VERIFICATION 53 The partial order between 0 and 1 is not defined. <p> This CHAPTER 3. VERIFICATION 55 complexity bound is based on the assumption that the ternary evaluation of a single gate takes a constant time <ref> [12] </ref>. Although ternary simulation can be used to detect both combinational and se quential hazards efficiently, it suffers from two major drawbacks: * It is state-based and is difficult to use directly for event-based specifications like STGs where there is no explicit notion of stable states. <p> This dynamic hazard cannot be detected by simply examining the final state; the paths leading to the final state must be also be examined. However, no efficient method to perform this path analysis is known <ref> [12] </ref>. The following section describes a method based on trace theory which can be used to detect both dynamic hazards and delay hazards. 3.2.2 Trace Theory Trace-theoretic verification method proposed by Dill [20] considers the correctness of implementations relative to specifications.
Reference: [13] <author> J. R. Burch, E. M. Clarke, and K. L. McMillan. </author> <title> "Sequential Circuit Verification Using Symbolic Model Checking". </title> <booktitle> In Proc. Design Automation Conf., </booktitle> <pages> pages 46 - 51, </pages> <year> 1990. </year>
Reference-contexts: To overcome the insufficiency of simulation, many analysis and verification methods have been proposed. Some methods rely on proving some set of properties <ref> [13] </ref> [35] or invariants [4] to verify the correctness of the implementations.
Reference: [14] <author> S. Burns and A. Martin. </author> <title> A synthesis method for self-timed VLSI circuits. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <year> 1987. </year>
Reference-contexts: We are also planning to investigate how to use it within other event-based specifications for asynchronous circuits, such as the one proposed in <ref> [14] </ref>. 126 Chapter 5 Conclusions and Future Work This thesis has addressed synthesis and verification problems arising from the signal transition graph (STG) specifications of asynchronous circuits.
Reference: [15] <author> Steven M. Burns and A. J. Martin. </author> <title> "Syntax-directed Translation of Concurrent Programs into Self-timed Circuits". </title> <booktitle> In Proc. Fifth MIT Conference, </booktitle> <pages> pages 35 - 50, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Then some rule-based local optimizations are performed to remove hazards and simplify the logic. The optimized circuit is shown in Fig. 1.2 (b). This method is fast and intuitive, but does not guarantee globally optimal solutions in general. Another rule-based method uses a technique called syntax-directed translation <ref> [15] </ref> [10]. Given the specification and a set of primitive elements (arbiters, AND gates, OR gates, etc.), the specification is successively refined until it can be implemented with the given set of primitive elements.
Reference: [16] <author> Yaacov Choueka. </author> <title> "Theories of Automata on !-Tapes: A Simplified Approach". </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 8 </volume> <pages> 117-141, </pages> <year> 1974. </year>
Reference-contexts: Such models can be built by using finite automata similar to DFA which accept sequences by considering their infinite or eventuality behavior. Such automata are called !-automata and there exist many types of !-automata depending on how the acceptance conditions are defined <ref> [16] </ref>. One such type is an L-automaton. The model of L-automaton was proposed by Kurshan [37] with the intent of providing support for component-wise reduction.
Reference: [17] <author> Kan M. Chu and David I. Pulfrey. </author> <title> "Design Procedures for Differential Cascode Voltage Switch Logic". </title> <journal> IEEE J. Solid State Circuits, </journal> <volume> SC-21(6):1082 - 1087, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: However, this low power potential CHAPTER 1. INTRODUCTION 3 is sensitive to the implementation technology. Technologies such as the Differential Cas-code Voltage Switch Logic (DCVSL) <ref> [17] </ref> may not obtain the benefit of low power from the elimination of the clock because they have more switching elements than synchronous circuits.
Reference: [18] <author> Tam-Anh Chu. </author> <title> "Synthesis of Self-timed VLSI Circuits from Graph-theoretic Specifications". </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: Introduction Asynchronous circuits have always been part of digital systems. The design of asynchronous circuits, however, have been thought to be difficult, and the main application of asynchronous circuits has been limited to interface circuits (or interface transducers [5]). Recently there has been a surge of interest on asynchronous circuits <ref> [18] </ref> [43] [46] [65] [39] due to numerous problems which arise from the design of high-speed synchronous circuits. This chapter reviews the problems with high-speed synchronous circuits and gives motivation for using asynchronous circuits. <p> The use of STGs as specification for formal verification will be discussed in chapter 3. The early work on STGs focused on analysis techniques at the specification level to satisfy some syntactic constraints <ref> [18] </ref> [46] [66] and relied on some particular types of latches to remove hazards [66] [5]. Unfortunately, such approaches do not produce implementations CHAPTER 1. INTRODUCTION 10 which are hazard-free under gate delay variations caused by operating conditions or process variations. <p> A net is safe if and only if all of its places are safe. Safeness is sufficient for ensuring boundedness and for explicitly specifying the choice behavior <ref> [18] </ref>. When free-choice places are not safe, choice behavior cannot be specified explicitly 1 . 1 Consider a free-choice place with two fanout transitions t 1 and t 2 . <p> An STG is executed by examining all the markings reachable from M 0 . The SG captures all the possible transition sequences from the STG, and can be derived by the deterministic procedure given in <ref> [18] </ref>. Formally, SG is a 2-tuple, hV; F i, where V is a set of states and F a set of edges V fi V . <p> The edge e is labeled with t. In order to implement the SG, each state must be assigned a binary code. In <ref> [18] </ref>, Chu proposed using the signal values S to define a binary labeling of each state. The label is simply the set of values of all signals S that the circuit may have in the given state. With this labeling, only output signals are used as feedback signals. <p> Definition 2.2.10 A state graph is said to satisfy a unique state coding (USC) property [65] if no two different states are assigned the same binary code. 2 This definition comes from p. 36 and p. 84 in <ref> [18] </ref>, and is different from the definition of liveness used in Petri net literature. 3 The SM component SM i of a Petri net P refers to a strongly connected subgraph of P such that each transition of SM i has exactly one fanin and one fanout place. <p> CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 17 A variation of the USC property which is less stringent is called the complete state coding (CSC) property. The CSC property allows two states to have the same code if the environment can distinguish them. This property was proposed in <ref> [18] </ref> by Chu, who simply called the CSC violation a "state assignment problem." Definition 2.2.11 A state graph is said to satisfy a complete state coding (CSC) property if * it satisfies the USC property or * when the same binary code is assigned for two different states, the transitions of <p> After this, output logic can be derived from the implied values of the outputs at each state. Definition 2.2.19 The implied value <ref> [18] </ref> of an output z in some state s is defined as * the complement of the present value of z as seen in the binary code of s if zfl is enabled in state s; otherwise, * the present value of z in the binary label of s. <p> If CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 24 no initial marking is given, then an algorithm based on the reduction of the STG into marked graph components is used to find a live initial marking <ref> [18] </ref>. STGs based on non free-choice Petri nets are also synthesized. For a non free-choice net without an initial marking, we perform marked graph decomposition. <p> some syntactic constraints (liveness, CSC property, and STG persistency) on the STGs <ref> [18] </ref>[46]. Unfortunately, such syntactic constraints only remove part of the undesirable behavior at a functional level and do not guarantee a hazard-free implementation. STG persistency, for example, was a condition thought to be necessary and sufficient for speed-independence [18]. The basic idea behind CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 26 STG persistency is as follows: if a signal causes some output signal to change, then it must remain stable until the output signal has changed. <p> diagram (BDD) should help reduce the complexity even further. 3.5 Component-wise Reduction To avoid the explosion in the number of states and the number of selection variables, we propose a reduction method which is based on the closure properties of L-process and the Petri net decomposition technique called net contraction <ref> [18] </ref>. The reduction in complexity is achieved by performing verification on a component-by-component basis. <p> This component-wise verification is illustrated in Fig. 3.21. To obtain P ST G and P Gate as a tensor product of its components, we apply net contraction <ref> [18] </ref> at each output signal s i in the STG. Net contraction removes transitions not belonging to the input set of s i from the given STG, without destroying its temporal CHAPTER 3. VERIFICATION 86 properties such as concurrency and sequencing. <p> STG input and output signals) change. Furthermore every FSM stable state is represented by a stable circuit state, if we use any of the synthesis methodologies presented in <ref> [18] </ref>, [38] or [48]. This is due to the fact that if the synthesized circuit implements the STG specification, then after all the enabled transitions fire, they cannot be enabled again until some external signal changes.
Reference: [19] <author> F. Commoner, A. W. Holt, S. Even, and A. Pnueli. </author> <title> "Marked Directed Graphs". </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 5 </volume> <pages> 511-523, </pages> <year> 1971. </year>
Reference: [20] <author> David L. Dill. </author> <title> "Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits". </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1988. </year> <note> BIBLIOGRAPHY 130 </note>
Reference-contexts: The basic approach is based on the event coordination model of Kurshan [37]. This approach is similar to the trace-theoretic approach of Dill <ref> [20] </ref> in that both attempt to verify the correctness of the implementation relative to the specification. The differences are that the event coordination approach uses CHAPTER 3. VERIFICATION 52 a non-deterministic model which accepts infinite sequences, whereas the trace-theoretic approach uses a deterministic model which accepts finite sequences. <p> However, no efficient method to perform this path analysis is known [12]. The following section describes a method based on trace theory which can be used to detect both dynamic hazards and delay hazards. 3.2.2 Trace Theory Trace-theoretic verification method proposed by Dill <ref> [20] </ref> considers the correctness of implementations relative to specifications. Both specifications and implementations are modeled as finite automata, and traces (sequences of events on signals) accepted by the automata are used to represent the actual or the desired circuit behavior. Verification is performed by "comparing" the traces.
Reference: [21] <author> David L. Dill. </author> <title> "Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits". </title> <booktitle> In Proc. Fifth MIT Conference, </booktitle> <pages> pages 51 - 65, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: A petri net specification is transformed to DFA by using its reachability graph (or a state graph in the case of STGs). Although conformance relation has been used to discover errors in some published designs <ref> [21] </ref>, and is powerful enough to detect delay hazards and dynamic hazards (as well as other combinational and sequential hazards), the results of verification can be false positive: i.e., M I M S does not necessarily mean that I is a correct implementation of S.
Reference: [22] <author> Daniel Dobberpuhl, Richard Witek, Randy Allmon, Robert Anglin, Sharon Britton, Linda Chao, Robert Conrad, Daniel Dever, Bruce Gieseke, Gregory Hoeppner, John Kowaleski, Kathryn Kuchler, Maureen Ladd, Michael Leary, Liam Madden, Edward McLellan, Derrick Meyer, James Montanaro, Donald Priore, Vidya Rajagopalan, Srid-har Samudrala, and Sribalan Santhanam. </author> <title> A 200MHz 64b dual-issue CMOS microprocessor. </title> <booktitle> In IEEE International Solid-State Circuits Conference, </booktitle> <pages> pages 106-107,256, </pages> <year> 1992. </year>
Reference-contexts: Another possible benefit of eliminating the clock signal is the low power. The recent DEC Alpha chip, for example, operates at 200 MHz and dissipates 30 W of power, about half of which is used by the clock circuitry <ref> [22] </ref>. However, this low power potential CHAPTER 1. INTRODUCTION 3 is sensitive to the implementation technology. Technologies such as the Differential Cas-code Voltage Switch Logic (DCVSL) [17] may not obtain the benefit of low power from the elimination of the clock because they have more switching elements than synchronous circuits.
Reference: [23] <author> E. B. Eichelberger. </author> <title> "Hazard Detection in Combinational and Sequential Switching Circuits". </title> <journal> IBM Journal of Research and Development, </journal> <pages> pages 90 - 99, </pages> <month> March </month> <year> 1965. </year>
Reference-contexts: Depending on the nature of hazards, they can be classified into two categories: logic hazards and function hazards. This classification is due to Eichelberger <ref> [23] </ref>. Definition 2.2.22 Logic (Function) hazards refer to static and dynamic hazards in functions which (do not) respond monotonically to all input changes. Function hazards can only be removed by altering the specified behavior. CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 20 Logic and function hazards are illustrated in Fig. 2.4. <p> F against R */ 14 g 16 onset minterm (s) f 17 if (there exists a on-set minterm m corresponding to state s) f 18 return m; 19 g else f 20 return ;; /* The implied value of every output in s is 0 */ 21 g g mentation <ref> [23] </ref>. We identify the conditions under which 1-hazards can occur, and remove 1-hazards by adding some redundant cubes to the given cover. State graphs provide an excellent framework to perform such hazard analysis and removal because it sequentializes all concurrency as single signal changes. <p> are given in section 3.6. 3.2 Previous Work This section reviews two works which are the most relevant for this thesis on the verification of asynchronous circuits using the speed-independent model: ternary simulation and trace theory. 3.2.1 Ternary Simulation Ternary simulation is a verification technique proposed by Eichelberger in 1965 <ref> [23] </ref>. This technique can be used to detect sequential as well as combinational hazards, and is very efficient. This method uses three values: 0, 1 and X (X represents an intermediate value between 0 and 1).
Reference: [24] <author> J. Gimpel. </author> <title> A reduction technique for prime implicant tables. </title> <journal> IEEE Trans. Elec. Comp., </journal> <volume> EC-14:535-541, </volume> <month> August </month> <year> 1965. </year>
Reference-contexts: No polynomial time algorithms which solve the minimum cover problem exactly are known [58], but efficient heuristics (such as the one suggested by Gimpel <ref> [24] </ref>) exist, and can be used to solve the minimum cover problem. This procedure has not been implemented. Fig. 2.11 shows the application of the algorithm of Fig. 2.10. A new prime implicant ac is added to eliminate the hazard.
Reference: [25] <author> G. Gopalakrishnan, E. Brunvand, N. Michell, and S. Nowick. </author> <title> "A Correctness Criterion for Asynchronous Circuit Validation and Optimization". </title> <type> Technical Report UUCS92-004, </type> <institution> University of Utah, </institution> <year> 1992. </year>
Reference-contexts: The main problem is that the DFA model of the trace theory has difficulty handling liveness, which is a property associated with infinite sequences. As an illustration of this problem, consider the two DFA's in Fig. 3.5. This example is from <ref> [25] </ref>. In this example, I = fa; bg, O = fcg, and M I M S , but I fails to produce the output c after receiving inputs a and b. <p> Thus, I is not a correct implementation of S, even though M I M S . To remedy this problem, a new relation called strong conformance was proposed CHAPTER 3. VERIFICATION 60 by Gopalakrishnan et. al. in <ref> [25] </ref>. M I strongly conforms to M S if * M I M S , and * S (M S ) S (M I ), where S (M ) denotes the set of successful traces of M . Strong conformance can detect some but not all deadlocks. <p> Strong conformance can detect some but not all deadlocks. For example, Ebergen's implementations of the generalized selector <ref> [25] </ref> have deadlocks that strong conformance cannot detect. In addition, as pointed out in [25], strong conformance relation can sometimes give false negative results: i.e., it can reject correct implementations. The alternating selector [25] of Fig. 3.6 is a correct "refinement" of the generalized selector, but M AS does not strongly <p> Strong conformance can detect some but not all deadlocks. For example, Ebergen's implementations of the generalized selector <ref> [25] </ref> have deadlocks that strong conformance cannot detect. In addition, as pointed out in [25], strong conformance relation can sometimes give false negative results: i.e., it can reject correct implementations. The alternating selector [25] of Fig. 3.6 is a correct "refinement" of the generalized selector, but M AS does not strongly conform to M GS (however, M AS conforms to M GS ). <p> For example, Ebergen's implementations of the generalized selector <ref> [25] </ref> have deadlocks that strong conformance cannot detect. In addition, as pointed out in [25], strong conformance relation can sometimes give false negative results: i.e., it can reject correct implementations. The alternating selector [25] of Fig. 3.6 is a correct "refinement" of the generalized selector, but M AS does not strongly conform to M GS (however, M AS conforms to M GS ). <p> CHAPTER 3. VERIFICATION 72 The conformance test used in Dill's verifier fails to detect the error in Example 3.3.4. The strong conformance test <ref> [25] </ref> detects this error, but may lead to false negative results in some other cases. <p> Thus, L (P as A # gs ) = ;, and L (P as ) L (P gs ). Note that the alternating selector of Example 3.3.5 does not strongly conform to the generalized selector <ref> [25] </ref>, even though the behavior of the alternating selector is contained in the behavior of the generalized selector.
Reference: [26] <author> G.D. Hachtel, J.-K. Rho, F. Somenzi, and R. </author> <title> Jacoby. Exact and Heuristic Algorithms for the Minimization of Incompletely Specified State Machines. </title> <booktitle> In Proceedings of the European Design Automation Conference, </booktitle> <pages> pages 184-191, </pages> <address> Amsterdam, The Nether-lands, </address> <month> February </month> <year> 1991. </year>
Reference: [27] <author> Michel H. Hack. </author> <title> "Analysis of Production Schemata by Petri Nets". </title> <type> Master's thesis, </type> <institution> M.I.T., </institution> <month> February </month> <year> 1972. </year> <note> (Project MAC TR-94). </note>
Reference-contexts: Free-choice (FC) nets allow both concurrency and choice to be specified but are easier to analyze than general Petri nets <ref> [27] </ref>. Hack proved that free-choice nets can be decomposed into a set of marked graph components or a set of state machine components [27]. Thus, free-choice nets can be viewed as a set of state machines (SMs) operating concurrently or as a set of concurrent processes (MGs) operating sequentially. <p> Free-choice (FC) nets allow both concurrency and choice to be specified but are easier to analyze than general Petri nets <ref> [27] </ref>. Hack proved that free-choice nets can be decomposed into a set of marked graph components or a set of state machine components [27]. Thus, free-choice nets can be viewed as a set of state machines (SMs) operating concurrently or as a set of concurrent processes (MGs) operating sequentially. STG is an interpreted free-choice net where each transition is interpreted as a physical transition on some signal. <p> In <ref> [27] </ref> Hack proved that for a live, safe Petri net P can be decomposed into a set of SM components SM i which cover P : i.e., all the transitions and places of P are included in some SM i . CHAPTER 2.
Reference: [28] <author> Z. Har'El and R. P. Kurshan. </author> <title> "Software for Analysis of Coordination". </title> <booktitle> In Proc. International Conf. Syst. Sci., </booktitle> <pages> pages 382 - 385, </pages> <year> 1988. </year>
Reference-contexts: We were able to remove all dynamic hazards from the circuits where the cube reduction of [48] failed. Extending this factoring method to produce general multi-level implementations from STGs could be an interesting avenue for future research. The following chapter describes a formal method based on event coordination <ref> [28] </ref>, which can verify the correctness of any gate-level implementations relative to STG specifications. 51 Chapter 3 Verification 3.1 Introduction Verifying the correctness of asynchronous circuits is one of the most important tasks in asynchronous design. <p> The computation of the tensor product and checking its language for emptiness can be performed by a software tool called COSPAN <ref> [28] </ref>. COSPAN finds that L (P I ) 6 L (A S ), and produces the error track of Fig. 3.13. The sequence of signals leading to the beginning of the bad cycle is b; a; b.
Reference: [29] <author> C.A.R. Hoare. </author> <title> "Communicating Sequential Processes". </title> <journal> Communications of the ACM, </journal> <volume> 21(8):323 - 334, </volume> <month> August </month> <year> 1978. </year>
Reference-contexts: Like [5] this method does not guarantee a globally optimal solution, but provides a higher level of specification than the event graph of [5] because both data path and control behaviors can be specified [43]. The specification consists of a set of communicating processes similar to Hoare's CSP <ref> [29] </ref>. The CSP-like specification corresponding to Fig 1.1 is shown in Fig. 1.3. CHAPTER 1. INTRODUCTION 8 (a; b) C c a ^ b 7! c " Algorithmic Synthesis While rule-based methods view only local solution space, algorithmic methods try to take a global view.
Reference: [30] <author> D. A. Huffman. </author> <title> "The Synthesis of Sequential Switching Circuits". </title> <journal> J. Franklin Institute, </journal> <volume> 257:161 - 190, </volume> <pages> 275-303, </pages> <month> March </month> <year> 1954. </year> <note> BIBLIOGRAPHY 131 </note>
Reference-contexts: This section briefly reviews how the two approaches addressed the design problems for control-dominated asynchronous circuits, where the problems are the most complex and difficult. 1.4.1 State-based Approaches The classical Huffman finite-state machine (FSM) <ref> [30] </ref> is a well-known state-based specification. Synchronous circuits are usually specified in the form of a state transition table, which specifies how the states and the outputs react to input changes. The equivalent form of specification for asynchronous circuits is called the flow table.
Reference: [31] <author> Gordon M. Jacobs. </author> <title> "Self-timed Integrated Circuits for Digital Signal Processing". </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1989. </year> <note> (UCB/ERL M89/128). </note>
Reference-contexts: Today's high-speed designs are already exceeding 100 MHz, and the problem of distributing clock signals is becoming increasingly difficult. As the device dimensions are scaled down further, the clock skew problem may even become uncharacterizable until the layout of a chip is completed <ref> [31] </ref>. Asynchronous circuits are very attractive in this respect because they use no global clock signal. Also, by eliminating the clock signal, designers can be freed from the "tyranny of the clock"[50]. <p> The delay-insensitive model can give rise to more robust designs, but unfortunately the class of circuits which can be implemented in a delay-insensitive manner is very limited [44]. The speed-independent model has been found to be a reasonable model for today's VLSI technologies <ref> [31] </ref>. Using the speed-independent model, a two-level implementation is synthesized which is hazard-free under various operating conditions. The area overhead due to hazard removal is shown to be very small. CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 12 This chapter is organized as follows. <p> The validation of the speed-independent model is an interesting area of future research. Although for small to medium size interface circuits, the speed-independent model has been shown to be practical <ref> [31] </ref>, it will be interesting to formalize the conditions under which the speed-independent or the isochronic fork models hold. One possible validation method is to come up with a set of inequalities in terms of gate and wire delays from the final gate-level implementation.
Reference: [32] <author> T. Kam. </author> <title> Multi-valued decision diagrams. </title> <type> Master's thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1990. </year>
Reference-contexts: The properties of ordinary Boolean functions (where all the variables have S i = f0; 1g) can be directly extended to Boolean functions of multi-valued variables ([41]). Definition 4.2.12 A multi-valued decision diagram (MDD, see [11] and <ref> [32] </ref>) is a rooted directed acyclic graph where: * every leaf node is labeled with either the value 1 or 0. * every non-leaf node is labeled with a multi-valued Boolean variable. * every edge is labeled with one value of the variable corresponding to its source node. 2 The encoded
Reference: [33] <author> J. Katzenelson and R. P. Kurshan. </author> <title> "S/R: A Language For Specifying Protocols and Other Coordinating Processes". </title> <booktitle> In Proc. 5 th Ann. International Pheonix Conf. Com-put. Commun., </booktitle> <pages> pages 286-292, </pages> <year> 1986. </year>
Reference-contexts: This L-automaton expresses the following invariant or task: signals a and c always alternate. This automaton can be used on the JOIN element of Fig. 3.5 (b) to check if it performs the above task (Example 3.3.3). The S/R language specification <ref> [33] </ref> of this task is given in Fig. 3.8 2 . L-automata are well-suited for describing some desired tasks or properties in terms of cyclic or recurring invariants, but the lack of outputs makes it difficult to specify the actual or desired circuit behavior as a set of interacting automata.
Reference: [34] <author> M. A. Kishinevsky, A. Y. Kondratyev, and A. R. Taubin. </author> <title> Formal method for self-timed design. </title> <booktitle> In Proceedings of the European Design Automation Conference, </booktitle> <year> 1991. </year>
Reference: [35] <author> M.A. Kishinevsky, A. Y. Kondratyev, and A. R. Taubin. </author> <title> "Concurrent Asynchronous Hardware: Behavior Verification on Event-based Model". </title> <booktitle> In Proc. Computer-aided Verification, </booktitle> <year> 1992. </year>
Reference-contexts: To overcome the insufficiency of simulation, many analysis and verification methods have been proposed. Some methods rely on proving some set of properties [13] <ref> [35] </ref> or invariants [4] to verify the correctness of the implementations. Such properties or invariants are very important and useful, but the burden of finding such properties usually rests on the designer, and the verification is incomplete in that not all errors, or deviations of implementation from specification, are covered.
Reference: [36] <author> David S. Kung. </author> <title> "Hazard-non-increasing gate-level optimization algorithms". </title> <booktitle> Proc. Int'l. Conf. Computer-Aided Design, </booktitle> <pages> pages 631 - 634, </pages> <year> 1992. </year>
Reference-contexts: However, factoring is the preferred method in general since cube reduction may decrease testability. Extending this factoring method to produce general multi-level implementations from STGs is an interesting area of future research. While most multi-level decomposition techniques [55] <ref> [36] </ref> are hazard-non-increasing, our factoring method is actually hazard-decreasing. We have also addressed the problem of verifying the correctness of gate-level imple CHAPTER 5. CONCLUSIONS AND FUTURE WORK 127 mentations relative to STG specifications. This verification method is fully automatic and covers all variations of implementations from specifications.
Reference: [37] <author> R.P. Kurshan. </author> <title> "Analysis of Discrete Event Coordination". </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 430:414 - 453, </volume> <year> 1990. </year>
Reference-contexts: The new method can also prove properties and invariants such as liveness and stability, and can model concurrency and conflict as well as various modes of interactions between the circuit and the environment. The basic approach is based on the event coordination model of Kurshan <ref> [37] </ref>. This approach is similar to the trace-theoretic approach of Dill [20] in that both attempt to verify the correctness of the implementation relative to the specification. The differences are that the event coordination approach uses CHAPTER 3. <p> Such automata are called !-automata and there exist many types of !-automata depending on how the acceptance conditions are defined [16]. One such type is an L-automaton. The model of L-automaton was proposed by Kurshan <ref> [37] </ref> with the intent of providing support for component-wise reduction. L-automata were designed to express a set of properties (like liveness or stability) or tasks (for example, a request eventually gets acknowledged ) on infinite sequences. A dual of an L-automaton is a finite-state machine called an L-process. <p> Since the verification work of this thesis is based on the model of event coordination, it is reviewed in some detail here. A complete review can be found in <ref> [37] </ref>. This section is organized as follows. Section 3.3.1 defines L-processes and L-automata, and the languages accepted by them. Section 3.3.2 discusses how verification is performed using L-processes and L-automata. The example of Fig. 3.5 is used to compare the language containment verification method with the trace-theoretic method. <p> This problem can be solved by transforming P S into an L-automaton A S such that L (P S ) = L (A S ). A method to perform this transformation in general is given in <ref> [37] </ref>. The S/R CHAPTER 3. <p> The following theorem <ref> [37] </ref> gives the conditions under which the implication 3.1 holds. Theorem 3.3.1 Let P be an L-process, P 0 an L 0 -process, T an L-automaton and T 0 an L 0 -automaton. <p> Thus, to check for L (P ) L ('P 0 ), L ('P 0 ) needs to be transformed into an equivalent L-automata A 0 such that L ('P 0 ) = L (A 0 ) <ref> [37] </ref>. Then, the language containment can be checked from the tensor product: L (P A 0# ). The problem of checking if L (T # ) L ('T 0# ) is treated similarly [37]. <p> into an equivalent L-automata A 0 such that L ('P 0 ) = L (A 0 ) <ref> [37] </ref>. Then, the language containment can be checked from the tensor product: L (P A 0# ). The problem of checking if L (T # ) L ('T 0# ) is treated similarly [37]. This homomorphism verification lends nicely to implementation verification, where both specifications and implementations are expressed as either L-processes or L-automata. The following example illustrates the homomorphism verification using two L-processes. Example 3.3.5 Let us consider the selectors of Fig. 3.6. <p> i P Gate i , L (Gate i ) L (ST G i ) 8i ) L (Gate) L (ST G): Proof Since L (Gate i ) L (ST G i ) 8i, " L (Gate i ) " L (ST G i ): By the closure property of L-process <ref> [37] </ref>, T i L (Gate i ) = L ( i Gate i ); T i L (Gate i ) = L ( i ST G i ): Thus, L (Gate i ) L (ST G i ) 8i ) L (Gate) L (ST G). <p> This verification method provides a sanity check for synthesis methods which use the speed-independent model, and enables designers to validate some manual gate-level changes to the final design. This method is based on the event coordination model <ref> [37] </ref>, which is capable of detecting deadlocks, and removes all the false negative and positive results associated with the liveness problems in the trace theory. Our method do not require any manual intervention, and can cover all the deviations of implementations from the specified behavior given by the STG.
Reference: [38] <author> L. Lavagno, K. Keutzer, and A. Sangiovanni-Vincentelli. </author> <title> Algorithms for synthesis of hazard-free asynchronous circuits. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: STG input and output signals) change. Furthermore every FSM stable state is represented by a stable circuit state, if we use any of the synthesis methodologies presented in [18], <ref> [38] </ref> or [48]. This is due to the fact that if the synthesized circuit implements the STG specification, then after all the enabled transitions fire, they cannot be enabled again until some external signal changes.
Reference: [39] <author> L. Lavagno, C. W. Moon, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Solving the state assignment problem for signal transition graphs. </title> <booktitle> In Proc. Design Automation Conf., </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: The design of asynchronous circuits, however, have been thought to be difficult, and the main application of asynchronous circuits has been limited to interface circuits (or interface transducers [5]). Recently there has been a surge of interest on asynchronous circuits [18] [43] [46] [65] <ref> [39] </ref> due to numerous problems which arise from the design of high-speed synchronous circuits. This chapter reviews the problems with high-speed synchronous circuits and gives motivation for using asynchronous circuits. <p> Transitions belonging to output signals whose input signals change prematurely were called non-persistent, and were thought to be hazard-prone. However, it has been shown in <ref> [39] </ref> that non-persistent transitions do not necessarily lead to hazards. In addition, it has been shown in [64] that STG persistency is not a sufficient condition for the CSC property. Thus, STG persistency is neither necessary nor sufficient for speed-independence.
Reference: [40] <author> B. Lin and F. Somenzi. </author> <title> Minimization of symbolic relations. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: CHAPTER 4. SOLVING THE STATE ASSIGNMENT PROBLEM 106 (II) Finding a minimum cost partitioning set One way to find a minimum cost partitioning set given the clauses described in the previous section is to combine the approach described in <ref> [40] </ref> to solve binate covering using binary decision diagrams with the multi-valued extension of binary decision diagrams (MDD). We build an MDD representing a conjunction of the clauses. Any path from the root to the 1 leaf corresponds to a partial assignment of values to the variables. <p> Then, as shown in <ref> [40] </ref>, a shortest path from the root to the 1 leaf corresponds to a minimum cost assignment that satisfies all the constraints.
Reference: [41] <author> S. Malik. </author> <title> Combinational Logic Optimization Techniques in Sequential Logic Synthesis. </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <month> November </month> <year> 1990. </year>
Reference: [42] <author> A. Martin. </author> <title> Formal program transformations for VLSI synthesis. </title> <editor> In E. W. Dijkstra, editor, </editor> <booktitle> Formal Development of Programs and Proofs, The UT Year of Programming Series. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year> <note> BIBLIOGRAPHY 132 </note>
Reference: [43] <author> A. J. Martin, S. M. Burns, and T. K. Lee. </author> <title> "The Design of an Asynchronous Microprocessor". </title> <booktitle> In Proc. Decennial Caltech Conference on VLSI, </booktitle> <pages> pages 351 - 373, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: The design of asynchronous circuits, however, have been thought to be difficult, and the main application of asynchronous circuits has been limited to interface circuits (or interface transducers [5]). Recently there has been a surge of interest on asynchronous circuits [18] <ref> [43] </ref> [46] [65] [39] due to numerous problems which arise from the design of high-speed synchronous circuits. This chapter reviews the problems with high-speed synchronous circuits and gives motivation for using asynchronous circuits. <p> Like [5] this method does not guarantee a globally optimal solution, but provides a higher level of specification than the event graph of [5] because both data path and control behaviors can be specified <ref> [43] </ref>. The specification consists of a set of communicating processes similar to Hoare's CSP [29]. The CSP-like specification corresponding to Fig 1.1 is shown in Fig. 1.3. CHAPTER 1.
Reference: [44] <author> Alain J. Martin. </author> <title> "The Limitations to Delay-Insensitivity in Asynchronous Circuits". </title> <editor> In William J. Dally, editor, </editor> <booktitle> Proc. Advanced Research in VLSI, </booktitle> <pages> pages 263 - 278. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The delay-insensitive model assumes that both gates and wires can have unbounded but finite delays. The delay-insensitive model can give rise to more robust designs, but unfortunately the class of circuits which can be implemented in a delay-insensitive manner is very limited <ref> [44] </ref>. The speed-independent model has been found to be a reasonable model for today's VLSI technologies [31]. Using the speed-independent model, a two-level implementation is synthesized which is hazard-free under various operating conditions. The area overhead due to hazard removal is shown to be very small. CHAPTER 2.
Reference: [45] <author> K. L. McMillan. </author> <title> "Using unfoldings to avoid the state explosion problem in the verification of asynchronous circuits". </title> <booktitle> In Proc. Computer-aided Verification, </booktitle> <pages> pages 169 - 174, </pages> <year> 1992. </year>
Reference: [46] <author> T. Meng, R. W. Brodersen, and D. G. Messerschmitt. </author> <title> "Automatic Synthesis of Asynchronous Circuits from High-Level Specifications". </title> <journal> IEEE Tran. Computer-Aided Design, </journal> <volume> 8(11):1185 - 1205, </volume> <month> November </month> <year> 1989. </year>
Reference-contexts: The design of asynchronous circuits, however, have been thought to be difficult, and the main application of asynchronous circuits has been limited to interface circuits (or interface transducers [5]). Recently there has been a surge of interest on asynchronous circuits [18] [43] <ref> [46] </ref> [65] [39] due to numerous problems which arise from the design of high-speed synchronous circuits. This chapter reviews the problems with high-speed synchronous circuits and gives motivation for using asynchronous circuits. <p> The presence of a deadlock can be checked formally [19][27], and the performance can be evaluated from the lengths of the longest cycles in the STG <ref> [46] </ref>. <p> The use of STGs as specification for formal verification will be discussed in chapter 3. The early work on STGs focused on analysis techniques at the specification level to satisfy some syntactic constraints [18] <ref> [46] </ref> [66] and relied on some particular types of latches to remove hazards [66] [5]. Unfortunately, such approaches do not produce implementations CHAPTER 1. INTRODUCTION 10 which are hazard-free under gate delay variations caused by operating conditions or process variations.
Reference: [47] <author> R. E. Miller. </author> <title> "Switching Theory", volume II, chapter 10. </title> <publisher> John Wiley and Sons, </publisher> <year> 1965. </year>
Reference-contexts: By using CHAPTER 1. INTRODUCTION 6 the notion of total state 1 , in which states are defined by inputs and outputs, more efficient implementations can be produced <ref> [47] </ref>. Specifications based on total states are called state graphs to distinguish them from the Huffman FSMs. Although state graphs can lead to more efficient implementations, they still suffer from the similar syntactic drawbacks as Huffman FSMs. 1.4.2 Event-based Approaches Unlike state-based specifications, event-based specifications define states implicitly. <p> To produce hazard-free circuits in the presence of variations in component and interconnect delays, an abstract but realistic delay model is necessary. We use the speed-independent model. This model (also called the Muller model <ref> [47] </ref> or the unbounded gate delay model) assumes that gates (components) have unbounded but finite delays and wires (interconnects) have zero delays. The delay-insensitive model assumes that both gates and wires can have unbounded but finite delays.
Reference: [48] <author> Cho W. Moon, Paul R. Stephan, and Robert K. Brayton. </author> <title> "Synthesis of Hazard-free Asynchronous Circuits from Graphical Specifications". </title> <booktitle> In Proc. Int'l. Conf. Computer-Aided Design, </booktitle> <year> 1991. </year>
Reference-contexts: HAZARD-FREE LOGIC SYNTHESIS 35 latches, but again only combinational circuits were considered; the method did not exploit any signal ordering relations. As a result, many combinational circuits were not decomposable. Methods which exploit the signal ordering relations and are applicable to both combinational and sequential circuits were proposed in <ref> [48] </ref> and [54]. Dynamic hazards were identified in the context of the signal ordering relations, and were removed by reducing some product terms. Although these methods have been applied successfully to many examples, the reduction is not always possible and may require reducing the concurrency in the specification. <p> The decomposition technique of Bredeson fails to remove this dynamic hazard because there exists only one total stable set 8 (as defined in [8]). Also, the reduction technique of <ref> [48] </ref> 8 During the total stable set computation, we assumed that all the don't-care vertices belong to the off-set since the method of [8] assumes a fully specified function with no don't-care set. CHAPTER 2. <p> Although this case is theoretically possible, we have not seen it in practice, and we conjecture that this case never happens for STGs without choice behavior (marked graphs), and very rarely for general free-choice STGs. If this case does occur, then we can resort to cube reduction <ref> [48] </ref> or concurrency reduction. <p> Note that the dynamic hazard occurs even if the logic is implemented with an SR latch with S = a d and CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 46 R = a d. In this case, the S and R functions are also orthogonal. In <ref> [48] </ref>, the 0-hazard (and thus the dynamic hazard) was removed by adding literal c to a d because c remains at 0 while a and d fire. <p> The Hazard column was obtained by running ESPRESSO with single output option (no logic sharing), which produces prime and irredundant but not necessarily hazard-free implementations. The Hazard-free column was obtained by applying the static hazard removal method of section 2.4 and the cube reduction method of <ref> [48] </ref>. This synthesis method produces implementations which have, on the average, 3.4 % more product terms and 5.2 % more literals than ESPRESSO. The cube reduction method removed all dynamic hazards from all of the examples except varshavsky. This is the same example illustrated in Fig. 2.12. <p> Valid literals provide the means to guarantee the hazard-freedom of the resulting multi-level CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 50 implementation. We were able to remove all dynamic hazards from the circuits where the cube reduction of <ref> [48] </ref> failed. Extending this factoring method to produce general multi-level implementations from STGs could be an interesting avenue for future research. <p> STG input and output signals) change. Furthermore every FSM stable state is represented by a stable circuit state, if we use any of the synthesis methodologies presented in [18], [38] or <ref> [48] </ref>. This is due to the fact that if the synthesized circuit implements the STG specification, then after all the enabled transitions fire, they cannot be enabled again until some external signal changes. <p> We have not come up with the syntactic conditions under which all dynamic hazards can be removed. If the factoring method fails to remove some dynamic hazards, then the cube reduction of <ref> [48] </ref> can be used. However, factoring is the preferred method in general since cube reduction may decrease testability. Extending this factoring method to produce general multi-level implementations from STGs is an interesting area of future research.
Reference: [49] <author> Cho W. Moon, Paul R. Stephan, and Robert K. Brayton. </author> <title> "Specification, Synthesis and Verification of Hazard-free Asynchronous Circuits". </title> <journal> Journal of VLSI Signal Processing, </journal> <note> 1993. Kluwer Press (To Appear). </note>
Reference-contexts: The new state codes enable us to insert appropriate signal transitions into the STG to satisfy the CSC property. Although the synthesis CHAPTER 4. SOLVING THE STATE ASSIGNMENT PROBLEM 88 methods of chapter 2 can be applied at the state graph level <ref> [49] </ref> without inserting the additional signal transitions into the STG, we augment the original STG * to provide feedback to the designer on what kind of transformation was made to the original design, and * to retain the graph-theoretic advantages of STGs (this is useful for design documenta tion purposes).
Reference: [50] <author> J. Craig Mudge. </author> <title> "An Illustration of Micropipelines Using Two-Dimensional Fourier Transform Architectures". </title> <booktitle> In VLSI '89, </booktitle> <pages> pages 359 - 368, </pages> <month> August </month> <year> 1989. </year>
Reference: [51] <author> Tadao Murata. </author> <title> "Petri Nets: Properties, Analysis and Applications". </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(4):541 - 580, </volume> <month> April </month> <year> 1989. </year>
Reference-contexts: An enabled transition must eventually fire. After a transition fires, a token is removed from each of its fanin places and a token is added to each of its fanout places, thereby defining a new marking. A good review of other basic Petri net concepts is given in <ref> [51] </ref>. CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 13 Although Petri nets are very expressive (even more so than finite state machines [56]), they are difficult to analyze in general [51]. Thus, many Petri net subsets have been proposed to gain some analytical power at the expense of losing some expressive power. <p> A good review of other basic Petri net concepts is given in <ref> [51] </ref>. CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 13 Although Petri nets are very expressive (even more so than finite state machines [56]), they are difficult to analyze in general [51]. Thus, many Petri net subsets have been proposed to gain some analytical power at the expense of losing some expressive power. Some useful Petri net subsets include marked graphs, state machines and free-choice nets. <p> CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 16 Definition 2.2.9 An STG is live 2 if 1. the underlying net is safe, and 2. every transition can be enabled through some firing sequence from every reachable marking <ref> [51] </ref>, and 3. the rising and falling transitions of each signal strictly alternate (this is called "switch over correct" in [69]). A sufficient condition for STG liveness is that all of its SM components 3 are initially marked with exactly one token.
Reference: [52] <author> S. M. Nowick and D. L. Dill. </author> <title> "Practicality of State-Machine Verification of Speed-independent Circuits". </title> <booktitle> In Proc. Int'l. Conf. Computer-Aided Design, </booktitle> <pages> pages 266 - 269, </pages> <year> 1989. </year>
Reference-contexts: Since M k M M has no failure states, M conforms to M , as expected. To facilitate the verification of asynchronous circuits from event-based specifications, a petri net front end to the Dill's verifier has been added by Nowick <ref> [52] </ref>. A petri net specification is transformed to DFA by using its reachability graph (or a state graph in the case of STGs).
Reference: [53] <author> S. M. Nowick and D. L. Dill. </author> <title> "Automatic Synthesis of Locally-Clocked Asynchronous State Machines". </title> <booktitle> In Proc. Int'l. Conf. Computer-Aided Design, </booktitle> <pages> pages 318 - 321, </pages> <year> 1991. </year> <note> BIBLIOGRAPHY 133 </note>
Reference-contexts: Recently, there have been attempts to extend the FSM specification to express concurrency more explicitly. One such form of specification is called the burst mode FSM <ref> [53] </ref>. The granularity of the expressed concurrency, however, is rather coarse, so it is not be suitable for specifying arbitrary concurrency and environmental interaction.
Reference: [54] <author> S. M. Nowick and D. L. Dill. </author> <title> "Exact Two-Level Minimization of Hazard-Free Logic with Multiple-Input Changes". </title> <booktitle> In Proc. Int'l. Conf. Computer-Aided Design, </booktitle> <year> 1992. </year>
Reference-contexts: Fig. 2.3 illustrates how a logic function is derived from a state graph. The shaded states in the SG become off-set vertices with respect to output c, and are represented by dark circles on the three-dimensional Boolean cube. 4 This notation for the transition cube is from <ref> [54] </ref>. The transition cube [A; B] is simply the smallest cube containing both A and B. CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 19 2.2.5 Hazards A hazard is a possible deviation of the output from the specified behavior. There are two basic categories: combinational and sequential hazards. <p> As a result, many combinational circuits were not decomposable. Methods which exploit the signal ordering relations and are applicable to both combinational and sequential circuits were proposed in [48] and <ref> [54] </ref>. Dynamic hazards were identified in the context of the signal ordering relations, and were removed by reducing some product terms. Although these methods have been applied successfully to many examples, the reduction is not always possible and may require reducing the concurrency in the specification.
Reference: [55] <author> M. C. Paull and S. H. Unger. </author> <title> Minimizing the Number of States in Incompletely Specified Sequential Circuits. </title> <journal> In IRE Transactions on Electronic Computers, </journal> <volume> volume EC-8, </volume> <pages> pages 356-357, </pages> <month> September </month> <year> 1959. </year>
Reference-contexts: Thus, there is no race and hence no critical race. Theorem 2.3.4 If an STG G is well-formed, then the SOP implementation produced from G is free of 0-hazards. Proof In <ref> [55] </ref> (Lemma 4.1, page 123) Unger proved that all SOP implementations are free of 0-hazards if no product term contains both the complemented and uncomplemented literals of the same variable. <p> However, factoring is the preferred method in general since cube reduction may decrease testability. Extending this factoring method to produce general multi-level implementations from STGs is an interesting area of future research. While most multi-level decomposition techniques <ref> [55] </ref> [36] are hazard-non-increasing, our factoring method is actually hazard-decreasing. We have also addressed the problem of verifying the correctness of gate-level imple CHAPTER 5. CONCLUSIONS AND FUTURE WORK 127 mentations relative to STG specifications. This verification method is fully automatic and covers all variations of implementations from specifications.
Reference: [56] <author> James L. Peterson. </author> <title> "Petri Net Theory and the Modeling of Systems". </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: A good review of other basic Petri net concepts is given in [51]. CHAPTER 2. HAZARD-FREE LOGIC SYNTHESIS 13 Although Petri nets are very expressive (even more so than finite state machines <ref> [56] </ref>), they are difficult to analyze in general [51]. Thus, many Petri net subsets have been proposed to gain some analytical power at the expense of losing some expressive power. Some useful Petri net subsets include marked graphs, state machines and free-choice nets. <p> Input signal transitions are underlined. The analytical power of the STG comes from the Petri net. In many asynchronous interface circuits, it is important to ensure that the circuit has no deadlocks. An example of a deadlock is a system in which two processes share two resources <ref> [56] </ref>. If each process has one resource and waits for the other process to release the other resource, then each process waits forever without ever getting both resources.
Reference: [57] <author> Irith Pomeranz and Kwang-Ting Cheng. </author> <title> "State Assignment Using Input/Output Functions". </title> <booktitle> In Proc. Design Automation Conf., </booktitle> <pages> pages 573 - 577, </pages> <year> 1992. </year>
Reference-contexts: A simple timing diagram is shown in Fig. 1.1. 1 Recently, the total state concept has also been applied to synchronous FSMs. Pomeranz and Cheng proposed using inputs and outputs as state variables for the synthesis of synchronous FSMs and reported some decrease in area and increase in testability <ref> [57] </ref>. For synchronous FSMs, however, whenever an input and or an output is used as a state variable, there is an overhead of an additional latch or flip-flop associated with each input or output used as state variable. This overhead becomes zero for asynchronous circuits. CHAPTER 1.
Reference: [58] <author> R. Rudell. </author> <title> Logic Synthesis for VLSI Design. </title> <editor> In U. C. </editor> <address> Berkeley, </address> <note> ERL Memo 89/49, </note> <month> April </month> <year> 1989. </year>
Reference-contexts: This problem can be formulated as a minimum cover problem <ref> [58] </ref> of some binary matrix A, where the rows are the cubes in F 0 and the columns the primes in F . No polynomial time algorithms which solve the minimum cover problem exactly are known [58], but efficient heuristics (such as the one suggested by Gimpel [24]) exist, and can <p> This problem can be formulated as a minimum cover problem <ref> [58] </ref> of some binary matrix A, where the rows are the cubes in F 0 and the columns the primes in F . No polynomial time algorithms which solve the minimum cover problem exactly are known [58], but efficient heuristics (such as the one suggested by Gimpel [24]) exist, and can be used to solve the minimum cover problem. This procedure has not been implemented. Fig. 2.11 shows the application of the algorithm of Fig. 2.10.
Reference: [59] <author> A. Saldanha, T. Villa, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> A framework for satisfying input and output encoding constraints. </title> <booktitle> In Proceedings of the 28 th Design Automation Conference, </booktitle> <pages> pages 170-175, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: To obtain a minimum 9 length encoding, we use the exact constraint solver by Saldanha et. al. <ref> [59] </ref> which generates all the prime dichotomies and then finds a minimum cover of the initial dichotomies by the prime dichotomies. The complexity of satisfying the dichotomy constraints by the above technique is 0 (2 n ), where n is the number of states.
Reference: [60] <author> Charles L. Seitz. </author> <title> "System Timing". In C.A. Mead and L.A. Conway, editors, Introduction to VLSI Systems, chapter 7. </title> <publisher> Addison-Wesley, </publisher> <year> 1980. </year>
Reference-contexts: Pipelining improves the hardware utilization but not the latency. Asynchronous circuits can be designed such that each element operates without idling for the slowest element. Such circuits are called self-timed <ref> [60] </ref>, and self-timed circuits can operate at data-dependent speeds. In addition, the performance of asynchronous circuits can potentially improve because the latency is not determined by the slowest element. <p> Thus, the following latches can be used to implement the feedback loop: * SM latch : Q = S + M Q [3] * SR latch : Q = S + RQ, where R = M . * C-element : Q = AB + (A + B)Q <ref> [60] </ref> where S = AB and M = A + B. As a result of theorems 2.3.2, 2.3.3 and 2.3.4, an SOP implementation derived from a well-formed STG can only have logic 1-hazards or logic dynamic hazards.
Reference: [61] <author> James H. Tracey. </author> <title> "Internal State Assignments for Asynchronous Sequential Machines". </title> <journal> IEEE Tran. Electronic Computers, </journal> <volume> EC-15(4):551 - 560, </volume> <month> August </month> <year> 1966. </year>
Reference-contexts: This proposed framework is general enough to embed also previous methods to solve the CSC problem for some specific sub-classes of STGs, such as [67]. Using the minimized STG, we apply a critical race-free state assignment algorithm (such as the one proposed by Tracey <ref> [61] </ref>). The new state codes enable us to insert appropriate signal transitions into the STG to satisfy the CSC property. Although the synthesis CHAPTER 4. <p> This step must not introduce any critical races and should allow state signals to change as soon as possible. We employ Tracey's single transition time (STT) state assignment technique <ref> [61] </ref> because it satisfies both of these criteria. Tracey's technique is based on a set of dichotomy constraints extracted from the FSM.
Reference: [62] <author> S. H. Unger. </author> <title> Asynchronous Sequential Switching Circuits. </title> <publisher> Wiley Interscience, </publisher> <year> 1969. </year>
Reference-contexts: Finite State Machine Most of the following definitions are from <ref> [62] </ref>. CHAPTER 4. <p> A graphical representation of an FSM is given in Fig. 4.3 (b). The tabular form representation of this FSM is called a Flow Table <ref> [62] </ref>. A flow table corresponding to the FSM of Fig. 4.3 (b) is shown in Table 4.1. The stable state entries are boxed. Definition 4.2.2 A state s of an FSM is stable under input state i if N (i; s) = fsg: i.e., a self-loop in the graphical representation. <p> where: * every leaf node is labeled with either the value 1 or 0. * every non-leaf node is labeled with a multi-valued Boolean variable. * every edge is labeled with one value of the variable corresponding to its source node. 2 The encoded FSM is called Flow Matrix in <ref> [62] </ref>. CHAPTER 4. SOLVING THE STATE ASSIGNMENT PROBLEM 93 An MDD represents a Boolean function over the variables associated with the MDD labels in the following way. <p> The procedures that we will give below are guaranteed to find a solution, if such exists within the search space, that does not constrain the environment. The following result (Theorem 5.2 of <ref> [62] </ref>) shows that using this framework we obtain a lower bound on the number of new state signals required : Theorem 4.5.1 Given any minimized FSM with s i stable states under input label i, any sequential circuit realizing this FSM, in which stable FSM states are represented by stable circuit
Reference: [63] <author> Stephen H. Unger. </author> <title> "Asynchronous Sequential Switching Circuits". </title> <publisher> Wiley-Interscience, </publisher> <year> 1969. </year>
Reference-contexts: The equivalent form of specification for asynchronous circuits is called the flow table. A circuit is synthesized from a flow table in much the same way that a synchronous circuit is synthesized from a CHAPTER 1. INTRODUCTION 5 state transition table <ref> [63] </ref>: the states are first minimized, encoded and then the resulting logic is optimized. However, the optimization techniques at each phase of synthesis are more constrained. <p> If this state variable change is seen before the input change x at gate B, the state variable y 1 makes a rising transition and brings the circuit to an incorrect final state 4. Essential hazards can be removed by adding feedback delays <ref> [63] </ref> or by using special factoring techniques [1]. All combinational hazards, critical races and essential hazards should be avoided because they can cause a circuit to malfunction.
Reference: [64] <author> P. Vanbekbergen. </author> <title> "A Matrix Equation and a Timing Analysis Algorithm for Signal Transition Graphs". </title> <type> Technical Report Report ESPRIT 2260, </type> <institution> IMEC, </institution> <year> 1990. </year>
Reference-contexts: Transitions belonging to output signals whose input signals change prematurely were called non-persistent, and were thought to be hazard-prone. However, it has been shown in [39] that non-persistent transitions do not necessarily lead to hazards. In addition, it has been shown in <ref> [64] </ref> that STG persistency is not a sufficient condition for the CSC property. Thus, STG persistency is neither necessary nor sufficient for speed-independence.
Reference: [65] <author> P. Vanbekbergen, F. Catthoor, G. Goossens, and H. De Man. </author> <title> "Optimized Synthesis of Asynchronous Control Circuits from Graph-theoretic Specifications". </title> <booktitle> In Proc. Int'l. Conf. Computer-Aided Design, </booktitle> <pages> pages 184 - 187, </pages> <year> 1990. </year> <note> BIBLIOGRAPHY 134 </note>
Reference-contexts: The design of asynchronous circuits, however, have been thought to be difficult, and the main application of asynchronous circuits has been limited to interface circuits (or interface transducers [5]). Recently there has been a surge of interest on asynchronous circuits [18] [43] [46] <ref> [65] </ref> [39] due to numerous problems which arise from the design of high-speed synchronous circuits. This chapter reviews the problems with high-speed synchronous circuits and gives motivation for using asynchronous circuits. <p> The initial token marking and the corresponding state are shaded. The binary codes are shown inside each state. The order of variables used in the state encoding is a b c. Definition 2.2.10 A state graph is said to satisfy a unique state coding (USC) property <ref> [65] </ref> if no two different states are assigned the same binary code. 2 This definition comes from p. 36 and p. 84 in [18], and is different from the definition of liveness used in Petri net literature. 3 The SM component SM i of a Petri net P refers to a <p> Conversely every path from the root to the 1 leaf defines a (possibly partial) assignment of values (cube) that makes the associated function evaluate to 1 (and similarly for 0). 4.2.2 Previous work Early work in the area of unique state coding (USC, definition 2.2.10) enforcement (for example [71] and <ref> [65] </ref>) concentrated on the introduction of constraints within MG, using a sufficient condition as guidance. Namely both [71] and [65] recognized that if all pairs of signals in the STG are locked using a chain of handshaking pairs, then the MG satisfies the USC condition. <p> makes the associated function evaluate to 1 (and similarly for 0). 4.2.2 Previous work Early work in the area of unique state coding (USC, definition 2.2.10) enforcement (for example [71] and <ref> [65] </ref>) concentrated on the introduction of constraints within MG, using a sufficient condition as guidance. Namely both [71] and [65] recognized that if all pairs of signals in the STG are locked using a chain of handshaking pairs, then the MG satisfies the USC condition. <p> However, the analysis and synthesis methods for MGs often have polynomial worst-case behavior, while analogous algorithms for free-choice nets have in general exponential worst-case behavior. For example, the CSC analysis in [71] and <ref> [65] </ref> is O (n 3 ) in the worst case for n signals, while the algorithms presented in this chapter work on the SG, which, in the worst case, is exponential in the number of signals. 4.3 Overview of the proposed approach In our approach we first check the given STG <p> Furthermore, we can also reduce the number of state signals below the given bound if we are allowed to declare some state invalid , because then we are modifying the FSM before realization. For example, the method described in <ref> [65] </ref> adds constraints to the STG to remove from the FSM states that can cause incompatibilities, so that the resulting FSM has only one compatible and, by Theorem 4.4.1, the STG has CSC. However, this is not general and cannot always be done without adding state signals. <p> For this reason, approaches which solve CSC by adding constraints to the STG, such as <ref> [65] </ref>, are unlikely to be extendable to free-choice STGs. 12 Note that this restriction is due to the algorithm used to enforce CSC, and it is not inherent in the proposed framework. CHAPTER 4.
Reference: [66] <author> P. Vanbekbergen, F. Catthoor, J.V. Meerbergen, and H. De Man. </author> <title> "Race-free Time-optimised Synthesis of Asynchronous Interface Circuits". </title> <booktitle> In Proc. Int'l. Workshop on Logic Synthesis, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: The use of STGs as specification for formal verification will be discussed in chapter 3. The early work on STGs focused on analysis techniques at the specification level to satisfy some syntactic constraints [18] [46] <ref> [66] </ref> and relied on some particular types of latches to remove hazards [66] [5]. Unfortunately, such approaches do not produce implementations CHAPTER 1. INTRODUCTION 10 which are hazard-free under gate delay variations caused by operating conditions or process variations. <p> The use of STGs as specification for formal verification will be discussed in chapter 3. The early work on STGs focused on analysis techniques at the specification level to satisfy some syntactic constraints [18] [46] <ref> [66] </ref> and relied on some particular types of latches to remove hazards [66] [5]. Unfortunately, such approaches do not produce implementations CHAPTER 1. INTRODUCTION 10 which are hazard-free under gate delay variations caused by operating conditions or process variations. <p> Since the set-reset (SR) latches implemented with cross-coupled NOR gates are immune to 1-hazards, some methods rely on SR latches to remove 1-hazards [5] <ref> [66] </ref>. Fig. 2.8 shows the basic structure of the two-level implementation using SR latches. The asterisk after S indicates that the SR latch is set-dominant :i.e., when both S and R inputs are 1, the output is determined by the S input.
Reference: [67] <author> P. Vanbekbergen, G. Goossens, and H. De Man. </author> <title> A local optimization technique for asynchronous control circuits. </title> <booktitle> In Proceedings of the International Workshop on Logic Synthesis, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Minimization of this FSM allows us to prove necessary conditions on the number of state signals required to satisfy the CSC property. This proposed framework is general enough to embed also previous methods to solve the CSC problem for some specific sub-classes of STGs, such as <ref> [67] </ref>. Using the minimized STG, we apply a critical race-free state assignment algorithm (such as the one proposed by Tracey [61]). The new state codes enable us to insert appropriate signal transitions into the STG to satisfy the CSC property. Although the synthesis CHAPTER 4. <p> In fact, graph coloring is a classical heuristic used for FSM minimization ([70]). However, Vanbekbergen did not recognize the need to use critical race-free encoding. Critical races would show up as further violations of CSC in the encoded STG. Thus the main advantage of our framework over <ref> [67] </ref> is the recognition that CSC falls within a much more general 3 The author also adds constraints to allow optimization of the combinational logic implementing some particular signal, but this has no direct relevance to the CSC problem per se. CHAPTER 4. <p> Example "master-read" took a relatively long time to complete due to the fact that most states were assigned to all the compatibles by the initial FSM minimization procedure, and then procedure 4.5.2 was slow to converge. Table 4.3 contains some results of <ref> [67] </ref>, for comparison. Our procedure obtains larger circuits than Vanbekbergen for vbe4a because we use state signals to remove CSC violation but preserve the concurrency of the specification as much as possible, while Van-bekbergen does not add state variables but reduces the concurrency. The example vbe4a CHAPTER 4. <p> The example vbe4a CHAPTER 4. SOLVING THE STATE ASSIGNMENT PROBLEM 123 was solved in <ref> [67] </ref> by removing those states that can cause incompatibilities, without requiring the addition of state signals. Presently we do not attempt to remove any state and always add state signals, which accounts for the large area penalty in the case of vbe4a. Applying the state removal technique of [67] to vbe4a <p> solved in <ref> [67] </ref> by removing those states that can cause incompatibilities, without requiring the addition of state signals. Presently we do not attempt to remove any state and always add state signals, which accounts for the large area penalty in the case of vbe4a. Applying the state removal technique of [67] to vbe4a within our framework by hand (without too much attention to optimality) led to a result that did not require any state signal and had 13 literals but more concurrency than [67]. <p> Applying the state removal technique of <ref> [67] </ref> to vbe4a within our framework by hand (without too much attention to optimality) led to a result that did not require any state signal and had 13 literals but more concurrency than [67]. <p> This allowed us to prove a lower bound on the number of state signals to be added in order to implement the STG specification without substantially reducing its concurrency. We are investigating ways to view the technique in <ref> [67] </ref> in this framework, because we believe our method to be powerful enough to view the CSC problem in its generality. So CHAPTER 4. <p> 6 4 4 8 2 8 3.8 master-read 14 28 132 17 36 5 77 1635.1 vbe4a 6 12 34 8 16 4 22 10.1 Table 4.2: Results of the proposed approach name initial final sig. trans. sig. trans. lit. vbe4a 6 12 6 12 5 Table 4.3: Results of <ref> [67] </ref> (for comparison) we will be able to fully exploit the trade-off between reduction in concurrency and insertion of new signals.
Reference: [68] <author> P. Vanbekbergen, B. Lin, G. Goossens, and H. De Man. </author> <title> "A Generalized State Assignment Theory for Transformations on Signal Transition Graphs". </title> <booktitle> In Proc. Int'l. Conf. Computer-Aided Design, </booktitle> <year> 1992. </year>
Reference-contexts: Factoring entails inserting in the given STG an internal signal, which represents the function of the quotient resulting from the factoring operation. For invalid literals, no such signals can be defined (this is the same problem as that described in Theorem 3.5 of <ref> [68] </ref>). The algorithm to remove dynamic hazards is given in Fig. 2.16.
Reference: [69] <editor> Victor I. Varshavsky, editor. </editor> <booktitle> Self-Timed Control of Concurrent Processes, </booktitle> <volume> volume 52. </volume> <publisher> Kluwer Academic Publishers, </publisher> <year> 1990. </year> <note> (Russian Edition Published in 1986). </note>
Reference-contexts: The state graph can be used to view the global state space. This algorithmic method was used by Chu using the signal transition graph specification (STG) and also by Varshavsky et al. using a similar graphical specification called the change diagram (CD) <ref> [69] </ref>. CD can specify concurrency but not choice behavior 2 , whereas STG can specify both. The STG specification corresponding to the timing diagram of Fig 1.1 is shown in Fig. 1.4. <p> 16 Definition 2.2.9 An STG is live 2 if 1. the underlying net is safe, and 2. every transition can be enabled through some firing sequence from every reachable marking [51], and 3. the rising and falling transitions of each signal strictly alternate (this is called "switch over correct" in <ref> [69] </ref>). A sufficient condition for STG liveness is that all of its SM components 3 are initially marked with exactly one token. With this condition, the specification of the initial marking becomes optional. 2.2.2 State Graph The state graph (SG) is a finite automaton obtained by "executing" the STG. <p> Thus, each literal in any product term switches at most once. Consequently, if a product terms switches more than once, then it must have one literal turning on and the other turning off, a 0-hazard. An example <ref> [69] </ref> of a dynamic hazard under a 0 ) 1 transition is shown in Fig. 2.12. A dynamic hazard of the form 0 ) 1 ) 0 ) 1 exists at the output z 1 .
Reference: [70] <author> T. Villa. </author> <title> A heuristic incompletely specified finite state machine minimizer. </title> <type> Personal communication, </type> <year> 1985. </year>
Reference: [71] <author> A. V. Yakovlev and A. Petrov. </author> <title> Petri nets and parallel bus controller design. </title> <booktitle> In International Conference on Application and Theory of Petri Nets, </booktitle> <address> Paris, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Conversely every path from the root to the 1 leaf defines a (possibly partial) assignment of values (cube) that makes the associated function evaluate to 1 (and similarly for 0). 4.2.2 Previous work Early work in the area of unique state coding (USC, definition 2.2.10) enforcement (for example <ref> [71] </ref> and [65]) concentrated on the introduction of constraints within MG, using a sufficient condition as guidance. Namely both [71] and [65] recognized that if all pairs of signals in the STG are locked using a chain of handshaking pairs, then the MG satisfies the USC condition. <p> (cube) that makes the associated function evaluate to 1 (and similarly for 0). 4.2.2 Previous work Early work in the area of unique state coding (USC, definition 2.2.10) enforcement (for example <ref> [71] </ref> and [65]) concentrated on the introduction of constraints within MG, using a sufficient condition as guidance. Namely both [71] and [65] recognized that if all pairs of signals in the STG are locked using a chain of handshaking pairs, then the MG satisfies the USC condition. <p> However, the analysis and synthesis methods for MGs often have polynomial worst-case behavior, while analogous algorithms for free-choice nets have in general exponential worst-case behavior. For example, the CSC analysis in <ref> [71] </ref> and [65] is O (n 3 ) in the worst case for n signals, while the algorithms presented in this chapter work on the SG, which, in the worst case, is exponential in the number of signals. 4.3 Overview of the proposed approach In our approach we first check the
References-found: 71

