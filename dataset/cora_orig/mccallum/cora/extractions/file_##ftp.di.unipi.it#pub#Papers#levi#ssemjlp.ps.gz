URL: file://ftp.di.unipi.it/pub/Papers/levi/ssemjlp.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: The s-semantics approach: theory and applications  
Author: Annalisa Bossi Maurizio Gabbrielli Giorgio Levi Maurizio Martelli 
Abstract: The paper is a general overview of an approach to the semantics of logic programs whose aim is finding notions of models which really capture the operational semantics, and are therefore useful for defining program equivalences and for semantics-based program analysis. The approach leads to the introduction of extended interpretations which are more expressive than Herbrand interpretations. The semantics in terms of extended interpretations can be obtained as a result of both an operational (top-down) and a fixpoint (bottom-up) construction. It can also be characterized from the model-theoretic viewpoint, by defining a set of extended models which contains standard Herbrand models. We discuss the original construction modeling computed answer substitutions, its compositional version and various semantics modeling more concrete observables. We then show how the approach can be applied to several extensions of positive logic programs. We finally consider some applications, mainly in the area of semantics-based program transformation and analysis.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Alpuente and M. Falaschi. </author> <title> Narrowing as an Incremental Constraint Satisfaction Algorithm. </title> <editor> In J. Maluszynski and M. Wirsing, editors, </editor> <booktitle> Proc. of PLILP'91, volume 528 of Lecture Notes in Computer Science, </booktitle> <pages> pages 111-122. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year> <note> Extended version to appear in Theoretical Computer Science. </note>
Reference-contexts: The s-semantics of CLP and its compositional version have been applied to obtain the semantics of two new instances of the CLP scheme, namely CLP (H=E ) and CLP (AD). CLP (H=E) <ref> [1, 2] </ref> is a logic + equational language, where constraints are equations to be solved in an equational theory and the constraint solver is a narrowing algorithm. CLP (AD) [15] models a deductive database language with updates.
Reference: [2] <author> M. Alpuente, M. Falaschi, M. Gabbrielli, and G. Levi. </author> <title> The semantics of equational logic programming as an instance of CLP. </title> <editor> In K. R. Apt, J. W. de Bakker, and J. J. M. M. Rutten, editors, </editor> <booktitle> Logic Programming Languages: Constraints, Functions and Objects, </booktitle> <pages> pages 49-81. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: The s-semantics of CLP and its compositional version have been applied to obtain the semantics of two new instances of the CLP scheme, namely CLP (H=E ) and CLP (AD). CLP (H=E) <ref> [1, 2] </ref> is a logic + equational language, where constraints are equations to be solved in an equational theory and the constraint solver is a narrowing algorithm. CLP (AD) [15] models a deductive database language with updates.
Reference: [3] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Finally, section 7 shows some applications of the approach, in the areas of program transformation, semantics-based analysis and metaprogramming. 1.6 Preliminaries The reader is assumed to be familiar with the terminology of and the basic results in the semantics of logic programs <ref> [88, 3] </ref>. Let L be the first order language defined by the signature S consisting of a set C of data constructors, a finite set P of predicate symbols, a denumerable set V of variable symbols. <p> We show our construction in a language independent way by considering three separate steps, which roughly correspond to the three standard semantics of logic programs <ref> [109, 88, 3] </ref>. The first step is related to the operational semantics and leads to the definition of the structure of -interpretations. The second step is concerned with the fixpoint semantics. <p> D 1 ; : : : ; D m ; P fl ;R B 1 ; : : : ; B n ; c = p ( ~ X)fl# : B 1 ; : : : ; B n g Note that O (P ) is a set of resultants <ref> [89, 3] </ref> obtained from goals of the form p ( ~ X) in P and is strongly related to partial evaluation [78] 2 . The set of clauses Id in the previous definition is used to delay the evaluation of open atoms. <p> The resultants, introduced in [89] in the framework of partial evaluation, are a compact representation of the relation between the initial goal and the current hgoal; mgui pair. They are useful (see <ref> [3] </ref>) to formalize the properties of SLD-resolution.
Reference: [4] <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: The first attempt to extend the s-semantics to negation is described in [108]. It is a bottom-up semantics for stratified normal programs which generalizes to the non-ground case the construction of <ref> [4] </ref>. The resulting denotation has several similarities with the s-semantics, namely the fixpoint characterization and the use of sets of clauses (with constraints) as -interpretations.
Reference: [5] <author> K. R. Apt and M. Gabbrielli. </author> <title> Declarative Interpretations Reconsidered. </title> <publisher> CWI, </publisher> <address> Amsterdam. </address> <note> Submitted for publication, </note> <year> 1993. </year>
Reference-contexts: The success set semantics does not need to be the same as the s-semantics in order to be correct with respect to computed answers, rather it needs to be isomorphic. The class of programs for which this property holds has been studied in <ref> [5] </ref>. Another related useful property of the s-semantics is its independence from the language. This means that the denotation defined by O is not affected by the choice of the language signature. The language signature affects the domain of -interpretations B.
Reference: [6] <author> K. R. Apt, E. Marchiori, and C. Palamidessi. </author> <title> A theory of first-order built-in's of PROLOG. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 69-83. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Other extensions of the s-semantics approach which are not related to the frontiers semantics defined in section 5.3 are presented in <ref> [6, 10] </ref>. In [10] a compilative approach to model Prolog control is defined. Instead of collecting information concerning the control of the program in the semantics, the program itself is enhanced so that its standard meaning reflects the required control. <p> A logic program P is transformed into a program P t defined on a constraint language which contains ask-tell constrained clauses. Ask constraints are interpreted by an associated termination theory which captures the control of a Prolog program. In <ref> [6] </ref> various Prolog built-in's that include arithmetic operations and met-alogical relations like var and ground are considered. Only the Prolog leftmost selection rule is taken into account. <p> Suitable notions of truth and model are defined on these interpretations and the existence of a least model is shown. The primitive 37 predicates considered in <ref> [6] </ref> are called first-order built-in's to distinguish them from those built-in's which refer to clauses and goals like call.
Reference: [7] <author> C. Aravindan and Phan Minh Dung. </author> <title> On the correctness of unfold/fold transformation of normal and extended logic programs. </title> <type> Technical report, </type> <institution> Asian Institute of Technology, Bangkok, Thailand, </institution> <year> 1993. </year>
Reference-contexts: The proof can in fact be based on general theorems (such as AN D-compositionality) and on powerful technical tools such as the specialized immediate consequences operators. This is the approach taken in [19] and <ref> [7] </ref>, where the reference semantics are the answer substitution semantics and the semantic kernel respectively. In [19] some transformation operations which are basic for all the transformation techniques for logic programs, such as partial evaluation, program specialization, program synthesis and optimization, are considered. <p> Semantic delay is not properly a property of the s-semantics, rather it depends on its fixpoint construction. Turning to normal logic programs, <ref> [7] </ref> gives a very elegant proof of the correctness of unfold/fold w.r.t. several non-monotonic semantics (as, for example, the stable model and the well-founded model semantics), by showing that it preserves the semantic kernel considered in section 6.3. 7.2 Program analysis In the area of program analysis, the s-semantics has been
Reference: [8] <author> R. Bagnara, R. Giacobazzi, and G. Levi. </author> <title> An Application of Constraint Propagation to Data-flow Analysis. </title> <booktitle> In Proc of Ninth IEEE Conference on AI Applications, </booktitle> <pages> pages 270-276. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: A similar result, in a framework based on the generalization of the top-down operational semantics, is described in [34]. The ability to use the CLP interpreter to analyze CLP programs has been exploited in some interesting applications <ref> [8] </ref>. 7.3 Declarative debugging The application of the s-semantics approach to semantics-based (declarative) debugging [16] has the following features when compared to the existing methods [103, 49, 87]. * The s-semantics, when taken as specification of the intended semantics, allows us to obtain a more accurate diagnosis than the one that
Reference: [9] <author> I. Balbin and K. Ramamohanarao. </author> <title> A Generalization of the Differential Approach to Recursive Query Evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 259-262, </pages> <year> 1987. </year>
Reference-contexts: Such an extension was needed to investigate properties which make possible improvements in the performance of the bottom-up fixpoint evaluation. Algorithms such as the Seminaive evaluation <ref> [9] </ref> try to avoid repeating inferences by comparing the new facts computed at each iteration with previously generated facts to eliminate duplicates. To study properties of these algorithms and their specializations for certain classes of programs, it is then necessary to consider duplicates, and hence multisets of atoms.
Reference: [10] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modelling Prolog Control. </title> <journal> Journal of Logic and Computation, </journal> <volume> 3, </volume> <year> 1993. </year> <month> 50 </month>
Reference-contexts: Other extensions of the s-semantics approach which are not related to the frontiers semantics defined in section 5.3 are presented in <ref> [6, 10] </ref>. In [10] a compilative approach to model Prolog control is defined. Instead of collecting information concerning the control of the program in the semantics, the program itself is enhanced so that its standard meaning reflects the required control. <p> Other extensions of the s-semantics approach which are not related to the frontiers semantics defined in section 5.3 are presented in [6, 10]. In <ref> [10] </ref> a compilative approach to model Prolog control is defined. Instead of collecting information concerning the control of the program in the semantics, the program itself is enhanced so that its standard meaning reflects the required control.
Reference: [11] <author> R. Barbuti, M. Codish, R. Giacobazzi, and M. Maher. </author> <title> Oracle Semantics for PROLOG. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-114. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: equivalent top-down and bottom-up semantics can be derived as abstractions of O R R , including * the resultants semantics defined (for any local rule R) in [61, 59], where we don't care about the sequences of clauses, * the resultants semantics with depth defined (for the leftmost rule) in <ref> [11] </ref>, where a sequence of clauses is abstracted by its length, * the partial answers semantics O PA R defined (for any local rule R) in [61, 59], where we only keep the heads of the resultants by labeling as partial those heads that were heads of a non-unit resultant, * <p> This information is very important for the semantics of PROLOG <ref> [11, 17] </ref> and of all-solutions metapredicates [40]. * A goal G finitely fails iff there exist a finite number of frontiers for G, all the atoms in the frontiers of G are labeled as partial. This information is useful to get a bottom-up characterization of SLDNF resolution [95]. <p> The semantics defined according to the the s-semantics approach is instead a syntactic object, which encodes information on the observable, collected in a goal independent way. Another semantics which can be viewed as an abstraction of O R (P ) is presented in <ref> [11] </ref>. The sequence of clauses is abstracted by its length, while the solution to the control problem of Prolog is solved by resorting to a notion of oracle, which defines, at each computation step, the set of clauses applicable to rewrite the current resolvent. <p> The logical reading of a program results thus unaffected. The program's semantics is defined parametrically on the oracle. This gives to the approach a quite general flavour. The semantics in <ref> [11] </ref> has only a top-down definition. However, a more recent version of [11] contains two equivalent (top-down and bottom-up) semantics much in the style of O R R (P ) and more similar to the semantics in [17]. <p> The logical reading of a program results thus unaffected. The program's semantics is defined parametrically on the oracle. This gives to the approach a quite general flavour. The semantics in <ref> [11] </ref> has only a top-down definition. However, a more recent version of [11] contains two equivalent (top-down and bottom-up) semantics much in the style of O R R (P ) and more similar to the semantics in [17]. Other extensions of the s-semantics approach which are not related to the frontiers semantics defined in section 5.3 are presented in [6, 10].
Reference: [12] <author> R. Barbuti and R. Giacobazzi. </author> <title> A Bottom-up Polymorphic Type Inference in Logic Programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 19(3) </volume> <pages> 281-313, </pages> <year> 1992. </year>
Reference-contexts: An instance of the framework consists in the specialization of a set of basic abstract operators, i.e. abstract unification, abstract substitution application and abstract union. Instances have been defined for ground dependency analysis [13], type inference <ref> [12] </ref> and for analysis of properties related to AND-parallelism [67, 68]. The emphasis in [13] is on the bottom-up definition of an abstract 45 model, i.e. a goal independent approximation of the concrete denotation.
Reference: [13] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1993. </year>
Reference-contexts: w.r.t. several non-monotonic semantics (as, for example, the stable model and the well-founded model semantics), by showing that it preserves the semantic kernel considered in section 6.3. 7.2 Program analysis In the area of program analysis, the s-semantics has been used as a foundation of several frameworks for abstract interpretation <ref> [13, 65, 77, 31] </ref>. Abstract interpretation is inherently semantics sensitive and different semantic definition styles lead to different approaches to program analysis. In the case of logic programs (see [38] for a broad overview), two main approaches exist, namely the top-down and the bottom-up ones [94]. <p> The s-semantics approach to abstract interpretation was started by defining a framework for bottom-up abstract interpretation <ref> [13] </ref> based on the concrete semantics of section 3, which correctly models computed answer substitutions. An instance of the framework consists in the specialization of a set of basic abstract operators, i.e. abstract unification, abstract substitution application and abstract union. Instances have been defined for ground dependency analysis [13], type inference <p> abstract interpretation <ref> [13] </ref> based on the concrete semantics of section 3, which correctly models computed answer substitutions. An instance of the framework consists in the specialization of a set of basic abstract operators, i.e. abstract unification, abstract substitution application and abstract union. Instances have been defined for ground dependency analysis [13], type inference [12] and for analysis of properties related to AND-parallelism [67, 68]. The emphasis in [13] is on the bottom-up definition of an abstract 45 model, i.e. a goal independent approximation of the concrete denotation. <p> Instances have been defined for ground dependency analysis <ref> [13] </ref>, type inference [12] and for analysis of properties related to AND-parallelism [67, 68]. The emphasis in [13] is on the bottom-up definition of an abstract 45 model, i.e. a goal independent approximation of the concrete denotation. <p> As a matter of fact the framework in <ref> [13] </ref> has been extended to handle modularity [32], by replacing the s-semantics with its compositional version (the -semantics of section 4), which has clauses as semantic objects. This extension requires a notion of abstract program and a uniform treatment of concrete 46 and abstract objects (i.e. programs and -interpretations).
Reference: [14] <author> M. Baudinet. </author> <title> Proving Termination Properties of Prolog Programs: A Semantic Approach. </title> <journal> Journal of Logic Programming, </journal> <volume> 14 </volume> <pages> 1-29, </pages> <year> 1992. </year>
Reference-contexts: There are analogies between S DF L (P ) and other functional semantics for PROLOG developed in the denotational style. For instance, in <ref> [14] </ref> the semantics is a function which associates to any goal an extended or infinite sequence of p.a.s. which clearly recalls the sequence computed by ? . The difference is in the style of the semantics construction.
Reference: [15] <author> E. Bertino, M. Martelli, and D. Montesi. </author> <title> CLP(AD) as a Deductive Database Language with Updates. </title> <editor> In E. Lamma and P. Mello, editors, </editor> <booktitle> Extensions of Logic Programming. Proc. Third International Workshop on Extensions of Logic Programming, ELP'92, volume 660 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 80-99. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: CLP (H=E) [1, 2] is a logic + equational language, where constraints are equations to be solved in an equational theory and the constraint solver is a narrowing algorithm. CLP (AD) <ref> [15] </ref> models a deductive database language with updates. The semantics provides a nice characterization of the intensional part w.r.t. the extensional one and of the notion of transaction. The corresponding equivalence notions can profitably be used to prove interesting properties of optimization procedures.
Reference: [16] <author> E. Bolzan. Proprieta osservabili e diagnosi di programmi logici. </author> <type> Master's thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1993. </year> <note> in italian. </note>
Reference-contexts: The ability to use the CLP interpreter to analyze CLP programs has been exploited in some interesting applications [8]. 7.3 Declarative debugging The application of the s-semantics approach to semantics-based (declarative) debugging <ref> [16] </ref> has the following features when compared to the existing methods [103, 49, 87]. * The s-semantics, when taken as specification of the intended semantics, allows us to obtain a more accurate diagnosis than the one that can be obtained using the least Herbrand model or the c-semantics (which is used
Reference: [17] <author> A. Bossi, M. Bugliesi, and M. Fabris. </author> <title> Fixpoint semantics for PROLOG. </title> <editor> In D. S. Warren, editor, </editor> <booktitle> Proc. Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 374-389. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: This information is very important for the semantics of PROLOG <ref> [11, 17] </ref> and of all-solutions metapredicates [40]. * A goal G finitely fails iff there exist a finite number of frontiers for G, all the atoms in the frontiers of G are labeled as partial. This information is useful to get a bottom-up characterization of SLDNF resolution [95]. <p> Therefore, the semantics encodes the ordered trees of resultants for any goal. Clearly, if we are interested in some specific observable, the semantics O R (P ) contains too much information and can usefully be abstracted. One such abstraction is presented in <ref> [17] </ref>. It has been designed to capture the set of (PROLOG) computed answer substitutions (p.a.s.) as observable, i.e. the set of answers which can be reached by using PROLOG's control. The observational equivalence induced by p.a.s. is the following. <p> P 1 p:a:s P 2 if for any goal G, is a p:a:s for G in P 1 if and only if is a p:a:s for G in P 2 . We can reconstruct the semantics presented in <ref> [17] </ref>, by first mapping O R (P ) into an ordered set of sequences of resultants, such that the i-th sequence represents the frontiers of the partial SLD-trees of depth i for the most general goals. <p> We first consider the first atom and extract information on it. In this case we will find the two answers fX=bg :: fX=cg. Then we consider the corresponding instances of the second atom, i.e. p (X; Y )fX=bg and p (X; Y )fX=cg. 6 Actually in <ref> [17] </ref> hypothetical atoms are called divergent and denoted by b A. Here we adopt the notation introduced in section 5.3.1. 34 Since the goal p (b; Y ) unifies with p (b; Y ), the empty substitution " will be its first answer. <p> The following definition is an extension of the one given in <ref> [17] </ref> for atomic goals only. Definition 6.28 Let S be a sequence in B fl E , G be a goal, A; A 0 2 B, A E 2 B E . <p> Definition 6.29 <ref> [17] </ref> Let P be the program c 1 :: :: c n . P : B fl E 7! B fl defined clause-wise as the concatenation P (S) = c 1 (S) :: :: c n (S), for any sequence S. Let c be a clause standardized apart from S. <p> Interpretations are elements of the complete lattice (P (B fl E ); ; ?; &gt;; [; "), i.e. sets of sequences representing abstractions of frontiers. The immediate consequences operator P extends P to interpretations. Definition 6.30 <ref> [17] </ref> The immediate consequences operator P : P (B fl E ) 7! E ) is defined in terms of P as follows. Let I 2 P (B fl E ), P is continuous on the lattice of interpretations and the fixpoint semantics S DF L (P ) defined in [17] <p> <ref> [17] </ref> The immediate consequences operator P : P (B fl E ) 7! E ) is defined in terms of P as follows. Let I 2 P (B fl E ), P is continuous on the lattice of interpretations and the fixpoint semantics S DF L (P ) defined in [17] is its least fixpoint. It contains a possibly infinite set of abstractions of increasing frontiers. S DF L (P ) has been defined by considering most general goals. According to the s-semantics style, it encodes the information on any goal. <p> To extract this information we use the reachability function ? . Any Prolog answer substitution (p.a.s.) for a goal G in the program P can be characterized in terms of the reachability of G in one of the sequences in S DF L (P ). Theorem 6.31 <ref> [17] </ref> Let G be a goal and P be a program. is a p.a.s for G in P if and only if there exists S 2 S DF L (P ) such that 2 ? (G; S). Therefore S DF L (P ) is correct with respect to p:a:s: . <p> In fact, the analogous of theorem 5.17 holds for the Prolog search strategy, i.e. when p.a.s. instead of c.a.s. are considered. 36 Theorem 6.32 <ref> [17] </ref> Let G be a goal and P be a program. <p> This gives to the approach a quite general flavour. The semantics in [11] has only a top-down definition. However, a more recent version of [11] contains two equivalent (top-down and bottom-up) semantics much in the style of O R R (P ) and more similar to the semantics in <ref> [17] </ref>. Other extensions of the s-semantics approach which are not related to the frontiers semantics defined in section 5.3 are presented in [6, 10]. In [10] a compilative approach to model Prolog control is defined.
Reference: [18] <author> A. Bossi, M. Bugliesi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Differential logic programming. </title> <booktitle> In Proc. Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 359-370. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The delayed evaluation of open predicates which is typical of O (P ) can easily be generalized to other logic languages, to achieve compositionality w.r.t the union of programs. By modifying O (P ) we can obtain semantics compositional w.r.t. other composition operators, as for example inheritance mechanisms <ref> [18] </ref> (see section 6.6). O (P ) can be considered as the semantic basis for modular program analysis, since by using suitable abstractions of O (P ), we can analyze program components and then combine the results to obtain the analysis of the whole program [32]. <p> In [97] this second class of built-in's is considered. 6.6 Modular logic programs with inheritance As already mentioned, by modifying O (P ) we can obtain semantics which are compositional w.r.t. other composition operators. In this section we will show an extension of such a semantics introduced in <ref> [18] </ref> to model several inheritance mechanisms in a compositional way. In [18] inheritance is viewed as a mechanism for differential programming, i.e. a mechanism for constructing new program components by specifying how they differ from the existing ones. <p> In this section we will show an extension of such a semantics introduced in <ref> [18] </ref> to model several inheritance mechanisms in a compositional way. In [18] inheritance is viewed as a mechanism for differential programming, i.e. a mechanism for constructing new program components by specifying how they differ from the existing ones. Differential programming is achieved by using "filters" to modify the external behavior of existing components. <p> An intuitive justification for such an interpretation can be found in [35]. See also [26] for a survey on inheritance mechanisms in logic programming. Differential programs <ref> [18] </ref> are program components, i.e. logic programs annotated by three sets of exported predicate symbols (the external interface): : statically inherited predicates (a la Simula-67); : dynamically inherited predicates (a la Smalltalk); fi: extensible predicates. <p> The following example shows the use of these composition mechanisms. Example 6.33 <ref> [18] </ref> Consider two classes Student and CS Student (computer science student). CS Student is a subclass of Student and redefines one of its superclass' methods. The two classes can be defined as differential logic programs as follows. <p> diff P 2 if for every differential program Q and for every hierarchy HP Q isa (P 1 isa HP ) isa Q isa (P 2 isa HP ): In order to obtain a compositional semantics for isa hierarchies, a syntactic composition operator / on programs has been introduced in <ref> [18] </ref>. Such an operator makes it possible to translate an isa hierarchy HP = P n isa : : : isa P 1 into an equivalent "flat" program HP / = P n &lt; : : : &lt; P 1 to be evaluated by standard SLD-derivation. <p> The next theorem shows the equivalence between the ` derivations in HP and SLD-derivations (denoted by ;) in HP / . Theorem 6.35 <ref> [18] </ref> Let HP = P n isa : : : isa P 1 be an isa-hierarchy and HP / = P n &lt; : : : &lt; P 1 be the corresponding h; ; fii-differential program. <p> The next example shows that O (P ) does not contain enough information to model the program composition we are considering. Hence the generalization is truly necessary. Example 6.37 <ref> [18] </ref> Let h 1 ; 1 ; fi 1 i-P 1 and h 2 ; 2 ; fi 2 i-P 2 be the programs P 1 = fr (a):g P 2 = f p (X) : r (X): where 1 = frg, 2 = fr; pg and i = fi i <p> The problem shown by the previous example is solved by introducing context sensitive clauses as elements of the semantic domain. Definition 6.38 <ref> [18] </ref> A context sensitive clause (cs-clause) is an object of the form A:-fq 1 ; : : :; q n g2B 1 ; : : : ; B k (1) where q 1 ; : : : ; q n are predicate symbols. <p> Let P be a h; ; fii-program and (P ) be the set of predicates defined in P . The set of predicates whose definitions can be modified by composing P is the set (open predicates) Open (P ) = ( n (P )) [ [ fi. Definition 6.39 <ref> [18] </ref> Let P be a h; ; fii-program and let I be a cs-interpretat ion for P . <p> Moreover, when cs-interpretations contain unit clauses only and Open (P ) = ;, the previous definition boils down to the operator of definition 3.16. P is continuous on (C ; ). Hence the fixpoint semantics is the following. Definition 6.40 <ref> [18] </ref> Let P be a h; ; fii-program. <p> ]] of P is defined as [[P ]] = T cs where A = fH : s2 ~ B j P red (H) 2 (P )g and P " ! such that s 0 s; H 0 : ~ B 0 + H : ~ B g We refer to <ref> [18] </ref> for the details on the previous construction and in the following we will only show the main results which hold for the [[P ]] semantics. <p> Compositionality of [[P ]] wrt &lt; has been proven by introducing a (right associative) semantic operator on cs-interpretations which corresponds to the syntactic composition &lt; of differential programs. Theorem 6.41 (compositionality) <ref> [18] </ref> Let h P ; P ; fi P i-P and h Q ; Q ; fi Q i-Q be differential programs. <p> Theorem 6.42 <ref> [18] </ref> Let HP = P n isa : : : isa P 1 be an isa-hierarchy, HP / = P n &lt; : : : &lt; P 1 be the corresponding h; ; fii-program and G = A 1 ; : : : ; A k be a goal with P <p> A similar result was also proved [85] for a metainterpreter defining the inheritance mechanism described in <ref> [18] </ref>. 8 Conclusions We have shown several semantics, which exhibit similar properties and which are all defined according to the same methodology. We have also shown that at least some of the above semantics have successfully been used to solve real problems.
Reference: [19] <author> A. Bossi and N. Cocco. </author> <title> Basic transformation operations for logic programs which preserve computed answer substitutions of logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 16 </volume> <pages> 47-87, </pages> <year> 1993. </year>
Reference-contexts: The proof can in fact be based on general theorems (such as AN D-compositionality) and on powerful technical tools such as the specialized immediate consequences operators. This is the approach taken in <ref> [19] </ref> and [7], where the reference semantics are the answer substitution semantics and the semantic kernel respectively. In [19] some transformation operations which are basic for all the transformation techniques for logic programs, such as partial evaluation, program specialization, program synthesis and optimization, are considered. <p> This is the approach taken in <ref> [19] </ref> and [7], where the reference semantics are the answer substitution semantics and the semantic kernel respectively. In [19] some transformation operations which are basic for all the transformation techniques for logic programs, such as partial evaluation, program specialization, program synthesis and optimization, are considered. For each operation, applicability conditions which guarantee the safeness of the trasfor-mation with respect to the s-semantics of section 3 are defined. <p> The only exception is the folding operation. Safeness of folding cannot be ensured by just inspecting the s-semantics as the following example shows. Example 7.1 Consider the following program. P = f p : r:; r : q:; q: g The definition p q is consistent <ref> [19] </ref> with P , since both p and q belong to O (P ), but, if we use it to fold the body of the second clause we obtain P 0 = f p : r:; r : p:; q: g which is by no means equivalent to the previous program.
Reference: [20] <author> A. Bossi, N. Cocco, and S. Etalle. </author> <title> On Safe Folding. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming Proceedings PLILP'92, volume 631 of Lecture Notes in Computer Science, </booktitle> <pages> pages 172-186. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: In fact O (P 0 ) = fqg. 7 The [-compositional semantics of section 4 is essentially the result of the partial evalua tion, where derivations terminate at open predicates (i.e. predicates in ). 44 This problem has been partially overcome in <ref> [20] </ref> where a notion of semantic delay between atoms is introduced to give applicability conditions for folding. Semantic delay is not properly a property of the s-semantics, rather it depends on its fixpoint construction.
Reference: [21] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 570-580, </pages> <year> 1992. </year> <note> Extended version to appear in Theoretical Computer Science. 51 </note>
Reference-contexts: Ex amples are the compositional semantics for positive logic programs <ref> [62, 63, 22, 21] </ref>, whose domains are sets of clauses (see section 4), the semantic kernel for normal logic programs [43, 75], whose domains are sets of negative normal clauses (see section 6.3), the model state semantics for disjunctive logic programs [98, 90], whose domains are sets of positive disjunctive ground <p> This idea fits quite naturally within the s-semantics approach since the semantic domains are syntactic objects, i.e. programs. The -semantics <ref> [22, 21] </ref> is similar to one of the semantics in [62], yet it is defined according to the general s-semantics approach. It was originally defined for a more general composition operator [ , defined on -open programs. <p> A more general notion of composition which allows different sets of open predicates for the composed programs is considered in <ref> [21] </ref>. The semantics of open programs must be compositional w.r.t. [ , i.e. the semantics of P 1 [ P 2 must be derivable from the semantics of P 1 and P 2 . <p> The above observational equivalence is captured by the following operational semantics. We denote by Id the set of clauses fp ( ~ X) : p ( ~ X) j p 2 g where is a set of predicate symbols. 16 Definition 4.4 (-compositional computed answer substitutions semantics) <ref> [21] </ref> Let P be a positive program, be a set of predicate symbols, P fl be the augmented program P [ Id and R be a fair selection rule. <p> P = f p (X) : q (X): q (a): Then O (P ) = fp (X) : q (X); p (a); q (a); r (b); s (b)g. The following results show that O actually models computed answer substitutions in a compositional way. Theorem 4.8 (compositionality) <ref> [21] </ref> Let P; P 1 ; P 2 be programs and assume P red (P 1 ) " P red (P 2 ) . <p> Note that we consider a -interpretation also as a set of (renamed apart) syntactic clauses. Moreover operators such as unf P are considerd as operators on C . These "semantic" versions are well defined since clauses are always renamed apart. Definition 4.9 <ref> [21] </ref> Let P be an -open program and let I C . Then T Lemma 4.10 [21] Let P be an -open program. Then T P; is continuous on (=; )). <p> Moreover operators such as unf P are considerd as operators on C . These "semantic" versions are well defined since clauses are always renamed apart. Definition 4.9 <ref> [21] </ref> Let P be an -open program and let I C . Then T Lemma 4.10 [21] Let P be an -open program. Then T P; is continuous on (=; )). Definition 4.11 [22, 21] The (least) fixpoint semantics of an -open program P is defined as F (P ) = T P; " !. Theorem 4.12 (equivalence of the fixpoint and the operational semantics) [21] Let <p> These "semantic" versions are well defined since clauses are always renamed apart. Definition 4.9 [21] Let P be an -open program and let I C . Then T Lemma 4.10 [21] Let P be an -open program. Then T P; is continuous on (=; )). Definition 4.11 <ref> [22, 21] </ref> The (least) fixpoint semantics of an -open program P is defined as F (P ) = T P; " !. Theorem 4.12 (equivalence of the fixpoint and the operational semantics) [21] Let P be an -open program. Then F (P ) = O (P ). <p> 4.10 <ref> [21] </ref> Let P be an -open program. Then T P; is continuous on (=; )). Definition 4.11 [22, 21] The (least) fixpoint semantics of an -open program P is defined as F (P ) = T P; " !. Theorem 4.12 (equivalence of the fixpoint and the operational semantics) [21] Let P be an -open program. Then F (P ) = O (P ). The denotation O (P ) can be viewed as a function which, when provided with the denotation of a program Q, returns the denotation of P [ Q. <p> This is formalized by the function H in the following definition. Definition 4.13 <ref> [21] </ref> Let I be a -interpretation for an -open program. <p> Proposition 4.14 <ref> [21] </ref> Let P be an -open program.
Reference: [22] <editor> A. Bossi and M. Menegus. Una Semantica Composizionale per Programmi Logici Aperti. In P. Asirelli, editor, </editor> <booktitle> Proc. Sixth Italian Conference on Logic Programming, </booktitle> <pages> pages 95-109, </pages> <year> 1991. </year>
Reference-contexts: Ex amples are the compositional semantics for positive logic programs <ref> [62, 63, 22, 21] </ref>, whose domains are sets of clauses (see section 4), the semantic kernel for normal logic programs [43, 75], whose domains are sets of negative normal clauses (see section 6.3), the model state semantics for disjunctive logic programs [98, 90], whose domains are sets of positive disjunctive ground <p> This idea fits quite naturally within the s-semantics approach since the semantic domains are syntactic objects, i.e. programs. The -semantics <ref> [22, 21] </ref> is similar to one of the semantics in [62], yet it is defined according to the general s-semantics approach. It was originally defined for a more general composition operator [ , defined on -open programs. <p> The -semantics [22, 21] is similar to one of the semantics in [62], yet it is defined according to the general s-semantics approach. It was originally defined for a more general composition operator [ , defined on -open programs. An -open program <ref> [22] </ref> P is a positive program in which the predicate symbols belonging to the set are considered partially defined in P . P can be composed with another program Q which may further specify the predicates in and use clauses in P to complete its own predicate definitions. <p> These "semantic" versions are well defined since clauses are always renamed apart. Definition 4.9 [21] Let P be an -open program and let I C . Then T Lemma 4.10 [21] Let P be an -open program. Then T P; is continuous on (=; )). Definition 4.11 <ref> [22, 21] </ref> The (least) fixpoint semantics of an -open program P is defined as F (P ) = T P; " !. Theorem 4.12 (equivalence of the fixpoint and the operational semantics) [21] Let P be an -open program. Then F (P ) = O (P ).
Reference: [23] <author> P. Bruscoli, F. Levi, G. Levi, and M. C. Meo. </author> <title> Compilative Constructive negation in Constraint Logic Programs. </title> <editor> In S. Tison, editor, </editor> <booktitle> Proc. CAAP'94, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: As a result of this step, the negation in the stratified component has been completely evaluated (and replaced by constraints), while the non-stratified negation is still there in some clauses. The above approaches have been overriden by <ref> [23] </ref>, which considers constructive negation in constraint logic programs as defined in [105], for which there exists a very strong completeness result w.r.t. 3-valued models of the completion. -interpretations are pairs of sets of (equivalence classes of) constrained atoms (similar to those used in the CLP semantics discussed in section 6.1).
Reference: [24] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: As we will argue later, the application of the s-semantics approach to abstract interpretation shows that the real issue is goal dependency vs. goal independency rather than top-down vs. bottom-up. Another relevant feature of the analysis method is its ability to determine call pattern information <ref> [24, 73, 94] </ref>, i.e. information about the procedure calls (atoms selected in an SLD-derivation). The ability to determine call patterns is also usually associated to goal dependent top-down methods. <p> Recently, the approach was made goal independent [33], by using the -semantics. The result is a denotation consisting of clauses very similar to the one in [53]. * It is worth noting that the top-down operational or denotational frameworks <ref> [24, 94, 104, 74] </ref> do indeed contain a lot of information on the "inter nal" computation details. By choosing a semantics like the one of section 47 5.3, we can model the same observables and still get a goal independent top-down and bottom-up construction of the abstract model.
Reference: [25] <author> F. Bry. </author> <title> Logic Programming as Constructivism: A Formalization and its Application to Databases. </title> <booktitle> In Proc. Eighth ACM Symp. on Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: Theorem 6.19 [75] Every model of the completion of F k (P ) is a model of the completion of P . 4 The same construction was independently proposed in <ref> [25] </ref>. 5 A negative clause [75] is a normal clause of the form A : :B 1 ; : : : ; :B n . 31 It is also strongly related to the stable model semantics [64] of P , as shown by the following very important theorem.
Reference: [26] <author> M. Bugliesi, E. Lamma, and P. Mello. </author> <title> Modularity in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <note> 1994. To appear. </note>
Reference-contexts: Accordingly, a modified version of a component is obtained by defining a new component that performs some special operations and possibly calls the original one. An intuitive justification for such an interpretation can be found in [35]. See also <ref> [26] </ref> for a survey on inheritance mechanisms in logic programming. Differential programs [18] are program components, i.e. logic programs annotated by three sets of exported predicate symbols (the external interface): : statically inherited predicates (a la Simula-67); : dynamically inherited predicates (a la Smalltalk); fi: extensible predicates.
Reference: [27] <author> D. Chan. </author> <title> Constructive Negation Based on the Completed Database. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 111-125. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: As we will show in the next section the semantic kernel construction can be useful even in relation to constructive negation. 6.4 Constructive negation The inference rule for negation which is the most adequate to be handled by the s-semantics approach is clearly constructive negation introduced in <ref> [27, 28] </ref>, because it allows the negative literals to compute answers. The first attempt to extend the s-semantics to negation is described in [108]. It is a bottom-up semantics for stratified normal programs which generalizes to the non-ground case the construction of [4].
Reference: [28] <author> D. Chan. </author> <title> An Extension of Constructive Negation and its Application in Coroutining. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 477-493. </pages> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1989. </year>
Reference-contexts: As we will show in the next section the semantic kernel construction can be useful even in relation to constructive negation. 6.4 Constructive negation The inference rule for negation which is the most adequate to be handled by the s-semantics approach is clearly constructive negation introduced in <ref> [27, 28] </ref>, because it allows the negative literals to compute answers. The first attempt to extend the s-semantics to negation is described in [108]. It is a bottom-up semantics for stratified normal programs which generalizes to the non-ground case the construction of [4].
Reference: [29] <author> K. H. Chan. </author> <title> Equivalent logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 9(3) </volume> <pages> 187-199, </pages> <year> 1990. </year>
Reference-contexts: For example, subsumption equivalence of two programs is shown to correspond to the equality of their T P operators. Equivalences based on correct answer substitutions have also been 3 studied in <ref> [29] </ref>. However, these formalizations are not completely satisfactory since they do not consider an important class of program equivalences, which cannot be described by purely (standard first-order) logical notions. This is the class of equivalences based on what we can observe from a computation.
Reference: [30] <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: When trying to understand the meaning of programs, when analyzing and transforming programs, this semantics cannot be taken as the reference semantics. This is the reason why the need for a different formal semantics was recognized by many authors, giving rise to several new definitions <ref> [30, 49, 113, 42] </ref>. The need for better semantics was also recognized in the case of semantics-based abstract interpretation [94] and transformation [76]. 1.4 Compositionality In addition to the problem related to modeling the computed answers observational equivalences, there exists another problem with the least Herbrand model semantics. <p> Note also that O 2 is the semantics considered in <ref> [30, 42, 62] </ref> and called c-semantics in [47]. We will now compare the three semantics on an example. <p> If L P is the language underlying program P , the following theorem shows the language independence property. Note that the same property does not hold for other variable-based semantics, such as those in <ref> [30, 49] </ref>. Theorem 3.11 [85] If P is a positive program, then O L P (P ) = O L 0 (P ) for any extension L 0 of L P . <p> Early attempts [93, 94] of defining bottom-up abstract interpretations based on the immediate consequences operators corresponding to the least Herbrand model semantics or to the semantics in <ref> [30] </ref> failed on non-trivial analyses (like mode analysis). In fact, the corresponding concrete semantics do not contain enough information on the program behavior, i.e. they are too abstract to be useful to capture program properties like variable sharing or ground dependencies.
Reference: [31] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Weizmann Institute, Rehovot, </institution> <year> 1990. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: w.r.t. several non-monotonic semantics (as, for example, the stable model and the well-founded model semantics), by showing that it preserves the semantic kernel considered in section 6.3. 7.2 Program analysis In the area of program analysis, the s-semantics has been used as a foundation of several frameworks for abstract interpretation <ref> [13, 65, 77, 31] </ref>. Abstract interpretation is inherently semantics sensitive and different semantic definition styles lead to different approaches to program analysis. In the case of logic programs (see [38] for a broad overview), two main approaches exist, namely the top-down and the bottom-up ones [94]. <p> A similar (yet goal dependent) result can be obtained by using a transformational approach <ref> [31, 99] </ref>. A program P and a goal G are transformed (by using a transformation similar to the magic set transformation) into a program P 0 , such that every call pattern of G in P is a success pattern of P 0 .
Reference: [32] <author> M. Codish, S. K. Debray, and R. Giacobazzi. </author> <title> Compositional Analysis of Modular Logic Programs. </title> <booktitle> In Proc. Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 451-464. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: O (P ) can be considered as the semantic basis for modular program analysis, since by using suitable abstractions of O (P ), we can analyze program components and then combine the results to obtain the analysis of the whole program <ref> [32] </ref>. Let us finally mention that O is strongly related to abduction [44]. <p> As a matter of fact the framework in [13] has been extended to handle modularity <ref> [32] </ref>, by replacing the s-semantics with its compositional version (the -semantics of section 4), which has clauses as semantic objects. This extension requires a notion of abstract program and a uniform treatment of concrete 46 and abstract objects (i.e. programs and -interpretations).
Reference: [33] <author> M. Codish and B. Demoen. </author> <title> Analysing Logic Programs using "prop"- ositional Logic Programs and a Magic Wand. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proc. 1993 Int'l Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year> <month> 52 </month>
Reference-contexts: An abstraction of the operator T P 0 of definition 3.13 can now be used to compute in a bottom-up way information on the call patterns of G in P . Recently, the approach was made goal independent <ref> [33] </ref>, by using the -semantics. The result is a denotation consisting of clauses very similar to the one in [53]. * It is worth noting that the top-down operational or denotational frameworks [24, 94, 104, 74] do indeed contain a lot of information on the "inter nal" computation details.
Reference: [34] <author> P. Codognet and G. </author> <title> File. Computations, Abstractions and Constraints. </title> <booktitle> In Proc. Fourth IEEE Int'l Conference on Computer Languages. </booktitle> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: A similar result, in a framework based on the generalization of the top-down operational semantics, is described in <ref> [34] </ref>.
Reference: [35] <author> W. Cook and J. Palsberg. </author> <title> A Denotational Semantics of Inheritance and its Correctness. </title> <booktitle> In Proceedings of OOPSLA'89, </booktitle> <pages> pages 433-443. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Accordingly, a modified version of a component is obtained by defining a new component that performs some special operations and possibly calls the original one. An intuitive justification for such an interpretation can be found in <ref> [35] </ref>. See also [26] for a survey on inheritance mechanisms in logic programming. Differential programs [18] are program components, i.e. logic programs annotated by three sets of exported predicate symbols (the external interface): : statically inherited predicates (a la Simula-67); : dynamically inherited predicates (a la Smalltalk); fi: extensible predicates.
Reference: [36] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional Formula as Abstract Domain for Groundness Analysis. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 322-327. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: While this is needed to handle generic (possibly infinite) abstract domains, there exists [54] a wide class of compositionally tractable abstract domains (e.g Sharing [70] and Prop <ref> [36] </ref>) for which a finite description of the compositional abstract semantics can be obtained without a further level of abstraction. In fact, when considering compositionally tractable domains we are essentially considering the -semantics over a finite function free signature.
Reference: [37] <author> D. De Schreye and B. Martens. </author> <title> A Sensible Least Herbrand Semantics for Untyped Vanilla Meta-Programming and its Extension to a Limited Form of Amalgamation. </title> <editor> In A. Pettorossi, editor, </editor> <booktitle> Meta-Programming in Logic. Third International Workshop, META'92, volume 649 of Lecture Notes in Computer Science, </booktitle> <pages> pages 192-204. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Theorem 3.10 shows that this is exactly the class of language independent programs as defined in <ref> [37] </ref>. Definition 3.9 [37] A program P with underlying language L P is language independent iff, for any extension L 0 of L P , its least L 0 -Herbrand model is equal to its least L P -Herbrand model. 11 Theorem 3.10 [85] Let P be a program. <p> Theorem 3.10 shows that this is exactly the class of language independent programs as defined in <ref> [37] </ref>. Definition 3.9 [37] A program P with underlying language L P is language independent iff, for any extension L 0 of L P , its least L 0 -Herbrand model is equal to its least L P -Herbrand model. 11 Theorem 3.10 [85] Let P be a program. <p> The problem is related to differences in the languages used at the metalevel and at the object level and was solved either by considering typed programs [69], or by considering language independent programs only <ref> [37] </ref>. If we consider the s-semantics of P and V P , due to the property stated by theorem 3.11, the language problem disappears and we can easily prove the following theorem.
Reference: [38] <author> S. K. Debray. </author> <title> Formal bases for dataflow analysis of logic programs. </title> <editor> In G. Levi, editor, </editor> <booktitle> Advances in logic programming theory. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Abstract interpretation is inherently semantics sensitive and different semantic definition styles lead to different approaches to program analysis. In the case of logic programs (see <ref> [38] </ref> for a broad overview), two main approaches exist, namely the top-down and the bottom-up ones [94]. The most popular approach is the top-down one, which propagates the information as SLD-resolution does.
Reference: [39] <author> S. K. Debray and R. Ramakrishnan. </author> <title> Generalized Horn Clause Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The University of Arizona, </institution> <year> 1991. </year>
Reference-contexts: Since abstract denotations are finite, they can explicitely be used as oracles. Then we can test a program in a uniform way w.r.t. different specifications of the program properties. 8 This semantics generalizes the approach in <ref> [39] </ref> which gives an algebraic description of a class of fixpoint semantics (including ground and non-ground concrete semantics, and various abstract semantics) in terms of abstract notions of "instance" and "normalization". 48 7.4 Metaprogramming We consider here a formalization of metaprogramming [85] with the non-ground metalevel representation of object level variables.
Reference: [40] <author> G. Delzanno and M. Martelli. </author> <title> A bottom-up characterization of finite success. </title> <type> Technical report, </type> <institution> Universita di Genova, DISI, </institution> <year> 1992. </year>
Reference-contexts: If we want to characterize finite success <ref> [40] </ref> we must be able to distinguish between unit resultants (representing successful derivations) and non-unit resultants (representing possibly non-terminating computations). Non-atomic resultants are abstracted upon resorting to the notion of hypothetical atoms. <p> Two selectors, Certain and U ncertain are used to project any subset I of B E into one of the base components. Certain (I) = fA j A 2 B " Ig U ncertain (I) = fA j A 2?B " Ig: The frontier semantics E defined in <ref> [40] </ref> is obtained by collecting information computed at each iteration of the immediate consequences operator. <p> Thus Certain (E ) is the s-semantics while U ncertain (E) contains all the atomic goals whose SLD-tree has at least one infinite branch. Clearly E captures finite success and failure of both ground and non ground atoms. Theorem 5.17 <ref> [40] </ref> Let P be a positive program and A be a non-ground atom. 25 * A unifies with A 1 ; : : : ; A n in E with mgu 1 ; : : : ; n respectively, and ?A 62 E iff the goal A has an SLD-tree of <p> This information is very important for the semantics of PROLOG [11, 17] and of all-solutions metapredicates <ref> [40] </ref>. * A goal G finitely fails iff there exist a finite number of frontiers for G, all the atoms in the frontiers of G are labeled as partial. This information is useful to get a bottom-up characterization of SLDNF resolution [95].
Reference: [41] <author> F. Denis and J.-P. Delahaye. </author> <title> Unfolding, Procedural and Fixpoint Semantics of Logic Programs. </title> <editor> In C. Choffrut and M. Jantzen, editors, </editor> <booktitle> STACS 91, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 511-522. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: The link between the top-down and the bottom-up constructions is given by an unfolding operator [82, 83]. The 6 equivalence proofs can be stated in terms of simple properties of the unfolding and the immediate consequences operators <ref> [41] </ref>. It is worth noting that the aim of the approach is not defining a new notion of model. <p> The proof of equivalence between U (P ) and F (P ) can be based on such a relation. In particular the equivalence immediately holds for those immediate consequences operators which are compatible with the unfolding rule <ref> [41] </ref>. <p> Therefore it is possible to define the immediate consequences operator in terms of the unfolding rule. Theorem 3.21 was proved in [83]. An alternative proof is given in <ref> [41] </ref> by using lemma 3.20. A direct proof of F (P ) = O (P ) was first given in [47]. Definition 3.17 [83, 41] Let P be a positive program. <p> Theorem 3.21 was proved in [83]. An alternative proof is given in [41] by using lemma 3.20. A direct proof of F (P ) = O (P ) was first given in [47]. Definition 3.17 <ref> [83, 41] </ref> Let P be a positive program. Then we define the collection of programs P 0 = P and the collection of -interpretations I i (P ) = fA j A 2 B and A 2 P i g. <p> The unfolding semantics U (P ) of the program P is defined as U (P ) = i=0;1;::: Theorem 3.18 (equivalence of unfolding and operational semantics) <ref> [83, 41] </ref> Let P be a positive program. Then U (P ) = O (P ). Definition 3.19 [41] Let P; Q be positive programs. Then T P is compatible with unf P (Q) iff T unf P (Q) (;) = T Q (;)). <p> The unfolding semantics U (P ) of the program P is defined as U (P ) = i=0;1;::: Theorem 3.18 (equivalence of unfolding and operational semantics) [83, 41] Let P be a positive program. Then U (P ) = O (P ). Definition 3.19 <ref> [41] </ref> Let P; Q be positive programs. Then T P is compatible with unf P (Q) iff T unf P (Q) (;) = T Q (;)). Lemma 3.20 [41] Let P; Q be positive programs. Then T P is compatible with unf P (Q). <p> Then U (P ) = O (P ). Definition 3.19 <ref> [41] </ref> Let P; Q be positive programs. Then T P is compatible with unf P (Q) iff T unf P (Q) (;) = T Q (;)). Lemma 3.20 [41] Let P; Q be positive programs. Then T P is compatible with unf P (Q). <p> Since T P is compatible with the unfolding rule and T P (I) = unf P (I) (by definition of the unfolding rule), then T P " (i + 1) = T P i (;) = unf P i (;). Therefore, Theorem 3.21 (equivalence of fixpoint and operational semantics) <ref> [83, 41] </ref> Let P be a positive program. Then F (P ) = U (P ) = O (P ). Theorem 3.21 shows that F (P ) is the fully abstract semantics w.r.t. com puted answer substitutions.
Reference: [42] <author> P. Deransart and G. Ferrand. </author> <title> Programmation en logique avec negation: presentation formelle. </title> <type> Technical Report No. 87/3, </type> <institution> Lab. d'Informatique, Departement de Mathematiques et d'Informatique, Universite d'Orleans, </institution> <year> 1987. </year>
Reference-contexts: When trying to understand the meaning of programs, when analyzing and transforming programs, this semantics cannot be taken as the reference semantics. This is the reason why the need for a different formal semantics was recognized by many authors, giving rise to several new definitions <ref> [30, 49, 113, 42] </ref>. The need for better semantics was also recognized in the case of semantics-based abstract interpretation [94] and transformation [76]. 1.4 Compositionality In addition to the problem related to modeling the computed answers observational equivalences, there exists another problem with the least Herbrand model semantics. <p> Note also that O 2 is the semantics considered in <ref> [30, 42, 62] </ref> and called c-semantics in [47]. We will now compare the three semantics on an example.
Reference: [43] <author> Phan Minh Dung and K. Kanchanasut. </author> <title> A Fixpoint Approach to Declarative Semantics of Logic Programs. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 604-625. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: Ex amples are the compositional semantics for positive logic programs [62, 63, 22, 21], whose domains are sets of clauses (see section 4), the semantic kernel for normal logic programs <ref> [43, 75] </ref>, whose domains are sets of negative normal clauses (see section 6.3), the model state semantics for disjunctive logic programs [98, 90], whose domains are sets of positive disjunctive ground clauses (see section 6.2). <p> Similar domains consisting of clauses have been used to model non-standard observables [61, 59] (see section 5.3) and to characterize logic programs with negation <ref> [43, 75, 60] </ref> (with the aim of delaying the evaluation of negative literals). The delayed evaluation of open predicates which is typical of O (P ) can easily be generalized to other logic languages, to achieve compositionality w.r.t the union of programs. <p> It is a fixpoint construction which generalizes to the non-ground case the fixpoint semantics first proposed in <ref> [43] </ref> 4 . The idea of the semantic kernel construction is to evaluate all the positive atoms in the clause bodies by unfolding them until there are no more positive atoms left. The semantic kernel is then a (possibly infinite) program consisting of negative clauses only 5 . <p> Theorem 6.20 <ref> [43] </ref> Every Herbrand model of the completion of F k (P ) is a stable model of P .
Reference: [44] <author> K. Eshghi and R. A. Kowalski. </author> <title> Abduction compared with Negation by Failure. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. Sixth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 234-254. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: Let us finally mention that O is strongly related to abduction <ref> [44] </ref>. If is the set of abducible predicates, the abductive consequences of any goal G can be found by executing G in O (P ). 5 Other observables 5.1 Finite failures There exist other useful observables for positive logic programs, such as, for example, finite failures.
Reference: [45] <author> M. Falaschi, M. Gabbrielli, G. Levi, and M. Murakami. </author> <title> Nested Guarded Horn Clauses. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 1(3) </volume> <pages> 249-263, </pages> <year> 1990. </year>
Reference-contexts: The corresponding equivalence notions can profitably be used to prove interesting properties of optimization procedures. The approach has finally been applied to concurrent constraint programs as defined in [101], leading to the definition of equivalent top-down and bottom-up semantics, defined as sets of unit clauses <ref> [45, 57] </ref>, which are trees of ask and tell constraints.
Reference: [46] <author> M. Falaschi and G. Levi. </author> <title> Finite failures and partial computations in concurrent logic languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 75 </volume> <pages> 45-66, </pages> <year> 1990. </year>
Reference-contexts: Then if 9# = mgu (G; H), then B 1 # is a call pattern. The knowledge about the call patterns is useful in program optimization. The above property makes feasible a bottom-up characterization of (possibly abstract versions of) the call patterns. * The partial answers, originally defined in <ref> [46] </ref>, are the answers computed at any intermediate computation step.
Reference: [47] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: These aspects include observable properties such as computed answers, which are modeled by sets of non-ground atoms or unit clauses <ref> [47] </ref> (see section 3), call patterns, which are modeled by sets of binary clauses [61] (see section 5.3.2), resultants, which are modeled by sets of clauses [59] (see section 5.3). Goal-independence is the key issue. <p> The overall approach is called in this paper the s-semantics approach after the s-semantics <ref> [47] </ref>, which was the first example of a semantic construction featuring some of the above properties. <p> The most adequate observable is therefore computed answers (denoted by c). P 1 c P 2 iff for any goal G, G has the same (up to renaming) computed answers in P 1 and in P 2 . As first shown in <ref> [47] </ref>, the van Emden and Kowalski's semantics is not correct w.r.t. to the observational equivalence based on computed answer substitutions. Namely, there exist programs which have the same least Herbrand model, yet compute different answer substitutions. <p> In section 3 we consider the original s-semantics <ref> [47, 48] </ref>, which is the first (non-compositional) semantics of positive logic programs correct w.r.t. computed answers. Compositionality is discussed in section 4, while in section 5 we consider semantics modeling other observables, such as finite failures and resultants. <p> The above relations suggest a methodology to obtain the immediate consequences operator by first defining the unfolding operator, which is easier to define because of its strong relation to the operational semantics. 2.3 Model-theoretic semantics Let us first note that the original model-theoretic view of the s-semantics <ref> [47] </ref> was based on ad-hoc notions of s-truth and s-model. The notion of -model, first introduced in [48], fixes the above problem, by viewing a denotation just 8 as a syntactic notation for a set of Herbrand interpretations. <p> The above observable is captured by the following operational semantics. Recall that ~ X denotes a tuple of distinct variables. 1 s stands for "subset interpretations" used in <ref> [47] </ref> as semantic domains and contrasted to "closed interpretations" used to define the so-called c-semantics (see Definition 3.6). 9 Definition 3.2 (Computed answer substitutions semantics, s-semantics) [47] Let P be a positive program. <p> Recall that ~ X denotes a tuple of distinct variables. 1 s stands for "subset interpretations" used in <ref> [47] </ref> as semantic domains and contrasted to "closed interpretations" used to define the so-called c-semantics (see Definition 3.6). 9 Definition 3.2 (Computed answer substitutions semantics, s-semantics) [47] Let P be a positive program. <p> These interpretations were called canonical realizations in [100, 79]. Theorem 3.4 shows that O actually models computed answer substitutions and that it is fully abstract, since P 1 ' P 2 implies O (P 1 ) = O (P 2 ). Theorem 3.4 <ref> [47] </ref> Let P 1 ; P 2 be positive programs. P 1 ' P 2 iff O (P 1 ) = O (P 2 ). <p> This property is a kind of AND-composit-ionality. Similar theorems will be shown to hold for all the semantics defined according to the s-semantics style. This is also the key property which allows us to use abstractions of the semantics for goal independent abstract interpretation. Theorem 3.5 <ref> [47] </ref> Let P be a positive program and G = G 1 ; : : : ; G n be a posi tive goal. <p> Note also that O 2 is the semantics considered in [30, 42, 62] and called c-semantics in <ref> [47] </ref>. We will now compare the three semantics on an example. <p> Example 3.7 shows that the three semantics are different. Indeed, if we denote by i the program equivalence induced by O i , i = 1; 2, the following (strict) inclusion holds <ref> [47, 48] </ref>. ' 2 1 , i.e. ' is finer than 2 , and 2 is finer than 1 . This shows that the success set semantics is not correct with respect to computed answers. <p> Let I be a -interpretation. If [I] denotes the set of ground instances of the atoms in I, [I] is clearly a Herbrand interpretation. The following theorem relates the s-semantics to the success set (and therefore to the least Herbrand model). Theorem 3.8 <ref> [47] </ref> If P is a positive program, then O 1 (P ) = [O (P )]. We have shown that the success set semantics does not correctly model the computed answers. One could still think that this is not the case in most reasonable logic programs. <p> Lemma 3.12 The set of all -interpretations (=; ) is a complete lattice. Definition 3.13 <ref> [47] </ref> Let P be a positive program and I be a -interpretation. <p> In other words T P defines a bottom-up inference rule (hyper-resolution) based on the same rule (unification) which is used by the top-down SLD-resolution. The following theorem allows us to define a fixpoint semantics for positive logic programs. 12 Theorem 3.14 <ref> [47] </ref> The T P operator is continuous on (=; ). Then there ex ists the least fixpoint T P " ! of T Definition 3.15 [47] The fixpoint semantics of a positive program P is defined as F (P ) = T It is worth noting that, since any program P <p> The following theorem allows us to define a fixpoint semantics for positive logic programs. 12 Theorem 3.14 <ref> [47] </ref> The T P operator is continuous on (=; ). Then there ex ists the least fixpoint T P " ! of T Definition 3.15 [47] The fixpoint semantics of a positive program P is defined as F (P ) = T It is worth noting that, since any program P is a finite set of clauses, all the finite fixpoint approximations T P " n; n ! are finite. <p> Therefore it is possible to define the immediate consequences operator in terms of the unfolding rule. Theorem 3.21 was proved in [83]. An alternative proof is given in [41] by using lemma 3.20. A direct proof of F (P ) = O (P ) was first given in <ref> [47] </ref>. Definition 3.17 [83, 41] Let P be a positive program. Then we define the collection of programs P 0 = P and the collection of -interpretations I i (P ) = fA j A 2 B and A 2 P i g. <p> On one side, it correctly models computed answers. On the other side, it has nice properties also from the model-theoretic viewpoint. This can be shown by considering the properties of the (atomic logical consequences) semantics O 2 and the relation between O and O 2 . Theorem 3.25 <ref> [47, 62] </ref> Let P be a positive program and A be a (possibly non-ground) atom. Then P j= 8A iff A 2 O 2 (P ). Theorem 3.26 [47] Let P be a positive program. <p> Theorem 3.25 [47, 62] Let P be a positive program and A be a (possibly non-ground) atom. Then P j= 8A iff A 2 O 2 (P ). Theorem 3.26 <ref> [47] </ref> Let P be a positive program.
Reference: [48] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Reconstruction of the Operational Semantics of Logic Programs. </title> <journal> Information and Computation, </journal> <volume> 102(1) </volume> <pages> 86-113, </pages> <year> 1993. </year>
Reference-contexts: In section 3 we consider the original s-semantics <ref> [47, 48] </ref>, which is the first (non-compositional) semantics of positive logic programs correct w.r.t. computed answers. Compositionality is discussed in section 4, while in section 5 we consider semantics modeling other observables, such as finite failures and resultants. <p> The notion of -model, first introduced in <ref> [48] </ref>, fixes the above problem, by viewing a denotation just 8 as a syntactic notation for a set of Herbrand interpretations. H (I P ) denotes the set of all the Herbrand interpretations represented by I P . <p> Example 3.7 shows that the three semantics are different. Indeed, if we denote by i the program equivalence induced by O i , i = 1; 2, the following (strict) inclusion holds <ref> [47, 48] </ref>. ' 2 1 , i.e. ' is finer than 2 , and 2 is finer than 1 . This shows that the success set semantics is not correct with respect to computed answers. <p> This makes available equivalent top-down and bottom-up proof methods. 3.3 Model-theoretic semantics In order to define -models according to definition 2.1 we have to specify the function H from -interpretations to sets of Herbrand interpretations. Definition 3.22 <ref> [48] </ref> Let I be a -interpretation. Then H (I) = f [I]g where [I] is the set of ground instances of atoms in I or, equivalently, the least Herbrand model of I. Proposition 3.23 [48] Let P be a program. <p> Definition 3.22 <ref> [48] </ref> Let I be a -interpretation. Then H (I) = f [I]g where [I] is the set of ground instances of atoms in I or, equivalently, the least Herbrand model of I. Proposition 3.23 [48] Let P be a program. Then every Herbrand model of P is a -model of P . Moreover O (P ); O 1 (P ); O 2 (P ) are -models of P . <p> This is not surprising, since set theoretic operations do not adequately model the operations on non-ground atoms, which stand for all their ground instances. A more adequate partial order relation on the set = of -interpretations was defined in <ref> [48] </ref>. Definition 3.24 [48] Let I 1 , I 2 be -denotations. <p> This is not surprising, since set theoretic operations do not adequately model the operations on non-ground atoms, which stand for all their ground instances. A more adequate partial order relation on the set = of -interpretations was defined in <ref> [48] </ref>. Definition 3.24 [48] Let I 1 , I 2 be -denotations.
Reference: [49] <author> G. Ferrand. </author> <title> Error Diagnosis in Logic Programming, an Adaptation of E.Y. Shapiro's Method. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 177-198, </pages> <year> 1987. </year>
Reference-contexts: When trying to understand the meaning of programs, when analyzing and transforming programs, this semantics cannot be taken as the reference semantics. This is the reason why the need for a different formal semantics was recognized by many authors, giving rise to several new definitions <ref> [30, 49, 113, 42] </ref>. The need for better semantics was also recognized in the case of semantics-based abstract interpretation [94] and transformation [76]. 1.4 Compositionality In addition to the problem related to modeling the computed answers observational equivalences, there exists another problem with the least Herbrand model semantics. <p> If L P is the language underlying program P , the following theorem shows the language independence property. Note that the same property does not hold for other variable-based semantics, such as those in <ref> [30, 49] </ref>. Theorem 3.11 [85] If P is a positive program, then O L P (P ) = O L 0 (P ) for any extension L 0 of L P . <p> The ability to use the CLP interpreter to analyze CLP programs has been exploited in some interesting applications [8]. 7.3 Declarative debugging The application of the s-semantics approach to semantics-based (declarative) debugging [16] has the following features when compared to the existing methods <ref> [103, 49, 87] </ref>. * The s-semantics, when taken as specification of the intended semantics, allows us to obtain a more accurate diagnosis than the one that can be obtained using the least Herbrand model or the c-semantics (which is used in [49]). * The properties of the s-semantics (equivalent top-down goal <p> the following features when compared to the existing methods [103, 49, 87]. * The s-semantics, when taken as specification of the intended semantics, allows us to obtain a more accurate diagnosis than the one that can be obtained using the least Herbrand model or the c-semantics (which is used in <ref> [49] </ref>). * The properties of the s-semantics (equivalent top-down goal independent denotations and bottom-up denotations) make possible to devise new elegant and powerful diagnosis methods.
Reference: [50] <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: The two elements of the pair specify the positive and negative components of the -interpretation. The function H now maps -interpretations onto partial A-interpretations <ref> [50, 51] </ref>. The denotation O CN (P ) of a normal CLP program P has two equivalent top-down and bottom-up characterizations and is correct 32 w.r.t. the answer constraints observable. <p> Finally, H (O CN (P )) is Kunen's seman-tics [80], namely P " !, where P is Fitting's map on partial A-interpretations <ref> [50] </ref>. It is worth noting that a similar bottom-up characterization can be obtained by the non-ground extension of P defined in [105]. 6.5 PROLOG We first consider pure PROLOG programs, i.e. programs without cut, built-in's or negation.
Reference: [51] <author> M. Fitting and M. Ben-Jacob. </author> <title> Stratified and Three-valued Logic Programming Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1054-1069. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: The two elements of the pair specify the positive and negative components of the -interpretation. The function H now maps -interpretations onto partial A-interpretations <ref> [50, 51] </ref>. The denotation O CN (P ) of a normal CLP program P has two equivalent top-down and bottom-up characterizations and is correct 32 w.r.t. the answer constraints observable.
Reference: [52] <author> M. Gabbrielli. </author> <title> The Semantics of Logic Programming as a Programming Language. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: For any set A, A fl denotes the set of finite sequences of elements of A. :: will denote concatenation of sequences and is the empty sequence. 2 The s-semantics approach The aim of the s-semantics approach <ref> [82, 56, 52, 58] </ref> is modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages. The approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> We have also shown that at least some of the above semantics have successfully been used to solve real problems. As shown in <ref> [59, 52] </ref>, the various semantics are mutually related by means of abstractions. The same relation holds between concrete and abstract semantics. In particular, the generalized semantics of CLP in [66, 65] shows that one can derive from a single semantics several specializations obtained by abstracting the constraints in the program.
Reference: [53] <author> M. Gabbrielli and R. Giacobazzi. </author> <title> Goal independency and call patterns in the analysis of logic programs. </title> <booktitle> In Proc. ACM Symposium on Applied Computing, </booktitle> <publisher> ACM press, </publisher> <year> 1994. </year>
Reference-contexts: Namely, we have to model an observable consisting of all the procedure calls. The problem of analyzing properties of the call patterns has been considered in <ref> [53] </ref>, where the concrete semantics is the call patterns semantics derived according to a local selection rule, as defined in [61, 59]. <p> Recently, the approach was made goal independent [33], by using the -semantics. The result is a denotation consisting of clauses very similar to the one in <ref> [53] </ref>. * It is worth noting that the top-down operational or denotational frameworks [24, 94, 104, 74] do indeed contain a lot of information on the "inter nal" computation details.
Reference: [54] <author> M. Gabbrielli, R. Giacobazzi, and D. Montesi. </author> <title> Modular logic programs over finite domains. </title> <editor> In D. Sacca, editor, </editor> <booktitle> Proc. Eight Italian Conference on Logic Programming, </booktitle> <pages> pages 663-678, </pages> <year> 1993. </year>
Reference-contexts: While this is needed to handle generic (possibly infinite) abstract domains, there exists <ref> [54] </ref> a wide class of compositionally tractable abstract domains (e.g Sharing [70] and Prop [36]) for which a finite description of the compositional abstract semantics can be obtained without a further level of abstraction. <p> In fact, when considering compositionally tractable domains we are essentially considering the -semantics over a finite function free signature. As shown in <ref> [54] </ref>, by imposing such a restriction we can always obtain a finite characterization of the compositional semantics.
Reference: [55] <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 238- 252. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: The observable we consider is then the answer constraint. All the definitions and results on the answer constraint semantics are from <ref> [55] </ref>. The observational program equivalence ' based on answer constraints is the following. Definition 6.1 Let P 1 ; P 2 be CLP programs. <p> O is correct (and fully abstract) w.r.t. answer constraints. Note that this semantics was not considered in the original report on the CLP semantics [72]. The usual AND-compositionality holds for O. Theorem 6.3 <ref> [55] </ref> Let P be a CLP program and G = c 0 2A 1 ; : : : ; A n be any goal.
Reference: [56] <author> M. Gabbrielli and G. Levi. </author> <title> On the Semantics of Logic Programs. </title> <editor> In J. Leach Albert, B. Monien, and M. Rodriguez-Artalejo, editors, </editor> <booktitle> Automata, Languages and Programming, 18th International Colloquium, volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-19. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year> <month> 54 </month>
Reference-contexts: For any set A, A fl denotes the set of finite sequences of elements of A. :: will denote concatenation of sequences and is the empty sequence. 2 The s-semantics approach The aim of the s-semantics approach <ref> [82, 56, 52, 58] </ref> is modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages. The approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains.
Reference: [57] <author> M. Gabbrielli and G. Levi. </author> <title> Unfolding and fixpoint semantics of concurrent constraint programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 105 </volume> <pages> 85-128, </pages> <year> 1992. </year>
Reference-contexts: The corresponding equivalence notions can profitably be used to prove interesting properties of optimization procedures. The approach has finally been applied to concurrent constraint programs as defined in [101], leading to the definition of equivalent top-down and bottom-up semantics, defined as sets of unit clauses <ref> [45, 57] </ref>, which are trees of ask and tell constraints.
Reference: [58] <author> M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> New Semantics Tools for Logic Programs. </title> <editor> In J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Semantics: Foundations and Applications, Proceedings REX Workshop, volume 666 of Lecture Notes in Computer Science, </booktitle> <pages> pages 204-235. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: For any set A, A fl denotes the set of finite sequences of elements of A. :: will denote concatenation of sequences and is the empty sequence. 2 The s-semantics approach The aim of the s-semantics approach <ref> [82, 56, 52, 58] </ref> is modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages. The approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains.
Reference: [59] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming, </booktitle> <pages> pages 131-145. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: These aspects include observable properties such as computed answers, which are modeled by sets of non-ground atoms or unit clauses [47] (see section 3), call patterns, which are modeled by sets of binary clauses [61] (see section 5.3.2), resultants, which are modeled by sets of clauses <ref> [59] </ref> (see section 5.3). Goal-independence is the key issue. <p> This is the syntactic device which allows us to obtain a unique representation for a possibly infinite set of Herbrand models when a unique representative Herbrand model does not exist. Similar domains consisting of clauses have been used to model non-standard observables <ref> [61, 59] </ref> (see section 5.3) and to characterize logic programs with negation [43, 75, 60] (with the aim of delaying the evaluation of negative literals). <p> We obtain a kind of "collecting semantics" which gives the maximum amount of information on computations and allows us to observe all the internal details of SLD-derivations. It is essentially the collecting semantics with selection rule defined in <ref> [61, 59] </ref> extended with the information on the sequence of clauses. As we will discuss later, several semantics useful for program analysis can be obtained by abstraction from O R R (P ). Let us first give the definition of resultant. <p> As a matter of fact, since O R R (P ) is essentially the collecting semantics with selection rule defined in <ref> [61, 59] </ref>, all the theorems proved in [59] can easily be extended to our definition. In particular, if we want a bottom-up definition equivalent to the top-down one, we have to consider "local" selection rules only. <p> As a matter of fact, since O R R (P ) is essentially the collecting semantics with selection rule defined in [61, 59], all the theorems proved in <ref> [59] </ref> can easily be extended to our definition. In particular, if we want a bottom-up definition equivalent to the top-down one, we have to consider "local" selection rules only. <p> For the sake of simplicity, we will give the next definitions in the case of the leftmost selection rule only. The general complete formalization can be found in <ref> [59] </ref>. The intuition behind the immediate consequences operator in definition 5.12 is the following. <p> information (as shown in theorem 5.17) to characterize success, finite and infinite failure. 5.3.2 Other abstractions of the resultants semantics Several other existing equivalent top-down and bottom-up semantics can be derived as abstractions of O R R , including * the resultants semantics defined (for any local rule R) in <ref> [61, 59] </ref>, where we don't care about the sequences of clauses, * the resultants semantics with depth defined (for the leftmost rule) in [11], where a sequence of clauses is abstracted by its length, * the partial answers semantics O PA R defined (for any local rule R) in [61, 59], <p> in <ref> [61, 59] </ref>, where we don't care about the sequences of clauses, * the resultants semantics with depth defined (for the leftmost rule) in [11], where a sequence of clauses is abstracted by its length, * the partial answers semantics O PA R defined (for any local rule R) in [61, 59], where we only keep the heads of the resultants by labeling as partial those heads that were heads of a non-unit resultant, * the call patterns semantics O CP R defined in [61, 59], where (in the case of the leftmost selection rule) we delete all the atoms in <p> length, * the partial answers semantics O PA R defined (for any local rule R) in <ref> [61, 59] </ref>, where we only keep the heads of the resultants by labeling as partial those heads that were heads of a non-unit resultant, * the call patterns semantics O CP R defined in [61, 59], where (in the case of the leftmost selection rule) we delete all the atoms in the clause bodies but the first. 26 We list in the following some of the program properties which can be studied on the above semantics. * The call patterns, i.e the procedure calls, for <p> The above property makes feasible a bottom-up characterization of (possibly abstract versions of) the call patterns. * The partial answers, originally defined in [46], are the answers computed at any intermediate computation step. They can be determined from the partial answers semantics O PA R as follows <ref> [61, 59] </ref>. # is a partial answer for a goal G 1 ; : : :; G n iff there exist fH 1 ; : : : ; H n g 2 O PA R such that # = mgu ((G 1 ; : : : ; G n ); (H <p> As shown in [54], by imposing such a restriction we can always obtain a finite characterization of the compositional semantics. This result can be applied also to the abstraction of other semantics consisting of sets of clauses, as for example the resultants semantics in <ref> [61, 59] </ref>. * If we want to determine abstract properties of the call patterns, we should use a concrete semantics which gives more information on the computation than just the computed answers. Namely, we have to model an observable consisting of all the procedure calls. <p> Namely, we have to model an observable consisting of all the procedure calls. The problem of analyzing properties of the call patterns has been considered in [53], where the concrete semantics is the call patterns semantics derived according to a local selection rule, as defined in <ref> [61, 59] </ref>. The resulting abstract semantics are goal independent, parametric w.r.t. the (local) selection rule and allow us to characterize properties of the correct call patterns [61, 59], which are those call patterns which belong to successful derivations. <p> has been considered in [53], where the concrete semantics is the call patterns semantics derived according to a local selection rule, as defined in <ref> [61, 59] </ref>. The resulting abstract semantics are goal independent, parametric w.r.t. the (local) selection rule and allow us to characterize properties of the correct call patterns [61, 59], which are those call patterns which belong to successful derivations. A similar (yet goal dependent) result can be obtained by using a transformational approach [31, 99]. <p> We have also shown that at least some of the above semantics have successfully been used to solve real problems. As shown in <ref> [59, 52] </ref>, the various semantics are mutually related by means of abstractions. The same relation holds between concrete and abstract semantics. In particular, the generalized semantics of CLP in [66, 65] shows that one can derive from a single semantics several specializations obtained by abstracting the constraints in the program.
Reference: [60] <author> M. Gabbrielli, G. Levi, and D. Turi. </author> <title> A Two Steps Semantics for Logic Programs with Negation. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Proceedings of the Int'l Conf. on Logic Programming and Automated Reasoning, volume 624 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 297-308. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Similar domains consisting of clauses have been used to model non-standard observables [61, 59] (see section 5.3) and to characterize logic programs with negation <ref> [43, 75, 60] </ref> (with the aim of delaying the evaluation of negative literals). The delayed evaluation of open predicates which is typical of O (P ) can easily be generalized to other logic languages, to achieve compositionality w.r.t the union of programs. <p> Essentially the same semantics (in the case of stratified programs) is obtained by the two-steps fixpoint construction in <ref> [60] </ref>. According to the last semantics, at each step we obtain a unique denotation, where some program fragments (the non-positive and the non-stratified fragments, respectively) are left uninterpreted.
Reference: [61] <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint Semantics for Partial Computed Answer Substitutions and Call Patterns. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-99. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: These aspects include observable properties such as computed answers, which are modeled by sets of non-ground atoms or unit clauses [47] (see section 3), call patterns, which are modeled by sets of binary clauses <ref> [61] </ref> (see section 5.3.2), resultants, which are modeled by sets of clauses [59] (see section 5.3). Goal-independence is the key issue. <p> This is the syntactic device which allows us to obtain a unique representation for a possibly infinite set of Herbrand models when a unique representative Herbrand model does not exist. Similar domains consisting of clauses have been used to model non-standard observables <ref> [61, 59] </ref> (see section 5.3) and to characterize logic programs with negation [43, 75, 60] (with the aim of delaying the evaluation of negative literals). <p> We obtain a kind of "collecting semantics" which gives the maximum amount of information on computations and allows us to observe all the internal details of SLD-derivations. It is essentially the collecting semantics with selection rule defined in <ref> [61, 59] </ref> extended with the information on the sequence of clauses. As we will discuss later, several semantics useful for program analysis can be obtained by abstraction from O R R (P ). Let us first give the definition of resultant. <p> As a matter of fact, since O R R (P ) is essentially the collecting semantics with selection rule defined in <ref> [61, 59] </ref>, all the theorems proved in [59] can easily be extended to our definition. In particular, if we want a bottom-up definition equivalent to the top-down one, we have to consider "local" selection rules only. <p> The proofs of both theorems can easily be obtained from the proofs of Theorems 23 and Lemma 22 in <ref> [61] </ref>. Theorem 5.13 Let P be positive program. Then O R (P ) = F R (P ). Theorem 5.14 Let P be a positive program and G = A 1 ; : : : ; A m be a goal. <p> information (as shown in theorem 5.17) to characterize success, finite and infinite failure. 5.3.2 Other abstractions of the resultants semantics Several other existing equivalent top-down and bottom-up semantics can be derived as abstractions of O R R , including * the resultants semantics defined (for any local rule R) in <ref> [61, 59] </ref>, where we don't care about the sequences of clauses, * the resultants semantics with depth defined (for the leftmost rule) in [11], where a sequence of clauses is abstracted by its length, * the partial answers semantics O PA R defined (for any local rule R) in [61, 59], <p> in <ref> [61, 59] </ref>, where we don't care about the sequences of clauses, * the resultants semantics with depth defined (for the leftmost rule) in [11], where a sequence of clauses is abstracted by its length, * the partial answers semantics O PA R defined (for any local rule R) in [61, 59], where we only keep the heads of the resultants by labeling as partial those heads that were heads of a non-unit resultant, * the call patterns semantics O CP R defined in [61, 59], where (in the case of the leftmost selection rule) we delete all the atoms in <p> length, * the partial answers semantics O PA R defined (for any local rule R) in <ref> [61, 59] </ref>, where we only keep the heads of the resultants by labeling as partial those heads that were heads of a non-unit resultant, * the call patterns semantics O CP R defined in [61, 59], where (in the case of the leftmost selection rule) we delete all the atoms in the clause bodies but the first. 26 We list in the following some of the program properties which can be studied on the above semantics. * The call patterns, i.e the procedure calls, for <p> The above property makes feasible a bottom-up characterization of (possibly abstract versions of) the call patterns. * The partial answers, originally defined in [46], are the answers computed at any intermediate computation step. They can be determined from the partial answers semantics O PA R as follows <ref> [61, 59] </ref>. # is a partial answer for a goal G 1 ; : : :; G n iff there exist fH 1 ; : : : ; H n g 2 O PA R such that # = mgu ((G 1 ; : : : ; G n ); (H <p> As shown in [54], by imposing such a restriction we can always obtain a finite characterization of the compositional semantics. This result can be applied also to the abstraction of other semantics consisting of sets of clauses, as for example the resultants semantics in <ref> [61, 59] </ref>. * If we want to determine abstract properties of the call patterns, we should use a concrete semantics which gives more information on the computation than just the computed answers. Namely, we have to model an observable consisting of all the procedure calls. <p> Namely, we have to model an observable consisting of all the procedure calls. The problem of analyzing properties of the call patterns has been considered in [53], where the concrete semantics is the call patterns semantics derived according to a local selection rule, as defined in <ref> [61, 59] </ref>. The resulting abstract semantics are goal independent, parametric w.r.t. the (local) selection rule and allow us to characterize properties of the correct call patterns [61, 59], which are those call patterns which belong to successful derivations. <p> has been considered in [53], where the concrete semantics is the call patterns semantics derived according to a local selection rule, as defined in <ref> [61, 59] </ref>. The resulting abstract semantics are goal independent, parametric w.r.t. the (local) selection rule and allow us to characterize properties of the correct call patterns [61, 59], which are those call patterns which belong to successful derivations. A similar (yet goal dependent) result can be obtained by using a transformational approach [31, 99].
Reference: [62] <author> H. Gaifman and E. Shapiro. </author> <title> Fully abstract compositional semantics for logic programs. </title> <booktitle> In Proc. Sixteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 134-142. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Ex amples are the compositional semantics for positive logic programs <ref> [62, 63, 22, 21] </ref>, whose domains are sets of clauses (see section 4), the semantic kernel for normal logic programs [43, 75], whose domains are sets of negative normal clauses (see section 6.3), the model state semantics for disjunctive logic programs [98, 90], whose domains are sets of positive disjunctive ground <p> Note also that O 2 is the semantics considered in <ref> [30, 42, 62] </ref> and called c-semantics in [47]. We will now compare the three semantics on an example. <p> On one side, it correctly models computed answers. On the other side, it has nice properties also from the model-theoretic viewpoint. This can be shown by considering the properties of the (atomic logical consequences) semantics O 2 and the relation between O and O 2 . Theorem 3.25 <ref> [47, 62] </ref> Let P be a positive program and A be a (possibly non-ground) atom. Then P j= 8A iff A 2 O 2 (P ). Theorem 3.26 [47] Let P be a positive program. <p> Gaifman and Shapiro first suggested to use sets of (equivalence classes of) clauses as a representation of one such a function, modeling the successful derivations <ref> [62] </ref> and the computed answers [63] observables. This idea fits quite naturally within the s-semantics approach since the semantic domains are syntactic objects, i.e. programs. The -semantics [22, 21] is similar to one of the semantics in [62], yet it is defined according to the general s-semantics approach. <p> clauses as a representation of one such a function, modeling the successful derivations <ref> [62] </ref> and the computed answers [63] observables. This idea fits quite naturally within the s-semantics approach since the semantic domains are syntactic objects, i.e. programs. The -semantics [22, 21] is similar to one of the semantics in [62], yet it is defined according to the general s-semantics approach. It was originally defined for a more general composition operator [ , defined on -open programs.
Reference: [63] <author> H. Gaifman and E. Shapiro. </author> <title> Proof theory and semantics of logic programs. </title> <booktitle> In Proc. Fourth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 50-62. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: Ex amples are the compositional semantics for positive logic programs <ref> [62, 63, 22, 21] </ref>, whose domains are sets of clauses (see section 4), the semantic kernel for normal logic programs [43, 75], whose domains are sets of negative normal clauses (see section 6.3), the model state semantics for disjunctive logic programs [98, 90], whose domains are sets of positive disjunctive ground <p> Gaifman and Shapiro first suggested to use sets of (equivalence classes of) clauses as a representation of one such a function, modeling the successful derivations [62] and the computed answers <ref> [63] </ref> observables. This idea fits quite naturally within the s-semantics approach since the semantic domains are syntactic objects, i.e. programs. The -semantics [22, 21] is similar to one of the semantics in [62], yet it is defined according to the general s-semantics approach.
Reference: [64] <author> M. Gelfond and V. Lifschitz. </author> <title> The Stable Model Semantics for Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1070-1079. </pages> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1988. </year>
Reference-contexts: of the completion of P . 4 The same construction was independently proposed in [25]. 5 A negative clause [75] is a normal clause of the form A : :B 1 ; : : : ; :B n . 31 It is also strongly related to the stable model semantics <ref> [64] </ref> of P , as shown by the following very important theorem. Theorem 6.20 [43] Every Herbrand model of the completion of F k (P ) is a stable model of P .
Reference: [65] <author> R. Giacobazzi. </author> <title> Semantic Aspects of Logic Program Analysis. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: w.r.t. several non-monotonic semantics (as, for example, the stable model and the well-founded model semantics), by showing that it preserves the semantic kernel considered in section 6.3. 7.2 Program analysis In the area of program analysis, the s-semantics has been used as a foundation of several frameworks for abstract interpretation <ref> [13, 65, 77, 31] </ref>. Abstract interpretation is inherently semantics sensitive and different semantic definition styles lead to different approaches to program analysis. In the case of logic programs (see [38] for a broad overview), two main approaches exist, namely the top-down and the bottom-up ones [94]. <p> As shown in [59, 52], the various semantics are mutually related by means of abstractions. The same relation holds between concrete and abstract semantics. In particular, the generalized semantics of CLP in <ref> [66, 65] </ref> shows that one can derive from a single semantics several specializations obtained by abstracting the constraints in the program. One interesting open research problem, which is currently under investigation, is whether the approach can be extended to cope with the various concrete observables.
Reference: [66] <author> R. Giacobazzi, S. K. Debray, and G. Levi. </author> <title> A Generalized Semantics for Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 581-591, </pages> <year> 1992. </year> <month> 55 </month>
Reference-contexts: Moreover O (P ) is a -model of P . It is straightforward to extend also the compositional semantics. The equivalent top-down and bottom-up semantics modeling the answer constraints have also an elegant algebraic characterization oriented towards abstract interpretation <ref> [66] </ref>, that will be discussed in section 7.2. The s-semantics of CLP and its compositional version have been applied to obtain the semantics of two new instances of the CLP scheme, namely CLP (H=E ) and CLP (AD). <p> If the abstraction satisfies suitable properties <ref> [70, 66] </ref>, we have two equivalent methods for computing the goal independent abstract denotation O ff (o) (P ) of the program P . * The result of the analysis for a specific goal G can be determined by exploiting the AND-compositionality property of all the semantics defined by the s-semantics <p> When applied to CLP , the above approach leads to a framework where abstraction simply means abstraction of the constraint system. The construction is based on a generalized algebraic semantics 8 <ref> [66] </ref>, defined in terms of a constraint system and a general (constraint system independent) notion of denotation, which is as usual characterized both top-down and bottom-up. Different abstract semantics can be defined by choosing suitable abstract constraint systems. <p> As shown in [59, 52], the various semantics are mutually related by means of abstractions. The same relation holds between concrete and abstract semantics. In particular, the generalized semantics of CLP in <ref> [66, 65] </ref> shows that one can derive from a single semantics several specializations obtained by abstracting the constraints in the program. One interesting open research problem, which is currently under investigation, is whether the approach can be extended to cope with the various concrete observables.
Reference: [67] <author> R. Giacobazzi and L. Ricci. </author> <title> Pipeline Optimizations in AND-Parallelism by Abstract Interpretation. </title> <editor> In D. H. D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. Seventh Int'l Conf. on Logic Programming, </booktitle> <pages> pages 291-305. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: An instance of the framework consists in the specialization of a set of basic abstract operators, i.e. abstract unification, abstract substitution application and abstract union. Instances have been defined for ground dependency analysis [13], type inference [12] and for analysis of properties related to AND-parallelism <ref> [67, 68] </ref>. The emphasis in [13] is on the bottom-up definition of an abstract 45 model, i.e. a goal independent approximation of the concrete denotation.
Reference: [68] <author> R. Giacobazzi and L. Ricci. </author> <title> Detecting Determinate Computations by a Bottom-up Abstract Interpretation. </title> <editor> In B. Krieg-Bruckner, editor, </editor> <booktitle> Pro-ceeedings ESOP '92, volume 582 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-181. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: An instance of the framework consists in the specialization of a set of basic abstract operators, i.e. abstract unification, abstract substitution application and abstract union. Instances have been defined for ground dependency analysis [13], type inference [12] and for analysis of properties related to AND-parallelism <ref> [67, 68] </ref>. The emphasis in [13] is on the bottom-up definition of an abstract 45 model, i.e. a goal independent approximation of the concrete denotation.
Reference: [69] <author> P. M. Hill and J. W. Lloyd. </author> <title> Analysis of meta-programs. </title> <editor> In H. Abram-son and M.H. Rogers, editors, </editor> <booktitle> Meta-programming in Logic Programming, </booktitle> <pages> pages 23-51. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: The problem is related to differences in the languages used at the metalevel and at the object level and was solved either by considering typed programs <ref> [69] </ref>, or by considering language independent programs only [37]. If we consider the s-semantics of P and V P , due to the property stated by theorem 3.11, the language problem disappears and we can easily prove the following theorem.
Reference: [70] <author> D. Jacobs and A. Langen. </author> <title> Static Analysis of Logic Programs for Independent AND Parallelism. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):291-314, 1992. 
Reference-contexts: If the abstraction satisfies suitable properties <ref> [70, 66] </ref>, we have two equivalent methods for computing the goal independent abstract denotation O ff (o) (P ) of the program P . * The result of the analysis for a specific goal G can be determined by exploiting the AND-compositionality property of all the semantics defined by the s-semantics <p> While this is needed to handle generic (possibly infinite) abstract domains, there exists [54] a wide class of compositionally tractable abstract domains (e.g Sharing <ref> [70] </ref> and Prop [36]) for which a finite description of the compositional abstract semantics can be obtained without a further level of abstraction. In fact, when considering compositionally tractable domains we are essentially considering the -semantics over a finite function free signature.
Reference: [71] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: The information in the frontiers can also be useful to get a fixpoint characterization of constructive negation. 6 Extending the s-semantics to other logic lan guages 6.1 Constraint logic programs The s-semantics extends quite naturally to the Constraint Logic Programming paradigm as defined by Jaffar and Lassez <ref> [71] </ref>, where constraints are interpreted over an algebraic structure A. A constraint c is solvable iff there exists a valuation # (solution) mapping variables to elements of the domain of A, such that c# is true in A.
Reference: [72] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <type> Technical report, </type> <institution> Department of Computer Science, Monash University, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: The existence of a syntactic representation for ~ depends on A (e.g. variance for the Herbrand universe). O is correct (and fully abstract) w.r.t. answer constraints. Note that this semantics was not considered in the original report on the CLP semantics <ref> [72] </ref>. The usual AND-compositionality holds for O. Theorem 6.3 [55] Let P be a CLP program and G = c 0 2A 1 ; : : : ; A n be any goal.
Reference: [73] <author> G. Janssens and M. Bruynooghe. </author> <title> Deriving descriptions of possible values of program variables by means of abstract interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):205-258, 1992. 
Reference-contexts: As we will argue later, the application of the s-semantics approach to abstract interpretation shows that the real issue is goal dependency vs. goal independency rather than top-down vs. bottom-up. Another relevant feature of the analysis method is its ability to determine call pattern information <ref> [24, 73, 94] </ref>, i.e. information about the procedure calls (atoms selected in an SLD-derivation). The ability to determine call patterns is also usually associated to goal dependent top-down methods.
Reference: [74] <author> N. D. Jones and H. Stndergaard. </author> <title> A Semantics-based Framework for the Abstract Interpretation of Prolog. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 123-142. </pages> <publisher> Ellis Horwood Ltd, </publisher> <year> 1987. </year>
Reference-contexts: Recently, the approach was made goal independent [33], by using the -semantics. The result is a denotation consisting of clauses very similar to the one in [53]. * It is worth noting that the top-down operational or denotational frameworks <ref> [24, 94, 104, 74] </ref> do indeed contain a lot of information on the "inter nal" computation details. By choosing a semantics like the one of section 47 5.3, we can model the same observables and still get a goal independent top-down and bottom-up construction of the abstract model.
Reference: [75] <author> K. Kanchanasut and P. Stuckey. </author> <title> Transforming Normal Logic Programs to Constraint Logic Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 105 </volume> <pages> 27-56, </pages> <year> 1992. </year>
Reference-contexts: Ex amples are the compositional semantics for positive logic programs [62, 63, 22, 21], whose domains are sets of clauses (see section 4), the semantic kernel for normal logic programs <ref> [43, 75] </ref>, whose domains are sets of negative normal clauses (see section 6.3), the model state semantics for disjunctive logic programs [98, 90], whose domains are sets of positive disjunctive ground clauses (see section 6.2). <p> Similar domains consisting of clauses have been used to model non-standard observables [61, 59] (see section 5.3) and to characterize logic programs with negation <ref> [43, 75, 60] </ref> (with the aim of delaying the evaluation of negative literals). The delayed evaluation of open predicates which is typical of O (P ) can easily be generalized to other logic languages, to achieve compositionality w.r.t the union of programs. <p> As was the case for the compositional semantics of section 4, we obtain a unique denotation which syntactically represents all the relevant models. A similar mechanism, related to normal programs, will be considered in the next section. 6.3 Normal logic programs We consider here the semantic kernel defined in <ref> [75] </ref> as a first step in the transformation of normal logic programs into constraint logic programs. It is a fixpoint construction which generalizes to the non-ground case the fixpoint semantics first proposed in [43] 4 . <p> The semantic kernel is then a (possibly infinite) program consisting of negative clauses only 5 . The result of the transformation can be viewed as a -interpretation (called quasi-interpretation in <ref> [75] </ref>). Definition 6.16 (quasi-interpretation) [75] Let P be a normal program. A quasi-interpretation for P is a set of negative clauses over the alphabet of P modulo variance. The semantic kernel is the least fixpoint of the immediate consequences operator T k P which maps quasi-interpretations onto quasi-interpretations. <p> The semantic kernel is then a (possibly infinite) program consisting of negative clauses only 5 . The result of the transformation can be viewed as a -interpretation (called quasi-interpretation in <ref> [75] </ref>). Definition 6.16 (quasi-interpretation) [75] Let P be a normal program. A quasi-interpretation for P is a set of negative clauses over the alphabet of P modulo variance. The semantic kernel is the least fixpoint of the immediate consequences operator T k P which maps quasi-interpretations onto quasi-interpretations. Definition 6.17 (immediate consequences operator) [75] Let <p> (quasi-interpretation) <ref> [75] </ref> Let P be a normal program. A quasi-interpretation for P is a set of negative clauses over the alphabet of P modulo variance. The semantic kernel is the least fixpoint of the immediate consequences operator T k P which maps quasi-interpretations onto quasi-interpretations. Definition 6.17 (immediate consequences operator) [75] Let P be a normal program and I be a quasi-interpretation. <p> 9A : A 1 ; : : : ; A n ; :B 1 ; : : : ; :B m 2 P i : :B i h i 2 I; i = 1; : : : ; n; 1 ; : : :; A 0 Definition 6.18 (semantic kernel) <ref> [75] </ref> F k (P ) = T k P " !. The semantic kernel is just an intermediate step in the process of defining a semantics for normal programs. <p> The semantic kernel is just an intermediate step in the process of defining a semantics for normal programs. It can be viewed as a compact representation of a set of models of the normal program, as shown by the following theorem. Theorem 6.19 <ref> [75] </ref> Every model of the completion of F k (P ) is a model of the completion of P . 4 The same construction was independently proposed in [25]. 5 A negative clause [75] is a normal clause of the form A : :B 1 ; : : : ; :B <p> Theorem 6.19 <ref> [75] </ref> Every model of the completion of F k (P ) is a model of the completion of P . 4 The same construction was independently proposed in [25]. 5 A negative clause [75] is a normal clause of the form A : :B 1 ; : : : ; :B n . 31 It is also strongly related to the stable model semantics [64] of P , as shown by the following very important theorem.
Reference: [76] <author> T. Kawamura and T. Kanamori. </author> <title> Preservation of Stronger Equivalence in Unfold/Fold Logic Programming Transformation. </title> <booktitle> In Proc. Int'l Conf. on Fifth Generation Computer Systems, </booktitle> <pages> pages 413-422. </pages> <institution> Institute for New Generation Computer Technology, </institution> <address> Tokyo, </address> <year> 1988. </year>
Reference-contexts: This is the reason why the need for a different formal semantics was recognized by many authors, giving rise to several new definitions [30, 49, 113, 42]. The need for better semantics was also recognized in the case of semantics-based abstract interpretation [94] and transformation <ref> [76] </ref>. 1.4 Compositionality In addition to the problem related to modeling the computed answers observational equivalences, there exists another problem with the least Herbrand model semantics. Namely a very important property, i.e. compositionality, does not hold. <p> Most of the transformation techniques are proved to be safe w.r.t. the declarative semantics only, thus failing to capture the safeness w.r.t. the more complex observable behavior. In some cases the observational equivalences related to computed answers <ref> [76, 89] </ref> and to finite failures [102] are considered. Usually proving that the transformation preserves the observational equivalence is rather complex (see, for example, the proofs of the partial evaluation theorems in [89]).
Reference: [77] <author> R. Kemp and G. Ringwood. </author> <title> An Algebraic Framework for the Abstract Interpretation of Logic Programs. </title> <editor> In S. K. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 506-520. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year> <month> 56 </month>
Reference-contexts: w.r.t. several non-monotonic semantics (as, for example, the stable model and the well-founded model semantics), by showing that it preserves the semantic kernel considered in section 6.3. 7.2 Program analysis In the area of program analysis, the s-semantics has been used as a foundation of several frameworks for abstract interpretation <ref> [13, 65, 77, 31] </ref>. Abstract interpretation is inherently semantics sensitive and different semantic definition styles lead to different approaches to program analysis. In the case of logic programs (see [38] for a broad overview), two main approaches exist, namely the top-down and the bottom-up ones [94].
Reference: [78] <author> H. J. Komorowski. </author> <title> Partial evaluation as a means for inferencing data structures in an applicative language: A theory and implementation in the case of PROLOG. </title> <booktitle> In Ninth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 255-267. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: n ; c = p ( ~ X)fl# : B 1 ; : : : ; B n g Note that O (P ) is a set of resultants [89, 3] obtained from goals of the form p ( ~ X) in P and is strongly related to partial evaluation <ref> [78] </ref> 2 . The set of clauses Id in the previous definition is used to delay the evaluation of open atoms. This is a trick which allows us to obtain a denotation which is independent from the (fair) selection rule. <p> ) and O R R (P ) (the resultants semantics of P ) are all -models of P . 24 As already mentioned, both the resultants semantics and the compositional semantics of section 4 are strongly related to partial evaluation, a program transformation technique first applied to logic programs in <ref> [78] </ref> and later fully formalized in [89]. The result of partial evaluation is a (finite) set of resultants, obtained from a program P and an atomic goal A. The selected set of resultants corresponds to a "cut" of the SLD-tree. <p> The same operation is not safe when the computed answers semantics is considered. In fact the answer substitution X=[a; b] would be missed in the transformed program. 43 As a matter of fact, all the program transformation techniques, such as unfold/fold [107] and partial evaluation <ref> [78] </ref>, are defined so as to preserve some observational equivalences. In most of these techniques, the relevant observables are computed answers (and sometimes finite failures).
Reference: [79] <author> G. Kreisel and J. L. Krivine. </author> <title> Elements of Mathematical Logic (Model Theory). </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1967. </year>
Reference-contexts: Moreover, we will denote the equivalence class of an atom A by A itself. Note that -interpretations of definition 3.3 are not Herbrand interpretations, yet are interpretations defined on the Herbrand universe. These interpretations were called canonical realizations in <ref> [100, 79] </ref>. Theorem 3.4 shows that O actually models computed answer substitutions and that it is fully abstract, since P 1 ' P 2 implies O (P 1 ) = O (P 2 ). Theorem 3.4 [47] Let P 1 ; P 2 be positive programs.
Reference: [80] <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: The function H now maps -interpretations onto partial A-interpretations [50, 51]. The denotation O CN (P ) of a normal CLP program P has two equivalent top-down and bottom-up characterizations and is correct 32 w.r.t. the answer constraints observable. Finally, H (O CN (P )) is Kunen's seman-tics <ref> [80] </ref>, namely P " !, where P is Fitting's map on partial A-interpretations [50]. It is worth noting that a similar bottom-up characterization can be obtained by the non-ground extension of P defined in [105]. 6.5 PROLOG We first consider pure PROLOG programs, i.e. programs without cut, built-in's or negation.
Reference: [81] <author> J.-L. Lassez and M. J. Maher. </author> <title> Closures and Fairness in the Semantics of Programming Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 29 </volume> <pages> 167-184, </pages> <year> 1984. </year>
Reference-contexts: As a matter of fact two [-compositional semantics (correct w.r.t. the successful derivations observable) are the semantics in which the denotation of P is the associated immediate consequences operator T P and the functional semantics defined in <ref> [81] </ref>. Gaifman and Shapiro first suggested to use sets of (equivalence classes of) clauses as a representation of one such a function, modeling the successful derivations [62] and the computed answers [63] observables.
Reference: [82] <author> G. Levi. </author> <title> Models, Unfolding Rules and Fixpoint Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1649-1665. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: For any set A, A fl denotes the set of finite sequences of elements of A. :: will denote concatenation of sequences and is the empty sequence. 2 The s-semantics approach The aim of the s-semantics approach <ref> [82, 56, 52, 58] </ref> is modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages. The approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> The link between the top-down and the bottom-up constructions is given by an unfolding operator <ref> [82, 83] </ref>. The 6 equivalence proofs can be stated in terms of simple properties of the unfolding and the immediate consequences operators [41]. It is worth noting that the aim of the approach is not defining a new notion of model. <p> If this equivalence holds, the immediate consequences operator T P models the observable properties and may be used for bottom-up program analysis. Concise and elegant equivalence proofs can be obtained by introducing the intermediate notion of unfolding semantics U <ref> [82, 83] </ref>. Unfolding is a well known program transformation rule which allows us to replace procedure calls by procedure definitions. The unfolding of the clauses of program P using the procedure definitions in program I is denoted by unf P (I). <p> The T P operator can then effectively be used for the construction of bottom-up proofs. The equivalence between F (P ) and O (P ) is proved by introducing the unfolding semantics. Definition 3.16 <ref> [82, 83] </ref> Let P and Q be positive programs. Then the unfolding of P w.r.t.
Reference: [83] <author> G. Levi and P. Mancarella. </author> <title> The Unfolding Semantics of Logic Programs. </title> <type> Technical Report TR-13/88, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1988. </year>
Reference-contexts: The link between the top-down and the bottom-up constructions is given by an unfolding operator <ref> [82, 83] </ref>. The 6 equivalence proofs can be stated in terms of simple properties of the unfolding and the immediate consequences operators [41]. It is worth noting that the aim of the approach is not defining a new notion of model. <p> If this equivalence holds, the immediate consequences operator T P models the observable properties and may be used for bottom-up program analysis. Concise and elegant equivalence proofs can be obtained by introducing the intermediate notion of unfolding semantics U <ref> [82, 83] </ref>. Unfolding is a well known program transformation rule which allows us to replace procedure calls by procedure definitions. The unfolding of the clauses of program P using the procedure definitions in program I is denoted by unf P (I). <p> The T P operator can then effectively be used for the construction of bottom-up proofs. The equivalence between F (P ) and O (P ) is proved by introducing the unfolding semantics. Definition 3.16 <ref> [82, 83] </ref> Let P and Q be positive programs. Then the unfolding of P w.r.t. <p> Therefore it is possible to define the immediate consequences operator in terms of the unfolding rule. Theorem 3.21 was proved in <ref> [83] </ref>. An alternative proof is given in [41] by using lemma 3.20. A direct proof of F (P ) = O (P ) was first given in [47]. Definition 3.17 [83, 41] Let P be a positive program. <p> Theorem 3.21 was proved in [83]. An alternative proof is given in [41] by using lemma 3.20. A direct proof of F (P ) = O (P ) was first given in [47]. Definition 3.17 <ref> [83, 41] </ref> Let P be a positive program. Then we define the collection of programs P 0 = P and the collection of -interpretations I i (P ) = fA j A 2 B and A 2 P i g. <p> The unfolding semantics U (P ) of the program P is defined as U (P ) = i=0;1;::: Theorem 3.18 (equivalence of unfolding and operational semantics) <ref> [83, 41] </ref> Let P be a positive program. Then U (P ) = O (P ). Definition 3.19 [41] Let P; Q be positive programs. Then T P is compatible with unf P (Q) iff T unf P (Q) (;) = T Q (;)). <p> Since T P is compatible with the unfolding rule and T P (I) = unf P (I) (by definition of the unfolding rule), then T P " (i + 1) = T P i (;) = unf P i (;). Therefore, Theorem 3.21 (equivalence of fixpoint and operational semantics) <ref> [83, 41] </ref> Let P be a positive program. Then F (P ) = U (P ) = O (P ). Theorem 3.21 shows that F (P ) is the fully abstract semantics w.r.t. com puted answer substitutions.
Reference: [84] <author> G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Failure and success made symmetric. </title> <editor> In S. K. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 3-22. </pages> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1990. </year>
Reference-contexts: It can be shown that the non-ground finite failure set as defined in <ref> [84] </ref> is indeed correct w.r.t. ' F F . However, the AND-compositionality property does not hold, i.e. it is not possible to decide whether a conjunctive goal finitely fails by just looking at the non-ground finite failure set.
Reference: [85] <author> G. Levi and D. Ramundo. </author> <title> A formalization of metaprogramming for real. </title> <editor> In D. S. Warren, editor, </editor> <booktitle> Proc. Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 354-373. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: Definition 3.9 [37] A program P with underlying language L P is language independent iff, for any extension L 0 of L P , its least L 0 -Herbrand model is equal to its least L P -Herbrand model. 11 Theorem 3.10 <ref> [85] </ref> Let P be a program. Then P is language independent iff O (P ) = O 1 (P ). A program P belongs to this class only if any goal in P returns ground answers. <p> If L P is the language underlying program P , the following theorem shows the language independence property. Note that the same property does not hold for other variable-based semantics, such as those in [30, 49]. Theorem 3.11 <ref> [85] </ref> If P is a positive program, then O L P (P ) = O L 0 (P ) for any extension L 0 of L P . <p> program properties. 8 This semantics generalizes the approach in [39] which gives an algebraic description of a class of fixpoint semantics (including ground and non-ground concrete semantics, and various abstract semantics) in terms of abstract notions of "instance" and "normalization". 48 7.4 Metaprogramming We consider here a formalization of metaprogramming <ref> [85] </ref> with the non-ground metalevel representation of object level variables. In the case of the vanilla metainterpreter, let P be a program and P M be its non-ground metalevel representation. <p> If we consider the s-semantics of P and V P , due to the property stated by theorem 3.11, the language problem disappears and we can easily prove the following theorem. Theorem 7.2 <ref> [85, 96] </ref> Let P be a positive program and V P be its vanilla metain-terpreted version, where the proof procedure is defined by the relation demo. <p> Then, for every n-adic predicate symbol p in P , demo (p (t 1 ; : : : ; t n )) 2 O (V P ) iff p (t 1 ; : : : ; t n ) 2 O (P ). A similar result was also proved <ref> [85] </ref> for a metainterpreter defining the inheritance mechanism described in [18]. 8 Conclusions We have shown several semantics, which exhibit similar properties and which are all defined according to the same methodology.
Reference: [86] <author> G. Levi and G. Sardu. </author> <title> Partial Evaluation of metaprograms in a multiple worlds logic language. </title> <journal> New Generation Computing, </journal> <volume> 6 </volume> <pages> 227-247, </pages> <year> 1988. </year>
Reference-contexts: In most of these techniques, the relevant observables are computed answers (and sometimes finite failures). There exists at least one technique, the partial evaluation of "open" programs <ref> [111, 106, 86] </ref>, whose aim is to preserve a [-compositional program equivalence 7 . Most of the transformation techniques are proved to be safe w.r.t. the declarative semantics only, thus failing to capture the safeness w.r.t. the more complex observable behavior.
Reference: [87] <author> J. W. Lloyd. </author> <title> Declarative error diagnosis. </title> <journal> New Generation Computing, </journal> <volume> 5(2) </volume> <pages> 133-154, </pages> <year> 1987. </year>
Reference-contexts: The ability to use the CLP interpreter to analyze CLP programs has been exploited in some interesting applications [8]. 7.3 Declarative debugging The application of the s-semantics approach to semantics-based (declarative) debugging [16] has the following features when compared to the existing methods <ref> [103, 49, 87] </ref>. * The s-semantics, when taken as specification of the intended semantics, allows us to obtain a more accurate diagnosis than the one that can be obtained using the least Herbrand model or the c-semantics (which is used in [49]). * The properties of the s-semantics (equivalent top-down goal
Reference: [88] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: Finally, section 7 shows some applications of the approach, in the areas of program transformation, semantics-based analysis and metaprogramming. 1.6 Preliminaries The reader is assumed to be familiar with the terminology of and the basic results in the semantics of logic programs <ref> [88, 3] </ref>. Let L be the first order language defined by the signature S consisting of a set C of data constructors, a finite set P of predicate symbols, a denumerable set V of variable symbols. <p> We show our construction in a language independent way by considering three separate steps, which roughly correspond to the three standard semantics of logic programs <ref> [109, 88, 3] </ref>. The first step is related to the operational semantics and leads to the definition of the structure of -interpretations. The second step is concerned with the fixpoint semantics. <p> Then P is language independent iff O (P ) = O 1 (P ). A program P belongs to this class only if any goal in P returns ground answers. It is therefore essentially the class of allowed positive programs <ref> [88] </ref> and does not contain any program able to compute partial data structures. The success set semantics does not need to be the same as the s-semantics in order to be correct with respect to computed answers, rather it needs to be isomorphic. <p> Then # is a correct answer substitution for G in P (i.e. P j= 8 (A 1 ^ : : : ^ A n )#) iff all the atoms A i # are instances of atoms in O (P ). Note that, as shown in <ref> [88] </ref>, correct answer substitutions cannot be determined from the least Herbrand model. 4 A compositional semantics The semantics defined in section 3 is compositional w.r.t. the AND operator. We consider here [-compositionality, i.e. composition w.r.t. to union of programs.
Reference: [89] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial Evaluation in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 217-242, </pages> <year> 1991. </year>
Reference-contexts: D 1 ; : : : ; D m ; P fl ;R B 1 ; : : : ; B n ; c = p ( ~ X)fl# : B 1 ; : : : ; B n g Note that O (P ) is a set of resultants <ref> [89, 3] </ref> obtained from goals of the form p ( ~ X) in P and is strongly related to partial evaluation [78] 2 . The set of clauses Id in the previous definition is used to delay the evaluation of open atoms. <p> In principle one could be interested in the complete information about the SLD-derivation, namely the sequences of goals, most general unifiers and variants of clauses. The resultants, introduced in <ref> [89] </ref> in the framework of partial evaluation, are a compact representation of the relation between the initial goal and the current hgoal; mgui pair. They are useful (see [3]) to formalize the properties of SLD-resolution. <p> ) (the resultants semantics of P ) are all -models of P . 24 As already mentioned, both the resultants semantics and the compositional semantics of section 4 are strongly related to partial evaluation, a program transformation technique first applied to logic programs in [78] and later fully formalized in <ref> [89] </ref>. The result of partial evaluation is a (finite) set of resultants, obtained from a program P and an atomic goal A. The selected set of resultants corresponds to a "cut" of the SLD-tree. A is atomic but not necessarily of the form p ( ~ X). <p> The aim of partial evaluation is in fact to obtain a specialization of P for the goal A. The construction of the compositional semantics of section 4 and of the resultants semantics is based on goals of the form p ( ~ X) which trivially satisfy the A-closedness condition <ref> [89] </ref>, which guarantees the completeness of partial evaluation. <p> Most of the transformation techniques are proved to be safe w.r.t. the declarative semantics only, thus failing to capture the safeness w.r.t. the more complex observable behavior. In some cases the observational equivalences related to computed answers <ref> [76, 89] </ref> and to finite failures [102] are considered. Usually proving that the transformation preserves the observational equivalence is rather complex (see, for example, the proofs of the partial evaluation theorems in [89]). <p> In some cases the observational equivalences related to computed answers [76, 89] and to finite failures [102] are considered. Usually proving that the transformation preserves the observational equivalence is rather complex (see, for example, the proofs of the partial evaluation theorems in <ref> [89] </ref>). The same goal could more easily be achieved by proving that the transformation preserves a semantics which correctly models the relevant observable. The proof can in fact be based on general theorems (such as AN D-compositionality) and on powerful technical tools such as the specialized immediate consequences operators.
Reference: [90] <author> J. Lobo, J. Minker, and A. Rajasekar. </author> <title> Foundations of Disjunctive Logic Programming. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: amples are the compositional semantics for positive logic programs [62, 63, 22, 21], whose domains are sets of clauses (see section 4), the semantic kernel for normal logic programs [43, 75], whose domains are sets of negative normal clauses (see section 6.3), the model state semantics for disjunctive logic programs <ref> [98, 90] </ref>, whose domains are sets of positive disjunctive ground clauses (see section 6.2). The overall approach is called in this paper the s-semantics approach after the s-semantics [47], which was the first example of a semantic construction featuring some of the above properties. <p> The denotation correctly models computed answers, finite failures and deadlocks, even if it is not [-compositional and fully abstract and there is no model-theoretic semantics. 6.2 Disjunctive logic programs Disjunctive logic programs <ref> [90] </ref>, where clause heads are disjunctions of atoms, have in general more than one minimal Herbrand model. We can get a unique model characterization by capturing the disjunctive consequences as a set of positive disjunctive ground clauses 3 (-interpretations, called states in [98]), defined over the disjunctive Herbrand base.
Reference: [91] <author> M. J. Maher. </author> <title> Equivalences of Logic Programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 627-658. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year> <month> 57 </month>
Reference-contexts: One can use model-theoretic properties, such as the set of models, the set of logical consequences or the least Herbrand model, and proof-theoretic properties, such as the set of derivable atoms. A systematic comparison of several program equivalences has been worked out in <ref> [91] </ref>. In particular, [91] shows the relations between equivalences based on purely logical properties and equivalences induced on programs by more "operational" aspects. For example, subsumption equivalence of two programs is shown to correspond to the equality of their T P operators. <p> One can use model-theoretic properties, such as the set of models, the set of logical consequences or the least Herbrand model, and proof-theoretic properties, such as the set of derivable atoms. A systematic comparison of several program equivalences has been worked out in <ref> [91] </ref>. In particular, [91] shows the relations between equivalences based on purely logical properties and equivalences induced on programs by more "operational" aspects. For example, subsumption equivalence of two programs is shown to correspond to the equality of their T P operators.
Reference: [92] <author> M. J. Maher and R. Ramakrishnan. </author> <title> Deja Vu in Fixpoints of Logic Pro--grams. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 963-980. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: We believe that a correct and AND-compositional semantics for finite failure needs to be based on a semantics similar to the one of section 5.3. 5.2 Multisets of answers The s-semantics was extended in <ref> [92] </ref> to deal with multisets rather than sets. Such an extension was needed to investigate properties which make possible improvements in the performance of the bottom-up fixpoint evaluation. <p> To study properties of these algorithms and their specializations for certain classes of programs, it is then necessary to consider duplicates, and hence multisets of atoms. We show here the definition of the multiset version of the s-semantics (ms-semantics for short) from <ref> [92] </ref>. For the sake of uniformity we use a T P -like construction. A more general formulation which allows us to express different evaluation algorithms and different semantics is given in [92]. The ms-semantics can be obtained by simply replacing sets by multisets in all the definitions of section 3. <p> We show here the definition of the multiset version of the s-semantics (ms-semantics for short) from <ref> [92] </ref>. For the sake of uniformity we use a T P -like construction. A more general formulation which allows us to express different evaluation algorithms and different semantics is given in [92]. The ms-semantics can be obtained by simply replacing sets by multisets in all the definitions of section 3. Therefore, in the following an interpretation will be a multiset of atoms modulo variance and a program will be a multiset of clauses. <p> We denote by mset (X) the set obtained from the multiset X by replacing any element a with multiplicity n by n (different) elements a 1 ; : : : ; a n . When atoms are unified the superscripts are simply ignored. Definition 5.3 <ref> [92] </ref> Let P be a positive program and I be an interpretation. <p> Finally note that, as shown by the following proposition, the s-semantics can be obtained from the ms-semantics by ignoring multiplicities. Proposition 5.7 <ref> [92] </ref> Let P be a positive program. Then F (P ) = set (F m (P )). 21 5.3 Resultants We will consider now less abstract observables which make visible internal computation details.
Reference: [93] <author> K. Marriott and H. Stndergaard. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 733-748. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P . The idea of bottom-up analysis was first introduced in <ref> [93] </ref>. The main difference between the top-down and the bottom-up approach is usually related to goal dependency. In particular, a top-down analysis starts with a specific goal, while the bottom-up approach determines an approximation of the success set which is goal independent. <p> Instances have been defined for ground dependency analysis [13], type inference [12] and for analysis of properties related to AND-parallelism [67, 68]. The emphasis in [13] is on the bottom-up definition of an abstract 45 model, i.e. a goal independent approximation of the concrete denotation. Early attempts <ref> [93, 94] </ref> of defining bottom-up abstract interpretations based on the immediate consequences operators corresponding to the least Herbrand model semantics or to the semantics in [30] failed on non-trivial analyses (like mode analysis).
Reference: [94] <author> K. Marriott and H. Stndergaard. </author> <title> Semantics-based Dataflow Analysis of Logic Programs. </title> <editor> In G. Ritter, editor, </editor> <booktitle> Information Processing 89. </booktitle> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: This is the reason why the need for a different formal semantics was recognized by many authors, giving rise to several new definitions [30, 49, 113, 42]. The need for better semantics was also recognized in the case of semantics-based abstract interpretation <ref> [94] </ref> and transformation [76]. 1.4 Compositionality In addition to the problem related to modeling the computed answers observational equivalences, there exists another problem with the least Herbrand model semantics. Namely a very important property, i.e. compositionality, does not hold. <p> Abstract interpretation is inherently semantics sensitive and different semantic definition styles lead to different approaches to program analysis. In the case of logic programs (see [38] for a broad overview), two main approaches exist, namely the top-down and the bottom-up ones <ref> [94] </ref>. The most popular approach is the top-down one, which propagates the information as SLD-resolution does. In this class there are ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics. <p> As we will argue later, the application of the s-semantics approach to abstract interpretation shows that the real issue is goal dependency vs. goal independency rather than top-down vs. bottom-up. Another relevant feature of the analysis method is its ability to determine call pattern information <ref> [24, 73, 94] </ref>, i.e. information about the procedure calls (atoms selected in an SLD-derivation). The ability to determine call patterns is also usually associated to goal dependent top-down methods. <p> Instances have been defined for ground dependency analysis [13], type inference [12] and for analysis of properties related to AND-parallelism [67, 68]. The emphasis in [13] is on the bottom-up definition of an abstract 45 model, i.e. a goal independent approximation of the concrete denotation. Early attempts <ref> [93, 94] </ref> of defining bottom-up abstract interpretations based on the immediate consequences operators corresponding to the least Herbrand model semantics or to the semantics in [30] failed on non-trivial analyses (like mode analysis). <p> Recently, the approach was made goal independent [33], by using the -semantics. The result is a denotation consisting of clauses very similar to the one in [53]. * It is worth noting that the top-down operational or denotational frameworks <ref> [24, 94, 104, 74] </ref> do indeed contain a lot of information on the "inter nal" computation details. By choosing a semantics like the one of section 47 5.3, we can model the same observables and still get a goal independent top-down and bottom-up construction of the abstract model.
Reference: [95] <author> M. Martelli and C. </author> <title> Tricomi. A new SLDNF-tree. </title> <journal> Information Processing Letters, </journal> <volume> 43(2) </volume> <pages> 57-62, </pages> <year> 1992. </year>
Reference-contexts: This information is useful to get a bottom-up characterization of SLDNF resolution <ref> [95] </ref>.
Reference: [96] <author> B. Martens and D. De Schreye. </author> <title> Why Untyped Meta-Programming is not (much of) a problem. </title> <type> Technical Report CW159, </type> <institution> Katholieke Universiteit Leuven, Department of Computer Science, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: If we consider the s-semantics of P and V P , due to the property stated by theorem 3.11, the language problem disappears and we can easily prove the following theorem. Theorem 7.2 <ref> [85, 96] </ref> Let P be a positive program and V P be its vanilla metain-terpreted version, where the proof procedure is defined by the relation demo.
Reference: [97] <author> A. Messora and M. Martelli. </author> <title> Declarative semantics of meta-logic predicates in logic programming. </title> <type> Technical report, </type> <institution> Universita di Genova, DISI, </institution> <year> 1992. </year>
Reference-contexts: Suitable notions of truth and model are defined on these interpretations and the existence of a least model is shown. The primitive 37 predicates considered in [6] are called first-order built-in's to distinguish them from those built-in's which refer to clauses and goals like call. In <ref> [97] </ref> this second class of built-in's is considered. 6.6 Modular logic programs with inheritance As already mentioned, by modifying O (P ) we can obtain semantics which are compositional w.r.t. other composition operators.
Reference: [98] <author> J. Minker and A. Rajasekar. </author> <title> A Fixpoint Semantics for Disjunctive Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 9 </volume> <pages> 45-74, </pages> <year> 1990. </year>
Reference-contexts: amples are the compositional semantics for positive logic programs [62, 63, 22, 21], whose domains are sets of clauses (see section 4), the semantic kernel for normal logic programs [43, 75], whose domains are sets of negative normal clauses (see section 6.3), the model state semantics for disjunctive logic programs <ref> [98, 90] </ref>, whose domains are sets of positive disjunctive ground clauses (see section 6.2). The overall approach is called in this paper the s-semantics approach after the s-semantics [47], which was the first example of a semantic construction featuring some of the above properties. <p> We can get a unique model characterization by capturing the disjunctive consequences as a set of positive disjunctive ground clauses 3 (-interpretations, called states in <ref> [98] </ref>), defined over the disjunctive Herbrand base. Definition 6.6 (disjunctive Herbrand base) [98] Let P be a disjunctive program. <p> We can get a unique model characterization by capturing the disjunctive consequences as a set of positive disjunctive ground clauses 3 (-interpretations, called states in <ref> [98] </ref>), defined over the disjunctive Herbrand base. Definition 6.6 (disjunctive Herbrand base) [98] Let P be a disjunctive program. <p> Definition 6.7 (-interpretation, state) <ref> [98] </ref> Let P be a disjunctive program. A state for P is a subset of DHB P . 3 A positive disjunctive clause is a disjunctive clause with an empty body. 29 Definition 6.8 [98] Let P be a disjunctive program and I be a state. <p> Definition 6.7 (-interpretation, state) <ref> [98] </ref> Let P be a disjunctive program. A state for P is a subset of DHB P . 3 A positive disjunctive clause is a disjunctive clause with an empty body. 29 Definition 6.8 [98] Let P be a disjunctive program and I be a state. <p> T d Theorem 6.10 <ref> [98] </ref> Let P be a disjunctive program. T d P is continuous on the complete lattice h2 DHB P ; i. Definition 6.11 [98] Let P be a disjunctive program. <p> T d Theorem 6.10 <ref> [98] </ref> Let P be a disjunctive program. T d P is continuous on the complete lattice h2 DHB P ; i. Definition 6.11 [98] Let P be a disjunctive program. <p> Definition 6.13 Let P be a disjunctive program and I be a state for P . Then H (I) is the set of minimal Herbrand models of I (viewed as a disjunctive program). The following theorem is a straightforward consequence of some theorems in <ref> [98] </ref> and shows that the fixpoint semantics is indeed a -model (called model state in [98]). Theorem 6.14 Let P be a disjunctive program. <p> Then H (I) is the set of minimal Herbrand models of I (viewed as a disjunctive program). The following theorem is a straightforward consequence of some theorems in <ref> [98] </ref> and shows that the fixpoint semantics is indeed a -model (called model state in [98]). Theorem 6.14 Let P be a disjunctive program.
Reference: [99] <author> U. Nilsson. </author> <title> Abstract Interpretation: A Kind of Magic. </title> <editor> In J. Maluszynski and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, Proceedings 3rd Int'l Symposium PLILP'91, volume 528 of Lecture Notes in Computer Science, </booktitle> <pages> pages 299-309. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: A similar (yet goal dependent) result can be obtained by using a transformational approach <ref> [31, 99] </ref>. A program P and a goal G are transformed (by using a transformation similar to the magic set transformation) into a program P 0 , such that every call pattern of G in P is a success pattern of P 0 .
Reference: [100] <author> H. Rasiowa and R. Sikorski. </author> <title> The Mathematics of Metamathematics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1963. </year>
Reference-contexts: Moreover, we will denote the equivalence class of an atom A by A itself. Note that -interpretations of definition 3.3 are not Herbrand interpretations, yet are interpretations defined on the Herbrand universe. These interpretations were called canonical realizations in <ref> [100, 79] </ref>. Theorem 3.4 shows that O actually models computed answer substitutions and that it is fully abstract, since P 1 ' P 2 implies O (P 1 ) = O (P 2 ). Theorem 3.4 [47] Let P 1 ; P 2 be positive programs.
Reference: [101] <author> V. A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: The semantics provides a nice characterization of the intensional part w.r.t. the extensional one and of the notion of transaction. The corresponding equivalence notions can profitably be used to prove interesting properties of optimization procedures. The approach has finally been applied to concurrent constraint programs as defined in <ref> [101] </ref>, leading to the definition of equivalent top-down and bottom-up semantics, defined as sets of unit clauses [45, 57], which are trees of ask and tell constraints.
Reference: [102] <author> H. Seki. </author> <title> Unfold/fold transformation of stratified programs. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. Sixth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 554-568. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: Most of the transformation techniques are proved to be safe w.r.t. the declarative semantics only, thus failing to capture the safeness w.r.t. the more complex observable behavior. In some cases the observational equivalences related to computed answers [76, 89] and to finite failures <ref> [102] </ref> are considered. Usually proving that the transformation preserves the observational equivalence is rather complex (see, for example, the proofs of the partial evaluation theorems in [89]). The same goal could more easily be achieved by proving that the transformation preserves a semantics which correctly models the relevant observable.
Reference: [103] <author> E. Y. Shapiro. </author> <title> Algorithmic Program Debugging. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1983. </year> <month> 58 </month>
Reference-contexts: The ability to use the CLP interpreter to analyze CLP programs has been exploited in some interesting applications [8]. 7.3 Declarative debugging The application of the s-semantics approach to semantics-based (declarative) debugging [16] has the following features when compared to the existing methods <ref> [103, 49, 87] </ref>. * The s-semantics, when taken as specification of the intended semantics, allows us to obtain a more accurate diagnosis than the one that can be obtained using the least Herbrand model or the c-semantics (which is used in [49]). * The properties of the s-semantics (equivalent top-down goal <p> The intended semantics is usually represented by an oracle <ref> [103] </ref>, which tells us whether a given object belongs to the semantics. Since abstract denotations are finite, they can explicitely be used as oracles.
Reference: [104] <author> H. Stndergaard. </author> <title> Semantics-Based Analysis and Transformation of Logic Programs. </title> <type> PhD thesis, </type> <institution> The University of Melbourne, </institution> <month> June </month> <year> 1990. </year> <note> Revised version of PhD thesis, </note> <institution> University of Copenhagen, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Recently, the approach was made goal independent [33], by using the -semantics. The result is a denotation consisting of clauses very similar to the one in [53]. * It is worth noting that the top-down operational or denotational frameworks <ref> [24, 94, 104, 74] </ref> do indeed contain a lot of information on the "inter nal" computation details. By choosing a semantics like the one of section 47 5.3, we can model the same observables and still get a goal independent top-down and bottom-up construction of the abstract model.
Reference: [105] <author> P. J. Stuckey. </author> <title> Constructive Negation for Constraint Logic Programming. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 328-339. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: As a result of this step, the negation in the stratified component has been completely evaluated (and replaced by constraints), while the non-stratified negation is still there in some clauses. The above approaches have been overriden by [23], which considers constructive negation in constraint logic programs as defined in <ref> [105] </ref>, for which there exists a very strong completeness result w.r.t. 3-valued models of the completion. -interpretations are pairs of sets of (equivalence classes of) constrained atoms (similar to those used in the CLP semantics discussed in section 6.1). <p> Finally, H (O CN (P )) is Kunen's seman-tics [80], namely P " !, where P is Fitting's map on partial A-interpretations [50]. It is worth noting that a similar bottom-up characterization can be obtained by the non-ground extension of P defined in <ref> [105] </ref>. 6.5 PROLOG We first consider pure PROLOG programs, i.e. programs without cut, built-in's or negation. Only the leftmost ( ) selection rule and the PROLOG search strategy are taken into account.
Reference: [106] <author> A. Takeuchi and K. Furukawa. </author> <title> Partial evaluation of Prolog programs and its application to meta programming. </title> <editor> In H.-J. Kugler, editor, </editor> <booktitle> Information Processing 86, </booktitle> <pages> pages 415-420. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1986. </year>
Reference-contexts: In most of these techniques, the relevant observables are computed answers (and sometimes finite failures). There exists at least one technique, the partial evaluation of "open" programs <ref> [111, 106, 86] </ref>, whose aim is to preserve a [-compositional program equivalence 7 . Most of the transformation techniques are proved to be safe w.r.t. the declarative semantics only, thus failing to capture the safeness w.r.t. the more complex observable behavior.
Reference: [107] <author> H. Tamaki and T. Sato. </author> <title> Unfold/Fold Transformations of Logic Programs. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proc. Second Int'l Conf. on Logic Programming, </booktitle> <pages> pages 127-139, </pages> <year> 1984. </year>
Reference-contexts: The same operation is not safe when the computed answers semantics is considered. In fact the answer substitution X=[a; b] would be missed in the transformed program. 43 As a matter of fact, all the program transformation techniques, such as unfold/fold <ref> [107] </ref> and partial evaluation [78], are defined so as to preserve some observational equivalences. In most of these techniques, the relevant observables are computed answers (and sometimes finite failures).
Reference: [108] <author> D. Turi. </author> <title> Extending S-Models to Logic Programs with Negation. </title> <editor> In K. Fu-rukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 397-411. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: The first attempt to extend the s-semantics to negation is described in <ref> [108] </ref>. It is a bottom-up semantics for stratified normal programs which generalizes to the non-ground case the construction of [4]. The resulting denotation has several similarities with the s-semantics, namely the fixpoint characterization and the use of sets of clauses (with constraints) as -interpretations. <p> However, there is no explicit relation to an observational equivalence based on an existing operational semantics (even if the reference derivation rule is clearly Chan's constructive negation). As a matter of fact, as it is the case for most declarative semantics of negation, the semantics in <ref> [108] </ref> tries to model the abstract intended meaning of the program and can be viewed as the ideal semantics to be approximated by effective operational semantics. Essentially the same semantics (in the case of stratified programs) is obtained by the two-steps fixpoint construction in [60]. <p> The first step consists of the fixpoint construction of the semantic kernel described in section 6.3, while the second step interprets the stratified component according to constructive negation, essentially following the approach in <ref> [108] </ref>. As a result of this step, the negation in the stratified component has been completely evaluated (and replaced by constraints), while the non-stratified negation is still there in some clauses.
Reference: [109] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: This is exactly what van Emden and Kowalski did for definite Horn clauses in their seminal paper <ref> [109] </ref>, where the proof procedure was SLD-resolution and the model was the least Herbrand model. <p> We show our construction in a language independent way by considering three separate steps, which roughly correspond to the three standard semantics of logic programs <ref> [109, 88, 3] </ref>. The first step is related to the operational semantics and leads to the definition of the structure of -interpretations. The second step is concerned with the fixpoint semantics. <p> T 9 B 0 n variants of atoms in I and renamed apart; 9# = mgu ((B 1 ; : : :; B n ); (B 0 n )) and A = A 0 # g Note that T P is different from the standard T P operator <ref> [109] </ref> in that it derives instances of the clause heads by unifying the clause bodies with atoms in the current -interpretation, rather than by taking all the possible ground instances.
Reference: [110] <author> T. Vasak and J. Potter. </author> <title> Characterization of Terminating Logic Programs. </title> <booktitle> In Proc. Third IEEE Int'l Symp. on Logic Programming, </booktitle> <pages> pages 140-147. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1986. </year>
Reference-contexts: The construction of E recalls the theoretical characterization of termination of logic programs developed by Vasak e Potter in <ref> [110] </ref>. They compare terminating queries under different choices of the selection rule (thus dealing with different notions of universal termination) while we consider fair selection rules in theorem 5.17 and Prolog selection rule in section 6.5.
Reference: [111] <author> R. Venken. </author> <title> A PROLOG meta-interpreter for partial evaluation and its application to source-to-source transformation and query optimization. </title> <editor> In T. O'Shea, editor, ECAI-84: </editor> <booktitle> Advances in Artificial Intelligence, </booktitle> <pages> pages 91-100. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: In most of these techniques, the relevant observables are computed answers (and sometimes finite failures). There exists at least one technique, the partial evaluation of "open" programs <ref> [111, 106, 86] </ref>, whose aim is to preserve a [-compositional program equivalence 7 . Most of the transformation techniques are proved to be safe w.r.t. the declarative semantics only, thus failing to capture the safeness w.r.t. the more complex observable behavior.
Reference: [112] <author> L. Vieille. </author> <title> Recursive query processing: the power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: In particular, if we want a bottom-up definition equivalent to the top-down one, we have to consider "local" selection rules only. A local selection rule is defined in <ref> [112] </ref> as a rule which always selects in a goal N one of the most recently introduced atoms in the derivation from the initial goal to N . <p> Note that the PROLOG leftmost rule is local and that in general local rules produce SLD-trees with a simpler structure, suitable for efficient searching techniques <ref> [112] </ref>. For the sake of simplicity, we will give the next definitions in the case of the leftmost selection rule only. The general complete formalization can be found in [59]. The intuition behind the immediate consequences operator in definition 5.12 is the following.
Reference: [113] <author> S. Yamasaki, M. Yoshida, and S. Doshita. </author> <title> A fixpoint semantics of Horn Sentences based on Substitution Sets. </title> <journal> Theoretical Computer Science, </journal> <volume> 51 </volume> <pages> 309-324, </pages> <year> 1987. </year>
Reference-contexts: When trying to understand the meaning of programs, when analyzing and transforming programs, this semantics cannot be taken as the reference semantics. This is the reason why the need for a different formal semantics was recognized by many authors, giving rise to several new definitions <ref> [30, 49, 113, 42] </ref>. The need for better semantics was also recognized in the case of semantics-based abstract interpretation [94] and transformation [76]. 1.4 Compositionality In addition to the problem related to modeling the computed answers observational equivalences, there exists another problem with the least Herbrand model semantics.
References-found: 113

