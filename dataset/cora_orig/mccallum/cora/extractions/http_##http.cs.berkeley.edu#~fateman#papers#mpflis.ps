URL: http://http.cs.berkeley.edu/~fateman/papers/mpflis.ps
Refering-URL: http://http.cs.berkeley.edu/~fateman/algebra.html
Root-URL: 
Title: Importing Pre-packaged Software into Lisp: Experience with Arbitrary-Precision Floating-Point Numbers  
Author: Richard J. Fateman 
Address: Berkeley  
Affiliation: University of California at  
Abstract: We advocate the use of Common Lisp as a powerful glue for building scientific computing environments. Naturally one then has to address mixing pre-existing (non Lisp) code into this system. We provide a specific example as an elaborate FORTRAN system written by David Bailey for arbitrary-precision floating-point numeric calculation. We discuss the advantages and disadvantages of wholesale importing into Lisp. A major advantage is being able to use state-of-the art packaged software sooner, while overcoming the disadvantages caused by FORTRAN's traditional batch orientation and weak storage model. In this paper we emphasize in particular how effective use of imported systems may require one to address the contrast between the functional (Lisp-like) versus state-transition-based (Fortran-like) approaches to dealing with compound objects. While our example is high-precision floats, other highly useful packages including those for simulation, PDE solutions, signal processing, statistical computation, etc. may also benefit by similar consideration. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David H. Bailey. MPFUN: </author> <title> A Portable High Performance Multiprecision Package. </title> <institution> NAS Applied Research Office, NASA Ames Research Center, Moffett Field, </institution> <address> CA 94035. </address> <month> March, </month> <year> 1991. </year> <title> A report was published as "Algorithm 719, Multiprecision translation and execution of FORTRAN programs." </title> <journal> ACM Trans. Math. Softw. </journal> <volume> 19, no 3 (Sept, </volume> <year> 1993) </year> <month> 288|320. </month>
Reference-contexts: Fortunately, David H. Bailey has done an excellent job of building a multiple-precision package in a Fortran 3 . To quote from Bailey's abstract <ref> [1] </ref> describing MPFUN: This package features (1) virtually universal portability, (2) high performance, especially on vector supercomputers, (3) advanced algorithms, including FFT-based multiplication and quadrat-ically convergent algorithms for , exp and log, and (4) extensive self-checking and debug facilities that permit the package to be used as a rigorous system integrity <p> Programming in a mixture of the two styles is also possible, and even convenient sometimes, but the programmer must guard against conflicts in the use of MP registers. 4 The Implementation Here we provide a brief survey of Bailey's design; a full description is given by Bailey [3] <ref> [1] </ref>. 4.1 MP Data Types This description is taken from Bailey's documentation [3] with only minor change. An MP number is represented by a single precision floating point array. The sign of the first word is the sign of the MP number. <p> But the correct answer is about0:5106. So the relative error in the answer 0 is quite high, and it is certainly not good to 8 decimal places. 8 For details on MPFUN We do not attempt to reproduce the details given in the excellent documentation of MPFUN <ref> [1] </ref>. In fact, we encourage users except of the most casual sort, to obtain full documentation for reference. <p> also log, exponential, sin/cos, sinh/cosh, angle (related to arctan and arcsin), square-root, cube-root, polynomial zero-finding, searching for an integer relation (A typical application of this routine is to "determine if a given computed real number r is the root of any algebraic equation of degree n 1 with integer coefficients." <ref> [1] </ref>. 9 Various details The program is loaded by typing :ld mpfunext into Lisp in the appropriate environment. The number of words used in the mantissa of MP numbers is initially 16. This can be changed to, say, 20 by (setf (mpcom1 nw) 20).
Reference: [2] <author> David H. Bailey. </author> <title> "A Fortran 90-based multiprecision system." </title> <journal> ACM Trans. Math. Softw., </journal> <volume> 21 no 4, </volume> <month> (Dec. </month> <year> 1995) </year> <month> 379|87. </month>
Reference-contexts: Inflexibility is one of the prices one pays to write in portable Fortran, compared to Lisp, C, or even a mod ern dialect of Fortran (e.g. Fortran 90 <ref> [2] </ref>. 2. Complex numbers. MPCs in MPFUN are represented as single arrays with the real and imaginary parts placed in adjacent places with a given offset.
Reference: [3] <author> David H. Bailey. </author> <title> Source Code for MPFUN. </title> <publisher> dbailey@wk49.nas.nasa.gov </publisher>
Reference-contexts: Programming in a mixture of the two styles is also possible, and even convenient sometimes, but the programmer must guard against conflicts in the use of MP registers. 4 The Implementation Here we provide a brief survey of Bailey's design; a full description is given by Bailey <ref> [3] </ref> [1]. 4.1 MP Data Types This description is taken from Bailey's documentation [3] with only minor change. An MP number is represented by a single precision floating point array. The sign of the first word is the sign of the MP number. <p> possible, and even convenient sometimes, but the programmer must guard against conflicts in the use of MP registers. 4 The Implementation Here we provide a brief survey of Bailey's design; a full description is given by Bailey <ref> [3] </ref> [1]. 4.1 MP Data Types This description is taken from Bailey's documentation [3] with only minor change. An MP number is represented by a single precision floating point array. The sign of the first word is the sign of the MP number. The magnitude of the first word is the number of mantissa words. <p> If the entry is two, a message is output and execution is immediately terminated. All entries of ker are initially 2." <ref> [3] </ref> And yes, messages output to the default unit ldb appear as Lisp standard output. 5 Additional Utilities for MP in Lisp 5.1 Input A single Lisp program reads any normal Lisp number and converts to a MP form.
Reference: [4] <author> C. Batut, D. Bernardi, H. Cohen, M. Olivier. </author> <note> User's Guide to PARI-GP. Feb, 1991 (version 1.35). </note>
Reference-contexts: a few more: Sasaki [14] wrote programs in Lisp for the Reduce system; for the SAC-I system, Pinkert wrote a system [12]; most other programs seem to have been written in C such as the desk-calculator (dc) in the UNIX system [15], and components of Maple [6], Mathematica [16], PARI <ref> [4] </ref> and Saclib [11]. Viewed from the perspective of a subroutine library for applications, it is clear that the authors of the Fortran-extension packages were sensitive to usability issues, and that a "raw library" interface was thought to be too hard to use.
Reference: [5] <author> Richard P. Brent. </author> <title> A Fortran Multiple Precision Arithmetic Package, </title> <journal> ACM Trans. Math. Softw. </journal> <month> 4 (March, </month> <year> 1978), </year> <editor> p. </editor> <volume> 57 - 70. </volume>
Reference-contexts: One such extension that has repeatedly appeared as user-implemented programs is that of a multiple-precision floating-point number system. A design for such a system in Fortran goes back at least as far as Wyatt [17]. A well-distributed version is the one by Brent <ref> [5] </ref>. An early implementation in Lisp is described by Fateman [8]. Other implementations have been written through the last several decades.
Reference: [6] <author> B. Char et al. </author> <title> Maple Reference Manual, </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We note a few more: Sasaki [14] wrote programs in Lisp for the Reduce system; for the SAC-I system, Pinkert wrote a system [12]; most other programs seem to have been written in C such as the desk-calculator (dc) in the UNIX system [15], and components of Maple <ref> [6] </ref>, Mathematica [16], PARI [4] and Saclib [11]. Viewed from the perspective of a subroutine library for applications, it is clear that the authors of the Fortran-extension packages were sensitive to usability issues, and that a "raw library" interface was thought to be too hard to use.
Reference: [7] <author> I. Emiris and R. Fateman. </author> <title> Interval arithmetic in Lisp. </title> <note> (working paper). </note>
Reference-contexts: Building a real-interval package on top of an existing arithmetic is another example <ref> [7] </ref> of a task easily undertaken in Lisp. In fact, MPFUN has provided a handle, although not a complete solution for one of the essential controls: (setf (mpcom1 ird) n) sets the rounding mode in MPFUN.
Reference: [8] <author> R. Fateman. </author> <title> `The MACSYMA 'Big-Floating-Point' Arithmetic System," </title> <editor> in: R. D. Jenks, (ed.), </editor> <booktitle> Proc. of the 1976 ACM Symp. on Symbolic and Algebraic Computation, </booktitle> <address> (SYMSAC-76), Yorktown Height, N.Y., </address> <month> August </month> <year> 1976, </year> <pages> 209-213. </pages>
Reference-contexts: A design for such a system in Fortran goes back at least as far as Wyatt [17]. A well-distributed version is the one by Brent [5]. An early implementation in Lisp is described by Fateman <ref> [8] </ref>. Other implementations have been written through the last several decades. <p> For example, one could (perhaps iteratively) find a good-enough value of to provide the requested precision with full accuracy (done, for example, by Macsyma <ref> [8] </ref>) or refuse to provide a result for an argument of very large size (loss of precision in range reduction). Many systems implement this latter option. Perhaps it is unreasonable request sin (10 100 ) if you are only carrying 100 digits of precision.
Reference: [9] <author> R. Fateman, K. Broughan, D. Willcock, D. Rettig, </author> <title> Fast Floating-Point Computation in Lisp ACM Trans. </title> <journal> Math. Softw. </journal> <volume> 21 no 1. </volume> <month> March </month> <year> 1996 </year> <month> 26-62. </month>
Reference: [10] <author> E. Gallopoulos, E. Houstis and J. R. Rice. </author> <title> "Future Research Directions in Problem Solving Environments for Computational Science," Report of a Workshop on Research Directions in Integrating Numerical Analysis, </title> <booktitle> Symbolic Computing, Computational Geometry, and Artificial Intelligence for Computational Science, </booktitle> <address> April, 1991 Washington DC </address>
Reference-contexts: 1 Introduction One of the traditional advantages of Lisp as a programming language is that it is relatively supportive of language extensions to data abstractions, even those not specifically anticipated. The building of problem solving environments <ref> [10] </ref> is just such a situation. An additional selling point for Lisp is that it has an interactive basis, and a thorough support for object-oriented programming.
Reference: [11] <author> Krandick, Johnson. SACLIB. </author> <note> RISC-Linz </note>
Reference-contexts: Sasaki [14] wrote programs in Lisp for the Reduce system; for the SAC-I system, Pinkert wrote a system [12]; most other programs seem to have been written in C such as the desk-calculator (dc) in the UNIX system [15], and components of Maple [6], Mathematica [16], PARI [4] and Saclib <ref> [11] </ref>. Viewed from the perspective of a subroutine library for applications, it is clear that the authors of the Fortran-extension packages were sensitive to usability issues, and that a "raw library" interface was thought to be too hard to use. Therefore many of the Fortran-based system providers (e.g. <p> One can sometimes periodically widen intervals with rational endpoints in order to take advantage of nearby "easy-to-represent" rational numbers (e.g. those with denominators that are powers of 2 <ref> [11] </ref>) but in fact this is approximately equivalent to conservative-rounding of floating-point numbers. Building a real-interval package on top of an existing arithmetic is another example [7] of a task easily undertaken in Lisp.
Reference: [12] <author> J. R. Pinkert. </author> <title> "SAC-1 Variable Precision Floating Point Arithmetic," </title> <booktitle> Proc. ACM 75, </booktitle> <year> (1975) </year> <month> 274-276. </month>
Reference-contexts: An early implementation in Lisp is described by Fateman [8]. Other implementations have been written through the last several decades. We note a few more: Sasaki [14] wrote programs in Lisp for the Reduce system; for the SAC-I system, Pinkert wrote a system <ref> [12] </ref>; most other programs seem to have been written in C such as the desk-calculator (dc) in the UNIX system [15], and components of Maple [6], Mathematica [16], PARI [4] and Saclib [11].
Reference: [13] <author> P. L. Richman, </author> <title> "Automatic Error Analysis for Determining Precision," </title> <journal> Comm. </journal> <note> ACM 15 (1972) 813-817. </note>
Reference: [14] <author> T. Sasaki. </author> <title> "An Arbitrary Precision Real Arithmetic Package in REDUCE" in Proc. </title> <booktitle> EUROSAM 1979, Lecture Notes in Computer Science, </booktitle> <volume> 72, </volume> <year> 1979, </year> <pages> Springer-Verlag pp. 358-368. </pages>
Reference-contexts: A well-distributed version is the one by Brent [5]. An early implementation in Lisp is described by Fateman [8]. Other implementations have been written through the last several decades. We note a few more: Sasaki <ref> [14] </ref> wrote programs in Lisp for the Reduce system; for the SAC-I system, Pinkert wrote a system [12]; most other programs seem to have been written in C such as the desk-calculator (dc) in the UNIX system [15], and components of Maple [6], Mathematica [16], PARI [4] and Saclib [11]. <p> These include translations between binary "unit in the last place (ulp)" and decimal ulp, rounding, truncation, etc. The Reduce system <ref> [14] </ref> uses decimal. In our bigfloat package, we wrote two versions for Macsyma (the differences are limited to a few places in the code), with the more recent one being binary; Bailey's MPFUN went through two versions, settling on a binary version.
Reference: [15] <institution> UNIX manual. </institution>
Reference-contexts: We note a few more: Sasaki [14] wrote programs in Lisp for the Reduce system; for the SAC-I system, Pinkert wrote a system [12]; most other programs seem to have been written in C such as the desk-calculator (dc) in the UNIX system <ref> [15] </ref>, and components of Maple [6], Mathematica [16], PARI [4] and Saclib [11].
Reference: [16] <author> Stephen Wolfram. </author> <title> Mathematica A System for doing Mathematics. 2nd edition. </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: We note a few more: Sasaki [14] wrote programs in Lisp for the Reduce system; for the SAC-I system, Pinkert wrote a system [12]; most other programs seem to have been written in C such as the desk-calculator (dc) in the UNIX system [15], and components of Maple [6], Mathematica <ref> [16] </ref>, PARI [4] and Saclib [11]. Viewed from the perspective of a subroutine library for applications, it is clear that the authors of the Fortran-extension packages were sensitive to usability issues, and that a "raw library" interface was thought to be too hard to use.
Reference: [17] <author> W. T. Wyatt Jr., D. W. Lozier, and D. J. Orsen. </author> <title> A Portable Extended-Precision "Arithmetic Package and Library with Fortran Precompiler," </title> <institution> Math. Software II, Purdue Univ., </institution> <month> May </month> <year> 1974. </year> <month> 8 </month>
Reference-contexts: One such extension that has repeatedly appeared as user-implemented programs is that of a multiple-precision floating-point number system. A design for such a system in Fortran goes back at least as far as Wyatt <ref> [17] </ref>. A well-distributed version is the one by Brent [5]. An early implementation in Lisp is described by Fateman [8]. Other implementations have been written through the last several decades.
References-found: 17

