URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/scandal/public/code/nesl/nesl/doc/user.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/andrew.cmu.edu/scs/cs/15-499B/www/lectures.html
Root-URL: http://www.cs.cmu.edu
Title: Nesl User's Manual (For Nesl Version 3.1)  
Author: Guy E. Blelloch Jay Sipelstein Jonathan C. Hardwick Marco Zagha 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: November 28, 1995  
Pubnum: CMU-CS-95-169  
Abstract: This manual is a supplement to the language definition of Nesl version 3.1. It describes how to use the Nesl system interactively and covers features for accessing on-line help, debugging, profiling, executing programs on remote machines, using Nesl with GNU Emacs, and installing and customizing the Nesl system. This research was sponsored in part by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330. It was also supported in part by an NSF Young Investigator Award under grant number CCR-9258525, and by Finmeccanica. The views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of Wright Laboratory or the U. S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Guy E. Blelloch. </author> <title> The NESL language definition (version 3.1). </title> <type> Technical Report CMU-CS-95-170, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction This manual is a supplement to the language definition of Nesl version 3.1 <ref> [1] </ref>, and assumes that the reader is familiar with the basics of the language. It describes how to use the Nesl system interactively and covers features for accessing on-line help, debugging, profiling, executing programs on remote machines, using Nesl with GNU Emacs, and installing and customizing the Nesl system. <p> A full syntax for each of these is given in Appendix A of the Nesl language definition <ref> [1] </ref>. Some examples of top-level expressions include: function double (a) = 2*a; function add3 (a,b,c) = a + b + c; datatype complex (float,float); foo = double (3) + add3 (1,2,3); foo; Expressions that are not assigned to a user defined variable are assigned to the variable it. <p> The command ? (with or without a terminating semicolon) has the same effect. describe funname; This gives a description of function funname, including the documentation from the manual <ref> [1] </ref>. apropos name; This prints the names of all the Nesl functions and variables that contain the string name in either their name or their documentation string. show code funname; This displays the Nesl code for function funname. <p> Only n elements of a sequence are printed on the screen, followed by "...". The default value for print length is 100. The print length applies to each level of a nested sequence. For example: &lt;Nesl&gt; set print_length 3; &lt;Nesl&gt; x = [[1:10],[1:10],[1:10],[1:10]]; x = [<ref> [1, 2, 3,...] </ref>, [1, 2, 3,...], [1, 2, 3,...],...] : [[int]] pattern |= exp; By typing a |= exp; at the top level, the expression exp is assigned to the file variable a. The pattern can be any variable pattern. <p> The default value for print length is 100. The print length applies to each level of a nested sequence. For example: &lt;Nesl&gt; set print_length 3; &lt;Nesl&gt; x = [[1:10],[1:10],[1:10],[1:10]]; x = [<ref> [1, 2, 3,...] </ref>, [1, 2, 3,...], [1, 2, 3,...],...] : [[int]] pattern |= exp; By typing a |= exp; at the top level, the expression exp is assigned to the file variable a. The pattern can be any variable pattern. <p> Here is an example: &lt;Nesl&gt; a |= index (10000); a : [int] &lt;Nesl&gt; sum (a); it = 49995000 : int &lt;Nesl&gt; function foo (n) = take (a,n); foo = fn : int -&gt; [int] &lt;Nesl&gt; foo (10); it = <ref> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </ref> : [int] File variables are stored in the temp dir specified by the configuration (/tmp/ by default). <p> The Nesl prompt returns soon as the job has been submitted. For example: &lt;Nesl&gt; a &= sum ([0:100000]); Compiling..Writing..Submitting.. <ref> [1] </ref> 12782 background a : int &lt;Nesl&gt; The result is retrieved using the get command described below. The &= command has three optional arguments: * mem: This specifies the amount of memory the job will need.
Reference: [2] <author> Guy E. Blelloch, Siddhartha Chatterjee, Jonathan C. Hardwick, Jay Sipelstein, and Marco Zagha. </author> <title> Implementation of a portable nested data-parallel language. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 21(1) </volume> <pages> 4-14, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: The WWW home page contains a link to this site. * A mailing list used to discuss Nesl and announce new patches and releases. If you want to be added to this list send e-mail to nesl-request@cs.cmu.edu. * Papers on the implementation <ref> [2] </ref>, uses [4], and teaching [3] of Nesl. These can be obtained from the FTP site, or viewed directly from the WWW home page. 2 1.3 Conventions Within this document, interactions with the Nesl system are shown in a typewriter font, and command arguments are shown in an italic font. <p> If you want to find out more about the memory system used by Nesl and the meaning of the compacting vector memory message, see the paper on the implementation of Nesl <ref> [2] </ref>. Parse errors: Common syntax errors include functions with no arguments, mismatched parentheses, and empty vectors without types. Sometimes errors are a bit cryptic, for example: function foo = sqrt (2.0); ) = is missing its left argument. Most semantic errors (such as type mismatches) produce more informative error messages. <p> Only n elements of a sequence are printed on the screen, followed by "...". The default value for print length is 100. The print length applies to each level of a nested sequence. For example: &lt;Nesl&gt; set print_length 3; &lt;Nesl&gt; x = [[1:10],[1:10],[1:10],[1:10]]; x = <ref> [[1, 2, 3,...] </ref>, [1, 2, 3,...], [1, 2, 3,...],...] : [[int]] pattern |= exp; By typing a |= exp; at the top level, the expression exp is assigned to the file variable a. The pattern can be any variable pattern. <p> Only n elements of a sequence are printed on the screen, followed by "...". The default value for print length is 100. The print length applies to each level of a nested sequence. For example: &lt;Nesl&gt; set print_length 3; &lt;Nesl&gt; x = [[1:10],[1:10],[1:10],[1:10]]; x = [<ref> [1, 2, 3,...] </ref>, [1, 2, 3,...], [1, 2, 3,...],...] : [[int]] pattern |= exp; By typing a |= exp; at the top level, the expression exp is assigned to the file variable a. The pattern can be any variable pattern. <p> The default value for print length is 100. The print length applies to each level of a nested sequence. For example: &lt;Nesl&gt; set print_length 3; &lt;Nesl&gt; x = [[1:10],[1:10],[1:10],[1:10]]; x = [<ref> [1, 2, 3,...] </ref>, [1, 2, 3,...], [1, 2, 3,...],...] : [[int]] pattern |= exp; By typing a |= exp; at the top level, the expression exp is assigned to the file variable a. The pattern can be any variable pattern. <p> Here is an example: &lt;Nesl&gt; a |= index (10000); a : [int] &lt;Nesl&gt; sum (a); it = 49995000 : int &lt;Nesl&gt; function foo (n) = take (a,n); foo = fn : int -&gt; [int] &lt;Nesl&gt; foo (10); it = <ref> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </ref> : [int] File variables are stored in the temp dir specified by the configuration (/tmp/ by default).
Reference: [3] <author> Guy E. Blelloch and Jonathan C. Hardwick. </author> <title> Class notes: Programming parallel algorithms. </title> <type> Technical Report CMU-CS-93-115, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: The WWW home page contains a link to this site. * A mailing list used to discuss Nesl and announce new patches and releases. If you want to be added to this list send e-mail to nesl-request@cs.cmu.edu. * Papers on the implementation [2], uses [4], and teaching <ref> [3] </ref> of Nesl. These can be obtained from the FTP site, or viewed directly from the WWW home page. 2 1.3 Conventions Within this document, interactions with the Nesl system are shown in a typewriter font, and command arguments are shown in an italic font. <p> Here is an example: &lt;Nesl&gt; a |= index (10000); a : [int] &lt;Nesl&gt; sum (a); it = 49995000 : int &lt;Nesl&gt; function foo (n) = take (a,n); foo = fn : int -&gt; [int] &lt;Nesl&gt; foo (10); it = <ref> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </ref> : [int] File variables are stored in the temp dir specified by the configuration (/tmp/ by default).
Reference: [4] <author> John Greiner. </author> <title> A comparison of data-parallel algorithms for connected components. </title> <booktitle> In Proceedings Sixth Annual Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 16-25, </pages> <address> Cape May, NJ, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The WWW home page contains a link to this site. * A mailing list used to discuss Nesl and announce new patches and releases. If you want to be added to this list send e-mail to nesl-request@cs.cmu.edu. * Papers on the implementation [2], uses <ref> [4] </ref>, and teaching [3] of Nesl. These can be obtained from the FTP site, or viewed directly from the WWW home page. 2 1.3 Conventions Within this document, interactions with the Nesl system are shown in a typewriter font, and command arguments are shown in an italic font. <p> Here is an example: &lt;Nesl&gt; a |= index (10000); a : [int] &lt;Nesl&gt; sum (a); it = 49995000 : int &lt;Nesl&gt; function foo (n) = take (a,n); foo = fn : int -&gt; [int] &lt;Nesl&gt; foo (10); it = <ref> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </ref> : [int] File variables are stored in the temp dir specified by the configuration (/tmp/ by default).
Reference: [5] <author> Jonathan Hardwick. </author> <title> Porting a vector library: A comparison of MPI, paris, CMMD and PVM. </title> <type> Technical Report CMU-CS-94-200, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> November </month> <year> 1994. </year> <month> 21 </month>
Reference-contexts: Here is an example: &lt;Nesl&gt; a |= index (10000); a : [int] &lt;Nesl&gt; sum (a); it = 49995000 : int &lt;Nesl&gt; function foo (n) = take (a,n); foo = fn : int -&gt; [int] &lt;Nesl&gt; foo (10); it = <ref> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </ref> : [int] File variables are stored in the temp dir specified by the configuration (/tmp/ by default). <p> Argument checking is on by default and includes bounds checking, divide by zero checking, and range checking. Runtime errors detected by argument checking print a message of the form: &lt;Nesl&gt; let a = [2,3,4] in a <ref> [5] </ref>; Compiling..Writing..Loading..Running.. RUNTIME ERROR: Sequence reference (a [i]) out of bounds. Exiting..Reading.. Argument checking takes time, so it can be turned off to generate faster code. set trace funname n; This sets the tracing level for any non-primitive function. <p> Entering FOO A = 2 A = 4 Leaving FOO RESULT = 5 RESULT = 6 RESULT = 7 Exiting..Reading.. it = <ref> [5, 6, 7] </ref> : [int] set trace off; Turns tracing off for all functions. set profile funname fon,offg; When profiling is turned on for a function, the time taken for each expression on the right of a let binding in that function are printed. <p> See the Makefile and README files in the vcode and cvl/mpi subdirectories for further details. A comparison of the CM-2, CM-5 and MPI versions is given in <ref> [5] </ref>. 17 Compiling for multiple serial architectures: If you want versions of Nesl for multiple serial architectures, you will need copies of vinterp.serial, xneslplot and runnesl for each architecture.
Reference: [6] <author> Daniel V. Pryor, Steven A. Cuccaro, Michael Mascagni, </author> <title> and M.L. Robinson. Implementa--tion of a portable and reproducible parallel pseudorandom number generator. </title> <booktitle> In Proceedings Supercomputing '94, </booktitle> <pages> pages 311-319, </pages> <address> Washington D.C., </address> <month> December </month> <year> 1994. </year> <journal> ACM. </journal> <volume> 22 </volume>
Reference-contexts: Here is an example: &lt;Nesl&gt; a |= index (10000); a : [int] &lt;Nesl&gt; sum (a); it = 49995000 : int &lt;Nesl&gt; function foo (n) = take (a,n); foo = fn : int -&gt; [int] &lt;Nesl&gt; foo (10); it = <ref> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </ref> : [int] File variables are stored in the temp dir specified by the configuration (/tmp/ by default). <p> Entering FOO A = 2 A = 4 Leaving FOO RESULT = 5 RESULT = 6 RESULT = 7 Exiting..Reading.. it = <ref> [5, 6, 7] </ref> : [int] set trace off; Turns tracing off for all functions. set profile funname fon,offg; When profiling is turned on for a function, the time taken for each expression on the right of a let binding in that function are printed. <p> Portable pseudorandom numbers: For users who want a pseudorandom number generator that is portable across parallel machines, we supply hooks in the MPI and CM-5 code to use the additive lagged-Fibonacci generator described in <ref> [6] </ref>. This is available to US residents via FTP from ftp://ftp.super.org/pub/mascagni/lfibrng6a.tar.Z. See the appropriate CVL Makefile for instructions on how to enable the hooks.
References-found: 6

