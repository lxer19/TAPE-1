URL: http://www.cs.mu.oz.au/tr_db/mu_93_03_revised.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Nonrecursive Incremental Evaluation of Datalog Queries  
Author: Guozhu Dong Jianwen Su Rodney Topor 
Date: Revised: May 1994  
Note: To appear in Annals of Mathematics and Artificial Intelligence  
Address: Parkville, Vic. 3052, Australia  Santa Barbara, CA 93106 USA  Melbourne  
Affiliation: Department of Computer Science University of Melbourne  Department of Computer Science University of California  School of Computing and Information Technology Griffith University Nathan, Qld 4111, Australia Computer Science TR 93/3, University of  
Abstract: fl Parts of the results in this paper appeared as extended abstracts in Proceedings of the 1992 International Conference on Database Theory (LNCS 646, Springer-Verlag), and in Proceedings of the 1993 International Workshop on Database Programming Languages (Workshops in Computing, Springer-Verlag). Guozhu Dong gratefully acknowledges support of Australian Research Council through research grants and the Centre for Intelligent Decision Systems. Work by Jianwen Su was supported in part by NSF grants IRI-9109520 and IRI-9117094. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Afrati and S.S. Cosmadakis. </author> <title> Expressiveness of restricted recursive queries. </title> <booktitle> In Proc. ACM SIGACT Symp. on the Theory of Computing, </booktitle> <pages> pages 113-126, </pages> <year> 1989. </year>
Reference-contexts: Note that chain Datalog programs contain only variables and binary predicate symbols. Chain Datalog programs and generalizations allow special optimization techniques. Indeed, several papers have considered efficiency issues of such programs <ref> [1, 12, 13] </ref>. The current paper also explores such possibilities. It is well known that, for each chain Datalog program P, the query (P; p) can be associated with a context-free grammar 2 G constructed as follows.
Reference: [2] <author> K. R. Apt, H. A. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: This optimization approach is analogous to the incremental checking of integrity constraint satisfaction by using (i) database updates and (ii) the fact that the integrity constraints were satisfied prior to the updates [9, 28, 29]. Our task is closely related to the problem of efficiently updating the standard model <ref> [2] </ref> of a definite or more generally stratified database [4, 25]. Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [27].
Reference: [3] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Database Theory: From A to F. </title> <type> Manuscript. </type> <year> 1994. </year>
Reference-contexts: Note that nonrecursive programs define unions of conjunctive queries [11]. Such queries allow very efficient computations, and have received extensive attention in the literature <ref> [3, 31] </ref>. As we shall argue later, queries permitting incremental evaluation using conjunctive queries strictly generalize queries computable by nonrecursive programs. We assume familiarity with the relational databases and the Datalog language [31]. 2 We assume the existence of three pairwise disjoint infinite sets of constants, variables, and predicates. <p> The problem is a variation of the transitive closure query and it can be shown not expressible by nonrecursive queries using an argument of playing Ehrenfeucht-Fraiss e games similar to the proof for the graph connectivity query in <ref> [3] </ref>. <p> The most desirable aspect of P q ffi is its parallel efficiency. Indeed, membership of facts in the answer to the query can be checked in constant time using P q ffi since P ffi is a nonrecursive query <ref> [3] </ref>. We illustrate the above discussion using Examples 2.1 and 3.5. For Example 2.1, E = edge + , there are four rules in P ffi and the number of joins needed is four. <p> Hence P has 1-CCI. 2 As an aside, by using a reduction to the undecidable problem of satisfiability of relational calculus <ref> [3] </ref>, it can be shown that it is undecidable if a binary relational calculus (algebra) query has CCI (the detail is omitted). We note that the notion of CCI can be generalized to predicates with arity &gt; 2 and all the results on CCI reported here can also be generalized.
Reference: [4] <author> K. R. Apt and J.-M. Pugin. </author> <title> Maintenance of stratified databases viewed as a belief revision system. </title> <booktitle> In Proc. Sixth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 136-145, </pages> <year> 1987. </year>
Reference-contexts: Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database <ref> [4, 25] </ref>. Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [27]. <p> Our approach, for query evaluation rather than for constraint checking, differs in storing previous derived relations and in transforming the programs used in query evaluation. Efficient maintenance of (stratified) databases <ref> [4, 25] </ref>. The goal of this approach is to efficiently compute the standard model of a stratified database after a database update. <p> It is similar to our approach in using the previous standard model (analogous to our stored relations) to simplify the task of computing the standard model (query answer) after the update. Our approach differs by storing intermediate relations rather than reasons (or supports) for including computed facts <ref> [4] </ref>, by not using meta-programs to compute the difference between successive models [25], and by transforming the programs used in query evaluation. Our approach is, however, more restricted as it does not allow negation in rules and queries. Incremental evaluation by counting [17].
Reference: [5] <author> A. Aho and J. Ullman. </author> <title> Universality of data retrieval languages. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 110-120, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Relational query languages have limited power since they cannot express recursive queries such as transitive closure queries <ref> [5] </ref>. Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation.
Reference: [6] <author> F. Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In M. L. Brodie and J. Mylopoulos, editors, </editor> <booktitle> On Knowledge Base Management Systems: Integrating Artificial Intelligence and Database Technologies. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> This technique also applies to other examples described below. We will discuss the complexity of more general IEC in Section 3. 2 Example 2.2 We now compare our incremental method with the semi-naive evaluation method <ref> [6, 31] </ref>, by considering their computations of the transitive closure query Q after edge (3; 4) is added to the database D in Example 2.1. To make the comparison fair for the semi-naive method, we assume that the semi-naive 4 method also starts with path o available. <p> More importantly, we emphasize the transformation of the original program into a more efficient nonrecursive program. The second basis is designed to fit database application by virtue of efficiency and easy programmability in database query languages. We now briefly compare our approach with related work. Semi-naive evaluation <ref> [6] </ref>. The basic idea of semi-naive evaluation is, in each iteration in the bottom-up evaluation, to compute only those facts that depend on at least one fact computed in the previous iteration.
Reference: [7] <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally embedded query languages. </title> <booktitle> In Proc. 1992 Int. Conference on Database Theory, </booktitle> <volume> LNCS 646, </volume> <pages> pages 140-154. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In the incremental approach only one or two joins are necessary since the needed steps have previously been computed in anticipation. Structural induction <ref> [7] </ref>. The idea is to build a simple programming language whose main computational engine is structural recursion on sets. Our work can be viewed as special cases of structural induction where structural recursion is deterministic and one fact at a time, and uses nonrecursive queries to compute the increment.
Reference: [8] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. Fifth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <year> 1986. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> In this sense, this approach is also similar to ours, though it does not involve database updates or storage of derived relations. Our results may contribute to research on partial evaluation. Magic sets <ref> [8] </ref>. Our incremental approach differs considerably from approaches such as the magic set approach [8] to query optimization. Indeed, incremental query evaluation is driven by anticipation, whereas magic set evaluation is driven by need. <p> In this sense, this approach is also similar to ours, though it does not involve database updates or storage of derived relations. Our results may contribute to research on partial evaluation. Magic sets <ref> [8] </ref>. Our incremental approach differs considerably from approaches such as the magic set approach [8] to query optimization. Indeed, incremental query evaluation is driven by anticipation, whereas magic set evaluation is driven by need. Consequently, it is difficult to combine the two approaches. 29 To see this, consider the path problem in Example 2.1.
Reference: [9] <author> F. Bry, H. Decker and R. Manthey. </author> <title> A uniform approach to constraint satisfaction and constraint satisfiability in deductive databases. </title> <booktitle> In Proc. First Int. Conf. on Extending Database Technology, </booktitle> <pages> pages 488-505, </pages> <year> 1988. </year>
Reference-contexts: This optimization approach is analogous to the incremental checking of integrity constraint satisfaction by using (i) database updates and (ii) the fact that the integrity constraints were satisfied prior to the updates <ref> [9, 28, 29] </ref>. Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database [4, 25]. Our approach is very useful in maintaining materialized views upon updates. <p> This is because the incremental approach only produces facts that use the newly inserted fact in their proofs, and the semi-naive method leads to duplicated derivations at least from the first iteration. Integrity constraint simplification <ref> [9, 28, 29] </ref>.
Reference: [10] <author> A.L. Buchsbaum, P.C. Kanellakis and J.S. Vitter. </author> <title> A data structure for arc insertion and regular path finding. </title> <booktitle> In Proc. ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1990. </year> <month> 31 </month>
Reference-contexts: Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [27]. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs <ref> [10, 14, 20, 21] </ref>. More detailed comparison will be given in Section 6. In general, all these optimization approaches store extra information to reduce the time required for subsequent computations.
Reference: [11] <author> A. Chandra and P. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational data bases. </title> <booktitle> In Proc. ACM SIGACT Symp. on the Theory of Computing, </booktitle> <pages> pages 77-90, </pages> <year> 1977. </year>
Reference-contexts: However, the results cannot be extended to the case where an arbitrary set of tuples is inserted, since for example the transitive closure query (on the inserted set) cannot be computed by a nonrecursive program. Note that nonrecursive programs define unions of conjunctive queries <ref> [11] </ref>. Such queries allow very efficient computations, and have received extensive attention in the literature [3, 31]. As we shall argue later, queries permitting incremental evaluation using conjunctive queries strictly generalize queries computable by nonrecursive programs.
Reference: [12] <author> G. Dong. </author> <title> On Datalog linearization of chain queries. </title> <editor> In J.D. Ullman, editor, </editor> <booktitle> Theoretical Studies in Computer Science, </booktitle> <pages> pages 181-206. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Note that chain Datalog programs contain only variables and binary predicate symbols. Chain Datalog programs and generalizations allow special optimization techniques. Indeed, several papers have considered efficiency issues of such programs <ref> [1, 12, 13] </ref>. The current paper also explores such possibilities. It is well known that, for each chain Datalog program P, the query (P; p) can be associated with a context-free grammar 2 G constructed as follows.
Reference: [13] <author> G. Dong. </author> <title> Datalog expressiveness of chain queries: Grammar tools and characterizations. </title> <booktitle> In Proc. Eleventh ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 81-90, </pages> <year> 1992. </year>
Reference-contexts: Note that chain Datalog programs contain only variables and binary predicate symbols. Chain Datalog programs and generalizations allow special optimization techniques. Indeed, several papers have considered efficiency issues of such programs <ref> [1, 12, 13] </ref>. The current paper also explores such possibilities. It is well known that, for each chain Datalog program P, the query (P; p) can be associated with a context-free grammar 2 G constructed as follows.
Reference: [14] <author> G. Dong and J. Su. </author> <title> First-order on-line computation of transitive closure queries. </title> <booktitle> In Proc. of 16th Australian Computer Science Conference, </booktitle> <pages> pages 721-729, </pages> <year> 1993. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [27]. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs <ref> [10, 14, 20, 21] </ref>. More detailed comparison will be given in Section 6. In general, all these optimization approaches store extra information to reduce the time required for subsequent computations. <p> Incremental evaluation by counting [17]. The basic idea of this work is to use the number of derivation trees to achieve incremental evaluation of Datalog queries. In contrast, among other things, our incremental approach do not create new constants not in the original input database. Incremental evaluation after deletion <ref> [14] </ref>. Complementary to the insertion case presented in this paper, [14] considers the computation of the transitive closure of graphs after the deletion of an edge, and gives nonrecursive queries for such computations for two classes of graphs (including the acyclic graphs). <p> In contrast, among other things, our incremental approach do not create new constants not in the original input database. Incremental evaluation after deletion <ref> [14] </ref>. Complementary to the insertion case presented in this paper, [14] considers the computation of the transitive closure of graphs after the deletion of an edge, and gives nonrecursive queries for such computations for two classes of graphs (including the acyclic graphs). Incremental evaluation of Datalog : and its application to parallelism [34].
Reference: [15] <author> G. Dong and J. Su. </author> <title> First-Order Incremental Evaluation of Datalog Queries. </title> <booktitle> Proceedings of 4th International Workshop on Database Programming Languages, </booktitle> <year> 1993. </year>
Reference: [16] <author> G. Dong and R. Topor. </author> <title> Incremental evaluation of Datalog queries. </title> <booktitle> In Proc. Int. Conference on Database Theory, </booktitle> <volume> LNCS 646, </volume> <pages> pages 282-296. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The counters remember the number of times the fact is derived, and the number of times the fact is deleted. The algorithms can handle general Datalog : programs by using these counters from the appropriate iterations, but at the price of using recursive algorithms. Incremental evaluation of arbitrary Datalog <ref> [16] </ref>. An algorithm is given in [16] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms [21, 20, 26, 24]. <p> The algorithms can handle general Datalog : programs by using these counters from the appropriate iterations, but at the price of using recursive algorithms. Incremental evaluation of arbitrary Datalog <ref> [16] </ref>. An algorithm is given in [16] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms [21, 20, 26, 24].
Reference: [17] <author> A. Gupta, D. Katiyar, and I. S. Mumick. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proceedings of ACM SIGMOD Conference, </booktitle> <pages> pages 157-166. </pages>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Our approach is, however, more restricted as it does not allow negation in rules and queries. Incremental evaluation by counting <ref> [17] </ref>. The basic idea of this work is to use the number of derivation trees to achieve incremental evaluation of Datalog queries. In contrast, among other things, our incremental approach do not create new constants not in the original input database. Incremental evaluation after deletion [14].
Reference: [18] <author> G. G. Hillerbrand, P. C. Kanellakis, H. G. Mairson, and M. Y. Vardi. </author> <title> Tools for Datalog boundedness. </title> <booktitle> In Proc. Tenth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 1-12, </pages> <year> 1991. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Second, semi-naive evaluation does more derivations, at least in iteration one, because of its large initialization. 2 In the remainder of the section, we discuss the equivalence between predicate boundedness and the existence of IEC of a certain form. Predicate boundedness is a special case of boundedness <ref> [22, 18] </ref>. <p> Combining this with Lemma 2.3, we see that queries having IEC strictly generalizes bounded Datalog queries. Since it is undecidable whether an arbitrary Datalog program is predicate bounded <ref> [18] </ref> (even when the program has only one IDB predicate and has only binary IDB predicates [33]), Lemma 2.3 implies the following result: Theorem 2.4 It is undecidable for each arbitrary query (P; p) whether there is an IEC of the form hP p ; fpg; P ffi i. <p> We considered some complexity issues associated with the incremental programs. We also gave decidability result on weak regularity and results on when programs have the cartesian-closed increment property. Queries permitting incremental evaluation using conjunctive queries can be viewed as a strict generalization of bounded recursive Datalog queries <ref> [22, 18] </ref>. In fact, such queries can perhaps be appropriately called incrementally bounded queries. Several problems for future research are listed below. * Incremental evaluation can compute more facts than computation using the original programs.
Reference: [19] <author> G. Hillebrand, P. Kanellakis, H. Mairson, and M. Vardi. </author> <title> Undecidable boundedness problems for Datalog programs. </title> <type> Technical Report RJ 8739, </type> <institution> IBM Almaden Research Center, </institution> <address> San Jose, CA, </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Proposition 5.8 It is undecidable whether an arbitrary program P has CCI with respect to a given predicate. Proof The proof is based on a reduction from the halting problem of Turing machines on empty inputs. The reduction is modified from the one used by Vardi et al <ref> [33, 19] </ref> in proving the undecidability of boundedness for binary Datalog programs. We briefly describe their reduction and the changes below. Let M be a Turing machine with one-way infinite tape, an alphabet S, a set K of states, and a starting state s 2 K. <p> A constant c encodes a iff q a (c) is true. The predicates succ represents the adjacency relation and first the first symbol. Intuitively, succ represents a word over S 0 [ f#g which possibly encodes a computation of M . In <ref> [33, 19] </ref>, it was shown that a Datalog program P 0 with only one binary IDB predicate FING can be constructed such that when the input is not a proper encoding or is an encoded halting computation, then P 0 floods FING, i.e., inserting every pair of constants into FING.
Reference: [20] <author> T. Ibaraki and N. Katoh. </author> <title> On-line computation of transitive closure of graphs. </title> <journal> Information Processing Letters, </journal> <volume> 16 </volume> <pages> 95-97, </pages> <year> 1983. </year>
Reference-contexts: Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [27]. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs <ref> [10, 14, 20, 21] </ref>. More detailed comparison will be given in Section 6. In general, all these optimization approaches store extra information to reduce the time required for subsequent computations. <p> Incremental evaluation of arbitrary Datalog [16]. An algorithm is given in [16] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms <ref> [21, 20, 26, 24] </ref>. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [21, 20], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [24]. <p> An algorithm is given in [16] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms [21, 20, 26, 24]. Graph algorithms for on-line evaluation of transitive closure of graphs are given in <ref> [21, 20] </ref>, and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [24]. The main difference is that they use more elaborate data structures and recursive algorithms, whereas we only use relations and nonrecursive Datalog programs.
Reference: [21] <author> G.F. </author> <title> Italiano. Amortized efficiency of a path retrieval data structure. </title> <journal> Theoretical Computer Science, </journal> <volume> 48 </volume> <pages> 273-281, </pages> <year> 1986. </year>
Reference-contexts: Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [27]. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs <ref> [10, 14, 20, 21] </ref>. More detailed comparison will be given in Section 6. In general, all these optimization approaches store extra information to reduce the time required for subsequent computations. <p> Incremental evaluation of arbitrary Datalog [16]. An algorithm is given in [16] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms <ref> [21, 20, 26, 24] </ref>. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [21, 20], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [24]. <p> An algorithm is given in [16] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms [21, 20, 26, 24]. Graph algorithms for on-line evaluation of transitive closure of graphs are given in <ref> [21, 20] </ref>, and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [24]. The main difference is that they use more elaborate data structures and recursive algorithms, whereas we only use relations and nonrecursive Datalog programs.
Reference: [22] <author> Y. Ioannidis. </author> <title> A time bound on the materialization of some recursively defined views. </title> <booktitle> In Proc. of International Conference on Very Large Data Bases, </booktitle> <year> 1985. </year>
Reference-contexts: Second, semi-naive evaluation does more derivations, at least in iteration one, because of its large initialization. 2 In the remainder of the section, we discuss the equivalence between predicate boundedness and the existence of IEC of a certain form. Predicate boundedness is a special case of boundedness <ref> [22, 18] </ref>. <p> We considered some complexity issues associated with the incremental programs. We also gave decidability result on weak regularity and results on when programs have the cartesian-closed increment property. Queries permitting incremental evaluation using conjunctive queries can be viewed as a strict generalization of bounded recursive Datalog queries <ref> [22, 18] </ref>. In fact, such queries can perhaps be appropriately called incrementally bounded queries. Several problems for future research are listed below. * Incremental evaluation can compute more facts than computation using the original programs.
Reference: [23] <author> D. Jacobs and R. Hull. </author> <title> Database programming with delayed updates. </title> <booktitle> In Proc. 3rd Int. Workshop on Database Programming Languages, </booktitle> <pages> pages 416-428, </pages> <year> 1991. </year>
Reference-contexts: Computing Datalog queries using IEC is also related to the bounded iteration constructs [30] and the more general treatment of database states and their differences (deltas) <ref> [23] </ref>. 7 Conclusions and Research Problems We have considered the incremental evaluation problem for Datalog queries. The main idea is to use the facts computed in one state to reduce the cost of computing the answer to the same query after the insertion of a bounded number of facts.
Reference: [24] <author> H. Jakobsson. </author> <title> On materializing views and on-line queries. </title> <booktitle> In Proc. Int. Conference on Database Theory, </booktitle> <volume> LNCS 646, </volume> <pages> pages 407-420. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Incremental evaluation of arbitrary Datalog [16]. An algorithm is given in [16] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms <ref> [21, 20, 26, 24] </ref>. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [21, 20], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [24]. <p> Graph algorithms [21, 20, 26, 24]. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [21, 20], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in <ref> [24] </ref>. The main difference is that they use more elaborate data structures and recursive algorithms, whereas we only use relations and nonrecursive Datalog programs. We now compare with some other optimization approaches which are not incremental. Partial evaluation in logic programming [27].
Reference: [25] <author> V. K uchenhoff. </author> <title> On the efficient computation of the difference between consecutive database states. </title> <editor> In C. Delobel, M. Kifer, and Y. Masunaga, editors, </editor> <booktitle> Proc. Second Int. Conf. on Deductive Object-Oriented Databases, </booktitle> <volume> LNCS 566, </volume> <pages> pages 478-502. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <month> 32 </month>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database <ref> [4, 25] </ref>. Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs [27]. <p> Our approach, for query evaluation rather than for constraint checking, differs in storing previous derived relations and in transforming the programs used in query evaluation. Efficient maintenance of (stratified) databases <ref> [4, 25] </ref>. The goal of this approach is to efficiently compute the standard model of a stratified database after a database update. <p> Our approach differs by storing intermediate relations rather than reasons (or supports) for including computed facts [4], by not using meta-programs to compute the difference between successive models <ref> [25] </ref>, and by transforming the programs used in query evaluation. Our approach is, however, more restricted as it does not allow negation in rules and queries. Incremental evaluation by counting [17].
Reference: [26] <author> J. La Poutre and J. van Leeuwen. </author> <title> Maintenance of transitive closures and transitive reductions of graphs. </title> <type> Technical Report RUU-CS-87-25, </type> <institution> Department of Computer Science, University of Utrecht, </institution> <address> The Netherlands, </address> <year> 1987. </year> <note> An extended abstract of this paper appeared in LNCS 314, pp. 106-120. </note>
Reference-contexts: Incremental evaluation of arbitrary Datalog [16]. An algorithm is given in [16] for transforming an arbitrary Datalog query into an incremental query for arbitrary updates, but which is not in general nonrecursive. Graph algorithms <ref> [21, 20, 26, 24] </ref>. Graph algorithms for on-line evaluation of transitive closure of graphs are given in [21, 20], and a method to optimize transitive queries by using subtrees in graphs constructed in previous evaluations is presented in [24].
Reference: [27] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 217-242, </pages> <year> 1991. </year>
Reference-contexts: Datalog provides a way of incorporating recursion into a query language. However, it also raises the complexity of query evaluation. The problem of efficiently computing Datalog queries has attracted a great deal of attention in the database and logic programming communities e.g., <ref> [6, 8, 12, 14, 17, 18, 24, 25, 27] </ref>. In this paper, we consider the problem of repeatedly evaluating the same (computationally expensive) Datalog query to a database that is being updated between successive query requests. <p> Our approach is very useful in maintaining materialized views upon updates. It is also closely related to the problem of partially evaluating definite logic programs <ref> [27] </ref>. Finally, when restricted to standard transitive closure programs, our task can be viewed as solving the incremental transitive closure computation problem for graphs [10, 14, 20, 21]. More detailed comparison will be given in Section 6. <p> The main difference is that they use more elaborate data structures and recursive algorithms, whereas we only use relations and nonrecursive Datalog programs. We now compare with some other optimization approaches which are not incremental. Partial evaluation in logic programming <ref> [27] </ref>. The idea of partial evaluation is to propagate given facts into programs so that subsequent queries involving those facts can be evaluated more efficiently. In this sense, this approach is also similar to ours, though it does not involve database updates or storage of derived relations.
Reference: [28] <author> J. W. Lloyd, E. A. Sonenberg, and R. W. Topor. </author> <title> Integrity constraint checking in stratified databases. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 331-343, </pages> <year> 1987. </year>
Reference-contexts: This optimization approach is analogous to the incremental checking of integrity constraint satisfaction by using (i) database updates and (ii) the fact that the integrity constraints were satisfied prior to the updates <ref> [9, 28, 29] </ref>. Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database [4, 25]. Our approach is very useful in maintaining materialized views upon updates. <p> This is because the incremental approach only produces facts that use the newly inserted fact in their proofs, and the semi-naive method leads to duplicated derivations at least from the first iteration. Integrity constraint simplification <ref> [9, 28, 29] </ref>.
Reference: [29] <author> J-M. Nicolas. </author> <title> Logic for improving integrity checking in relational data bases. </title> <journal> Acta Informatica, </journal> <volume> 18(3) </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference-contexts: This optimization approach is analogous to the incremental checking of integrity constraint satisfaction by using (i) database updates and (ii) the fact that the integrity constraints were satisfied prior to the updates <ref> [9, 28, 29] </ref>. Our task is closely related to the problem of efficiently updating the standard model [2] of a definite or more generally stratified database [4, 25]. Our approach is very useful in maintaining materialized views upon updates. <p> This is because the incremental approach only produces facts that use the newly inserted fact in their proofs, and the semi-naive method leads to duplicated derivations at least from the first iteration. Integrity constraint simplification <ref> [9, 28, 29] </ref>.
Reference: [30] <author> X. Qian. </author> <title> On the expressive power of the bounded iteration construct. </title> <booktitle> In Proc. 2nd Int. Workshop on Database Programming Languages, </booktitle> <pages> pages 411-421, </pages> <year> 1989. </year>
Reference-contexts: Our work can be viewed as special cases of structural induction where structural recursion is deterministic and one fact at a time, and uses nonrecursive queries to compute the increment. Computing Datalog queries using IEC is also related to the bounded iteration constructs <ref> [30] </ref> and the more general treatment of database states and their differences (deltas) [23]. 7 Conclusions and Research Problems We have considered the incremental evaluation problem for Datalog queries.
Reference: [31] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-base Systems, Vols I and II. 1989, </title> <publisher> Computer Science Press. </publisher>
Reference-contexts: Nonrecursive Datalog programs are effectively unions of conjunctive queries, which permit efficient computation methods <ref> [31] </ref> and are more suitable for parallel computation than recursive Datalog and recursive algorithms embedding relational operations. For database applications, we believe that nonrecursive Datalog programs are much better than recursive graph algorithms using elaborate data structures even though the latter have lower sequential complexity. <p> Note that nonrecursive programs define unions of conjunctive queries [11]. Such queries allow very efficient computations, and have received extensive attention in the literature <ref> [3, 31] </ref>. As we shall argue later, queries permitting incremental evaluation using conjunctive queries strictly generalize queries computable by nonrecursive programs. We assume familiarity with the relational databases and the Datalog language [31]. 2 We assume the existence of three pairwise disjoint infinite sets of constants, variables, and predicates. <p> Such queries allow very efficient computations, and have received extensive attention in the literature [3, 31]. As we shall argue later, queries permitting incremental evaluation using conjunctive queries strictly generalize queries computable by nonrecursive programs. We assume familiarity with the relational databases and the Datalog language <ref> [31] </ref>. 2 We assume the existence of three pairwise disjoint infinite sets of constants, variables, and predicates. Predicates are divided into extensional (or EDB) predicates and intensional (or IDB) predicates. Built-in predicates such as equality are disallowed. Each predicate has a positive arity. <p> This technique also applies to other examples described below. We will discuss the complexity of more general IEC in Section 3. 2 Example 2.2 We now compare our incremental method with the semi-naive evaluation method <ref> [6, 31] </ref>, by considering their computations of the transitive closure query Q after edge (3; 4) is added to the database D in Example 2.1. To make the comparison fair for the semi-naive method, we assume that the semi-naive 4 method also starts with path o available. <p> A program P is nonredundant if, for each rule r in P, r is nonredundant and P 6 P frg. In <ref> [31] </ref> nonredundant rules (programs) are termed minimal rules (programs), and a detailed discussion and a method (based on containment substitution defined below) for obtaining minimal equivalent program of a nonrecursive program are given. <p> Again by Lemma 5.3 P is redundant, a contradiction. 2 Since a nonredundant equivalent of a nonrecursive, single IDB-predicate program can be constructed <ref> [31] </ref>, we have the following: Corollary 5.6 It is decidable whether arbitrary nonrecursive, single IDB-predicate programs with binary IDB predicates (or unions of binary conjunctive queries) have CCI. 2 Although CCI for unions of conjunctive queries is decidable, it is also interesting to know, for a fixed k, if a nonrecursive
Reference: [32] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: The result P (D) of applying a Datalog program P to a set D of facts is the set of IDB facts in the least (Herbrand) model for P [ D or, equivalently, the set of IDB facts that are logical consequences of P [ D <ref> [32] </ref>. The answer Q (D) to a query Q = (P; p) on a database D is simply the set 1 of facts P (D)j p .
Reference: [33] <author> M. Vardi. </author> <title> Decidability and undecidability results for boundedness of linear recursive programs. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 341-351, </pages> <year> 1988. </year>
Reference-contexts: Combining this with Lemma 2.3, we see that queries having IEC strictly generalizes bounded Datalog queries. Since it is undecidable whether an arbitrary Datalog program is predicate bounded [18] (even when the program has only one IDB predicate and has only binary IDB predicates <ref> [33] </ref>), Lemma 2.3 implies the following result: Theorem 2.4 It is undecidable for each arbitrary query (P; p) whether there is an IEC of the form hP p ; fpg; P ffi i. <p> Proposition 5.8 It is undecidable whether an arbitrary program P has CCI with respect to a given predicate. Proof The proof is based on a reduction from the halting problem of Turing machines on empty inputs. The reduction is modified from the one used by Vardi et al <ref> [33, 19] </ref> in proving the undecidability of boundedness for binary Datalog programs. We briefly describe their reduction and the changes below. Let M be a Turing machine with one-way infinite tape, an alphabet S, a set K of states, and a starting state s 2 K. <p> A constant c encodes a iff q a (c) is true. The predicates succ represents the adjacency relation and first the first symbol. Intuitively, succ represents a word over S 0 [ f#g which possibly encodes a computation of M . In <ref> [33, 19] </ref>, it was shown that a Datalog program P 0 with only one binary IDB predicate FING can be constructed such that when the input is not a proper encoding or is an encoded halting computation, then P 0 floods FING, i.e., inserting every pair of constants into FING.
Reference: [34] <author> O. Wolfson, H.M. Dewan, S.J. Stolfo, and Y. Yemini. </author> <title> Incremental Evaluation of Rules and Its Relationship to Parallelism. </title> <booktitle> In Proc. of ACM SIGMOD Conference, </booktitle> <pages> pages 78-87, </pages> <year> 1991. </year> <month> 33 </month>
Reference-contexts: Incremental evaluation of Datalog : and its application to parallelism <ref> [34] </ref>. The approach in this work associates with each derived fact a collection of records of counters, one for each iteration in bottom-up evaluation. The counters remember the number of times the fact is derived, and the number of times the fact is deleted.
References-found: 34

