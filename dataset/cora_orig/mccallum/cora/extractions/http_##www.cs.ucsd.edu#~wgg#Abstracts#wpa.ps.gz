URL: http://www.cs.ucsd.edu/~wgg/Abstracts/wpa.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/wpa.html
Root-URL: http://www.cs.ucsd.edu
Note: Copyright 1996 IEEE. Published in the Proceedings of the 18th International Conference on Software Engineering (ICSE-18), March 25-29, 1996, Berlin, Germany. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE.  
Abstract: Correction: At the beginning of Section 4.1, the paper states Our analysis of the times and sizes of the slices suggests that they are linearly related. However, Table 2 on the previous page clearly shows a quadratic relationship; linearly should be replaced by quadratic in the above statement. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: One such representation is the program dependence graph (PDG) [7], in which nodes denote operations and edges denote dependencies between operations. Program slicing using the PDG is simple and algorithmically efficient, once the PDG has been constructed [18]. More traditional representations include the control-flow graph (CFG) and dominator trees <ref> [1] </ref>. However, program understanding tasks are interactive, unlike compilation, and an analysis such as slicing is often applied iteratively to answer a programmer's question about the program. Thus, a whole-program analysis tool must perform analyses quickly in order to effectively answer many of the questions posed by programmers and designers. <p> Although this information is demanded like other representations, it is stored on disk rather than discarded. Subsequent runs of the slicer on the same program can reuse this information as long as the program has not changed. Many control-flow and data-flow analysessuch as interval analysis <ref> [1] </ref> or alias analysis [16, 2]are sufficiently complicated without the additional burden of requiring the algorithm to demand-derive additional data structures. It is desirable to make minimal changes to these algorithms when addressing the problems encountered when analyzing large systems. <p> However, because an algorithm can require between polynomial and exponential time, depending on its precision, it is also necessary to control the time complexity of the algorithm itself in order to obtain acceptable performance of a whole-program analysis tool. Since many data-flow analyses are iterative <ref> [1] </ref>, significant improvements can be achieved by either reducing the running time of each iteration or by reducing the number of iterations performed.
Reference: [2] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <address> Charleston, SC, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Although this information is demanded like other representations, it is stored on disk rather than discarded. Subsequent runs of the slicer on the same program can reuse this information as long as the program has not changed. Many control-flow and data-flow analysessuch as interval analysis [1] or alias analysis <ref> [16, 2] </ref>are sufficiently complicated without the additional burden of requiring the algorithm to demand-derive additional data structures. It is desirable to make minimal changes to these algorithms when addressing the problems encountered when analyzing large systems.
Reference: [3] <author> J.-D. Choi, R. Cytron, and J. Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> In Proceedings of the 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <address> Orlando, FL, </address> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: However, if the representations were to be retained for later use, as required by a whole-program analysis tool, then the resulting space could be prohibitive. A demand-driven algorithm <ref> [3, 4, 12] </ref> can reduce the space (and time) requirements of an analysis by ignoring portions of the program that are irrelevant to the analysis.
Reference: [4] <author> J.-D. Choi, R. Cytron, and J. Ferrante. </author> <title> On the efficient engineering of ambitious program analysis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(2) </volume> <pages> 105-114, </pages> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: However, if the representations were to be retained for later use, as required by a whole-program analysis tool, then the resulting space could be prohibitive. A demand-driven algorithm <ref> [3, 4, 12] </ref> can reduce the space (and time) requirements of an analysis by ignoring portions of the program that are irrelevant to the analysis.
Reference: [5] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Although in some analyses the intermediate representations may be a priori discarded, in others many must be retained [9]. Our slicer, for example, depends upon a CFG, dominance frontiers <ref> [5] </ref>, and an AST for display. Thus, there are many representations for each procedure in the program, but large portions of some of these representations are used infrequently or not at all.
Reference: [6] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 20-24, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In contrast, the invocation graph approach <ref> [6] </ref> is fully context-sensitive since each procedure has a distinct calling context for each possible call sequence starting from the main procedure of the program. 2 The invocation graph can be understood as treating all the procedures as inlined at their call sites.
Reference: [7] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: In order to analyze a program, such tools construct control-flow and data-flow representations of the program, similar to those used by an optimizing compiler. One such representation is the program dependence graph (PDG) <ref> [7] </ref>, in which nodes denote operations and edges denote dependencies between operations. Program slicing using the PDG is simple and algorithmically efficient, once the PDG has been constructed [18]. More traditional representations include the control-flow graph (CFG) and dominator trees [1].
Reference: [8] <author> W. G. Griswold and D. C. Atkinson. </author> <title> Managing the design trade-offs for a program understanding and transformation tool. </title> <journal> Journal of Systems and Software, 30(1-2):99-116, </journal> <volume> July-Aug. </volume> <year> 1995. </year>
Reference-contexts: second item in Table 1 illustrates, 1 although the size of an AST is linear in the size of the program, the space consumed by an AST constructed for CHCS, 414 MB, exceeds the capacity of the main memory of the machine, even though care was exercised in its design <ref> [8] </ref>. In such cases, the time required to first construct the representation and then later retrieve it from the slower portions of the memory hierarchy for actual use may be unacceptable. <p> To accommodate the needed changes in control-flow without compromising independence, our solution is to modify the existing architecture to use events and mappings. This architecture borrows from our previous experience with layered and event-based architectures <ref> [10, 8] </ref>, but these architectures do not accommodate demand-driven computation or discarding. Figure 2 presents an example of our architecture containing three program representations the program text, the AST, and the CFGwith each representation fully encapsulated inside a module.
Reference: [9] <author> W. G. Griswold and D. Notkin. </author> <title> Automated assistance for program restructuring. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(3) </volume> <pages> 228-269, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: However, we have found that demand-driven construction of a single program representation does not sufficiently reduce the space requirements, since many program representations are derived from other representations. Although in some analyses the intermediate representations may be a priori discarded, in others many must be retained <ref> [9] </ref>. Our slicer, for example, depends upon a CFG, dominance frontiers [5], and an AST for display. Thus, there are many representations for each procedure in the program, but large portions of some of these representations are used infrequently or not at all.
Reference: [10] <author> W. G. Griswold and D. Notkin. </author> <title> Architectural tradeoffs for a meaning-preserving program restructuring tool. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 275-287, </pages> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: To accommodate the needed changes in control-flow without compromising independence, our solution is to modify the existing architecture to use events and mappings. This architecture borrows from our previous experience with layered and event-based architectures <ref> [10, 8] </ref>, but these architectures do not accommodate demand-driven computation or discarding. Figure 2 presents an example of our architecture containing three program representations the program text, the AST, and the CFGwith each representation fully encapsulated inside a module.
Reference: [11] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Using a depth-3 context-graph, which is equivalent to the unbounded-depth context-graph for our sample program, will result in a precise analysis. Unless an unbounded-depth context-graph is used, data may be propagated along unrealizable paths <ref> [12, 11] </ref>. For example, data merged at the return statements of C, which is the source of the imprecision, is propagated along unrealizable paths (e.g., the data of A is propagated through C to B). Our slicing algorithm tries to avoid unrealizable paths.
Reference: [12] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedu-ral dataflow analysis. </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 104-115, </pages> <address> Washington, DC, </address> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: However, if the representations were to be retained for later use, as required by a whole-program analysis tool, then the resulting space could be prohibitive. A demand-driven algorithm <ref> [3, 4, 12] </ref> can reduce the space (and time) requirements of an analysis by ignoring portions of the program that are irrelevant to the analysis. <p> Using a depth-3 context-graph, which is equivalent to the unbounded-depth context-graph for our sample program, will result in a precise analysis. Unless an unbounded-depth context-graph is used, data may be propagated along unrealizable paths <ref> [12, 11] </ref>. For example, data merged at the return statements of C, which is the source of the imprecision, is propagated along unrealizable paths (e.g., the data of A is propagated through C to B). Our slicing algorithm tries to avoid unrealizable paths.
Reference: [13] <author> D. Jackson. </author> <title> ASPECT: An economical bug-detector. </title> <booktitle> In Proceedings of the 13th International Conference on Software Engineering, </booktitle> <pages> pages 13-22, </pages> <address> Austin, TX, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: For instance, a program slicer computes the set of statements in a program that may affect the value of a programmer-specified variable [26]. A static assertion checker such as ASPECT checks the consistency of a program's data-flow and control-flow characteristics against declared computational dependencies <ref> [13] </ref>. In order to analyze a program, such tools construct control-flow and data-flow representations of the program, similar to those used by an optimizing compiler. One such representation is the program dependence graph (PDG) [7], in which nodes denote operations and edges denote dependencies between operations.
Reference: [14] <author> D. Jackson and E. J. Rollins. </author> <title> A new model of program dependences for reverse engineering. </title> <booktitle> In Proceedings of the 2nd ACM Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 2-10, </pages> <address> New Orleans, LA, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Additionally, B may not be called from M if the call paths are constrained, as in chopping. <ref> [14, 20] </ref> routine line no. variable procedures depth contexts time (min) space (MB) size of slice (stmts) COMARG 15 ERRTYP 26 1 26 0.017 0.29 488 2 49 0.033 0.37 483 unbounded 363 0.217 0.97 483 COMBLK 14 ERRTYP 36 1 36 0.030 0.37 780 2 74 0.058 0.43 774 unbounded
Reference: [15] <author> S. C. Johnson. </author> <title> A portable compiler: Theory and practice. </title> <booktitle> In Proceedings of the 5th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-104, </pages> <address> Tucson, AZ, </address> <month> Jan. </month> <year> 1978. </year>
Reference-contexts: This concept of processing granularity for events and the construction of program representations unifies the entire architecture, since it naturally exploits the structure of the problem <ref> [15] </ref>, namely interprocedural analysis. The in-traprocedural algorithms are unaffected. If the CFG was constructed incrementally for each statement and the AST constructed incrementally for each file, the resulting architecture would be more complicated. Address-independent mappings: If a representation may be discarded, the mapping module must support address-independent mappings.
Reference: [16] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Although this information is demanded like other representations, it is stored on disk rather than discarded. Subsequent runs of the slicer on the same program can reuse this information as long as the program has not changed. Many control-flow and data-flow analysessuch as interval analysis [1] or alias analysis <ref> [16, 2] </ref>are sufficiently complicated without the additional burden of requiring the algorithm to demand-derive additional data structures. It is desirable to make minimal changes to these algorithms when addressing the problems encountered when analyzing large systems.
Reference: [17] <author> M. M. Lehman and L. A. Belady, </author> <title> editors. Program Evolu--tion: Processes of Software Change. </title> <publisher> Academic Press, </publisher> <address> Or-lando, FL, </address> <year> 1985. </year>
Reference-contexts: Finally, these large systems have been evolved in this fashion over several years, with modification after modification being layered upon the original implementation by several generations of programmers. The resulting complexity may be exponential in the age of the system <ref> [17] </ref>. Many of these systems are still in use today, such as the Comprehensive Health Care System (CHCS), a 1,000,000 line hospital management system that we are analyzing in collaboration with Science Applications International Corporation (SAIC).
Reference: [18] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 23-25, </pages> <address> Pittsburgh, PA, </address> <month> Apr. </month> <year> 1984. </year>
Reference-contexts: One such representation is the program dependence graph (PDG) [7], in which nodes denote operations and edges denote dependencies between operations. Program slicing using the PDG is simple and algorithmically efficient, once the PDG has been constructed <ref> [18] </ref>. More traditional representations include the control-flow graph (CFG) and dominator trees [1]. However, program understanding tasks are interactive, unlike compilation, and an analysis such as slicing is often applied iteratively to answer a programmer's question about the program.
Reference: [19] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> Dec. </month> <year> 1972. </year>
Reference-contexts: 1 Introduction 1.1 Motivation Software designers and maintainers need to understand their systems if their successful development and maintenance is to continue. Unfortunately, large software systems are difficult to understand, in part because of their age. Some were not implemented using modern programming techniques such as information hiding <ref> [19] </ref>, which can help reduce the complexity of a system.
Reference: [20] <author> T. Reps and G. Rosay. </author> <title> Precise interprocedural chopping. </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 41-52, </pages> <address> Washington, DC, </address> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: Additionally, B may not be called from M if the call paths are constrained, as in chopping. <ref> [14, 20] </ref> routine line no. variable procedures depth contexts time (min) space (MB) size of slice (stmts) COMARG 15 ERRTYP 26 1 26 0.017 0.29 488 2 49 0.033 0.37 483 unbounded 363 0.217 0.97 483 COMBLK 14 ERRTYP 36 1 36 0.030 0.37 780 2 74 0.058 0.43 774 unbounded
Reference: [21] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: One approach is to allow the tool user to specify the interprocedural context-sensitivity of the algorithm. Before we describe our support for this feature, we present some background on precision and context-sensitivity. Recent work has focused on the trade-offs between context-sensitive and context-insensitive analyses <ref> [27, 21] </ref>. Many approaches such as the slicing algorithm of Weiser [26] use only a single calling context for each procedurethat is, there is no accounting of the calling sequence that led to the call in order to precisely estimate the calling sequence's influenceand therefore are context-insensitive.
Reference: [22] <author> O. Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> Ph.D. dissertation, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: However, D still has only a single calling context since the call stacks M A C D and M B C D are equivalent, as both have a depth-2 call stack of C D. This approach is similar to the approach of Shivers <ref> [22] </ref> for analyzing control-flow in languages with functions as first-class objects. A depth-1 context-graph has an equal number of procedures and contexts, resulting in a high degree of imprecision but an efficient analysis.
Reference: [23] <author> B. Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings of the 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, FL, </address> <month> Jan. </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Although C has aliasing through pointers, our implementation for MUMPS handles dynamic scoping as pointer aliasing. Also, some of the newer results in points-to analysis <ref> [23] </ref> should make it possible to inexpensively compute alias relations on a demand basis. Our intuition is that the performance results for analyzing C programs should be similar. Acknowledgments: Thanks to David Notkin and Jeanne Ferrante for their help on improving the organization of this paper.
Reference: [24] <author> K. J. Sullivan. Mediators: </author> <title> Easing the Design and Evolution of Integrated Systems. </title> <type> Ph.D. dissertation, </type> <institution> University of Washington, Department of Computer Science & Engineering, </institution> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: These mappings could be maintained explicitly within each module (e.g., by having each AST node contain a pointer to its corresponding CFG statement), but this would reduce the independence of the individual modules [25]. Instead, we use separate mediators to maintain mappings between the modules <ref> [24, 25] </ref>. However, since the representations need to be constructed on demand, each mediator may call the required construction module for the representation, as shown in Figure 2.
Reference: [25] <author> K. J. Sullivan and D. Notkin. </author> <title> Reconciling environment integration and component independence. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(3) </volume> <pages> 229-268, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: These mappings could be maintained explicitly within each module (e.g., by having each AST node contain a pointer to its corresponding CFG statement), but this would reduce the independence of the individual modules <ref> [25] </ref>. Instead, we use separate mediators to maintain mappings between the modules [24, 25]. However, since the representations need to be constructed on demand, each mediator may call the required construction module for the representation, as shown in Figure 2. <p> These mappings could be maintained explicitly within each module (e.g., by having each AST node contain a pointer to its corresponding CFG statement), but this would reduce the independence of the individual modules [25]. Instead, we use separate mediators to maintain mappings between the modules <ref> [24, 25] </ref>. However, since the representations need to be constructed on demand, each mediator may call the required construction module for the representation, as shown in Figure 2. <p> Rather than have the CFG module call the AST-CFG mediator, which would require a modification to the CFG module and consequently reduce its independence, our solution is to use events <ref> [25] </ref>, shown in Figure 2 as dashes. The CFG module can send an event announcing that it is about to execute the called routine operation. The mediator module hears this announcement, and thus responds to the event by calling the code generator, if necessary.
Reference: [26] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Because of their complexity, large systems can greatly benefit from automated support for program understanding. Several automated semantic techniques have been developed for understanding software. For instance, a program slicer computes the set of statements in a program that may affect the value of a programmer-specified variable <ref> [26] </ref>. A static assertion checker such as ASPECT checks the consistency of a program's data-flow and control-flow characteristics against declared computational dependencies [13]. In order to analyze a program, such tools construct control-flow and data-flow representations of the program, similar to those used by an optimizing compiler. <p> Before we describe our support for this feature, we present some background on precision and context-sensitivity. Recent work has focused on the trade-offs between context-sensitive and context-insensitive analyses [27, 21]. Many approaches such as the slicing algorithm of Weiser <ref> [26] </ref> use only a single calling context for each procedurethat is, there is no accounting of the calling sequence that led to the call in order to precisely estimate the calling sequence's influenceand therefore are context-insensitive.
Reference: [27] <author> R. P. Wilson and M. S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: One approach is to allow the tool user to specify the interprocedural context-sensitivity of the algorithm. Before we describe our support for this feature, we present some background on precision and context-sensitivity. Recent work has focused on the trade-offs between context-sensitive and context-insensitive analyses <ref> [27, 21] </ref>. Many approaches such as the slicing algorithm of Weiser [26] use only a single calling context for each procedurethat is, there is no accounting of the calling sequence that led to the call in order to precisely estimate the calling sequence's influenceand therefore are context-insensitive.
References-found: 27

