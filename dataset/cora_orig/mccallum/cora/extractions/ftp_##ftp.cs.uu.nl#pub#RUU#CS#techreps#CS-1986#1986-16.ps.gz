URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1986/1986-16.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: kuiper@cs.ruu.nl  
Title: Using attribute grammars to derive efficient functional programs  
Author: M.F. Kuiper and S.D. Swierstra 
Address: P.O.Box 80.089, 3508 TB Utrecht, The Netherlands  
Affiliation: Department of Computer Science, University of Utrecht  
Abstract: Two mappings from attribute grammars to lazy functional programs are defined. One of these mappings is an efficient implementation of attribute grammars. The other mapping yields inefficient programs. It is shown how some transformations of functional programs may be better understood by viewing the programs as inefficient implementations of attribute grammars.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.S. Bird. </author> <title> Using circular programs to eliminate multiple traversals of data. </title> <journal> Acta Informatica, </journal> <volume> 21 </volume> <pages> 239-250, </pages> <year> 1984. </year>
Reference-contexts: Published by SION in 1987. 1 Mapping CIRC can also be used to implement attribute grammars. CIRC yields attribute evaluators that visit each node of a structure tree only once and that perform no reevaluations of attribute values. 1.1 An example The following example has been taken from <ref> [1] </ref>. The problem is to write a program that takes as input a non-empty binary tree t. Every leaf of t is labeled with an integer value. <p> Bird <ref> [1] </ref> uses various rewrite techniques to obtain a solution that visits every node of the tree only once. We will call such a solution a one touch solution. A different way to obtain a one touch solution is to write an attribute grammar for the input trees.
Reference: [2] <author> P. Deransart and J. Maluszynski. </author> <title> Relating Logic Programs and Attribute Grammars. </title> <type> Technical Report 393, </type> <institution> INRIA, </institution> <month> April </month> <year> 1985. </year>
Reference-contexts: Katayama [7] translates attribute grammars into Pascal procedures. In his scheme attributes may be evaluated more than once, although he claims otherwise. An overview of these and other evaluation techniques is given in [3]. Deransart and Maluszynski <ref> [2] </ref> use attribute grammars to analyse logic programs. They derive conditions under which a Prolog program allows a nonstandard, but efficient, evaluation strategy. 13 Takeichi [12] obtains one touch algorithms by introducing higher order func-tions.
Reference: [3] <author> J. Engelfriet. </author> <title> Attribute grammars: attribute evaluation methods. </title> <editor> In B. Lorho, editor, </editor> <booktitle> Methods and Tools For Compiler Construction, </booktitle> <pages> pages 103-138, </pages> <publisher> Cambridge University Press, </publisher> <year> 1984. </year>
Reference-contexts: His translation yields a correct implementation for the class of absolutely noncircular attribute grammars [8]. Katayama [7] translates attribute grammars into Pascal procedures. In his scheme attributes may be evaluated more than once, although he claims otherwise. An overview of these and other evaluation techniques is given in <ref> [3] </ref>. Deransart and Maluszynski [2] use attribute grammars to analyse logic programs. They derive conditions under which a Prolog program allows a nonstandard, but efficient, evaluation strategy. 13 Takeichi [12] obtains one touch algorithms by introducing higher order func-tions.
Reference: [4] <editor> J. Hughes. Lazy memo-functions. In J-P. Jouannaud, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 129-146, </pages> <publisher> Springer, </publisher> <year> 1985. </year>
Reference-contexts: From the conditions it follows that the above is the definition of an attribute grammar. It is straightforward to check that, after renaming some identifiers, F=SIM (AG). 2 In the remainder of this section we will demonstrate our technique with a simple example. The problem <ref> [4] </ref> is to find the deepest nodes of a tree. A tree may have many leaves at the same depth so the result is a list of leaves. The program we derive is lazy: only lists that are needed to construct the answer are computed.
Reference: [5] <author> M. Jourdan. </author> <title> An Efficient Recursive Evaluator for Strongly Non-circular Attribute Grammars. </title> <type> Technical Report 235, </type> <institution> INRIA, </institution> <month> October </month> <year> 1983. </year>
Reference-contexts: Jourdan <ref> [5] </ref> gives a mapping from attribute grammars to functions. His target language is a non-lazy functional language. His translation yields a correct implementation for the class of absolutely noncircular attribute grammars [8]. Katayama [7] translates attribute grammars into Pascal procedures.
Reference: [6] <author> U. Kastens, B. Hutt, and E. Zimmerman. GAG: </author> <title> A Practical Compiler Generator. </title> <publisher> Springer, </publisher> <year> 1982. </year>
Reference-contexts: They specify the computation of attribute values attached to nodes in a structure tree. An attribute grammar can be transformed into a compiler <ref> [6] </ref>. A compiler based on attribute grammars usually consists of two parts: the first 5 part parses the input and builds a structure tree; the second part, the attri-bute evaluator, decorates the structure tree i.e. it evaluates attributes that are attached to the nodes of the tree.
Reference: [7] <author> T. Katayama. </author> <title> Translation of attribute grammars into procedures. </title> <journal> TOPLAS, </journal> <volume> 6(3) </volume> <pages> 345-369, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Jourdan [5] gives a mapping from attribute grammars to functions. His target language is a non-lazy functional language. His translation yields a correct implementation for the class of absolutely noncircular attribute grammars [8]. Katayama <ref> [7] </ref> translates attribute grammars into Pascal procedures. In his scheme attributes may be evaluated more than once, although he claims otherwise. An overview of these and other evaluation techniques is given in [3]. Deransart and Maluszynski [2] use attribute grammars to analyse logic programs.
Reference: [8] <author> K. Kennedy and S.Warren. </author> <title> Automatic generation of efficient evaluators for attribute grammars. </title> <booktitle> In Proceedings of third conference on POPL, </booktitle> <pages> pages 32-49, </pages> <publisher> ACM, </publisher> <year> 1976. </year>
Reference-contexts: Jourdan [5] gives a mapping from attribute grammars to functions. His target language is a non-lazy functional language. His translation yields a correct implementation for the class of absolutely noncircular attribute grammars <ref> [8] </ref>. Katayama [7] translates attribute grammars into Pascal procedures. In his scheme attributes may be evaluated more than once, although he claims otherwise. An overview of these and other evaluation techniques is given in [3]. Deransart and Maluszynski [2] use attribute grammars to analyse logic programs.
Reference: [9] <author> D.E. Knuth. </author> <title> Semantics of context-free languages. </title> <journal> Math. Syst. Theory, </journal> <volume> 2(2) </volume> <pages> 127-145, </pages> <year> 1968. </year>
Reference-contexts: These programs are usually not very efficient. The efficiency of the programs is improved by applying successive transformations. In this article we show that rewrite rules employing tupling [11] and deriving circular programs can be more easily expressed using attribute grammars <ref> [9, 10] </ref>. The method we decsribe also results in a form of common subexpression elimination. We define two mappings from attribute grammars to functional programs. One of these mappings, SIM, yields programs that visit the nodes of a certain data structure usually more than once.
Reference: [10] <author> D.E. Knuth. </author> <title> Semantics of context-free languages (correction). </title> <journal> Math. Syst. Theory, </journal> <volume> 5(1) </volume> <pages> 95-96, </pages> <year> 1971. </year>
Reference-contexts: These programs are usually not very efficient. The efficiency of the programs is improved by applying successive transformations. In this article we show that rewrite rules employing tupling [11] and deriving circular programs can be more easily expressed using attribute grammars <ref> [9, 10] </ref>. The method we decsribe also results in a form of common subexpression elimination. We define two mappings from attribute grammars to functional programs. One of these mappings, SIM, yields programs that visit the nodes of a certain data structure usually more than once.
Reference: [11] <author> A. Pettorossi. </author> <title> Methodologies for Transformations and Memoing in Applicative Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <month> October </month> <year> 1984. </year>
Reference-contexts: 1 Introduction The transformational approach to programming starts with writing very clear and obviously correct programs. These programs are usually not very efficient. The efficiency of the programs is improved by applying successive transformations. In this article we show that rewrite rules employing tupling <ref> [11] </ref> and deriving circular programs can be more easily expressed using attribute grammars [9, 10]. The method we decsribe also results in a form of common subexpression elimination. We define two mappings from attribute grammars to functional programs.
Reference: [12] <author> Masato Takeichi. </author> <title> Partial parametrization eliminates multiple traversals of data structures. </title> <journal> Acta Informatica, </journal> <volume> 24 </volume> <pages> 57-77, </pages> <year> 1987. </year> <month> 14 </month>
Reference-contexts: An overview of these and other evaluation techniques is given in [3]. Deransart and Maluszynski [2] use attribute grammars to analyse logic programs. They derive conditions under which a Prolog program allows a nonstandard, but efficient, evaluation strategy. 13 Takeichi <ref> [12] </ref> obtains one touch algorithms by introducing higher order func-tions. The main conclusion of this article must be that attribute grammars can be used to derive efficient functional programs.
Reference: [13] <author> D.A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software-practice and experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference-contexts: We consider attribute grammars as describing computations of values attached to nodes in a labelled tree. 3.1 A circular implementation of attribute grammars The 2-phase attribute evaluation scheme can be implemented in a functional language with lazy evaluation and local definitions. In this article SASL <ref> [13] </ref> will be used. We will define the mapping CIRC that maps an attribute grammar into a functional program. CIRC constructs a SASL program that takes as input a structure tree corresponding to the underlying context free grammar of the attribute grammar. Trees are represented in SASL as lists.
Reference: [14] <author> W.M. Waite and G.Goos. </author> <title> Compiler Construction. </title> <publisher> Springer, </publisher> <year> 1984. </year> <month> 15 </month>
Reference-contexts: In section 4 the mappings from section 3 are used to rewrite functional programs. Section 5 contains a comparison with related work. 2 Attribute grammars In this section attribute grammars are defined. The definitions are taken, almost literally, from <ref> [14] </ref>. 2.1 Definitions A context free grammar G = (T; N; P; Z) consists of a set of terminal symbols T , a set of non-terminal symbols N , a set of productions P and a start symbol Z 2 N . <p> The dependency graph of S, DG (S), is the graph of the relation DT (S). The following theorem gives another characterization of well-defined attribute grammars. A proof can be found in <ref> [14] </ref>. Theorem 2.1 An attribute grammar is well-defined iff it is complete and the graph DG (S) is a-cyclic for each structure tree S corresponding to a sentence of L (G). 3 Functional implementations of attribute gram mars Attribute grammars are used to specify the semantics of programming languages.
References-found: 14

