URL: http://www.iro.umontreal.ca/~feeley/papers/pdpta96.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~feeley/
Root-URL: http://www.iro.umontreal.ca
Email: dionne@alex.qc.ca feeley@iro.umontreal.ca  
Title: A Taxonomy of Distributed Debuggers Based on Execution Replay 1  
Author: Carl Dionne Marc Feeley Jocelyn Desbiens Alex 
Keyword: debugging, nondeterminism, execution replay  
Web: desbiens@inrs-telecom.uquebec.ca  
Address: Montreal INRS-Telecommunications Lachine (Quebec) Montreal (Quebec) Iles-des-Soeurs (Quebec) Canada Canada Canada  
Affiliation: Informatique Universite de  
Abstract: This paper presents a taxonomy of parallel and distributed debuggers based on execution replay. Programming of distributed and parallel systems is a complex task. Amongst the many factors contributing to this complexity, the nondeterminacy of these systems is an important one. Execution replay is a technique developed to facilitate the debugging of nondeterministic programs. Execution replay has very broad applications and not every algorithm is applicable in every situation. This taxonomy provides a precise classification of replay debuggers using nine criteria. From this classification, it is easier to determine a debugger's scope of application, outline its strengths and weaknesses and compare it with others. This taxonomy is illustrated and validated using a collection of existing replay debuggers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Curtis and L. Wittie. BugNet: </author> <title> A debugging system for parallel programming environments. </title> <booktitle> In Proceedings of the Third International Conference on Distributed Computing Systems, </booktitle> <pages> pages 394-399, </pages> <year> 1982. </year>
Reference-contexts: These debuggers will be used to illustrate the various classification criteria. Their classification is summarized in table 1. RD 1 (BugNet <ref> [1] </ref>) BugNet is a replay debugger developed by Curtis and Wittie. It is used to replay applications running on a workstation cluster. The application's tasks communicate through interprocess communication (IPC), where unpredictable communication delays cause nondeterminism.
Reference: [2] <author> J. Desbiens, M. Lavoie, S. Pouzyreff, P. Raymond, T. Tamazouzt, and M. Toulouse. CLAP: </author> <title> An object-oriented programming system for distributed memory parallel machines. </title> <booktitle> In Proceedings of the PARCO'93 Conference, </booktitle> <pages> pages 601-604, </pages> <address> Grenoble, France, </address> <year> 1994. </year>
Reference-contexts: Nondeter-minism of KLIC's executions occurs because the clause to which each goal (or process) commits during an execution is nondeterministic. Tracing this information is sufficient to create a correct replay. RD 9 (Actor Language [3]) Dionne proposed a replay debugger applied to CLAP <ref> [2] </ref>, an actor extension of C++. CLAP's multi-threaded actors communicate through both shared-variables and messages. This replay debugger reproduces some nondeterministic instructions of CLAP with an extension of Instant Replay, and combines the logging of data to reproduce other nondeterministic instructions such as clock accesses or user input.
Reference: [3] <author> C. Dionne. </author> <title> Un devermineur permettant la reexecution d'un langage de programmation parallele de type acteur. </title> <type> Master's thesis, </type> <institution> Universite de Montreal, </institution> <year> 1996. </year>
Reference-contexts: The most important property is that KLIC's processes communicate through single-assignment shared-variables. Nondeter-minism of KLIC's executions occurs because the clause to which each goal (or process) commits during an execution is nondeterministic. Tracing this information is sufficient to create a correct replay. RD 9 (Actor Language <ref> [3] </ref>) Dionne proposed a replay debugger applied to CLAP [2], an actor extension of C++. CLAP's multi-threaded actors communicate through both shared-variables and messages. <p> If tasks are dynamically created, the value of t changes. Thus, debuggers (RD 5, 6) require a static task creation model. 2 A formal definition of these three classes of instruction may be found in <ref> [3] </ref> The replay debugger (RD 10) does not handle dynamic task creation. It was not required since the underlying communication system does not permit the attachment or creation of tasks. If dynamic task creation was allowed, the event identification method would have to be adapted accordingly.
Reference: [4] <author> C. Dionne, M. Nolette, and D. Gagne. </author> <title> Message passing in complex irregular systems. </title> <booktitle> In Proceedings of the MPI Developers Conference and Users Group Meeting (MPIDC'96), </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: CLAP's multi-threaded actors communicate through both shared-variables and messages. This replay debugger reproduces some nondeterministic instructions of CLAP with an extension of Instant Replay, and combines the logging of data to reproduce other nondeterministic instructions such as clock accesses or user input. RD 10 (Distributed Training System <ref> [4] </ref>) Dionne proposed a debugger to replay executions of a distributed training system composed of a user interface, a simulation engine and a collection of artificial agents.
Reference: [5] <author> S. I. Feldman and C. B. Brown. IGOR: </author> <title> A system for program debugging via reversible execution. </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, published in ACM SIGPLAN Notices, </booktitle> <volume> 24(1) </volume> <pages> 112-123, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: There is no direct relation between dynamic time range and reverse execution: (RD 1) is characterized with a dynamic time range but does not support reverse execution, and IGOR, although not a replay debugger, supports reverse execution of deterministic programs <ref> [5] </ref>. We do not discriminate replay debuggers according to this criteria (whether they support reverse execution or not): we consider that it is rather a characteristic of the debugging system to which the replay debugger belongs.
Reference: [6] <author> R. H. Halstead, Jr. and D. A. Kranz. </author> <title> A replay mechanism for mostly functional parallel programs. </title> <booktitle> In Proceedings of the International Symposium on Shared Memory Multiprocessing, </booktitle> <pages> pages 119-130, </pages> <address> Tokyo, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: RD 6 (Optimal Tracing of Messages [13]) Based on the previous observation, Net-zer and Miller proposed an algorithm applicable to message-passing programs that dynamically computes the minimal subset of events that needs to be recorded. RD 7 (Mostly Functional Language <ref> [6] </ref>) Halstead and Krantz proposed a replay algorithm adapted to mostly functional parallel programs. The algorithm has been implemented for Multilisp, a parallel variant of Scheme. Like Instant Replay, their algorithm reproduces the order in which shared-variables are accessed.
Reference: [7] <author> D. P. Helmbold and C. E. McDowell. </author> <title> A taxonomy of race detection algorithms. </title> <type> Technical Report UCSC-CRL-94-35, </type> <institution> University of California, Santa Cruz, Computer Research Laboratory, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Regarding replay debugging more specifically, important work has been accomplished since, but we are still far from a general theory and terminology. Netzer proposed a taxonomy of race conditions [12], extended by Helmbold and McDowell in 1994 <ref> [7] </ref>. A better comprehension of race condition properties lead to replay algorithms optimal in terms of the quantity of logged information [11, 13]. Our taxonomy widens the scope of these race condition taxonomies, by caracterizing other aspects of a replay debugger.
Reference: [8] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Criterion 9 (Range in task space) This last criterion describes the set of tasks collaborating during the replay: all tasks (9a), a subset (9b) or only one task (9c). Our definition of collaboration is based on Lamport's happened before relation <ref> [8] </ref>. We say that tasks collaborate if and only if, for every pair of events ordered in the initial execution, the ordering relation also holds true in the replay.
Reference: [9] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging parallel programs with Instant Replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-482, </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: RD 3 (Instant Replay <ref> [9] </ref>) Instant Replay is an algorithm developed by Leblanc and Mellor-Crummey to replay shared-memory parallel programs. Instant Replay assumes that all accesses to shared variables are guarded. The replay is guaranteed by recording the order in which the variables are accessed, rather than recording the data that is accessed.
Reference: [10] <author> T. J. LeBlanc and B. P. Miller. </author> <title> Workshop summary. </title> <booktitle> In Proceedings of the Workshop of Parallel and Distributed Debugging, pages ix-xxi, </booktitle> <address> Madison, Wisconsin, </address> <year> 1988. </year>
Reference-contexts: Tools used in sequential programming environments may not scale appropriately to distributed and parallel environments. Mellor-Crummey cites four reasons that make debugging parallel systems more problematic: lack of global time, nondeterminism, multiple threads of control and complex patterns of interactions <ref> [10] </ref>. Innovative strategies have to be developed to build tools well adapted to these difficulties. <p> The need for a debugging terminology has been formally identified in the conclusion to the 1988 workshop on distributed and parallel debugging by Sopka and Redell. Both concluded that we lacked a theory and a terminology for debugging <ref> [10] </ref>. Regarding replay debugging more specifically, important work has been accomplished since, but we are still far from a general theory and terminology. Netzer proposed a taxonomy of race conditions [12], extended by Helmbold and McDowell in 1994 [7].
Reference: [11] <author> R. H. B. Netzer. </author> <title> Optimal tracing and replay for debugging shared-memory parallel programs. </title> <booktitle> In Proceedings of ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 1-11, </pages> <address> San Diego, California, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Netzer proposed a taxonomy of race conditions [12], extended by Helmbold and McDowell in 1994 [7]. A better comprehension of race condition properties lead to replay algorithms optimal in terms of the quantity of logged information <ref> [11, 13] </ref>. Our taxonomy widens the scope of these race condition taxonomies, by caracterizing other aspects of a replay debugger. <p> Their debugger is concerned with all nondeterministic Ada constructs, except accesses to shared-variables: it is assumed that these accesses will be guarded using other Ada constructs. RD 5 (Optimal Tracing of Shared Memory Accesses <ref> [11] </ref>) Netzer proposed an enhancement to the original Instant Replay algorithm. This enhancement is based on the observation that it is usually more expensive to record all log entries than to compute a subset of them that is sufficient to guarantee replay.
Reference: [12] <author> R. H. B. Netzer and B. P. Miller. </author> <title> What are race conditions? Some issues and formalizations. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 251-253, </pages> <address> Santa Cruz, California, </address> <month> May </month> <year> 1991. </year> <note> [Extended abstract]. </note>
Reference-contexts: Both concluded that we lacked a theory and a terminology for debugging [10]. Regarding replay debugging more specifically, important work has been accomplished since, but we are still far from a general theory and terminology. Netzer proposed a taxonomy of race conditions <ref> [12] </ref>, extended by Helmbold and McDowell in 1994 [7]. A better comprehension of race condition properties lead to replay algorithms optimal in terms of the quantity of logged information [11, 13]. Our taxonomy widens the scope of these race condition taxonomies, by caracterizing other aspects of a replay debugger.
Reference: [13] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Optimal tracing and replay for debugging message-passing parallel programs. </title> <booktitle> In Proceedings of Supercomputing '92, </booktitle> <pages> pages 502-511, </pages> <address> Min-neapolis, MN, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Netzer proposed a taxonomy of race conditions [12], extended by Helmbold and McDowell in 1994 [7]. A better comprehension of race condition properties lead to replay algorithms optimal in terms of the quantity of logged information <ref> [11, 13] </ref>. Our taxonomy widens the scope of these race condition taxonomies, by caracterizing other aspects of a replay debugger. <p> With Instant Replay, all accesses to shared variables are logged. Netzer proposes an algorithm that computes, dynamically, a subset of accesses that is sufficient to guarantee a correct replay, and shows that this subset is minimal. RD 6 (Optimal Tracing of Messages <ref> [13] </ref>) Based on the previous observation, Net-zer and Miller proposed an algorithm applicable to message-passing programs that dynamically computes the minimal subset of events that needs to be recorded. RD 7 (Mostly Functional Language [6]) Halstead and Krantz proposed a replay algorithm adapted to mostly functional parallel programs.
Reference: [14] <author> D. Z. Pan and M. A. Linton. </author> <title> Supporting reverse execution of parallel programs. </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, published in ACM SIGPLAN Notices, </booktitle> <volume> 24(1) </volume> <pages> 124-129, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: It is used to replay applications running on a workstation cluster. The application's tasks communicate through interprocess communication (IPC), where unpredictable communication delays cause nondeterminism. All I/O and IPC data exchanges are captured, their data recorded and used to create the replay. RD 2 (Recap <ref> [14] </ref>) Recap is a debugger that provides the illusion of reverse execution. It logs and replays the results of systems calls and shared-memory read, as well as the time when asynchronous events (signals) occur.
Reference: [15] <author> K. Shen and S. Gregory. </author> <title> Instant Replay debugging of concurrent logic programs. </title> <journal> New Generation Computing, </journal> <volume> 14(1) </volume> <pages> 79-107, </pages> <year> 1996. </year>
Reference-contexts: RD 8 (Concurrent Logic Language <ref> [15] </ref>) Shen and Gregory extended Instant Replay to concurrent logic programs. Their replay debugger is applied to KLIC. Committed choice concurrent logic programming languages have several properties that they exploit in order to simplify the replay algorithm. The most important property is that KLIC's processes communicate through single-assignment shared-variables.
Reference: [16] <author> K.-C. Tai, R. H. Carver, and E. E. Obaid. </author> <title> Debugging concurrent Ada programs by deterministic execution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 45-63, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The replay is guaranteed by recording the order in which the variables are accessed, rather than recording the data that is accessed. Several adaptations of Instant Replay were proposed to debug other types of nondeterministic constructs (RD 8, 9). RD 4 (SYN-Sequence <ref> [16] </ref>) Tai, Carver and Obaid proposed a replay debugger for concurrent Ada programs.
References-found: 16

