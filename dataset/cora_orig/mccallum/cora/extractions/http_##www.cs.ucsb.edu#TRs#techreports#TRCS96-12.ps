URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS96-12.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Parallelizing Multidimensional Index Structures  
Author: K. V. Ravi Kanth Divyakant Agrawal Amr El Abbadi Ambuj Singh Terence R. Smith 
Address: Santa Barbara, CA 93106  
Affiliation: University of California at Santa Barbara  
Abstract: Indexing multidimensional data is inherently complex leading to slow query processing. This behavior becomes more pronounced with the increase in database size and/or number of dimensions. In this paper, we address this issue by processing an index structure in parallel. First, we study different ways of partitioning an index structure. We then propose efficient algorithms for processing each query in parallel on the index structure. Using these strategies, we parallelized two multidimensional index structures R* and LIB and evaluated the performance gains for the Gazetteer and the Catalog data of the Alexandria Digital Library on the Meiko CS-2. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Beckmann, H. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R* tree: An efficient and robust access method for points and rectangles. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 322331, </pages> <month> May 23-25 </month> <year> 1990. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data. <p> However, some structures like the R fl trees <ref> [1] </ref> perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data. In [10], we have devised a new multidimensional index structure called the LIB-structure that exploits the semantics of the data to gain efficiency. <p> We chose the LIB structure because it performs well for certain types of spatial data. We selected the R fl because it is representative of some of the versatile multidimensional indices <ref> [4, 1, 20] </ref> that cater to arbitrary data. We parallelized these two structures and evaluated their performance on two datasets of the Alexandria Digital Library the Gazetteer data for the region of California, and the Catalog data for the whole world. <p> However, it is quite possible that most of the data is concentrated at a particular nesting level, limiting the parallelism. In this case, we need to split the index dimensional data at that level into several components so that they may be searched in parallel. The R fl tree <ref> [1] </ref>, on the other hand, is a single B-tree like structure for multidimensional data. Hence, each node in the tree has between dm=2e and m children (m being the node capacity), whereas the root has at least 2 children.
Reference: [2] <author> M. W. Freeston. </author> <title> The bang file: a new kind of grid file. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 260269, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data.
Reference: [3] <author> A. Gerasoulis and T. Yang. </author> <title> On the granularity and clustering of directed acyclic task graphs. </title> <journal> IEEE Trans on Parallel and Distributed Systems, </journal> <volume> 4(6):686701, </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: The problem at hand is to physically layout the forest of search trees on a given number of processors to achieve small query response times. This problem is similar to the problem of partitioning a task graph <ref> [3, 17] </ref> on a given number of processors. The difference is that in task graph partitioning, all the nodes (tasks) in the task graph are to be executed while minimizing an objective function (say, parallel time).
Reference: [4] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 4757, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data. <p> We chose the LIB structure because it performs well for certain types of spatial data. We selected the R fl because it is representative of some of the versatile multidimensional indices <ref> [4, 1, 20] </ref> that cater to arbitrary data. We parallelized these two structures and evaluated their performance on two datasets of the Alexandria Digital Library the Gazetteer data for the region of California, and the Catalog data for the whole world.
Reference: [5] <author> I. Kamel. </author> <title> Fast retrieval of cursive handwriting. </title> <type> Technical Report MITL-TR-134-94, </type> <year> 1994. </year>
Reference-contexts: Most image database systems approximate the images as large multidimensional feature vectors and the retrieval of images in such systems is based on searching in the multidimensional feature space. Similarly, large sequence database systems for handwriting recognition <ref> [5] </ref> also use multidimensional indices. The attributes in relational database systems can be viewed as forming a multidimensional space.
Reference: [6] <author> I. Kamel and C. Faloutsos. </author> <title> Parallel r-trees. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 195204, </pages> <year> 1992. </year>
Reference-contexts: In this paper, we propose an alternative means to gain performance: parallelism. Parallelism can take advantage of the need for searching multiple portions of the index for most of the queries like containment and intersection. Kamel and Faloutsos <ref> [6] </ref> present the idea of proximity index for storing data on multiple disks and use simulations to show performance gains for R-trees with multiple disks on a single processor. In this paper, we focus on parallel performance from multiple processors each with its own disk. <p> This process is repeated until there is an acceptable level of imbal ance. 3.1.1 Tree Partitioning scheme Let G be the search tree that needs to be partitioned. We first estimate the likelihood of two nodes in G being searched in the same query using proximity-index <ref> [6] </ref> for the associated regions. Kamel and Faloutsos define the proximity-index of two regions in multidimensional space as the likelihood of the their being accessed in the same query and devise a way to compute it. <p> to two arbitrary nodes a; b of a search tree G as follows: * If a; b are connected in G, then proximity index (a; b) = 0. * Otherwise, proximity-index (a; b) is the proximity-index of the regions covered by a and b as defined by Kamel and Faloutsos <ref> [6] </ref>. If the proximity-index of two nodes is high enough, then we try to assign them to different processors so that they can be searched in parallel. However, for any two nodes that are connected, the proximity-index is set to 0 for the following reasons. 1.
Reference: [7] <author> C. Kolovson and M. Stonebraker. </author> <title> Segment indexes: Dynamic indexing techniques for multi-dimensional interval data. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 138147, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data.
Reference: [8] <author> H. P. Kriegel, M. Schwietz, R. Schneider, and B. Seeger. </author> <title> Performance comparison of point and spatial access methods. Design and Implementation of Large Spatial Databases, </title> <booktitle> First Symposium, </booktitle> <volume> SSD 89, </volume> <pages> pages 88114, </pages> <year> 1993. </year>
Reference-contexts: This will become evident in our experiments. Since our dataset is 2-dimensional in nature, we experimented with 2-dimensional queries. The queries generated are ensured to span 0.1%, 1% or 10% of the area of the domain (California). Similar assumptions are made in [15] and <ref> [8] </ref>. Each query window is assumed to be a square and hence the sides of the query window are calculated from the area. These sides are scaled appropriately for the domain we are dealing with.
Reference: [9] <author> V. Kumar, A. Grama, A. Gupta, and G. Karypis. </author> <title> Introduction to Parallel Computing. </title> <publisher> Bejamin-Cumming Publishing Company, </publisher> <address> Erewhon, NC, </address> <year> 1994. </year>
Reference-contexts: The first processor gets the first bk=pc search trees, the second processor the next bk=pc search trees and so on. The last processors gets all the remaining search trees. This assignment corresponds to block striping <ref> [9] </ref> of the search trees. Phase 2 Partition individual search trees If there is a heavily loaded processor, then the largest search tree (with maximum number of nodes) assigned to that processor is partitioned using the tree partitioning scheme described below.
Reference: [10] <author> K.V.Ravi Kanth, D. Agrawal, A. El Abbadi, A. Singh, and T.R.Smith. </author> <title> Indexing hierarchical data. </title> <type> Technical Report TRCS-95-014, </type> <year> 1995. </year>
Reference-contexts: However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data. In <ref> [10] </ref>, we have devised a new multidimensional index structure called the LIB-structure that exploits the semantics of the data to gain efficiency. <p> As we see later, the parallelizing techniques can be applied to arbitrary index structures and are not restricted to these two indices. The LIB structure <ref> [10] </ref> segregates the data into different levels of nesting based on the containment relationships of objects. (An object a is contained in object b if the region covered by a in the n-dimensional space is a subset of that covered by b). <p> The first layer indexes the objects using the intervals along X-axis and the second layer along the Y-axis. For indexing intervals along a chosen dimension, we have developed a new unidimensional index structure called the IB-tree <ref> [10] </ref>. The IB-tree is a B-tree like structure which guarantees logarithmic bounds on all operations when the data is not nested. Maintaining separate indices for each nesting level has two main advantages. First, the index at each level can be chosen depending upon the characteristics of data at that level.
Reference: [11] <author> K.Y.Whang and R.Krishnamurthy. </author> <title> Multilevel grid files. </title> <type> Technical Report, </type> <institution> IBM Research Lab., </institution> <year> 1985. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data.
Reference: [12] <author> D. B. Lomet and B. Salzberg. </author> <title> The hb-tree: A multiattribute indexing method with good guaranteed performance. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 15(4):625658, </volume> <year> 1990. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data.
Reference: [13] <author> M.A.Ouksel and O.Mayer. </author> <title> A robust and effiecient spatial data structure. </title> <journal> Acta Informatica, </journal> <volume> 29:335373, </volume> <year> 1992. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data.
Reference: [14] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik. </author> <title> The grid file: an adaptable symmetric multikey file structure. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 9(1):3871, </volume> <year> 1984. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data.
Reference: [15] <author> B. U. Pagel, H. W. Siz, H. Toben, and P. Widmayer. </author> <title> Towards an analysis of range query performance. </title> <booktitle> Proc. of 12th ACM PODS Symposium, </booktitle> <pages> pages 214221, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: This will become evident in our experiments. Since our dataset is 2-dimensional in nature, we experimented with 2-dimensional queries. The queries generated are ensured to span 0.1%, 1% or 10% of the area of the domain (California). Similar assumptions are made in <ref> [15] </ref> and [8]. Each query window is assumed to be a square and hence the sides of the query window are calculated from the area. These sides are scaled appropriately for the domain we are dealing with.
Reference: [16] <author> J. Robinson. </author> <title> The k-d-b tree: A search structure for large multidimensional indexes. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> 10-18, </pages> <year> 1981. </year>
Reference-contexts: With so many applications being naturally modeled as multidimensional data, there have been many attempts to provide efficient index structures, but due to the inherent complexity of multidimensional data, there appears to be no clear winner among the plethora of indices <ref> [2, 4, 7, 12, 14, 1, 13, 16, 11] </ref> fl Work supported in part by a research grant from NSF/ARPA/NASA IRI9411330. in the literature. However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees [16] are good for point data. <p> However, some structures like the R fl trees [1] perform reasonably well for rectangular data whereas others like KDB-trees <ref> [16] </ref> are good for point data. In [10], we have devised a new multidimensional index structure called the LIB-structure that exploits the semantics of the data to gain efficiency.
Reference: [17] <author> V. Sarkar. </author> <title> Partitioning and Scheduling parallel programs for execution on multiprocessors. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: The problem at hand is to physically layout the forest of search trees on a given number of processors to achieve small query response times. This problem is similar to the problem of partitioning a task graph <ref> [3, 17] </ref> on a given number of processors. The difference is that in task graph partitioning, all the nodes (tasks) in the task graph are to be executed while minimizing an objective function (say, parallel time).
Reference: [18] <author> K. Schauser and C. Schieman. </author> <title> Experience with active messages on Meiko CS-2. </title> <booktitle> 9th Intl. Parallel Processing Symposium IPPS95, </booktitle> <pages> pages 140149, </pages> <year> 1995. </year>
Reference-contexts: Modern parallel machines like the Meiko CS-2 provide additional support to accomplish queuing at a remote processor without interrupting its computation. Schauser et al. <ref> [18] </ref> came up with several solutions for emulating remote queues on architectures that support one or more of the following: * remote read/writes , * remote test-and-set, and * a separate co-processor to handle communication.
Reference: [19] <author> A. Schilberschatz, J.L.Peterson, and P.B.Galvin. </author> <title> Operating Systems Concepts. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Erewhon, NC, </address> <year> 1989. </year>
Reference-contexts: Let us look at the issues in receiving a remote request. Each processor can potentially receive requests from all other processors and hence queuing these requests at a processor and servicing them is akin to the multiple producers single consumer problem. There are many solutions to this fundamental problem <ref> [19] </ref>. However, to maximize performance of the index structures, we would like to ensure that the destination processor of a remote request can receive it without much overhead. Modern parallel machines like the Meiko CS-2 provide additional support to accomplish queuing at a remote processor without interrupting its computation.
Reference: [20] <author> T. Sellis, N. Roussopoulos, and C.Faloutsos. </author> <title> The R+ trees: An dynamic index for multidimensional objects. </title> <booktitle> Proc. of the 13th Intl. Conf. on Very Large Databases, </booktitle> <pages> pages 507 518, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: We chose the LIB structure because it performs well for certain types of spatial data. We selected the R fl because it is representative of some of the versatile multidimensional indices <ref> [4, 1, 20] </ref> that cater to arbitrary data. We parallelized these two structures and evaluated their performance on two datasets of the Alexandria Digital Library the Gazetteer data for the region of California, and the Catalog data for the whole world.
Reference: [21] <author> T.R.Smith and J.Frew. </author> <title> Alexandria Digital Library. </title> <journal> Communications of the ACM, </journal> <volume> 38(4):6162, </volume> <month> April </month> <year> 1995. </year> <month> 8 </month>
Reference-contexts: 1 Introduction Advances in processing technology and storage management over the last decade have opened up new avenues for handling large and complex map and image data. Efficient management and retrieval of such multidimensional data is of primary concern for several reasons. Many projects such as the Alexandria Digital Library <ref> [21] </ref>, which maintain large collections of spatial and geographic data, have to provide efficient access to such multidimensional data. Most image database systems approximate the images as large multidimensional feature vectors and the retrieval of images in such systems is based on searching in the multidimensional feature space.
References-found: 21

