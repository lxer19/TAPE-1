URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-037.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: A New Approach to Finding Objects in Programs  
Author: Panos E. Livadas Theodore Johnson 
Address: Gainesville, FL 32611  
Affiliation: Computer and Information Sciences Department University of Florida,  
Abstract: Software maintenance is difficult and costly because the maintainer must understand the existing relationships in the maintained code. The maintainer's job can be made considerably easier if the objects in the code (related groups of types, data, and procedures) are identified. In this paper, we discuss methods for identifying objects in programs, and present a new approach that relies on these key features. First, our internal program representation (IPR) lets us make a more precise identification of objects than previous methods allowed. Second, we introduce the idea of receiver-based object identification. Third, we introduce the idea of two-step object identification, which gives the user greater control in precisely identifying objects. Our object finding tool can be used with the other tools our IPR provides to create an integrated software maintenance environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Horwitz, T. Reps and D. Binkley, </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM TOPLAS, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: Namely, global variable gs is clustered with procedures push, pop, empty_GS, empty_S whereas gq is clustered with procedures insert, delete, empty_GQ. Therefore, the output of the global based object identification algorithm when executed on the program in Table 1 is: C g C g P <ref> [ 1 ] </ref> = ( push, pop, empty_GS, empty_S , , gs), C g P [ 2 ] = ( insert, delete, empty_GQ , , gq ) . <p> As an example, we applied the TBOI algorithm to the program in Table 1. All routines whose type set is t are clustered together, and the result is: C tp + tr C tp + tr P <ref> [ 1 ] </ref> = ( copy , stack, stcque ,), C tp + tr P [ 2 ] = ( push_S, pop_S , stack,elem ,), C tp + tr P [ 3 ] = ( insert_Q, delete_Q , queue, elem ,), C tp + tr P [ 4 ] = ( <p> Notice that we treat the static variables as global variables of limited scope. The motivation for introducing globals as pass-by-reference parameters is to avoid having flow edges cross procedure boundaries when using or defining global variables <ref> [1] </ref> whereas static variables are persistent in the sense that they are alive between calls. All procedures that call a procedure directly or those which indirectly use or define global (static) variable (s) are modified to include the global variable (s) as pass-by-reference parameters.
Reference: [2] <author> S.S. Liu, N. Wilde, </author> <title> ``Identifying objects in a conventional procedural language'', </title> <booktitle> in Proceedings of the Conference on Software Maintenance, </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: In addition, the distinction between primary and secondary object identification permits a clearer description of the identification algorithms. In section 2, we discuss three primary identification methods: global-based (M = g), type-based (M = t), and receiver-based (M = r); the first two have been proposed in <ref> [2] </ref>. In section 3, we discuss secondary object identification methods. In section 4, we discuss our internal program representation, and algorithms that return precise primary objects. In section 5, we draw some conclusions. 2. <p> In section 5, we draw some conclusions. 2. Primary Object Identification Methods The primary object identification methods that we consider can be grouped into global-based (M = g), type-based (M = t), and receiver-based (M = r) methods. Global and type-based object finding has been discussed in <ref> [2] </ref>; and receiver-based object finding is a novel approach that is often more accurate than type-based object finding. We need to make a definition for our discussion of primary object finding. Let x be a variable of type t and let f F. <p> Global-based Object Identification Global-based object identification (GBOI) defines a candidate object to be a triple (f,,x) where f F and x is a global variable that is visible to each element of f. Objects identified by this method will be referred to as globally accessible objects. The method in <ref> [2] </ref> for identifying global objects overlooked two important cases, so their ``objects'' are not precisely identified. First, in languages such as Pascal that permit nested procedures, non-local variables can be regarded as global variables for the purpose of the object finder. <p> Hence, the object finder shouldn't distinguish between global and non-local variables for programs written in these languages. We will use the term global to mean both global and nonlocal variables in the remainder of this paper. Second, in <ref> [2] </ref> the global-based object finder clusters instances of a global variable with a routine. <p> However, if a variable x is global to a routine f 1 , and f 1 calls f 2 with x as the actual parameter, an interpretation should be that x is global to f 2 . The algorithm for the object finder described in <ref> [2] </ref> is unable to find the threads that would be caused by such bindings. As we discuss, our algorithm uses a graph as an underlying structure where bindings, as well as the results of flow-sensitive analysis, are explicitly represented. Therefore, those threads can be identified and traversed. <p> Therefore, the output of the global based object identification algorithm when executed on the program in Table 1 is: C g C g P [ 1 ] = ( push, pop, empty_GS, empty_S , , gs), C g P <ref> [ 2 ] </ref> = ( insert, delete, empty_GQ , , gq ) . As an extension, we note that static variables as in C can be considered as global variables of limited scope, since a static variable exists between the invocations of the routines that define it. <p> Program illustrating the object finder. 2.2. Type-based Object Identification Type-based object identification (TBOI) clusters a routine with the set of types of all its formal parameters and the type of its returned value <ref> [2] </ref>. For example, each routine r: (a 1 ,a 2 ,........ ,a n ) fib is clustered with the set t = i = 1 n a i b, where a i 's represent the types of the parameters and b the type of the returned variable (if any). <p> All routines whose type set is t are clustered together, and the result is: C tp + tr C tp + tr P [ 1 ] = ( copy , stack, stcque ,), C tp + tr P <ref> [ 2 ] </ref> = ( push_S, pop_S , stack,elem ,), C tp + tr P [ 3 ] = ( insert_Q, delete_Q , queue, elem ,), C tp + tr P [ 4 ] = ( empty_Q , queue, boolean ,), C tp + tr P [ 5 ] = ( <p> We have shown the shortcomings of the global-and type-based methods suggested in <ref> [2] </ref> and [5], proposed a more precise method based on receiver types, and presented a flexible method for secondary object finding. We have implemented the object finder and the dependence analysis tool for a large subset of ANSI C and Pascal.
Reference: [3] <author> P.E. Livadas, S. Croll and P.K. Roy, </author> <title> ``Towards an Integrated Software Maintenance Environment'', </title> <booktitle> in Proceedings of the 1st Symposium on Software Engineering Research Forum, </booktitle> <address> Tampa, Florida, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: type set is t are clustered together, and the result is: C tp + tr C tp + tr P [ 1 ] = ( copy , stack, stcque ,), C tp + tr P [ 2 ] = ( push_S, pop_S , stack,elem ,), C tp + tr P <ref> [ 3 ] </ref> = ( insert_Q, delete_Q , queue, elem ,), C tp + tr P [ 4 ] = ( empty_Q , queue, boolean ,), C tp + tr P [ 5 ] = ( empty_S , stack, boolean ,), C tp + tr P [ 6 ] = ( <p> Even though the system dependence graph as well as its construction has been discussed extensively elsewhere ([1], <ref> [3] </ref>, [4]) for the sake of completness we present its highlights. An SDG is a directed, labeled multigraph that consists of a program dependence graph and a collection of procedure dependence graphs. The program dependence graph models the main program and the procedure dependence graphs model the procedure bodies.
Reference: [4] <author> P.E. Livadas, S. Croll, </author> <title> ``Program Slicing'', </title> <institution> SERC-TR-55F, Software Engineering Research Center, Computer and Information Sciences Department, University of Florida, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: tp + tr P [ 1 ] = ( copy , stack, stcque ,), C tp + tr P [ 2 ] = ( push_S, pop_S , stack,elem ,), C tp + tr P [ 3 ] = ( insert_Q, delete_Q , queue, elem ,), C tp + tr P <ref> [ 4 ] </ref> = ( empty_Q , queue, boolean ,), C tp + tr P [ 5 ] = ( empty_S , stack, boolean ,), C tp + tr P [ 6 ] = ( push, pop, insert, delete , elem ,), C tp + tr P [ 7 ] = <p> Furthermore, we must emphasize that the SDG is not constructed for implementing only the algorithms discussed here; it is also the basis for a number of other software maintenance activities -- namely, program slicing, dicing, and ripple analysis <ref> [4] </ref>. Even though the system dependence graph as well as its construction has been discussed extensively elsewhere ([1], [3], [4]) for the sake of completness we present its highlights. An SDG is a directed, labeled multigraph that consists of a program dependence graph and a collection of procedure dependence graphs. <p> is not constructed for implementing only the algorithms discussed here; it is also the basis for a number of other software maintenance activities -- namely, program slicing, dicing, and ripple analysis <ref> [4] </ref>. Even though the system dependence graph as well as its construction has been discussed extensively elsewhere ([1], [3], [4]) for the sake of completness we present its highlights. An SDG is a directed, labeled multigraph that consists of a program dependence graph and a collection of procedure dependence graphs. The program dependence graph models the main program and the procedure dependence graphs model the procedure bodies. <p> A technique that will identify direct and indirect aliasing and the dependency analysis of procedures in the presence of aliasing has been discussed elsewhere ([1], <ref> [4] </ref>). We have created a separate copy of the procedure for each unique alias configuration and solve the procedure taking into account the variables that are bound to the same memory location.
Reference: [5] <author> R.M. Ogando, </author> <title> ``An Approach to Software System Modularization Based on Data and Type Binding'', </title> <type> PhD thesis, </type> <institution> University of Florida, Gainesville, Florida, </institution> <year> 1991. </year>
Reference-contexts: tp + tr P [ 2 ] = ( push_S, pop_S , stack,elem ,), C tp + tr P [ 3 ] = ( insert_Q, delete_Q , queue, elem ,), C tp + tr P [ 4 ] = ( empty_Q , queue, boolean ,), C tp + tr P <ref> [ 5 ] </ref> = ( empty_S , stack, boolean ,), C tp + tr P [ 6 ] = ( push, pop, insert, delete , elem ,), C tp + tr P [ 7 ] = ( empty_GQ, empty_GS , boolean ,) . <p> Intuitively, there are only a few (perhaps one) types in an object. If we are to cluster a routine with a small subset of its types, then intuitively we should cluster the routine with the most complex types <ref> [5] </ref>. If type x is used to define type y, then we say x is a part of y or that y contains x. If y contains x, then y is a more complex, or more highly structured, type than x. <p> We have shown the shortcomings of the global-and type-based methods suggested in [2] and <ref> [5] </ref>, proposed a more precise method based on receiver types, and presented a flexible method for secondary object finding. We have implemented the object finder and the dependence analysis tool for a large subset of ANSI C and Pascal.
References-found: 5

