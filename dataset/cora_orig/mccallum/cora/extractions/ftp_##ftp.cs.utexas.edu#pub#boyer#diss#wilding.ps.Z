URL: ftp://ftp.cs.utexas.edu/pub/boyer/diss/wilding.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/boyer/students.html
Root-URL: http://www.cs.utexas.edu
Title: Machine-Checked Real-Time System Verification  
Author: by Matthew Michael Wilding, B.S., M.S.C.S. 
Degree: DISSERTATION Presented to the Faculty of the Graduate School of  in Partial Fulfillment of the Requirements for the Degree of DOCTOR OF PHILOSOPHY  
Date: May 1996  
Address: Austin  AUSTIN  
Affiliation: The University of Texas at  THE UNIVERSITY OF TEXAS AT  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Robert L. Akers, Donald I. Good, Lawrence M. Smith, and William D. Young. </author> <title> Report on Micro-Gypsy. </title> <type> Technical Report 34, </type> <institution> Computational Logic, Inc., </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: KIT is a small operating system proved correct for a typical Von Neumann architecture [5]. Some of the proof obligations involve showing that code correctly implements aspects of the operating system. A compiler for a subset of Gypsy <ref> [1, 44] </ref> that has as a target Piton [38] is proved correct [59]. Again, code that implements the needed functionality is proved correct.
Reference: [2] <author> Ken Albin and Warren Hunt. </author> <title> The FM9001 single-board computer. </title> <type> Technical Report 90, </type> <institution> Computational Logic, Inc., </institution> <year> 1993. </year>
Reference-contexts: 6)) ((OUT 6)) ((OUT 6)) ((OUT 6)) Note that after some time the value of the location is incremented by the FM9001 running our example state. 66 5.8 The FM9001 Single Board Computer The FM9001 single board computer contains an FM9001 and several other devices needed to run FM9001 programs <ref> [2, 55] </ref>. We have modified the board in order to run applications that perform I/O. Rather than present a complete description of the FM9001 board, we present here a description of the changes we made to the board for this project. <p> Rather than present a complete description of the FM9001 board, we present here a description of the changes we made to the board for this project. The original board design is therefore needed to understand in detail what the modified board contains <ref> [2] </ref>. The original single board computer was designed and built by Ken Albin, who also helped the author make these modifications. <p> This type of approach holds promise for the development of systems that work reliably in the face of real-time system complexity. 153 Appendix A Modifications to the FM9001 Board The FM9001 board described in <ref> [2] </ref> and [55] has been modified to support real-time applications. Two new PLD's were designed, one a modification of memory address-handling hardware and one that drives the buttons and lights, and the board was rewired somewhat. This appendix contains the modified PLD design and lists the wiring changes. <p> The pin numbers are references to the FM9001 board <ref> [2] </ref>. 1. REMOVE UART TXRDY (UART Pin 24) from FM addr Pin 5 2. REMOVE UART RXRDY (UART Pin 29) from FM addr Pin 6 3. ADD DEL80 (delay Pin 16) to IO DELAY (FM addr Pin 6) 4.
Reference: [3] <author> Rajeev Alur and David Dill. </author> <title> Automata for modeling real-time systems. In M.S. </title> <editor> Paterson, editor, </editor> <booktitle> Automata, Languages and Programming 17th International Colloquium, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 322-335. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This abstract view of real-time systems has been used in a variety of contexts. Real-time system that are described using various kinds of timed automata have been analyzed <ref> [3] </ref>. Modechart and Statechart are two state-based design approaches that support the design and implementation of real-time systems using a state-based model of their operation [26, 29]. <p> Behaviors as presented in Chapter 6 are similar to other approaches for specifying real-time systems. Much work has also been done to automate correctness proofs about automata. Alur and Dill present timed automata and a decision procedure for deciding interesting properties <ref> [3] </ref>. Subsequent algorithms have made these kinds of automatic inferences less impractical because of inefficiency.
Reference: [4] <author> AMD. </author> <title> PALASM User's Guide. </title> <booktitle> Advanced Micro Devices, </booktitle> <year> 1990. </year>
Reference-contexts: This appendix contains the modified PLD design and lists the wiring changes. The PLD designs are in the form of PALASM input [43]. PALASM is a program that interprets designs and configures a programmable logic array that implements the design <ref> [4] </ref>. A.1 Design for FM addr The PLD FM addr is designed to decode the FM9001 address lines and select appropriate inputs and delay lines was revised. Revision B simplified the old design and added the ability to select an I/O device.
Reference: [5] <author> William R. Bevier. </author> <title> Kit: A study in operating system verification. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(11) </volume> <pages> 1368-81, </pages> <month> November </month> <year> 1989. </year> <note> Also published as CLI Technical Report 28. </note>
Reference-contexts: Programs were proved correct using an interpreter-based model of a commercial processor [13]. The interpreter in this project models the behavior of the user model of the Motorola 68020 microprocessor. KIT is a small operating system proved correct for a typical Von Neumann architecture <ref> [5] </ref>. Some of the proof obligations involve showing that code correctly implements aspects of the operating system. A compiler for a subset of Gypsy [1, 44] that has as a target Piton [38] is proved correct [59]. Again, code that implements the needed functionality is proved correct.
Reference: [6] <author> William R. Bevier, Warren A. Hunt Jr., J Strother Moore, and William D. Young. </author> <title> An approach to systems verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 411-428, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: The use of Nqthm often uncovers mistakes in hand-constructed proofs. 6 7 Nqthm provides us the confidence associated with formal proof while shielding us somewhat from the drudgery of writing the complete proof ourselves. Nqthm has been successfully applied in computer systems verification <ref> [6] </ref>. The requirement imposed by Nqthm to get every detail of a proof exactly correct is very important in computer systems verification as any mistake can be catastrophic. Another reason Nqthm is well-suited for modeling of and proof about computer systems is the executable nature of the Lisp-like Nqthm logic. <p> The interpreter function serves as a precise specification for the expected behavior of a system component. This general approach to system verification has been used on other projects <ref> [6, 18] </ref>. Interpreter functions can be complex: Piton has 71 instructions and some high-level features, and the definition of `p' in the Nqthm logic requires about 50 pages. The FM9001 [27] is a fairly conventional microprocessor with an instruction set somewhat like that on a PDP-11.
Reference: [7] <author> W.R. Bevier. </author> <title> A library for hardware verification. Internal Note 57, Computational Logic, </title> <publisher> Inc., </publisher> <month> June </month> <year> 1988. </year> <pages> 643 644 </pages>
Reference-contexts: Clever design of inference rules is peculiar to the construction of mechanical proofs. The standard Nqthm arithmetic libraries are an example of this kind of design <ref> [7, 31, 51] </ref>. These libraries contain theorems proved about arithmetic that constitute a strategy for how to divine needed truths about involving arithmetic operations.
Reference: [8] <author> W.W. Bledsoe. </author> <title> The Sup-Inf method in Presberger arithmetic. </title> <type> Technical Report ATP-18, </type> <institution> Mathematics Department, University of Texas at Austin, </institution> <year> 1975. </year>
Reference-contexts: The logic includes inference rules that allow the proof of interesting system properties. Some work has been done toward proving RTL properties automatically by using a modification of the Sup-Inf procedure <ref> [8, 28] </ref>. 149 RTL has many interesting and useful features. The logic allows reasoning about an application and the proof of some timing correctness properties. Events in the environment are modeled simply and assumptions about when they occur are used in the proof.
Reference: [9] <author> Charles L. Bouton. </author> <title> Nim, a game with a complete mathematical theory. </title> <journal> In Annals of Mathematics, </journal> <volume> volume 3, </volume> <pages> 1901-02. </pages>
Reference-contexts: Let green-statep (state, ws) = (0 &lt; bigp (state)) $ (xor-bvs (state, ws) 6= 0-vector). Theorem: wsp-green-state nat-listp (s, wordsize) ! (wsp (s, t) $ green-statep (s, wordsize)) This remarkable property was rediscovered for this project, but has in fact been known at least since its publication in 1901 <ref> [9] </ref>. The hypothesis requires that s be a list of naturals each representable with ws bits. The most obvious proof uses an induction on the search tree.
Reference: [10] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: There is an index of Nqthm theorem and definition names and a bibliography. Chapter 2 A Mechanical Theorem Prover 2.1 Overview of Nqthm Nqthm is the name of both a logic and an associated theorem proving system that is sometimes called the Boyer-Moore theorem prover <ref> [10] </ref>. A large number of mathematical theorems from many disparate domains have been proved using Nqthm. The Nqthm logic is a quantifier-free, first-order logic resembling Pure Lisp. <p> Many Nqthm introductions have been written by this author and others. Although we use attribution, parts of this chapter, particularly Sections 2.2 and 2.3, have been influenced by a variety of sources <ref> [10, 21, 53] </ref>. 2.2 A Brief Introduction to the Nqthm Logic The Nqthm logic is explained precisely in its documentation [10]. We present a brief description because our work makes extensive use of Nqthm, and we wish this dissertation to be as self-contained as possible. <p> Although we use attribution, parts of this chapter, particularly Sections 2.2 and 2.3, have been influenced by a variety of sources [10, 21, 53]. 2.2 A Brief Introduction to the Nqthm Logic The Nqthm logic is explained precisely in its documentation <ref> [10] </ref>. We present a brief description because our work makes extensive use of Nqthm, and we wish this dissertation to be as self-contained as possible. The Nqthm logic is a simple quantifier-free, first-order logic resembling the Lisp programming language. Terms in the logic are written using a prefix syntax. <p> Nqthm prover capabilities are explained precisely in the Nqthm documentation <ref> [10] </ref> and in a tutorial [32]. <p> A proof checked mechanically by a trusted proof-checking program is very dependable. Nqthm is such a mechanical theorem prover <ref> [10] </ref> and is described in Chapter 2. This chapter describes an Nqthm-checked proof of the EDF optimality theorem. The proof uses an approach suggested by Al Mok [35]. Section 3.2 presents the Nqthm definitions related to EDF schedules and periodic tasks used in the theorems. <p> We present some of the relevant definitions to convey the nature of our work, and refer the reader to descriptions of Nqthm <ref> [10] </ref>. We use the standard, Lisp-like Nqthm logic when showing execution examples and the Nqthm infix notation [11] when 76 presenting definitions and theorems. Each of these definitions appears in Appendix E. The function `my-eval' evaluates an expression with respect to two assignments in the manner described in Section 6.2. <p> Expressions of the form old (x ) are interpreted as a reference to x 's value in the second assignment. Other variables are replaced by the values associated with them in the first assignment. Several kinds of function symbols are interpreted as in the Nqthm logic <ref> [10] </ref>. We present the result of evaluating `my-eval' on examples below, taking advantage of the executability of Nqthm functions.
Reference: [11] <author> R. S. Boyer and J S. Moore. </author> <title> Chapter 14 of A Computational Logic Handbook, 2nd edition. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <note> to be published. (Distributed in Nqthm-1992 release available from Computational Logic, Inc.). </note>
Reference-contexts: However, those unfamiliar with it often find the prefix notation opaque. In this dissertation we use a more conventional infix notation when possible. A Lisp program generates infix notation automatically from Nqthm input <ref> [11] </ref>, and the following list excerpted from the program documentation describes the relationship between Nqthm terms and this notation. 1. Variables are printed in italics, unless specified otherwise in Table 2.1. 2. Function application. <p> The remaining symbols that are printed specially are described in Ta ble 2.1, which is taken from the infix program documentation <ref> [11] </ref>. <p> We present some of the relevant definitions to convey the nature of our work, and refer the reader to descriptions of Nqthm [10]. We use the standard, Lisp-like Nqthm logic when showing execution examples and the Nqthm infix notation <ref> [11] </ref> when 76 presenting definitions and theorems. Each of these definitions appears in Appendix E. The function `my-eval' evaluates an expression with respect to two assignments in the manner described in Section 6.2. Counters are represented by lists whose first element is c.
Reference: [12] <author> Robert S. Boyer, M. W. Green, and J S. Moore. </author> <title> The use of a formal simulator to verify a simple real-time control program. </title> <booktitle> In Beauty is Our Business, </booktitle> <pages> pages 54-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Some real-time system correctness theorems have been proved using a mechanical theorem prover. A simple model of a rowboat is constructed in which it travels down a river and the boat is acted upon by wind and force exerted by an actuator under program control <ref> [12] </ref>. Both the wind and actuator forces are integral units of unspecified size. There is a sensor that detects the position of the boat with respect to the centerline of the river, and the controller adjusts the actuator such that the boat stays close to this centerline. <p> The requirements on an implementation of the rowboat controller are not obviously derivable from the algorithm and model presented in <ref> [12] </ref>. For example, to conform to the simple model the program needs to take no time to execute. Young presents an Nqthm-based specification of a simple real-time system [60]. Similar in style to the rowboat, it captures the requirements of a railroad crossing.
Reference: [13] <author> Robert S. Boyer and Yuan Yu. </author> <title> Automated correctness proofs of machine code programs for a commercial microprocessor. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Automated Deduction - CADE-11, number 607 in Lecture Notes in Computer Science, </booktitle> <pages> pages 416-430. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: choose to represent the system with the following history. (((buzzer on) (loc1 3)) ((buzzer off) (loc1 3)) ((buzzer off) (loc1 4)) The development of formal processor models, in particular for use in hardware verification, provides in principle the capability to reason about real-time systems using very realistic models of computation <ref> [13, 14, 33] </ref>. A model 70 71 of the FM9001 processor is developed in Chapter 5. But how do we describe precisely the properties of real-time systems about which we wish to reason? Our approach is to view a real-time system as a history. <p> Programs were proved correct using an interpreter-based model of a commercial processor <ref> [13] </ref>. The interpreter in this project models the behavior of the user model of the Motorola 68020 microprocessor. KIT is a small operating system proved correct for a typical Von Neumann architecture [5]. Some of the proof obligations involve showing that code correctly implements aspects of the operating system.
Reference: [14] <author> Bishop C. Brock, Warren A. Hunt Jr., Matt Kaufmann, Art Flatau, Ann Siebert, and William D. Young. </author> <title> The formal specification and verification of the FM9001 microprocessor. </title> <type> Technical Report 86, </type> <institution> Computational Logic, Inc., </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Extra reliability can be attained by checking the proofs with a trustworthy automatic theorem prover. In this chapter we describe the verified "short stack" that includes a verified compiler for the programming language Piton [38]. We discuss the proofs of that compiler and the design of the FM9001 microprocessor <ref> [14] </ref> in Section 4.2. In Section 4.4 we develop a specification for a program that plays nim, a centuries-old game introduced in Section 4.3. Section 4.5 presents an algorithm and Piton implementation of this program. <p> we use to reason about real-time systems that contain an operating FM9001. 5.1 The Verified and Fabricated FM9001 The FM9001 is a general-purpose 32-bit microprocessor with 15 arithmetic and logical operations, five addressing modes, extensive arithmetical flag support, 16 general-purpose registers, and other features that make it practical to use <ref> [14] </ref>. The FM9001 is verified in the sense that a netlist-level description of the FM9001 has been proved to implement a programmer-level model of the processor. The verification was accomplished using Nqthm, so the specifications are expressed in the Nqthm logic. <p> The execution of an instruction is accomplished each "tick" of a computation. The Nqthm function `fm9001-interpreter' from the FM9001 correctness proof <ref> [14] </ref> models the execution of n instructions starting from an FM9001 state state using pc-reg as the designated program counter. <p> The reader interested in the details of `fm9001-step' is referred to the FM9001 verification project report <ref> [14] </ref>. We use this function as our definition of the effect of one instruction in a new model of FM9001 operation. This new model, the real-time FM9001 model, allows useful reasoning about real-time properties of FM9001 operation. <p> We call a tick of this underlying clock a microcy-cle. Each FM9001 instruction's execution is defined in terms of a sequence of internal FM9001 states, one for each microcycle during the execution of the instruction <ref> [14] </ref>. 57 The instruction execution time calculation is in some sense outside the scope of the FM9001 design since the response time of the processor's memory is a component of the execution time of instructions. <p> The function `microcycles-constant', for example, has the function `map-down' in its definition. We refer the user to the description of the FM9001 hardware proof for definitions of these functions <ref> [14] </ref>. The Nqthm constant mirror-initial-state is a representation of an FM9001 state that we present in Section 7.6. The current instruction of mirror-initial-state | that is, the instruction in memory pointed to by the FM9001 program counter | is an assembled version of a move instruction. <p> (state, mat, inputs-list, loclist, 1 + n)) endif endlet else nil endif Definition: fm9001-rt-history (state, mat, inputs-list, loclist) = fm9001-rt-history-helper (state, mat, inputs-list, loclist, 0) 64 5.7 FM9001 Representation and Execution Example The representation of the FM9001 state we use is identical to that used in the FM9001 verification effort <ref> [14] </ref>, even though as discussed the model of execution we use is more detailed. We shall not describe in detail how we represent the components of the FM9001 state or how to write and assemble an FM9001 state that contains a real-time application. <p> We shall not describe in detail how we represent the components of the FM9001 state or how to write and assemble an FM9001 state that contains a real-time application. We omit this seemingly important information not just because it is already described fully elsewhere <ref> [14] </ref>, but because how we build an FM9001 state is not needed to understand the correctness results. <p> The new board runs all known FM9001 benchmarks, including the nim program described in Chapter 4. 5.9 `fm9001-rt-history' Versus `fm9001-interpreter' The real-time model of the FM9001 is different from the programmer's model of the FM9001 that was used to specify the behavior of the FM9001 for its verification <ref> [14] </ref> and serves as the target of the Piton compiler described in Chapter 4. <p> choose to represent the system with the following history. (((buzzer on) (loc1 3)) ((buzzer off) (loc1 3)) ((buzzer off) (loc1 4)) The development of formal processor models, in particular for use in hardware verification, provides in principle the capability to reason about real-time systems using very realistic models of computation <ref> [13, 14, 33] </ref>. A model 70 71 of the FM9001 processor is developed in Chapter 5. But how do we describe precisely the properties of real-time systems about which we wish to reason? Our approach is to view a real-time system as a history. <p> The semantics of FM9001 assembly language is not important to our project since we verify machine code, not assembly language instructions. The reader interested in the FM9001 assembler is referred to the FM9001 verification project report <ref> [14] </ref> and the minor modification to allow code relocation in the definition of `my-asm' in Appendix E.
Reference: [15] <author> Moyer Chen. </author> <title> TAL a language for timing analysis. </title> <type> unpublished technical report, </type> <institution> University of Texas, </institution> <year> 1987. </year> <month> 645 </month>
Reference-contexts: Even so, this work is similar to the aspect of our work that involves machine-checked code correctness proofs. 145 9.3 Real-time Application Development Tools TAL (Timing Analysis Language) is a special-purpose language designed to help programmers derive timing information from their programs <ref> [15] </ref>. In addition to conventional language features like assignment and alternation, TAL has primitives that allow the programmer to describe a program's structure and perform calculations involving the timing properties of that program. <p> For simple cases, the development of the corresponding TAL program is straightforward from an analysis of the syntactic structure of the target program. But, as is pointed out in <ref> [15] </ref>, for realistic examples semantic information must be used to achieve tighter, more-reasonable execution time upper 146 bounds. The process of developing non-obvious TAL programs to derive these bounds could introduce errors into the development process.
Reference: [16] <author> Nancy Day. </author> <title> A model checker for statecharts (linking CASE tools with formal methods. </title> <type> Technical Report 93-35, </type> <institution> Department of Computer Science, University of British Columbia, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: But at least for simple properties like those presented in Chapter 7 and the example in Figure 9.1, the two approaches allow the expression of similar specifications. A model-checker that facilitates the proof of properties expressed as temporal formulae about systems described with Statechart specifications has been developed <ref> [16] </ref>. Simple properties of specified systems have been verified 151 automatically with this system. Some real-time system correctness theorems have been proved using a mechanical theorem prover.
Reference: [17] <author> Colin Fidge, Peter Kearney, and Mark Utting. </author> <title> Formal specification and interactive proof of a simple real-time scheduler. </title> <type> Technical Report 94-11, </type> <institution> Software Verification Research Centre, The University of Queensland, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: In this section we briefly present several such projects. 9.1 A Verified Round-robin Scheduler Implementation Researchers at the Australian Software Verification Research Centre have developed a machine-checked proof of the correctness of a round-robin scheduler <ref> [17] </ref>. The theorem they prove is that each task of a task set is assigned a processor time slice during each large time period.
Reference: [18] <author> Arthur Flatau. </author> <title> A verified implementation of an applicative language with dynamic storage allocation. </title> <type> Technical Report 83, </type> <institution> Computational Logic, Inc., </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: The interpreter function serves as a precise specification for the expected behavior of a system component. This general approach to system verification has been used on other projects <ref> [6, 18] </ref>. Interpreter functions can be complex: Piton has 71 instructions and some high-level features, and the definition of `p' in the Nqthm logic requires about 50 pages. The FM9001 [27] is a fairly conventional microprocessor with an instruction set somewhat like that on a PDP-11.
Reference: [19] <author> Martin Gardner. </author> <title> Mathematical Puzzles and Diversions. </title> <editor> Simon and Schus-ter, </editor> <address> New York, </address> <year> 1959. </year>
Reference-contexts: The rest of this paper describes the development of a verified application that runs in this environment. 4.3 Nim Nim is one of the oldest and one of the most engaging mathematical games <ref> [19] </ref>. The game is played with piles of stones and two players who alternate turns. On his turn a player removes at least one stone from exactly one pile. The player who removes the final stone loses. Figure 4.2 shows an example nim game.
Reference: [20] <author> D.M. Goldschlag. </author> <title> Mechanizing unity. </title> <booktitle> In Proceedings of IFIP TC2 Working Conference on Programming Concepts and Methods. </booktitle> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: These libraries contain theorems proved about arithmetic that constitute a strategy for how to divine needed truths about involving arithmetic operations. The libraries have proved useful for accomplishing proofs from a variety of domains that involve arithmetic <ref> [20, 51, 52, 58] </ref> and we use them in the proofs described in this dissertation. A relatively simple mechanical proof of Matijasevich's lemma a theorem about Fibonnaci numbers demonstrates the efficacy of the arithmetic libraries [53].
Reference: [21] <author> Donald I. Good and William D. Young. </author> <title> Mathematical methods for digital systems development. </title> <type> Technical Report 67, </type> <institution> Computational Logic, Inc., </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Many Nqthm introductions have been written by this author and others. Although we use attribution, parts of this chapter, particularly Sections 2.2 and 2.3, have been influenced by a variety of sources <ref> [10, 21, 53] </ref>. 2.2 A Brief Introduction to the Nqthm Logic The Nqthm logic is explained precisely in its documentation [10]. We present a brief description because our work makes extensive use of Nqthm, and we wish this dissertation to be as self-contained as possible. <p> The Nqthm logic is a simple quantifier-free, first-order logic resembling the Lisp programming language. Terms in the logic are written using a prefix syntax. The logic is an extension of propositional calculus with variables, function symbols, and the equality relation. Axioms are added defining the following <ref> [21] </ref>: * the logical constants true and false, abbreviated t and f; 8 * the function `if' where (IF x y z) is z if x is f and y otherwise; * the Boolean connectives `and', `or', `not', and `implies'; * the `equal' function where (EQUAL x y) is t when <p> The Nqthm theorem prover takes as input conjectures formalized as terms in the logic and attempts to prove them by repeated transformation and simplification. The theorem prover employs eight basic operations <ref> [21] </ref>: * decision procedures for propositional calculus, equality, and linear arith metic; * rewriting based on axioms, definitions, and previously-proved lemmas; * automatic application of user-supplied simplifiers previously proved; * elimination of calls to certain functions in favor of others that are "better" from a proof perspective; * heuristic use of <p> Each conjecture, once proved, may be stored in the prover's database to guide the theorem prover's actions in subsequent proof attempts. A database is thus more than a logical theory since it is a set of rules for proving theorems in the given theory <ref> [21] </ref>. The user leads the theorem prover to difficult proofs by programming the rule base. Given a goal theorem, the user generally discovers a proof himself, identifies the key steps in the proof, and then formulates them as lemmas, paying particular attention to their interpretation as rules.
Reference: [22] <author> Mike Gordon. </author> <title> A mechanized Hoare logic of state transitions. </title> <type> Technical report, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Like the nim proof in Chapter 4, timing behavior information is not dealt with in these projects as the models of computation associate with the execution of each instruction one "clock tick". One project that differentiates between timings of instructions is pursuing machine-checking of correctness <ref> [22] </ref>. Hoare logic annotations are added to a simple imperative programming language by the programmer and verified using an automatic theorem proving system. These properties include timing properties of the program.
Reference: [23] <author> Mike Gordon. </author> <title> Overview of HOL. In Towards Verified Systems. </title> <note> 1993. draft chapter, to appear. </note>
Reference-contexts: The axioms about the timing properties of individual language statements are justified by demonstrating a compiler for a small, lower-level language for which it is expected that a verified processor will be built. The system is based on the HOL theorem prover <ref> [23] </ref> and does not use an interpreter-based language semantics. Also, its focus is program execution properties and not on real-time systems.
Reference: [24] <author> R.L. Graham, D.E. Knuth, and O. Patashnik. </author> <title> Concrete Mathematics. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year> <month> 646 </month>
Reference-contexts: A relatively simple mechanical proof of Matijasevich's lemma a theorem about Fibonnaci numbers demonstrates the efficacy of the arithmetic libraries [53]. The sequence of Nqthm conjectures ending in Matijasevich's lemma that is accepted by Nqthm is similar to an informal hand proof in a textbook <ref> [24] </ref>. Nqthm is able to "fill in the formality" because of the strategy incorporated in the libraries.
Reference: [25] <author> Wolfgang A. Halang and Alexander D. Stoyenko. </author> <title> Constructing Predictable Real Time Systems. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: A misunderstanding of the behavior of the hardware platform could cause a malfunction just as could a mistake in the application program itself. Reliability in an application is enhanced if the connection from level to level is explicit and exact. Halang and Stoyenko <ref> [25] </ref> focus on tools available to the real-time application developer at different levels of the system. They evaluate hardware and languages in terms of usefulness in constructing predictable real-time systems.
Reference: [26] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <type> Technical report, </type> <institution> Dept. of Applied Mathematics, The Weizmann Institute of Science, </institution> <month> July </month> <year> 1986. </year>
Reference-contexts: Real-time system that are described using various kinds of timed automata have been analyzed [3]. Modechart and Statechart are two state-based design approaches that support the design and implementation of real-time systems using a state-based model of their operation <ref> [26, 29] </ref>. Representing real-time system operation using a state-based formalism appears to be an appropriate and useful way to describe the properties we wish to verify. <p> Thus, though this methodology appears to be an improvement on current practice of coding and testing, it has drawbacks as a tool for producing verified real-time software. Other real-time development tools use timed automata similar to behaviors to describe real-time system properties <ref> [26, 29] </ref>. <p> Modechart is a state-based specification technique for real-time systems whose semantics is defined using RTL [29]. Tools that facilitate use of Modechart for real-time specification that exploit the ability to view these kinds of specifications graphically have been built [41]. Modechart is similar to Statechart <ref> [26] </ref>, although Modechart allows convenient specification of absolute timing constraints. Behaviors, the specification formalism introduced in Chapter 6, are simpler than Modechart specifications.
Reference: [27] <author> Warren A. Hunt and Bishop Brock. </author> <title> A formal HDL and its use in the FM9001 verification. </title> <journal> Proceedings of the Royal Society, </journal> <month> April </month> <year> 1992. </year>
Reference-contexts: This general approach to system verification has been used on other projects [6, 18]. Interpreter functions can be complex: Piton has 71 instructions and some high-level features, and the definition of `p' in the Nqthm logic requires about 50 pages. The FM9001 <ref> [27] </ref> is a fairly conventional microprocessor with an instruction set somewhat like that on a PDP-11. Unlike most processors, however, the FM9001 has been specified, designed, and proved correct in the sense that the design is shown to meet the specification.
Reference: [28] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <booktitle> In Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <month> September </month> <year> 1986. </year>
Reference-contexts: We believe that this work does not advance the cause of reliable real-time kernel development or use and, in particular, that the work presented in this dissertation is unrelated to the work presented in [46]. RTL (real-time logic) is a logic for reasoning about the requirements of real-time applications <ref> [28] </ref>. It uses an event-action model of real-time execution. Events in the environment and beginning and end of the execution of tasks are described in the logic along with various constraints on their relationships. The logic includes inference rules that allow the proof of interesting system properties. <p> The logic includes inference rules that allow the proof of interesting system properties. Some work has been done toward proving RTL properties automatically by using a modification of the Sup-Inf procedure <ref> [8, 28] </ref>. 149 RTL has many interesting and useful features. The logic allows reasoning about an application and the proof of some timing correctness properties. Events in the environment are modeled simply and assumptions about when they occur are used in the proof.
Reference: [29] <author> Farnam Jahanian and Aloysius K. Mok. Modechart: </author> <title> A specification language for real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> 20(12) 933-947, December 1994. 
Reference-contexts: Real-time system that are described using various kinds of timed automata have been analyzed [3]. Modechart and Statechart are two state-based design approaches that support the design and implementation of real-time systems using a state-based model of their operation <ref> [26, 29] </ref>. Representing real-time system operation using a state-based formalism appears to be an appropriate and useful way to describe the properties we wish to verify. <p> Thus, though this methodology appears to be an improvement on current practice of coding and testing, it has drawbacks as a tool for producing verified real-time software. Other real-time development tools use timed automata similar to behaviors to describe real-time system properties <ref> [26, 29] </ref>. <p> Other theorems in which we are interested such as the correctness of the underlying support system cannot be formalized in RTL, and therefore can't be connected formally to it. Modechart is a state-based specification technique for real-time systems whose semantics is defined using RTL <ref> [29] </ref>. Tools that facilitate use of Modechart for real-time specification that exploit the ability to view these kinds of specifications graphically have been built [41]. Modechart is similar to Statechart [26], although Modechart allows convenient specification of absolute timing constraints.
Reference: [30] <author> Matt Kaufmann. </author> <title> A user's manual for an interactive enhancement to the Boyer-Moore theorem prover. </title> <type> Technical Report 19, </type> <institution> Computational Logic, Inc., </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: kind of strategy that the arithmetic libraries contain for arithmetic is needed for the problem domain of any non-trivial theorem to be proved using Nqthm. 2.5 The Nqthm Proof-checker Enhancement A proof-checker enhancement of Nqthm called Pc-Nqthm is available for construction of proofs of theorems expressed in the Nqthm logic <ref> [30] </ref>. This enhancement allows the user some control over the direction of a proof attempt 15 in addition to the design of the preceding lemmas. Only one of the hundreds of theorems we prove in this dissertation relies on the Pc-Nqthm enhancements. <p> We call proofs of this kind of lemma timing proofs. Although these proofs require only Nqthm, they were developed with extensive use of Pc-Nqthm <ref> [30] </ref>, the interactive enhancement to Nqthm. The proof that the Piton program meets the specification uses the default arithmetic library [53] and the Piton interpreter definitions [38]. The correctness of the Piton subroutine nat-to-bv listed in Figure 4.6 is described by the prove-lemma command in Figure 4.7.
Reference: [31] <author> M.J. Kaufmann. </author> <title> An integer library for Nqthm. Internal Note 182, Computational Logic, </title> <publisher> Inc., </publisher> <year> 1990. </year>
Reference-contexts: Clever design of inference rules is peculiar to the construction of mechanical proofs. The standard Nqthm arithmetic libraries are an example of this kind of design <ref> [7, 31, 51] </ref>. These libraries contain theorems proved about arithmetic that constitute a strategy for how to divine needed truths about involving arithmetic operations.
Reference: [32] <author> M.J. Kaufmann and Paolo Pecchiari. </author> <title> Interaction with the Boyer-Moore and theorem prover: A tutorial study using the arithmetic-geometric mean theorem. </title> <type> Technical Report 100, </type> <institution> Computational Logic, Inc., </institution> <month> August </month> <year> 1994. </year> <note> (to appear in Journal of Automated Reasoning). 647 </note>
Reference-contexts: Nqthm prover capabilities are explained precisely in the Nqthm documentation [10] and in a tutorial <ref> [32] </ref>.
Reference: [33] <author> Peter Kearney and Mark Utting. </author> <title> A layered real-time specification of a RISC processor. In Costas Courcoubetis, editor, </title> <booktitle> Computer-aided Verification - CAV '93, volume 697 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: choose to represent the system with the following history. (((buzzer on) (loc1 3)) ((buzzer off) (loc1 3)) ((buzzer off) (loc1 4)) The development of formal processor models, in particular for use in hardware verification, provides in principle the capability to reason about real-time systems using very realistic models of computation <ref> [13, 14, 33] </ref>. A model 70 71 of the FM9001 processor is developed in Chapter 5. But how do we describe precisely the properties of real-time systems about which we wish to reason? Our approach is to view a real-time system as a history.
Reference: [34] <author> C.L. Liu and James W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference-contexts: Chapter 3 An Optimal Real-time Scheduling Policy 3.1 Introduction Real-time applications often have several required functions with different timing constraints. In a seminal paper for building real-time systems, Liu and Layland introduce abstractions that facilitate real-time application development <ref> [34] </ref>. Using a simple computation model, they exhibit different real-time scheduling policies that are used to choose which of an application's various tasks to assign a processor and argue that these policies have certain useful properties. <p> An EDF scheduler is optimal for tasks requested periodically in the sense that if any schedule can meet the timing constraints on the requests then an EDF schedule will. The original proof of this theorem contained flaws <ref> [34] </ref>, but a subsequent published proof developed independently of the machine-checked proof presented in this chapter appears correct [61]. <p> The abstractions defined in this section are similar to those in Liu and Layland <ref> [34] </ref>. A real-time application is composed of tasks each with a unique name. Occasionally there is a request for a task, which has four elements: the requested task's name, the time of the task request, the task request deadline, and the task's duration.
Reference: [35] <author> Al Mok, </author> <title> Private Communication, </title> <month> March </month> <year> 1993. </year>
Reference-contexts: A proof checked mechanically by a trusted proof-checking program is very dependable. Nqthm is such a mechanical theorem prover [10] and is described in Chapter 2. This chapter describes an Nqthm-checked proof of the EDF optimality theorem. The proof uses an approach suggested by Al Mok <ref> [35] </ref>. Section 3.2 presents the Nqthm definitions related to EDF schedules and periodic tasks used in the theorems. Section 3.3 presents the optimality theorem and an example of its application. The proof of EDF optimality is described in Section 3.4. <p> We first present an informal proof of the optimality theorem presented in Section 3.3. The approach used to prove this theorem was suggested by Al Mok <ref> [35] </ref>. We present it to help motivate the Nqthm proof that uses the same basic approach and to contrast the informal proof with the formal proof. We then outline the formal proof of the optimality theorem by presenting some of its key lemmas.
Reference: [36] <author> Al Mok. </author> <title> SARTOR a design environment for real-time systems. </title> <booktitle> In Proceedings Compsac, </booktitle> <month> October </month> <year> 1985. </year>
Reference-contexts: The specifications of the timing properties are simple and easy to understand, unlike some competing systems. RTL has also been used as a part of a larger design system that assists a developer in the construction of a real-time application <ref> [36] </ref>. The use of a special-purpose logic such as RTL has disadvantages in the verification of real-time systems that include properties unrelated to timing.
Reference: [37] <author> Aloysius K. Mok, Prasanna Amerasinghe, Moyer Chen, and Karntorn Tan-tisirivat. </author> <title> Evaluating tight execution time bounds of programs by annotations. </title> <booktitle> In Proceedings of IEEE Real-Time Operating Systems and Software Workshop, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: Some work has been accomplished to support building software with this methodology. A prototype system for adding annotations to assembly language programs that allows the calculation of tighter timing bounds has been implemented <ref> [37] </ref>. Nevertheless, programs developed in this way using TAL will not achieve the reliability of a formally specified and mechanically checked application. For simple cases, the development of the corresponding TAL program is straightforward from an analysis of the syntactic structure of the target program.
Reference: [38] <author> J Strother Moore. </author> <title> A mechanically verified language implementation. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 493-518, </pages> <month> December </month> <year> 1989. </year> <note> Also published as CLI Technical Report 30. </note>
Reference-contexts: Extra reliability can be attained by checking the proofs with a trustworthy automatic theorem prover. In this chapter we describe the verified "short stack" that includes a verified compiler for the programming language Piton <ref> [38] </ref>. We discuss the proofs of that compiler and the design of the FM9001 microprocessor [14] in Section 4.2. In Section 4.4 we develop a specification for a program that plays nim, a centuries-old game introduced in Section 4.3. Section 4.5 presents an algorithm and Piton implementation of this program. <p> The requirement imposed by Nqthm to get every detail of a proof exactly correct is very important in computer systems verification as even the most trivial-seeming mistake can lead to catastrophe. Piton is a computer language for which there is a compiler and associated machine-checked compiler correctness theorem <ref> [38] </ref>. A formal semantics for Piton, a formal description of the FM9001 microprocessor, and the Piton compiler are introduced as Nqthm functions. <p> The definition 39 of `wsp', and all the functions and lemmas associated with this proof, are listed in Appendix D. Some subsidiary functions are defined in the Piton proof report <ref> [38] </ref>. In particular, wsp (state, t) returns false if state is a losing state, and an optimal move otherwise. <p> stack space. (nim-piton-ctrl-stk-requirement + nim-piton-temp-stk-requirement) &lt; 1000 This part of the specification eliminates, for example, a table-driven implementation since there are 2 177 distinct possible nim states. 4.4.6 FM9001 Loadability We require that the program work on an FM9001 and that it meet the requirements of the compiler correctness proof <ref> [38] </ref>. This requires among other things that the compiled Piton programs fit into the FM9001 address space and that the Piton programs be well-formed. <p> The interested reader is referred to the Piton compiler correctness proof for details of this part of the specification, which has enabled us to apply the compiler correctness theorem <ref> [38] </ref>. This constraint eliminates some undesirable implementations that would otherwise satisfy the specification. <p> Although these proofs require only Nqthm, they were developed with extensive use of Pc-Nqthm [30], the interactive enhancement to Nqthm. The proof that the Piton program meets the specification uses the default arithmetic library [53] and the Piton interpreter definitions <ref> [38] </ref>. The correctness of the Piton subroutine nat-to-bv listed in Figure 4.6 is described by the prove-lemma command in Figure 4.7. The proof of this lemma illustrates what it takes to prove Piton correctness theorems. First, we accomplish a code correctness proof of the loop in nat-to-bv. <p> KIT is a small operating system proved correct for a typical Von Neumann architecture [5]. Some of the proof obligations involve showing that code correctly implements aspects of the operating system. A compiler for a subset of Gypsy [1, 44] that has as a target Piton <ref> [38] </ref> is proved correct [59]. Again, code that implements the needed functionality is proved correct. Like the nim proof in Chapter 4, timing behavior information is not dealt with in these projects as the models of computation associate with the execution of each instruction one "clock tick".
Reference: [39] <author> John B. Peatman. </author> <title> Design with Microcontrollers. </title> <publisher> McGraw-Hill, </publisher> <year> 1988. </year>
Reference-contexts: Signal debouncing is a problem routinely faced by real-time software developers that is caused by the physical bounce of the contacts in the button <ref> [39, 47] </ref> . Figure 7.2 displays a signal generated by a bouncy button. After a depress occurs, the signal is not predictable for some time. After a known amount of time has elapsed the signal will be high and will stay high until the button is released.
Reference: [40] <author> Gustav Pospischil, Peter Puschner, Alexander Vrchoticky, and Ralph Zain-linger. </author> <title> Developing real-time tasks with predictable timing. </title> <journal> IEEE Software, </journal> <pages> pages 35-44, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The use of semantic information about the application could be applied in a sound manner rather than in an ad hoc fashion during development of timing routines. The Mars design environment system <ref> [40] </ref> allows the user to do timing calculations similar to that of TAL. That is, the system can calculate upper bounds of program execution time, mostly automatically from the syntax.
Reference: [41] <author> Anne Rose, Maunel A. Perez, and Paul Clements. </author> <title> Modechart toolset user's guide. </title> <type> Technical report, </type> <institution> Center for Computer High Assurance Systems, US Navy Research Laboratory. </institution> <month> 648 </month>
Reference-contexts: Modechart is a state-based specification technique for real-time systems whose semantics is defined using RTL [29]. Tools that facilitate use of Modechart for real-time specification that exploit the ability to view these kinds of specifications graphically have been built <ref> [41] </ref>. Modechart is similar to Statechart [26], although Modechart allows convenient specification of absolute timing constraints. Behaviors, the specification formalism introduced in Chapter 6, are simpler than Modechart specifications.
Reference: [42] <author> John Rushby. </author> <title> Critical system properties: Survey and taxonomy. </title> <type> Technical Report CSL-93-01, </type> <institution> Computer Science Laboratory, SRI International, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: to apply our work to a commercially-available system that supports this kind of development in order to make our formal verification approach more widely accessible. 147 9.4 Real-time Verification Research Two particularly useful overviews of aspects of real-time verification research have been written: a "survey and taxonomy" of critical systems <ref> [42] </ref> and a description of the application of different kinds of schedulers [45]. One of the difficulties in producing reliable real-time software is that many levels of a system must be validated.
Reference: [43] <author> Larry Smith. </author> <title> Programming a PAL. Internal note, Computational Logic, </title> <publisher> Inc., </publisher> <year> 1990. </year>
Reference-contexts: Two new PLD's were designed, one a modification of memory address-handling hardware and one that drives the buttons and lights, and the board was rewired somewhat. This appendix contains the modified PLD design and lists the wiring changes. The PLD designs are in the form of PALASM input <ref> [43] </ref>. PALASM is a program that interprets designs and configures a programmable logic array that implements the design [4]. A.1 Design for FM addr The PLD FM addr is designed to decode the FM9001 address lines and select appropriate inputs and delay lines was revised.
Reference: [44] <author> M.K. Smith, Donald I. Good, and Benedetto L. DiVito. </author> <title> Using the Gypsy Methodology. </title> <booktitle> Computational Logic Inc., </booktitle> <year> 1986. </year> <note> Revised January 1988. </note>
Reference-contexts: KIT is a small operating system proved correct for a typical Von Neumann architecture [5]. Some of the proof obligations involve showing that code correctly implements aspects of the operating system. A compiler for a subset of Gypsy <ref> [1, 44] </ref> that has as a target Piton [38] is proved correct [59]. Again, code that implements the needed functionality is proved correct.
Reference: [45] <author> John A. Stankovic, Marco Spuri, and Marco Di Natale. </author> <title> Implications of classical scheduling results for real-time systems. </title> <type> Technical report, </type> <institution> University of Massachusetts, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: of development in order to make our formal verification approach more widely accessible. 147 9.4 Real-time Verification Research Two particularly useful overviews of aspects of real-time verification research have been written: a "survey and taxonomy" of critical systems [42] and a description of the application of different kinds of schedulers <ref> [45] </ref>. One of the difficulties in producing reliable real-time software is that many levels of a system must be validated. A misunderstanding of the behavior of the hardware platform could cause a malfunction just as could a mistake in the application program itself.
Reference: [46] <author> R. Tol. </author> <title> A small real-time kernel proven correct. </title> <booktitle> Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 227-230, </pages> <year> 1992. </year>
Reference-contexts: A purported Nqthm-checked correctness proof of a real-time kernel appears to have great relevance to our work <ref> [46] </ref> because its title suggests that an implementation of a real-time kernel had been reasoned about. Nevertheless, this project does not address the issue of real-time kernel implementation. Instead, a real-time kernel formalized in the Nqthm logic is presented. <p> The characterization of kernel "correctness" is so trivial that it does not require any behavior with which in practice a real-time kernel builder or user is concerned <ref> [46] </ref>. The "correctness" theorem is proved automatically by Nqthm directly from the definitions introduced to describe the kernel. <p> We believe that this work does not advance the cause of reliable real-time kernel development or use and, in particular, that the work presented in this dissertation is unrelated to the work presented in <ref> [46] </ref>. RTL (real-time logic) is a logic for reasoning about the requirements of real-time applications [28]. It uses an event-action model of real-time execution. Events in the environment and beginning and end of the execution of tasks are described in the logic along with various constraints on their relationships.
Reference: [47] <author> John Ursoleo. </author> <title> Software performs debouncing for large array of switches. </title> <booktitle> Electronic Design, </booktitle> <month> October 3 </month> <year> 1994. </year>
Reference-contexts: Signal debouncing is a problem routinely faced by real-time software developers that is caused by the physical bounce of the contacts in the button <ref> [39, 47] </ref> . Figure 7.2 displays a signal generated by a bouncy button. After a depress occurs, the signal is not predictable for some time. After a known amount of time has elapsed the signal will be high and will stay high until the button is released.
Reference: [48] <author> M. Utting and P. Kearney. </author> <title> Pipeline specification of a mips r3000 cpu. </title> <type> Technical Report 93-25, </type> <institution> Software Verification Research Cenre, The University of Queensland, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: The theorem they prove is that each task of a task set is assigned a processor time slice during each large time period. Their implementation is coded on a MIPS R3000 processor for which they have a processor model <ref> [48] </ref> and they are developing a general-purpose theorem-proving system, Ergo, with which they check their proofs [49]. There are many differences in our work, besides obvious ones such as the different theorem proving system and different target machine.
Reference: [49] <author> M. Utting and K. Whitwell. </author> <title> Ergo user manual. </title> <type> Technical Report 93-19, </type> <institution> Software Verification Research Cenre, The University of Queensland, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Their implementation is coded on a MIPS R3000 processor for which they have a processor model [48] and they are developing a general-purpose theorem-proving system, Ergo, with which they check their proofs <ref> [49] </ref>. There are many differences in our work, besides obvious ones such as the different theorem proving system and different target machine. Perhaps most importantly, they are not focussed on proving the correctness of particular real-time systems as we are, for example, with the verification of the quiz-show system.
Reference: [50] <author> Larry Wall and Randal L. Schwartz. </author> <title> Programming PERL. </title> <publisher> O'Reilly and Associates, Inc., </publisher> <address> California, </address> <year> 1990. </year> <month> 649 </month>
Reference-contexts: is that the applications described in that chapter may be dependably executed on the FM9001 board described in Section 5. (Recall the discussion in Section 5.9 about the relationship between the real-time FM9001 model and the fabricated FM9001.) The monitor program resident in the FM9001 ROM and a PERL script <ref> [50] </ref> running on a Sun Sparcstation are used to communicate with the FM9001 board [55].
Reference: [51] <author> Matthew Wilding. </author> <title> A mechanically-checked correctness proof of a floating-point search program. </title> <type> Technical Report 56, </type> <institution> Computational Logic, Inc., </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Clever design of inference rules is peculiar to the construction of mechanical proofs. The standard Nqthm arithmetic libraries are an example of this kind of design <ref> [7, 31, 51] </ref>. These libraries contain theorems proved about arithmetic that constitute a strategy for how to divine needed truths about involving arithmetic operations. <p> These libraries contain theorems proved about arithmetic that constitute a strategy for how to divine needed truths about involving arithmetic operations. The libraries have proved useful for accomplishing proofs from a variety of domains that involve arithmetic <ref> [20, 51, 52, 58] </ref> and we use them in the proofs described in this dissertation. A relatively simple mechanical proof of Matijasevich's lemma a theorem about Fibonnaci numbers demonstrates the efficacy of the arithmetic libraries [53]. <p> append (periodic-task-requests (car (pts), starting-time, ending-time), periodic-tasks-requests (cdr (pts), starting-time, ending-time)) else nil endif else nil endif *(PERIODIC-TASKS-REQUESTS '((A 3 2) (B 9 3)) 0 18) '((A 0 3 2) (A 3 6 2) (A 6 9 2) (A 9 12 2) Nqthm has been used to reason about rationals <ref> [51] </ref>, but it is simpler when using Nqthm to stay in the realm of naturals. We introduce a function that we use to express the desired theorem using only natural number arith metic. The term big-period (pts) is the product of the task periods in pts.
Reference: [52] <author> Matthew Wilding. </author> <title> Events for the proof of rational facts needed in a distributed algorithm correctness proof. Internal Note 222, Computational Logic, </title> <publisher> Inc., </publisher> <month> March </month> <year> 1991. </year>
Reference-contexts: These libraries contain theorems proved about arithmetic that constitute a strategy for how to divine needed truths about involving arithmetic operations. The libraries have proved useful for accomplishing proofs from a variety of domains that involve arithmetic <ref> [20, 51, 52, 58] </ref> and we use them in the proofs described in this dissertation. A relatively simple mechanical proof of Matijasevich's lemma a theorem about Fibonnaci numbers demonstrates the efficacy of the arithmetic libraries [53].
Reference: [53] <author> Matthew Wilding. </author> <title> Proving Matijasevich's lemma with a default arithmetic strategy. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7(3), </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: Many Nqthm introductions have been written by this author and others. Although we use attribution, parts of this chapter, particularly Sections 2.2 and 2.3, have been influenced by a variety of sources <ref> [10, 21, 53] </ref>. 2.2 A Brief Introduction to the Nqthm Logic The Nqthm logic is explained precisely in its documentation [10]. We present a brief description because our work makes extensive use of Nqthm, and we wish this dissertation to be as self-contained as possible. <p> A relatively simple mechanical proof of Matijasevich's lemma a theorem about Fibonnaci numbers demonstrates the efficacy of the arithmetic libraries <ref> [53] </ref>. The sequence of Nqthm conjectures ending in Matijasevich's lemma that is accepted by Nqthm is similar to an informal hand proof in a textbook [24]. Nqthm is able to "fill in the formality" because of the strategy incorporated in the libraries. <p> Most of these are lemmas that are stated and proved in order to guide Nqthm to the proof of later theorems, and this listing does not include the standard library of arithmetic theorems upon which this proof depends <ref> [53] </ref>. The proof took approximately 3 months for the author to construct. Nqthm requires approximately 2.5 hours to process the events on an unloaded Sun Sparcstation IPC and generates an 8 Megabyte file containing 29 an English-language justification. <p> In our proof of this theorem, for example, we take advantage of the libraries of previously-proved arithmetic facts described briefly in Section 2.4 that have been developed for Nqthm-checked proofs of other theorems <ref> [53] </ref>. In contrast, the many theorems we have proved involving earliest-deadline-first scheduling are probably not applicable in other domains. <p> We call proofs of this kind of lemma timing proofs. Although these proofs require only Nqthm, they were developed with extensive use of Pc-Nqthm [30], the interactive enhancement to Nqthm. The proof that the Piton program meets the specification uses the default arithmetic library <ref> [53] </ref> and the Piton interpreter definitions [38]. The correctness of the Piton subroutine nat-to-bv listed in Figure 4.6 is described by the prove-lemma command in Figure 4.7. The proof of this lemma illustrates what it takes to prove Piton correctness theorems.
Reference: [54] <author> Matthew Wilding. </author> <title> A verified nim strategy. Internal Note 249, Computational Logic, </title> <publisher> Inc., </publisher> <month> November </month> <year> 1991. </year>
Reference-contexts: The development of the correctness proof required about 3 months, not including time to develop the events of the Piton compiler or arithmetic library or to accomplish an earlier proof related to nim <ref> [54] </ref>. Approximately 40% of the development time was spent on code correctness proofs, 30% on specification proofs, 20% on algorithm proofs, and 10% on timing proofs.
Reference: [55] <author> Matthew Wilding. </author> <title> Using the FM9001 single-board computer. Internal Note 260, Computational Logic, </title> <publisher> Inc., </publisher> <year> 1992. </year>
Reference-contexts: The verification was accomplished using Nqthm, so the specifications are expressed in the Nqthm logic. The netlist-level description has been used to fabricate physically the processor, and the resulting integrated circuit has run programs <ref> [55] </ref>. The programmer-level model has served as a basis for the development of highly-reliable applications such as the nim program described in Chapter 4. 54 55 general-purpose registers, the arithmetical flags, and the memory. The execution of an instruction is accomplished each "tick" of a computation. <p> 6)) ((OUT 6)) ((OUT 6)) ((OUT 6)) Note that after some time the value of the location is incremented by the FM9001 running our example state. 66 5.8 The FM9001 Single Board Computer The FM9001 single board computer contains an FM9001 and several other devices needed to run FM9001 programs <ref> [2, 55] </ref>. We have modified the board in order to run applications that perform I/O. Rather than present a complete description of the FM9001 board, we present here a description of the changes we made to the board for this project. <p> FM9001 board described in Section 5. (Recall the discussion in Section 5.9 about the relationship between the real-time FM9001 model and the fabricated FM9001.) The monitor program resident in the FM9001 ROM and a PERL script [50] running on a Sun Sparcstation are used to communicate with the FM9001 board <ref> [55] </ref>. <p> This type of approach holds promise for the development of systems that work reliably in the face of real-time system complexity. 153 Appendix A Modifications to the FM9001 Board The FM9001 board described in [2] and <ref> [55] </ref> has been modified to support real-time applications. Two new PLD's were designed, one a modification of memory address-handling hardware and one that drives the buttons and lights, and the board was rewired somewhat. This appendix contains the modified PLD design and lists the wiring changes.
Reference: [56] <author> Matthew Wilding. </author> <title> A mechanically verified application for a mechanically verified environment. In Costas Courcoubetis, editor, </title> <booktitle> Computer-aided Verification - CAV '93, volume 697 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Section 4.5 presents an algorithm and Piton implementation of this program. The development of an Nqthm-checked proof that the program meets the requirements outlined in Section 4.4 is discussed in Section 4.6. This work is also reported in <ref> [56] </ref>. 34 35 4.2 Background Proofs about computer systems are often mind-numbingly complex but not particularly deep, which is to say perfectly suited to automatic generation.
Reference: [57] <author> Matthew Wilding. </author> <title> A detailed processor model for verification of real-time applications. </title> <booktitle> In Proceedings of the 2nd IFAC Workshop on Safety and Reliability, IFAC Control Notes, </booktitle> <year> 1995. </year>
Reference-contexts: can represent the state of a real-time system at an instant in time as an association of values with variables, and the state of a system over time by a history, a sequence of associations where consecutive associations represent the system at instants separated by some constant amount of time <ref> [57] </ref>.
Reference: [58] <author> W.D. Young W.R. Bevier. </author> <title> The proof of correctness of a fault-tolerant circuit design. </title> <booktitle> In Proceedings of the Second International Working Conference on Dependable Computing for Critical Applications, </booktitle> <pages> pages 107-114. </pages> <publisher> IFIP, </publisher> <month> February </month> <year> 1991. </year> <month> 650 </month>
Reference-contexts: These libraries contain theorems proved about arithmetic that constitute a strategy for how to divine needed truths about involving arithmetic operations. The libraries have proved useful for accomplishing proofs from a variety of domains that involve arithmetic <ref> [20, 51, 52, 58] </ref> and we use them in the proofs described in this dissertation. A relatively simple mechanical proof of Matijasevich's lemma a theorem about Fibonnaci numbers demonstrates the efficacy of the arithmetic libraries [53].
Reference: [59] <author> W.D. Young. </author> <title> A verified code generator for a subset of Gypsy. </title> <type> Technical Report 33, </type> <institution> Computational Logic, Inc., </institution> <year> 1988. </year> <type> Ph.D. Thesis, </type> <institution> University of Texas at Austin. </institution>
Reference-contexts: Some of the proof obligations involve showing that code correctly implements aspects of the operating system. A compiler for a subset of Gypsy [1, 44] that has as a target Piton [38] is proved correct <ref> [59] </ref>. Again, code that implements the needed functionality is proved correct. Like the nim proof in Chapter 4, timing behavior information is not dealt with in these projects as the models of computation associate with the execution of each instruction one "clock tick".
Reference: [60] <author> William D. Young. </author> <title> Verifying a simple real-time system with Nqthm. Internal Note 288, Computational Logic, </title> <publisher> Inc., </publisher> <year> 1993. </year>
Reference-contexts: The requirements on an implementation of the rowboat controller are not obviously derivable from the algorithm and model presented in [12]. For example, to conform to the simple model the program needs to take no time to execute. Young presents an Nqthm-based specification of a simple real-time system <ref> [60] </ref>. Similar in style to the rowboat, it captures the requirements of a railroad crossing. The behavior of the train, a railway gate, and a controller are modeled using a sequence of states.
Reference: [61] <author> Zheng Yuhua and Zhou Chaochen. </author> <title> A formal proof of the deadline driven scheduler. Formal Techniques in Real-Time and Fault-Tolerant Systems, </title> <booktitle> Third International Symposium, </booktitle> <pages> pages 756-775, </pages> <year> 1994. </year>
Reference-contexts: The original proof of this theorem contained flaws [34], but a subsequent published proof developed independently of the machine-checked proof presented in this chapter appears correct <ref> [61] </ref>.
References-found: 61

