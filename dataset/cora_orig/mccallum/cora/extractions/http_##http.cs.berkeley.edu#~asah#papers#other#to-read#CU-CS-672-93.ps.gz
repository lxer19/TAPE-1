URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/CU-CS-672-93.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: Control Constructs in a Completely Visual Imperative Programming Language  
Author: Wayne Citrin Michael Doherty and Benjamin Zorn 
Date: September 1993  
Address: Campus Box #425  Boulder 80309-0425  Campus Box #430  Boulder 80309-0430  Boulder  
Affiliation: Department of Electrical and Computer Engineering  University of Colorado,  Department of Computer Science  University of Colorado,  ffi University of Colorado at  
Pubnum: CU-CS-672-93  
Abstract: Technical Report CU-CS-672-93 Department of Computer Science Campus Box 430 University of Colorado Boulder, Colorado 80309 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bell and C. Lewis. ChemTrains: </author> <title> A language for creating behaving pictures. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Visual Languages, </booktitle> <pages> pages 188-195, </pages> <address> Bergen, Norway, </address> <year> 1993. </year>
Reference-contexts: If the "before" part of a before/after pair matches part of the state, the state is transformed to conform to the "after" part of the pair. BitPict [7] is one of the simplest of such languages, in that its before/after pairs are simple pixel patterns. ChemTrains <ref> [1] </ref> and Vampire [12] allow more complex visual entities and relations, and also permit variables in the transformation rules. <p> The textual representation of the bubble sort is shown in Figure 11 and the corresponding static representation is shown in Figure 12. steps in its execution. The four snapshots are labeled with the corresponding statement number from 16 int a [100], n; <ref> [1] </ref> void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; [3] do [4] exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; [8] a [j] = a [j+1]; [9] a [j+1] = hold; [10] exch = 1; - [11]
Reference: [2] <author> F. P. Brooks. </author> <title> No silver bullet: Essence and accidents of software engineering. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 10-19, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction 1.1 Motivation Although visual programming languages have been a subject of research for at least thirty years, they have failed to make an impact on programming language design in proportion to the enthusiasm of the investigators in the field. Although various reasons have been advanced for this (see <ref> [2] </ref> and [5] for a discussion of problems with visual languages), one problem is that most proposed visual languages have simply been visual overlays of textual languages. Semantics of such visual languages can only be understood through reference to the semantics of the underlying textual languages. <p> The four snapshots are labeled with the corresponding statement number from 16 int a [100], n; [1] void BubbleSort (void) - int hold, j, pass, exch; <ref> [2] </ref> pass = n; [3] do [4] exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; [8] a [j] = a [j+1]; [9] a [j+1] = hold; [10] exch = 1; - [11] pass--; [12] while (exch); - too crowded are shaded, indicating
Reference: [3] <author> Wayne Citrin, Michael Doherty, and Benjamin Zorn. </author> <title> The design of a completely visual object-oriented programming language. </title> <booktitle> In OOPSLA'93 Workshop on Visual Object-Oriented Programming, </booktitle> <pages> pages 19-35, </pages> <address> Washington, D.C., </address> <month> September </month> <year> 1993. </year>
Reference-contexts: The language we describe, called Vipr (Visual Imperative PRogramming language), is based roughly on the C programming language. We are also considering object-oriented features in Vipr; they are discussed in a companion paper <ref> [3] </ref>. The language discussed in this paper is intended to be a starting point for 2 further research in completely visual programming languages; the specifics of the language will likely change over time. This paper focuses on control constructs in Vipr. <p> The four snapshots are labeled with the corresponding statement number from 16 int a [100], n; [1] void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; <ref> [3] </ref> do [4] exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; [8] a [j] = a [j+1]; [9] a [j+1] = hold; [10] exch = 1; - [11] pass--; [12] while (exch); - too crowded are shaded, indicating that there is some
Reference: [4] <author> Wayne Citrin, Michael Doherty, and Benjamin Zorn. </author> <title> Formal semantics of control constructs in a completely visual imperative language. </title> <type> Technical Report CU-CS-673-93, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Boulder, CO, </institution> <month> September </month> <year> 1993. </year> <note> In preparation. </note>
Reference-contexts: To our knowledge, such a formal definition has not been given to a visual imperative programming language. In this paper, we outline the formal semantics of the constructs introduced and refer the interested reader to a companion paper for more details <ref> [4] </ref>. After defining the semantics of our language, we illustrate our ideas by presenting a more complex example program in the language. This example, a bubble sort program, serves to illustrate that the static and dynamic program representation use the same framework and shows how simple programs are represented. <p> A formal denotational and operational description of the general Vipr language is beyond the scope of this paper, but may be found in <ref> [4] </ref>. In addition [4], contains a proof that the semantics of the constructs presented below, interpreted as general Vipr constructs, are equivalent to the semantics of the Simple Imperative Language as conventionally defined. 4.2 A Note on Syntax For the syntactic specification of Vipr, we employ a formalism known as relational <p> A formal denotational and operational description of the general Vipr language is beyond the scope of this paper, but may be found in <ref> [4] </ref>. In addition [4], contains a proof that the semantics of the constructs presented below, interpreted as general Vipr constructs, are equivalent to the semantics of the Simple Imperative Language as conventionally defined. 4.2 A Note on Syntax For the syntactic specification of Vipr, we employ a formalism known as relational grammars [15], which <p> The four snapshots are labeled with the corresponding statement number from 16 int a [100], n; [1] void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; [3] do <ref> [4] </ref> exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; [8] a [j] = a [j+1]; [9] a [j+1] = hold; [10] exch = 1; - [11] pass--; [12] while (exch); - too crowded are shaded, indicating that there is some lost information.
Reference: [5] <author> E. Dijkstra. </author> <title> On the cruelty of really teaching computer science. </title> <journal> Communications of the ACM, </journal> <pages> pages 1397-1404, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Although various reasons have been advanced for this (see [2] and <ref> [5] </ref> for a discussion of problems with visual languages), one problem is that most proposed visual languages have simply been visual overlays of textual languages. Semantics of such visual languages can only be understood through reference to the semantics of the underlying textual languages. <p> The four snapshots are labeled with the corresponding statement number from 16 int a [100], n; [1] void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; [3] do [4] exch = 0; <ref> [5] </ref> for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; [8] a [j] = a [j+1]; [9] a [j+1] = hold; [10] exch = 1; - [11] pass--; [12] while (exch); - too crowded are shaded, indicating that there is some lost information.
Reference: [6] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1976. </year>
Reference-contexts: If none of the guards are true, the program is in error. Thus, we support conditional semantics very similar to Dijkstra's guarded-if construct <ref> [6] </ref>. With these semantics, if-then, if-then-else, and case statements can be easily represented. if-then-elsif-else semantics simply requires nested if-then-else conditionals. both branches of the conditional. This example also illustrates the use of arrow notation in Vipr.
Reference: [7] <author> G. W. Furnas. </author> <title> New graphical reasoning models for understanding graphical interfaces. </title> <booktitle> In Proceedings of CHI'91, </booktitle> <pages> pages 71-78, </pages> <address> Anaheim, CA, April 1981. </address> <publisher> ACM Press. </publisher>
Reference-contexts: State consists of a set of graphical entities and their relationships. If the "before" part of a before/after pair matches part of the state, the state is transformed to conform to the "after" part of the pair. BitPict <ref> [7] </ref> is one of the simplest of such languages, in that its before/after pairs are simple pixel patterns. ChemTrains [1] and Vampire [12] allow more complex visual entities and relations, and also permit variables in the transformation rules. <p> The four snapshots are labeled with the corresponding statement number from 16 int a [100], n; [1] void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; [3] do [4] exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - <ref> [7] </ref> hold = a [j]; [8] a [j] = a [j+1]; [9] a [j+1] = hold; [10] exch = 1; - [11] pass--; [12] while (exch); - too crowded are shaded, indicating that there is some lost information. <p> State objects have been omitted for the same reason. shaded circle inside the j++ statement contains a copy of the for statement (excluding the loop variable initialization). This copy was obtained by substitution of the circle pointed to by the j++ statement in exchange beginning at statement <ref> [7] </ref> is about to execute. Substitution of the j++ statement has occurred. reached by executing through the sequential statements that are the outer circles of Figure 13 (b) or by taking the alternate branch from Figure 13 (a).
Reference: [8] <author> E. P. Glinert and S. L. Tanimoto. </author> <title> Pict: An interactive graphical programming environment. </title> <booktitle> Computer, </booktitle> <pages> pages 7-25, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Pict <ref> [8] </ref> is the archetypal language in this model. Pict was designed to allow the user to do everything "visually," but in this case, "visually" meant through the use of icons representing computation steps. <p> The four snapshots are labeled with the corresponding statement number from 16 int a [100], n; [1] void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; [3] do [4] exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; <ref> [8] </ref> a [j] = a [j+1]; [9] a [j+1] = hold; [10] exch = 1; - [11] pass--; [12] while (exch); - too crowded are shaded, indicating that there is some lost information.
Reference: [9] <author> E. J. Golin and S. P. Reiss. </author> <title> The specification of visual language syntax. </title> <booktitle> In 1989 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 105-110, </pages> <address> Rome, ITALY, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: In relational grammars, particularly the subclass known as picture layout grammars <ref> [9] </ref>, context sensitivity is modeled by allowing the spatial relations on the righthand side of a rule to reference objects that are not part of the corresponding multiset. These objections are known as remote objects. <p> the corresponding statement number from 16 int a [100], n; [1] void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; [3] do [4] exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; [8] a [j] = a [j+1]; <ref> [9] </ref> a [j+1] = hold; [10] exch = 1; - [11] pass--; [12] while (exch); - too crowded are shaded, indicating that there is some lost information. In an actual implementation of Vipr such overcrowding would be handled by culling out all objects that appear below screen resolution.
Reference: [10] <author> K. M. Kahn and V. A. Saraswat. </author> <title> Complete visualizations of concurrent programs and their executions. </title> <booktitle> In Proceedings of the 1990 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 7-15, </pages> <address> Skokie, IL, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: The most 3 significant such language is Pictorial Janus <ref> [10] </ref>, which was originally designed to model the execution of the constraint logic programming language Janus, but whose execution semantics may be derived from graphical rules applied to the visual representation. <p> Its appearance and semantics are based roughly on Kahn's Pictorial Janus <ref> [10] </ref>, which is a completely visual language that supports constraint logic programming. Vipr is different from Pictorial Janus in that its underlying model of computation is a familiar imperative language with procedures. Formally, the Vipr language described here is very similar to Tennent's Simple Imperative Language [14]. <p> 16 int a [100], n; [1] void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; [3] do [4] exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; [8] a [j] = a [j+1]; [9] a [j+1] = hold; <ref> [10] </ref> exch = 1; - [11] pass--; [12] while (exch); - too crowded are shaded, indicating that there is some lost information. In an actual implementation of Vipr such overcrowding would be handled by culling out all objects that appear below screen resolution.
Reference: [11] <author> M. E. Kopache and E. P. Glinert. </author> <title> Visual Programming Environments: Paradigms and Systems, chapter C 2 </title> : 
Reference-contexts: Other similar systems that refine the design of visual equivalents of textual imperative languages include C 2 <ref> [11] </ref> and PECAN [13]. 4 /* This is a simple VIPR program */ int x; void main () - if (x == 1) - printf ("Hello World"); - 3 Informal Syntax and Semantics of Vipr 3.1 Overview of Vipr Vipr is a statically-typed, imperative programming language. <p> [1] void BubbleSort (void) - int hold, j, pass, exch; [2] pass = n; [3] do [4] exch = 0; [5] for (j=0; j &lt; (pass-1); j++) - - [7] hold = a [j]; [8] a [j] = a [j+1]; [9] a [j+1] = hold; [10] exch = 1; - <ref> [11] </ref> pass--; [12] while (exch); - too crowded are shaded, indicating that there is some lost information. In an actual implementation of Vipr such overcrowding would be handled by culling out all objects that appear below screen resolution.
References-found: 11

