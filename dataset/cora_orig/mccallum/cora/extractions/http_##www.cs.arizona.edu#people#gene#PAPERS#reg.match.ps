URL: http://www.cs.arizona.edu/people/gene/PAPERS/reg.match.ps
Refering-URL: http://www.cs.arizona.edu/people/gene/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Author: Eugene W. Myers Paulo Oliva Katia Guimar~aes 
Date: February 4, 1998  
Abstract: Reporting Exact and Approximate Regular Expression Matches Abstract While much work has been done on determining if a document or a line of a document contains an exact or approximate match to a regular expression, less effort has been expended in formulating and determining what to report as "the match" once such a "hit" is detected. For exact regular expression pattern matching, we give algorithms for finding a longest match, all symbols involved in some match, and finding optimal submatches to tagged parts of a pattern. For approximate regular expression matching, we develop notions of what constitutes a significant match, give algorithms for them, and also for finding a longest match and all symbols in a match.
Abstract-found: 1
Intro-found: 1
Reference: [CC97] <author> C.A. Clarke and G.V. Cormack. </author> <title> On the use of regular expressons for searching text. </title> <journal> ACM Trans. on Prog. Languages and Systems, </journal> <volume> 19(3) </volume> <pages> 413-426, </pages> <year> 1997. </year>
Reference-contexts: In a recent paper, Clarke and Cormack, argue that shortest matches have superior search properties when looking at patterns that involve matching several regular expressions <ref> [CC97] </ref>. On the other hand, we know of no reported work on reporting approximate matches to regular expressions, save that there are connections to work on finding locally optimal alignments [SW81, Sel84]. Our goal is to report matches in a meaningful way.
Reference: [IEE92] <author> IEEE. </author> <title> Portable Operating System Interface (POSIX). </title> <institution> IEEE Std 1003.2, Inst. of EE Engineers, </institution> <address> New York, </address> <year> 1992. </year>
Reference-contexts: That is, we can afford to spend more time on each line containing a match, working on delivering a meaningful match rather than one that is an artifact of the scanning/filtration algorithm. The widely accepted standard, e.g. Perl [WS91], Tcl/Tk [Ous94], and the IEEE Posix standard <ref> [IEE92] </ref>, for exact regular expression pattern matching is to report the left-most longest match, i.e. the matching substring whose left end is leftmost, and if there are several with such a left end, then fl Dept. of Computer Science, University of Arizona Tucson, AZ 85721 (e-mail: gene@cs.arizona.edu).
Reference: [MJ96] <author> E. Myers and M. Jain. </author> <title> Going against the grain. </title> <publisher> In Carleton University Press, </publisher> <editor> editor, </editor> <booktitle> Proc. 3rd South American Workshop on String Processing, International Informatics Series #4, </booktitle> <pages> pages 203-213, </pages> <year> 1996. </year>
Reference-contexts: Thus the "grain" of the computations for S f and S r oppose each other. If space is a problem in a particular context, then one can employ the "going-against the grain" algorithm of Myers and Jain <ref> [MJ96] </ref>, to compute S r (1); S r (2); S r (3); : : :S r (N ) in the given order using O (tP N ) time and O (P N 1=t ) space for any choice of t 1. <p> The computation of E " S can be efficiently organized as we noted earlier in Section 2.2, where the grain or direction of two recurrences oppose each other, as do the recurrences for PreP and SufP 9 here. With the method of <ref> [MJ96] </ref> we can compute SufP R (0), SufP R (1), : : : SufP R (N ) in the order given using O (tP N ) time and O (P N 1=t ) space for any choice of t 1, where SufP R (i) is the set of values fSufP (i;
Reference: [MM88] <author> E. Myers and W. Miller. </author> <title> Approximate matching of regular expressions. </title> <journal> Bulletin of Mathematical Biology, </journal> <volume> 51(1) </volume> <pages> 5-37, </pages> <year> 1988. </year>
Reference-contexts: Interestingly, this problem can be solved in O (P N ) time using a specialization of the approximate regular expression matching algorithm of Miller and Myers <ref> [MM88] </ref> that accommodates any additive alignment scoring scheme ffi. Quickly we review this result and then proceed to the specialization. First, recall that any regular expression R can be converted to a state-labeled *-NFA F that has at most O (P ) states and transitions and a single final/accepting state.
Reference: [Ous94] <author> J.K. Ousterhout. </author> <title> Tcl and the TK Toolkit. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1994. </year>
Reference-contexts: That is, we can afford to spend more time on each line containing a match, working on delivering a meaningful match rather than one that is an artifact of the scanning/filtration algorithm. The widely accepted standard, e.g. Perl [WS91], Tcl/Tk <ref> [Ous94] </ref>, and the IEEE Posix standard [IEE92], for exact regular expression pattern matching is to report the left-most longest match, i.e. the matching substring whose left end is leftmost, and if there are several with such a left end, then fl Dept. of Computer Science, University of Arizona Tucson, AZ 85721
Reference: [Sed83] <author> R. Sedgewick. </author> <title> Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: Solving this problem requires extending the well-known O (P N ) state-set simulation algorithm for matching regular expressions <ref> [Tho68, Sed83] </ref>. Recall that the algorithm computes in increasing sequence of text position i, what we call here the forward state-set S f (i) = fs : a suffix of A [1::i] is in L F (s)g.
Reference: [Sel84] <author> P.H. Sellers. </author> <title> Pattern recognition in genetic sequences by mismatch density. </title> <journal> Bulletin of Mathematical Biology, </journal> <volume> 46 </volume> <pages> 501-514, </pages> <year> 1984. </year>
Reference-contexts: On the other hand, we know of no reported work on reporting approximate matches to regular expressions, save that there are connections to work on finding locally optimal alignments <ref> [SW81, Sel84] </ref>. Our goal is to report matches in a meaningful way. For example, suppose one is given the regular expression babb*bab and one is requested to find matches with 2 differences or less. <p> Intuitively, every "extension" of the match is significant. In the early 1980's Sellers <ref> [Sel84] </ref> explored algorithms for finding such matches in the context of molecular biology. This work appears to have been forgotten in the wake of the current popularity of the Smith-Waterman algorithm [SW81]. Sellers' basic idea is as follows.
Reference: [SW81] <author> T.F. Smith and M.S. Waterman. </author> <title> Identification of common molecular sequence. </title> <journal> J. of Molecular Biology, </journal> <volume> 147 </volume> <pages> 195-197, </pages> <year> 1981. </year>
Reference-contexts: On the other hand, we know of no reported work on reporting approximate matches to regular expressions, save that there are connections to work on finding locally optimal alignments <ref> [SW81, Sel84] </ref>. Our goal is to report matches in a meaningful way. For example, suppose one is given the regular expression babb*bab and one is requested to find matches with 2 differences or less. <p> Intuitively, every "extension" of the match is significant. In the early 1980's Sellers [Sel84] explored algorithms for finding such matches in the context of molecular biology. This work appears to have been forgotten in the wake of the current popularity of the Smith-Waterman algorithm <ref> [SW81] </ref>. Sellers' basic idea is as follows. Suppose scoring is with respect to a general additive scoring scheme ffi, and suppose one wants to detect only matches for which ffi (A; P )=jP j r.
Reference: [Tho68] <author> K. Thompson. </author> <title> Regular expression search algorithm. </title> <journal> Comm. of ACM, </journal> <volume> 11(6) </volume> <pages> 419-422, </pages> <year> 1968. </year>
Reference-contexts: Solving this problem requires extending the well-known O (P N ) state-set simulation algorithm for matching regular expressions <ref> [Tho68, Sed83] </ref>. Recall that the algorithm computes in increasing sequence of text position i, what we call here the forward state-set S f (i) = fs : a suffix of A [1::i] is in L F (s)g. <p> While this demonstrates that S f (i) can be computed from S f (i 1) in O (P ) worst-case time, the traditional reaching algorithm of <ref> [Tho68] </ref> does so in O (jS f (i 1)j + jS f (i)j) time as one is free to discover the states in S f (i) in any order.
Reference: [WS91] <author> L. Wall and R.L. Schwartz. </author> <title> Programming Perl. </title> <publisher> O'Reilly and Associates, </publisher> <address> Sebastopol, Calif., </address> <year> 1991. </year> <month> 10 </month>
Reference-contexts: That is, we can afford to spend more time on each line containing a match, working on delivering a meaningful match rather than one that is an artifact of the scanning/filtration algorithm. The widely accepted standard, e.g. Perl <ref> [WS91] </ref>, Tcl/Tk [Ous94], and the IEEE Posix standard [IEE92], for exact regular expression pattern matching is to report the left-most longest match, i.e. the matching substring whose left end is leftmost, and if there are several with such a left end, then fl Dept. of Computer Science, University of Arizona Tucson,
References-found: 10

