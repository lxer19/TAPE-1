URL: ftp://ftp.sics.se/pub/isl/papers/plilp97.ps.gz
Refering-URL: http://www.sics.se/isl/sicstus2.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: 2  3  
Title: An Open-Ended Finite Domain Constraint Solver  
Author: Mats Carlsson Greger Ottosson and Bjorn Carlson 
Address: PO Box 1263, S-164 29 KISTA, Sweden  PO Box 311, S-751 05 UPPSALA, Sweden  3333 Coyote Hill Road, Palo Alto, CA 94304, USA  
Affiliation: 1 SICS,  Computing Science Dept., Uppsala University  Xerox PARC,  
Abstract: We describe the design and implementation of a finite domain constraint solver embedded in a Prolog system using an extended unification mechanism via attributed variables as a generic constraint interface. The solver is essentially a scheduler for indexicals, i.e. reactive functional rules encoding local consistency methods performing incremental constraint solving or entailment checking, and global constraints, i.e. general propagators which may use specialized algorithms to achieve a higher degree of consistency or better time and space complexity. The solver has an open-ended design: the user can introduce new constraints, either in terms of indexicals by writing rules in a functional notation, or as global constraints via a Prolog programming interface. Constraints defined in terms of indexicals can be linked to 0/1-variables modeling entailment; thus indexicals are used for constraint solving as well as for entailment testing. Constraints can be arbitrarily combined using the propositional connectives by automatic expansion to systems of reified constraints. Keywords: Implementation of Constraint Systems, Constraint Program ming, Finite Domains, Indexicals, Global Constraints.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aggoun and N. Beldiceanu. </author> <title> Extending CHIP in order to solve complex scheduling and placement problems. </title> <journal> Mathl. Comput. Modelling, </journal> <volume> 17(7) </volume> <pages> 57-73, </pages> <year> 1993. </year>
Reference-contexts: element (I; L; Y ), constraining the I:th element of L to be equal to Y , uses a consistency algorithm based on AC-4. cumulative (S; D; R; L), modelling a set of tasks with start times S, durations D, and resource need R, sharing a resource with capacity L <ref> [1] </ref>. The implementation is based on several OR methods [7,2]. 5 Performance Evaluation The performance evaluation of our solver is structured as follows. First, we compare our low-level implementation of reification with alternative schemes.
Reference: 2. <author> P. Baptiste and C. Le Pape. </author> <title> A theoretical and experimental comparison of constraint propagation techniques for disjunctive scheduling. </title> <booktitle> In Proceedings of the Seventeenth International Joint Conference on Artificial Intelligence (IJCAI-95), </booktitle> <address> Montreal, Canada, </address> <month> August </month> <year> 1995. </year>
Reference: 3. <author> N. Beldiceanu and E. Contejean. </author> <title> Introducing global constraints in CHIP. </title> <journal> Mathl. Comput. Modelling, </journal> 20(12) 97-123, 1994. 
Reference: 4. <author> B. Carlson and M. Carlsson. </author> <title> Compiling and Executing Disjunctions of Finite Domain Constraints. </title> <booktitle> In Proceedings of the Twelfth International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference: 5. <author> B. Carlson, M. Carlsson, and D. Diaz. </author> <title> Entailment of finite domain constraints. </title> <booktitle> In Proceedings of the Eleventh International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Coding rules for a propagating indexicals X in r Rule 1 says that it is safe to consider C entailed after pruning X if r is ground. This is a significant optimization <ref> [5] </ref>, and is exploited as follows: Indexicals that are projections of the same constraint, as e.g. in eqcd/3 in Fig. 2, are connected by references to a common flag. Whenever one of the indexicals is decided entailed, the flag is set. <p> Finally, rule 3 is a natural consequence of rule 1 for any reasonable constraint. It has been shown that anti-monotone indexicals can be used for expressing logical conditions for entailment detection <ref> [5] </ref>. As we will show in the following section, a reification mechanism can be built on top of indexicals. Coding rules analogous to those in Fig. 3 apply for indexicals detecting entailment. <p> This is achieved by suspending the indexicals until certain variables are ground. The set of variables to suspend on is easily computed at compile time <ref> [5] </ref>. For example, in eqcd/3 in Fig. 2, the first indexical is not admitted for execution until C is known. We maintain separate separate scheduling queues for indexicals and global constraints; a global constraint is only resumed when no indexicals are scheduled for execution.
Reference: 6. <author> B. Carlson, M. Carlsson, and S. </author> <title> Janson. </title> <booktitle> The implementation of AKL(FD). In Logic Programming: Proceedings of the 1995 International Symposium. </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: We share this extensions with some other systems [12,16,21,17]. Host language integration The design of clp (F D) [9] extends the underlying Prolog engine with several new abstract machine instructions supporting constraints, and compiles all source code to C. AKL (FD) <ref> [6] </ref> integrated the indexical approach into a concurrent constraint language with deep guards and a generic constraint interface on the level of C. Constraint system specific methods for e.g. garbage collection must be provided in this interface.
Reference: 7. <author> Y. Caseau and F. Laburthe. </author> <title> Improved clp scheduling with task intervals. </title> <editor> In P. Van Hentenryck, editor, </editor> <booktitle> Logic Programming, Proceedings of the Eleventh International Conference on Logic Programming, </booktitle> <pages> pages 369-383, </pages> <address> Santa Margherita Ligure, Italy, 1994. </address> <publisher> MIT Press. </publisher>
Reference: 8. <author> Philippe Codognet and Giuseppe Nardiello. </author> <title> Enhancing the constraint-solving power of clp(FD) by means of path-consistency methods. </title> <editor> In A. Podelski, editor, </editor> <title> Constraints: Basics and Trends, </title> <booktitle> volume 910 of Lecture Notes in Computer Science, </booktitle> <pages> pages 37-61. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The indexical scheme can be readily extended, with for example conditional ranges [21,6], with "foreach" constructs as in our design, or with arbitrary functions written in C [9]. A generalization of indexicals to m-constraints encoding path-consistency methods was proposed in <ref> [8] </ref>. Reification CLP (BNR) [16] was the first system to allow propositional combinations of arithmetic constraints by means of reification. This is now allowed by many systems including ours [21,12,22,17]. Other systems provide blocking implication [10,25] or cardinality [25]. Only research prototypes have no reification support.
Reference: 9. <author> D. Diaz and P. Codognet. </author> <title> A Minimal Extension of the WAM for CLP(FD). </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 774-790, </pages> <address> Budapest, Hungary, 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In-dexicals were a key component of the design, but seem to have been abandoned later. Unfortunately, no implementation of cc (F D) is available for comparison. Other systems [9,21,6] have been solely based on indexicals. Notably, clp (FD) <ref> [9] </ref> demonstrated the feasibility of the indexical approach, achieving excellent performance by compiling to C. Our design is the first to be based on a mixture of indexicals and global constraints, compiling indexicals to byte code for a threaded-code stack machine. <p> The indexical scheme can be readily extended, with for example conditional ranges [21,6], with "foreach" constructs as in our design, or with arbitrary functions written in C <ref> [9] </ref>. A generalization of indexicals to m-constraints encoding path-consistency methods was proposed in [8]. Reification CLP (BNR) [16] was the first system to allow propositional combinations of arithmetic constraints by means of reification. This is now allowed by many systems including ours [21,12,22,17]. <p> Ours is based on a mixed approach, combining the best of both worlds. Programming interfaces Any system that is not completely closed needs a programming interface for defining new constraints. In indexical-based systems, the indexical language provides such an interface. clp (F D) <ref> [9] </ref> allows the use of arbitrary C functions in indexicals. ECL i PS e [12] uses attributed variables as a generic constraint interface. By accessing these attributed variables and calling internal coroutining primitives, user-defined constraints can be programmed. <p> The extension to the full integer domain strictly extends the expressive power of the language so that it can reason e.g. about differences, but complicates the non-linear arithmetic constraints somewhat. We share this extensions with some other systems [12,16,21,17]. Host language integration The design of clp (F D) <ref> [9] </ref> extends the underlying Prolog engine with several new abstract machine instructions supporting constraints, and compiles all source code to C. AKL (FD) [6] integrated the indexical approach into a concurrent constraint language with deep guards and a generic constraint interface on the level of C.
Reference: 10. <author> M. Dincbas, P. van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <year> 1988. </year>
Reference-contexts: In this section, we will focus on particular features of our solver and how they relate to some other known systems. Indexicals Indexicals were first conceived in the context of cc (FD) [24,25]. The vision was to provide a rational, glass box reconstruction of the FD part of CHIP <ref> [10] </ref>, replacing a host of ad-hoc concepts by a small set of powerful concepts and combinators such as blocking implication and the cardinality operator. In-dexicals were a key component of the design, but seem to have been abandoned later. Unfortunately, no implementation of cc (F D) is available for comparison. <p> ECL i PS e [12] uses attributed variables as a generic constraint interface. By accessing these attributed variables and calling internal coroutining primitives, user-defined constraints can be programmed. Oz [22], Ilog Solver [14] and CHIP <ref> [10] </ref> provide programming interfaces in terms of C++ classes. CHIP also provides declarations that allow the user to use arbitrary Prolog code as constraints; we provide the same ability via a simple API. Negative numbers In many finite domain constraint solvers, the constraints are over natural numbers [22,9,25,6,10].
Reference: 11. <author> Mats Carlsson et al. </author> <title> SICStus Prolog User's Manual. </title> <institution> SICS Research Report, Swedish Institute of Computer Science, </institution> <year> 1995. </year> <note> URL: http://www.sics.se/isl/sicstus.html. </note>
Reference-contexts: 1 Introduction We describe the design and implementation of the SICStus Prolog <ref> [11] </ref> finite domain constraint solver. The solver is essentially a scheduler for two entities: indexicals [24], i.e. reactive functional rules performing incremental constraint solving or entailment checking within the framework of the Waltz filtering algorithm [26], and global constraints, i.e. general propagators which may use specialized constraint solving algorithms.
Reference: 12. <author> Micha Meier et al. </author> <title> ECLiPSe user manual. </title> <institution> ECRC Research Report ECRC-93-6, European Computer Research Consortium, </institution> <year> 1993. </year>
Reference-contexts: Programming interfaces Any system that is not completely closed needs a programming interface for defining new constraints. In indexical-based systems, the indexical language provides such an interface. clp (F D) [9] allows the use of arbitrary C functions in indexicals. ECL i PS e <ref> [12] </ref> uses attributed variables as a generic constraint interface. By accessing these attributed variables and calling internal coroutining primitives, user-defined constraints can be programmed. Oz [22], Ilog Solver [14] and CHIP [10] provide programming interfaces in terms of C++ classes.
Reference: 13. <author> C. Holzbaur. </author> <title> Specification of Constraint Based Inference Mechanism through Extended Unification. </title> <type> PhD thesis, </type> <institution> Dept. of Medical Cybernetics and AI, University of Vienna, </institution> <year> 1990. </year>
Reference-contexts: A small set of solver primitives provides the necessary back-end, managing memory, storing byte code in-core, etc. The interface between the Prolog engine and the solver is provided in part by the attributed variables mechanism <ref> [13] </ref>, which has been used previously to interface several constraint solvers into CLP systems [10,12,25,9,6,22]. This mechanism associates solver-specific information with variables, and provides hooks for extended unification and projection of answer constraints.
Reference: 14. <author> ILOG. </author> <title> ILOG Solver C++. Reference manual, </title> <type> ILOG S.A., </type> <year> 1993. </year>
Reference-contexts: ECL i PS e [12] uses attributed variables as a generic constraint interface. By accessing these attributed variables and calling internal coroutining primitives, user-defined constraints can be programmed. Oz [22], Ilog Solver <ref> [14] </ref> and CHIP [10] provide programming interfaces in terms of C++ classes. CHIP also provides declarations that allow the user to use arbitrary Prolog code as constraints; we provide the same ability via a simple API.
Reference: 15. <author> R. Mohr and T.C. Henderson. </author> <title> Arc and path consistency revisited. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 225-233, </pages> <year> 1986. </year>
Reference-contexts: The interface maintains a private state for each invocation of a global constraint. The state may e.g. contain the domains of the most recent invocation, admitting consistency methods such as AC-4 <ref> [15] </ref>. The interface also provides means to access the domains of variables and operations on the internal domain representation.
Reference: 16. <author> W. Older and A. Vellino. </author> <title> Constraint arithmetic on real intervals. In Constraint Logic Programming: </title> <editor> Selected Research (eds. Benhamou and Colmerauer). </editor> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The indexical scheme can be readily extended, with for example conditional ranges [21,6], with "foreach" constructs as in our design, or with arbitrary functions written in C [9]. A generalization of indexicals to m-constraints encoding path-consistency methods was proposed in [8]. Reification CLP (BNR) <ref> [16] </ref> was the first system to allow propositional combinations of arithmetic constraints by means of reification. This is now allowed by many systems including ours [21,12,22,17]. Other systems provide blocking implication [10,25] or cardinality [25]. Only research prototypes have no reification support.
Reference: 17. <author> PrologIA. </author> <title> Le manuel de Prolog IV. Reference manual, </title> <address> PrologIA S.A., </address> <year> 1997. </year>
Reference: 18. <author> J.-F. Puget and M. Leconte. </author> <title> Beyond the glass box: Constraints as objects. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proceedings of the International Logic Programming Symposium (ILPS-95), </booktitle> <pages> pages 513-527, </pages> <address> Portland, </address> <year> 1995. </year>
Reference: 19. <author> J.-C. Regin. </author> <title> A filtering algorithm for constraints of difference in CSPs. </title> <booktitle> In Proc. of the Twelfth National Conference on Artificial Intelligence (AAAI-94), </booktitle> <pages> pages 362-367, </pages> <year> 1994. </year>
Reference-contexts: We have implemented a weak version simulating pairwise inequalities as well as a strong version based on Regin's algorithm <ref> [19] </ref>. element (I; L; Y ), constraining the I:th element of L to be equal to Y , uses a consistency algorithm based on AC-4. cumulative (S; D; R; L), modelling a set of tasks with start times S, durations D, and resource need R, sharing a resource with capacity L <p> If the same constraint is expressed as a single, global constraint, we get much better (O (N )) space complexity, much smaller scheduler overhead, and the opportunity to employ a specialized, complete filtering algorithm <ref> [19] </ref> instead of merely mimicking the pairwise disequations. The need for specialized algorithms is most obvious on hard combinatorial problems [1,3,18], while the space complexity aspects can dominate on large instances of otherwise easy problems. Consequently, solvers based solely on indexicals can hardly be competitive on these classes of problems.
Reference: 20. <author> Vijay A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: Thus constraints can be combined using propositional connectives to model car-dinality and disjunction simply by flattening to systems of reified constraints and arithmetic constraints over their 0/1-variables. Reification subsumes several frequently used operations such as blocking implication <ref> [20] </ref> and the cardinality operator [23]. These 0/1-variables may be used in other constraints, thus complex constraints can often be decomposed into a system of many reified, simple constraints. A crucial operation in reification is entailment detection.
Reference: 21. <author> Gregory Sidebottom. </author> <title> A Language for Optimizing Constraint Propagation. </title> <type> PhD thesis, </type> <institution> Simon Fraser University, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: The basic idea is to express C as n indexicals, one for each X i , encoding a local consistency method for solving C. Each indexical is a projection of C onto X i ; hence, indexicals are also known as projection constraints <ref> [21] </ref>, and have been used in several implementations [9,21,6]. Ranges are defined using a "constraint programming assembly language", which gives the programmer precise control over the level of consis-tency, and can yield more efficient solutions than relying on the solver's built-in constraints. <p> There are well-known techniques in OR for reifying linear arithmetic constraints [27]. Sidebottom showed how reification can be encoded into indexicals using the conditional range operator <ref> [21] </ref>. Finally, reification can be expressed by a global constraint. We measured the performance of these four schemes on the simple example x; y 2 1::10; x y , b.
Reference: 22. <author> Gert Smolka. </author> <title> The Oz programming model. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Computer Science Today, volume 1000 of Lecture Notes in Computer Science, </booktitle> <pages> pages 324-343. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The performance comparison has been limited to the above systems since these are the Prolog based systems that were available to us, but could easily be extended. Furthermore, SICStus and Oz <ref> [22] </ref> have almost identical performance on the alpha, eq10 and eq20 benchmarks [28]. <p> ECL i PS e [12] uses attributed variables as a generic constraint interface. By accessing these attributed variables and calling internal coroutining primitives, user-defined constraints can be programmed. Oz <ref> [22] </ref>, Ilog Solver [14] and CHIP [10] provide programming interfaces in terms of C++ classes. CHIP also provides declarations that allow the user to use arbitrary Prolog code as constraints; we provide the same ability via a simple API.
Reference: 23. <author> Pascal Van Hentenryck and Yves Deville. </author> <title> The cardinality operator: a new logical connective in constraint logic programming. </title> <booktitle> In International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Thus constraints can be combined using propositional connectives to model car-dinality and disjunction simply by flattening to systems of reified constraints and arithmetic constraints over their 0/1-variables. Reification subsumes several frequently used operations such as blocking implication [20] and the cardinality operator <ref> [23] </ref>. These 0/1-variables may be used in other constraints, thus complex constraints can often be decomposed into a system of many reified, simple constraints. A crucial operation in reification is entailment detection.
Reference: 24. <author> Pascal Van Hentenryck, Vijay Saraswat, and Yves Deville. </author> <title> Constraint processing in cc(FD). </title> <type> Draft, </type> <institution> Computer Science Department, Brown University, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction We describe the design and implementation of the SICStus Prolog [11] finite domain constraint solver. The solver is essentially a scheduler for two entities: indexicals <ref> [24] </ref>, i.e. reactive functional rules performing incremental constraint solving or entailment checking within the framework of the Waltz filtering algorithm [26], and global constraints, i.e. general propagators which may use specialized constraint solving algorithms. <p> Constraints can be arbitrarily combined using the propositional connectives by automatic expansion to systems of reified constraints. Our work has the following contributions. It is the first full implementation of an idea <ref> [24] </ref> to use indexicals to specify the four aspects of a reified constraint, viz. solving the constraint or its negation, and detecting entailment or disentailment of the constraint. It is a loosely coupled integration of indexicals into the Prolog abstract machine, with truly minimal extensions on the Prolog side. <p> This is now allowed by many systems including ours [21,12,22,17]. Other systems provide blocking implication [10,25] or cardinality [25]. Only research prototypes have no reification support. We have provided a full implementation of an idea <ref> [24] </ref> to use indexicals to specify the four aspects of a reified constraint, viz. solving the constraint or its negation, and detecting entailment or disentailment of the constraint. Global constraints It is well known that local constraint propagation, even with reification, can be too weak.
Reference: 25. <author> Pascal Van Hentenryck, Vijay Saraswat, and Yves Deville. </author> <title> Design, implementation and evaluation of the constraint language cc(FD). </title> <editor> In A. Podelski, editor, </editor> <title> Constraints: Basics and Trends, </title> <booktitle> volume 910 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: A store S 0 is an extension of a store S iff 8X : [X] S 0 [X] S . The following definitions, adapted from <ref> [25] </ref>, define important notions of consistency and entailment of constraints wrt. stores. Let [[X]] S denote the interval min ([X] S ):: max ([X] S ): A constraint C is domain-consistent wrt. <p> Reification CLP (BNR) [16] was the first system to allow propositional combinations of arithmetic constraints by means of reification. This is now allowed by many systems including ours [21,12,22,17]. Other systems provide blocking implication [10,25] or cardinality <ref> [25] </ref>. Only research prototypes have no reification support. We have provided a full implementation of an idea [24] to use indexicals to specify the four aspects of a reified constraint, viz. solving the constraint or its negation, and detecting entailment or disentailment of the constraint.
Reference: 26. <author> D. Waltz. </author> <title> The Psychology of Computer Vision (Ed. </title> <editor> P. Winston), </editor> <title> chapter Understanding line drawings of scenes with shadows. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: 1 Introduction We describe the design and implementation of the SICStus Prolog [11] finite domain constraint solver. The solver is essentially a scheduler for two entities: indexicals [24], i.e. reactive functional rules performing incremental constraint solving or entailment checking within the framework of the Waltz filtering algorithm <ref> [26] </ref>, and global constraints, i.e. general propagators which may use specialized constraint solving algorithms. <p> Hence, x 2 r S is added to S, and we say that x is pruned. 3 The Constraint Solver 3.1 Design The solver is essentially a scheduler for two entities: indexicals performing constraint solving within the framework of the Waltz filtering algorithm <ref> [26] </ref>, and global constraints, i.e. general propagators which may use specialized consistency algorithms. At the heart of the solver is an evaluator for indexicals, i.e. an efficient implementation of the decision table shown in Tab. 1.
Reference: 27. <author> H.P. Williams. </author> <title> Model Building in Mathematical Programming. </title> <editor> J. </editor> <publisher> Wiley and sons, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: There are well-known techniques in OR for reifying linear arithmetic constraints <ref> [27] </ref>. Sidebottom showed how reification can be encoded into indexicals using the conditional range operator [21]. Finally, reification can be expressed by a global constraint. We measured the performance of these four schemes on the simple example x; y 2 1::10; x y , b.
Reference: 28. <author> Jorg Wurtz, </author> <year> 1997. </year> <type> Personal Communication. </type>
Reference-contexts: The performance comparison has been limited to the above systems since these are the Prolog based systems that were available to us, but could easily be extended. Furthermore, SICStus and Oz [22] have almost identical performance on the alpha, eq10 and eq20 benchmarks <ref> [28] </ref>. Of the eight programs, the last two, Magic 20 (magic series of length 20) and Squares 21 (packing 21 squares into a large square) need reification, which is not supported in clp (F D), B-Prolog and only partly supported in CHIP.
Reference: 29. <author> Neng-Fa Zhou. </author> <title> B-Prolog User's Manual Version 2.1. </title> <type> Technical report, </type> <institution> Kyushu Institute of Technology, </institution> <year> 1997. </year> <note> URL: http://www.cad.mse.kyutech.ac.jp/people/zhou/bprolog.html. </note>
Reference-contexts: Thus, the collected figures represent a notion of the basic performance of a system. The systems tested besides SICStus are CHIP version 5.0.0, ECL i PS e version 3.5.2, B-Prolog version 2.1 <ref> [29] </ref> and clp (FD) version 2.21. All benchmarks have been run on (or normalized to) a SUN SPARCstation 4 with a 85MHz microSPARC CPU and the times shown are in milliseconds.
References-found: 29

