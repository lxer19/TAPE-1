URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1996/1996-50.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: -saraiva,kuiper,swierstra-@cs.ruu.nl  
Phone: phone: +31 30 2536761  
Title: Effective Function Cache Management for Incremental Attribute Evaluation  
Author: Joo Saraiva Matthijs Kuiper and Doaitse Swierstra 
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands  
Affiliation: Department of Computer Science, University of Utrecht  
Abstract: This paper presents an eective strategy for function cache management in the context of incremental attribute evaluation. The evaluators we study consist of pure functions which are memoized to achieve incremental evaluation. To prevent unbounded growth of the function cache a strategy for managing this cache is needed. Our strategy only keeps in the cache the functions used in the reevaluation of the current input. This strategy has the following properties: it eciently handles Higher-order Attribute Grammars, it works well when a sequence of moditcations on the input exhibits some locality of work and measurements show that for sequences of typical tree transformations the evaluator consumes only a fraction of memory with our strategy than with a complete memoization, and is even slightly faster. 
Abstract-found: 1
Intro-found: 1
Reference: [AM91] <editor> H. Alblas and B. Melichar, editors. </editor> <booktitle> International Summer School on Attribute Grammars, Applications and Systems, volume 545 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Section 4 presents an eective cache management strategy. In section 5 results of our strategy are presented. Section 6 briey compares our strategy with other approaches. Section 7 presents the conclusions. 2 Incremental Attribute Evaluation Higher-order attribute grammars (HAG) [VSK89] extend the classical attribute grammar formalism <ref> [AM91, Paa95] </ref>. In a HAG an attribute itself can have attributes (which can have attributes, etc.). Such an attribute is called an attributable attribute (an ata). Traditional attribute evaluators have problems with the incremental evaluation of ata's.
Reference: [Kas91] <author> Uwe Kastens. </author> <title> Attribute grammars as a specitcation method. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <booktitle> International Summer School on Attribute Grammars, Applications and Systems, volume 545 of LNCS, </booktitle> <pages> pages 1647. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: This motivates the development of incremental versions of such tools, i.e., tools which can eciently recompute the result of a function when the input has changed only slightly. Attribute grammars are a suitable formalism for specifying such tools <ref> [Kas91] </ref>. From an attribute grammar incremental attribute evaluators can be automatically derived which evaluate any particular input [RTD83, Pen94]. Incremental attribute evaluation is particularly suited to implement language-based editors where the performance of the evaluator is primordial, since the feedback it provides may guide the user through the editing process.
Reference: [Paa95] <author> Jukka Paakki. </author> <title> Attribute grammar paradigms a high-level methodology in language implementation. </title> <journal> ACM Computing Surveys, </journal> <volume> 27(2):196255, </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: Section 4 presents an eective cache management strategy. In section 5 results of our strategy are presented. Section 6 briey compares our strategy with other approaches. Section 7 presents the conclusions. 2 Incremental Attribute Evaluation Higher-order attribute grammars (HAG) [VSK89] extend the classical attribute grammar formalism <ref> [AM91, Paa95] </ref>. In a HAG an attribute itself can have attributes (which can have attributes, etc.). Such an attribute is called an attributable attribute (an ata). Traditional attribute evaluators have problems with the incremental evaluation of ata's.
Reference: [Pen94] <author> Maarten Pennings. </author> <title> Generating Incremental Evaluators. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <month> Novem-ber </month> <year> 1994. </year> <month> ftp://ftp.cs.ruu.nl/pub/RUU/CS/phdtheses/Pennings/. </month>
Reference-contexts: Attribute grammars are a suitable formalism for specifying such tools [Kas91]. From an attribute grammar incremental attribute evaluators can be automatically derived which evaluate any particular input <ref> [RTD83, Pen94] </ref>. Incremental attribute evaluation is particularly suited to implement language-based editors where the performance of the evaluator is primordial, since the feedback it provides may guide the user through the editing process. The main question in the implementation of a function memoization scheme is which cache management to employ.
Reference: [PSV92] <author> Maarten Pennings, Doaitse Swierstra, and Harald Vogt. </author> <title> Using cached functions and constructors for incremental attribute evaluation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, volume 631 of LNCS, </booktitle> <pages> pages 130144. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [PT89] <author> William Pugh and Tim Teitelbaum. </author> <title> Incremental computation via function caching. </title> <booktitle> In 16th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <volume> volume 1, </volume> <pages> pages 315328. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: Both approaches have an optimal running time processing OAG's. However, they consume too much memory and become extremely complicated and far from when processing HAG's [TC90]. 9 Function Caching - Pugh <ref> [PT89] </ref> caches the semantic function calls in order to achieve incre--mentality. Our approach is more ecient since a cache hit for a visit-function call means that an entire visit to an arbitrarily large tree can be skipped.
Reference: [RTD83] <author> Thomas Reps, Tim Teitelbaum, and Alan Demers. </author> <title> Incremental context-dependent analysis for language-based editors. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3):449 477, </volume> <month> July </month> <year> 1983. </year>
Reference-contexts: Attribute grammars are a suitable formalism for specifying such tools [Kas91]. From an attribute grammar incremental attribute evaluators can be automatically derived which evaluate any particular input <ref> [RTD83, Pen94] </ref>. Incremental attribute evaluation is particularly suited to implement language-based editors where the performance of the evaluator is primordial, since the feedback it provides may guide the user through the editing process. The main question in the implementation of a function memoization scheme is which cache management to employ. <p> The latter consists of strategies that do not have any knowledge about the AG. This includes all the probabilistic cache management strategies. 2 Incremental attribute evaluation is particularly suited to implement language-based editors, i.e., for performing incremental semantic analysis of programs <ref> [RTD83] </ref>. The editor maintains the abstract syntax tree of the input and each moditcation/edit action is described as a tree transformation. <p> This improvement of the performance is due to have a smaller and consequently faster cache. 6 Brief Comparison with Other Approaches There has been a lot of research on incremental attribute evaluation, ever since Reps <ref> [RTD83] </ref> trst used attribute grammars for performing incremental semantic analysis of programs. The goals of the following approaches are very similar to ours, but they use a dierent methodology. Change Propagation Reps [RTD83] proposes a simple approach to incremental attribute evaluation which involves propagating changes through the attributed tree. <p> Comparison with Other Approaches There has been a lot of research on incremental attribute evaluation, ever since Reps <ref> [RTD83] </ref> trst used attribute grammars for performing incremental semantic analysis of programs. The goals of the following approaches are very similar to ours, but they use a dierent methodology. Change Propagation Reps [RTD83] proposes a simple approach to incremental attribute evaluation which involves propagating changes through the attributed tree. It uses a dependency graph to ensure that an attribute instance is evaluated only after all the instances it depends on have been assigned their tnal values.
Reference: [TC90] <author> Tim Teitelbaum and Richard Chapman. </author> <title> Higher-order attribute grammars and editing environments. </title> <booktitle> In ACM SIGPLAN'90 Conference on Principles of Programming Languages, </booktitle> <volume> volume 25, </volume> <pages> pages 197208. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Yeh and Kastens [YK88] propose an approach that eliminates the need of the dependency graph and that allows multiple tree transformations. Both approaches have an optimal running time processing OAG's. However, they consume too much memory and become extremely complicated and far from when processing HAG's <ref> [TC90] </ref>. 9 Function Caching - Pugh [PT89] caches the semantic function calls in order to achieve incre--mentality. Our approach is more ecient since a cache hit for a visit-function call means that an entire visit to an arbitrarily large tree can be skipped.
Reference: [VSK89] <author> Harald Vogt, Doaitse Swierstra, and Matthijs Kuiper. </author> <title> Higher order attribute grammars. </title> <booktitle> In ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <volume> volume 24, </volume> <pages> pages 131145. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Section 4 presents an eective cache management strategy. In section 5 results of our strategy are presented. Section 6 briey compares our strategy with other approaches. Section 7 presents the conclusions. 2 Incremental Attribute Evaluation Higher-order attribute grammars (HAG) <ref> [VSK89] </ref> extend the classical attribute grammar formalism [AM91, Paa95]. In a HAG an attribute itself can have attributes (which can have attributes, etc.). Such an attribute is called an attributable attribute (an ata). Traditional attribute evaluators have problems with the incremental evaluation of ata's.
Reference: [VSK91] <author> Harald Vogt, Doaitse Swierstra, and Matthijs Kuiper. </author> <title> Ecient incremental evaluation of higher order attribute grammars. </title> <editor> In J. Maluszynki and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, volume 528 of LNCS, </booktitle> <pages> pages 231242. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [YK88] <author> Dashing Yeh and Uwe Kastens. </author> <title> Improvements of an incremental evaluation algorithm for ordered attribute grammars. </title> <journal> ACM - SIGPLAN Notices, </journal> <volume> 23(12):4550, </volume> <month> December </month> <year> 1988. </year> <month> 10 </month>
Reference-contexts: It needs also to keep track of which attributes changed value. Furthermore, this approach only allows one single edit action before decoration takes place. Yeh and Kastens <ref> [YK88] </ref> propose an approach that eliminates the need of the dependency graph and that allows multiple tree transformations. Both approaches have an optimal running time processing OAG's.
References-found: 11

