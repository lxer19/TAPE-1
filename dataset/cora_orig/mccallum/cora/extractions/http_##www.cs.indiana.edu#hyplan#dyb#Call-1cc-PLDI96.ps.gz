URL: http://www.cs.indiana.edu/hyplan/dyb/Call-1cc-PLDI96.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/owaddell.html
Root-URL: http://www.cs.indiana.edu
Email: fbruggema,owaddell,dybg@cs.indiana.edu  
Title: Representing Control in the Presence of One-Shot Continuations  
Author: Carl Bruggeman Oscar Waddell R. Kent Dybvig 
Address: Lindley Hall 215 Bloomington, Indiana 47405  
Affiliation: Indiana University Computer Science Department  
Abstract: Traditional first-class continuation mechanisms allow a captured continuation to be invoked multiple times. Many continuations, however, are invoked only once. This paper introduces one-shot continuations, shows how they interact with traditional multi-shot continuations, and describes a stack-based implementation of control that handles both one-shot and multi-shot continuations. The implementation eliminates the copying overhead for one-shot continuations that is inherent in multi-shot continuations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <booktitle> In Proceedings of the Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The performance was measured on a 96MB DEC Alpha 3000/600 running OSF/1. Times are shown in milliseconds. 7 of control, in which control stacks are represented as linked lists of frames rather than as true stacks. This approach is used by Appel and MacQueen <ref> [1] </ref> in a compiler for ML [17].
Reference: [2] <author> Andrew W. Appel and Zhong Shao. </author> <title> An empirical and analytical study of stack vs. heap cost for languages with closures. </title> <type> Technical Report CS-TR-450-94, </type> <institution> Prince-ton University, </institution> <month> March </month> <year> 1994. </year> <note> Revised version to appear in Journal of Functional Programming. </note>
Reference-contexts: Times are shown in milliseconds. 7 of control, in which control stacks are represented as linked lists of frames rather than as true stacks. This approach is used by Appel and MacQueen [1] in a compiler for ML [17]. Appel and Shao <ref> [2] </ref> have compared their heap-based approach to a simulated stack-based approach and found them to have approximately the same per-frame overhead (an average of 7.5 and 7.4 instructions per frame, respectively) when potential negative cache effects associated with the heap-based approach are factored out.
Reference: [3] <author> J. Michael Ashley and R. Kent Dybvig. </author> <title> An efficient implementation of multiple return values in scheme. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 140-149, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: then use the remaining portion of the stack segment as the new current stack segment rather than allocating a fresh stack (possibly from the stack cache). 4 Performance We have added one-shot continuations to the implementation of Chez Scheme while maintaining support for call/cc, dynamic-wind [8], and multiple return values <ref> [3] </ref>. To determine the benefit of one-shot continuations for programs in which call/cc can be replaced by call/1cc, we modified the call-intensive tak program [11] so that each call captures and invokes a continuation, either with call/cc or with call/1cc.
Reference: [4] <author> Robert G. Burger, Oscar Waddell, and R. Kent Dyb-vig. </author> <title> Register allocation using lazy saves, eager restores, and greedy shu*ing. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 130-138, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Using a frame pointer instead of a stack pointer simplifies argument and local variable access and eliminates register increments and decrements used to support stack "push" and "pop" operations. 1 Our compiler actually passes the return address and the first few arguments in registers, where feasible <ref> [4] </ref>. Although this complicates the implementation only slightly, we assume a more straightforward model here to simplify our presentation. No explicit links are formed between frames on the stack.
Reference: [5] <editor> William Clinger, Jonathan A. Rees, et al. </editor> <title> The revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <type> 4(3), </type> <year> 1991. </year>
Reference-contexts: 1 Introduction Scheme <ref> [5] </ref> and some implementations of ML [17] provide continuations as first-class data objects. Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7].
Reference: [6] <author> William F. Clocksin and Christopher S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1984. </year>
Reference-contexts: One-shot continuations can be used in most contexts where multi-shot continuations are currently used, e.g., to implement non-local exits, non-blind backtracking [22], and coroutines [7]. One-shot continuations can also be used to implement thread systems in user code. One-shot continuations cannot be used to implement nondeterminism, as in Prolog <ref> [6] </ref>, in which a continuation is invoked multiple times to yield additional values [10, 14]. In these sorts of applications, multi-shot continuations must still be used. If a language supports both multi-shot and one-shot continuations, it is necessary handle cases in which programs use both varieties of continuation.
Reference: [7] <author> Christopher T. Haynes Daniel P. Friedman and Mitchell Wand. </author> <title> Obtaining coroutines with continuations. </title> <journal> Computer Languages, </journal> 11(3/4):143-153, 1986. 
Reference-contexts: 1 Introduction Scheme [5] and some implementations of ML [17] provide continuations as first-class data objects. Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines <ref> [7] </ref>. Source-level implementations of thread systems [9, 15, 21], especially in the area of graphical user interfaces (GUIs) [12, 13, 20, 23], are an important and rapidly growing application area for first-class continuations. Continuations represent the remainder of a computation from a given point in the computation. <p> One-shot continuations can be used in most contexts where multi-shot continuations are currently used, e.g., to implement non-local exits, non-blind backtracking [22], and coroutines <ref> [7] </ref>. One-shot continuations can also be used to implement thread systems in user code. One-shot continuations cannot be used to implement nondeterminism, as in Prolog [6], in which a continuation is invoked multiple times to yield additional values [10, 14].
Reference: [8] <author> R. Kent Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> second edition, </address> <year> 1996. </year>
Reference-contexts: We then use the remaining portion of the stack segment as the new current stack segment rather than allocating a fresh stack (possibly from the stack cache). 4 Performance We have added one-shot continuations to the implementation of Chez Scheme while maintaining support for call/cc, dynamic-wind <ref> [8] </ref>, and multiple return values [3]. To determine the benefit of one-shot continuations for programs in which call/cc can be replaced by call/1cc, we modified the call-intensive tak program [11] so that each call captures and invokes a continuation, either with call/cc or with call/1cc.
Reference: [9] <author> R. Kent Dybvig and Robert Hieb. </author> <title> Engines from continuations. </title> <journal> Computer Languages, </journal> <volume> 14(2) </volume> <pages> 109-123, </pages> <year> 1989. </year>
Reference-contexts: Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7]. Source-level implementations of thread systems <ref> [9, 15, 21] </ref>, especially in the area of graphical user interfaces (GUIs) [12, 13, 20, 23], are an important and rapidly growing application area for first-class continuations. Continuations represent the remainder of a computation from a given point in the computation.
Reference: [10] <author> Mathias Felleisen. </author> <title> Transliterating Prolog into Scheme. </title> <type> Technical Report 182, </type> <institution> Indiana University, </institution> <month> October </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Scheme [5] and some implementations of ML [17] provide continuations as first-class data objects. Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations <ref> [10, 14] </ref>, and coroutines [7]. Source-level implementations of thread systems [9, 15, 21], especially in the area of graphical user interfaces (GUIs) [12, 13, 20, 23], are an important and rapidly growing application area for first-class continuations. <p> One-shot continuations can also be used to implement thread systems in user code. One-shot continuations cannot be used to implement nondeterminism, as in Prolog [6], in which a continuation is invoked multiple times to yield additional values <ref> [10, 14] </ref>. In these sorts of applications, multi-shot continuations must still be used. If a language supports both multi-shot and one-shot continuations, it is necessary handle cases in which programs use both varieties of continuation.
Reference: [11] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of LISP Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: To determine the benefit of one-shot continuations for programs in which call/cc can be replaced by call/1cc, we modified the call-intensive tak program <ref> [11] </ref> so that each call captures and invokes a continuation, either with call/cc or with call/1cc. The version using call/1cc is 13% faster than the version using call/cc and allocates 23% less memory. 5 the one-shot continuation is used to update the current stack record.
Reference: [12] <author> Emden R. Gansner and John H. Reppy. </author> <title> A multi-threaded higher-order user interface toolkit. In User Interface Software. </title> <publisher> John Wiley & Sons Ltd, </publisher> <year> 1993. </year>
Reference-contexts: Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7]. Source-level implementations of thread systems [9, 15, 21], especially in the area of graphical user interfaces (GUIs) <ref> [12, 13, 20, 23] </ref>, are an important and rapidly growing application area for first-class continuations. Continuations represent the remainder of a computation from a given point in the computation. When a continuation is invoked, control returns to the point in the program at which the continuation was captured.
Reference: [13] <author> Paul Haahr. </author> <title> Montage: Breaking windowing into small pieces. </title> <booktitle> In USENIX Summer Conference, </booktitle> <pages> pages 289-297, </pages> <address> Anaheim, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7]. Source-level implementations of thread systems [9, 15, 21], especially in the area of graphical user interfaces (GUIs) <ref> [12, 13, 20, 23] </ref>, are an important and rapidly growing application area for first-class continuations. Continuations represent the remainder of a computation from a given point in the computation. When a continuation is invoked, control returns to the point in the program at which the continuation was captured.
Reference: [14] <author> Christopher T. Haynes. </author> <title> Logic continuations. </title> <booktitle> LISP Pointers, </booktitle> <pages> pages 157-176, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Scheme [5] and some implementations of ML [17] provide continuations as first-class data objects. Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations <ref> [10, 14] </ref>, and coroutines [7]. Source-level implementations of thread systems [9, 15, 21], especially in the area of graphical user interfaces (GUIs) [12, 13, 20, 23], are an important and rapidly growing application area for first-class continuations. <p> One-shot continuations can also be used to implement thread systems in user code. One-shot continuations cannot be used to implement nondeterminism, as in Prolog [6], in which a continuation is invoked multiple times to yield additional values <ref> [10, 14] </ref>. In these sorts of applications, multi-shot continuations must still be used. If a language supports both multi-shot and one-shot continuations, it is necessary handle cases in which programs use both varieties of continuation.
Reference: [15] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Abstracting timed preemption with engines. </title> <journal> Computer Languages, </journal> <volume> 12(2) </volume> <pages> 109-121, </pages> <year> 1987. </year>
Reference-contexts: Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7]. Source-level implementations of thread systems <ref> [9, 15, 21] </ref>, especially in the area of graphical user interfaces (GUIs) [12, 13, 20, 23], are an important and rapidly growing application area for first-class continuations. Continuations represent the remainder of a computation from a given point in the computation.
Reference: [16] <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 66-77, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This allows programmers to build abstractions based on one-shot continuations that can be composed with abstractions based on multi-shot continuations in a consistent manner. 3 Implementation A detailed description of our implementation of multi-shot continuations is described elsewhere <ref> [16] </ref>. In this section, we review the essential details and discuss the changes necessary to implement one-shot continuations. 3.1 Segmented stack model In our model, the control stack is represented as a linked list of stack segments. <p> If the return address is always placed in a known frame location, the frame size effectively gives the offset from the return address of the current frame to the return address of the preceding frame <ref> [16] </ref>. 3.2 Continuation operations A large initial stack segment and an associated current stack record are created in the heap at the beginning of a program run. <p> Although it would be sufficient to split off a single frame, it is more efficient to split off as much as possible without exceeding the bound because of the overhead of splitting the continuation and initiating the copy. See <ref> [16] </ref> for additional details on splitting. For one-shot continuations, there is no need to copy the saved stack segment since the continuation will be invoked only once. Thus, the current stack segment is discarded and control is simply returned to the saved stack segment. <p> Without a stack segment cache, we found that many programs written in terms of call/1cc were unacceptably slow, much slower than the equivalent programs written in terms of call/cc. Stack overflow can be treated as an implicit call/cc <ref> [16] </ref>, although since overflow occurs when the current stack segment has insufficient space, a new current segment must be allocated. <p> Promotion of a one-shot continuation is trivial given our representations of one-shot and 4 If the size of the saved stack segment is greater than the copy-bound, the segment is first split into two segments <ref> [16] </ref>. If the current stack segment is not large enough to hold the contents of the saved stack segment, a new stack segment is allocated. multi-shot continuations: promotion simply sets the size of a one-shot continuation equal to its current size.
Reference: [17] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Scheme [5] and some implementations of ML <ref> [17] </ref> provide continuations as first-class data objects. Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7]. <p> Times are shown in milliseconds. 7 of control, in which control stacks are represented as linked lists of frames rather than as true stacks. This approach is used by Appel and MacQueen [1] in a compiler for ML <ref> [17] </ref>. Appel and Shao [2] have compared their heap-based approach to a simulated stack-based approach and found them to have approximately the same per-frame overhead (an average of 7.5 and 7.4 instructions per frame, respectively) when potential negative cache effects associated with the heap-based approach are factored out.
Reference: [18] <author> Simon L. Peyton-Jones. </author> <title> private communication, </title> <booktitle> De-cember 1991. </booktitle> <pages> 8 </pages>
Reference-contexts: The overflow continuation thus includes the portion of the stack segment that is not copied. A similar mechanism is used in the spineless tagless G-machine [19] to solve essentially the same problem <ref> [18] </ref>. We found that, without the hysteresis provided by this mechanism, there was a noticeable performance degradation in certain programs.
Reference: [19] <author> Simon L. Peyton-Jones and Jon Salkild. </author> <booktitle> The spine-less tagless G-machine. In Proceedings of the Fourth Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 184-201, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: This problem can be reduced by copying up several frames on overflow from the current stack segment into the newly allocated stack segment. The overflow continuation thus includes the portion of the stack segment that is not copied. A similar mechanism is used in the spineless tagless G-machine <ref> [19] </ref> to solve essentially the same problem [18]. We found that, without the hysteresis provided by this mechanism, there was a noticeable performance degradation in certain programs. <p> In this context, the segmented stack permits the use of large numbers of threads while supporting arbitrary recursion, since it is possible to allocate threads with relatively small stacks that grow on demand. This fact was observed by Peyton-Jones and Salkild in the context of the Spineless Tagless G-machine <ref> [19] </ref>.
Reference: [20] <author> R. Pike. </author> <title> A concurrent window system. </title> <journal> Computing Systems, </journal> <volume> 2(2) </volume> <pages> 133-153, 89. </pages>
Reference-contexts: Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7]. Source-level implementations of thread systems [9, 15, 21], especially in the area of graphical user interfaces (GUIs) <ref> [12, 13, 20, 23] </ref>, are an important and rapidly growing application area for first-class continuations. Continuations represent the remainder of a computation from a given point in the computation. When a continuation is invoked, control returns to the point in the program at which the continuation was captured.
Reference: [21] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <address> Toronto, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7]. Source-level implementations of thread systems <ref> [9, 15, 21] </ref>, especially in the area of graphical user interfaces (GUIs) [12, 13, 20, 23], are an important and rapidly growing application area for first-class continuations. Continuations represent the remainder of a computation from a given point in the computation.
Reference: [22] <author> Gerald J. Sussman and Guy L. Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> AI Memo 349, </type> <institution> Massachusetts Institute of Technology Artificial Intelligence Lab, </institution> <year> 1975. </year>
Reference-contexts: 1 Introduction Scheme [5] and some implementations of ML [17] provide continuations as first-class data objects. Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking <ref> [22] </ref>, nondeterministic computations [10, 14], and coroutines [7]. Source-level implementations of thread systems [9, 15, 21], especially in the area of graphical user interfaces (GUIs) [12, 13, 20, 23], are an important and rapidly growing application area for first-class continuations. <p> One-shot continuations can be used in most contexts where multi-shot continuations are currently used, e.g., to implement non-local exits, non-blind backtracking <ref> [22] </ref>, and coroutines [7]. One-shot continuations can also be used to implement thread systems in user code. One-shot continuations cannot be used to implement nondeterminism, as in Prolog [6], in which a continuation is invoked multiple times to yield additional values [10, 14].
Reference: [23] <author> Oscar Waddell. </author> <title> The Scheme Widget Library User's Manual. </title> <institution> Indiana University, Bloomington, Indiana, </institution> <year> 1995. </year>
Reference-contexts: Continuations can be used to implement, at the source level, a number of interesting control features, such as loops, nonlocal exits, nonblind backtracking [22], nondeterministic computations [10, 14], and coroutines [7]. Source-level implementations of thread systems [9, 15, 21], especially in the area of graphical user interfaces (GUIs) <ref> [12, 13, 20, 23] </ref>, are an important and rapidly growing application area for first-class continuations. Continuations represent the remainder of a computation from a given point in the computation. When a continuation is invoked, control returns to the point in the program at which the continuation was captured.
References-found: 23

