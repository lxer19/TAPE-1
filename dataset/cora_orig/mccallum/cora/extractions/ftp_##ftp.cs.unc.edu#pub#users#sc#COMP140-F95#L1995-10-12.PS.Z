URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP140-F95/L1995-10-12.PS.Z
Refering-URL: http://www.cs.unc.edu/~sc/teaching/COMP140-F1995/lectures.html
Root-URL: http://www.cs.unc.edu
Title: COMP 140: Introduction to Translator Systems Run-Time Environments (Lecture 2 of 2) 1 Runtime memory
Author: Siddhartha Chatterjee 
Keyword: 2 Parameter passing  
Note: 2.1  
Date: 12 October 1995  
Abstract: In a language like ANSI C or Pascal that allows dynamic memory allocation, the runtime storage must provide for activation records organized in a stack fashion as well as chunks of memory allocated at runtime using malloc() or new(). Such dynamically allocated memory usually comes from a storage pool called the heap that is separate from the stack. You should have studied memory allocation algorithms such as first-fit and best-fit in COMP 121. How should the memory available for program execution be divided up? Clearly, we need to store the program code, global data, parameters and local data, and dynamic data. A common allocation strategy is to have static memory chunks for code and global data, and to place the stack and the heap at the opposite ends of the remainder of the address space, so that they can dynamically grow towards each other. When we make a subroutine call, we need to establish a correspondence between actual parameters and formal parameters. This process is called parameter passing. These parameters (and possibly global variables) are the only means of communication between the caller routine and the called routine. There are various schemes for parameter passing, such as call by value, call by reference, call by value-result, and call by name. We will study the first two schemes in detail, as these are used most often. Other schemes should be covered in COMP 144. Call by value can be implemented as follows. Storage for a formal parameter is allocated in the activation record of the called subroutine. The calling subroutine evaluates the actual parameters and places their R-values in these storage locations. Note that this requires the calling subroutine to know the layout of the activation record of called subroutine, at least the locations of the formals in the record. Alternatively, the parameters can be passed in registers. This is the standard convention on the MIPS for the first four parameters. The distinguishing feature of call by value is that changes to the formal parameters affect only values in the activation record of the called subroutine and are not visible in the caller. In fact, one can take advantage of this and treat the formals as initialized local variables. ANSI C programmer often take advantage of this interpretation of formals. 
Abstract-found: 1
Intro-found: 1
References-found: 0

