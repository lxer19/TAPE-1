URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/hula.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/
Root-URL: 
Email: umesh@lcs.mit.edu  
Title: Hula: An Efficient Protocol for Reliable Delivery of Messages  
Author: Umesh Maheshwari 
Date: July 1997  
Affiliation: MIT Laboratory for Computer Science  
Pubnum: Technical Report MIT-LCS-TR-720  
Abstract: We present a new protocol for reliable delivery of messages over a network that might lose, duplicate, reorder, or arbitrarily delay packets. It is the first protocol that guarantees exactly-once and ordered delivery on a connection while avoiding precursory handshakes. Avoiding handshakes reduces the overhead for sending small, intermittent messages as in remote procedure calls and protocols like HTTP. Like other practical protocols, it permits discarding information for idle connections. The protocol works by combining existing handshake-based and time-based protocols. It uses loosely synchronized clocks to avoid handshakes. A handshake is executed only upon an unexpectedly long packet delay or clock skew. Thus, unexpected conditions degrade performance but do not compromise reliability. The resultant protocol has the reliability of handshake-based protocols and the efficiency of time-based protocols. 
Abstract-found: 1
Intro-found: 1
Reference: [BAD + 92] <author> M. Baker, S. Asami, E. Deprit, J. Ousterhout, and M. Seltzer. </author> <title> Non-volatile memory for fast, reliable file systems. </title> <booktitle> In Proc. Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 10-22, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: First, crashes can often be prevented using reliable hardware and software at the end hosts, but it is difficult to guarantee reliable network performance because the network is a heavily shared resource. Second, software techniques such as warm reboots [CNC + 96], or hardware techniques such as non-volatile RAM <ref> [BAD + 92] </ref> can be used to prevent loss of connection information upon crashes. If such techniques are used, protocols that fail only upon losing connection information will be highly reliable. deliver a single message.
Reference: [Bel76] <author> D. Belsnes. </author> <title> Single message communication. </title> <journal> IEEE Transactions on Communications, </journal> <volume> 24(2), </volume> <month> Feb. </month> <year> 1976. </year>
Reference-contexts: In particular, protocols that guarantee reliable delivery over unreliable networks with unbounded delays require an exchange of mutual information, called a handshake, before two processes can communicate <ref> [Tom75, Bel76] </ref>. The handshake delays communication and consumes resources. This cost is amortized over the messages sent between the communicating processes until they discard mutual information. <p> Therefore, in practice, there might be two discrepancies: False positives An Ok is returned for a message not delivered to the receiver process. False negatives An Error is returned for a message delivered to the receiver process. Usually, false negatives are considered the lesser evil <ref> [Bel76, LLSA93] </ref>. Thus, our safety and fault-tolerance requirements are as follows: * As long as there is no crash: exactly-once and ordered delivery. * Upon a crash: possible loss of messages and false neg ative acknowledgements until recovery. <p> Belsnes showed that two different four-packet protocols could be constructed with different crash semantics <ref> [Bel76] </ref>. His five-packet protocol has the desirable property that it is reliable while there is no crash and only loses messages or causes false negative acknowledgement upon a crash. Protocols that close connections after the maximum lifetime of packets might duplicate messages if packets outlive the expected maximum [FW78].
Reference: [BN84] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1), </volume> <month> Feb. </month> <year> 1984. </year>
Reference-contexts: Often, such delivery must be provided using an underlying network that may lose, duplicate, reorder, or arbitrarily delay packets; the Internet is a well-known example of such a network. Many protocols have been designed for this purpose, such as TCP [Pos81], Birrell and Nelson's RPC <ref> [BN84] </ref>, Delta-t [Wat89], and SCMP [LSW91], but they fall short of either reliability or efficiency. In particular, protocols that guarantee reliable delivery over unreliable networks with unbounded delays require an exchange of mutual information, called a handshake, before two processes can communicate [Tom75, Bel76]. <p> The cost is acceptable when sending large messages or a large number of messages, as in transferring large files or in a remote login session. However, the cost is significant when sending a few small messages at a time as in remote procedure calls <ref> [BN84] </ref> and in protocols such as HTTP used in the Web. The increasing use of these facilities makes it important to avoid initial handshakes. <p> For example, some protocols assume that no copy of a packet may be present in the network after its maximum lifetime has passed <ref> [FW78, BN84, Wat89] </ref>. If a duplicate packet survives for longer, these protocols might deliver duplicate messages. Another protocol relies on loosely-synchronized clocks at hosts and bounded packet delay so that old information can be discarded [LSW91]. If clock skews or packet delays are longer, this protocol might reject valid messages. <p> There are two kinds of such protocols. The first assumes that packets do not linger in the network for longer than some maximum lifetime and discards connection information after this period <ref> [BN84, Wat89] </ref>. However, if duplicate messages linger in the network for longer, this protocol might accept them. The second kind of time-based protocol assumes that hosts have loosely synchronized clocks and that packets are delivered within some period [LSW91]. We describe this protocol below because our protocol uses it. <p> max (r.i, max closed), r.state := CLOSED r.state = SYNC * ! sync [r.i, r.j] valid [r.i, r.j] ! Receive (r.buf), r.state := ACK yclose [r.i] ! r.state := CLOSED 4.2 Remote Procedure Calls As mentioned, an important use of reliable delivery is in executing remote procedure calls, or RPCs <ref> [BN84] </ref>. An RPC, say from S to R, involves a call message from S to R and a reply message from R to S. Although, this paper does not discuss duplex transfer using Hula, an isolated RPC can be performed using three packets as shown in Figure 9. <p> As mentioned before, Hula performs an isolated RPC using three packets. Purely time-based protocols must also either employ the third packet, close, or buffer the reply message for a conservatively long interval. Therefore, most time-based protocols do use three packets <ref> [BN84, LSW91] </ref>. If a number of RPCs are executed successively, Hula as well as these protocols use only two packets for each RPC except for the last one. Hula allows a host to control the number of connections that are kept open in the LINGER state.
Reference: [CNC + 96] <author> P. M. Chen, W. T. Ng, S. Chandra, C. Aycock, G. Rajamani, and D. Lowell. </author> <title> The rio file cache: Surviving operating system crashes. </title> <booktitle> In Proc. Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: The selection is justified for the following reasons. First, crashes can often be prevented using reliable hardware and software at the end hosts, but it is difficult to guarantee reliable network performance because the network is a heavily shared resource. Second, software techniques such as warm reboots <ref> [CNC + 96] </ref>, or hardware techniques such as non-volatile RAM [BAD + 92] can be used to prevent loss of connection information upon crashes. If such techniques are used, protocols that fail only upon losing connection information will be highly reliable. deliver a single message.
Reference: [FW78] <author> J. G. Fletcher and R. W. Watson. </author> <title> Mechanisms for a reliable timer-based protocol. </title> <booktitle> In Proc. Symp. Computer Network Protocols, </booktitle> <month> Feb. </month> <year> 1978. </year>
Reference-contexts: For example, some protocols assume that no copy of a packet may be present in the network after its maximum lifetime has passed <ref> [FW78, BN84, Wat89] </ref>. If a duplicate packet survives for longer, these protocols might deliver duplicate messages. Another protocol relies on loosely-synchronized clocks at hosts and bounded packet delay so that old information can be discarded [LSW91]. If clock skews or packet delays are longer, this protocol might reject valid messages. <p> His five-packet protocol has the desirable property that it is reliable while there is no crash and only loses messages or causes false negative acknowledgement upon a crash. Protocols that close connections after the maximum lifetime of packets might duplicate messages if packets outlive the expected maximum <ref> [FW78] </ref>. The synchronized clock protocol might lose messages if packets arrive late, or seem to arrive late because of clock skews [LSW91]. Finally, Hula provides the same reliability as the best handshake protocol.
Reference: [JBB92] <author> V. Jacobson, R. Braden, and D. </author> <title> Borman. TCP extensions for high performance. </title> <booktitle> Network-Working-Group RFC 1323, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: Bel-snes added a fifth packet to the protocol to provide the crash semantics specified in Section 2, i.e., to avoid false positive acknowledgements. Figure 3 (i) shows a slightly modified version of Belsnes's protocol. TCP uses a similar protocol <ref> [Pos81, JBB92] </ref>, but it differs operationally because of duplex transfer, because TCP is meant to transfer a stream of bytes rather than messages, and because of the possibility of sequence numbers wrapping around.
Reference: [LLSA93] <author> B. Lampson, N. Lynch, and J. Sgaard-Andersen. </author> <title> Correctness of at-most once message delivery protocols. </title> <booktitle> In Proc. Conf. Formal Description Techniques, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: It is expensive to guarantee reliable delivery across host crashes, because that requires logging information on stable storage every time a message is sent or received <ref> [LLSA93] </ref>. Therefore, we weaken the reliability requirement upon crashes. When a host S crashes, the last message sent by a process on S might be lost. When host R crashes, the last messages sent to a process on Runtil R recoversmight be lost. <p> Therefore, in practice, there might be two discrepancies: False positives An Ok is returned for a message not delivered to the receiver process. False negatives An Error is returned for a message delivered to the receiver process. Usually, false negatives are considered the lesser evil <ref> [Bel76, LLSA93] </ref>. Thus, our safety and fault-tolerance requirements are as follows: * As long as there is no crash: exactly-once and ordered delivery. * Upon a crash: possible loss of messages and false neg ative acknowledgements until recovery. <p> Upon recovery from a host crash, all connections at the host are closed due to loss of information. Further, the protocol ensures that these connections will be closed at peer hosts and that negative acknowledgements are sent as needed. For a formal proof of correctness of this protocol, see <ref> [LLSA93] </ref>. 4 3.3 Time-based Protocols Time-based protocols allow hosts to discard connection information based on assumptions about the underlying network. There are two kinds of such protocols. <p> Below we indicate some important directions for future work on Hula. First, while we have provided informal arguments for the correctness of our protocol, it needs to be proven more formally. (The five-packet handshake protocol and the synchronized clock protocol have been proven to satisfy their specifications <ref> [LLSA93] </ref>.) Second, Hula needs to be extended to incorporate common features of transport protocols such as full-duplex transfer and fragmentation of messages. Finally, a simulation or a real implementation is necessary to measure performance gains from using this protocol. Acknowledgement The author is grateful to Butler Lampson for encouraging discussions.
Reference: [LSW91] <author> B. Liskov, L. Shrira, and J. Wroclawski. </author> <title> Efficient at-most-once messages based on synchronized clocks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 125-142, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Many protocols have been designed for this purpose, such as TCP [Pos81], Birrell and Nelson's RPC [BN84], Delta-t [Wat89], and SCMP <ref> [LSW91] </ref>, but they fall short of either reliability or efficiency. In particular, protocols that guarantee reliable delivery over unreliable networks with unbounded delays require an exchange of mutual information, called a handshake, before two processes can communicate [Tom75, Bel76]. The handshake delays communication and consumes resources. <p> If a duplicate packet survives for longer, these protocols might deliver duplicate messages. Another protocol relies on loosely-synchronized clocks at hosts and bounded packet delay so that old information can be discarded <ref> [LSW91] </ref>. If clock skews or packet delays are longer, this protocol might reject valid messages. Thus, existing time-based protocols do not guarantee reliable delivery in a network where packet delays or clock skews may vary unexpectedly. <p> However, if duplicate messages linger in the network for longer, this protocol might accept them. The second kind of time-based protocol assumes that hosts have loosely synchronized clocks and that packets are delivered within some period <ref> [LSW91] </ref>. We describe this protocol below because our protocol uses it. The synchronized-clock protocol is illustrated in Figure 4. S stamps the message packets with its clock. <p> Protocols that close connections after the maximum lifetime of packets might duplicate messages if packets outlive the expected maximum [FW78]. The synchronized clock protocol might lose messages if packets arrive late, or seem to arrive late because of clock skews <ref> [LSW91] </ref>. Finally, Hula provides the same reliability as the best handshake protocol. <p> As mentioned before, Hula performs an isolated RPC using three packets. Purely time-based protocols must also either employ the third packet, close, or buffer the reply message for a conservatively long interval. Therefore, most time-based protocols do use three packets <ref> [BN84, LSW91] </ref>. If a number of RPCs are executed successively, Hula as well as these protocols use only two packets for each RPC except for the last one. Hula allows a host to control the number of connections that are kept open in the LINGER state.
Reference: [Mil88] <author> D. L. Mills. </author> <title> Network time protocol (version 1) specification and implementation. Internet RFC 1059, </title> <month> July </month> <year> 1988. </year>
Reference-contexts: We also assume that a crashed host eventually recovers. Sites are equipped with clocks that are loosely synchronized. Low overhead protocols such as the Network Time Protocol are already in use for synchronizing clocks within 100 milliseconds <ref> [Mil88] </ref>. The clock survives host crashes. It is fast enough that it ticks at least once between successive messages sent. For current systems, a 1 s tick would suffice.
Reference: [Pos81] <author> J. Postel. </author> <title> Transmission control protocol. Internet RFC 793, </title> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: Often, such delivery must be provided using an underlying network that may lose, duplicate, reorder, or arbitrarily delay packets; the Internet is a well-known example of such a network. Many protocols have been designed for this purpose, such as TCP <ref> [Pos81] </ref>, Birrell and Nelson's RPC [BN84], Delta-t [Wat89], and SCMP [LSW91], but they fall short of either reliability or efficiency. In particular, protocols that guarantee reliable delivery over unreliable networks with unbounded delays require an exchange of mutual information, called a handshake, before two processes can communicate [Tom75, Bel76]. <p> Bel-snes added a fifth packet to the protocol to provide the crash semantics specified in Section 2, i.e., to avoid false positive acknowledgements. Figure 3 (i) shows a slightly modified version of Belsnes's protocol. TCP uses a similar protocol <ref> [Pos81, JBB92] </ref>, but it differs operationally because of duplex transfer, because TCP is meant to transfer a stream of bytes rather than messages, and because of the possibility of sequence numbers wrapping around.
Reference: [Ste76] <author> N. V. Stenning. </author> <title> A data transfer protocol. </title> <journal> Computer Networks, </journal> <volume> 1(2) </volume> <pages> 99-110, </pages> <month> Sept. </month> <year> 1976. </year>
Reference-contexts: If a packet arrives for which there is no matching input, it is ignored. 3 Background This section describes existing protocols for reliable delivery since our protocol is based on them. 3.1 Stenning's Protocol Stenning's protocol is the simple basis for reliable delivery <ref> [Ste76] </ref>. S stamps each message sent on a connection sequentially, while R accepts a message only if it has the expected stamp. S sends a message repeatedly until it receives an acknowledgement with the same stamp from R. two states: STAY and MSG.
Reference: [Tom75] <author> R. S. Tomlinson. </author> <title> Selecting sequence numbers. </title> <journal> ACM SIGCOM/SIGOPS Interprocess Communications Workshop, </journal> <volume> 9(3) </volume> <pages> 11-23, </pages> <month> July </month> <year> 1975. </year>
Reference-contexts: In particular, protocols that guarantee reliable delivery over unreliable networks with unbounded delays require an exchange of mutual information, called a handshake, before two processes can communicate <ref> [Tom75, Bel76] </ref>. The handshake delays communication and consumes resources. This cost is amortized over the messages sent between the communicating processes until they discard mutual information. <p> Also, it does not handle host crashes. 3.2 Handshake-based Protocols Handshake-based protocols allow hosts to close a connection and re-open it by sending extra packets to re-initialize mutual information. The most common handshake protocol is the one by Tomlinson <ref> [Tom75] </ref>. This protocol sends four packets when a connection is opened to send a single message. Bel-snes added a fifth packet to the protocol to provide the crash semantics specified in Section 2, i.e., to avoid false positive acknowledgements. Figure 3 (i) shows a slightly modified version of Belsnes's protocol.
Reference: [Wat89] <author> R. W. Watson. </author> <title> The delta-t transport protocol: Features and experience. </title> <booktitle> In Proc. 14th Conf. Local Computer Networks, </booktitle> <pages> pages 399-407. </pages> <publisher> IEEE, </publisher> <month> Oct. </month> <year> 1989. </year> <month> 9 </month>
Reference-contexts: Often, such delivery must be provided using an underlying network that may lose, duplicate, reorder, or arbitrarily delay packets; the Internet is a well-known example of such a network. Many protocols have been designed for this purpose, such as TCP [Pos81], Birrell and Nelson's RPC [BN84], Delta-t <ref> [Wat89] </ref>, and SCMP [LSW91], but they fall short of either reliability or efficiency. In particular, protocols that guarantee reliable delivery over unreliable networks with unbounded delays require an exchange of mutual information, called a handshake, before two processes can communicate [Tom75, Bel76]. The handshake delays communication and consumes resources. <p> For example, some protocols assume that no copy of a packet may be present in the network after its maximum lifetime has passed <ref> [FW78, BN84, Wat89] </ref>. If a duplicate packet survives for longer, these protocols might deliver duplicate messages. Another protocol relies on loosely-synchronized clocks at hosts and bounded packet delay so that old information can be discarded [LSW91]. If clock skews or packet delays are longer, this protocol might reject valid messages. <p> There are two kinds of such protocols. The first assumes that packets do not linger in the network for longer than some maximum lifetime and discards connection information after this period <ref> [BN84, Wat89] </ref>. However, if duplicate messages linger in the network for longer, this protocol might accept them. The second kind of time-based protocol assumes that hosts have loosely synchronized clocks and that packets are delivered within some period [LSW91]. We describe this protocol below because our protocol uses it.
References-found: 13

