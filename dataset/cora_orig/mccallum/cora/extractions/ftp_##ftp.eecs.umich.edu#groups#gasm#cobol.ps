URL: ftp://ftp.eecs.umich.edu/groups/gasm/cobol.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Title: The Evolving Algebra Semantics of COBOL Part 1: Programs and Control  
Author: Marc Vale 
Date: 26 April 1993  
Abstract-found: 0
Intro-found: 1
Reference: [ANSI] <author> American National Standards Institute, </author> <title> "American National Standard for Information Systems Programming Language COBOL", </title> <booktitle> 1985, </booktitle> <address> New York, NY, </address> <publisher> ANSI X3.23-1985, </publisher> <pages> ISO 1989-1985 </pages>
Reference-contexts: Descriptions of the language are taken from <ref> [ANSI] </ref>, [IBM] and [PK]. This paper is modeled after a preliminary version of [GH]. 1.2 Required Knowledge A basic familiarity with evolving algebras such as that provided by [Gu3] is assumed. A brief description is provided in an appendix for those who need it. This paper is somewhat less formal. <p> In its long history the language has been covered by many standards. The standard for use within this paper is documented in <ref> [ANSI] </ref> and is commonly referred to as COBOL-85. Due to the latitude allowed to the implementor by the standards, there are many dialects, and minor details may differ between implementations of the language. <p> Due to the latitude allowed to the implementor by the standards, there are many dialects, and minor details may differ between implementations of the language. This report was prepared as directed study for the Master of Science in Computer Science and Engineering. 2 <ref> [ANSI] </ref> separates the standard into various modules and for some modules, specifies low and high levels of implementation. This report will discuss the Nucleus, Sequential I-O, Relative I-O, Indexed I-O, Inter-Program Communication, and Sort-Merge modules and usually at level 2. <p> It is also true of section names in the DATA DIVISION. 3 The syntax of COBOL is usually presented through syntax diagrams rather than context-free grammars. We will use these diagrams to illustrate each construct. We follow the conventions of <ref> [ANSI] </ref>: reserved words are written in upper case, if the word is required it is underlined (Many reserved words are optional); items which the programmer supplies are written in lower case; optional items are enclosed in square brackets; mutually exclusive choices are enclosed in braces, and potential repetition of a construct <p> An example follows: ADD -identifier-1 | literal-1 ... TO -identifier-2 [ROUNDED]- ... [ON SIZE ERROR imperativestatement-1] [NOT ON SIZE ERROR imperativestatement-2] [END-ADD] Sometimes it will be necessary to use more than one syntax diagram to illustrate the full range of variations of a construct. We follow the conventions of <ref> [ANSI] </ref> in referring to these as formats of the construct in question. 1.5 Acknowledgments Professor Yuri Gurevich directed our research. He and Jim Huggins authored [GH] which inspired most of the algebras of the paper. <p> He and Jim Huggins authored [GH] which inspired most of the algebras of the paper. We gratefully acknowledge comments by Raghu Mani. 2 Algebra Zero: The Algebra of Programs Our initial algebra deals with programs and the passage of control among them. In <ref> [ANSI] </ref> the element which is executed is referred to as the run unit. We will be studying such a run unit. A run unit may consist of one or more COBOL programs. <p> We will further constrain NextTask as we proceed. 3.2 Statement Classification A COBOL statement is recognized by its first word which is commonly referred to as the verb. Statements are frequently called sentences and parts thereof are called clauses or phrases. In <ref> [ANSI] </ref> and [IBM], statements are divided into four categories: imperative, conditional, delimited scope, and compiler directing. We will not discuss compiler directing statements; some of them are concerned with source or listing management, and the rest implement little-used features which we will not have time to explain. <p> We now make TestValue an internal, dynamic function. We will also follow the usual practice of describing an expression by a parse tree, although this is more consistent with the use of context-free grammars than the syntax diagrams of <ref> [ANSI] </ref>. 5.1 Basic functions for computations. We borrow from [GH] the following functions: A static partial function Parent: tasks tasks to locate the closest enclosing expression for a given expression. For expressions not contained in other expressions, Parent returns the test task which uses the result of the expression.
Reference: [Bl] <author> George Robert Blakley, </author> <title> "Building Interpreters Using Algebraic Operational Semantics", </title> <type> Ph.D. Thesis, </type> <institution> The University of Michigan, </institution> <year> 1992. </year>
Reference-contexts: is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam [GMs], Prolog [Bo1, Bo2, Bo3, BR1, BR2], Prolog III [BS], Smalltalk <ref> [Bl] </ref>, and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK].
Reference: [Bo1] <author> Egon Brger, </author> <title> "A Logical Operational Semantics for Full Prolog. Part I: </title> <booktitle> Selection Core and Control" in Proc. of CSL'89, 3rd Workshop on Computer Science Login (eds. </booktitle> <editor> E. Brger, H Kleine Bning and M Richter), </editor> <publisher> Springer LNCS 440 (1990), </publisher> <pages> 36-64. </pages>
Reference-contexts: Having several such algebras is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam [GMs], Prolog <ref> [Bo1, Bo2, Bo3, BR1, BR2] </ref>, Prolog III [BS], Smalltalk [Bl], and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK].
Reference: [Bo2] <author> Egon Brger, </author> <title> "A Logical Operational Semantics for Full Prolog. Part II: Built-in Predicates for Database Manipulations", </title> <booktitle> in Proc. of Mathematical Foundations of Computer Science 1990 (ed. </booktitle> <editor> B. Rovan), </editor> <publisher> Springer LCNS 452, </publisher> <pages> 1-14. </pages>
Reference-contexts: Having several such algebras is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam [GMs], Prolog <ref> [Bo1, Bo2, Bo3, BR1, BR2] </ref>, Prolog III [BS], Smalltalk [Bl], and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK].
Reference: [Bo3] <author> Egon Brger, </author> <title> "A Logical Operational Semantics for Full Prolog. Part III: Builtin Predicates for Files, Terms, Arithmetic and Input-Output", </title> <type> IWBS Report no. 117, </type> <institution> IBM Germany, Institut Fr Wissensbasierte Systeme, </institution> <month> April </month> <year> 1990, </year> <booktitle> pp25; to appear in Proc. of Workshop on Logic from Computer Science (Berkeley, 1989), MSRI Proceedings Series, </booktitle> <editor> ed. Y. Moschovakis, </editor> <publisher> Springer Verlag. </publisher>
Reference-contexts: Having several such algebras is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam [GMs], Prolog <ref> [Bo1, Bo2, Bo3, BR1, BR2] </ref>, Prolog III [BS], Smalltalk [Bl], and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK].
Reference: [BR1] <author> Egon Brger and Dean Rosenzweig, </author> <title> "A Formal Analysis of Prolog Database Views and their Uniform Implementation", </title> <institution> University of Michigan Technical Report CSE-TR-89-91, </institution> <year> 1991. </year>
Reference-contexts: Having several such algebras is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam [GMs], Prolog <ref> [Bo1, Bo2, Bo3, BR1, BR2] </ref>, Prolog III [BS], Smalltalk [Bl], and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK].
Reference: [BR2] <author> Egon Brger and Dean Rosenzweig, </author> <title> "A Formal Specification of Prolog by Tree Algebras", </title> <booktitle> Proceedings of ITI, </booktitle> <address> Cavtat, </address> <year> 1991. </year>
Reference-contexts: Having several such algebras is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam [GMs], Prolog <ref> [Bo1, Bo2, Bo3, BR1, BR2] </ref>, Prolog III [BS], Smalltalk [Bl], and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK].
Reference: [BS] <author> Egon Brger and Peter Schmitt, </author> <title> "A Formal Operational Semantics for Languages of Type Prolog III", </title> <booktitle> in Proc. of CSL'90, 4th Workshop on Computer Science Logic (eds. </booktitle> <editor> E. Brger, H. Kliene Bnning and M. Richter), </editor> <publisher> Springer LNCS, </publisher> <year> 1991. </year>
Reference-contexts: such algebras is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam [GMs], Prolog [Bo1, Bo2, Bo3, BR1, BR2], Prolog III <ref> [BS] </ref>, Smalltalk [Bl], and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK].
Reference: [Gu1] <author> Yuri Gurevich, </author> <booktitle> "Logic and the Challenge of Computer Science", in Current Trends in Theoretical Computer Science (ed. </booktitle> <editor> E. Brger), </editor> <publisher> Computer Science Press, </publisher> <year> 1987, </year> <month> 1057. </month>
Reference-contexts: 1 Introduction 1.1 Overview of the Method. The following is from an earlier version of [GH]. "Evolving algebras were first proposed in <ref> [Gu1] </ref> (and more recently discussed in [Gu3]) as an improvement upon (a stronger version of) Turing's thesis. One may use an evolving algebra to model any computation.
Reference: [Gu2] <author> Yuri Gurevich, </author> <title> "Algorithms in the World of Bounded Resources", in "The Universal Turing Machine: </title> <editor> A Half-Century Story" (ed. R. Herken), </editor> <publisher> Oxford University Press, </publisher> <year> 1988, </year> <pages> 407-416. </pages>
Reference-contexts: In order to maintain the focus on semantics, we assume our algebra will evolve without regard to resource bounds. Resource management may be added to an evolving algebra without undue difficulty; see <ref> [Gu2] </ref> for further information and [Mor] for an example of resource management in an evolving algebra. 1.4 Abstraction Levels In our report we will present a series of evolving algebras which model fragments of the COBOL programming language. Each algebra will be presented as a refinement of the previous algebra.
Reference: [Gu3] <author> Yuri Gurevich, </author> <title> "Evolving Algebras: An introductory Tutorial", </title> <journal> Bulletin of European Association for Theoretical Computer Science, </journal> <month> February </month> <year> 1991. </year>
Reference-contexts: 1 Introduction 1.1 Overview of the Method. The following is from an earlier version of [GH]. "Evolving algebras were first proposed in [Gu1] (and more recently discussed in <ref> [Gu3] </ref>) as an improvement upon (a stronger version of) Turing's thesis. One may use an evolving algebra to model any computation. <p> Descriptions of the language are taken from [ANSI], [IBM] and [PK]. This paper is modeled after a preliminary version of [GH]. 1.2 Required Knowledge A basic familiarity with evolving algebras such as that provided by <ref> [Gu3] </ref> is assumed. A brief description is provided in an appendix for those who need it. This paper is somewhat less formal.
Reference: [Gu4] <author> Yuri Gurevich and James Morris, </author> <title> "Algebraic Operational Semantics and Modula 2", </title> <booktitle> Lecture Notes in Computer Science, Proceedings of Logik und Informatik (Karlsruhe, </booktitle> <publisher> October 1987) Springer-Verlag, </publisher> <address> Berlin. </address>
Reference: [GH] <author> Yuri Gurevich and James K. Huggins, </author> <title> "The Semantics of the C Programming Language" </title>
Reference-contexts: 1 Introduction 1.1 Overview of the Method. The following is from an earlier version of <ref> [GH] </ref>. "Evolving algebras were first proposed in [Gu1] (and more recently discussed in [Gu3]) as an improvement upon (a stronger version of) Turing's thesis. One may use an evolving algebra to model any computation. <p> one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam [GMs], Prolog [Bo1, Bo2, Bo3, BR1, BR2], Prolog III [BS], Smalltalk [Bl], and C <ref> [GH] </ref>." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK]. This paper is modeled after a preliminary version of [GH]. 1.2 Required Knowledge A basic familiarity with evolving algebras such as that provided by [Gu3] is assumed. <p> Modula-2 [Mor], Oc-cam [GMs], Prolog [Bo1, Bo2, Bo3, BR1, BR2], Prolog III [BS], Smalltalk [Bl], and C <ref> [GH] </ref>." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK]. This paper is modeled after a preliminary version of [GH]. 1.2 Required Knowledge A basic familiarity with evolving algebras such as that provided by [Gu3] is assumed. A brief description is provided in an appendix for those who need it. This paper is somewhat less formal. <p> It will not cover the Source Text Manipulation, Report Writer, Communication, Debug, or Segmentation modules. 1.3 Separation of Concerns Because we are concerned with programming language semantics rather than syntax, we follow <ref> [GH] </ref> and assume that all syntactic information regarding a given program is available to us at the beginning of the computation through static functions of the algebra which contain that information. <p> We follow the conventions of [ANSI] in referring to these as formats of the construct in question. 1.5 Acknowledgments Professor Yuri Gurevich directed our research. He and Jim Huggins authored <ref> [GH] </ref> which inspired most of the algebras of the paper. We gratefully acknowledge comments by Raghu Mani. 2 Algebra Zero: The Algebra of Programs Our initial algebra deals with programs and the passage of control among them. <p> Each call lengthens a chain through that graph and each return shortens it. The prohibition in the standard requires that each program have only one parent active in the chain. 2.1 Initial Universes and Functions. We take from <ref> [GH] </ref> a substantial number of universes and functions. We display those of a general use before exploring an algebra in detail. 2.1.1 Run Unit Representation and Execution We borrow from [GH] a universe tasks of elements representing tasks which the interpreters of the various algebras must accomplish. <p> We take from <ref> [GH] </ref> a substantial number of universes and functions. We display those of a general use before exploring an algebra in detail. 2.1.1 Run Unit Representation and Execution We borrow from [GH] a universe tasks of elements representing tasks which the interpreters of the various algebras must accomplish. The concept is a general one. A task may represent execution of a program, execution of a statement within a program, initialization of a variable, or evaluation of an expression. <p> The concept is a general one. A task may represent execution of a program, execution of a statement within a program, initialization of a variable, or evaluation of an expression. It is frequently necessary to indicate the nature of a task. We borrow the universe tags from <ref> [GH] </ref> for this purpose. 4 Following [GH], we define a dynamic zero-ary function (hereafter distinguished element) Cur--Task: tasks (that is, a function with null domain and range tasks) which indicates the current task being executed. We borrow from [GH] the static function TaskType: tasks tags which indicates the action to be <p> A task may represent execution of a program, execution of a statement within a program, initialization of a variable, or evaluation of an expression. It is frequently necessary to indicate the nature of a task. We borrow the universe tags from <ref> [GH] </ref> for this purpose. 4 Following [GH], we define a dynamic zero-ary function (hereafter distinguished element) Cur--Task: tasks (that is, a function with null domain and range tasks) which indicates the current task being executed. We borrow from [GH] the static function TaskType: tasks tags which indicates the action to be performed by the task. <p> We borrow the universe tags from <ref> [GH] </ref> for this purpose. 4 Following [GH], we define a dynamic zero-ary function (hereafter distinguished element) Cur--Task: tasks (that is, a function with null domain and range tasks) which indicates the current task being executed. We borrow from [GH] the static function TaskType: tasks tags which indicates the action to be performed by the task. We will describe the range of the TaskType function, and hence the contents of tags, as we proceed. We will often refer to the result of TaskType as the type of a task. <p> We will often refer to the result of TaskType as the type of a task. It is necessary to indicate the order in which tasks are executed. The static function NextTask: tasks tasks taken from <ref> [GH] </ref> serves this purpose. For this algebra, NextTask is an external function with its value determined by an oracle outside the algebra. We represent programs by a task of type program. <p> We represent programs by a task of type program. We will introduce tasks to represent the COBOL constructs involved as needed. 2.2 Abbreviation: Moveto We find it convenient to borrow some useful abbreviation from <ref> [GH] </ref>. This one, Moveto (Task), accomplishes transfer of control to a particular task by modifying the CurTask distinguished element appropriately. Its definition is: CurTask := Task 2.3 Interprogram Communication The format of the PROGRAM-ID paragraph is: PROGRAM-ID. program-name [IS -COMMON | INITIAL PROGRAM]. <p> The initial value of EndTask for this task is ^ 3 Algebra One: The Algebra of Control. This algebra is concerned solely with the PROCEDURE DIVISION. 3.1Initial Universes and Functions. For this algebra, we add more universes and functions from <ref> [GH] </ref>. 3.1.1 Program Values One of those is the universe results which is the universe of values which may appear as the "result" of a computation. <p> programs written to prior standards which did not possess explicit scope delimiters. (Recall that in the absence of scope de-limiters the scope of a conditional continues to the next period.) We will represent an IF statement by the graph shown in Figure 1 using a diagram and the conventions of <ref> [GH] </ref>, where the ovals represent tasks, the arcs represent unary functions, and the boxes represent subgraphs. <p> An unALTERed GO will always transfer control to procedure-name-1, so the NextTask function is all we need. We represent this unconditional transfer of control with the jump task taken from <ref> [GH] </ref> which has the following transition rule: if TaskType (CurTask) = jump then Moveto (NextTask (CurTask)) endif To support the altered GO TO we define two new task types, go and alter. <p> This algebra is concerned primarily with the DATA DIVISION. 4.1 Declarations Following <ref> [GH] </ref>, we represent declarations as elements of the tasks universe, linked by the Next-Task function. 23 The semantics of declarations differ with the section in which they occur. <p> Yet another function usage: task internals is required to describe further details of how the data will be represented in memory. 5 The Algebra of Expressions Following the example of <ref> [GH] </ref>, we replace each occurrence of a task of type expression and many of those of type imperativestatement with a collection of tasks reflecting the structure of the expression. We now make TestValue an internal, dynamic function. <p> We now make TestValue an internal, dynamic function. We will also follow the usual practice of describing an expression by a parse tree, although this is more consistent with the use of context-free grammars than the syntax diagrams of [ANSI]. 5.1 Basic functions for computations. We borrow from <ref> [GH] </ref> the following functions: A static partial function Parent: tasks tasks to locate the closest enclosing expression for a given expression. For expressions not contained in other expressions, Parent returns the test task which uses the result of the expression. <p> ConstValue: tasks results indicates the values of program constants. 25 5.2 The ReportValue macro We assign the result of evaluating an expression to the appropriate storage function of the parent expression with the ReportValue (value) macro abbreviation from <ref> [GH] </ref>.
Reference: [GMs] <author> Yuri Gurevich and Larry Moss, </author> <title> "Algebraic Operational Semantics and Occam", </title> <publisher> Springer LNCS 440, </publisher> <pages> 176-192 </pages>
Reference-contexts: Having several such algebras is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 [Mor], Oc-cam <ref> [GMs] </ref>, Prolog [Bo1, Bo2, Bo3, BR1, BR2], Prolog III [BS], Smalltalk [Bl], and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK].
Reference: [IBM] <author> International Business Machines, </author> <title> "VS COBOL II Application Programming: Language Reference", </title> <booktitle> GC26-4047-6, International Business Machines, Seventh edition, 1990, </booktitle> <address> San Jose, Ca. </address> <month> 27 </month>
Reference-contexts: Descriptions of the language are taken from [ANSI], <ref> [IBM] </ref> and [PK]. This paper is modeled after a preliminary version of [GH]. 1.2 Required Knowledge A basic familiarity with evolving algebras such as that provided by [Gu3] is assumed. A brief description is provided in an appendix for those who need it. This paper is somewhat less formal. <p> We will further constrain NextTask as we proceed. 3.2 Statement Classification A COBOL statement is recognized by its first word which is commonly referred to as the verb. Statements are frequently called sentences and parts thereof are called clauses or phrases. In [ANSI] and <ref> [IBM] </ref>, statements are divided into four categories: imperative, conditional, delimited scope, and compiler directing. We will not discuss compiler directing statements; some of them are concerned with source or listing management, and the rest implement little-used features which we will not have time to explain. <p> [WITH TEST -BEFORE | AFTER] VARYING -identifier-1 |index-name-1 FROM -literal-1 | identifier-2 | index-name-2 BY -literal-2 | identifier-3 UNTIL condition-1 [AFTER -identifier-4 | index-name-3 FROM -literal-3 | identifier-5 | index-name-4 BY -literal-4 | identifier-6 UNTIL condition-2] ... imperativestatement END-PERFORM (The AFTER phrase is not allowed with the inline PERFORM in <ref> [IBM] </ref>) The behavior is as follows: First the variables in the VARYING and AFTER clauses are initialized to the values spe cified by the corresponding FROM clauses. Then, unless TEST AFTER has been specified, all the conditions are tested. <p> The out-of-line PERFORM may be combined with the full set of iterative options. The result is the same as enclosing the simple PERFORM within the iterative form (although the full range of VARYING with AFTER is allowed only with this form in <ref> [IBM] </ref>). Because the format varies slightly, we present only the syntax diagrams here.
Reference: [Mor] <author> James Morris, </author> <title> "Algebraic Operational Semantics for Modula2", </title> <type> Ph.D. thesis, </type> <institution> The University of Michigan, </institution> <year> 1988. </year>
Reference-contexts: Having several such algebras is useful, for one can examine the semantics of a particular feature of a programming language at any desired level of abstraction, with unnecessary details omitted. "Evolving algebras have been used to provide operational semantics for Modula-2 <ref> [Mor] </ref>, Oc-cam [GMs], Prolog [Bo1, Bo2, Bo3, BR1, BR2], Prolog III [BS], Smalltalk [Bl], and C [GH]." This technical report describes a universal machine for the COBOL programming language. Descriptions of the language are taken from [ANSI], [IBM] and [PK]. <p> In order to maintain the focus on semantics, we assume our algebra will evolve without regard to resource bounds. Resource management may be added to an evolving algebra without undue difficulty; see [Gu2] for further information and <ref> [Mor] </ref> for an example of resource management in an evolving algebra. 1.4 Abstraction Levels In our report we will present a series of evolving algebras which model fragments of the COBOL programming language. Each algebra will be presented as a refinement of the previous algebra.

References-found: 16

