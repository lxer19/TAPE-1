URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-92-4-3.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-92-4-3.html
Root-URL: http://www.cs.man.ac.uk
Author: John Sargeant 
Note: UFO United Functions and Objects Draft Language Description  
Address: Manchester M13 9PL, England  
Affiliation: Department of Computer Science University of Manchester  
Pubnum: Technical Report Series UMCS-92-4-3  
Abstract-found: 0
Intro-found: 1
Reference: <institution> Two questions raised by the introduction of state are as follows: </institution>
Reference: 1. <editor> What does value definition, </editor> <title> A = B, or assignment, A := B, mean when A and B are stateful? Is B copied, or does A merely become another reference to it? (Of course in the functional case, we don't care, but now we certainly do.) </title>
Reference-contexts: And yet the problem of programmability of parallel machines is acute, especially as the scale of machines increases rapidly. The Japanese EM5 machine, for example <ref> [1] </ref> will have 16000 processors. Attempts at implicit parallelism have been made via strict, lenient, and lazy functional languages, logic languages, and parallel object-oriented languages such as ABCL [8], POOL [9] and actor languages [10]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices <ref> [1] </ref>, vertices [2]); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides.
Reference: 2. <editor> Do we have a notion of explicit pointers, </editor> <title> i.e. where something of type pointer-to-x is different from something of type x? The proposed answers are the same as in Eiffel, </title> <publisher> namely: </publisher>
Reference-contexts: Of these, strict functional languages (SFLs) are the simplest, and therefore the easiest to implement efficiently. A notable success is SISAL <ref> [2] </ref>, which for some numeric applications runs as fast as Fortran on Crays. Efficient SISAL implementations also exist on shared memory multiprocessors, and a distributed memory implementation is in progress [13]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real = topr.y - botl.y hside: Real <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = <ref> [2, 3 | 42 ] </ref> % A 2D array of one element d = [2, 3 | 1 to 10 ] % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = [2, 3 | 42 ] % A 2D array of one element d = <ref> [2, 3 | 1 to 10 ] </ref> % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for <p> Viz. a # b The dimensionalities of the arrays a and b must match, and the bounds of b must be included within those of a, otherwise an error is generated. For example a # <ref> [2, 2 | 5] </ref> produces a 2-D Array [Int] with bounds and elements the same as those of a, (which must also be a 2-D Array [Int]), except in position [2,2], where 5 is used. [0..10, 0..10 | all 0 ] # [1..9, 1..9 | all 1 ] produces a 2D
Reference: 1. <author> Value definition, </author> <title> A = B, or assignment, A := B, of non-scalar values copy references only. 20 The one bit which can't is that it might have been nondeterministic; this is discussed later 21 In fact, the weak sequencing rules described later mean that deadlock is harder to generate than the above would suggest. UFO does not require the implementation to detect deadlock, although some such mechanism would obviously be a useful optional facility. </title> <type> 34 </type>
Reference-contexts: And yet the problem of programmability of parallel machines is acute, especially as the scale of machines increases rapidly. The Japanese EM5 machine, for example <ref> [1] </ref> will have 16000 processors. Attempts at implicit parallelism have been made via strict, lenient, and lazy functional languages, logic languages, and parallel object-oriented languages such as ABCL [8], POOL [9] and actor languages [10]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices <ref> [1] </ref>, vertices [2]); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides.

Reference: 1. <institution> The queuing for access to a stateful object is FIFO. </institution>
Reference-contexts: And yet the problem of programmability of parallel machines is acute, especially as the scale of machines increases rapidly. The Japanese EM5 machine, for example <ref> [1] </ref> will have 16000 processors. Attempts at implicit parallelism have been made via strict, lenient, and lazy functional languages, logic languages, and parallel object-oriented languages such as ABCL [8], POOL [9] and actor languages [10]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices <ref> [1] </ref>, vertices [2]); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides.
Reference: 2. <institution> A method call (proc or function) on a stateful object is safe as soon as it has been queued. </institution>
Reference-contexts: Of these, strict functional languages (SFLs) are the simplest, and therefore the easiest to implement efficiently. A notable success is SISAL <ref> [2] </ref>, which for some numeric applications runs as fast as Fortran on Crays. Efficient SISAL implementations also exist on shared memory multiprocessors, and a distributed memory implementation is in progress [13]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real = topr.y - botl.y hside: Real <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = <ref> [2, 3 | 42 ] </ref> % A 2D array of one element d = [2, 3 | 1 to 10 ] % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = [2, 3 | 42 ] % A 2D array of one element d = <ref> [2, 3 | 1 to 10 ] </ref> % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for <p> Viz. a # b The dimensionalities of the arrays a and b must match, and the bounds of b must be included within those of a, otherwise an error is generated. For example a # <ref> [2, 2 | 5] </ref> produces a 2-D Array [Int] with bounds and elements the same as those of a, (which must also be a 2-D Array [Int]), except in position [2,2], where 5 is used. [0..10, 0..10 | all 0 ] # [1..9, 1..9 | all 1 ] produces a 2D
Reference: 3. <editor> In general, </editor> <title> a construct is safe as soon as all method calls it makes are safe, and all assignments to, or uses of, instance variables of the enclosing object have been completed. </title>
Reference-contexts: Some examples of arrays are as follows: a1 = [1,2,3,4,5]; % An Array [Int] a2 = [1 to 5]; % Same as a1 empty = []: Array [Int] % An empty array requires an explicit typespec. three = a1 <ref> [3] </ref>; % = 3 Arrays are the basic built-in structured data type in UFO, in much the same way as lists are in many functional languages. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices [2]); hside: Real = distance (vertices [2], vertices <ref> [3] </ref>); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real = topr.y - botl.y hside: Real = topr.x <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> E.g. b) b, c = initially x = 1 while x &lt; 5 do y = x * x z = new x return (y, z) od has the effect of setting b to [1 j 1, 4, 9, 16], and c to <ref> [1 j 2, 3, 4, 5] </ref>. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for
Reference: 4. <institution> The order of execution of statements in blocks and loop bodies is constrained only by data dependencies between the value names 23 , except that if two statements are separated by fby, </institution> <note> the second statement does not begin execution until the first is safe. </note>
Reference-contexts: Adopting lazy semantics, as in Haskell, solves some of these problems but not all, and introduces heavy performance penalties. Furthermore, the object-oriented approach to software construction has advantages over the functional approach, in terms of adaptation to change and reusability of software components (See <ref> [4] </ref> for a very clear and thorough exposition of OO design principles). For instance, the pattern matching against constructors used in many FLs directly conflicts with notions of data abstraction. We propose to retain the efficiency of strict functional programming, and introduce objects to solve the above problems. <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> E.g. b) b, c = initially x = 1 while x &lt; 5 do y = x * x z = new x return (y, z) od has the effect of setting b to <ref> [1 j 1, 4, 9, 16] </ref>, and c to [1 j 2, 3, 4, 5]. <p> E.g. b) b, c = initially x = 1 while x &lt; 5 do y = x * x z = new x return (y, z) od has the effect of setting b to [1 j 1, 4, 9, 16], and c to <ref> [1 j 2, 3, 4, 5] </ref>. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for
Reference: 5. <editor> All method calls (notionally) create separate, </editor> <title> asynchronous, </title> <booktitle> parallel processes. </booktitle>
Reference-contexts: The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> E.g. b) b, c = initially x = 1 while x &lt; 5 do y = x * x z = new x return (y, z) od has the effect of setting b to [1 j 1, 4, 9, 16], and c to <ref> [1 j 2, 3, 4, 5] </ref>. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2.

Reference: 1. <editor> Allow the programmer to decide when to write function, </editor> <title> rather than proc (apart from a few basic restrictions such as disallowing assignments within function bodies). The implementation then has to decide which ones are really functions for optimisation purposes. </title>
Reference-contexts: And yet the problem of programmability of parallel machines is acute, especially as the scale of machines increases rapidly. The Japanese EM5 machine, for example <ref> [1] </ref> will have 16000 processors. Attempts at implicit parallelism have been made via strict, lenient, and lazy functional languages, logic languages, and parallel object-oriented languages such as ABCL [8], POOL [9] and actor languages [10]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices <ref> [1] </ref>, vertices [2]); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides.
Reference: 2. <editor> Restrict `function' to mean only SISAL-like functions, </editor> <title> i.e. no state manipulations anywhere in the call graph. </title>
Reference-contexts: Of these, strict functional languages (SFLs) are the simplest, and therefore the easiest to implement efficiently. A notable success is SISAL <ref> [2] </ref>, which for some numeric applications runs as fast as Fortran on Crays. Efficient SISAL implementations also exist on shared memory multiprocessors, and a distributed memory implementation is in progress [13]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real = topr.y - botl.y hside: Real <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = <ref> [2, 3 | 42 ] </ref> % A 2D array of one element d = [2, 3 | 1 to 10 ] % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = [2, 3 | 42 ] % A 2D array of one element d = <ref> [2, 3 | 1 to 10 ] </ref> % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for <p> Viz. a # b The dimensionalities of the arrays a and b must match, and the bounds of b must be included within those of a, otherwise an error is generated. For example a # <ref> [2, 2 | 5] </ref> produces a 2-D Array [Int] with bounds and elements the same as those of a, (which must also be a 2-D Array [Int]), except in position [2,2], where 5 is used. [0..10, 0..10 | all 0 ] # [1..9, 1..9 | all 1 ] produces a 2D

Reference: 1. <author> Stick with the original R3, </author> <title> and check it statically. </title> <type> 24 </type>
Reference-contexts: And yet the problem of programmability of parallel machines is acute, especially as the scale of machines increases rapidly. The Japanese EM5 machine, for example <ref> [1] </ref> will have 16000 processors. Attempts at implicit parallelism have been made via strict, lenient, and lazy functional languages, logic languages, and parallel object-oriented languages such as ABCL [8], POOL [9] and actor languages [10]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices <ref> [1] </ref>, vertices [2]); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides.
Reference: 2. <author> Use R3', </author> <title> check as much as possible statically, but leave the ultimate responsibility with the programmer. </title>
Reference-contexts: Of these, strict functional languages (SFLs) are the simplest, and therefore the easiest to implement efficiently. A notable success is SISAL <ref> [2] </ref>, which for some numeric applications runs as fast as Fortran on Crays. Efficient SISAL implementations also exist on shared memory multiprocessors, and a distributed memory implementation is in progress [13]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real = topr.y - botl.y hside: Real <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = <ref> [2, 3 | 42 ] </ref> % A 2D array of one element d = [2, 3 | 1 to 10 ] % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = [2, 3 | 42 ] % A 2D array of one element d = <ref> [2, 3 | 1 to 10 ] </ref> % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for <p> Viz. a # b The dimensionalities of the arrays a and b must match, and the bounds of b must be included within those of a, otherwise an error is generated. For example a # <ref> [2, 2 | 5] </ref> produces a 2-D Array [Int] with bounds and elements the same as those of a, (which must also be a 2-D Array [Int]), except in position [2,2], where 5 is used. [0..10, 0..10 | all 0 ] # [1..9, 1..9 | all 1 ] produces a 2D

Reference: 1. <editor> The type and inheritance mechanisms need to be more fully defined, </editor> <booktitle> and their relationship clarified. </booktitle>
Reference-contexts: And yet the problem of programmability of parallel machines is acute, especially as the scale of machines increases rapidly. The Japanese EM5 machine, for example <ref> [1] </ref> will have 16000 processors. Attempts at implicit parallelism have been made via strict, lenient, and lazy functional languages, logic languages, and parallel object-oriented languages such as ABCL [8], POOL [9] and actor languages [10]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices <ref> [1] </ref>, vertices [2]); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides.
Reference: 2. <editor> Various standard functions applicable to all objects should be considered, e.g. </editor> <title> equality, shallow copy, deep copy. </title>
Reference-contexts: Of these, strict functional languages (SFLs) are the simplest, and therefore the easiest to implement efficiently. A notable success is SISAL <ref> [2] </ref>, which for some numeric applications runs as fast as Fortran on Crays. Efficient SISAL implementations also exist on shared memory multiprocessors, and a distributed memory implementation is in progress [13]. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices <ref> [2] </ref>); hside: Real = distance (vertices [2], vertices [3]); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real = topr.y - botl.y hside: Real <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = <ref> [2, 3 | 42 ] </ref> % A 2D array of one element d = [2, 3 | 1 to 10 ] % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> For example : a = [1..3, 1..2 | 1 to 6 ] % First row is [1,2] etc. b = [1..3, 1 | 1 to 6 ] % Same as a c = [2, 3 | 42 ] % A 2D array of one element d = <ref> [2, 3 | 1 to 10 ] </ref> % 10 elements, all in row 2. 25 3.2 Loops and Arrays Another way of producing an array value is as the result of a loop. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for <p> Viz. a # b The dimensionalities of the arrays a and b must match, and the bounds of b must be included within those of a, otherwise an error is generated. For example a # <ref> [2, 2 | 5] </ref> produces a 2-D Array [Int] with bounds and elements the same as those of a, (which must also be a 2-D Array [Int]), except in position [2,2], where 5 is used. [0..10, 0..10 | all 0 ] # [1..9, 1..9 | all 1 ] produces a 2D
Reference: 3. <editor> Full I/O facilities (functional and otherwise) need to be defined. </editor> <title> We should consider whether we want to have some notion of persistent objects. </title> <type> 47 </type>
Reference-contexts: Some examples of arrays are as follows: a1 = [1,2,3,4,5]; % An Array [Int] a2 = [1 to 5]; % Same as a1 empty = []: Array [Int] % An empty array requires an explicit typespec. three = a1 <ref> [3] </ref>; % = 3 Arrays are the basic built-in structured data type in UFO, in much the same way as lists are in many functional languages. <p> My cheap and nasty design serves the current purpose, though. 16 vside: Real = distance (vertices [1], vertices [2]); hside: Real = distance (vertices [2], vertices <ref> [3] </ref>); % Non-default constructor, for rectangle orthogonal to axes. constructor Rectangle ( botl, topr: Point ) is vertices = [Point (botl.x, botl.y), Point (botl.x, topr.y), Point (topr.x, topr.y), Point (topr.x, botl.y)] num_vertices = 4; % lengths of horizontal and vertical sides. vside: Real = topr.y - botl.y hside: Real = topr.x <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> E.g. b) b, c = initially x = 1 while x &lt; 5 do y = x * x z = new x return (y, z) od has the effect of setting b to [1 j 1, 4, 9, 16], and c to <ref> [1 j 2, 3, 4, 5] </ref>. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for
Reference: 4. <editor> Notions like what constitutes a complete program, </editor> <title> how classes map to files, and what the environment looks like need to be sorted out. </title>
Reference-contexts: Adopting lazy semantics, as in Haskell, solves some of these problems but not all, and introduces heavy performance penalties. Furthermore, the object-oriented approach to software construction has advantages over the functional approach, in terms of adaptation to change and reusability of software components (See <ref> [4] </ref> for a very clear and thorough exposition of OO design principles). For instance, the pattern matching against constructors used in many FLs directly conflicts with notions of data abstraction. We propose to retain the efficiency of strict functional programming, and introduce objects to solve the above problems. <p> The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> E.g. b) b, c = initially x = 1 while x &lt; 5 do y = x * x z = new x return (y, z) od has the effect of setting b to <ref> [1 j 1, 4, 9, 16] </ref>, and c to [1 j 2, 3, 4, 5]. <p> E.g. b) b, c = initially x = 1 while x &lt; 5 do y = x * x z = new x return (y, z) od has the effect of setting b to [1 j 1, 4, 9, 16], and c to <ref> [1 j 2, 3, 4, 5] </ref>. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2. <p> The evaluation of the loop body only occurs for values of val1 and val2 in positions within this intersection of the generators. Thus h) for i in <ref> [0 | 1, 2, 3, 4] </ref> dot k = i + j return k od produces an array [12, 23, 34]. i) When the array produced by the loop is 1-D, it is possible to use a form of loop which is a hybrid between a while loop and a for
Reference: 5. <editor> The error semantics needs to be properly defined (or thrown away!). </editor> <title> Error handling in general needs more attention. </title>
Reference-contexts: The step in the arithmetic progression may be positive or negative, and defaults to 1 if omitted. The progression will be empty if the step is 0 or has the wrong sign for progression towards the final value, e.g. a = <ref> [3 | 1, 2, 3, 4, 5] </ref> % lowerbound 3, upperbound 7 b = [3..7 | 1 to 5 ] % same as a c = [5 | 0 to 10 step 2 ] % 6 values d = [1..10 | all 0 ] % 10 zeros e = [1..10 | <p> E.g. b) b, c = initially x = 1 while x &lt; 5 do y = x * x z = new x return (y, z) od has the effect of setting b to [1 j 1, 4, 9, 16], and c to <ref> [1 j 2, 3, 4, 5] </ref>. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2.
Reference: 6. <institution> The various restrictions and semantic issues to do with stateful objects and functions need to be gone over very thoroughly. </institution>
Reference-contexts: The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2.
Reference: 7. <institution> The issue about union types and case statements has not yet been resolved. </institution>
Reference-contexts: The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2.
Reference: 8. <editor> The array features need more work, </editor> <title> and in particular the dynamic shaping of arrays needs critical assessment. </title>
Reference-contexts: The Japanese EM5 machine, for example [1] will have 16000 processors. Attempts at implicit parallelism have been made via strict, lenient, and lazy functional languages, logic languages, and parallel object-oriented languages such as ABCL <ref> [8] </ref>, POOL [9] and actor languages [10]. Of these, strict functional languages (SFLs) are the simplest, and therefore the easiest to implement efficiently. A notable success is SISAL [2], which for some numeric applications runs as fast as Fortran on Crays. <p> The body is evaluated with val1 taking each value from gen1 and, for each value of val1, val2 takes all possible values from val2. For example : for i in [1 to 4] join j in [i to 4] do k = i+j return k od produces the Array <ref> [2, 3, 4, 5, 4, 5, 6, 6, 7, 8] </ref>. Notice that val1 can be used in gen2.

References-found: 21

