URL: http://www.cs.sunysb.edu/~juliana/schedmix.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fjuliana,warreng@cs.sunysb.edu  
Title: Combining Scheduling Strategies in an SLG Evaluation Extended Abstract  
Author: Juliana Freire David S. Warren 
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Abstract: SLG has proven to be an efficient and elegant strategy to evaluate normal logic programs with respect to the well-founded semantics. Given the flexibility tabling provides in the choice of when to schedule answers, efficiency of evaluation can be further improved by choosing an appropriate scheduling strategy, that is, how and when answers are returned to consuming nodes. Several different scheduling strategies for SLG have been investigated including Local Scheduling, a strategy that avoids non-productive computation in the presence of answer subsumption. Local Scheduling can also benefit the evaluation of programs with negation, and in this paper we explore an extension of Local Scheduling that computes the well-founded model of normal programs. Even though Local Scheduling performs well in general, there are cases where it leads to unacceptable performance | the same can be said of other scheduling strategies for SLG. Since different applications have different requirements, the ability to use multiple strategies in an evaluation is likely to be beneficial. We discuss the issues involved in intermixing different strategies in an SLG evaluation and describe an implementation which provides engine-level support for a mixed-strategy evaluation at the predicate level.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> J. of Logic Programming, </journal> <volume> 10(3) </volume> <pages> 255-299, </pages> <year> 1991. </year>
Reference-contexts: The importance of providing this kind of flexibility in the evaluation has been identified in deductive databases. In bottom-up systems, the search can be controlled through the use of different rewriting techniques <ref> [1] </ref>. In Aditi [12], for instance, users may specify at the predicate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive [11]).
Reference: [2] <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> J. of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: By ensuring an SCC is completely evaluated before returning its answers, Local Scheduling is able to avoid the propagation of sub-optimal answers present in Batched Scheduling [6] for applications that benefit from answer subsumption, such as many aggregate computations [13] and program analyses <ref> [2] </ref>, and therefore its performance can be asymptotically better than that of Batched Scheduling.
Reference: [3] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A foundation for higher-order logic programming. </title> <journal> J. of Logic Programming, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: The following example illustrates the actions of Local Scheduling. Example 3.2 Consider the following program p (X) :- subsumes (min)(q,X),long computation (X). q (X) :- r (X). r (X) :- q (X). SDG where subsumes (min) is a tabled HiLog <ref> [3] </ref> predicate that performs answer subsumption and deletes non-minimal answers every time a new answer is added to the table. 3 Given the query :- p (X), the subgoal dependency graph (SDG) for this program is depicted above.
Reference: [4] <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: This section provides a brief (and informal) overview of SLG; for a more detailed discussion see <ref> [4] </ref>.
Reference: [5] <author> Lusk,E. et. al. </author> <title> The Aurora or-parallel Prolog system. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 819-830. </pages> <publisher> ICOT, </publisher> <year> 1988. </year>
Reference-contexts: The SLG-WAM achieves this by freezing the various WAM stacks at the point a new consuming node is created. In fact, the SLG-WAM keeps a linearized version of the search space in its stacks (similar to the cactus stacks of OR-parallel implementations such as Aurora <ref> [5] </ref>). Switching from one environment to another is performed by backtracking to a common ancestor, and then using a forward trail to reconstitute the environments of consuming nodes. The second change arises from the need to approximate the subgoal dependency graph (SDG), and thus provide incremental completion.
Reference: [6] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Beyond depth-first: Improving tabled logic programs through alternative scheduling strategies. </title> <journal> Journal of Functional and Logic Programming, </journal> <note> 1997. To appear. </note>
Reference-contexts: Each of these strategies has very specific characteristics. Breadth-First, for instance, performs a breadth-first (set-at-a-time) search, and in [7] we have shown this strategy is very efficient for evaluating queries which involve relations in external databases while incurring small overheads for in-memory data. In <ref> [6] </ref>, we described Local Scheduling for definite programs. <p> By ensuring an SCC is completely evaluated before returning its answers, Local Scheduling is able to avoid the propagation of sub-optimal answers present in Batched Scheduling <ref> [6] </ref> for applications that benefit from answer subsumption, such as many aggregate computations [13] and program analyses [2], and therefore its performance can be asymptotically better than that of Batched Scheduling. <p> Single Stack Scheduling schedules answers eagerly, as soon as they are created, whereas Batched Scheduling delays the return of answers | favoring the execution of Program Clause Resolution and batching the return of answers until no more program clauses are available. Different strategies have different performance behaviors. In <ref> [6] </ref> we compared implementations of Single 6 Stack Scheduling and Batched Scheduling (for definite programs), and not only Batched Schedul--ing has proven to be faster, but it also uses significantly less memory than Single Stack Scheduling for a representative set of benchmarks. 2 Other strategies are possible. <p> A more comprehensive description of Local Scheduling for definite programs as well as a thorough performance analysis is provided in <ref> [6] </ref>. Local Scheduling can also benefit the evaluation of programs with negation. As we have mentioned in Section 2, the SLG-WAM approximates the dependencies between subgoals in the completion stack. As a result, for some programs with negation, false negative loops may be created in the completion stack. <p> local return the answers to the generator-consuming of S Else backtrack to return unresolved answers; Else backtrack to previous tabled subgoal; 5 Experimental Results In this section we compare the performace of the following engines, whichdiffer only in the scheduling strategy used: 5 * XSB v. 1.7: uses Batched Scheduling <ref> [6] </ref>. * XSB-Local: uses Local Scheduling [6]. * XSB-Integ: combines Batched Scheduling and Local Scheduling at the predicate level (Sec tion 4). We consider both execution time and memory usage of SLG-WAM engines as well as the dynamic count of SLG-WAM instructions and operations. <p> generator-consuming of S Else backtrack to return unresolved answers; Else backtrack to previous tabled subgoal; 5 Experimental Results In this section we compare the performace of the following engines, whichdiffer only in the scheduling strategy used: 5 * XSB v. 1.7: uses Batched Scheduling <ref> [6] </ref>. * XSB-Local: uses Local Scheduling [6]. * XSB-Integ: combines Batched Scheduling and Local Scheduling at the predicate level (Sec tion 4). We consider both execution time and memory usage of SLG-WAM engines as well as the dynamic count of SLG-WAM instructions and operations. Benches were run on a SPARC2 with 64MB RAM under SUNOS.
Reference: [7] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 198-212, </pages> <year> 1997. </year>
Reference-contexts: Each of these strategies has very specific characteristics. Breadth-First, for instance, performs a breadth-first (set-at-a-time) search, and in <ref> [7] </ref> we have shown this strategy is very efficient for evaluating queries which involve relations in external databases while incurring small overheads for in-memory data. In [6], we described Local Scheduling for definite programs. <p> Further research is needed to assess the possibility of automatically inferring for each predicate which strategy might result in the best performance. Finally, we would like to add Breadth-First <ref> [7] </ref> as another scheduling option for the mixed-strategy evaluation.
Reference: [8] <author> J. Freire and D.S. Warren. </author> <title> Combining scheduling strategies in the slg-wam. </title> <type> Technical report, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, </institution> <year> 1997. </year>
Reference: [9] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> An abstract machine for computing the well-founded semantics. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming., </booktitle> <pages> pages 274-289, </pages> <year> 1996. </year>
Reference-contexts: For more information on these aggregate predicates, consult the XSB Manual (available at http://www.cs.sunysb.edu/ ~ sbprolog/manual/manual.html). 7 the engine explicitly builds the exact SDG of the program to rule out false negative loops <ref> [9] </ref>.
Reference: [10] <author> T. Swift and D.S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 633-654, </pages> <year> 1994. </year>
Reference-contexts: In a sense, Local Scheduling resembles the strategy proposed by Zukowski and Freitag in [14] where instead of SCCs program fragments are evaluated by different fixpoints. 2 Local Scheduling also benefits the evaluation of programs with negation: It simplifies the implementation of the well-founded semantics on top of the SLG-WAM <ref> [10] </ref> by avoiding the creation of extraneous negative dependencies; and it improves the performance of some programs (both running times and memory usage). Even though Local Scheduling can achieve good performance for some applications, for others it may add overheads and even lead to unacceptable inefficiency. <p> the answer q (a) :- r (a)j can be made unconditional (i.e., q (a) succeeds); and as a consequence the answer p (a) which is conditional on : q (a) fails (Figure 2 (d)). 2 The SLG-WAM The data structures and instruction set used by the SLG-WAM are described in <ref> [10] </ref>; here we briefly summarize aspects of the SLG-WAM needed to describe scheduling strategies. As mentioned in above, there are several types of nodes: generator, consuming, interior and answer. Interior nodes are represented in the SLG-WAM by Prolog-style (or interior) choice points.
Reference: [11] <author> J. Ullman. </author> <title> Principles of Data and Knowledge-base Systems Vol I. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: In bottom-up systems, the search can be controlled through the use of different rewriting techniques [1]. In Aditi [12], for instance, users may specify at the predicate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive <ref> [11] </ref>). Here we discuss the issues involved in providing engine support for different scheduling strategies at the predicate level as means of controlling the search in an SLG evaluation to attain the best possible performance.
Reference: [12] <author> J. Vaghani, K. Ramamohanarao, D.B. Kemp, Z. Somogyi, P.J. Stuckey, T.S. Leask, and J. Harland. </author> <title> The Aditi deductive database system. </title> <journal> The VLDB Journal, </journal> <volume> 3(2) </volume> <pages> 245-288, </pages> <year> 1994. </year> <month> 14 </month>
Reference-contexts: The importance of providing this kind of flexibility in the evaluation has been identified in deductive databases. In bottom-up systems, the search can be controlled through the use of different rewriting techniques [1]. In Aditi <ref> [12] </ref>, for instance, users may specify at the predicate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive [11]).
Reference: [13] <author> A. van Gelder. </author> <title> Foundations of Aggregation in Deductive Databases. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 13-34, </pages> <year> 1993. </year>
Reference-contexts: By ensuring an SCC is completely evaluated before returning its answers, Local Scheduling is able to avoid the propagation of sub-optimal answers present in Batched Scheduling [6] for applications that benefit from answer subsumption, such as many aggregate computations <ref> [13] </ref> and program analyses [2], and therefore its performance can be asymptotically better than that of Batched Scheduling.
Reference: [14] <author> U. Zukowski and B. Freitag. </author> <title> Adding flexibility to query evaluation for modularly stratified databases. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming., </booktitle> <pages> pages 304-318, </pages> <year> 1996. </year> <month> 15 </month>
Reference-contexts: In a sense, Local Scheduling resembles the strategy proposed by Zukowski and Freitag in <ref> [14] </ref> where instead of SCCs program fragments are evaluated by different fixpoints. 2 Local Scheduling also benefits the evaluation of programs with negation: It simplifies the implementation of the well-founded semantics on top of the SLG-WAM [10] by avoiding the creation of extraneous negative dependencies; and it improves the performance of <p> Example 2.1 Consider the following program 1 A set of mutually dependent subgoals is completely evaluated after all program clauses have been tried for all subgoals, and all answers have been returned returned to the consumers in the set. 2 As a remark, the strategy described in <ref> [14] </ref> evaluates modularly stratified programs, whereas the extension of Local Scheduling described here can handle stratified as well as non-stratified negation. 2 :- table p/2. a (1,2). a (2,3). a (1,3). p (X,Y) :- a (X,Y). and the query ?- p (1,Y), which seeks to find all nodes in the graph
References-found: 14

