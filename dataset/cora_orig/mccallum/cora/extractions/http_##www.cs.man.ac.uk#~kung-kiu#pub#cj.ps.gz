URL: http://www.cs.man.ac.uk/~kung-kiu/pub/cj.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Phone: Tel: (o) (061) 275 5716 (h) (061) 434 4904  
Title: Top-down Synthesis of Sorting Algorithms  
Author: K.K. Lau, 
Address: Oxford Road, Manchester M13 9PL  
Affiliation: Department of Computer Science, University of Manchester,  
Abstract: Traditionally sorting algorithms are classified according to their main operational characteristic, rather than their underlying logic. More recent work in program synthesis has exposed the logic of and hence the logical relationships between some sorting algorithms. Following the program synthesis approach, and by using a logic programming system for deriving recursive logic procedures from their specifications, we have synthesised a large family of sorting algorithms in a strictly top-down manner. Such an approach not only produces algorithms which are guaranteed to be partially correct, it also provides a family tree showing clearly the relationships between its members. This paper contains c.4500 words, 15 pages, and 1 diagram. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D.R. Barstow, </author> <title> Remarks on "A Synthesis of Several Sorting Algorithms" by John Darling-ton, </title> <journal> Acta Informatica 13, </journal> <month> 225-227 </month> <year> (1980). </year>
Reference-contexts: Clark & Darlington [4] have also derived quick sort , selection sort , merge sort , and insertion sort , using similar program transformation rules, but they adopt an informal (first order) predicate logic notation for programs. Green & Barstow <ref> [8, 1] </ref> have used their system for automatic program synthesis to demonstrate the synthesis of programs for the same six sorting algorithms that Darlington derived, using the divide-and-conquer paradigm.
Reference: [2] <author> D. Bitton, D.J. DeWitt, D.K. Hsiao, J.Menon, </author> <title> A Taxonomy of Parallel Sorting, </title> <journal> Computing Surveys 16(3), </journal> <month> 289-318 </month> <year> (1984). </year>
Reference-contexts: This defines the block bubble sort algorithm. Similar parallel (block) sorting algorithms <ref> [2] </ref> can be synthesised from other comparison-based list sorting algorithms. K.K. Lau, Top-down Synthesis of Sorting Algorithms 13 4 Conclusion We have demonstrated a strictly top-down synthesis of a large family of sorting algorithms. <p> Finally, as far as we know, our use of data partitioning by partial value and data structure transformation is new. However, it is obvious that many variants of these algorithms, as well as other algorithms can be added to these branches. In particular, many more block or parallel algorithms <ref> [2] </ref> can be synthesised, to develop the data structure transformation branch itself into a tree of such algorithms. Furthermore, another subclass of algorithms can be produced by transformation to other data structures such as trees (e.g. heaps). Acknowledgements I would like to thank S.D.
Reference: [3] <author> R.M. Burstall, J. Darlington, </author> <title> A Transformation System for Developing Recursive Programs, </title> <journal> Journal of the ACM 24, </journal> <month> 44-67 </month> <year> (1977). </year>
Reference-contexts: Our nomenclature shall conform to standard works such as Knuth [11] and Mehlhorn [16].) His synthesis is by program transformation on recursion equations, the key transformation rule being the fold-unfold rule of Burstall & Darlington <ref> [3] </ref> and Manna & Waldinger [15]. Clark & Darlington [4] have also derived quick sort , selection sort , merge sort , and insertion sort , using similar program transformation rules, but they adopt an informal (first order) predicate logic notation for programs.
Reference: [4] <author> K.L. Clark, J. Darlington, </author> <title> Algorithm Classification Through Synthesis, </title> <journal> The Computer Journal 23(1), </journal> <month> 61-65 </month> <year> (1980). </year> <title> K.K. Lau, Top-down Synthesis of Sorting Algorithms 14 </title>
Reference-contexts: Our nomenclature shall conform to standard works such as Knuth [11] and Mehlhorn [16].) His synthesis is by program transformation on recursion equations, the key transformation rule being the fold-unfold rule of Burstall & Darlington [3] and Manna & Waldinger [15]. Clark & Darlington <ref> [4] </ref> have also derived quick sort , selection sort , merge sort , and insertion sort , using similar program transformation rules, but they adopt an informal (first order) predicate logic notation for programs.
Reference: [5] <author> J. Darlington, </author> <title> A Synthesis of Several Sorting Algorithms, </title> <journal> Acta Informatica 11(1), </journal> <month> 1-30 </month> <year> (1978). </year>
Reference-contexts: More recently, work in program synthesis has been applied to the derivation of algorithms from their specifications. The main advantage of this approach is that correctness is usually automatically built-in. Several people have chosen sorting algorithms for such exercises using different notations and methodologies.[12] Darlington <ref> [5] </ref> has derived a family of six sorting algorithms, namely quick sort , selection sort , merge sort , insertion sort , bubble sort , and sinking sort . (Note that he actually calls bubble sort and sinking sort respectively exchange sort and bubble sort .
Reference: [6] <author> E.W. Dijkstra, </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J. </address> <year> (1976). </year>
Reference-contexts: Decomposition and composition are done according to a chosen pre-determined (abstract) program scheme. Dromey [7] uses Dijkstra's constructive weakest pre-condition technique <ref> [6] </ref> to derive sorting algorithms from a specification in the form of a pair of pre- and post-conditions. These algorithms include quick sort , selection sort , bubble sort , insertion sort , and heap sort . His approach is however not top-down. K.K.
Reference: [7] <author> R.G. Dromey, </author> <title> Derivation of Sorting Algorithms from a Specification, </title> <journal> The Computer Journal 30(6), </journal> <month> 512-518 </month> <year> (1987). </year>
Reference-contexts: Decomposition and composition are done according to a chosen pre-determined (abstract) program scheme. Dromey <ref> [7] </ref> uses Dijkstra's constructive weakest pre-condition technique [6] to derive sorting algorithms from a specification in the form of a pair of pre- and post-conditions. These algorithms include quick sort , selection sort , bubble sort , insertion sort , and heap sort . His approach is however not top-down.
Reference: [8] <author> C. Green, D. Barstow, </author> <title> On Program Synthesis Knowledge. </title> <booktitle> Artificial Intelligence 10, </booktitle> <month> 241-279 </month> <year> (1978). </year>
Reference-contexts: Clark & Darlington [4] have also derived quick sort , selection sort , merge sort , and insertion sort , using similar program transformation rules, but they adopt an informal (first order) predicate logic notation for programs. Green & Barstow <ref> [8, 1] </ref> have used their system for automatic program synthesis to demonstrate the synthesis of programs for the same six sorting algorithms that Darlington derived, using the divide-and-conquer paradigm.
Reference: [9] <author> A. Hansson, S.A. </author> <title> Tarnlund, Program Transformation by Data Structure Mapping, in K.L. </title> <editor> Clark, S.A. Tarnlund (eds.), </editor> <booktitle> Logic Programming, </booktitle> <pages> pp. 117-122. </pages> <publisher> Academic Press, </publisher> <address> London (1982). </address>
Reference: [10] <author> C.A.R. Hoare, </author> <title> Quicksort, </title> <journal> The Computer Journal 5(1), </journal> <month> 10-15 </month> <year> (1962). </year>
Reference-contexts: To complete its synthesis, it remains to synthesise a procedure for the corresponding definition of part. For example, Quicksort (the original quick sort algorithm due to Hoare <ref> [10] </ref>) uses the first element of a as the pivot. In this case, we have (writing a as h:t) sort (h:t; b^[h]^d) part (h:t; e; [h]; g) ^ sort (e; b) ^ sort (g; d) : To complete the synthesis of Quicksort, it remains to synthesise a procedure for part.
Reference: [11] <author> D.E. Knuth, </author> <title> The Art of Computer Programming vol.3: Sorting and Searching. </title> <publisher> Addison-Wesley, </publisher> <address> Reading (1973). </address>
Reference-contexts: Our nomenclature shall conform to standard works such as Knuth <ref> [11] </ref> and Mehlhorn [16].) His synthesis is by program transformation on recursion equations, the key transformation rule being the fold-unfold rule of Burstall & Darlington [3] and Manna & Waldinger [15].
Reference: [12] <author> K.K. Lau, </author> <title> A Note on Synthesis and Classification of Sorting Algorithms, </title> <journal> Acta Informatica 27, </journal> <month> 73-80 </month> <year> (1989). </year>
Reference-contexts: The use of our logic programming system for aiding the syntheses has made this possible. Indeed many more algorithms could be added to this tree with relatively little effort. The classification of algorithms which our tree represents is interesting when compared to other people's schemes <ref> [12] </ref>. For example, our synthesis of quick sort using pivot partitioning differs from Clark & Darlington's and Green & Barstow's, in that their quick sort puts the pivot itself in either partition, whereas ours does not.
Reference: [13] <author> K.K. Lau, </author> <title> S.D. Prestwich, Top-down Synthesis of Recursive Logic Procedures from First-order Logic Specifications, </title> <booktitle> in Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pp. 667-684. </pages> <publisher> MIT Press, </publisher> <address> Cambridge (1990). </address>
Reference: [14] <author> K.K. Lau, </author> <title> S.D. Prestwich, Synthesis of Logic Programs for Recursive Sorting Algorithms, </title> <type> Technical Report UMCS-88-10-1, </type> <institution> Department of Computer Science, University of Manch-ester, </institution> <month> October </month> <year> 1988. </year>
Reference: [15] <author> Z. Manna, R. Waldinger, </author> <title> Synthesis: Dreams ) Programs, </title> <journal> IEEE Transactions on Software Engineering 5(4), </journal> <month> 294-328 </month> <year> (1979). </year>
Reference-contexts: Our nomenclature shall conform to standard works such as Knuth [11] and Mehlhorn [16].) His synthesis is by program transformation on recursion equations, the key transformation rule being the fold-unfold rule of Burstall & Darlington [3] and Manna & Waldinger <ref> [15] </ref>. Clark & Darlington [4] have also derived quick sort , selection sort , merge sort , and insertion sort , using similar program transformation rules, but they adopt an informal (first order) predicate logic notation for programs.
Reference: [16] <author> K. Mehlhorn, </author> <title> Data Structures and Algorithms 1: Sorting and Searching. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin (1984). </address>
Reference-contexts: Our nomenclature shall conform to standard works such as Knuth [11] and Mehlhorn <ref> [16] </ref>.) His synthesis is by program transformation on recursion equations, the key transformation rule being the fold-unfold rule of Burstall & Darlington [3] and Manna & Waldinger [15].
Reference: [17] <author> R.S. Scowen, </author> <title> Algorithm 271: </title> <journal> Quickersort, Communications of ACM 8(11), </journal> <month> 669-670 </month> <year> (1965). </year>
Reference: [18] <author> D.R. Smith, </author> <title> Top-down Synthesis of Divide-and-Conquer Algorithms, </title> <booktitle> Artificial Intelligence 27, </booktitle> <month> 43-96 </month> <year> (1985). </year>
Reference-contexts: Green & Barstow [8, 1] have used their system for automatic program synthesis to demonstrate the synthesis of programs for the same six sorting algorithms that Darlington derived, using the divide-and-conquer paradigm. Smith <ref> [18, 19] </ref> derives merge sort , insertion sort , quick sort , and selection sort using a method for synthesising divide-and-conquer algorithms by top-down decomposition of specifications into subproblem specifications, followed by bottom-up composition of (concrete) programs synthe-sised for the subproblems.
Reference: [19] <author> D.R. Smith, </author> <title> The Design of Divide and Conquer Algorithms, </title> <booktitle> Science of Computer Programming 5, </booktitle> <month> 37-58 </month> <year> (1985). </year>
Reference-contexts: Green & Barstow [8, 1] have used their system for automatic program synthesis to demonstrate the synthesis of programs for the same six sorting algorithms that Darlington derived, using the divide-and-conquer paradigm. Smith <ref> [18, 19] </ref> derives merge sort , insertion sort , quick sort , and selection sort using a method for synthesising divide-and-conquer algorithms by top-down decomposition of specifications into subproblem specifications, followed by bottom-up composition of (concrete) programs synthe-sised for the subproblems.
Reference: [20] <author> M.H. van Emden, </author> <title> Increasing the Efficiency of Quicksort, </title> <journal> Communications of ACM 13(9), </journal> <month> 563-567 </month> <year> (1970). </year>
Reference: [21] <author> R.L. Wainwright, </author> <title> A Class of Sorting Algorithms Based on Quicksort, </title> <journal> Communications of ACM 28(4), </journal> <month> 396-402 </month> <year> (1985). </year>
References-found: 21

