URL: ftp://ftp.cs.bham.ac.uk/pub/tech-reports/1997/CSRP-97-03.ps.gz
Refering-URL: http://www.cs.bham.ac.uk/~rmp/eebic/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: fR.Poli,W.B.Langdong@cs.bham.ac.uk  
Title: A New Schema Theorem for Genetic Programming with One-point Crossover and Point Mutation  
Author: Riccardo Poli and W.B. Langdon 
Note: GAs, to which it asymptotically converges.  
Date: January 1997 (Revised August 1997)  
Address: (UK)  
Affiliation: School of Computer Science The University of Birmingham  
Pubnum: Technical Report: CSRP-97-3  
Abstract: We review the main results obtained in the theory of schemata in Genetic Programming (GP) emphasising their strengths and weaknesses. Then we propose a new, simpler definition of the concept of schema for GP which is closer to the original concept of schema in genetic algorithms (GAs). Along with a new form of crossover, one-point crossover, and point mutation this concept of schema has been used to derive an improved schema theorem for GP which describes the propagation of schemata from one generation to the next. We discuss this result and show that our schema theorem is the natural counterpart for GP of the schema theorem for 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Lee Altenberg. </author> <title> The Schema Theorem and Price's Theorem. </title> <editor> In L. Darrell Whitley and Michael D. Vose, editors, </editor> <booktitle> Foundations of Genetic Algorithms 3, </booktitle> <pages> pages 23-49, </pages> <address> Estes Park, Colorado, USA, 31 July-2 August 1994 1995. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Since John Holland's seminal work in the mid seventies and his well known schema theorem (see [5] and [4]), schemata (similarity templates representing entire groups of chromosomes) are often used to explain why GAs work (although their usefulness has been recently criticised <ref> [1] </ref>). So the obvious most natural way of creating a theory for GP has been to define a concept of schema for parse trees and to extend Holland's schema 1 theorem to GP to see how schemata would propagate generation after generation under the effects of selection, crossover and mutation.
Reference: [2] <editor> Peter J. Angeline and K. E. Kinnear, Jr., editors. </editor> <booktitle> Advances in Genetic Programming 2. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Genetic Programming (GP) has been applied successfully to a large number of difficult problems like automatic design, pattern recognition, robotic control, synthesis on neural architectures, symbolic regression, music and picture generation <ref> [2, 6, 7, 8, 9, 10] </ref>. However a relatively small number of theoretical results are available to try and explain why it works and how (see [12, pages 517-519] for a list of references).
Reference: [3] <author> Patrik D'haeseleer. </author> <title> Context preserving crossover in genetic programming. </title> <booktitle> In Proceedings of the 1994 IEEE World Congress on Computational Intelligence, </booktitle> <volume> volume 1, </volume> <pages> pages 256-261, </pages> <address> Orlando, Florida, USA, 27-29 June 1994. </address> <publisher> IEEE Press. </publisher> <pages> 23 </pages>
Reference-contexts: This means that it is possible to study in detail its effects on different kinds of schemata and to obtain a schema theorem as described in the next section. One-point crossover has some similarity to strong context preserving crossover operator <ref> [3] </ref>. However, one-point crossover constraints crossover points more tightly than strong context preserving crossover.
Reference: [4] <author> David E. Goldberg. </author> <title> Genetic Algorithms in Search, Optimization, and Machine Learning. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: However a relatively small number of theoretical results are available to try and explain why it works and how (see [12, pages 517-519] for a list of references). Since John Holland's seminal work in the mid seventies and his well known schema theorem (see [5] and <ref> [4] </ref>), schemata (similarity templates representing entire groups of chromosomes) are often used to explain why GAs work (although their usefulness has been recently criticised [1]). <p> Likewise, we explain the building block hypothesis <ref> [4, 5] </ref> by saying that GAs work by hierarchically composing relatively fit, short schemata to form complete solutions. <p> Equation 1 applies when crossover is performed taking both parents from the mating pool <ref> [4, 23] </ref>. 3 strings sampling the subspace represented by a schema. For example, if H =#10#1 the theorem could be interpreted as describing the variations of frequency of the component 10 at position 2 and 1 at position 5 within a population of bit strings. <p> one generation to the next as a result of fitness proportionate selection, one-point crossover and point mutation. 5.1 Effect of Fitness Proportionate Selection The effect of fitness proportionate selection on our schemata can be obtained by performing exactly the same calculations as for the GA schema theorem (see for example <ref> [5, 4, 23] </ref> or [22, Appendix C]).
Reference: [5] <author> John Holland. </author> <title> Adaptation in Natural and Artificial Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: However a relatively small number of theoretical results are available to try and explain why it works and how (see [12, pages 517-519] for a list of references). Since John Holland's seminal work in the mid seventies and his well known schema theorem (see <ref> [5] </ref> and [4]), schemata (similarity templates representing entire groups of chromosomes) are often used to explain why GAs work (although their usefulness has been recently criticised [1]). <p> The distance between the furthest two non-# symbols is called the defining length L (H) of the schema. Holland obtained a result (the schema theorem) which predicts how the number of strings in a population 2 matching a schema varies from one generation to the next <ref> [5] </ref>. <p> Likewise, we explain the building block hypothesis <ref> [4, 5] </ref> by saying that GAs work by hierarchically composing relatively fit, short schemata to form complete solutions. <p> one generation to the next as a result of fitness proportionate selection, one-point crossover and point mutation. 5.1 Effect of Fitness Proportionate Selection The effect of fitness proportionate selection on our schemata can be obtained by performing exactly the same calculations as for the GA schema theorem (see for example <ref> [5, 4, 23] </ref> or [22, Appendix C]).
Reference: [6] <editor> K. E. Kinnear, Jr., editor. </editor> <booktitle> Advances in Genetic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Genetic Programming (GP) has been applied successfully to a large number of difficult problems like automatic design, pattern recognition, robotic control, synthesis on neural architectures, symbolic regression, music and picture generation <ref> [2, 6, 7, 8, 9, 10] </ref>. However a relatively small number of theoretical results are available to try and explain why it works and how (see [12, pages 517-519] for a list of references).
Reference: [7] <author> John R. Koza. </author> <title> Genetic Programming: On the Programming of Computers by Natural Selection. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Genetic Programming (GP) has been applied successfully to a large number of difficult problems like automatic design, pattern recognition, robotic control, synthesis on neural architectures, symbolic regression, music and picture generation <ref> [2, 6, 7, 8, 9, 10] </ref>. However a relatively small number of theoretical results are available to try and explain why it works and how (see [12, pages 517-519] for a list of references). <p> All of them define schemata as composed of one or multiple trees or fragments of trees. In some definitions <ref> [7, 14, 15, 20, 22] </ref> schema components are non-rooted and, therefore, a schema can be present multiple times within the same program. <p> This has led some authors to concentrate their analysis on the propagation of such components in the population rather than on the way the number of programs sampling a given schema change over time. 2.3 Koza's GP schemata Given the popularity of Holland's work, Koza <ref> [7, pages 116-119] </ref> made a first attempt to explain why GP works producing an informal argument showing that Holland's schema theorem would work for GP as well. <p> Therefore, the initialisation method and parameters chosen for the creation of the initial population can modify significantly the behaviour of the algorithm. For example, if all functions in F have the same arity and one uses the "full" initialisation method <ref> [7] </ref> which produces balanced trees with a fixed depth, then the search will be limited to programs with a fixed size and shape. If on the contrary the "ramped half-and-half" initialisation method is used [7], which produces trees of variable shape and size with depths ranging from 0 to the prefixed <p> if all functions in F have the same arity and one uses the "full" initialisation method <ref> [7] </ref> which produces balanced trees with a fixed depth, then the search will be limited to programs with a fixed size and shape. If on the contrary the "ramped half-and-half" initialisation method is used [7], which produces trees of variable shape and size with depths ranging from 0 to the prefixed maximum initial tree depth D, then the entire space of programs with maximum depth D will be searched (at least if the population is big enough). 5 Thirdly, the offspring produced by one-point crossover <p> So, crossing over a program with itself produces the original program. This property is an instance of a more general property: GP schemata are closed under crossover (i.e. when 5 The "ramped half-and-half" initialisation method used in <ref> [7] </ref> enforced a minimum depth of 2. In our work we use a minimum depth of 0. 15 one-point crossover is applied to two programs sampling the same schema the offspring produced will sample the same schema, too). <p> particular we will consider the situation at the early stages and at late stages of a run. 6.1 Early stages of a GP run If we consider the typical case in which functions with different arity are present in the function set and the initialisation method is "ramped-half-and-half" or "grow" <ref> [7] </ref>, at the beginning of a run it is unlikely that two trees h and ^ h with different shapes undergoing crossover will swap a subtree with exactly the same shape.
Reference: [8] <author> John R. Koza. </author> <title> Genetic Programming II: Automatic Discovery of Reusable Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge Massachusetts, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Genetic Programming (GP) has been applied successfully to a large number of difficult problems like automatic design, pattern recognition, robotic control, synthesis on neural architectures, symbolic regression, music and picture generation <ref> [2, 6, 7, 8, 9, 10] </ref>. However a relatively small number of theoretical results are available to try and explain why it works and how (see [12, pages 517-519] for a list of references).
Reference: [9] <editor> John R. Koza, Kalyanmoy Deb, Marco Dorigo, David B. Fogel, Max Garzon, Hitoshi Iba, and Rick L. Riolo, editors. </editor> <booktitle> Genetic Programming 1997: Proceedings of the Second Annual Conference, </booktitle> <address> Stanford University, CA, USA, 13-16 July 1997. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: 1 Introduction Genetic Programming (GP) has been applied successfully to a large number of difficult problems like automatic design, pattern recognition, robotic control, synthesis on neural architectures, symbolic regression, music and picture generation <ref> [2, 6, 7, 8, 9, 10] </ref>. However a relatively small number of theoretical results are available to try and explain why it works and how (see [12, pages 517-519] for a list of references).
Reference: [10] <editor> John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors. </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction Genetic Programming (GP) has been applied successfully to a large number of difficult problems like automatic design, pattern recognition, robotic control, synthesis on neural architectures, symbolic regression, music and picture generation <ref> [2, 6, 7, 8, 9, 10] </ref>. However a relatively small number of theoretical results are available to try and explain why it works and how (see [12, pages 517-519] for a list of references).
Reference: [11] <author> W. B. Langdon and R. Poli. </author> <title> Fitness causes bloat. </title> <booktitle> In Second On-line World Conference on Soft Computing in Engineering Design and Manufacturing, </booktitle> <month> 23-27 June </month> <year> 1997. </year>
Reference-contexts: This is can be very useful to help reduce the typical undesirable growth of program size (bloating) observed in GP runs (see for example <ref> [11] </ref>), which slows down the search for solutions and, in some cases, can lead to overfitting. One-point crossover does this without the need of any extra machinery (e.g. parsimony terms in the fitness function).
Reference: [12] <author> William B. Langdon. </author> <title> A bibliography for genetic programming. </title> <editor> In Peter J. Angeline and K. E. Kinnear, Jr., editors, </editor> <booktitle> Advances in Genetic Programming 2, chapter B, </booktitle> <pages> pages 507-532. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA, </address> <year> 1996. </year>
Reference-contexts: However a relatively small number of theoretical results are available to try and explain why it works and how (see <ref> [12, pages 517-519] </ref> for a list of references).
Reference: [13] <author> Ben McKay, Mark J. Willis, and Geoffrey W. Barton. </author> <title> Using a tree structured genetic algorithm to perform symbolic regression. </title> <editor> In A. M. S. Zalzala, editor, </editor> <booktitle> First International Conference on Genetic Algorithms in Engineering Systems: Innovations and Applications, GALESIA, </booktitle> <volume> volume 414, </volume> <pages> pages 487-492, </pages> <address> Sheffield, UK, </address> <month> 12-14 September </month> <year> 1995. </year> <pages> IEE. </pages>
Reference-contexts: The obvious analogue of bit-flip mutation is the substitution of a function in the tree with another function with the same arity, or the substitution of a terminal with another terminal: a technique that has been sometimes used in the GP literature <ref> [13] </ref>. We will call this operation point mutation.
Reference: [14] <author> Una-May O'Reilly. </author> <title> An Analysis of Genetic Programming. </title> <type> PhD thesis, </type> <institution> Carleton University, Ottawa-Carleton Institute for Computer Science, </institution> <address> Ottawa, Ontario, Canada, </address> <month> 22 September </month> <year> 1995. </year>
Reference-contexts: All of them define schemata as composed of one or multiple trees or fragments of trees. In some definitions <ref> [7, 14, 15, 20, 22] </ref> schema components are non-rooted and, therefore, a schema can be present multiple times within the same program. <p> the program (+ x x). (One of the two possible instantiations of the more complex schema H=f (- 2 x), xg in the program (+ (- 2 x) x) is shown in Figure 1 (a).) 2.4 O'Reilly's GP schemata Koza's work on schemata was later formalised and refined by O'Reilly <ref> [14, 15] </ref> who derived a schema theorem for GP in the presence of fitness-proportionate selection and crossover. The theorem was based on the idea of defining a schema as an unordered collection (a multiset) of subtrees and tree fragments.
Reference: [15] <author> Una-May O'Reilly and Franz Oppacher. </author> <title> The troubling aspects of a building block hypothesis for genetic programming. </title> <editor> In L. Darrell Whitley and Michael D. Vose, editors, </editor> <booktitle> Foundations of Genetic Algorithms 3, </booktitle> <pages> pages 73-88, </pages> <address> Estes Park, Colorado, USA, 31 July-2 August 1994 1995. </address> <publisher> Morgan Kaufmann. </publisher> <pages> 24 </pages>
Reference-contexts: All of them define schemata as composed of one or multiple trees or fragments of trees. In some definitions <ref> [7, 14, 15, 20, 22] </ref> schema components are non-rooted and, therefore, a schema can be present multiple times within the same program. <p> the program (+ x x). (One of the two possible instantiations of the more complex schema H=f (- 2 x), xg in the program (+ (- 2 x) x) is shown in Figure 1 (a).) 2.4 O'Reilly's GP schemata Koza's work on schemata was later formalised and refined by O'Reilly <ref> [14, 15] </ref> who derived a schema theorem for GP in the presence of fitness-proportionate selection and crossover. The theorem was based on the idea of defining a schema as an unordered collection (a multiset) of subtrees and tree fragments. <p> In this second phase the hyperplanes within the few remaining hyperspaces start competing on the basis of their relative defining lengths as well as their fitness. In this phase GP tends to behave more and more like a standard GA. As discussed in <ref> [15] </ref>, in general no schema theorem alone can support conclusions on the correctness of the building block hypothesis.
Reference: [16] <author> Riccardo Poli and W. B. Langdon. </author> <title> An experimental analysis of schema creation, propagation and disruption in genetic programming. </title> <editor> In Eric Goodman, editor, </editor> <booktitle> Genetic Algorithms: Proceedings of the Seventh International Conference, </booktitle> <institution> Michigan State University, </institution> <address> East Lansing, MI, USA, 19-23 July 1997. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: In particular, a schema H with above average fitness 7 Some of the arguments presented in the rest of the section are the result of observing the actual behaviour of runs of GP with one-point crossover (some of which are described in [17]) and also of the experiments reported in <ref> [16] </ref> in which we have counted the schemata present in small populations and studied their creation, disruption and propagation. 21 and short defining-length (and therefore low order) with respect to its total size will tend to survive better. <p> It also suggests that the building block hypothesis, which has been strongly criticised in the context of standard GP, might in fact hold in GP with one-point crossover. Some recent experimental results have corroborated the theory presented in this paper <ref> [16] </ref>. More theoretical and experimental work will be needed to investigate the building block hypothesis. Acknowledgements The authors wish to thank Una-May O'Reilly and the members of the EEBIC (Evolutionary and Emergent Behaviour Intelligence and Computation) group for useful discussions and comments.
Reference: [17] <author> Riccardo Poli and W. B. Langdon. </author> <title> Genetic programming with one-point crossover. </title> <booktitle> In Second On-line World Conference on Soft Computing in Engineering Design and Manufacturing, </booktitle> <month> 23-27 June </month> <year> 1997. </year>
Reference-contexts: In particular, a schema H with above average fitness 7 Some of the arguments presented in the rest of the section are the result of observing the actual behaviour of runs of GP with one-point crossover (some of which are described in <ref> [17] </ref>) and also of the experiments reported in [16] in which we have counted the schemata present in small populations and studied their creation, disruption and propagation. 21 and short defining-length (and therefore low order) with respect to its total size will tend to survive better. <p> As a natural follow-up of this theoretical work we have recently started an investigation of the performance of GP with one-point crossover obtaining very promising results <ref> [17] </ref> on the even parity problems. More research will be needed to study the properties and the performance of this kind of crossover.
Reference: [18] <author> Nicholas J. Radcliffe. </author> <title> Forma analysis and random respectful recombination. </title> <booktitle> In Proceedings of the Fourth International Conference on Genetic Algorithms. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: An analysis of the theoretical results described in the paper is reported in Section 6 while Section 7 includes some final remarks and indications of future work. 2 Previous Work on Schemata for GP As highlighted in <ref> [18] </ref>, a schema is a subspace of the space of possible solutions.
Reference: [19] <author> Justinian P. Rosca. </author> <title> Analysis of complexity drift in genetic programming. </title> <editor> In John R. Koza, Kalyanmoy Deb, Marco Dorigo, David B. Fogel, Max Garzon, Hitoshi Iba, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1997: Proceedings of the Second Annual Conference, </booktitle> <pages> pages 286-294, </pages> <address> Stanford University, CA, USA, 13-16 July 1997. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: This, together with the variability of the size and shape of the programs matching the same schema, leads to some complications in the computation of the schema-disruption probabilities necessary to formulate schema theorems for GP. In a recent definition <ref> [19] </ref> schemata are represented by rooted tree fragments. This definition makes schema theorem calculations easier. We will critically review the main results obtained to date in the theory of schemata for GP in Section 2 where we will also briefly recall Holland's schema theory for binary GAs. <p> Whigham's schemata represent derivation-tree fragments which always represent single subexpressions, while O'Reilly's schemata can represent multiple subexpressions. 2.6 Rosca's GP schemata More recently Rosca <ref> [19] </ref> has proposed a new definition of schema, called rooted tree-schema, in which a schema is a rooted contiguous tree fragment. For example, the rooted tree-schema H=(+ # x) represents all the programs whose root node is a + the second argument of which is x.
Reference: [20] <author> P. A. Whigham. </author> <title> A schema theorem for context-free grammars. </title> <booktitle> In 1995 IEEE Conference on Evolutionary Computation, </booktitle> <volume> volume 1, </volume> <pages> pages 178-181, </pages> <address> Perth, Australia, </address> <month> 29 November - 1 December </month> <year> 1995. </year> <note> IEEE Press. </note>
Reference-contexts: All of them define schemata as composed of one or multiple trees or fragments of trees. In some definitions <ref> [7, 14, 15, 20, 22] </ref> schema components are non-rooted and, therefore, a schema can be present multiple times within the same program. <p> schemata In the framework of his GP system based on context free grammars (CFG-GP) Whigham produced a concept of schema for context-free grammars and the related schema theo 2 We use here the standard notation for multisets, which is slightly different from the one used in O'Reilly's work. 6 rem <ref> [20, 21, 22] </ref>. In CFG-GP programs are the result of applying a set of rewrite rules taken from a pre-defined grammar to a starting symbol S.
Reference: [21] <author> P. A. Whigham. </author> <title> Search bias, language bias, and genetic programming. </title> <editor> In John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <pages> pages 230-237, </pages> <address> Stan-ford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: schemata In the framework of his GP system based on context free grammars (CFG-GP) Whigham produced a concept of schema for context-free grammars and the related schema theo 2 We use here the standard notation for multisets, which is slightly different from the one used in O'Reilly's work. 6 rem <ref> [20, 21, 22] </ref>. In CFG-GP programs are the result of applying a set of rewrite rules taken from a pre-defined grammar to a starting symbol S.
Reference: [22] <author> Peter Alexander Whigham. </author> <title> Grammatical Bias for Evolutionary Learning. </title> <type> PhD thesis, </type> <institution> School of Computer Science, University College, University of New South Wales, Australian Defence Force Academy, </institution> <month> 14 October </month> <year> 1996. </year>
Reference-contexts: All of them define schemata as composed of one or multiple trees or fragments of trees. In some definitions <ref> [7, 14, 15, 20, 22] </ref> schema components are non-rooted and, therefore, a schema can be present multiple times within the same program. <p> schemata In the framework of his GP system based on context free grammars (CFG-GP) Whigham produced a concept of schema for context-free grammars and the related schema theo 2 We use here the standard notation for multisets, which is slightly different from the one used in O'Reilly's work. 6 rem <ref> [20, 21, 22] </ref>. In CFG-GP programs are the result of applying a set of rewrite rules taken from a pre-defined grammar to a starting symbol S. <p> By changing the grammar used in CFG-GP this theorem can be shown to be applicable both to GAs with fixed length binary strings and to standard GP, of which CFG-GP is a generalisation (see the GP grammar given in <ref> [22, page 130] </ref>). Like in O'Reilly's case, this theorem describes the way in which the components of the representation of a schema propagate from one generation to the next, rather than the way the number of programs sampling a given schema change over time. <p> next as a result of fitness proportionate selection, one-point crossover and point mutation. 5.1 Effect of Fitness Proportionate Selection The effect of fitness proportionate selection on our schemata can be obtained by performing exactly the same calculations as for the GA schema theorem (see for example [5, 4, 23] or <ref> [22, Appendix C] </ref>).
Reference: [23] <author> Darrel Whitley. </author> <title> A genetic algorithm tutorial. </title> <type> Technical Report CS-93-103, </type> <institution> Department of Computer Science, Colorado State University, </institution> <month> August </month> <year> 1993. </year> <month> 25 </month>
Reference-contexts: Equation 1 applies when crossover is performed taking both parents from the mating pool <ref> [4, 23] </ref>. 3 strings sampling the subspace represented by a schema. For example, if H =#10#1 the theorem could be interpreted as describing the variations of frequency of the component 10 at position 2 and 1 at position 5 within a population of bit strings. <p> one generation to the next as a result of fitness proportionate selection, one-point crossover and point mutation. 5.1 Effect of Fitness Proportionate Selection The effect of fitness proportionate selection on our schemata can be obtained by performing exactly the same calculations as for the GA schema theorem (see for example <ref> [5, 4, 23] </ref> or [22, Appendix C]).
References-found: 23

