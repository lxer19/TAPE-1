URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-96-24.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Data Dependent Optimizations for Permutation Volume Rendering  
Author: Craig M. Wittenbrink Kwansik Kim Alex T. Pang 
Keyword: parallel volume visualization, SIMD, algorithms, octree, ray tracing  
Note: Partially supported by a grant from ISCR-LLNL B291836 and NSF IRI-9423881, C.M.Wittenbrink is with  
Address: Santa Cruz, CA 95064 USA  Palo Alto, CA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  Hewlett-Packard Laboratories,  
Date: December 11, 1996  
Pubnum: UCSC-CRL-96-24  
Abstract: Volume rendering or volume visualization is an algorithm for creating images from three-dimensional and four-dimensional data sets, without computing intermediate surface representations. Because of the inherent O(N 3 ) run time, numerous approximations are used to provide interactivity. As compute platforms have become more capable in their operations per second, and in their memory capacities, the requirements of volume rendering become more and more advanced. The goal of application users is high fidelity renderings of medical, simulation, and remotely sensed data sets. Interactivity provides a tractable means for setting the many input parameters, but interactivity is challenging because of the run time complexity. We investigate the further optimization of massively parallel algorithm solutions, in an effort to have the efficiency of the parallel approaches reach that of sequential ones, without sacrificing fidelity. This paper discusses experiments in extending permutation warping on the MasPar MP-2 implementation to include data dependent coherency optimizations, and object space to screen space precompositing communication savings. We start with a description of the base algorithm, and then describe the extensions, showing results of nearly 400% speed improvement or a factor of 5 speedup. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Craig M. Wittenbrink and A. K. Somani. </author> <title> Permutation warping for data parallel volume rendering. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <note> 1995. submitted. </note>
Reference-contexts: On the MasPar MP-1, we have shown a speedup of 15.7 for a 16 k processor MP-1 over a 1k processor MP-1, and two frames/second with a 128 3 volume and trilinear view reconstruction. Supra linear speedups of over 20 are achieved with near neighbor filtering <ref> [1] </ref>. We have also shown that run time is constant across view angle, that the algorithm has tunable filter quality, and that one may achieve efficient memory implementation. <p> There is a place for all three of these approaches, and one may imagine that the best approach will differ depending on metric, state of the art, and price point. We have done work on general parallel machines <ref> [2, 3, 1] </ref> (MasPar, Pro-teus), and continue to research that approach. The highest performance in frames/second has been the parallelization of the shear warp approach of Lacroute [4, 5, 6, 7]. <p> In one study, we showed the utility of such a tiling scheme in working with tiles in images [13]. In another study, we showed how tiling improved the effectiveness of a massively parallel rendering algorithm <ref> [1] </ref>. To go to the next step in the development of tiling requires generalizing the tiler to work not just with common image processing operations and volume rendering, but with many classes of rendering algorithms. Another solution we developed is permutation warping for network efficiency. <p> If there is a one-to-one pairing, then the pairing is called a permutation. We showed that for spatial assignment in rendering, such a dance hall pairing can be computed, and therefore rendering requires simply a one-on-one tete-a-tete instead of a large conference <ref> [14, 1] </ref>. This holds for regular grids, and many data sets of interest are regularly gridded. We work with atmospheric circulation data, finite element trabecular bone data, and the numerous regularly gridded example data sets publicly available. <p> This holds for regular grids, and many data sets of interest are regularly gridded. We work with atmospheric circulation data, finite element trabecular bone data, and the numerous regularly gridded example data sets publicly available. Our solutions have been published <ref> [15, 13, 14, 1] </ref>, but their utility has not been widely seized upon, and collaboration with LLNL was started to port these solutions onto the world wide web for current biomedical studies [11]. <p> We describe these enhancements, and their 4 3. Methodology expected improvement for the algorithm. Our prior algorithmic studies of permutation warping have shown that it is asymptotically time and space optimal for resampling on the EREW PRAM (exclusive read exclusive write parallel random access machine) <ref> [28, 2, 3, 14, 1] </ref>. The MIMD study that we carried out showed that there was poor load balacing for certain view angles. <p> resulting image quality so comparison of computed images has been used to verify proper functioning, and identify artifacts of various schemes. 4 Implementation and Results These are the algorithm variants that we have used to evaluate coherency acceleration on the MasPar (variant 0 is the baseline algorithm as described in <ref> [1] </ref>): 1. Octree compression of sub-volume with no attempt at load balancing. 2. Octree compression with dynamic load balancing. 3. Octree compression with static load balancing. 4. Pre-compositing before communication. The performance of permutation warping can be improved by using compression techniques like octtree or run length encoding. <p> It takes about 30 to 60 seconds for reading data, building octree and load balancing depending on the number of nodes compressed. The re-sampling was done using trilinear filter. Version 0 is the baseline algorithm as described in <ref> [1] </ref>. Version 1 was run without any compression and load balancing. The run time is slightly increased because of the overhead in processing 4. Implementation and Results 7 Version Number Max. Conden- Removing Load Avg. Avg.
Reference: [2] <author> Craig M. Wittenbrink and Arun K. Somani. </author> <title> Permutation warping for data parallel volume rendering. </title> <booktitle> In Proceedings of the Parallel Rendering Symposium, </booktitle> <pages> pages 57-60, </pages> <address> color plate p. 110, San Jose, CA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: There is a place for all three of these approaches, and one may imagine that the best approach will differ depending on metric, state of the art, and price point. We have done work on general parallel machines <ref> [2, 3, 1] </ref> (MasPar, Pro-teus), and continue to research that approach. The highest performance in frames/second has been the parallelization of the shear warp approach of Lacroute [4, 5, 6, 7]. <p> A backwards viewing transform is ray tracing [21]. Nieh and Levoy [22], Yoo et al. [23], Montani et al. [24], Neu-mann [25], Goel et al. [26], and Hsu [27] have developed backwards (ray tracing) volume rendering algorithms for parallel computers. Our permutation warping <ref> [2] </ref> approach computes a backwards mapping algorithm with optimal storage and deterministic communication on shared or distributed memory machines. Figures 2.1 and 2.2 illustrate the transforms calculated by processors. The object space and screen space are separated, the object space on the left and the screen space on the right. <p> We describe these enhancements, and their 4 3. Methodology expected improvement for the algorithm. Our prior algorithmic studies of permutation warping have shown that it is asymptotically time and space optimal for resampling on the EREW PRAM (exclusive read exclusive write parallel random access machine) <ref> [28, 2, 3, 14, 1] </ref>. The MIMD study that we carried out showed that there was poor load balacing for certain view angles.
Reference: [3] <author> Craig M. Wittenbrink and Michael Harrington. </author> <title> A scalable MIMD volume rendering algorithm. </title> <booktitle> In Proceedings IEEE 8th International Parallel Processing Symposium, </booktitle> <pages> pages 916-920, </pages> <address> Cancun, Mexico, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: There is a place for all three of these approaches, and one may imagine that the best approach will differ depending on metric, state of the art, and price point. We have done work on general parallel machines <ref> [2, 3, 1] </ref> (MasPar, Pro-teus), and continue to research that approach. The highest performance in frames/second has been the parallelization of the shear warp approach of Lacroute [4, 5, 6, 7]. <p> Figure 2.1 shows the aligned subimages in two-dimensions. In Step 3, a parallel product evaluation combines resampled intensities and opacities. Binary tree combining computes products for any associative (not necessarily commutative) operator. For details of binary tree compositing, see our work <ref> [28, 3] </ref>. a permutation warping assignment. The arrow shows the data communication from object space (OS) to screen space (SS). The final 2D volume on the right shows the communicated fragments properly sorted. Several enhancements are possible for the permutation warping algorithm. <p> We describe these enhancements, and their 4 3. Methodology expected improvement for the algorithm. Our prior algorithmic studies of permutation warping have shown that it is asymptotically time and space optimal for resampling on the EREW PRAM (exclusive read exclusive write parallel random access machine) <ref> [28, 2, 3, 14, 1] </ref>. The MIMD study that we carried out showed that there was poor load balacing for certain view angles.
Reference: [4] <author> Philippe Lacroute and Marc Levoy. </author> <title> Fast volume rendering using a shear-warp factorization of the viewing transformation. </title> <booktitle> In Proceedings of SIGGRAPH 94, </booktitle> <pages> pages 451-458, </pages> <address> Orlando, FL, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: We have done work on general parallel machines [2, 3, 1] (MasPar, Pro-teus), and continue to research that approach. The highest performance in frames/second has been the parallelization of the shear warp approach of Lacroute <ref> [4, 5, 6, 7] </ref>. <p> The permutation assignment can be done from virtual processor address to virtual processor address, and the virtual assignments can be dynamically altered to load balance the processing as it occurs. The Lacroute et al. shear warp factorization algorithm, <ref> [4] </ref>, has been able to reduce the amount of work necessary in computing a volume rendered output from regular volumes by nearly an order of magnitude. Parallel versions of this program have been presented [7], and the primary speedup is through straight forward parallelization of the sequential algorithm.
Reference: [5] <author> Philippe Lacroute. </author> <title> Real-time volume rendering on shared memory multiprocessors using the shear-warp factorization. </title> <booktitle> In Proceedings of the 1995 Parallel Rendering Symposium, </booktitle> <pages> pages 15-22, </pages> <address> Atlanta, GA, </address> <month> Oct </month> <year> 1995. </year> <note> IEEE. Use for a conference paper. </note>
Reference-contexts: We have done work on general parallel machines [2, 3, 1] (MasPar, Pro-teus), and continue to research that approach. The highest performance in frames/second has been the parallelization of the shear warp approach of Lacroute <ref> [4, 5, 6, 7] </ref>.
Reference: [6] <author> Minesh B. Amin, Ananth Grama, and Vineet Singh. </author> <title> Fast volume rendering using an efficient, scalable parallel formulation of the shear-warp algorithm. </title> <booktitle> In Proceedings of the 1995 Parallel Rendering Symposium, </booktitle> <pages> pages 7-14, </pages> <address> Atlanta, GA, </address> <month> Oct </month> <year> 1995. </year> <note> IEEE. Use for a conference paper. </note>
Reference-contexts: We have done work on general parallel machines [2, 3, 1] (MasPar, Pro-teus), and continue to research that approach. The highest performance in frames/second has been the parallelization of the shear warp approach of Lacroute <ref> [4, 5, 6, 7] </ref>.
Reference: [7] <author> Jaswinder Pal Singh, Anoop Gupta, and Marc Levoy. </author> <title> Parallel visualization algorithms: Performance and architectural implications. </title> <journal> IEEE Computer, </journal> <volume> 27(7) </volume> <pages> 45-55, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: We have done work on general parallel machines [2, 3, 1] (MasPar, Pro-teus), and continue to research that approach. The highest performance in frames/second has been the parallelization of the shear warp approach of Lacroute <ref> [4, 5, 6, 7] </ref>. <p> The Lacroute et al. shear warp factorization algorithm, [4], has been able to reduce the amount of work necessary in computing a volume rendered output from regular volumes by nearly an order of magnitude. Parallel versions of this program have been presented <ref> [7] </ref>, and the primary speedup is through straight forward parallelization of the sequential algorithm. Culling of the amount of volume that needs to be considered speeds up the algorithm. But, their studies show that the possible speedup to higher numbers of processors is limited because of the decomposition.
Reference: [8] <author> Brian Cabral, Nancy Cam, and Jim Foran. </author> <title> Accelerated volume rendering and tomographic reconstruction using texture mapping hardware. </title> <booktitle> In Proceedings 1994 Symposium on Volume Visualization, </booktitle> <pages> pages 91-98, </pages> <address> Washington, D.C., </address> <month> Oct </month> <year> 1994. </year> <title> IEEE/ACM. Use for a conference paper. </title>
Reference: [9] <author> Donald Meagher. </author> <title> Fourth-generation computer graphics hardware using octrees. </title> <booktitle> In NCGA, </booktitle> <pages> pages 316-325, </pages> <address> Chicago, IL, </address> <month> Apr </month> <year> 1991. </year> <institution> Nat. Comput. Graphics Assoc. </institution> <note> Use for a conference paper. </note>
Reference-contexts: Volume rendering algorithms on special purpose graphics hardware include Cabral et al. [8]'s use of the SGI Reality Engine's Texture mapping hardware, SGI Infinite Reality Engine MIP Mapping hardware for 3D texture mapping, and special purpose volume rendering hardware includes Meagher's Octree Corporation volume rendering accelerator <ref> [9] </ref> and Pfister and Kaufman et al.'s Cube architecture [10]. In the pursuit of the highest performance solutions there are several challenges: achieve the highest performance, achieve the highest efficiency, create new capabilities, and create new applications.
Reference: [10] <author> H. Pfister and Arie Kaufman. </author> <title> Real-time architecture for high resolution volume visualization. </title> <booktitle> In Proceedings of 8th Eurographics Workshop on Graphics Hardware Proceedings, </booktitle> <pages> pages 72-80, </pages> <address> Barcelona, Spain, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: purpose graphics hardware include Cabral et al. [8]'s use of the SGI Reality Engine's Texture mapping hardware, SGI Infinite Reality Engine MIP Mapping hardware for 3D texture mapping, and special purpose volume rendering hardware includes Meagher's Octree Corporation volume rendering accelerator [9] and Pfister and Kaufman et al.'s Cube architecture <ref> [10] </ref>. In the pursuit of the highest performance solutions there are several challenges: achieve the highest performance, achieve the highest efficiency, create new capabilities, and create new applications. Imagine even without any innovation in algorithms, the highest performance will double every 18 months given the advancements in commodity computer hardware.
Reference: [11] <author> Craig M. Wittenbrink, Kwansik Kim, Jeremy Story, Alex T. Pang, Karin Hollerbach, and Nelson Max. </author> <title> A system for remote parallel and distributed volume visualization. </title> <booktitle> In accepted to the IS&T/SPIE Symposium on Electronic Imaging: Science and Technology, </booktitle> <address> San Jose, CA, </address> <month> January </month> <year> 1997. </year> <note> SPIE. References 11 </note>
Reference-contexts: Development at the University of California, Santa Cruz uses the MasPar MP-2 4096 node machine, the Silicon Graphics Reality Engine 2 with 4 processors, and several Silicon Graphics Indigo-2 Extremes. We have also developed remote frame viewing solutions, in order to effectively use the remote MPP's <ref> [11] </ref>. We developed several solutions to various aspects of the rendering problem. Our solutions can be divided into primarily two areas, memory access efficiency, and network efficiency. <p> Our solutions have been published [15, 13, 14, 1], but their utility has not been widely seized upon, and collaboration with LLNL was started to port these solutions onto the world wide web for current biomedical studies <ref> [11] </ref>. It was hoped the use of the developed volume rendering tools would help to prove or disprove their efficiency. By generalizing tiling and permutation warping to more classes of rendering and showing implementations on more machines, it becomes more important to a wider audience of people.
Reference: [12] <author> Jay Torborg and James T. Kajiya. Talisman: </author> <title> Commodity realtime 3d graphics for the pc. </title> <booktitle> In Proceedings of SIGGRAPH, </booktitle> <pages> pages 353-363, </pages> <address> New Orleans, LA, </address> <month> August </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: We invented a cache architecture scheme, a storing of a subset of data for immediate access, which uses tiling to achieve efficiency with little hardware. Tiling is also called blocking, chuncking, and mosaicing-a recent example of such subdivision is in the Microsoft Talisman architecture <ref> [12] </ref>. In one study, we showed the utility of such a tiling scheme in working with tiles in images [13]. In another study, we showed how tiling improved the effectiveness of a massively parallel rendering algorithm [1].
Reference: [13] <author> Craig M. Wittenbrink and A. K. Somani. </author> <title> Cache tiling for high performance morphological image processing. </title> <journal> Machine Vision and Applications, </journal> <volume> 7(1) </volume> <pages> 12-22, </pages> <month> Winter </month> <year> 1993. </year>
Reference-contexts: Tiling is also called blocking, chuncking, and mosaicing-a recent example of such subdivision is in the Microsoft Talisman architecture [12]. In one study, we showed the utility of such a tiling scheme in working with tiles in images <ref> [13] </ref>. In another study, we showed how tiling improved the effectiveness of a massively parallel rendering algorithm [1]. <p> This holds for regular grids, and many data sets of interest are regularly gridded. We work with atmospheric circulation data, finite element trabecular bone data, and the numerous regularly gridded example data sets publicly available. Our solutions have been published <ref> [15, 13, 14, 1] </ref>, but their utility has not been widely seized upon, and collaboration with LLNL was started to port these solutions onto the world wide web for current biomedical studies [11]. <p> The final output is a two dimensional array of pixel values. For a more in depth discussion of volume rendering see Collected papers in Kaufman [20], Blinn [16], Kajiya and von Herzen [17], Levoy [18, 19], and our survey <ref> [13] </ref>. The array of output pixel intensities can be calculated many different ways indicated by the numerous input variables: volume data, light sources, view transform, classification function, and shading function. An illustrative categorization of possible algorithms is by viewing transform.
Reference: [14] <author> Craig M. Wittenbrink and A. K. Somani. </author> <title> 2D and 3D optimal parallel image warping. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 25(2) </volume> <pages> 197-208, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: If there is a one-to-one pairing, then the pairing is called a permutation. We showed that for spatial assignment in rendering, such a dance hall pairing can be computed, and therefore rendering requires simply a one-on-one tete-a-tete instead of a large conference <ref> [14, 1] </ref>. This holds for regular grids, and many data sets of interest are regularly gridded. We work with atmospheric circulation data, finite element trabecular bone data, and the numerous regularly gridded example data sets publicly available. <p> This holds for regular grids, and many data sets of interest are regularly gridded. We work with atmospheric circulation data, finite element trabecular bone data, and the numerous regularly gridded example data sets publicly available. Our solutions have been published <ref> [15, 13, 14, 1] </ref>, but their utility has not been widely seized upon, and collaboration with LLNL was started to port these solutions onto the world wide web for current biomedical studies [11]. <p> We describe these enhancements, and their 4 3. Methodology expected improvement for the algorithm. Our prior algorithmic studies of permutation warping have shown that it is asymptotically time and space optimal for resampling on the EREW PRAM (exclusive read exclusive write parallel random access machine) <ref> [28, 2, 3, 14, 1] </ref>. The MIMD study that we carried out showed that there was poor load balacing for certain view angles.
Reference: [15] <author> Robert M. Haralick, Arun K. Somani, Craig M. Wittenbrink, et al. Proteus: </author> <title> a reconfigurable computational network for computer vision. </title> <journal> Machine Vision and Applications, </journal> <volume> 8(2) </volume> <pages> 85-100, </pages> <year> 1995. </year>
Reference-contexts: This holds for regular grids, and many data sets of interest are regularly gridded. We work with atmospheric circulation data, finite element trabecular bone data, and the numerous regularly gridded example data sets publicly available. Our solutions have been published <ref> [15, 13, 14, 1] </ref>, but their utility has not been widely seized upon, and collaboration with LLNL was started to port these solutions onto the world wide web for current biomedical studies [11].
Reference: [16] <author> Jim Blinn. </author> <title> Light reflection functions for simulations of clouds and dusty surfaces. </title> <booktitle> In Computer Graphics, </booktitle> <pages> pages 21-29, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: The PPS calculates normals, opacities, and initial shaded intensities. Classification and 2. Background on Permutation Warping 3 shading is discussed in detail in the background references <ref> [16, 17, 18, 19] </ref>. The VWS transforms the initial shading intensities and the opacities to the three dimensional screen space by resampling. The CS evaluates the view ray line integrals to get the two dimensional screen space pixel intensities. The final output is a two dimensional array of pixel values. <p> The CS evaluates the view ray line integrals to get the two dimensional screen space pixel intensities. The final output is a two dimensional array of pixel values. For a more in depth discussion of volume rendering see Collected papers in Kaufman [20], Blinn <ref> [16] </ref>, Kajiya and von Herzen [17], Levoy [18, 19], and our survey [13]. The array of output pixel intensities can be calculated many different ways indicated by the numerous input variables: volume data, light sources, view transform, classification function, and shading function.
Reference: [17] <author> J. T. Kajiya and B. Von Herzen. </author> <title> Ray tracing volume densities. </title> <booktitle> In Proceedings of SIGGRAPH, </booktitle> <pages> pages 165-174, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: The PPS calculates normals, opacities, and initial shaded intensities. Classification and 2. Background on Permutation Warping 3 shading is discussed in detail in the background references <ref> [16, 17, 18, 19] </ref>. The VWS transforms the initial shading intensities and the opacities to the three dimensional screen space by resampling. The CS evaluates the view ray line integrals to get the two dimensional screen space pixel intensities. The final output is a two dimensional array of pixel values. <p> The CS evaluates the view ray line integrals to get the two dimensional screen space pixel intensities. The final output is a two dimensional array of pixel values. For a more in depth discussion of volume rendering see Collected papers in Kaufman [20], Blinn [16], Kajiya and von Herzen <ref> [17] </ref>, Levoy [18, 19], and our survey [13]. The array of output pixel intensities can be calculated many different ways indicated by the numerous input variables: volume data, light sources, view transform, classification function, and shading function. An illustrative categorization of possible algorithms is by viewing transform.
Reference: [18] <author> Marc Levoy. </author> <title> Display of surfaces from volume data. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 8(5) </volume> <pages> 29-37, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: The PPS calculates normals, opacities, and initial shaded intensities. Classification and 2. Background on Permutation Warping 3 shading is discussed in detail in the background references <ref> [16, 17, 18, 19] </ref>. The VWS transforms the initial shading intensities and the opacities to the three dimensional screen space by resampling. The CS evaluates the view ray line integrals to get the two dimensional screen space pixel intensities. The final output is a two dimensional array of pixel values. <p> The final output is a two dimensional array of pixel values. For a more in depth discussion of volume rendering see Collected papers in Kaufman [20], Blinn [16], Kajiya and von Herzen [17], Levoy <ref> [18, 19] </ref>, and our survey [13]. The array of output pixel intensities can be calculated many different ways indicated by the numerous input variables: volume data, light sources, view transform, classification function, and shading function. An illustrative categorization of possible algorithms is by viewing transform.
Reference: [19] <author> Marc Levoy. </author> <title> Efficient ray tracing of volume data. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 9(3) </volume> <pages> 245-261, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The PPS calculates normals, opacities, and initial shaded intensities. Classification and 2. Background on Permutation Warping 3 shading is discussed in detail in the background references <ref> [16, 17, 18, 19] </ref>. The VWS transforms the initial shading intensities and the opacities to the three dimensional screen space by resampling. The CS evaluates the view ray line integrals to get the two dimensional screen space pixel intensities. The final output is a two dimensional array of pixel values. <p> The final output is a two dimensional array of pixel values. For a more in depth discussion of volume rendering see Collected papers in Kaufman [20], Blinn [16], Kajiya and von Herzen [17], Levoy <ref> [18, 19] </ref>, and our survey [13]. The array of output pixel intensities can be calculated many different ways indicated by the numerous input variables: volume data, light sources, view transform, classification function, and shading function. An illustrative categorization of possible algorithms is by viewing transform. <p> Timing numbers for Brain64 data show similar speed up which is about 230 % faster than base permutation warping algorithm. It has been reported that 90 % of most volumes can be considered empty without sacrificing the resulting raycasted image quality <ref> [19] </ref>. From the numbers in the Table 4.1 and Table 4.2, we can conclude that we will get about 200 % to 400 % performance gains without losing image quality. With more compression with the linear octree, the performance gain is more.
Reference: [20] <author> Arie Kaufman, </author> <title> editor. Volume Visualization. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1991. </year>
Reference-contexts: The CS evaluates the view ray line integrals to get the two dimensional screen space pixel intensities. The final output is a two dimensional array of pixel values. For a more in depth discussion of volume rendering see Collected papers in Kaufman <ref> [20] </ref>, Blinn [16], Kajiya and von Herzen [17], Levoy [18, 19], and our survey [13]. The array of output pixel intensities can be calculated many different ways indicated by the numerous input variables: volume data, light sources, view transform, classification function, and shading function.
Reference: [21] <author> J. Foley, A. vanDam, S.K. Feiner, and J.F. Hughes. </author> <title> Computer Graphics Principles and Practice. </title> <publisher> Addison Wesley Inc., </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: An illustrative categorization of possible algorithms is by viewing transform. Existing parallel algorithms may be grouped into four categories determined by their viewing transforms: backwards, multipass forwards, forwards splatting, and forwards wavefront. A backwards viewing transform is ray tracing <ref> [21] </ref>. Nieh and Levoy [22], Yoo et al. [23], Montani et al. [24], Neu-mann [25], Goel et al. [26], and Hsu [27] have developed backwards (ray tracing) volume rendering algorithms for parallel computers.
Reference: [22] <author> J. Nieh and M. Levoy. </author> <title> Volume rendering on scalable shared-memory mimd architectures. </title> <booktitle> In Proceedings of 1992 Workshop on Volume Visualization, </booktitle> <pages> pages 17-24, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: An illustrative categorization of possible algorithms is by viewing transform. Existing parallel algorithms may be grouped into four categories determined by their viewing transforms: backwards, multipass forwards, forwards splatting, and forwards wavefront. A backwards viewing transform is ray tracing [21]. Nieh and Levoy <ref> [22] </ref>, Yoo et al. [23], Montani et al. [24], Neu-mann [25], Goel et al. [26], and Hsu [27] have developed backwards (ray tracing) volume rendering algorithms for parallel computers.
Reference: [23] <author> T. S. Yoo, U. Neumann, H. Fuchs, S. M. Pizer, T. Cullip, J. Rhoades, and R. Whitaker. </author> <title> Achieving direct volume visualization with interactive semantic region selection. </title> <booktitle> In Proceedings IEEE Visualization `91, </booktitle> <pages> pages 58-65, </pages> <address> San Diego, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: An illustrative categorization of possible algorithms is by viewing transform. Existing parallel algorithms may be grouped into four categories determined by their viewing transforms: backwards, multipass forwards, forwards splatting, and forwards wavefront. A backwards viewing transform is ray tracing [21]. Nieh and Levoy [22], Yoo et al. <ref> [23] </ref>, Montani et al. [24], Neu-mann [25], Goel et al. [26], and Hsu [27] have developed backwards (ray tracing) volume rendering algorithms for parallel computers. Our permutation warping [2] approach computes a backwards mapping algorithm with optimal storage and deterministic communication on shared or distributed memory machines.
Reference: [24] <author> C. Montani and R. Scopigno. </author> <title> Rendering volumetric data using the sticks representation scheme. </title> <booktitle> In Computer Graphics, San Diego Workshop on Volume Visualization, </booktitle> <pages> pages 87-93, </pages> <address> San Diego, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: Existing parallel algorithms may be grouped into four categories determined by their viewing transforms: backwards, multipass forwards, forwards splatting, and forwards wavefront. A backwards viewing transform is ray tracing [21]. Nieh and Levoy [22], Yoo et al. [23], Montani et al. <ref> [24] </ref>, Neu-mann [25], Goel et al. [26], and Hsu [27] have developed backwards (ray tracing) volume rendering algorithms for parallel computers. Our permutation warping [2] approach computes a backwards mapping algorithm with optimal storage and deterministic communication on shared or distributed memory machines.
Reference: [25] <author> Ulrich Neumann. </author> <title> Parallel volume rendering algorithm performance on mesh connected multi-computers. </title> <booktitle> In Proceedings on the Parallel Rendering Symposium, </booktitle> <pages> pages 97-104, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Existing parallel algorithms may be grouped into four categories determined by their viewing transforms: backwards, multipass forwards, forwards splatting, and forwards wavefront. A backwards viewing transform is ray tracing [21]. Nieh and Levoy [22], Yoo et al. [23], Montani et al. [24], Neu-mann <ref> [25] </ref>, Goel et al. [26], and Hsu [27] have developed backwards (ray tracing) volume rendering algorithms for parallel computers. Our permutation warping [2] approach computes a backwards mapping algorithm with optimal storage and deterministic communication on shared or distributed memory machines.
Reference: [26] <author> Vineet Goel and Amar Mukherjee. </author> <title> An optimal parallel algorithm for volume ray casting. </title> <booktitle> In 9th International Parallel Processing Symposium, page to appear, </booktitle> <address> Santa Barbara, CA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Existing parallel algorithms may be grouped into four categories determined by their viewing transforms: backwards, multipass forwards, forwards splatting, and forwards wavefront. A backwards viewing transform is ray tracing [21]. Nieh and Levoy [22], Yoo et al. [23], Montani et al. [24], Neu-mann [25], Goel et al. <ref> [26] </ref>, and Hsu [27] have developed backwards (ray tracing) volume rendering algorithms for parallel computers. Our permutation warping [2] approach computes a backwards mapping algorithm with optimal storage and deterministic communication on shared or distributed memory machines. Figures 2.1 and 2.2 illustrate the transforms calculated by processors.
Reference: [27] <author> W. H. Hsu. </author> <title> Segmented ray casting for data parallel volume rendering. </title> <booktitle> In Proceedings of the Parallel Rendering Symposium, </booktitle> <pages> pages 7-14, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: A backwards viewing transform is ray tracing [21]. Nieh and Levoy [22], Yoo et al. [23], Montani et al. [24], Neu-mann [25], Goel et al. [26], and Hsu <ref> [27] </ref> have developed backwards (ray tracing) volume rendering algorithms for parallel computers. Our permutation warping [2] approach computes a backwards mapping algorithm with optimal storage and deterministic communication on shared or distributed memory machines. Figures 2.1 and 2.2 illustrate the transforms calculated by processors.
Reference: [28] <author> Craig M. Wittenbrink. </author> <title> Designing Optimal Parallel Volume Rendering Algorithms. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1993. </year>
Reference-contexts: Figure 2.1 shows the aligned subimages in two-dimensions. In Step 3, a parallel product evaluation combines resampled intensities and opacities. Binary tree combining computes products for any associative (not necessarily commutative) operator. For details of binary tree compositing, see our work <ref> [28, 3] </ref>. a permutation warping assignment. The arrow shows the data communication from object space (OS) to screen space (SS). The final 2D volume on the right shows the communicated fragments properly sorted. Several enhancements are possible for the permutation warping algorithm. <p> We describe these enhancements, and their 4 3. Methodology expected improvement for the algorithm. Our prior algorithmic studies of permutation warping have shown that it is asymptotically time and space optimal for resampling on the EREW PRAM (exclusive read exclusive write parallel random access machine) <ref> [28, 2, 3, 14, 1] </ref>. The MIMD study that we carried out showed that there was poor load balacing for certain view angles.
Reference: [29] <author> L. G. Valiant. </author> <title> A bridging model for parallel computation. </title> <journal> Communications of the ACM, </journal> <volume> 33(8) </volume> <pages> 103-111, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: An effective load balancing strategy is a must for MIMD variants of the permutation warping algorithm, and the proposed work includes altering the mapping of permutations to virtual addresses which will allow the use of slackness <ref> [29] </ref>, and also redistribution of processor's work. The permutation assignment can be done from virtual processor address to virtual processor address, and the virtual assignments can be dynamically altered to load balance the processing as it occurs.
Reference: [30] <author> I. </author> <title> Gargantini. Linear octtrees for fast processing of three-dimensional objects. </title> <journal> Computer Graphics and Image Processing, </journal> <volume> 20(4) </volume> <pages> 365-374, </pages> <month> December </month> <year> 1982. </year>
Reference-contexts: Octree compression with static load balancing. 4. Pre-compositing before communication. The performance of permutation warping can be improved by using compression techniques like octtree or run length encoding. A space partitioning octtree scheme has been implemented for an attempt to improve performance of permutation warping. The linear octtree <ref> [30] </ref> is a data structure that can be traversed linearly and spatial location can be computed quickly by simple computations. The minimal storage requirements for a linear octree node is the size of voxel plus the size of an octree code. <p> The minimal storage requirements for a linear octree node is the size of voxel plus the size of an octree code. We use 1 byte for voxel data and 32 bits for an octree code. One octree coding level require 4 bits including a padding character <ref> [30] </ref>. Therefore our data structure can handle a sub-volume of size 2 8 in each direction. For performance, we have an additional data structure that stores the origin of each octree region and its size in each direction of 3 dimensional space. <p> In this case, we should either use a lower quality filter for re-sampling or sacrifice the performance through less optimal load balancing and communication. To save storage, we can also use the decoding calculations <ref> [30] </ref> without storing coordinate information for the octree region. A simple extension of the interpolation (re-sampling) routine, that fetches all surrounding voxels when necessary, will solve the memory limitations.
References-found: 30

