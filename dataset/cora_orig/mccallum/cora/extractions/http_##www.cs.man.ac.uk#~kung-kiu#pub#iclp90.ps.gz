URL: http://www.cs.man.ac.uk/~kung-kiu/pub/iclp90.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kkl@uk.ac.man.cs  
Title: Top-down Synthesis of Recursive Logic Procedures from First-order Logic Specifications  
Author: K.K. Lau S.D. Prestwich 
Address: Oxford Road, Manchester M13 9PL, England  Arabellastrasse 17, D-8000 Munchen 81, West Germany  
Affiliation: Department of Computer Science, University of Manchester  European Computer-Industry Research Center  
Abstract: Derivation of logic programs from first-order logic specifications is nontrivial and tends to be done by hand. We describe a method for synthesising recursive logic procedures from their first-order logic specifications that is amenable to mechanisation. The method is strictly top-down and has been implemented as part of a user-guided synthesis system in Prolog. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.M. Burstall, J. Darlington, </author> <title> A Transformation System for Developing Recursive Programs, </title> <journal> J. ACM 24(1), </journal> <month> January </month> <year> 1977, </year> <pages> 44-67. </pages>
Reference-contexts: 1 Introduction Recursion is fundamental to logic programming, as is evident in standard works such as [9] and [16]. The standard fold-unfold technique of Burstall & Darlington <ref> [1] </ref> and Manna & Waldinger [15] for recursion introduction has been applied to logic program derivation (in one form or another) by Clark & Darlington [2], Clark & Sickel [3], Hogger [8], Kanamori & Horiuchi [10], and Tamaki & Sato [17], among others.
Reference: [2] <author> K.L. Clark, J. Darlington, </author> <title> Algorithm Classification through Synthesis, </title> <journal> The Computer Journal 23(1), </journal> <year> 1980, </year> <pages> 61-65. </pages>
Reference-contexts: The standard fold-unfold technique of Burstall & Darlington [1] and Manna & Waldinger [15] for recursion introduction has been applied to logic program derivation (in one form or another) by Clark & Darlington <ref> [2] </ref>, Clark & Sickel [3], Hogger [8], Kanamori & Horiuchi [10], and Tamaki & Sato [17], among others. In general, where logic programs are derived from first-order logic specifications, the synthesis tends to be done by hand; whilst transformation of a program into another is more amenable to mechanisation. <p> Our experience shows that such definitions are often the key to the synthesis of useful auxiliary clauses. For example, clauses for the merge predicate for merge sort (as defined in <ref> [2] </ref> for instance) can be synthesised from such a definition (see [14]).
Reference: [3] <author> K.L. Clark, S. Sickel, </author> <title> Predicate Logic: A Calculus for the Derivation of Programs, </title> <booktitle> Proc. IJCAI-77 , 1977, </booktitle> <pages> 419-420. </pages>
Reference-contexts: The standard fold-unfold technique of Burstall & Darlington [1] and Manna & Waldinger [15] for recursion introduction has been applied to logic program derivation (in one form or another) by Clark & Darlington [2], Clark & Sickel <ref> [3] </ref>, Hogger [8], Kanamori & Horiuchi [10], and Tamaki & Sato [17], among others. In general, where logic programs are derived from first-order logic specifications, the synthesis tends to be done by hand; whilst transformation of a program into another is more amenable to mechanisation.
Reference: [4] <author> K. L. Clark, S.-A. </author> <title> Tarnlund, A First Order Theory of Data and Programs, </title> <booktitle> in Information Processing 77 , North-Holland 1977, </booktitle> <pages> 939-944. </pages>
Reference: [5] <author> G. Dayantis, </author> <title> Logic Program Derivation for a Class of First Order Logic Relations, </title> <booktitle> Proc. IJCAI-87 , 1987, </booktitle> <pages> 9-14. </pages>
Reference-contexts: This makes first-order logic a natural choice. However, for mechanised derivation, it may be advantageous to have a specification language closer to the (Horn) clausal form. For example, Kowalski [12] proposes the extended Horn clause subset of logic as a suitable general-purpose candidate, and Dayantis <ref> [5] </ref> makes use of recursively-defined relations which are also closely related to Horn clause logic. In our work, we are concerned with both expressiveness of specification language and ease of mechanisation of derivation. Not surprisingly, our choice is a compromise.
Reference: [6] <author> Y. Deville, J. Burnay, </author> <title> Generalization and Program Schemata: A Step Towards Computer-Aided Construction of Logic Programs, </title> <booktitle> Proc. NA-CLP 89 , 1989, </booktitle> <pages> 409-425. </pages>
Reference-contexts: The result of our synthesis is equivalent to what Deville & Burnay <ref> [6] </ref> call a logic description, from which they derive a logic program.
Reference: [7] <author> M.S. Feather, </author> <title> A System for Assisting Program Transformation, </title> <journal> ACM TOPLAS 4(1), </journal> <year> 1982, </year> <pages> 1-20. </pages>
Reference-contexts: calls in these procedures can be specified by the following folding problems: (i) fold subset (h:t; `) to fsubset (t; s)g ; (ii) fold subset (a^b; e) to fsubset (a; s 1 ); subset (b; s 2 )g : 4 Our approach here is similar to that taken by Feather <ref> [7] </ref> for pattern-directed fold unfold transformations used for developing programs in recursion equations. 5 Note the use of ^, and that in standard list notation, h:t = [h]^t, where h is a single element and t is a list. (Note that the "output variables" s; s 1 ; s 2 are
Reference: [8] <author> C.J. </author> <title> Hogger, Derivation of Logic Programs, </title> <journal> J. ACM 28(2), </journal> <year> 1981, </year> <pages> 372-392. </pages>
Reference-contexts: The standard fold-unfold technique of Burstall & Darlington [1] and Manna & Waldinger [15] for recursion introduction has been applied to logic program derivation (in one form or another) by Clark & Darlington [2], Clark & Sickel [3], Hogger <ref> [8] </ref>, Kanamori & Horiuchi [10], and Tamaki & Sato [17], among others. In general, where logic programs are derived from first-order logic specifications, the synthesis tends to be done by hand; whilst transformation of a program into another is more amenable to mechanisation.
Reference: [9] <author> C.J. </author> <title> Hogger, Introduction to Logic Programming, </title> <publisher> Academic Press 1984. </publisher>
Reference-contexts: 1 Introduction Recursion is fundamental to logic programming, as is evident in standard works such as <ref> [9] </ref> and [16].
Reference: [10] <author> T. Kanamori, K. Horiuchi, </author> <title> Construction of Logic Programs based on Generalised Unfold/fold Rules, </title> <type> ICOT Technical Report TR-177, </type> <year> 1986. </year>
Reference-contexts: The standard fold-unfold technique of Burstall & Darlington [1] and Manna & Waldinger [15] for recursion introduction has been applied to logic program derivation (in one form or another) by Clark & Darlington [2], Clark & Sickel [3], Hogger [8], Kanamori & Horiuchi <ref> [10] </ref>, and Tamaki & Sato [17], among others. In general, where logic programs are derived from first-order logic specifications, the synthesis tends to be done by hand; whilst transformation of a program into another is more amenable to mechanisation.
Reference: [11] <author> J. Komorowski, </author> <title> Towards Synthesis of Programs in the Framework of Partial Deduction, </title> <booktitle> Proc. Workshop on Automating Software Design, 11th IJCAI, </booktitle> <year> 1989. </year>
Reference: [12] <author> R. Kowalski, </author> <title> The Relation between Logic Programming and Logic Specification, in C.A.R. Hoare, J.C. </title> <editor> Shepherdson (eds), </editor> <booktitle> Mathematical Logic and Programming Languages, Prentice-Hall 1985, </booktitle> <pages> 11-27. </pages>
Reference-contexts: This makes first-order logic a natural choice. However, for mechanised derivation, it may be advantageous to have a specification language closer to the (Horn) clausal form. For example, Kowalski <ref> [12] </ref> proposes the extended Horn clause subset of logic as a suitable general-purpose candidate, and Dayantis [5] makes use of recursively-defined relations which are also closely related to Horn clause logic. In our work, we are concerned with both expressiveness of specification language and ease of mechanisation of derivation.
Reference: [13] <author> K.K. Lau, </author> <title> A Note on Synthesis and Classification of Sorting Algorithms, </title> <journal> Acta Informatica 27, </journal> <year> 1989, </year> <month> 73-80.. </month>
Reference: [14] <author> K.K. Lau, </author> <title> S.D. Prestwich, Synthesis of Logic Programs for Recursive Sorting Algorithms, </title> <type> Technical Report UMCS-88-10-1, </type> <institution> Department of Computer Science, University of Manchester, </institution> <year> 1988. </year>
Reference-contexts: Our experience shows that such definitions are often the key to the synthesis of useful auxiliary clauses. For example, clauses for the merge predicate for merge sort (as defined in [2] for instance) can be synthesised from such a definition (see <ref> [14] </ref>).
Reference: [15] <author> Z. Manna, R. Waldinger, </author> <title> Synthesis: Dreams ) Programs, </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> 5(4), </volume> <month> July </month> <year> 1979, </year> <pages> 294-328. </pages>
Reference-contexts: 1 Introduction Recursion is fundamental to logic programming, as is evident in standard works such as [9] and [16]. The standard fold-unfold technique of Burstall & Darlington [1] and Manna & Waldinger <ref> [15] </ref> for recursion introduction has been applied to logic program derivation (in one form or another) by Clark & Darlington [2], Clark & Sickel [3], Hogger [8], Kanamori & Horiuchi [10], and Tamaki & Sato [17], among others.
Reference: [16] <author> L. Sterling, E. Shapiro, </author> <title> The Art of Prolog, </title> <publisher> MIT Press 1986. </publisher>
Reference-contexts: 1 Introduction Recursion is fundamental to logic programming, as is evident in standard works such as [9] and <ref> [16] </ref>. <p> The required transformation is straightforward and can be done automatically. It may involve replacing 1 Variables occurring in q but not in p are called the internal variables of the implication. 2 As in <ref> [16] </ref>, a procedure is a set of clauses with the same positive predicate in the head. 3 By definition, we allow negated predicates as heads of implications (and clauses); in the bodies, we can either allow negated predicates, or remove them by making new definitions. subformulae with new predicates.
Reference: [17] <author> H. Tamaki, T. Sato, </author> <title> Unfold/fold Transformations for Logic Programs, </title> <booktitle> Proc. 2nd Int. Conf. on Logic Programming, </booktitle> <year> 1984, </year> <pages> 127-138. </pages>
Reference-contexts: The standard fold-unfold technique of Burstall & Darlington [1] and Manna & Waldinger [15] for recursion introduction has been applied to logic program derivation (in one form or another) by Clark & Darlington [2], Clark & Sickel [3], Hogger [8], Kanamori & Horiuchi [10], and Tamaki & Sato <ref> [17] </ref>, among others. In general, where logic programs are derived from first-order logic specifications, the synthesis tends to be done by hand; whilst transformation of a program into another is more amenable to mechanisation.
References-found: 17

