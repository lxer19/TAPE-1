URL: http://http.cs.berkeley.edu/~jjones/Work/phylo.ps
Refering-URL: http://http.cs.berkeley.edu/~jjones/Work/
Root-URL: http://www.cs.berkeley.edu
Title: Parallelizing the Phylogeny Problem  
Author: Jeff A. Jones 
Date: December 14, 1994  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Agarwala and D. Fernandez-Baca. </author> <title> A polynomial-time algorithm for the perfect phylogeny problem when the number of character states is fixed. </title> <booktitle> In Proceedings of the 34th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pp. 140-147, </pages> <year> 1993. </year>
Reference-contexts: Character compatibility solves the general phylogeny problem by combining the solutions of several perfect phylogeny problems. Our character compatibility implementation relies on an algorithm due to Agarwala and Fernandez-Baca <ref> [1] </ref> to solve the perfect phylogeny problem. We give a new, simpler description and proof of correctness of this algorithm in Section 3. Deriving an efficient implementation from an efficient algorithm requires care. Maximum performance requires appropriate data structures and use of heuristics based on expected inputs. <p> The characters can be skeletal structures, coloring, or other physical characteristics. More often, the characters are elements of molecular sequences. We represent a species u with a vector of character values, u <ref> [1] </ref>; : : :; u [c max ], where c max is the number of characters to be considered. In the case of molecular sequences, each element of this vector is a nucleotide or amino acid. <p> Tree b satisfies all three conditions, as does tree c. Notice that the perfect phylogeny for a given set of species may not be unique. Tree c contains the species <ref> [1; 1; 3] </ref>, which was not a member of the original set. The tree is still a perfect phylogeny, however, because all of the leaves appear in the original set. <p> If the subset is large, the corresponding perfect phylogeny will be a good estimate of the evolutionary history of the species. Solving the character compatibility problem requires determining whether or not each subset of characters is compatible. We use the algorithm of Agarwala and Fernandez-Baca <ref> [1] </ref>, which we describe in Section 3, to determine compatibility. Examining all possible subsets (an exponential number) in turn is extremely time-consuming, however. Fortunately, we can reduce the number of subproblems examined with the following lemma. <p> To complete the process, we connect the subtrees into successively larger trees by connecting the appropriate vertices. Unfortunately, vertex decomposition does not suffice for all sets of species. For example, Notice that, as in tree c of Figure 1, we have added a new vertex with character vector <ref> [1; 1; 1] </ref>. As noted above, a vertex decomposition requires a member of the original set of species that can be an internal vertex of the perfect phylogeny. The set in Figure 1, however, has no such species, which explains the necessity for the added species. <p> We introduced techniques for bounding this search, and showed their substantial impact on performance. Next, we considered the perfect phylogeny problem, a subproblem of character compatibility. 27 28 29 30 Our implementation uses the algorithm of of Agarwala and Fernandez-Baca <ref> [1] </ref>, implemented according to a suggestion from Lawler [6]. We believe our description and proof of correctness of the algorithm to be simpler than that in the original paper [1]. We also examined several aspects of the performance of our implementation. <p> phylogeny problem, a subproblem of character compatibility. 27 28 29 30 Our implementation uses the algorithm of of Agarwala and Fernandez-Baca <ref> [1] </ref>, implemented according to a suggestion from Lawler [6]. We believe our description and proof of correctness of the algorithm to be simpler than that in the original paper [1]. We also examined several aspects of the performance of our implementation. Guided by our measurements of the sequential implementation, we developed an initial parallel version based on two data structures.
Reference: [2] <author> H. Bodlaender, M. Fellows, and T. Warnow. </author> <title> Two strikes against perfect phylogeny. </title> <booktitle> In Proceedings of the 19th International Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pp. 273-283, </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1992. </year>
Reference-contexts: Each character takes on one of up to 4 possible values. Tree a is not a perfect phylogeny because it violates condition 3 in the definition: u <ref> [2] </ref> = w [2], but v [2] 6= u [2]. Tree b satisfies all three conditions, as does tree c. Notice that the perfect phylogeny for a given set of species may not be unique. <p> Each character takes on one of up to 4 possible values. Tree a is not a perfect phylogeny because it violates condition 3 in the definition: u <ref> [2] </ref> = w [2], but v [2] 6= u [2]. Tree b satisfies all three conditions, as does tree c. Notice that the perfect phylogeny for a given set of species may not be unique. Tree c contains the species [1; 1; 3], which was not a member of the original set. <p> Each character takes on one of up to 4 possible values. Tree a is not a perfect phylogeny because it violates condition 3 in the definition: u <ref> [2] </ref> = w [2], but v [2] 6= u [2]. Tree b satisfies all three conditions, as does tree c. Notice that the perfect phylogeny for a given set of species may not be unique. Tree c contains the species [1; 1; 3], which was not a member of the original set. <p> Each character takes on one of up to 4 possible values. Tree a is not a perfect phylogeny because it violates condition 3 in the definition: u <ref> [2] </ref> = w [2], but v [2] 6= u [2]. Tree b satisfies all three conditions, as does tree c. Notice that the perfect phylogeny for a given set of species may not be unique. Tree c contains the species [1; 1; 3], which was not a member of the original set. <p> We fix the set of characters and derive an algorithm that decides if a perfect phylogeny compatible with that set exists. The general form of the problem is NP-complete <ref> [2] </ref>. Possible approaches to obtaining a polynomial-time algorithm are fixing the maximum number of characters and fixing the maximum number of possible values per character to a constant, r max . <p> If at any point we fail to find a phylogeny for a subset, we know that none exists for S. 6 A, the common vector between S 1 = fv; u; wg and S 2 = fx; yg is <ref> [2; 3] </ref>, which is similar to v. We look for perfect phylogenies for fv; u; wg and fv; x; yg. In the figure, the dashed circles in each step indicate the species used to connect the two subtrees for that step.
Reference: [3] <author> J. Felsenstein. </author> <title> Numerical methods for inferring evolutionary trees. Q. </title> <journal> Rev. Biol, </journal> <volume> 57 </volume> <pages> 379-404, </pages> <year> 1982. </year>
Reference-contexts: Unfortunately, deriving phylogenetic trees is often prohibitively expensive. We used careful software design and parallel processing to solve the phylogeny problem quickly. Many methods for solving the phylogeny problem have been explored, including parsimony, compatibility, maximum likelihood, and distance matrix methods <ref> [3] </ref>. We focus on the method known as character compatibility [7], which we describe formally in Section 2. The character compatibility method searches a large space, so we have developed a number of heuristics for bounding the search. We demonstrate that the heuristics have a considerable impact on performance. <p> Tree b satisfies all three conditions, as does tree c. Notice that the perfect phylogeny for a given set of species may not be unique. Tree c contains the species <ref> [1; 1; 3] </ref>, which was not a member of the original set. The tree is still a perfect phylogeny, however, because all of the leaves appear in the original set. <p> If at any point we fail to find a phylogeny for a subset, we know that none exists for S. 6 A, the common vector between S 1 = fv; u; wg and S 2 = fx; yg is <ref> [2; 3] </ref>, which is similar to v. We look for perfect phylogenies for fv; u; wg and fv; x; yg. In the figure, the dashed circles in each step indicate the species used to connect the two subtrees for that step.
Reference: [4] <author> M. Hasegawa, H. Kishino, K. Hayasaka, and S. Horai. </author> <title> Mitochondrial DNA evolution in primates: transition rate has been extremely low in the lemur. </title> <journal> J. Molecular Evolution, </journal> <volume> 31(2) </volume> <pages> 113-21, </pages> <year> 1990. </year>
Reference-contexts: Experimental data supports our intuition. We compared the top-down and bottom-up approaches for 15 problems with 14 species and 10 characters, all taken from mitochondrial third positions in the D-loop region <ref> [4] </ref>. The top-down version explored an average of 1004 subsets, and the bottom-up version explored an average of 151:1. Note that the search tree contains only 1024 nodes. <p> We now present timing results for each of the three implementations. The benchmarks are 40 character sections of the same mitochondrial third positions in the D-loop region <ref> [4] </ref>. for small numbers of processors, the unshared and random techniques achieved superlinear speedup.
Reference: [5] <author> J.M. Hullot. </author> <title> Associative-commutative pattern matching. </title> <booktitle> 5th IJCAI, </booktitle> <address> Tokyo, Japan, </address> <year> 1979. </year>
Reference-contexts: The tree corresponds to a bottom-up search: we begin with small subsets and progress to larger subsets. The search tree for top-down search is the mirror image of the bottom-up tree. Trees with this structure are known as binomial trees <ref> [5, 9] </ref>. Binomial trees have the recursive structure shown in Figure 11. Figure 12 shows an example with 4 characters. Notice that a depth-first and right-to-left search of the tree in Figure 12 visits the subsets in lexicographic order.
Reference: [6] <author> E.L. Lawler. </author> <type> Personal communication. </type> <month> August </month> <year> 1993. </year>
Reference-contexts: We introduced techniques for bounding this search, and showed their substantial impact on performance. Next, we considered the perfect phylogeny problem, a subproblem of character compatibility. 27 28 29 30 Our implementation uses the algorithm of of Agarwala and Fernandez-Baca [1], implemented according to a suggestion from Lawler <ref> [6] </ref>. We believe our description and proof of correctness of the algorithm to be simpler than that in the original paper [1]. We also examined several aspects of the performance of our implementation.
Reference: [7] <author> W.J. Le Quesne. </author> <title> A method of selection of characters in numerical taxonomy. In Syst. </title> <journal> Zool., </journal> <volume> 18 </volume> <pages> 201-205, </pages> <year> 1969. </year>
Reference-contexts: We used careful software design and parallel processing to solve the phylogeny problem quickly. Many methods for solving the phylogeny problem have been explored, including parsimony, compatibility, maximum likelihood, and distance matrix methods [3]. We focus on the method known as character compatibility <ref> [7] </ref>, which we describe formally in Section 2. The character compatibility method searches a large space, so we have developed a number of heuristics for bounding the search. We demonstrate that the heuristics have a considerable impact on performance.
Reference: [8] <author> F.R. McMorris, T.J. Warnow, and T. Wimer. </author> <title> Triangulating vertex colored graphs. </title> <booktitle> In Proceedings of the 4th Annual Symposium on Discrete Algorithms, </booktitle> <address> Austin, Texas, </address> <year> 1993. </year>
Reference-contexts: Using the first approach, it has been shown that the problem may be solved in time O (n m+1 ), where n is the number of species and m is the number of characters <ref> [8] </ref>. We describe an algorithm using the second approach, due to Agarwala and Fernandez-Baca, which achieves a time bound of u 1 1 1 w 2 1 1 Table 2: Another example set of species. 4 O (2 2r max (nm 3 + m 4 )).
Reference: [9] <author> J. Vuillemin. </author> <title> A data structure for manipulating priority queues. </title> <journal> C. ACM, </journal> <volume> 21(4), </volume> <year> 1978. </year>
Reference-contexts: The tree corresponds to a bottom-up search: we begin with small subsets and progress to larger subsets. The search tree for top-down search is the mirror image of the bottom-up tree. Trees with this structure are known as binomial trees <ref> [5, 9] </ref>. Binomial trees have the recursive structure shown in Figure 11. Figure 12 shows an example with 4 characters. Notice that a depth-first and right-to-left search of the tree in Figure 12 visits the subsets in lexicographic order.
Reference: [10] <author> K. Yelick, S. Chakrabarti, E. Deprit, J. Jones, A. Krishnamurthy and C. Wen. </author> <title> Data structures for irregular applications. DIMACS Workshop on Parallel Algorithms for Unstructured and Dynamic Problems, </title> <booktitle> 1993. </booktitle> <pages> 31 </pages>
Reference-contexts: In addition, we prefer a distributed task queue, so that the queue is not a performance bottleneck. The task queue data structure from Multipol <ref> [10] </ref> meets our requirements, and is our choice for our implementation. Each processor executes a loop consisting of dequeuing a task from the task queue, executing the task, and enqueuing any new tasks generated. <p> We also examined several aspects of the performance of our implementation. Guided by our measurements of the sequential implementation, we developed an initial parallel version based on two data structures. The task queue from Multipol <ref> [10] </ref> distributes the tasks and maintains load balance, and the FailureStore, represented as a distributed trie, manages the sharing of information among processors. We studied three implementations of the FailureStore and found that the implementation that synchronized periodically to communicate information to all processors was the best.
References-found: 10

