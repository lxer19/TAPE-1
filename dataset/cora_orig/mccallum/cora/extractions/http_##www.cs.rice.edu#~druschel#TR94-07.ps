URL: http://www.cs.rice.edu/~druschel/TR94-07.ps
Refering-URL: http://www.cs.rice.edu/~druschel/
Root-URL: 
Email: fdavidm,druschel,llpg@cs.arizona.edu  
Title: A Fast and General Software Solution to Mutual Exclusion on Uniprocessors  
Author: David Mosberger, Peter Druschel, and Larry L. Peterson 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Note: June  
Date: TR 94-07  24, 1994  
Abstract: This paper presents a technique to solve the mutual exclusion problem for uniprocessors purely in software. The idea is to execute atomic sequences without any hardware protection and, in the rare case that the atomic sequence is interrupted, to rollforward to the end of the sequence. The main contribution of this paper is to discuss the OS-related issues of this technique and to demonstrate its practicality, both in terms of flexibility and performance. It proposes a purely software-based technique that achieves mutual exclusion without any memory-accesses. Experiments show that this technique has the potential to outperform equivalent hardware mechanisms. 
Abstract-found: 1
Intro-found: 1
Reference: [ABLL91] <author> T.E. Anderson, B.N. Bershad, E.D. Lazowska, and H.M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <booktitle> In Symposium on Operating System Principles, </booktitle> <year> 1991. </year>
Reference-contexts: Older processors that do not employ separate instruction and data caches guarantee this automatically. On many modern processors, however, this requires explicit cache flushing, which can be costly. 3 2.2.2 Cloning In <ref> [ABLL91] </ref>, a technique was proposed that avoids overheads per atomic sequence without requiring write access to the code segment. The idea is to clone every atomic sequence. The original copy is left unmodified while the cloned copy ends with an instruction that relinquishes control back to the interrupt handler. <p> There is good reason to belief that there are other multi-word operations that would be useful for constructing lock-free data-structures. Rollforward gives the flexibility to do so. Another system that employed rollforward is Scheduler Activations <ref> [ABLL91] </ref>. Unlike Trellis/Owl it does not use rollforward to achieve mutual exclusion. Instead, it is used to avoid deadlock. Scheduler Activations use lock-based synchronization. For performance and liveness reasons, it is undesirable to suspend a process while it is holding a lock.
Reference: [Ber93] <author> Brian N. Bershad. </author> <title> Practical considerations for non-blocking concurrent objects. </title> <booktitle> In Proceedings of the 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 264-273, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Finally, even though this technique is not directly applicable to multiprocessor synchronization, it is useful in constructing lock-free data-structures on machines that do not have sufficiently powerful hardware-primitives <ref> [Ber93] </ref>. While the idea is straight-forward, there are several issues that make this technique non-trivial in an OS context. In particular, it is necessary to address issues like interactions with the memory system, multiple address spaces, and multiple trust domains. <p> Another shortcoming is that the Trellis/Owl work does not address any of the operating system issues raised by software mutual exclusion. Being a language system, it is unclear whether the same techniques could be generalized to other languages or supported in a language-independent manner. Rollforward is also mentioned in <ref> [Ber93] </ref>. That work appears to dismiss rollforward as a practical solution for two reasons: (a) execution of code on behalf of another thread and (b) page-faults. It is true that executing code on behalf of another thread is difficult. <p> We also discussed how page-faults can be handled. In particular, restricting code and data to be (individually) contained in a single page is practical for the problem studied in <ref> [Ber93] </ref>. We would also like to point out that with rollback it would be difficult to implement primitives that need to update multiple words atomically. For example, a simple compare-and-swap2 operation that compares and conditionally updates two words is much easier to implement with rollforward.
Reference: [BRE92] <author> Brian N. Bershad, David D. Redell, and John R. Ellis. </author> <title> Fast mutual exclusion for uniprocessors. </title> <booktitle> In Fifth Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 223-233. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: It is also the case that support for hierarchical priority levels is more expensive than one might hope [SCB93]. Because of the limitations of these two hardware-based approaches to implementing atomic sequences, Bershad, Redell, and Ellis have proposed a software-only implementation of mutual exclusion on uniprocessors <ref> [BRE92] </ref>. However, their solution is applicable only to simple atomic sequencesthose that involve only one store to shared memory. While this is sufficient to implement synchronization primitives that can in turn be used to construct higher-level synchronization objects, the approach is still limited. <p> Clearly, to perform a rollforward (or rollback), an interrupt handler must know about the ranges (extents) of code that constitute atomic sequences. Many registration schemes are conceivable and we present only four possibilities in that spectrum. The first two were previously suggested by Bershad et al. <ref> [BRE92] </ref>; we repeat them here for completeness. We found that both approaches rather seriously limit the flexibility with which software mutual exclusion can be used. The third and fourth approach rid these limitations at the cost of slightly higher overheads. 2.1.1 Designated Sequences The first proposal in [BRE92] is to use <p> Bershad et al. <ref> [BRE92] </ref>; we repeat them here for completeness. We found that both approaches rather seriously limit the flexibility with which software mutual exclusion can be used. The third and fourth approach rid these limitations at the cost of slightly higher overheads. 2.1.1 Designated Sequences The first proposal in [BRE92] is to use designated instruction sequences to mark atomic sequences. This is also the technique used in [MK87]. Designated sequences must not appear anywhere but in atomic sequences. <p> Under the given model, the software-based method therefore outperforms the hardware-based scheme with any but the most severe interrupt loads. 13 5 Related Work As mentioned in the introduction, Bershad et al. propose a software-based technique for mutual exclusion on unipro-cessors <ref> [BRE92] </ref>. Their approach is based on rollback instead of rollforward. It also differs from our approach in several more specific ways. First, their solution is limited to atomic sequences that contain only a single store to shared memory, whereas our approach permits multiple stores. <p> First, we described that page faults present a more serious problem when using rollforward instead of rollback. With rollback, page faults are a problem only if an interrupt handler needs to inspect the interrupted code in order to determine whether it interrupted an atomic sequence <ref> [BRE92] </ref>. With rollforward, there is always a potential for a page fault during rollforward. On the other hand, it is much easier to use designated sequences with rollforward because false hits are tolerable. The Hyb/Jump techniques fully exploits this fact.
Reference: [Dig92] <author> Digital Equipment Corporation. </author> <title> DECchip 21064-AA Microprocessor Hardware Reference Manual. </title> <publisher> Dig ital Press, </publisher> <address> Maynard, Massachusetts, first edition, </address> <month> October </month> <year> 1992. </year> <title> Order number EC-N0079-72. </title>
Reference-contexts: DI: Disabling all interrupts before entering an atomic sequence and enabling all interrupts after leaving it; i.e., this scheme does not admit interrupt priority levels. The Alpha architecture does not support this. However, the implementation described in <ref> [Dig92] </ref> provides the required facilities in a chip specific fashion. These low-level facilities normally are not accessible to kernel-level software. The measurements therefore had to be performed in a small stand-alone system. For the PA-RISC, the technique was measured in a Mach kernel that was extended with the test programs.
Reference: [GS92] <author> Ruth E. Goldenberg and Saro Saravanan. </author> <title> VMS for Alpha PlatformsInternals and Data Structures, volume 1. </title> <publisher> DEC Press, </publisher> <address> Burlington, Massachusetts, prelimenary edition, </address> <year> 1992. </year> <title> Order number EY-L466E-P1. </title>
Reference-contexts: This makes it equally well suited for implementation within the OS kernel (e.g., for device drivers) and in user-level processes (e.g., to protect against asynchronous events such as Unix signals [LMKQ88] or VMS Asynchronous System Traps <ref> [GS92] </ref>). Finally, even though this technique is not directly applicable to multiprocessor synchronization, it is useful in constructing lock-free data-structures on machines that do not have sufficiently powerful hardware-primitives [Ber93]. While the idea is straight-forward, there are several issues that make this technique non-trivial in an OS context.
Reference: [Her93] <author> Maurice Herlihy. </author> <title> A methodology for implementing highly concurrent data objects. </title> <journal> ACM Trancsactions on Programming Languages and Systems, </journal> <volume> 15(5) </volume> <pages> 745-770, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: as this code cannot risk blocking. (In general, lock-based solutions introduce the complexity of deadlock.) Second, while it is possible to create lock-free data-structures based on some of these primitives, it is well-known that this approach can incur significant overheads, often requiring reference counts and/or shadow copies of shared objects <ref> [Mas92, Her93] </ref>. This paper describes an alternative software-based approach to implementing atomic sequences on uniprocessors. Like the Bershad et al. solution, the idea is to address the only source of interferenceinterrupts. <p> This is in contrast to the motivation for using lock-free data-structures on multiprocessors. There, as argued by Herlihy <ref> [Her93] </ref>, the interest is founded mainly on the fault-tolerance properties of lock-free data-structures. Third, our hybrid registration scheme allows inlining of atomic sequences, whereas their static registration scheme severely restricts the number of atomic sequences.
Reference: [HP90a] <author> John L. Hennessey and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Palo Alto, </address> <year> 1990. </year>
Reference-contexts: The only condition on the kinds of faults that can be used for this purpose is that it must be possible to resume a process after taking such a fault. Any precise fault guarantees this <ref> [HP90a] </ref>. 2.3 Difficulties in Realizing Rollforward There are two major difficulties in realizing rollforward. The first is how to ensure that a rollforward does not delay an interrupt excessively. The second is how to deal with faults induced by a rollforward. <p> However, in practice, this overhead is often in the 30 cycle range due to cache effects (PALcode is located at an operating system fixed address and therefore not inlinable). As the gap between memory system and CPU performance continues to grow <ref> [HP90a, Pri94] </ref>, techniques that yield good cache performance will become ever more important. Software-based methods that use designated sequences, a dynamic, or a hybrid scheme to register atomic sequences can all be inlined easily. Fourth, our experience is that rollforward is very practical.
Reference: [HP90b] <author> Hewlett-Packard. </author> <title> PA-RISC 1.1 Architecture and Instruction Set Reference Manual. </title> <institution> Hewlett-Packard, Cupertino, California, </institution> <note> first edition, </note> <month> November </month> <year> 1990. </year> <title> Part number 09740-90039. </title> <type> 16 </type>
Reference-contexts: For software-based schemes, this includes dynamic registration overheads, for example. The hardware on which we obtained these results consisted of a DEC 3000 Model 600 AXP workstation with an Alpha CPU operating at 175 MHz and an HP 9000/735 with a PA-RISC 1.1 CPU operating at 99 MHz <ref> [Sit92, HP90b] </ref>. All tests were small enough to fit in the cache and the reported results are the execution times when running in the cache (i.e., with a warm cache). Both machines provide timers with a resolution of a single CPU cycle.
Reference: [LMKQ88] <author> Samuel J. Leffler, Marshall Kirk McKusick, Michael J. Karels, and John S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: As the technique is purely software-based it can be used to achieve mutual exclusion at any privilege level. This makes it equally well suited for implementation within the OS kernel (e.g., for device drivers) and in user-level processes (e.g., to protect against asynchronous events such as Unix signals <ref> [LMKQ88] </ref> or VMS Asynchronous System Traps [GS92]). Finally, even though this technique is not directly applicable to multiprocessor synchronization, it is useful in constructing lock-free data-structures on machines that do not have sufficiently powerful hardware-primitives [Ber93].
Reference: [Mas92] <author> Henry Massalin. </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <address> New York, NY 10027, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: as this code cannot risk blocking. (In general, lock-based solutions introduce the complexity of deadlock.) Second, while it is possible to create lock-free data-structures based on some of these primitives, it is well-known that this approach can incur significant overheads, often requiring reference counts and/or shadow copies of shared objects <ref> [Mas92, Her93] </ref>. This paper describes an alternative software-based approach to implementing atomic sequences on uniprocessors. Like the Bershad et al. solution, the idea is to address the only source of interferenceinterrupts. <p> On the positive side, it combines the advantages of designated sequences and static registration. Inlining poses no problem. The extent of an atomic sequence can be computed at run time, so even late forms of inlining, such as code synthesis <ref> [Mas92] </ref>, work readily. Checking whether an atomic sequence was interrupted is efficient as well. <p> First, their solution is limited to atomic sequences that contain only a single store to shared memory, whereas our approach permits multiple stores. It is often more convenient, and in the end more efficient, to implement shared data-structures via sequences that require multiple stores to shared memory (e.g., see <ref> [Mas92] </ref>). Second, our approach supports efficient lock-free solutions, whereas the earlier solution was designed for a lock-based scenario. <p> We would also like to point out that with rollback it would be difficult to implement primitives that need to update multiple words atomically. For example, a simple compare-and-swap2 operation that compares and conditionally updates two words is much easier to implement with rollforward. In <ref> [Mas92] </ref>, Massalin found this primitive to greatly simplify the implementation of certain lock-free data-structures. There is good reason to belief that there are other multi-word operations that would be useful for constructing lock-free data-structures. Rollforward gives the flexibility to do so. Another system that employed rollforward is Scheduler Activations [ABLL91].
Reference: [MK87] <author> J. Eliot B. Moss and Walter H. Kohler. </author> <title> Concurrency features for the Trellis/Owl language. </title> <booktitle> In European Conference on Object-Oriented Programming, number 276 in Lecture Notes in Computer Science, </booktitle> <pages> pages 171-180. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The third and fourth approach rid these limitations at the cost of slightly higher overheads. 2.1.1 Designated Sequences The first proposal in [BRE92] is to use designated instruction sequences to mark atomic sequences. This is also the technique used in <ref> [MK87] </ref>. Designated sequences must not appear anywhere but in atomic sequences. An interrupt handler can check whether the PC is inside an atomic sequence by matching the surrounding code according to a set of templates. <p> The bottom line is that rollforward makes software-based mutual exclusion a much more widely applicable technique. Using rollforward to guarantee atomicity is not a new idea. For example, it has been used successfully in the VAX runtime system of the Trellis/Owl language <ref> [MK87] </ref>. There, rollforward was implemented by emulating the instructions from the point of interruption to the end of the atomic sequence. We do not believe that emulation is feasible in the applications we envision. The complexity and overheads involved would be simply too big.
Reference: [Pri94] <author> Betty Prince. </author> <title> Memory in the fast lane. </title> <journal> IEEE Spectrum, </journal> <volume> 31(2) </volume> <pages> 38-41, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: However, in practice, this overhead is often in the 30 cycle range due to cache effects (PALcode is located at an operating system fixed address and therefore not inlinable). As the gap between memory system and CPU performance continues to grow <ref> [HP90a, Pri94] </ref>, techniques that yield good cache performance will become ever more important. Software-based methods that use designated sequences, a dynamic, or a hybrid scheme to register atomic sequences can all be inlined easily. Fourth, our experience is that rollforward is very practical.
Reference: [SCB93] <author> Daniel Stodolsky, J. Bradley Chen, and Brian N. Bershad. </author> <title> Fast interrupt priority management in operating system kernels. </title> <booktitle> In Proceedings of the Second Usenix Workshop on Microkernels and Other Kernel Architectures, </booktitle> <pages> pages 105-110. </pages> <publisher> Usenix, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: Although an order of magnitude faster than load-linked/store-conditionally, operations for disabling interrupts are usually privileged, meaning that they cannot be directly invoked by user processes. It is also the case that support for hierarchical priority levels is more expensive than one might hope <ref> [SCB93] </ref>. Because of the limitations of these two hardware-based approaches to implementing atomic sequences, Bershad, Redell, and Ellis have proposed a software-only implementation of mutual exclusion on uniprocessors [BRE92]. However, their solution is applicable only to simple atomic sequencesthose that involve only one store to shared memory. <p> Unfortunately, the paper gives only a superficial treatment of the issues involved with rollforward. It does not give any indications as to the cost or limitations of the technique. Finally, <ref> [SCB93] </ref> presents a technique called optimistic interrupt protection. The idea is to use delayed (lazy) evaluation to reduce the number of times that expensive interrupt level changing instructions have to be invoked.
Reference: [Sit92] <author> Richard L. </author> <title> Sites, editor. Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <address> Burlington, Massachusetts, </address> <year> 1992. </year> <title> Order number EY-L520E-DP. </title> <type> 17 </type>
Reference-contexts: Due to the trend of implementing processors that are suitable for use in shared-memory multiprocessors, however, these primitives have become quite expensive. For example, the Alpha architecture <ref> [Sit92] </ref> provides a multiprocessor-safe load-linked/store-conditionally instruction that, even on a uniprocessor, takes over 100 cycles to move a 64 bit integer atomically between two memory locations. This is slow andwithout any doubtit is possible reduce this overhead significantly. <p> For software-based schemes, this includes dynamic registration overheads, for example. The hardware on which we obtained these results consisted of a DEC 3000 Model 600 AXP workstation with an Alpha CPU operating at 175 MHz and an HP 9000/735 with a PA-RISC 1.1 CPU operating at 99 MHz <ref> [Sit92, HP90b] </ref>. All tests were small enough to fit in the cache and the reported results are the execution times when running in the cache (i.e., with a warm cache). Both machines provide timers with a resolution of a single CPU cycle. <p> That is, the code to change the interrupt priority level is no longer inlined. PALcode: The Alpha architecture defines a Privileged Architecture Library (PALcode). This library code is invoked via traps and executes in privileged kernel mode with interrupts turned off <ref> [Sit92] </ref>. We did not have the opportunity to implement the benchmarks as PALcode yet, but found that it takes at least 13 cycles just to invoke PALcode and return immediately from it. It is not possible to inline PALcode. <p> As shown in row splx, this is rather expensive. Finally, as the last row indicates, a pair of load-linked/store-conditionally instructions has a surprisingly high cost. Considering this and the rather long list of conditions under which a store-conditionally is (almost) guaranteed to fail <ref> [Sit92] </ref>, this does not appear to be an effective scheme to provide atomicity in a uniprocessor (and it probably was not meant to be so). 4.2 Overhead per Rollforward The overhead per rollforward consists of two components: the time to check whether it is safe to do a rollforward and the <p> Conservatively, we set O R = 480 cycles. On the other side, the best architecturally defined hardware-based scheme on the Alpha is PALcode <ref> [Sit92] </ref>. As shown in Table 1, the overhead per PALcode invocation is at least 13 cycles. Optimistically, O H is 13 cycles.
References-found: 14

