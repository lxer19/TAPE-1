URL: http://www.research.microsoft.com/~ymwang/papers/FTCS-1995-W.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/FTCS95CR.htm
Root-URL: http://www.research.microsoft.com
Title: Why Optimistic Message Logging  In Telecommunications Systems  
Author: Yennun Huang and Yi-Min Wang 
Address: Murray Hill, NJ 07974  
Affiliation: AT&T Bell Laboratories  
Note: Has Not Been Used  
Abstract: Much of the literature on message logging and checkpointing in the past decade has been based on a so-called optimistic approach [1] that places more emphasis on failure-free overhead than recovery efficiency. Our experience has shown that most telecommunications systems use a pessimistic approach because the main purpose of using message logging and checkpointing is to achieve fast and localized recovery, and the failure-free overhead of a pessimistic approach can often be made reasonably low by exploiting application-specific information. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. E. Strom and S. Yemini, </author> <title> "Optimistic recovery in distributed systems," </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> Vol. 3, No. 3, </volume> <pages> pp. 204-226, </pages> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: Traditional pessimistic logging protocols guarantee the atomicity either by implementing atomic three-way message delivery (to the receiver, receiver's backup and sender's backup) [4, 5] or atomic two-way transmission (to the receiver and a centralized recorder) [6]. The optimistic approach <ref> [1] </ref> was proposed based on the assumption that synchronously logging every message upon its receipt can result in an unacceptably high failure-free overhead. Since failures rarely occur, it is argued that minimizing failure-free overhead by sacrificing recovery efficiency can achieve the best overall system performance. <p> Since failures rarely occur, it is argued that minimizing failure-free overhead by sacrificing recovery efficiency can achieve the best overall system performance. By grouping a number of received messages and logging them onto stable storage in a single write operation, optimistic logging techniques <ref> [1, 7-9] </ref> can greatly reduce message logging overhead. However, since messages can be lost if a failure occurs before they are logged, some states of a failed process may not be recreatable. Therefore, consistent recovery in general cannot be achieved by a local recovery of the failed process.
Reference: [2] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini, </author> <title> "Volatile logging in n-fault-tolerant distributed systems," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 44-49, </pages> <year> 1988. </year>
Reference-contexts: 1 A Brief Literature Survey Much of the existing work on message logging and checkpointing assumes a piecewise deterministic (PWD) execution model <ref> [2] </ref>. Under the PWD assumption, each process execution is viewed as a number of state intervals bounded by nondeterministic message receiving events 1 . Execution within each state interval is completely deterministic, and hence replayable. <p> The recovery process usually takes longer compared to the pessimistic approach. In contrast with the above receiver-based logging protocols, several sender-based logging protocols <ref> [2, 10, 11] </ref> have also been proposed. Since sender-based techniques require only volatile logging of message contents (as opposed to stable logging), the message logging overhead can be further reduced.
Reference: [3] <author> E. N. Elnozahy and W. Zwaenepoel, "Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit," </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 41, No. 5, </volume> <pages> pp. 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: A protocol is called optimistic if it optimistically assumes that failures are rare events, so optimizing failure-free performance is more important than 1 Or more general nondeterministic events <ref> [3] </ref>. achieving good recovery performance. In contrast, a pessimistic protocol always pessimistically prepares for failures, so it is willing to pay higher failure-free overhead in order to recover faster should a failure occur. <p> However, since a failed process has to either request the logged messages from the sender logs or wait for the failed senders to regenerate and retransmit those messages, the recovery time is in general even higher. A new class of causal logging protocols <ref> [3, 11-13] </ref> has recently emerged in the literature. For each message, the message content is volatile-logged at the sender and the processing order is volatile-logged at the receiver's receiver.
Reference: [4] <author> A. Borg, J. Baumbach, and S. Glazer, </author> <title> "A message system supporting fault-tolerance," </title> <booktitle> in Proc. 9th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 90-99, </pages> <month> Oct. </month> <year> 1983. </year>
Reference-contexts: Traditional pessimistic logging protocols guarantee the atomicity either by implementing atomic three-way message delivery (to the receiver, receiver's backup and sender's backup) <ref> [4, 5] </ref> or atomic two-way transmission (to the receiver and a centralized recorder) [6]. The optimistic approach [1] was proposed based on the assumption that synchronously logging every message upon its receipt can result in an unacceptably high failure-free overhead.
Reference: [5] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle, </author> <title> "Fault tolerance under UNIX," </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> Vol. 7, No. 1, </volume> <pages> pp. 1-24, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: Traditional pessimistic logging protocols guarantee the atomicity either by implementing atomic three-way message delivery (to the receiver, receiver's backup and sender's backup) <ref> [4, 5] </ref> or atomic two-way transmission (to the receiver and a centralized recorder) [6]. The optimistic approach [1] was proposed based on the assumption that synchronously logging every message upon its receipt can result in an unacceptably high failure-free overhead.
Reference: [6] <author> M. L. Powell and D. L. Presotto, </author> <title> "Publishing: A reliable broadcast communication mechanism," </title> <booktitle> in Proc. 9th ACM Symp. Oper. Syst. Principles, </booktitle> <pages> pp. 100-109, </pages> <month> Oct. </month> <year> 1983. </year>
Reference-contexts: Traditional pessimistic logging protocols guarantee the atomicity either by implementing atomic three-way message delivery (to the receiver, receiver's backup and sender's backup) [4, 5] or atomic two-way transmission (to the receiver and a centralized recorder) <ref> [6] </ref>. The optimistic approach [1] was proposed based on the assumption that synchronously logging every message upon its receipt can result in an unacceptably high failure-free overhead. Since failures rarely occur, it is argued that minimizing failure-free overhead by sacrificing recovery efficiency can achieve the best overall system performance.
Reference: [7] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> "Recovery in distributed systems using optimistic message logging and checkpointing," </title> <journal> J. Algorithms, </journal> <volume> Vol. 11, </volume> <pages> pp. 462-491, </pages> <year> 1990. </year>
Reference: [8] <author> A. P. Sistla and J. L. Welch, </author> <title> "Efficient distributed recovery using message logging," </title> <booktitle> in Proc. 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 223-238, </pages> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Therefore, consistent recovery in general cannot be achieved by a local recovery of the failed process. It may require the rollbacks of those surviving processes whose states depend on the non-creatable states, and the rollbacks of the senders of lost messages in order to regenerate those messages <ref> [8] </ref>. The recovery process usually takes longer compared to the pessimistic approach. In contrast with the above receiver-based logging protocols, several sender-based logging protocols [2, 10, 11] have also been proposed.
Reference: [9] <author> T. T.-Y. Juang and S. Venkatesan, </author> <title> "Crash recovery with little overhead," </title> <booktitle> in Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pp. 454-461, </pages> <year> 1991. </year>
Reference: [10] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> "Sender-based message logging," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 14-19, </pages> <year> 1987. </year>
Reference-contexts: The recovery process usually takes longer compared to the pessimistic approach. In contrast with the above receiver-based logging protocols, several sender-based logging protocols <ref> [2, 10, 11] </ref> have also been proposed. Since sender-based techniques require only volatile logging of message contents (as opposed to stable logging), the message logging overhead can be further reduced.
Reference: [11] <author> E. N. Elnozahy and W. Zwaenepoel, </author> <title> "On the use and implementation of message logging," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 298-307, </pages> <year> 1994. </year>
Reference-contexts: The recovery process usually takes longer compared to the pessimistic approach. In contrast with the above receiver-based logging protocols, several sender-based logging protocols <ref> [2, 10, 11] </ref> have also been proposed. Since sender-based techniques require only volatile logging of message contents (as opposed to stable logging), the message logging overhead can be further reduced. <p> They are quite different from the long-running scientific applications that are usually considered in the literature <ref> [11, 15, 16] </ref>. In a long-running scientific application, it is generally assumed that the entire state of a process at any point is dependent on any previous state of the same process. <p> Module UI communicates with a server module CM which processes the requests by communicating with another server module DM. Module DM then connects to several switches through 3 Some limited application-independent optimizations may be performed <ref> [11, 15, 16] </ref> to reduce the checkpoint size. 4 In this paper, we focus on message logging for interprocess communications inside a system. Messages that are generated from outside the system must be synchronously logged for re-coverability, not just for fast recovery. the phone lines and conducts the tests. <p> This guarantees that no more than one message needs to be replayed for any recovery. The recovery time is measured to be less than 30 seconds. For System D, the pessimistic approach has another advantage. There are frequent output commit <ref> [11, 20] </ref> points in the system for controlling switches and committing database operations. The low failure-free overhead of the optimistic approach would have been offset by the frequent execution of output commit protocols.
Reference: [12] <author> L. Alvisi and K. Marzullo, </author> <title> "Message logging: Pessimistic, optimistic, and causal," </title> <booktitle> in Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pp. 229-236, </pages> <month> May </month> <year> 1995. </year>
Reference: [13] <author> L. Alvisi, B. Hoppe, and K. Marzullo, </author> <title> "Nonblocking and orphan-free message logging protocols," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 145-154, </pages> <year> 1993. </year>
Reference: [14] <author> L. Alvisi, </author> <title> "Fast and localized recovery with asynchronous logging." </title> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: Checkpoints 2 One possible way to achieve fast and localized recovery without the overhead of synchronous logging is to combine asynchronous receiver-based logging with causal logging as a mechanism to avoid orphans <ref> [14] </ref>. are typically taken in a transparent fashion: a process is interrupted when a timer expires and a snapshot of the entire state is saved 3 . The checkpoint interval is on the order of tens of minutes to hours.
Reference: [15] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel, </author> <title> "The performance of consistent checkpointing," </title> <booktitle> in Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pp. 39-47, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: They are quite different from the long-running scientific applications that are usually considered in the literature <ref> [11, 15, 16] </ref>. In a long-running scientific application, it is generally assumed that the entire state of a process at any point is dependent on any previous state of the same process. <p> Module UI communicates with a server module CM which processes the requests by communicating with another server module DM. Module DM then connects to several switches through 3 Some limited application-independent optimizations may be performed <ref> [11, 15, 16] </ref> to reduce the checkpoint size. 4 In this paper, we focus on message logging for interprocess communications inside a system. Messages that are generated from outside the system must be synchronously logged for re-coverability, not just for fast recovery. the phone lines and conducts the tests.
Reference: [16] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li, "Libckpt: </author> <title> Transparent checkpointing under Unix," </title> <booktitle> in Proc. Usenix Technical Conference, </booktitle> <pages> pp. 213-224, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: They are quite different from the long-running scientific applications that are usually considered in the literature <ref> [11, 15, 16] </ref>. In a long-running scientific application, it is generally assumed that the entire state of a process at any point is dependent on any previous state of the same process. <p> Module UI communicates with a server module CM which processes the requests by communicating with another server module DM. Module DM then connects to several switches through 3 Some limited application-independent optimizations may be performed <ref> [11, 15, 16] </ref> to reduce the checkpoint size. 4 In this paper, we focus on message logging for interprocess communications inside a system. Messages that are generated from outside the system must be synchronously logged for re-coverability, not just for fast recovery. the phone lines and conducts the tests.
Reference: [17] <author> Y. M. Wang, Y. Huang, K. P. Vo, P. Y. Chung, and C. Kintala, </author> <title> "Checkpointing and its applications," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 22-31, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The checkpoint interval is on the order of tens of minutes to hours. Recovery is performed by restoring the checkpointed state, and the execution returns from the point at which the checkpoint was taken <ref> [17] </ref>.
Reference: [18] <author> Y. Huang and C. Kintala, </author> <title> "Software implemented fault tolerance: Technologies and experience," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 2-9, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: At the loop boundary, much of the significant process state has been saved on stable storage and only a small amount of critical data <ref> [18] </ref> remains in the volatile memory. Checkpoints are typically taken in a non-transparent fashion: an application explicitly invokes the checkpoint function at the loop boundary, and only critical data is saved. The checkpoint interval is in the order of seconds to a few minutes. <p> Specifically, by replaying the messages directly from a local log file instead of waiting for the senders to regenerate and resend the messages, a failed process can often recover much faster. To illustrate that point, we next describe our experience with three applications which have used libft <ref> [18] </ref> to do checkpointing and pessimistic message logging. System G System G is a tool used by maintenance people to test telephone circuits for large customers. In each test session, an operator selects several phone lines through a user interface module UI.
Reference: [19] <author> G. Fowler, Y. Huang, D. Korn, and H. Rao, </author> <title> "A user-level replicated file system," </title> <booktitle> in Proc. Summer '93 USENIX, </booktitle> <pages> pp. 279-290, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: A checkpoint is taken when the size of a log file exceeds 6 megabytes. Without message logging and checkpointing, each primary machine failure would cause a loss of data and a long service disruption. By incorporating the logging and checkpointing capabilities of libft and REPL <ref> [19] </ref>, the system down time due to a primary machine failure is reduced to less than 90 seconds, which includes 15 seconds for activating the backup processes and 75 seconds or less for replaying logged messages. System D System D is a cross-connection system for fiber cables.
Reference: [20] <author> D. B. Johnson, </author> <title> "Efficient transparent optimistic rollback recovery for distributed application programs," </title> <booktitle> in Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pp. 86-95, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: This guarantees that no more than one message needs to be replayed for any recovery. The recovery time is measured to be less than 30 seconds. For System D, the pessimistic approach has another advantage. There are frequent output commit <ref> [11, 20] </ref> points in the system for controlling switches and committing database operations. The low failure-free overhead of the optimistic approach would have been offset by the frequent execution of output commit protocols.
Reference: [21] <author> Y. M. Wang, Y. Huang, W. K. Fuchs, C. Kintala, and G. Suri, </author> <title> "Progressive retry for software failure recovery in message-passing applications," </title> <journal> IEEE Trans. Comput., </journal> <note> under revision. </note>
Reference-contexts: The failure-free overhead of combining both pessimistic receiver and sender logging has been measured to be between 3% and 10% <ref> [21] </ref>, which should be acceptable to those applications that would require such an extra pro tection against lost messages. * For some applications, the problem of lost messages is simply ignored because they can tolerate the resulting errors.
References-found: 21

