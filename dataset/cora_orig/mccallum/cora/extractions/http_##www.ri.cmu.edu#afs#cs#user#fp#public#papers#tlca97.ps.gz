URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/tlca97.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Email: joelle.despeyroux@sophia.inria.fr  ffpjcarsteng@cs.cmu.edu  
Phone: 2  
Title: Primitive Recursion for Higher-Order Abstract Syntax  
Author: Joelle Despeyroux Frank Pfenning and Carsten Schurmann 
Address: F-06902 Sophia-Antipolis Cedex, France  Pittsburgh PA 15213, USA  
Affiliation: 1 INRIA,  Carnegie Mellon University,  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: The basic idea is to represent variables of the object language by variables in the meta-language. Consequently, object language constructs which bind variables must be represented by meta-language constructs which bind the corresponding variables. This deceptively simple idea, which goes back to Church <ref> [1] </ref> and Martin-Lof's system of arities [18], has far-reaching consequences for the methodology of logical frameworks.
Reference: 2. <author> Thierry Coquand, Bengt Nordstrom, Jan M. Smith, and Bjorn von Sydow. </author> <title> Type theory and programming. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 52 </volume> <pages> 203-228, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: For larger applications, writing programs by iteration becomes tedious and error-prone and a pattern-matching calculus such as employed in ALF <ref> [2] </ref> or proposed by Jouannaud and Okada [11] seems more practical. Our informal notation in the examples provides some hints what concrete syntax one might envision for an implementation along these lines.
Reference: 3. <author> Rowan Davies and Frank Pfenning. </author> <title> A modal analysis of staged computation. </title> <editor> In Jr. Guy Steele, editor, </editor> <booktitle> Proceedings of the 23rd Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 258-270, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: The system is non-trivial since we may also abstract over objects of type 2A, but fortunately it is well understood and corresponds (via an extension of the Curry-Howard isomorphism) to the intuitionistic variant of S 4 <ref> [3] </ref>. In Section 4 we introduce schemas for defining functions by iteration and case distinction which require the subject to be of type 2B. We can recover the ordinary scheme of primitive recursion for type nat if we also add pairs to the language. <p> Just as the modal type 2A, pairs are lazy and values of these types are not observable|ultimately we are only interested in canonical forms of pure type. The formulation of the modal -calculus below is copied from <ref> [3] </ref> and goes back to [22].
Reference: 4. <author> Joelle Despeyroux, Amy Felty, and Andre Hirschowitz. </author> <title> Higher-order abstract syntax in Coq. </title> <editor> In M. Dezani-Ciancaglini and G. Plotkin, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 124-138, </pages> <address> Edinburgh, Scotland, April 1995. </address> <publisher> Springer-Verlag LNCS 902. </publisher>
Reference-contexts: On the other hand, higher-order representations are no longer inductive in the usual sense, which means that standard techniques for reasoning by induction do not apply. Various attempts have been made to preserve the advantages of higher-order abstract syntax in a setting with strong induction principles <ref> [5, 4] </ref>, but none of these is entirely satisfactory from a practical or theoretical point of view. In this paper we take a first step towards reconciling higher-order abstract syntax with induction by proposing a system of primitive recursive functionals that permits iteration over subjects of functional type. <p> A similar formulation of these laws is used in [7] for the treatment of recursion. We also plan to reexamine applications in the realm of functional programming [15, 8] and related work on reasoning about higher-order abstract syntax with explicit induction <ref> [5, 4] </ref> or definitional reflection [13]. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development.
Reference: 5. <author> Joelle Despeyroux and Andre Hirschowitz. </author> <title> Higher-order abstract syntax with induction in Coq. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 159-173, </pages> <address> Kiev, Ukraine, July 1994. </address> <publisher> Springer-Verlag LNAI 822. </publisher>
Reference-contexts: On the other hand, higher-order representations are no longer inductive in the usual sense, which means that standard techniques for reasoning by induction do not apply. Various attempts have been made to preserve the advantages of higher-order abstract syntax in a setting with strong induction principles <ref> [5, 4] </ref>, but none of these is entirely satisfactory from a practical or theoretical point of view. In this paper we take a first step towards reconciling higher-order abstract syntax with induction by proposing a system of primitive recursive functionals that permits iteration over subjects of functional type. <p> A similar formulation of these laws is used in [7] for the treatment of recursion. We also plan to reexamine applications in the realm of functional programming [15, 8] and related work on reasoning about higher-order abstract syntax with explicit induction <ref> [5, 4] </ref> or definitional reflection [13]. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development.
Reference: 6. <author> Joelle Despeyroux, Frank Pfenning, and Carsten Schurmann. </author> <title> Primitive recursion for higher-order abstract syntax. </title> <type> Technical Report CMU-CS-96-172, </type> <institution> Carnegie Mel-lon University, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: Finally, Section 6 assesses the results, compares some related work, and outlines future work. A full version of this paper with complete technical developments and detailed proofs is accessible as http://www.cs.cmu.edu/~carsten/CMU-CS-96-172.ps.gz <ref> [6] </ref>. 2 Higher-Order Abstract Syntax Higher-order abstract syntax exploits the full expressive power of a typed - calculus for the representation of an object language, where -abstraction provides the mechanism to represent binding. <p> A number of functions can be defined elegantly in this representation. Among them are the conversion from type exp to a representation using de Bruijn indices and one-step parallel reduction. The latter requires mutual iteration and pairs (see <ref> [6] </ref>). The following example illustrates two concepts: mutually inductive types and iteration over the form of a (parametric!) function. Example 8 Substitution in normal forms. Substitution is already directly definable by application, but one may also ask if there is a structural definition in the style of [16]. <p> For example, we can test if a given (parametric!) function is the identity or not. The typing rules and operational semantics for case are similar, but simpler than those for iteration. We therefore elide it here and refer the interested reader to <ref> [6] </ref>. 5 Meta-Theory The goal of this subsection is to show that the modal -calculus obeys the type preservation property and that it is a conservative extension of the simply typed -calculus defined in Section 2. We prove this by Tait's method, often called an argument by logical relations. <p> If ; ` M : A and ` ; % 2 [; ] then ` [; %](M ) 2 [[A]] The proof of this lemma is rather difficult. Due to the restrictions in length we are not presenting any details here, but refer the interested reader to <ref> [6] </ref>. Now, an easy inductive argument using Lemma 9 shows that the identity substitution (; id ), which maps all variables defined in to themselves, indeed lies within the logical relation [; ]. The soundness of typing is hence an immediate corollary of Lemma 11. Theorem 12 Soundness of typing.
Reference: 7. <author> Thierry Despeyroux and Andre Hirschowitz. </author> <title> Some theory for abstract syntax and induction. </title> <type> Draft manuscript. </type>
Reference-contexts: This may be the critical insight required for a dependently typed version of our calculus. A similar formulation of these laws is used in <ref> [7] </ref> for the treatment of recursion. We also plan to reexamine applications in the realm of functional programming [15, 8] and related work on reasoning about higher-order abstract syntax with explicit induction [5, 4] or definitional reflection [13]. Acknowledgments.
Reference: 8. <author> Leonidas Fegaras and Tim Sheard. </author> <title> Revisiting catamorphisms over datatypes with embedded functions (or, programs from outer space). </title> <booktitle> In Proceedings of 23rd Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 284-294, </pages> <address> St. Pe-tersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: In our system we view iteration as replacing constructors of a canonical term by functions of appropriate type, which is also the idea behind catamorphisms <ref> [8] </ref>. In the case of natural numbers, we replace z : nat by a term M z : A and s : nat ! nat by a function M s : A ! A. Thus iteration over natural numbers replaces type nat by A. <p> The system of Meijer and Hutton [14] and its refinement by Fe-garas and Sheard <ref> [8] </ref> are also related in that they extend primitive recursion to encompass functional objects. However, they treat functional objects extensionally, while our primitives are designed so we can analyze the internal structure of -abstractions directly. <p> However, they treat functional objects extensionally, while our primitives are designed so we can analyze the internal structure of -abstractions directly. Fegaras and Sheard also note the problem with adequacy and design more stringent type-checking rules in Section 3.4 of <ref> [8] </ref> to circumvent this problem. In contrast to our system, their proposal does not appear to have a logical interpretation. <p> This may be the critical insight required for a dependently typed version of our calculus. A similar formulation of these laws is used in [7] for the treatment of recursion. We also plan to reexamine applications in the realm of functional programming <ref> [15, 8] </ref> and related work on reasoning about higher-order abstract syntax with explicit induction [5, 4] or definitional reflection [13]. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development.
Reference: 9. <author> Kurt Godel. </author> <title> On an extension of finitary mathematics which has not yet been used. </title> <editor> In Solomon Feferman et al., editors, Kurt Godel, </editor> <booktitle> Collected Works, </booktitle> <volume> Volume II, </volume> <pages> pages 271-280. </pages> <publisher> Oxford University Press, </publisher> <year> 1990. </year> <type> 3 personal communication </type>
Reference-contexts: The resulting system allows, for example, iteration over the structure of expressions from the untyped -calculus when represented using higher-order abstract syntax. It is general enough to permit iteration over objects of any simple type, constructed over any simply typed signature and thereby encompasses Godel's system T <ref> [9] </ref>. Moreover, it is conservative over the simply-typed -calculus which means that the compositional adequacy of encodings in higher-order abstract syntax is preserved.
Reference: 10. <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining log-ics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Moreover, it is conservative over the simply-typed -calculus which means that the compositional adequacy of encodings in higher-order abstract syntax is preserved. We view our calculus as an important first step towards a system which allows the methodology of logical frameworks such as LF <ref> [10] </ref> to be incorporated into systems such as Coq [20] or ALF [12]. <p> For example, we can see that peq will never contain a fi-redex. Moreover, the argument to lam which has type exp ! exp will always be a -abstraction. Thus the image of the translation in this representation methodology is always a fi-normal and -long form. Following <ref> [10] </ref>, we call these forms canonical as defined by the following two judgments.
Reference: 11. <author> Jean-Pierre Jouannaud and Mitsuhiro Okada. </author> <title> A computation model for executable higher-order algebraic specification languages. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Proceedings of the 6th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 350-361, </pages> <address> Am-sterdam, The Netherlands, July 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: For larger applications, writing programs by iteration becomes tedious and error-prone and a pattern-matching calculus such as employed in ALF [2] or proposed by Jouannaud and Okada <ref> [11] </ref> seems more practical. Our informal notation in the examples provides some hints what concrete syntax one might envision for an implementation along these lines.
Reference: 12. <author> Lena Magnusson. </author> <title> The Implementation of ALF|A Proof Editor Based on Martin-Lof's Monomorphic Type Theory with Explicit Substitution. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology and Goteborg University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: We view our calculus as an important first step towards a system which allows the methodology of logical frameworks such as LF [10] to be incorporated into systems such as Coq [20] or ALF <ref> [12] </ref>. The remainder of this paper is organized as follows: Section 2 reviews the idea of higher order abstract syntax and introduces the simply typed -calculus ( ! ) which we extend to a modal -calculus in Section 3. Section 4 then presents the concept of iteration.
Reference: 13. <author> Raymond McDowell and Dale Miller. </author> <title> A logic for reasoning about logic specifications. </title> <type> Draft manuscript, </type> <month> July </month> <year> 1996. </year>
Reference-contexts: A similar formulation of these laws is used in [7] for the treatment of recursion. We also plan to reexamine applications in the realm of functional programming [15, 8] and related work on reasoning about higher-order abstract syntax with explicit induction [5, 4] or definitional reflection <ref> [13] </ref>. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development. During this time we have discussed various aspects of higher-order abstract syntax, iteration, and induction with too many people to acknowledge them individually.
Reference: 14. <author> Erik Meijer and Graham Hutton. </author> <title> Bananas in space: Extending fold and unfold to exponential types. </title> <booktitle> In Proceedings of the 7th Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> La Jolla, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Due to the presence of unrestricted recursion and the absence of a modal operator, Miller's system is computationally adequate, but has a much weaker meta-theory which would not be sufficient for direct use in a logical framework. The system of Meijer and Hutton <ref> [14] </ref> and its refinement by Fe-garas and Sheard [8] are also related in that they extend primitive recursion to encompass functional objects. However, they treat functional objects extensionally, while our primitives are designed so we can analyze the internal structure of -abstractions directly.
Reference: 15. <author> Dale Miller. </author> <title> An extension to ML to handle bound variables in data structures: Preliminary report. </title> <booktitle> In Proceedings of the Logical Frameworks BRA Workshop, </booktitle> <address> Nice, France, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: To our knowledge, this is the first system in which it is possible to safely program functionally with higher-order abstract syntax representations. It thus complements and refines the logic programming approach to programming with such representations [17, 21]. Our work was inspired by Miller's system <ref> [15] </ref>, which was presented in the context of ML. Due to the presence of unrestricted recursion and the absence of a modal operator, Miller's system is computationally adequate, but has a much weaker meta-theory which would not be sufficient for direct use in a logical framework. <p> This may be the critical insight required for a dependently typed version of our calculus. A similar formulation of these laws is used in [7] for the treatment of recursion. We also plan to reexamine applications in the realm of functional programming <ref> [15, 8] </ref> and related work on reasoning about higher-order abstract syntax with explicit induction [5, 4] or definitional reflection [13]. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development.
Reference: 16. <author> Dale Miller. </author> <title> Unification of simply typed lambda-terms as logic programming. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Eighth International Logic Programming Conference, </booktitle> <pages> pages 255-269, </pages> <address> Paris, France, June 1991. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The following example illustrates two concepts: mutually inductive types and iteration over the form of a (parametric!) function. Example 8 Substitution in normal forms. Substitution is already directly definable by application, but one may also ask if there is a structural definition in the style of <ref> [16] </ref>. Normal forms of the untyped -calculus are represented by the type nf with an auxiliary definition for atomic forms of type at.
Reference: 17. <author> Dale Miller. </author> <title> Abstract syntax and logic programming. </title> <booktitle> In Proceedings of the First and Second Russian Conferences on Logic Programming, </booktitle> <pages> pages 322-337, </pages> <address> Irkutsk and St. Petersburg, Russia, 1992. </address> <publisher> Springer-Verlag LNAI 592. </publisher>
Reference-contexts: To our knowledge, this is the first system in which it is possible to safely program functionally with higher-order abstract syntax representations. It thus complements and refines the logic programming approach to programming with such representations <ref> [17, 21] </ref>. Our work was inspired by Miller's system [15], which was presented in the context of ML.
Reference: 18. <author> Bengt Nordstrom, Kent Petersson, and Jan M. Smith. </author> <title> Programming in Martin-Lof's Type Theory: An Introduction, </title> <booktitle> volume 7 of International Series of Monographs on Computer Science. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference-contexts: The basic idea is to represent variables of the object language by variables in the meta-language. Consequently, object language constructs which bind variables must be represented by meta-language constructs which bind the corresponding variables. This deceptively simple idea, which goes back to Church [1] and Martin-Lof's system of arities <ref> [18] </ref>, has far-reaching consequences for the methodology of logical frameworks.
Reference: 19. <author> Martin Odersky. </author> <title> A functional theory of local names. </title> <booktitle> In Proceedings of the 21st Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 48-59, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: We model this in the informal presentation by introducing new parameters (written as -x : B: M ) using Odersky's notation <ref> [19] </ref>. This makes a dynamic extension of the function definition necessary to encompass the new parameters (written as "where f (x) = M "). Example 7 Counting variable occurrences.
Reference: 20. <author> Christine Paulin-Mohring. </author> <title> Inductive definitions in the system Coq: Rules and properties. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 328-345, </pages> <address> Utrecht, The Netherlands, March 1993. </address> <publisher> Springer-Verlag LNCS 664. </publisher>
Reference-contexts: We view our calculus as an important first step towards a system which allows the methodology of logical frameworks such as LF [10] to be incorporated into systems such as Coq <ref> [20] </ref> or ALF [12]. The remainder of this paper is organized as follows: Section 2 reviews the idea of higher order abstract syntax and introduces the simply typed -calculus ( ! ) which we extend to a modal -calculus in Section 3. Section 4 then presents the concept of iteration. <p> Note that type subordination is built into calculi where inductive types are defined explicitly (such as the Calculus of Inductive Constructions <ref> [20] </ref>); here it must be recovered from the signature since we impose no ordering constraints except that a type must be declared before it is used.
Reference: 21. <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: To our knowledge, this is the first system in which it is possible to safely program functionally with higher-order abstract syntax representations. It thus complements and refines the logic programming approach to programming with such representations <ref> [17, 21] </ref>. Our work was inspired by Miller's system [15], which was presented in the context of ML.
Reference: 22. <author> Frank Pfenning and Hao-Chi Wong. </author> <title> On a modal -calculus for S4. </title> <editor> In S. Brookes and M. Main, editors, </editor> <booktitle> Proceedings of the Eleventh Conference on Mathematical Foundations of Programming Sematics, </booktitle> <address> New Orleans, Louisiana, </address> <month> March </month> <year> 1995. </year> <note> To appear in Electronic Notes in Theoretical Computer Science, Volume 1, </note> <editor> Elsevier. </editor> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Just as the modal type 2A, pairs are lazy and values of these types are not observable|ultimately we are only interested in canonical forms of pure type. The formulation of the modal -calculus below is copied from [3] and goes back to <ref> [22] </ref>.
References-found: 22

