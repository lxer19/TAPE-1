URL: http://www.cs.toronto.edu/~chechik/courses97/csc2108/projects/web/2.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/courses97/csc2108/projects/web/
Root-URL: 
Email: dimi@cs.toronto.edu  biechele@cs.toronto.edu  
Title: CSC2108F Automated Verification A Case Study Production Cell with  
Author: PROMELA/SPIN Dimitrie O. Paun Bernd Biechele 
Affiliation: University of Toronto  
Abstract: In this project we develop a software controller for a production cell system. The main objective is to find out if PROMELA/SPIN is an appropriate environment for developing embedded real-time systems. We describe the production cell hardware model and its requirements. Subsequently, we describe the model of a distributed and concurrent controller for it. Furthermore, we mention some required properties we could prove with SPIN based on our model as well as those we could not prove. We outline a transformation scheme of the PROMELA language to C code. Finally, we describe some experiences and draw conclusions. 
Abstract-found: 1
Intro-found: 1
Reference: [LL 95] <author> Claus Lewerentz, Thomas Lindner (Eds.) </author> <title> Formal Development of Reactive Systems. Case Study Production Cell. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: PROMELA, its input language, is a non-deterministic language, loosely based on Dijkstra's guarded command notation and Hoare's language CSP. It allows to specify synchronous and asynchronous message passing via channels. The case study "Control Software for an Industrial Production Cell" 2 , as described in <ref> [LL 95] </ref>, was initiated at the Forschungszentrum Informatik (FZI) in Karlsruhe, Germany. Its intention was to show the usefulness of formal methods for critical software systems and to show their applicability to real-world examples. <p> Its intention was to show the usefulness of formal methods for critical software systems and to show their applicability to real-world examples. Many authors contributed to this case study and 18 of these contributions are summarized and compared in <ref> [LL 95] </ref>. 2 The Task The goal of the project is to model, design and implement a production cell controller that has certain proven properties. The production cell processes metal blanks which are conveyed to a press by a feed belt. <p> The traveling crane picks up the metal plate, moves to the feed belt, and unloads the metal plate on it. Of course, this is a rather simplified description of the system. For the complete specification of the production cell, refer to <ref> [LL 95] </ref>. 3 Modeling Reactive Systems This section describes the way we modeled the system. We explain some of the abstractions, modeling decisions and drawbacks of our approach. 4 3.1 Overview Our model was strongly influenced by the need to minimize the state space requirements for checking the model. <p> Thus, a refinement formalism is required if formal methods are to be used for more significant projects. 12 A The Properties This section describes state variables and the LTL formulas used to prove the required properties as specified in <ref> [LL 95] </ref> (with corresponding numbering). A.1 The State Variables To prove a property, all variables included in its corresponding formula have to be declared globally.
Reference: [HO 97] <author> G.J. Holzmann, </author> <title> The Model Checker SPIN, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 279-295, Vol. 23, No. 5, </volume> <month> May </month> <year> 1997 </year>
Reference-contexts: One approach to support development of correct software is model checking. A model checker starts from some sort of specification and tries to explore all possible states that an execution of this specification might have. SPIN 1 , as described in <ref> [HO 97] </ref> is one of such tools, developed at Bell Labs. PROMELA, its input language, is a non-deterministic language, loosely based on Dijkstra's guarded command notation and Hoare's language CSP. It allows to specify synchronous and asynchronous message passing via channels.
Reference: [NBF 96] <author> Bradford Nichols, Dick Buttlar, Jackie Farell. </author> <title> Pthreads Programming. </title> <publisher> O'Reilly & Associates, </publisher> <year> 1996. </year>
Reference-contexts: B Implementation Details A relatively clean way of translating the PROMELA code to C is by the use of a multi-threading library <ref> [NBF 96] </ref>. We will describe below the translation of each PROMELA construct that we used. We made the following simplifying assumptions: * We assume that read and assignment statements are atomic.
Reference: [DAC 98] <author> Matthew B. Dwyer, George S. Avrunin and James C. Corbett. </author> <title> Property Specification Patterns for Finite-state Verification, </title> <booktitle> 2nd Workshop on Formal Methods in Software Practice, </booktitle> <month> March </month> <year> 1998. </year>
Reference: [CA 95] <author> Thierry Cattel. </author> <title> Process Control Design Using SPIN, Spin Workshop, </title> <address> Montreal, Canada, </address> <year> 1995. </year>
Reference-contexts: For an outline of the translation patterns we used, see Appendix B. 6 Related Work After finishing most parts of the project, we discovered that similar work on a production cell controller had been done by Thierry Cattel as described in <ref> [CA 95] </ref>. He chose an approach of several layers with decreasing levels of abstraction. As described in [CA 95], all properties have been verified on a very high level of abstraction. On the more detailed levels not all properties have been verified. <p> used, see Appendix B. 6 Related Work After finishing most parts of the project, we discovered that similar work on a production cell controller had been done by Thierry Cattel as described in <ref> [CA 95] </ref>. He chose an approach of several layers with decreasing levels of abstraction. As described in [CA 95], all properties have been verified on a very high level of abstraction. On the more detailed levels not all properties have been verified. The correspondence between models on different levels of abstraction were validated using separate models in Concurrency Workbench [CPS 93]. <p> Our approaches differ in that we aimed at deriving a C implementation rather than an implementation in languages that have sophisticated communication primitives, like the one used in <ref> [CA 95] </ref>. 7 Conclusions The behavior of concurrent processes is too complex to handle manually, even for a fairly simple system. During the development process, the tools detected errors in our model and were of invaluable help in tracking down the problem.
Reference: [CPS 93] <author> R. Cleveland, J. Parrow, B. Steffen. </author> <title> The Concurrency Workbench: A semantics-based Tool for the Verification of Concurrent Systems. </title> <journal> ACM TOPLAS, </journal> <volume> Vol. 5, No. 1, </volume> <month> January </month> <year> 1993 </year> <month> 22 </month>
Reference-contexts: As described in [CA 95], all properties have been verified on a very high level of abstraction. On the more detailed levels not all properties have been verified. The correspondence between models on different levels of abstraction were validated using separate models in Concurrency Workbench <ref> [CPS 93] </ref>. Since this modeling was done manually, it is a potential source of errors. In our approach we verified all properties on a very low level of abstraction.
References-found: 6

