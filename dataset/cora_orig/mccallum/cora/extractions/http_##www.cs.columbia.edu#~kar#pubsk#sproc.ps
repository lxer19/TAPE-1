URL: http://www.cs.columbia.edu/~kar/pubsk/sproc.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: kar@cs.columbia.edu  
Title: A Syntactic Stratification Condition Using Constraints  
Author: Kenneth A. Ross 
Keyword: Negation, stratification, semantics, logic programming, constraints, deductive databases.  
Address: New York, NY 10027  
Affiliation: Department of Computer Science Columbia University  
Abstract: Stratification conditions for logic programs aim to ensure a two-valued semantics by restricting the class of allowable programs. Previous stratification conditions suffer from one of two problems. Some (such as modular stratification and weak stratification) are semantic, and cannot be recognized without examining the facts in addition to the rules of the program. Others (such as stratification and local stratification) are syntactic, but do not allow a number of useful examples. A nonsemantic version of modular stratification, i.e., whether a program is modularly stratified for all extensional databases, is shown to be undecidable. We propose a condition that generalizes local stratification, that ensures a two-valued well-founded model, and that can be syntactically determined from the rules and some constraints on the facts in the program. We call this condition "Universal Constraint Stratification." While not every modularly stratified program is universally constraint stratified, all of the well-known practical examples of modularly stratified programs are universally constraint stratified under appropriate natural constraints. In addition, there exist universally constraint stratified programs that are not modularly stratified. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Brodsky and Y. Sagiv. </author> <title> Inference of monotonicity constraints in Datalog programs. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: The constraints we allow are monotonicity constraints <ref> [1] </ref>. Monotonicity constraints specify that one argument of a predicate is less than another according to some partial order. Our approach can be outlined as follows: * Specify a set of monotonicity constraints on the EDB predicates. <p> We would like to phrase the question as whether a program has a two-valued well-founded model for all EDB relations that satisfy some acyclicity constraints. In this section we present the notion of monotonicity constraints from <ref> [1] </ref> in order to be able to phrase such constraints. We shall also look at the problem of inferring constraints on IDB predicates given constraints on the EDB predicates. <p> In the context of function-free programs, the finiteness of the partial order is reasonable given the finiteness of the database. We shall use the term "constraint" to mean a disjunctive constraint, unless otherwise noted. We have chosen a slightly more general notation for monotonicity constraints than that used in <ref> [1] </ref>. In [1], the authors effectively restrict the formula F in the definition above to be a single atom with distinct variables as arguments. We shall need the more general notation later in the paper. Lemma 4.1: ([1]) It can be algorithmically determined for two disjunctive constraints C and D, whether <p> We shall use the term "constraint" to mean a disjunctive constraint, unless otherwise noted. We have chosen a slightly more general notation for monotonicity constraints than that used in <ref> [1] </ref>. In [1], the authors effectively restrict the formula F in the definition above to be a single atom with distinct variables as arguments. We shall need the more general notation later in the paper. Lemma 4.1: ([1]) It can be algorithmically determined for two disjunctive constraints C and D, whether C j= <p> A constraint C is satisfiable if there exists a substitution and a partial order &lt; such that C &lt; is true; otherwise C is said to be unsatisfiable. 2 Lemma 4.3: (<ref> [1] </ref>) A constraint C is unsatisfiable iff it is inconsistent. Our context is more general than that of [1] since we allow negative subgoals. 2 While Brodsky and Sagiv's method is sound and complete for datalog programs, it may fail to detect monotonicity constraints for programs like p (X; Y ) e (X; Y ); :e (X; Y ): Even though there are no restrictions on relation e, the <p> The envelope of P is p (X; Y ) e (X; Y ) from which p (X; Y ) : Y mc X is derivable using the techniques of <ref> [1] </ref>. Thus, p (X; Y ) : Y mc X is true in P given E. 2 Definition 4.4: Let P be a program, E a constraint set on the EDB predicates of P , and C a constraint set on the IDB predicates of P . <p> Y ); t (Y ); s (Y; a; V ) we can infer the constraint r : (X mc W ) ^ (Y mc b) ^ (Y = ec a) ^ (V = ec a): There is a sound, complete, and effective way to perform this inference using techniques from <ref> [1] </ref>. We shall assume that we have performed this inference for every rule r. We may also want to "go the other way" by projecting a constraint on a rule onto the arguments of some of its atoms. <p> These transformations include inferring constraints, performing projections, performing compositions, and testing for satisfiability. That each of these steps is algorithmic follows from Lemmas 4.2 and 4.3, and from the soundness, completeness, and decidability of the constraint inference problem as shown in <ref> [1] </ref>. The second issue is that universal constraint stratification requires that all cycles with a negative edge have constraints whose cyclic composition is unsatisfiable. Even for simple programs it is possible that there are infinitely many such cycles.
Reference: [2] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. Recent work has shown that there are interesting logic programs that are not stratifiable but for which a natural, unambiguous semantics exists. The well-founded semantics [9] and the stable model semantics <ref> [2] </ref> are two (closely related) proposals for defining the semantics of logic programs, whether stratified or not. For stratified programs they both coincide with the perfect model semantics. The well-founded semantics is a three-valued semantics. Literals may be true, false or undefined.
Reference: [3] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to automata theory, languages, and computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: Proof : (Sketch) The first step is to show that testing whether a context free language L (not including the empty string 1 ) has the property that LL L, is undecidable. This proof uses standard techniques from <ref> [3] </ref>. The next step is to perform a translation from context-free grammars to datalog programs using Shmueli's construction. Containment of the corresponding context-free languages can then be expressed as the containment of a certain binary predicate g in the transformed program.
Reference: [4] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> New York, 2nd edition, </address> <year> 1987. </year>
Reference-contexts: Further, there are some constraint stratified programs that are not modularly stratified. We prove that constraint stratified programs have a two-valued well-founded semantics, and that constraint stratification generalizes local stratification. 2 Terminology We consider normal logic programs without function symbols <ref> [4] </ref>, also known as "Datalog" programs with negation, and follow standard logic-programming conventions.
Reference: [5] <author> T. C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: 1 Introduction Much recent work has concerned defining the semantics of negation in deductive databases. The "perfect model semantics" <ref> [5] </ref> has been generally accepted as natural, and is the basis for several experimental deductive database systems. Unfortunately, the perfect model semantics applies only to programs that are stratified (or locally stratified). A stratified program is one in which, effectively, there is no predicate that depends negatively on itself.
Reference: [6] <author> K. A. Ross. </author> <title> Modular stratification and magic sets for Datalog programs with negation. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1990. </year> <note> Full version to appear in J.ACM. </note>
Reference-contexts: In many cases, two truth values suffice to model the situation under consideration. So we desire a condition on the program, more general than stratification, that ensures that the well-founded semantics is two-valued. In <ref> [6] </ref> the present author proposed such a class, which was termed the class of modularly stratified programs. For modularly stratified programs the well-founded semantics is total (i.e., makes every ground literal either true or false). <p> For modularly stratified programs the well-founded semantics is total (i.e., makes every ground literal either true or false). The well-founded semantics and the stable model semantics coincide for modularly stratified programs, a consequence of the fact that the well-founded model is total. Modularly stratified programs also allow subgoal-at-a-time evaluation <ref> [6] </ref>. A program is modularly stratified if and only if its mutually recursive components are locally stratified once all instantiated rules with a false subgoal that is defined in a "lower" component are removed. Unfortunately, the definition of modular stratification is semantic rather than syntactic. <p> We demonstrate that universal constraint stratification can be checked algorithmically. Not every modularly stratified program is universally constraint stratified. However, we find, perhaps surprisingly, that all of the common examples of modularly stratified programs, including all of the examples from <ref> [6] </ref>, are constraint stratified. Further, there are some constraint stratified programs that are not modularly stratified. <p> Definition 2.1: The envelope of a program P is P with all negative subgoals removed. 2 3 Modular Stratification We now present the concept of modular stratification, originally defined in <ref> [6] </ref>. Definition 3.1: (Reduction of a component) Let F be a program component, and let S be the set of predicates used by F . Let M be a two-valued interpretation over the universe U for the predicates in S. <p> M for the union of all components F 0 F , and (b) The reduction of F modulo M is locally stratified. 2 Theorem 3.1: (<ref> [6] </ref>) Every modularly stratified program has a total well-founded model that is its unique stable model. 3.1 Examples We present a number of examples from [6] of modularly stratified programs. Note that none of these examples is locally stratified. Example 3.1: Consider the program P consisting of the rule w (X) m (X; Y ); :w (Y ) together with some facts about m. <p> 2 mc b) ^ (t h : 2 = ec a) ^ (t h : 2 = ec s b : 1) 2 5 Universal Constraint Stratification In this section we define a stratification condition that is general enough to include all of the examples from Section 3.1 originally from <ref> [6] </ref>, while also including some programs that are not modularly stratified. In a later section, we shall demonstrate that the condition is syntactic. The intuition behind our stratification condition is that we shall start with a set of constraint formulas describing the EDB of a program. <p> One applies constraint techniques to the uninstantiated rules. As far as the author is aware, there is no other proposed stratification condition on datalog programs that simultaneously (a) Is syntactic, (b) Generalizes local stratification, (c) Ensures a two-valued well-founded model, and (d) Admits the examples from <ref> [6] </ref> (Section 3.1) of useful programs that are not locally stratified. Acknowledgements This research was supported by NSF grants IRI-9209029 and CDA-90-24735, by a grant from the AT&T Foundation, by a David and Lucile Packard Foundation Fellowship in Science and Engineering, and by a Sloan Foundation Fellowship.
Reference: [7] <author> K. A. Ross. </author> <title> Constraint stratification. </title> <booktitle> In Proceedings of the ICLP Workshop on Deductive Databases, </booktitle> <pages> pages 101-116, </pages> <month> June </month> <year> 1994. </year> <note> Available as German GMD Society Publication Series number 231, ISBN 3-88457-231-8. </note>
Reference-contexts: Repeat the previous step for 2 sub-cycles, 3 sub-cycles, and so on. Since there are only finitely many inequivalent constraints, we must eventually terminate. Theorem 6.1: Universal constraint stratification is syntactic. 7 Related Work In <ref> [7] </ref> the present author defined the notion of "constraint stratification." That notion is more restricted than universal constraint stratification in two ways. First, constraint stratification requires that a partial order &lt; be specified in advance. <p> In this paper we do not suffer from this problem because we define universal constraint stratification in terms of an arbitrary partial order. This extension leads to much of the technical complexity of this paper. A second way that this paper improves upon <ref> [7] </ref> is that, unlike [7], one does not need to check all instances of a set of rules in order to determine universal constraint stratification. One applies constraint techniques to the uninstantiated rules. <p> In this paper we do not suffer from this problem because we define universal constraint stratification in terms of an arbitrary partial order. This extension leads to much of the technical complexity of this paper. A second way that this paper improves upon <ref> [7] </ref> is that, unlike [7], one does not need to check all instances of a set of rules in order to determine universal constraint stratification. One applies constraint techniques to the uninstantiated rules.
Reference: [8] <author> O. Shmueli. </author> <title> Decidability and expressiveness aspects of logic queries. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1987. </year>
Reference-contexts: As a result, one cannot, in general, recognize when a datalog program is modularly stratified for all EDBs. To establish this result we need a preliminary lemma, which uses a construction of Shmueli <ref> [8] </ref>. Lemma 3.2: It is recursively unsolvable to determine, for an arbitrary Datalog program whether a given relation is transitively closed for all possible assignments of relations to EDB predicates.
Reference: [9] <author> A. Van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. Recent work has shown that there are interesting logic programs that are not stratifiable but for which a natural, unambiguous semantics exists. The well-founded semantics <ref> [9] </ref> and the stable model semantics [2] are two (closely related) proposals for defining the semantics of logic programs, whether stratified or not. For stratified programs they both coincide with the perfect model semantics. The well-founded semantics is a three-valued semantics. Literals may be true, false or undefined.
References-found: 9

