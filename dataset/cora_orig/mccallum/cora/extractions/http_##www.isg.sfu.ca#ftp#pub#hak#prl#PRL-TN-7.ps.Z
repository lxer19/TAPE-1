URL: http://www.isg.sfu.ca/ftp/pub/hak/prl/PRL-TN-7.ps.Z
Refering-URL: http://www.isg.sfu.ca/life/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: 7  Compiling Order-Sorted Feature Term Unification  
Author: Hassan At-Kaci Roberto Di Cosmo 
Date: December 1993  
Affiliation: PARIS RESEARCH LABORATORY  
Abstract-found: 0
Intro-found: 0
Reference: 1. <author> Hassan At-Kaci. </author> <title> Warren's Abstract Machine, A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA (1991). </address>
Reference-contexts: However, we follow <ref> [1] </ref> using set instructions for queries rather than unify instructions with a systematic useless write mode test as done in [9]. December 1993 Digital PRL Compiling Order-Sorted Feature Term Unification 5 set sort X i ; s, we have the possibility to create new cells at a different time.
Reference: 2. <author> Hassan At-Kaci. </author> <title> An introduction to LIFE---programming with logic, inheritance, functions, and equations. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Proceedings of the International Symposium on Logic Programming, pages 52--68, </booktitle> <address> Cambridge, MA (October 1993). </address> <publisher> MIT Press. </publisher>
Reference-contexts: SAMUEL BECKETT, Molloy This document describes an abstract instruction set for compiling order-sorted feature (OSF) term unification [4] as it is used in the LIFE language <ref> [2] </ref>. This set of instructions is being used as the basis for the compiler of LIFE currently under development at PRL [8].
Reference: 3. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Towards a meaning of LIFE. </title> <type> PRL Research Report 11, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <address> Rueil-Malmaison, France (June 1991). </address>
Reference-contexts: This set of instructions is being used as the basis for the compiler of LIFE currently under development at PRL [8]. For an introduction to OSF terminology and the unification rules, the reader is referred to <ref> [4, 3] </ref>. 1 Heap representation We consider a simple language consisting of two kinds of entities, both OSF terms: a query and a program. The operational semantics of this language amounts to unifying the query term with the program term.
Reference: 4. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Towards a meaning of LIFE. </title> <journal> Journal of Logic Programming, </journal> <note> 16(3-4):195--234 (July-August 1993). </note>
Reference-contexts: SAMUEL BECKETT, Molloy This document describes an abstract instruction set for compiling order-sorted feature (OSF) term unification <ref> [4] </ref> as it is used in the LIFE language [2]. This set of instructions is being used as the basis for the compiler of LIFE currently under development at PRL [8]. <p> This set of instructions is being used as the basis for the compiler of LIFE currently under development at PRL [8]. For an introduction to OSF terminology and the unification rules, the reader is referred to <ref> [4, 3] </ref>. 1 Heap representation We consider a simple language consisting of two kinds of entities, both OSF terms: a query and a program. The operational semantics of this language amounts to unifying the query term with the program term.
Reference: 5. <author> Mohamed Amraoui. </author> <title> Une Experience de Compilation de Prolog II sur MALI. </title> <institution> These de doctorat, Universite de Rennes I, </institution> <note> France (January 1988). </note>
Reference-contexts: In this way, the mode flag need not be reset for a term once set to write at its root. Two streams of instructions, a 4 This method was in fact originally discovered as early as 1988 by Mohamed Amraoui, a doctoral student at Rennes, France <ref> [5] </ref>. Amraoui's idea, since unpublished, seems to have gone unnoticed until it was apparently rediscovered independently by Micha Meier [7] and later optimized further by Andre Marien and Bart Demoen [6]. It is the latter scheme that we shall adapt to our layout.
Reference: 6. <author> Andre Marien and Bart Demoen. </author> <title> A new scheme for unification in WAM. </title> <editor> In Vijay Saraswat and Kazunori Ueda, editors, </editor> <booktitle> Logic Programming, Proceedings of the 1991 International Symposium, pages 257--271, </booktitle> <address> Cambridge, MA (1991). </address> <publisher> MIT Press. </publisher>
Reference-contexts: Amraoui's idea, since unpublished, seems to have gone unnoticed until it was apparently rediscovered independently by Micha Meier [7] and later optimized further by Andre Marien and Bart Demoen <ref> [6] </ref>. It is the latter scheme that we shall adapt to our layout.
Reference: 7. <author> Micha Meier. </author> <title> Compilation of compound terms in Prolog. </title> <editor> In Saumya Debray and Manuel Hermenegildo, editors, </editor> <booktitle> Logic Programming, Proceedings of the 1990 North American Conference, pages 63--79, </booktitle> <address> Cambridge, MA (1990). </address> <publisher> MIT Press. </publisher>
Reference-contexts: Recently, another scheme for compiling unification was devised which does not rely on contiguity conventions, and has the advantage of being more efficient than the original contiguity scheme. The gist of this method relies on the fact, as described in <ref> [7] </ref>, 4 that the original WAM contiguity scheme generates redundant work and, therefore, inefficiency. Indeed, every execution of a get structure f =n; X i performs a complex test to determine if the machine must proceed in read or write mode. <p> Two streams of instructions, a 4 This method was in fact originally discovered as early as 1988 by Mohamed Amraoui, a doctoral student at Rennes, France [5]. Amraoui's idea, since unpublished, seems to have gone unnoticed until it was apparently rediscovered independently by Micha Meier <ref> [7] </ref> and later optimized further by Andre Marien and Bart Demoen [6]. It is the latter scheme that we shall adapt to our layout.
Reference: 8. <author> Richard Meyer. </author> <title> Compiling life. </title> <type> PRL Technical Note 8, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <month> Rueil-Malmaison (December </month> <year> 1993). </year>
Reference-contexts: SAMUEL BECKETT, Molloy This document describes an abstract instruction set for compiling order-sorted feature (OSF) term unification [4] as it is used in the LIFE language [2]. This set of instructions is being used as the basis for the compiler of LIFE currently under development at PRL <ref> [8] </ref>. For an introduction to OSF terminology and the unification rules, the reader is referred to [4, 3]. 1 Heap representation We consider a simple language consisting of two kinds of entities, both OSF terms: a query and a program. <p> index of its own HEAP cell. 1 However, many optimizations are possible, that will not be discussed here, whereby global analysis, explicit pragmas, together with clever indexing techniques such as perfect hashing and/or cached feature access can provide for Prolog terms to be compiled virtually as efficiently as in Prolog <ref> [8] </ref>. <p> This concludes our description of our basic compilation scheme for OSF term unification. This scheme can be improved much further to exploit several particular situations as shown in <ref> [8] </ref>.

References-found: 8

