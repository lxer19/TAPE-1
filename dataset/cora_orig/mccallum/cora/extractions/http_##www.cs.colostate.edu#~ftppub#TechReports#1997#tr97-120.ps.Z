URL: http://www.cs.colostate.edu/~ftppub/TechReports/1997/tr97-120.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Phone: Phone: (970) 491-5792 Fax: (970) 491-2466  
Title: A New Paradigm for Fault Tolerance in Distributed Algorithm Design  
Author: Gheorghe Antonoiu and Pradip K. Srimani 
Web: WWW: http://www.cs.colostate.edu  
Date: November 10, 1997  January 14-17, 1998.  
Address: Ft. Collins, CO 80523  Fort Collins, CO 80523-1873  
Affiliation: Department of Computer Science Colorado State University  Computer Science Department Colorado State University  
Note: Self-Stabilization:  To appear in the Proceedings of International Conference on Computers and Devices (CODEC), Calcutta, India,  
Pubnum: Technical Report CS-97-120  
Abstract: Computer Science Technical Report 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. W. Dijkstra. </author> <title> Self-stabilizing systems in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17(11) </volume> <pages> 643-644, </pages> <month> November </month> <year> 1974. </year>
Reference-contexts: Systems that reach the legitimate state starting from any illegitimate state in a finite number of steps are called self-stabilizing systems <ref> [1, 2] </ref>. <p> Since the states of the neighbors may have already been changed, the moves are not re ally atomic. * To enforce the atomicity and the serializability of the moves Dijkstra, <ref> [1] </ref>, has introduced the concept of central daemon. When multiple nodes are privileged, the central daemon arbitrarily selects one node to be active next.
Reference: [2] <author> E. W. Dijkstra. </author> <title> A belated proof of self-stabilization. </title> <journal> Distributed Computing, </journal> <volume> 1(1) </volume> <pages> 5-6, </pages> <year> 1986. </year>
Reference-contexts: Systems that reach the legitimate state starting from any illegitimate state in a finite number of steps are called self-stabilizing systems <ref> [1, 2] </ref>.
Reference: [3] <author> M. Schneider. </author> <title> Self-stabilization. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(1) </volume> <pages> 45-67, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Our purpose in the present paper is to present a brief high level overview of the recently emerging area of self-stabilizing distributed algorithm design; a somewhat dated survey can be found in <ref> [3] </ref>. 2 Distributed Systems and Algorithms Distributed computing systems have experienced a massive growth in the last few years. Many new frontiers of applications have opened up due to the availability of these distributed and parallel systems.
Reference: [4] <author> George F. Coulouris, Jean Dollimore, and Tim Kind-berg. </author> <title> Distributed Systems: Concepts and Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Mobile computing, electronic stock and bond market, combining far away resources to develop a complex application like weather modeling or aircraft designing or nuclear explosion simulation could all be example settings where distributed computing will be indispensable. To quote Birman in his forward to the book <ref> [4] </ref>, an awesome resource has been created by the computing and telecommunication technologies, but it is still largely untapped.
Reference: [5] <author> MG Gouda. </author> <title> The triumph and tribulation of system stabilization. </title> <booktitle> In WDAG95 Distributed Algorithms 9th International Workshop Proceedings, </booktitle> <publisher> Springer-Verlag LNCS:972, </publisher> <pages> pages 1-18, </pages> <year> 1995. </year>
Reference-contexts: The convergence property means that for any state and for any sequence of possible moves, after a finite number of moves the system is in a legitimate state. As Gouda observes in his paper <ref> [5] </ref>, self-stabilization can be in principle defined by a set, T , a relation R T fi T and a specification of the legitimate state set L. Different classes of closure and convergence can be defined and general methods of proving the self-stabilization can be sketched.
Reference: [6] <author> J. L. W. Kessels. </author> <title> An exercise in proving self-stabilization with a variant function. </title> <journal> Inf. Processing Letters, </journal> <volume> 29(2) </volume> <pages> 39-42, </pages> <year> 1988. </year>
Reference-contexts: Different classes of closure and convergence can be defined and general methods of proving the self-stabilization can be sketched. One useful and elegant strategy to prove the correctness of self stabilizing algorithms is to use bounded monotonically decreasing functions defined on global system states <ref> [6] </ref>; some existing self-stabilizing algorithms are proved to be correct by defining a bounded function that is shown to decrease monotonically at every step [7]. Many self-stabilizing algorithms do not use this bounded function method since it is usually very very difficult to design such a function.
Reference: [7] <author> S. T. Huang. </author> <title> Leader election in uniform rings. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(3) </volume> <pages> 563-573, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: One useful and elegant strategy to prove the correctness of self stabilizing algorithms is to use bounded monotonically decreasing functions defined on global system states [6]; some existing self-stabilizing algorithms are proved to be correct by defining a bounded function that is shown to decrease monotonically at every step <ref> [7] </ref>. Many self-stabilizing algorithms do not use this bounded function method since it is usually very very difficult to design such a function.
Reference: [8] <author> G. Antonoiu and P. K. Srimani. </author> <title> A self-stabilizing distributed algorithm to construct an arbitrary spanning tree of a connected graph. </title> <journal> Computers Mathematics and Applications, </journal> <volume> 30(9) </volume> <pages> 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Many self-stabilizing algorithms do not use this bounded function method since it is usually very very difficult to design such a function. In stead, they develop a different proof technique using induction on the number of nodes in the tree <ref> [8, 9] </ref>. 4.2 Implementation Issues The stabilizing algorithms achieve fault tolerance in a manner that is radically different from traditional fault tolerance in distributed systems. The paradigm allows us to abandon failure models and a bound on the number of failures.
Reference: [9] <author> G. Antonoiu and P. K. Srimani. </author> <title> A self-stabilizing leader election algorithm for tree graphs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 34 </volume> <pages> 227-232, </pages> <year> 1996. </year>
Reference-contexts: Many self-stabilizing algorithms do not use this bounded function method since it is usually very very difficult to design such a function. In stead, they develop a different proof technique using induction on the number of nodes in the tree <ref> [8, 9] </ref>. 4.2 Implementation Issues The stabilizing algorithms achieve fault tolerance in a manner that is radically different from traditional fault tolerance in distributed systems. The paradigm allows us to abandon failure models and a bound on the number of failures.
Reference: [10] <author> P.A Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Con-currency Control and Recovery in Databases Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Proving correctness is easier for a serial execution, but there are many parallel executions that might be equivalent with a serial execution <ref> [10] </ref>. These executions should be allowed by an efficient move scheduler.
Reference: [11] <author> Sartaj Sahni and Venkat Thanvantri. </author> <title> Parallel com-putin: Performance metrics and models. </title> <type> Technical Report TR-008, </type> <institution> University of Florida, Gainesville, </institution> <year> 1996. </year>
Reference-contexts: Unfortunately, there is no unifying model for the distributed system concept <ref> [11] </ref>. If some specific features of a system are not introduced in the model, the algorithms may be less efficient than they could possibly be; on the other hand, those features may not general enough to be present in all systems.
Reference: [12] <author> D. Angluin. </author> <title> Local and global properties in networks of processors. </title> <booktitle> In Conference Proceedings of the Twelfth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 82-93, </pages> <year> 1980. </year>
Reference-contexts: If each node has a unique hardwired id, the network is id-based; otherwise the network is anonymous. The anonymous network is a weaker model than an id-based network. For some problems there are no deterministic algorithms in anonymous networks <ref> [12] </ref>. The impossibility stems from the lack of deterministic symmetry breaking mechanisms without unique ids. In general, it is far more difficult to design algorithms for anonymous networks than for id-based networks.
Reference: [13] <author> S Dolev, A Israeli, and S Moran. </author> <title> Self-stabilization of dynamic systems assuming only read/write atomicity. </title> <journal> Distributed Computing, </journal> <volume> 7 </volume> <pages> 3-16, </pages> <year> 1993. </year>
Reference-contexts: By that time, some neighbor states may have already been changed. To correct this problem two approaches have been followed. One approach, taken for example in <ref> [13] </ref> is to design algorithms assuming only read/write atomicity. The paper shows that mutual exclusion in nonuniform networks is possible using only read/write atomicity (tree construction algorithm is also presented). However, the proof of correctness is difficult for this kind of approach.
Reference: [14] <author> S. T. Huang, L. C. Wuu, and M. S. Tsai. </author> <title> Distributed execution model for self-stabilizing systems. </title> <booktitle> In ICDCS94 Proceedings of the 14th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 432-439, </pages> <year> 1994. </year>
Reference-contexts: The paper shows that mutual exclusion in nonuniform networks is possible using only read/write atomicity (tree construction algorithm is also presented). However, the proof of correctness is difficult for this kind of approach. Since it's easier to prove correctness for a serial model, some others <ref> [14] </ref> use the following strategy. Each process at a node is split into several processes: one of them is called central process, and the others are called peripheral processes. Each peripheral process corresponds to a neighbor and maintains a recorded state of the neighbor via atomic read operations.
Reference: [15] <author> Craig Partridge. </author> <title> Gigabit Networking. </title> <address> Adison-Wesley, </address> <year> 1994. </year>
Reference-contexts: Though the error rate for some communication media may be very low <ref> [15] </ref>, there are no error free communication links. A data packet sent on a communication link may be changed due to a communication error or may be dropped due to a buffer overflow.
Reference: [16] <author> G.M. Brown, M. G. Gouda, and R. E. Miller. </author> <title> Block acknowledgement: Redisigning the window protocol. </title> <type> Technical Report TR-89-02, </type> <institution> University of Texas at Austin, </institution> <year> 1989. </year>
Reference-contexts: The alternating bit protocol is a fundamental data link protocol for data communication across error prone transmission media; but, this protocol is not self-stabilizing. Authors in <ref> [16] </ref> describe a window sliding protocol where message sequence numbers are taken from a finite domain and where both message disorder and loss can be tolerated. Most existing window protocols achieve only one of these two goals.
Reference: [17] <author> B Awerbuch and G Varghese. </author> <title> Distributed program checking: a paradigm for building self-stabilizing distributed protocols. </title> <booktitle> In FOCS91 Proceedings of the 31st Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 258-267, </pages> <year> 1991. </year>
Reference-contexts: It is more natural and desirable that an error at a one node remains confined to a small number of nodes. Some work in this area has been done <ref> [17] </ref> but there is not yet a stability definition of a self-stabilizing algorithm and no systematic procedure to achieve it. 7 Conclusion The concept of stabilization was known in mathematics for quite a while; an iterative method to solve a linear system can start from any value and converges to the
References-found: 17

