URL: http://www.cs.umd.edu/users/chechik/issta.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/publications.html
Root-URL: 
Email: fchechik, gannong@cs.umd.edu  
Title: Automatic Verification of Requirements Implementation events which cause state transitions. Implementations are annotated to describe
Author: Marsha Chechik John Gannon 
Note: Requirements describe  language encourages programmers to describe  different annotations of a temperature-control system.  
Address: College Park, Maryland 20742  
Affiliation: Computer Science Department University of Maryland  
Abstract: hold. However, we lack comparable methods to verify that implementations maintain the properties guaranteed by the requirements. We have built a tool that compares implementations written in C with their requirements. we show that each event causing a change of state in the implementation appears in the requirements, and that level behaviors, which are compared to those in the requirements. Since our analysis is not based on program code, annotations can describe behaviors at any level of granularity. We illustrate the use of our tool with several all the events specified to cause state changes in the requirements appear in the implementation. The annotation
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ulman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <address> Adisson-Welsley, </address> <year> 1988. </year>
Reference-contexts: Modeclass values are sets of modes which the system can attain at a particular point in the computation. Controlled and monitored variables have one of the values Undefined, True, False, and TrueOrFalse (indicating that the value of the variable may be either True or False). GEN and KILL sets <ref> [1] </ref> are computed for each SET, UPDATE, INITIAL, and PERFORM INITIAL command. <p> The KILL set contains HeatOn= False, Operating=fAC, Inactive, Offg, and undefined values for all other variables. Each node of the CFG containing a SET, UPDATE, INITIAL, or PERFORM INITIAL annotation is marked as the leader of a basic block <ref> [1] </ref>, and the basic blocks of the CFG are identified and stored in the BBG. An iterative algorithm is used to compute reaching definitions [1] for every basic block. The IN and OUT sets represent system states before and after the execution of the blocks. <p> Each node of the CFG containing a SET, UPDATE, INITIAL, or PERFORM INITIAL annotation is marked as the leader of a basic block <ref> [1] </ref>, and the basic blocks of the CFG are identified and stored in the BBG. An iterative algorithm is used to compute reaching definitions [1] for every basic block. The IN and OUT sets represent system states before and after the execution of the blocks. The algorithm uses set operations to manipulate GEN, KILL, IN, and OUT sets. Implementing set operations on modeclass variables is straightforward since their values are sets of modes.
Reference: [2] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. In Software Cost Reduction (SCR) requirements <ref> [2, 5, 6] </ref>, systems are modelled as concurrently executing state machines. Transition tables describe changes in the states of the system and in the values of the system's variables.
Reference: [3] <author> J.M. Atlee and J. Gannon. </author> <title> "State-based model checking of event-driven system requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Formal methods can be used to demonstrate that safety properties of event-based systems are enforced by the system's requirements <ref> [3] </ref>. After building a finite-state structure representing the system's reachability graph, a model checker can automatically determine if the structure is a model of temporal logic formulas representing the system's safety properties. Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. <p> Transitions in and out of Heat are similar to those of AC. In addition to these tables, we declare relationships between the controlled and monitored variables of the system to help requirements designers eliminate redundancy and increase the clarity of specifications <ref> [3] </ref>. These relationships improve readability and reduce the effort involved in writing the requirements as well as annotating the implementation. We implement three of the most frequently used relationships: implication, equivalence, and enumeration. Implication (X ! Y). Whenever X is asserted to be True, Y must also be True.
Reference: [4] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Programs". </title> <booktitle> In Proceedings of the "Colloque sur la Programma-tion", </booktitle> <month> April </month> <year> 1976. </year>
Reference-contexts: COND annotations are similar to control comments in the QDA comments language [7] because they can be used to control Analyzer's execution. We also use COND annotations to reduce the number of values in the set of reaching definitions in a manner similar to abstract interpretation <ref> [4] </ref> which uses predicates to reduce the ranges of values of variables. Analysis can be performed without any COND annotations. In this case, Analyzer reports additional errors and weaker invariants.
Reference: [5] <author> C. Heitmeyer and B. Labaw. </author> <title> "Consistency Checks for SCR-Style Requirements Specifications". </title> <type> Technical Report NRL Report 93-9586, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. In Software Cost Reduction (SCR) requirements <ref> [2, 5, 6] </ref>, systems are modelled as concurrently executing state machines. Transition tables describe changes in the states of the system and in the values of the system's variables.
Reference: [6] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. In Software Cost Reduction (SCR) requirements <ref> [2, 5, 6] </ref>, systems are modelled as concurrently executing state machines. Transition tables describe changes in the states of the system and in the values of the system's variables.
Reference: [7] <author> W.E. Howden. </author> <title> "Comments Analysis and Programming Errors". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(1) </volume> <pages> 72-81, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Using dataflow analysis techniques, the tool computes the events which cause state transitions in the implementation, determines if the transitions are permitted by the requirements, and keeps track of which of the requirements transitions have appeared in the implementation. Our tool uses concepts from comments analysis <ref> [7] </ref>, Cesar/Cecil [10, 11], and Aspect [8]. In comments analysis, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points. <p> We added COND annotations to our annotation language in order to permit programmers to indicate the conditions under which the paths are executable. COND annotations are similar to control comments in the QDA comments language <ref> [7] </ref> because they can be used to control Analyzer's execution. We also use COND annotations to reduce the number of values in the set of reaching definitions in a manner similar to abstract interpretation [4] which uses predicates to reduce the ranges of values of variables.
Reference: [8] <author> Daniel Jackson. </author> <title> "Abstract Analysis with Aspect". </title> <booktitle> In Proceedings of the 1993 International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 19-27, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Our tool uses concepts from comments analysis [7], Cesar/Cecil [10, 11], and Aspect <ref> [8] </ref>. In comments analysis, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [9] <author> B.H. Liskov and S.N. Zilles. </author> <title> "Specification Techniques for Data Abstraction". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(1):7-18, </volume> <month> March </month> <year> 1975. </year>
Reference-contexts: Generally, when two descriptions of a system are written, designers attempt to convince themselves that concepts are captured in the higher-level description and preserved in the lower fl This work was supported by the Air Force Office of Scientific Research under contract F49620-93-1-0034. level description <ref> [9] </ref>. Formal methods can be used to demonstrate that safety properties of event-based systems are enforced by the system's requirements [3].
Reference: [10] <author> Kurt M. Olender and Leon J. Osterweil. </author> <note> "Cesar: </note>
Reference-contexts: Using dataflow analysis techniques, the tool computes the events which cause state transitions in the implementation, determines if the transitions are permitted by the requirements, and keeps track of which of the requirements transitions have appeared in the implementation. Our tool uses concepts from comments analysis [7], Cesar/Cecil <ref> [10, 11] </ref>, and Aspect [8]. In comments analysis, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
References-found: 10

