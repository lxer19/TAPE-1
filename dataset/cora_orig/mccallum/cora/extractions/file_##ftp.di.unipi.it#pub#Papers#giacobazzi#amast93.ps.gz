URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/amast93.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: fgiaco,levig@di.unipi.it  debray@cs.arizona.edu  
Title: Joining Abstract and Concrete Computations in Constraint Logic Programming  
Author: Roberto Giacobazzi and Giorgio Levi Saumya K. Debray 
Address: Corso Italia 40, 56125 Pisa, Italy  Tucson, AZ 85721  
Affiliation: Dipartimento di Informatica, Universita di Pisa  Department of Computer Science, The University of Arizona  
Abstract: The use of standard instances of the CLP framework (e.g. CLP (Bool) and CLP (R)) for non-standard (possibly abstract) interpretations, weakens the distinction between concrete and abstract computations in semantics and analysis. We formalize this idea by applying the well known approximation techniques (e.g. the standard theory of closure operators) in conjunction with a generalized notion of constraint system, supporting any program evaluation. The "generalized semantics" resulting from this process, abstracts away from standard semantic objects, by focusing on the general properties of any (possibly non-standard) semantic definition. In constraint logic programming, this corresponds to a suitable definition of the constraint system supporting the semantic definition. Both top-down and a bottom-up semantics are considered.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1974. </year>
Reference-contexts: We consider closed semirings to summarize, in an algebraic framework, all the aspects dealing with composition of terms like unification (conjunction) and set union. A weaker structure, namely a non-distributive closed semiring, will be considered in Section 5. Definition 3.2 [closed semirings <ref> [1] </ref>] A Closed Semiring is an algebraic structure (C; ; ; 1; 0) satisfying the following: 1. (C; ; 1) and (C; ; 0) are monoids. 2. is commutative and idempotent. 3. 0 is an annihilator for , i.e., for every c 2 C, c 0 = 0 c = 0.
Reference: [2] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1993. </year>
Reference-contexts: Given a noetherian constraint system A, the domain = A is noetherian, and F A (P ) can be computed by iterating T P a finite number of times. We illustrate this technique by means of a simple example of data-flow analysis for ground dependences in pure logic programs <ref> [2, 6] </ref>. Consider the (concrete) term system t (;V ) being defined over a finite set of variables V . Let us consider the term system t V as defined in Example 3.2. Terms are finite sets of variables. Ground terms are denoted with the empty set of variables.
Reference: [3] <author> R. Barbuti and A. Martelli. </author> <title> A Structured Approach to Semantics Correctness. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 3 </volume> <pages> 279-311, </pages> <year> 1983. </year>
Reference-contexts: To relate constraint systems, we follow the approach to "static semantics correctness" in <ref> [3] </ref>. Correctness of non-standard semantic specifications can be handled in an algebraic way through the notion of mor-phism. However, the algebraic notion of morphism can be made less restrictive by assuming that the carriers of the algebras involved are partially ordered sets.
Reference: [4] <author> J. Cirulis. </author> <title> An Algebraization of First Order Logic with Terms. </title> <journal> Colloquia Mathematica Societatis Janos Bolyai, </journal> <volume> 54 </volume> <pages> 125-146, </pages> <year> 1991. </year>
Reference-contexts: are denoted : (A; Q A ) m (B; Q B ). 3 Generalized semantics In this section we recall some of the basic results on the generalized semantics in [12]. 3.1 Term systems A term system is an algebra of terms provided with a binary operator which realizes substitutions <ref> [4] </ref>. We are interested in term systems where every term depends only on a finite number of variables (also called finitary term systems). They represent the first basic definition in the semantic construction. Definition 3.1 [term systems [4]] A term system t is an algebraic structure (t; S; V ) where <p> is an algebra of terms provided with a binary operator which realizes substitutions <ref> [4] </ref>. We are interested in term systems where every term depends only on a finite number of variables (also called finitary term systems). They represent the first basic definition in the semantic construction. Definition 3.1 [term systems [4]] A term system t is an algebraic structure (t; S; V ) where we refer to the elements of t as t -terms (terms for short); V is a countable set 2 of t -variables (variables, for short) in t ; S is a countable set of binary operations on <p> Notice that, by T 2 , for each x; y 2 V : x ind y iff x 6= y. The condition that terms depend on a finite number of variables can be formalized by imposing that the dimension set <ref> [4] </ref>: fx 2 V j [t=x] t 0 6 t 0 for some t 2 t g is finite for every t 0 2 t . A renaming of a variable x in a term t is [y=x] t for some y 6= x. <p> A renaming of a variable x in a term t is [y=x] t for some y 6= x. Standard properties of term systems and substitutions, such as the properties of composition, can be found in <ref> [4] </ref>. Example 3.1 Let be a finite collection of function symbols. The standard term system t (;V ) = (T (; V ); Sub; V ) is a term system provided that substitutions in Sub perform standard substitutions. <p> Let t = (-f (); S; ), where S is the family of basic operators s , for 2 , such that for each 1 ; 2 2 2 A more general definition that considers sets of arbitrary cardinalities is given in <ref> [4] </ref>: for our purposes, it suffices to consider countable sets. -f (): 2 otherwise In this case, for each 2 and finite set : ind iff 62 . t is a term system. 3.2 Constraint systems The process of building constraints in any fixpoint evaluation of a given CLP program is <p> However, cylindric algebras, which are oriented to first-order languages without function symbols, are not adequate as an algebraic semantic framework for general constraint logic programs, so we extend diagonal elements to deal with generic terms, following the approach in <ref> [4] </ref>. Finally, for each variable x and term t, a unary operator @ t x extends the substitution operation to idempotent substitutions on constraints.
Reference: [5] <author> P. Codognet and G. </author> <title> File. Computations, Abstractions and Constraints in Logic Programs. </title> <booktitle> In Proc. Fourth Int. Conf. on Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: They both derive from the same general specification of the CLP paradigm. A related approach is also considered by Codognet and File, who give an algebraic definition of constraint systems and consider abstract interpretation of constraint logic programs <ref> [5] </ref>. However, the algebraic structure considered by these authors is very different: only -composition is considered. The notion of "computation system" is introduced but the underlying structure is not provided with a join operator.
Reference: [6] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional Formula as Abstract Domain for Groundness Analysis. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 322-327. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Given a noetherian constraint system A, the domain = A is noetherian, and F A (P ) can be computed by iterating T P a finite number of times. We illustrate this technique by means of a simple example of data-flow analysis for ground dependences in pure logic programs <ref> [2, 6] </ref>. Consider the (concrete) term system t (;V ) being defined over a finite set of variables V . Let us consider the term system t V as defined in Example 3.2. Terms are finite sets of variables. Ground terms are denoted with the empty set of variables.
Reference: [7] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: where a pair of functions (ff; fl) is a Galois insertion of hC 0 ; 0 i into hC; i iff ff and fl are monotonic, ff (fl (c 0 )) = c 0 and c fl (ff (c)) for each c 2 C and c 0 2 C 0 <ref> [7, 8] </ref>. If A 0 is correct with respect to A by means of a semimorphism ff , there exists a Galois insertion of hC 0 ; 0 i into hC; i. <p> In the framework of abstract interpretation, correctness of fixpoint approximations require in addition some conditions on correctness of the non-standard semantics operators <ref> [7] </ref>. With the assumption of additivity, semimorphisms are adequate to specify both Galois insertions, and correctness of constraint systems. Let A 0 be a constraint system which is correct with respect to A, by means of a semimorphism ff . <p> Convergence to the least fixpoint can either be obtained by forcing the abstract domain to satisfy the ascending chain condition or to use widening and narrowing operators to accelerate convergence for fixpoint approximations, as suggested in <ref> [7] </ref>. In the following we consider the conditions on the constraint system that ensure the resulting abstract domain to satisfy the ascending chain condition. Definition 4.2 A constraint system A is noetherian iff its universe C does not contain any infinite chain of free-variable bounded constraints 5 .
Reference: [8] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: where a pair of functions (ff; fl) is a Galois insertion of hC 0 ; 0 i into hC; i iff ff and fl are monotonic, ff (fl (c 0 )) = c 0 and c fl (ff (c)) for each c 2 C and c 0 2 C 0 <ref> [7, 8] </ref>. If A 0 is correct with respect to A by means of a semimorphism ff , there exists a Galois insertion of hC 0 ; 0 i into hC; i. <p> Theorem 4.3 Let be a consistent upper closure operator on the constraint system A. (A) is a correct constraint system (wrt A). As observed in <ref> [8] </ref>, any Galois insertion (ff; fl) defines an upper closure operator = fl ffi ff on the corresponding (concrete) complete lattice. In the following we characterize the consistency of upper closures induced by a Galois insertion.
Reference: [9] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> In Proc. Fifth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <year> 1978. </year>
Reference-contexts: Linear relationships analysis The inference of linear size relationships between the arguments of procedures is useful for a variety of applications such as compile-time overflow detection, integer subrange checking, array bound checking, termination analysis, etc., has been considered by a number of researchers <ref> [9, 17, 11, 24] </ref>. The approach of Verschaetse and De Schreye for automatic inference of linear size relations among variables in logic programs can be specified as a constraint computation in our framework.
Reference: [10] <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 238- 252. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: A semantic definition necessarily implies some notion of "observable behavior": programs that have the same semantics are considered to not be observably different. Modeling the semantics of constraint logic programs in terms of answer constraints corresponds to considering answer constraints as the appropriate observable property <ref> [10] </ref>. Thus, the notion of solution for a given answer constraint has to be restricted (projected) to the variables of the corresponding query (output variables). Closed semirings are too weak to capture the notion of variable projection. <p> For this reason we have assumed a left-to-right selection rule. The fixpoint semantics is defined by allowing constrained atoms into the base of interpretations as suggested in <ref> [10] </ref>. Each constrained atom `p (x) : c' represents the set of instances p (x)#, where # is a solution of the constraint c. We assume F V (c) var (A).
Reference: [11] <author> A. Van Gelder. </author> <title> Deriving Constraints Among Argument Sizes in Logic Programs. </title> <booktitle> In Proc. of the eleventh ACM Conference on Principles of Database Systems, </booktitle> <pages> pages 47-60. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Linear relationships analysis The inference of linear size relationships between the arguments of procedures is useful for a variety of applications such as compile-time overflow detection, integer subrange checking, array bound checking, termination analysis, etc., has been considered by a number of researchers <ref> [9, 17, 11, 24] </ref>. The approach of Verschaetse and De Schreye for automatic inference of linear size relations among variables in logic programs can be specified as a constraint computation in our framework.
Reference: [12] <author> R. Giacobazzi, S. K. Debray, and G. Levi. </author> <title> A Generalized Semantics for Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 581-591, </pages> <year> 1992. </year>
Reference-contexts: Since this aspect can be separated from the details specific to particular constraint systems, it seems natural to parameterize the semantics of CLP languages with respect to the underlying constraint system. We refer to such a semantics as generalized semantics <ref> [12] </ref>. It turns out that fl The work of R. Giacobazzi and G. Levi was supported by the Esprit Basic Research Action 3012 - Compulog and by "Progetto Finalizzato Sistemi Informatici e Calcolo Parallelo" of C.N.R. under grants no. 9100880.PF69. The work of S. <p> In this paper we show how abstract and concrete interpretations for logic-based languages can be joined into the unifying framework of constraint logic programming. We apply the generalized semantics introduced in <ref> [12] </ref>, intended to generalize the notion of constraint logic programs as firstly introduced in [15]. <p> The paper is structured as follows: in Section 2 we introduce the basic mathematical notations used throughout the paper. Section 3 introduces the main results in <ref> [12] </ref>, thus providing an incremental step-by-step algebraic specification for constraint systems and semantics. In Section 4 we consider generalized semantics for constraint logic programs as a framework for semantics-based analyses for constraint logic programs. An example, namely ground dependency analysis, is considered associating boolean constraints with standard equations on terms. <p> of algebraic structures (A; Q A ) and (B; Q B ), provided with a common set of basic operators, are denoted : (A; Q A ) m (B; Q B ). 3 Generalized semantics In this section we recall some of the basic results on the generalized semantics in <ref> [12] </ref>. 3.1 Term systems A term system is an algebra of terms provided with a binary operator which realizes substitutions [4]. We are interested in term systems where every term depends only on a finite number of variables (also called finitary term systems). <p> R n is a constraint system. 3.3 Operational and fixpoint semantics Constraint logic programming was defined by Jaffar and Lassez to specify relations on a constraint language by means of constraint-based Horn clauses. We follow the approach in <ref> [12] </ref> by defining Horn-like clauses on constraint systems. Constraint logic programs are defined in the usual way: let A be a constraint system on the term system t and be a finite set of predicate symbols.
Reference: [13] <editor> L. Henkin, J.D. Monk, and A. Tarski. </editor> <title> Cylindric Algebras. Part I and II. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1971. </year>
Reference-contexts: We handle this notion by means of a family of "hiding" operators on the underlying algebra. The intuition here is that given a constraint c, the cylindrification operation 9 S (c) yields the constraint obtained by "projecting out" information about the variables in S from c. Diagonal elements <ref> [13] </ref> are considered as a way to provide parameter passing [21]. In constraint logic programming the equality symbol "=" is assumed to provide term unification in any constraint system. <p> The variable restriction operation ^ 9 is performed by cylindrification parallel to an axis <ref> [13] </ref>: if c is a constraint in &lt; n and i n, we define: ^ 9 x i c = f ~y 2 &lt; n j y j = x j f or ~x 2 c and j 6= i g : ^ 9 x i c is the cylinder generated
Reference: [14] <author> M. Hermenegildo, R. Warren, and S.K. Debray. </author> <title> Global flow analysis as a practical compilation tool. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(4) </volume> <pages> 349-366, </pages> <year> 1992. </year>
Reference-contexts: This approach has some interesting practical applications, such as the ability to compile the data-flow analysis directly to an abstract machine for constraint logic programs. This approach, which is a logical extension of the "abstract compilation" scheme discussed in <ref> [14] </ref>, removes the overhead of program interpretation incurred by keeping separate abstract and concrete interpretations, and leads to significant improvements in the speed of analysis (e.g. see [14, 22]). The paper is structured as follows: in Section 2 we introduce the basic mathematical notations used throughout the paper. <p> This approach, which is a logical extension of the "abstract compilation" scheme discussed in [14], removes the overhead of program interpretation incurred by keeping separate abstract and concrete interpretations, and leads to significant improvements in the speed of analysis (e.g. see <ref> [14, 22] </ref>). The paper is structured as follows: in Section 2 we introduce the basic mathematical notations used throughout the paper. Section 3 introduces the main results in [12], thus providing an incremental step-by-step algebraic specification for constraint systems and semantics.
Reference: [15] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Constraint logic programming (CLP ) is a generalization of the pure logic programming paradigm, having similar model-theoretic, declarative and operational semantics <ref> [15] </ref>. CLP is then a general programming paradigm which may be instantiated on various semantic domains. The fundamental linguistic aspect of constraint logic programming is the ability of computing constraints by means of Horn-like rules. <p> In this paper we show how abstract and concrete interpretations for logic-based languages can be joined into the unifying framework of constraint logic programming. We apply the generalized semantics introduced in [12], intended to generalize the notion of constraint logic programs as firstly introduced in <ref> [15] </ref>. The algebraic approach we take to constraint interpretation makes it easy to identify a suitable set of operators which can be instantiated in different ways to obtain both standard and non-standard interpretations, relying on some simple axioms to ensure that desirable semantic properties are satisfied. <p> t x ; ft = t 0 g) fxg;XV ;t;t 0 2t (;V ) =~ EQ ; where: E H is the set of possibly existentially quantified finite conjunctions of equations over t (;V ) and H is intended to represent the Herbrand interpretation structure, interpreting diagonal elements as unification <ref> [15] </ref>.
Reference: [16] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) Language and System. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: Section 6 contains a survey of the most important related works. 1 CLP (R) denotes the CLP (&lt;) (constraint logic programs on the domain of real numbers) implementation described in <ref> [16] </ref>. 2 Preliminaries The set of natural and real numbers are denoted by N and &lt; respectively. Given sets A and B, AnB denotes the set A where the elements in B have been removed. The powerset of a set S is denoted by -(S). <p> A possible implementation can be obtained by slightly modifying the CLP (R) interpreter in <ref> [16] </ref> to cope with affine subspaces. This corresponds to implement (at the meta level) the join operator ^ for affine subspaces so as to combine the computed answer constraints generated by the interpreter. 6 Related work Abstract interpretation of constraint logic programs is considered by Marriott and Stndergaard [19].
Reference: [17] <author> M. Karr. </author> <title> Affine Relationships Among Variables of a Program. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 133-151, </pages> <year> 1976. </year>
Reference-contexts: Linear relationships analysis The inference of linear size relationships between the arguments of procedures is useful for a variety of applications such as compile-time overflow detection, integer subrange checking, array bound checking, termination analysis, etc., has been considered by a number of researchers <ref> [9, 17, 11, 24] </ref>. The approach of Verschaetse and De Schreye for automatic inference of linear size relations among variables in logic programs can be specified as a constraint computation in our framework. <p> As pointed out in <ref> [17] </ref>, there are no infinitely ascending chains of free-variable bounded constraints (i.e. bounded dimension affine spaces), otherwise in any properly ascending chain of subspaces: U 1 ^ U 2 ^ ::: the subspaces U i must have a dimension of at least one greater than U i1 .
Reference: [18] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: end of all the possible computations; in the fixpoint case, by contrast, the join operator is applied at each partial computation step (an equivalent operational semantics can be easily defined: this would correspond to the bottom-up execution strategy of deductive databases rather than the standard operational interpretation of logic programs <ref> [18] </ref>). In this case, as the constraint system is not distributive any more, we can only have a further approximation level by applying bottom-up instead of top-down, i.e. O (P ) v F (P ). We show the applicability of non-distributive constraint systems by means of an example.
Reference: [19] <author> K. Marriott and H. Stndergaard. </author> <title> Analysis of Constraint Logic Programs. </title> <editor> In S. K. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 531-547. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: This corresponds to implement (at the meta level) the join operator ^ for affine subspaces so as to combine the computed answer constraints generated by the interpreter. 6 Related work Abstract interpretation of constraint logic programs is considered by Marriott and Stndergaard <ref> [19] </ref>. Their treatment is based on abstracting a denotational semantics for constraint logic programs. A meta-language based on the typed -calculus is used to specify the semantics of logic languages in a denotational style, and both the standard and non-standard semantics are viewed as instances of the meta-language specification.
Reference: [20] <author> Oystein Ore. </author> <title> Combinations of Closure Relations. </title> <journal> Annals of Mathematics, </journal> <volume> 44(3) </volume> <pages> 514-533, </pages> <year> 1943. </year>
Reference-contexts: Notice that 9 ffi is not idempotent, unless 9 and commute. This is in accordance with a classical result of closure theory saying that any composition of two upper closure operators is an upper closure operator iff they commute <ref> [20] </ref>. Lemma 4.2 Let be an 9-consistent upper closure operator on the constraint system A with universe C, term system t and set of variables V .
Reference: [21] <author> V. A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantic Foundation of Concurrent Constraint Programming. </title> <booktitle> In Proc. Eighteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 333-353. </pages> <publisher> ACM, </publisher> <year> 1991. </year>
Reference-contexts: The intuition here is that given a constraint c, the cylindrification operation 9 S (c) yields the constraint obtained by "projecting out" information about the variables in S from c. Diagonal elements [13] are considered as a way to provide parameter passing <ref> [21] </ref>. In constraint logic programming the equality symbol "=" is assumed to provide term unification in any constraint system.
Reference: [22] <author> Jichang Tan and I-Peng Lin. </author> <title> Compiling Dataflow Analysis of Logic Programs. </title> <booktitle> In ACM Programming Language Design and Implementation, volume 27 of SIGPLAN Notices, </booktitle> <pages> pages 106-115. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: This approach, which is a logical extension of the "abstract compilation" scheme discussed in [14], removes the overhead of program interpretation incurred by keeping separate abstract and concrete interpretations, and leads to significant improvements in the speed of analysis (e.g. see <ref> [14, 22] </ref>). The paper is structured as follows: in Section 2 we introduce the basic mathematical notations used throughout the paper. Section 3 introduces the main results in [12], thus providing an incremental step-by-step algebraic specification for constraint systems and semantics.
Reference: [23] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: The set of A-interpretations is denoted = A . h= A ; vi is a complete lattice. The fixpoint semantics of a program P over a constraint system A, F A (P ), is defined in terms of a continuous immediate consequence operator in the style of <ref> [23] </ref>, i.e.
Reference: [24] <author> K. Verschaetse and D. De Schreye. </author> <title> Derivation of Linear Size Relations by abstract interpretation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proc. of PLILP'92, volume 631 of Lecture Notes in Computer Science, </booktitle> <pages> pages 296-310. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Linear relationships analysis The inference of linear size relationships between the arguments of procedures is useful for a variety of applications such as compile-time overflow detection, integer subrange checking, array bound checking, termination analysis, etc., has been considered by a number of researchers <ref> [9, 17, 11, 24] </ref>. The approach of Verschaetse and De Schreye for automatic inference of linear size relations among variables in logic programs can be specified as a constraint computation in our framework.
References-found: 24

