URL: http://www.cs.iastate.edu/tech-reports/TR98-07.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: ACL Eliminating Parameter Aliasing with Dynamic Dispatch  
Author: Olga Antropova 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: Copyright c 1998 by Olga Antropova. Permission to make copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not distributed for profit or commercial advantage.  
Date: June 1998  
Pubnum: TR #98-07  
Abstract: Keywords: reference parameter aliasing, global variable aliasing, multi-body procedures, dynamic dispatch, static despatch, program verification, ACL language, alias-free programs, compiler optimizations, call-by-value and call-by-result patterns. 1997 CR Categories: D.3.1 [Programming Languages] Formal Definitions and Theory semantics; D.3.3 [Programming Languages] Language Constructs and features control structures, procedures, functions, and subroutines;D.3.4 [Programming Languages] Processors interpreters; D.3.m [Programming Languages] Miscellaneous dynamic dispatch, multiple dispatch, type systems; F.3.1 [Logics and Meanings of Programs] Specifying and verifying and reasoning about programs, logics of programs; F.3.3 [Logics and Meanings of Programs] Studies of Program Constructs functional constructs, type structure. An ACL implementation is available from ftp://ftp.cs.iastate.edu/techreports/TR98-07/ 
Abstract-found: 1
Intro-found: 1
Reference: [PHLML77] <author> G.J. Popek, J. J. Horning, B. W. Lampson, J. G. Mitchel, and R. L. </author> <title> London. Notes on the Design of Euclid., </title> <journal> SIGPLAN Notices, </journal> <volume> 12(3) </volume> <pages> 11-18, </pages> <month> March </month> <year> 1977. </year> <booktitle> Proceedings of an ACM Conference on Language Design for Reliable Software. </booktitle>
Reference-contexts: Aliasing also affects efficiency of programs. Most of the researchers, working on aliasing problems, concentrate on efficient alias analysis for enabling compiler optimizations [REFS?]. There are thus important reasons to investigate languages which prohibit aliasing. 1.1. Related work Back in 1977 the programming language Euclid was developed <ref> [PHLML77] </ref>, which "... demonstrated that it is possible to completely eliminate aliasing in a practical programming language" ([PHLML77], page 16). The approach the authors took to eliminate aliases resulting from reference parameters to procedures was to prohibit procedure calls when the actual parameters overlap. <p> In the procedure body for a particular alias combination aliased locations should only be referenced through one of their alias names. To avoid unnecessary alias combinations with global variables, we adopt Eu-clid's idea of explicit importation of global variables <ref> [PHLML77] </ref> in procedures. (Functions and procedures are implicitly available in procedure bodies since they cannot be aliased to variables in the language that we study.) In general, dynamic dispatch must be used to find the appropriate procedure body to execute since the concrete alias combination among the parameters often cannot be <p> However, in many cases the aliasing combination is evident statically, and so static dispatch is possible as an optimization. An important implication of the proposed approach is that program verification becomes a simpler task compared to other languages (e.g., Euclid <ref> [PHLML77] </ref>). In Euclid, to make a program correct, the code, similar to the code in the procedure bodies for alias combinations, or alias analysis code should be written at all the points of the procedure calls repeatedly. <p> However the exponential number of alias combinations is not the property of ACL, as this situation has to be dealt with in all other languages. Recall that in general different procedure bodies are needed for aliasing combinations in Euclid <ref> [PHLML77] </ref> (see Example 1.2). Also, the number of parameters is usually not too big in practical programming. The exponential number of aliasing cases is thus not a key measure for the practicality of our approach. <p> We claim though, that the efficiency of the program written in ACL will be no worse than the efficiency of a similar program in languages such as Euclid <ref> [PHLML77] </ref>. Though in Euclid the dispatch to the procedures is static, recall that, unless one can statically prove otherwise, for correctness additional code similar to the code used by ACL to do dynamic dispatch must be written in the program at the point of each procedure call. <p> It will be interest-ing to study how the idea would apply to languages that operate more complex objects. One of the directions for future research would be to incorporate ACL's mechanisms into existing languages like Euclid <ref> [PHLML77] </ref>. Another direction of the future work is to investigate the possibility of applying these ideas to object-oriented languages. Recently several works appeared in the area of creating the object-oriented languages that deal with aliasing [MU97], [HLWCH92], [JH91].
Reference: [GL80] <author> D. Gries and G. Levin. </author> <title> Assignment and the Procedure Call Proof Rules. </title> <journal> ACM TOPLAS, </journal> <volume> 2(4): </volume> <pages> 564-579, </pages> <year> 1980. </year>
Reference-contexts: When aliasing is possible the verification of a procedure's correctness is difficult. It involves separate proofs for all possible aliases combinations among formal parameter names, and formal parameters and global variable names <ref> [GL80] </ref>. In many contemporary programming languages parameter aliases are common. For example C++ has call by reference. Other object-oriented languages such as Smalltalk and Java, and even mostly-functional languages such as ML and Scheme, manipulate objects indirectly, through references.
Reference: [MU97] <author> M. Utting. </author> <title> Reasoning about Aliasing. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3 </volume> <pages> 1-15, </pages> <year> 1997. </year>
Reference-contexts: The same restrictions apply to collections, elements of collections and pointers, when those are passed to the procedure or imported, as to arrays, array elements and subscripts. Recent work in this direction by Utting extends the idea of collections to object-oriented systems <ref> [MU97] </ref>. All complex objects (possibly sharing memory locations) can be considered [treated/manipulated/structured] as a set of disjoint collections (local stores) of homogeniuos objects. Local stores are practically the arrays indexed by pointers to objects in those. The proof logic for the arrays can be applied directly for the local stored. <p> Another direction of the future work is to investigate the possibility of applying these ideas to object-oriented languages. Recently several works appeared in the area of creating the object-oriented languages that deal with aliasing <ref> [MU97] </ref>, [HLWCH92], [JH91]. Since those works concentrate on the aliasing of other kinds than the parameter aliasing, it seems interesting to research if it is possible to connect their and our approaches in a single language.
Reference: [CM88] <author> C. Morgan. </author> <title> Procedures, Parameters and Abstractions: </title> <editor> Separate Concepts.,in C. Morgan and T. Vickers (Eds.). </editor> <booktitle> On the Refinement Calculus., </booktitle> <address> Springler-Verlag., </address> <year> 1992, </year> <month> p57. </month>
Reference: [HW73] <author> C. A. R. Hoare and N. Wirth. </author> <title> An Axiomatic Definition of Programming Language Pascal., </title> <journal> Acta Informatica, </journal> <volume> 2(4): </volume> <pages> 335-355, </pages> <year> 1973 </year>
Reference-contexts: 1. Introduction When a location can be referenced by several names those names are called aliases. The presence of aliases and mutation makes it more difficult to write correct programs and to reason about their correctness ([CM88], <ref> [HW73] </ref>). Some compiler optimizations become impossible in the presence of aliasing ([ASU86], p 648), which results is slower executable code. The most common and obvious source of aliases are alias declarations and pointer variables. Much research has been done to either completely eliminate or to restrict and control these aliases.
Reference: [WS73] <author> W. Wulf and M. Shaw. </author> <title> Global Variable Considered Harmful, </title> <journal> SIG-PLAN, </journal> <volume> 8 (2):28-34, Feb. 1973 20 </volume>
Reference-contexts: Furthermore, often too many parameters indicate that the procedure is designed to do many different things, which is not a good software engineering practice. Excessive usage of the global variables is considered to be a bad programming practice too <ref> [WS73] </ref>.
Reference: [HLWCH92] <author> J. Hogg, D. Lea, A. Wills, D. deChampeaux and R. Holt. </author> <title> The Geneva Convention on the Treatment of the Object Aliasing., </title> <journal> OOPS Messenger, </journal> <volume> 3(2) </volume> <pages> 11-16, </pages> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Another direction of the future work is to investigate the possibility of applying these ideas to object-oriented languages. Recently several works appeared in the area of creating the object-oriented languages that deal with aliasing [MU97], <ref> [HLWCH92] </ref>, [JH91]. Since those works concentrate on the aliasing of other kinds than the parameter aliasing, it seems interesting to research if it is possible to connect their and our approaches in a single language.
Reference: [JH91] <author> J. Hogg. </author> <title> Islands: Aliasing Protection in Object-Oriented Languages., </title> <booktitle> in Proceedings of OOPSLA '91, </booktitle> <pages> pp. 271-285, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Another direction of the future work is to investigate the possibility of applying these ideas to object-oriented languages. Recently several works appeared in the area of creating the object-oriented languages that deal with aliasing [MU97], [HLWCH92], <ref> [JH91] </ref>. Since those works concentrate on the aliasing of other kinds than the parameter aliasing, it seems interesting to research if it is possible to connect their and our approaches in a single language.
Reference: [ASU86] <author> A. V. Aho, R. Sethi and J. D. Ullman. </author> <booktitle> Compilers. Principles, Techniques and Tools., </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference: [FWH92] <author> D. P. Friedman, M. Wand and C. T. Hayness. </author> <title> Essentials of Programming Languages., </title> <publisher> MIT Press, </publisher> <year> 1992 </year>
Reference-contexts: possible alias combinations: 1) value parameters cannot be aliases to any other parameters and to global variables; 2) parameters of different types cannot be aliases to each other, likewise a parameter of one type cannot be alias to global variable of another type; 3) since ACL has the "direct model" <ref> [FWH92] </ref> of arrays (as in Pascal) and no reference or pointer variables, imported global variables cannot be aliases to each other, and an atomic imported global cannot be an alias to a structured reference parameter.
Reference: [HR94] <author> M. R. Headington and D.D. Riley. </author> <title> Data Abstraction and Structures Using C++., </title> <editor> HEATH, </editor> <year> 1994. </year>
Reference-contexts: In standard C++ libraries assert, ctype, math, and stdlib almost all the functions have one parameter. In the string library majority of functions have 2 reference parameters <ref> [HR94] </ref>. For a small number of reference parameters the difference in the performance of the O (n 2 ) and O (nlog n) algorithms is negligible. The bigger time saving may be achieved using some flow alias analysis techniques in combination with statically known information about aliases. 3.3.
Reference: [CLR90] <author> T. H. Cormen, C. E. Leiserson and R. L. Rivest. </author> <title> Introduction to Algorithms., </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Now we analyze the performance of this search. An upper bound on the number of the procedure bodies is n!, which in turn has an upper bound of n n (by Stirling's approximation) <ref> [CLR90] </ref>. The sequential search for the procedures with large number of reference parameters is inefficient.
Reference: [HJW92] <author> P. Hudak, S. R. Jones, P. Wadler and others. </author> <title> Report on the Programming Language Haskell: A Non-strict, Purely Functional Language, version 1.2., </title> <journal> SIGPLAN, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year> <month> 21 </month>
Reference-contexts: Counting alias combinations and dynamic dispatch ACL is implemented as an interpreter in Haskell <ref> [HJW92] </ref>. In this section we briefly describe the current algorithms and give their complexity. We also discuss the possible improvements and estimate the complexity of the improved algorithms. 3.1.
References-found: 13

