URL: http://trantor.cse.psu.edu/~yoo/publications/stack.ps
Refering-URL: http://trantor.cse.psu.edu/~yoo/research.html
Root-URL: http://www.cse.psu.edu
Email: E-mail: fyoo j dasg@cse.psu.edu  
Title: Good Processor Management Fast Allocation Efficient Scheduling  
Author: Byung S. Yoo and Chita R. Das 
Keyword: Index Terms Group scheduling policy, mesh-connected multicomputers, operating systems, processor management, stack-based allocation algorithm  
Address: Park, PA 16802  
Affiliation: Department of Computer Science and Engineering The Pennsylvania State University University  
Abstract: Fast and efficient processor allocation and job scheduling algorithms are essential components of a multi-user multicomputer operating system. In this paper, we propose two novel processor management schemes which meet such demands for mesh-connected multicomputers. A stack-based allocation algorithm that can locate a free sub-mesh for a job very quickly using simple coordinate calculation and spatial subtraction is proposed. Simulation results show that the stack-based allocation algorithm outperforms all the existing allocation policies in terms of allocation overhead while delivering competitive performance. Another technique, called group scheduling, schedules jobs in such a way that the jobs belonging to the same group do not block each other. The groups are scheduled in an FCFS order to prevent starvation. This simple but efficient scheduling policy reduces the response time significantly by minimizing the queueing delay for the jobs in the same group. These two schemes, when used together, can provide faster service to users with very little overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Babbar and P. Krueger, </author> <title> A Performance Comparison of Processor Allocation and Job Scheduling Algorithms for Mesh-Connected Multiprocessors, </title> <booktitle> Proc. 6th IEEE Symp. on Parallel and Distributed Processing, </booktitle> <pages> pp. 46-53, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: MIP-9406984. performance and complexity. The main focus of this paper is on developing a fast contiguous processor allocation algorithm for low-dimensional mesh architectures. Prior research indicates that better submesh recognition ability of an allocation algorithm provides only incremental performance gain at the cost of high run-time overhead <ref> [1, 4, 11] </ref>. It is therefore important to develop a faster allocation algorithm than to improve the recognition ability of the algorithm. Further performance improvement can be achieved by using a scheduling scheme other than the usual FCFS method. <p> Each side of a submesh request is calculated following a uniform, normal, or bimodal uniform distribution. In a bimodal uniform distribution, each side of a submesh request is uniformly selected from an interval <ref> [1; m] </ref> with a probability ' and selected from an interval [m+1; l] with a probability (1-') for some integer m (1 m &lt; l), where l represents the length of the corresponding side of mesh system.
Reference: [2] <author> P. J. Chuang and N. F. Tzeng, </author> <title> An Efficient Submesh Allocation Strategy for Mesh Computer Systems, </title> <booktitle> Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 256-263, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: We have selected these policies for comparison because they represent simple, fast, and efficient bitmap-based (first fit) and list-based (quick allocation) algorithms. Other existing allocation algorithms are not described here due to space limitation. These algorithms are described in detail in <ref> [2, 3, 5, 6, 7, 8] </ref>. First Fit (FF) The first fit strategy [13] can be used for meshes of arbitrary sizes and incurs no internal fragmentation. It maintains a busy array representing the allocation status of the mesh.
Reference: [3] <author> J. Ding and L. N. Bhuyan, </author> <title> An Adaptive Submesh Allocation Strategy for Two-Dimensional Mesh Connected Systems, </title> <booktitle> Proc. Int'l Conf. on Parallel Processing, </booktitle> <volume> Vol. II, </volume> <pages> pp. 193-200, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: We have selected these policies for comparison because they represent simple, fast, and efficient bitmap-based (first fit) and list-based (quick allocation) algorithms. Other existing allocation algorithms are not described here due to space limitation. These algorithms are described in detail in <ref> [2, 3, 5, 6, 7, 8] </ref>. First Fit (FF) The first fit strategy [13] can be used for meshes of arbitrary sizes and incurs no internal fragmentation. It maintains a busy array representing the allocation status of the mesh.
Reference: [4] <author> P. Krueger, T. H. Lai and V. A. Radiya, </author> <title> Job Scheduling Is More Important than Processor Allocation for Hypercube Computers, </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> Vol. 5, </volume> <pages> pp. 488-497, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: MIP-9406984. performance and complexity. The main focus of this paper is on developing a fast contiguous processor allocation algorithm for low-dimensional mesh architectures. Prior research indicates that better submesh recognition ability of an allocation algorithm provides only incremental performance gain at the cost of high run-time overhead <ref> [1, 4, 11] </ref>. It is therefore important to develop a faster allocation algorithm than to improve the recognition ability of the algorithm. Further performance improvement can be achieved by using a scheduling scheme other than the usual FCFS method.
Reference: [5] <author> K. Li and K. H. Cheng, </author> <title> A Two Dimensional Buddy System for Dynamic Resource Allocation in A Partitionable Mesh Connected System, </title> <booktitle> Proc. ACM Computer Science Conf., </booktitle> <pages> pp. 22-28, </pages> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: We have selected these policies for comparison because they represent simple, fast, and efficient bitmap-based (first fit) and list-based (quick allocation) algorithms. Other existing allocation algorithms are not described here due to space limitation. These algorithms are described in detail in <ref> [2, 3, 5, 6, 7, 8] </ref>. First Fit (FF) The first fit strategy [13] can be used for meshes of arbitrary sizes and incurs no internal fragmentation. It maintains a busy array representing the allocation status of the mesh.
Reference: [6] <author> T. Liu, W. Huang, F. Lombardi and L. N. Bhuyan, </author> <title> A Sub-mesh Allocation Scheme for Mesh-Connected Multiprocessor Systems, </title> <booktitle> Proc. Int'l Conf. on Parallel Processing, </booktitle> <volume> Vol. II, </volume> <pages> pp. 159-163, </pages> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: We have selected these policies for comparison because they represent simple, fast, and efficient bitmap-based (first fit) and list-based (quick allocation) algorithms. Other existing allocation algorithms are not described here due to space limitation. These algorithms are described in detail in <ref> [2, 3, 5, 6, 7, 8] </ref>. First Fit (FF) The first fit strategy [13] can be used for meshes of arbitrary sizes and incurs no internal fragmentation. It maintains a busy array representing the allocation status of the mesh.
Reference: [7] <author> W. Liu, V. Lo and B. Nitzberg, </author> <title> Non-contiguous Processor Allocation Algorithms for Distributed Memory Multicom-puters, </title> <booktitle> Proc. Supercomputing '94, </booktitle> <pages> pp. 227-236, </pages> <year> 1994. </year>
Reference-contexts: We have selected these policies for comparison because they represent simple, fast, and efficient bitmap-based (first fit) and list-based (quick allocation) algorithms. Other existing allocation algorithms are not described here due to space limitation. These algorithms are described in detail in <ref> [2, 3, 5, 6, 7, 8] </ref>. First Fit (FF) The first fit strategy [13] can be used for meshes of arbitrary sizes and incurs no internal fragmentation. It maintains a busy array representing the allocation status of the mesh.
Reference: [8] <author> D. Das Sharma and D. K. Pradhan, </author> <title> A Fast and Efficient Strategy for Submesh Allocation in Mesh-Connected Parallel Computers, </title> <booktitle> Proc. 5th IEEE Symp. on Parallel and Distributed Processing, </booktitle> <pages> pp. 682-689, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: We have selected these policies for comparison because they represent simple, fast, and efficient bitmap-based (first fit) and list-based (quick allocation) algorithms. Other existing allocation algorithms are not described here due to space limitation. These algorithms are described in detail in <ref> [2, 3, 5, 6, 7, 8] </ref>. First Fit (FF) The first fit strategy [13] can be used for meshes of arbitrary sizes and incurs no internal fragmentation. It maintains a busy array representing the allocation status of the mesh.
Reference: [9] <author> K. S. Trivedi, </author> <title> Probability and Statistics with Reliability, Queuing, </title> <booktitle> and Computer Science Applications, </booktitle> <publisher> Prentice-Hall Inc., </publisher> <year> 1982. </year>
Reference-contexts: The job in-terarrival time is assumed to follow an exponential distribution with a mean 1 . The job service time (or demand) follows a bimodal hyperexponential distribution, which is considered as the most probable distribution for the processor service time <ref> [9] </ref>, with a mean 1 . The service demand of a job is computed based on the system load (ae). The system load is defined as ae = , where is the mean job service rate and is the mean job arrival rate.
Reference: [10] <author> B. S. Yoo and C. R. Das, </author> <title> A Fast and Efficient Processor Management Scheme for Mesh-Connected Multicomputer Systems, </title> <type> Technical Report, </type> <institution> CSE-97-002, Dept. of Computer Science and Engineering, The Pennsylvania State University, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: Therefore, assuming that the stack length is a constant, the overall time complexity of above algorithm is O (B), where B is the length of the busy list. The time complexity and other performance characteristics of the proposed algorithm and other existing schemes are compared in <ref> [10] </ref>. It is interesting to note that the stack-based allocation scheme is versatile in the sense that it can emulate other existing allocation schemes. <p> The effect of group size on the response time has also been analyzed. However, in the interest of brevity, these results are not presented here. Interested readers may refer to <ref> [10] </ref>. 5 Conclusions It has been observed that the performance gain obtained by improving the efficiency of an underlying allocation algorithm, at the expense of high run-time overhead, is insignificant and that job scheduling plays an equally important role in improving the system performance.
Reference: [11] <author> B. S. Yoo, C. R. Das and C. Yu, </author> <title> Processor Management Techniques for Mesh-Connected Multiprocessors, </title> <booktitle> Proc. Int'l Conf. on Parallel Processing, </booktitle> <volume> Vol. II, </volume> <pages> pp. 105-112, </pages> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: MIP-9406984. performance and complexity. The main focus of this paper is on developing a fast contiguous processor allocation algorithm for low-dimensional mesh architectures. Prior research indicates that better submesh recognition ability of an allocation algorithm provides only incremental performance gain at the cost of high run-time overhead <ref> [1, 4, 11] </ref>. It is therefore important to develop a faster allocation algorithm than to improve the recognition ability of the algorithm. Further performance improvement can be achieved by using a scheduling scheme other than the usual FCFS method.
Reference: [12] <author> S. M. Yoo and H. Y. Youn, </author> <title> An Efficient Task Allocation Scheme for Two-Dimensional Mesh-Connected Systems, </title> <booktitle> Proc. Int'l. Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 501-508, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: The groups are scheduled in an FCFS order to avoid starvation. In-depth performance analysis of the two proposed techniques are conducted via simulation. Two schemes, the first fit (FF) algorithm [13] that has been referred in most prior studies and the more recent quick allocation (QA) algorithm <ref> [12] </ref> that has been shown to be the fastest allocation algorithm, are used for comparison in our study. It is shown that the stack-based allocation method outperforms all the existing allocation policies in terms of allocation overhead while providing comparable performance. <p> L: [&lt;A.base.x,A.base.y&gt;,<B.base.x-1,A.end.y>] R: [&lt;B.end.x+1,A.base.y&gt;,<A.end.x,A.end.y>] U: [&lt;B.base.x,B.end.y+1&gt;,<B.end.x,A.end.y>] to the problem of finding the base set B J and selecting a node in B J as the base of a free submesh for J . 2.2 Related Work Two (submesh) allocation algorithms of interest, first fit (FF) [13] and quick allocation (QA) <ref> [12] </ref>, are briefly discussed in this subsection. We have selected these policies for comparison because they represent simple, fast, and efficient bitmap-based (first fit) and list-based (quick allocation) algorithms. Other existing allocation algorithms are not described here due to space limitation. <p> This high run-time overhead renders the algorithm (and any bitmap-based algorithms) unattractive, especially when the mesh system is large or a fast submesh allocation is required. Quick Allocation (QA) This recently proposed allocation scheme aims at providing complete submesh recognition ability with minimal run-time overhead <ref> [12] </ref>. The basic idea of the QA scheme is very similar to that of the FF strategy. In an effort to reduce search overhead, the QA scheme identifies a set of adjacent processors, called covered segment, for each row. <p> Furthermore, the column wise scan employed by many bitmap-based algorithms can also be avoided. It has been shown that the QA algorithm is the fastest and the most efficient of all the allocation policies reported in the literature <ref> [12] </ref>. However, the construction of the covered segments requires a sorting operation whose cost is relatively expensive (but not as expensive as bitmap operations). In addition, the allocation overhead of the QA scheme linearly increases as number of rows in the mesh increases. The reader should refer to [12] for the <p> the literature <ref> [12] </ref>. However, the construction of the covered segments requires a sorting operation whose cost is relatively expensive (but not as expensive as bitmap operations). In addition, the allocation overhead of the QA scheme linearly increases as number of rows in the mesh increases. The reader should refer to [12] for the detailed discussion of the QA algorithm. 3 Proposed Processor Management Schemes 3.1 Processor Allocation The basic idea of our approach is to find a base set for allocation of a job. <p> By manipulating the order in which candidate blocks are pushed into the stack and by using a fixed location in a selected base block as a base, some of the prior algorithms can be emulated with significantly reduced search time. For example, the FF strategy [13] (QA strategy <ref> [12] </ref>) can be emulated by ordering the candidate blocks in such a way that a block with a base &lt; x 1 ; y 1 &gt; precedes a block with a base &lt; x 2 ; y 2 &gt; when x 1 &lt; x 2 or x 1 = x 2 <p> In what follows, the performance of the QA allocation scheme is compared with that of the stack-based allocation algorithm (STACK). Other allocation schemes are not considered in this paper simply because the QA scheme is the fastest of all the allocation algorithms reported in the literature <ref> [12] </ref>. The QA algorithm is emulated by the stack-based algorithm (hence called emulated quick allocation (EQA) scheme) and its performance is compared to show that the proposed allocation scheme can emulate the QA scheme with far less overhead. <p> In Fig. 5 and Fig. 6, the performance of the stack-based algorithms, STACK, EQA, and EFF, is compared with that of the QA <ref> [12] </ref> scheme, when the job size follows a uniform and a bimodal uniform distribution, respectively. <p> The stack-based allocation and group scheduling, when used together, can provide faster service to users with very little overhead. Acknowledgment The authors would like to thank S. Yoo for providing source code for his approach <ref> [12] </ref>.
Reference: [13] <author> Y. Zhu, </author> <title> Efficient Processor Allocation Strategies for Mesh Connected Parallel Computers, </title> <journal> Journal of Parallel and Dis tributed Computing, </journal> <volume> Vol. 16, </volume> <pages> pp. 328-337, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: Jobs in the same group do not block each other as in FCFS scheduling. The groups are scheduled in an FCFS order to avoid starvation. In-depth performance analysis of the two proposed techniques are conducted via simulation. Two schemes, the first fit (FF) algorithm <ref> [13] </ref> that has been referred in most prior studies and the more recent quick allocation (QA) algorithm [12] that has been shown to be the fastest allocation algorithm, are used for comparison in our study. <p> &lt;A.end.x,A.end.y&gt; A - B = L: [&lt;A.base.x,A.base.y&gt;,<B.base.x-1,A.end.y>] R: [&lt;B.end.x+1,A.base.y&gt;,<A.end.x,A.end.y>] U: [&lt;B.base.x,B.end.y+1&gt;,<B.end.x,A.end.y>] to the problem of finding the base set B J and selecting a node in B J as the base of a free submesh for J . 2.2 Related Work Two (submesh) allocation algorithms of interest, first fit (FF) <ref> [13] </ref> and quick allocation (QA) [12], are briefly discussed in this subsection. We have selected these policies for comparison because they represent simple, fast, and efficient bitmap-based (first fit) and list-based (quick allocation) algorithms. Other existing allocation algorithms are not described here due to space limitation. <p> Other existing allocation algorithms are not described here due to space limitation. These algorithms are described in detail in [2, 3, 5, 6, 7, 8]. First Fit (FF) The first fit strategy <ref> [13] </ref> can be used for meshes of arbitrary sizes and incurs no internal fragmentation. It maintains a busy array representing the allocation status of the mesh. With respect to a job to be allocated, the busy array is searched to construct a coverage array, which represents a coverage set. <p> The nodes and links are not shown in the figure for clarity. The coverages of these two busy submeshes are represented as shaded rectangles. First, the reject area R J with sink &lt; 14; 6 &gt; is determined. Using the sink, then, an initial candidate block B 1 <ref> [&lt; 0; 0 &gt;; &lt; 13; 5 &gt;] </ref> is pushed onto the stack with C 1 as the next coverage to be checked against as shown in Fig. 3.b. Here, B 1 represents U R J . <p> By manipulating the order in which candidate blocks are pushed into the stack and by using a fixed location in a selected base block as a base, some of the prior algorithms can be emulated with significantly reduced search time. For example, the FF strategy <ref> [13] </ref> (QA strategy [12]) can be emulated by ordering the candidate blocks in such a way that a block with a base &lt; x 1 ; y 1 &gt; precedes a block with a base &lt; x 2 ; y 2 &gt; when x 1 &lt; x 2 or x 1 <p> The FCFS scheduling policy is used in this study. First, we demonstrate the versatility and the usefulness of the proposed allocation algorithm by comparing the allocation overhead of the bit-map based first fit (BFF) <ref> [13] </ref> scheme to that of the emulated first fit (EFF). The EFF scheme is simply the BFF policy emulated by our stack-based allocation scheme using the method explained in Section 3.1. Obviously, both algorithms have the same response time behavior.
References-found: 13

