URL: http://www.cag.lcs.mit.edu/bayanihan/papers/wwca98/wwca98.ps
Refering-URL: http://www.cag.lcs.mit.edu/bayanihan/papers/wwca98/html/
Root-URL: 
Email: lfgs@cag.lcs.mit.edu  
Title: Bayanihan: Web-Based Volunteer Computing Using Java  
Author: Luis F. G. Sarmenta 
Web: http://www.cag.lcs.mit.edu/bayanihan  
Address: 545 Technology Square Cambridge, MA 02139  
Affiliation: MIT Laboratory for Computer Science Computer Architecture Group  
Abstract: This paper presents and discusses the idea of Web-based volunteer computing, which allows people to cooperate in solving a large parallel problem by using standard Web browsers to volunteer their computers' processing power. Because volunteering requires no prior human contact and very little technical knowledge, it becomes very easy to build very large volunteer computing networks. At its full potential, volunteer computing can make it possible to build world-wide massively parallel computing networks more powerful than any supercomputer. Even on a smaller, more practical scale, volunteer computing can be used within companies or institutions to provide supercomputer-like facilities by harnessing the computing power of existing workstations. Many interesting variations are possible, including networks of information appliances (NOIAs), paid volunteer systems, and barter trade of compute cycles. In this paper, we discuss these possibilities, and identify several issues that will need to be addressed in order to successfully implement them. We also present an overview of the current work being done in the Bayani han volunteer computing project.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Strumpen, V.: </author> <title> Coupling Hundreds of Workstations for Parallel Molecular Sequence Analysis. </title> <journal> Software Practice and Experience. </journal> <month> 25(3) </month> <year> (1995) </year> <month> 291-304 </month>
Reference-contexts: Global-scale NOWs, employing computers geographically distributed around the world and communicating through the Internet, have been used with great success to solve large parallel problems as far back as the early 90's <ref> [1, 2] </ref>, and until today [3, 4, 5]. Unfortunately, most of these earlier projects have used ad hoc software systems. Typically, a subsystem for providing communication and coordination between machines in the NOW had to be developed mostly from scratch as part of each project.
Reference: 2. <author> Levy, S.: Wisecrackers. </author> <note> Wired, issue 4.03. (Mar. 1996) http://www.hotwired.com/wired/4.03/features/crackers.html </note>
Reference-contexts: Global-scale NOWs, employing computers geographically distributed around the world and communicating through the Internet, have been used with great success to solve large parallel problems as far back as the early 90's <ref> [1, 2] </ref>, and until today [3, 4, 5]. Unfortunately, most of these earlier projects have used ad hoc software systems. Typically, a subsystem for providing communication and coordination between machines in the NOW had to be developed mostly from scratch as part of each project.
Reference: 3. <author> Gibbs, W.: </author> <title> CyberView. </title> <publisher> Scientific American. </publisher> <month> (May </month> <year> 1997) </year>
Reference-contexts: Global-scale NOWs, employing computers geographically distributed around the world and communicating through the Internet, have been used with great success to solve large parallel problems as far back as the early 90's [1, 2], and until today <ref> [3, 4, 5] </ref>. Unfortunately, most of these earlier projects have used ad hoc software systems. Typically, a subsystem for providing communication and coordination between machines in the NOW had to be developed mostly from scratch as part of each project.
Reference: 4. <author> Beberg, A. L., Lawson, J., McNett, D.: distributed.net. </author> <note> http://www.distributed.net </note>
Reference-contexts: Global-scale NOWs, employing computers geographically distributed around the world and communicating through the Internet, have been used with great success to solve large parallel problems as far back as the early 90's [1, 2], and until today <ref> [3, 4, 5] </ref>. Unfortunately, most of these earlier projects have used ad hoc software systems. Typically, a subsystem for providing communication and coordination between machines in the NOW had to be developed mostly from scratch as part of each project. <p> reason, the use of PVM and MPI has mostly been restricted to internal use within research institutions, where such close coordination is possible. 2.2 Non-Java-Based Volunteer Computing On October 19, 1997, distributed.net, a world-wide computing network composed of thousands of volunteer machines, successfully cracked the RSA Systems RC5-56 code challenge <ref> [4] </ref>. This network achieved an average aggregate computing power equivalent to about 26,000 commodity PCs, and involved as many as 500,000 different computers (as distinguished by their IP addresses) over a span of 250 days [8]. <p> they do (some ideas about this are presented in [16]), or it can be in the form of a lottery, such the one used in distributed.net, where part of the $10,000 RC5 challenge prize money from RSA Systems was offered to the volunteer team whose computer actually found the key <ref> [4] </ref>. Such lottery schemes not only require less money from the sponsor, but also encourage participation (i.e., the more one works, the bigger one's chances of winning are), and discourages cheating (i.e., pretending to do the work does not give one any chance of winning).
Reference: 5. <author> Woltman, G.: </author> <note> Mersenne.org Main Page. http://www.mersenne.org </note>
Reference-contexts: Global-scale NOWs, employing computers geographically distributed around the world and communicating through the Internet, have been used with great success to solve large parallel problems as far back as the early 90's [1, 2], and until today <ref> [3, 4, 5] </ref>. Unfortunately, most of these earlier projects have used ad hoc software systems. Typically, a subsystem for providing communication and coordination between machines in the NOW had to be developed mostly from scratch as part of each project. <p> Thus, the choice of appropriate target problems plays a large part in attracting and motivating volunteers. One class of target problems that have successfully attracted people are "cool" challenges like Mersenne prime verification <ref> [5] </ref>, the RSA cryptographic challenges [9], and distributed chess [10]. A more interesting and more useful class of target problems, however, is what might be called worthy causes.
Reference: 6. <author> Geist, A., Beguelin, A., Dongarra, J., Jiang, W., Manchek, R., Sunderam, V.: </author> <title> PVM: Parallel Virtual Machine: A User's Guide and Tutorial for Networked Parallelism. </title> <publisher> MIT Press. </publisher> <address> (1994) http://www.netlib.org/pvm3/book/pvm-book.html </address>
Reference-contexts: doing so required a large amount of human effort in terms of setting up, coordinating, and administering the system. 2.1 PVM and MPI In the past five years, this situation has been notably improved by the development of general-purpose and cross-platform parallel processing systems such as Parallel Virtual Machine (PVM) <ref> [6] </ref> and Message Passing Interface (MPI) [7].In such systems, the amount of manual work required is reduced significantly by the runtime system, which takes care of such things as automatically executing the appropriate code on each of the processors involved, keeping track of existing processors, routing and delivering messages, etc.
Reference: 7. <author> Gropp, W., Lusk, E., Skjellum, A.: </author> <title> Using MPI. </title> <publisher> MIT Press. </publisher> <address> (1994) http://www.epm.ornl.gov/ walker/mpi/index.html 8. </address> <publisher> distributed.net press release. </publisher> <month> (Oct. </month> <note> 1997) http://www.distributed.net/pressroom/56-announce.html </note>
Reference: 9. <author> RSA Data Security: </author> <title> RSA Factoring Challenge. </title> <note> http://www.rsa.com/factor/chalenge.htm 10. </note> <author> de Russcher, R.: </author> <title> Possible Projects. </title> <address> http://www.distributed.net/projects.html </address>
Reference-contexts: Thus, the choice of appropriate target problems plays a large part in attracting and motivating volunteers. One class of target problems that have successfully attracted people are "cool" challenges like Mersenne prime verification [5], the RSA cryptographic challenges <ref> [9] </ref>, and distributed chess [10]. A more interesting and more useful class of target problems, however, is what might be called worthy causes.
Reference: 11. <institution> SETI@home home page. </institution> <note> http://www.bigscience.com/setiathome.html </note>
Reference-contexts: A recent and interesting example of a possible worthy cause problem, 2 is the SETI@home project, which aims to use volunteers' home computers to analyze radio telescope data for unusual patterns that may indicate extraterrestrial life <ref> [11] </ref>. 3.2 Forced Volunteer Computing Interestingly, forced volunteer systems are possible as well.
Reference: 12. <institution> Communications of the ACM. </institution> <month> (Nov. </month> <year> 1996) </year>
Reference-contexts: Forced volunteer computing can be used wherever there is a need or opportunity to pool existing (and idle) resources to attain supercomputing power that would otherwise be unaffordable. For example, companies can use computers on their intranet for solving CPU-intensive problems such as market and process simulations, and data-mining <ref> [12] </ref>. Similarly, research labs and universities can use volunteer computing to turn their existing networks 2 Or maybe just a cool challenge, depending on who one talks to. of workstations into virtual supercomputers.
Reference: 13. <author> Rappa, M.: </author> <title> Solomon's House in the 21st century. </title> <note> Working Paper. (Nov. 1994) http://web.mit.edu/technika/www/solomon.html </note>
Reference-contexts: By making it very easy for institutions around the world to share their computing resources, volunteer computing opens up exciting new possibilities in world-wide collaborative research efforts. It can enable researchers in collabora-tories <ref> [13, 14] </ref> to share not only their data and ideas, but their computing power as well. Research institutions on opposite sides of the globe can also barter-trade for each other's computing power, depending on their need.
Reference: 14. <author> Wulf, W.: </author> <title> The Collaboratory Opportunity. </title> <booktitle> Science. </booktitle> <month> (Aug. </month> <year> 1993) </year>
Reference-contexts: By making it very easy for institutions around the world to share their computing resources, volunteer computing opens up exciting new possibilities in world-wide collaborative research efforts. It can enable researchers in collabora-tories <ref> [13, 14] </ref> to share not only their data and ideas, but their computing power as well. Research institutions on opposite sides of the globe can also barter-trade for each other's computing power, depending on their need.
Reference: 15. <institution> PVM home page. </institution> <note> http://www.epm.ornl.gov/pvm/ </note>
Reference-contexts: is day in Japan) in exchange for being able to use the Japanese lab's CPUs during the day (when it is night in Japan). 3 Forced volunteer computing is already being done by many institutions using their own ad hoc tools or libraries such as PVM (the PVM home page <ref> [15] </ref> has some links to PVM-based projects). Java-based forced volunteer computing improves on these by being much easier to use for everyone users, programmers, and administrators alike.
Reference: 16. <author> Alexandrov, A. D., Ibel, M., Schauser K. E., Scheiman, C. J.: SuperWeb: </author> <booktitle> Towards a Global Web-Based Parallel Computing Infrastructure 11th International Parallel Processing Symposium. </booktitle> <address> (April 1997) http://www.cs.ucsb.edu/research/superweb/ </address>
Reference-contexts: One way to increase participation in a volunteer computing system is to provide individual compensation as an incentive for volunteers. This can take the form of electronic credits proportional to the amount of work that they do (some ideas about this are presented in <ref> [16] </ref>), or it can be in the form of a lottery, such the one used in distributed.net, where part of the $10,000 RC5 challenge prize money from RSA Systems was offered to the volunteer team whose computer actually found the key [4]. <p> If reliable mechanisms for electronic currency, accounting, and bro-kering are developed, market systems promise a practical and productive use for volunteer computing technology. The SuperWeb group at UCSB is already actively pursuing this goal <ref> [16] </ref>. Forced and paid volunteer computing can be combined in contract-based systems: clients can be required by contract to volunteer their computers as (part of) their payment for goods or services received. <p> If Company A purchases computing power from Company B, a spy in B may read data from A's computation while he is doing it. For some classes of computations, encrypted computation techniques can be used to alleviate this problem <ref> [16] </ref>. 3.4 Networks of Information Appliances (NOIA) Many experts, both in industry and in the academic community, predict that in the near future, information appliances devices for retrieving information from the Internet which are as easy to use as everyday appliances such as TVs and VCRs will become commonplace [19, 20]. <p> One way to guarantee that a node cannot fake a checksum computation is to prevent it from disassembling the code. This is not an easy task, but in some cases, it may be possible to apply encrypted computation techniques, such as those that <ref> [16] </ref> proposes to use against spying. If cryptographically preventing disassembly is not possible, we can resort to dynamic obfuscation techniques to make understanding the disassembled code and isolating the checksum code as difficult as possible. <p> There is plenty of space in this field for exploration, and indeed many have already started <ref> [16, 18, 24, 28, 31, 32, 43] </ref>.
Reference: 17. <institution> DigiCrime Computational Services via Java. </institution> <note> (June 1996) http://www.digicrime.com/java.html </note>
Reference-contexts: Sites that require users to volunteer must say so clearly, and allow the user to back-out if they do not agree to the terms. Some of these ideas are discussed in <ref> [17, 18] </ref>. Some problems in anonymous paid volunteer systems are cheating (pretending to do work and getting paid for it), and spying. If Company A purchases computing power from Company B, a spy in B may read data from A's computation while he is doing it.
Reference: 18. <author> Vanhelsuwe, L.: </author> <title> Create your own supercomputer with Java. </title> <address> JavaWorld. </address> <month> (Jan. </month> <note> 1997) http://www.javaworld.com/jw-01-1997/jw-01-dampp.ibd.html </note>
Reference-contexts: Sites that require users to volunteer must say so clearly, and allow the user to back-out if they do not agree to the terms. Some of these ideas are discussed in <ref> [17, 18] </ref>. Some problems in anonymous paid volunteer systems are cheating (pretending to do work and getting paid for it), and spying. If Company A purchases computing power from Company B, a spy in B may read data from A's computation while he is doing it. <p> There is plenty of space in this field for exploration, and indeed many have already started <ref> [16, 18, 24, 28, 31, 32, 43] </ref>.
Reference: 19. <author> Gates, B.: </author> <title> The Road Ahead. Viking, a division of Penguin Books, </title> <address> USA. </address> <year> (1995) </year>
Reference-contexts: problem [16]. 3.4 Networks of Information Appliances (NOIA) Many experts, both in industry and in the academic community, predict that in the near future, information appliances devices for retrieving information from the Internet which are as easy to use as everyday appliances such as TVs and VCRs will become commonplace <ref> [19, 20] </ref>. In the United States today, companies such as WebTV [21] are starting to develop and sell information appliances, and cable companies are starting to include support for cable modems, using the same cable that carries the TV signals [22].
Reference: 20. <author> Negroponte, N.: </author> <title> Being Digital. Vintage Books, a division of Random House. </title> <year> (1995) </year>
Reference-contexts: problem [16]. 3.4 Networks of Information Appliances (NOIA) Many experts, both in industry and in the academic community, predict that in the near future, information appliances devices for retrieving information from the Internet which are as easy to use as everyday appliances such as TVs and VCRs will become commonplace <ref> [19, 20] </ref>. In the United States today, companies such as WebTV [21] are starting to develop and sell information appliances, and cable companies are starting to include support for cable modems, using the same cable that carries the TV signals [22].
Reference: 21. <institution> WebTV home page. </institution> <note> http://www.webtv.com/ns/index.html </note>
Reference-contexts: In the United States today, companies such as WebTV <ref> [21] </ref> are starting to develop and sell information appliances, and cable companies are starting to include support for cable modems, using the same cable that carries the TV signals [22].
Reference: 22. <institution> Media One home page. </institution> <note> http://www.mediaone.com/ </note>
Reference-contexts: In the United States today, companies such as WebTV [21] are starting to develop and sell information appliances, and cable companies are starting to include support for cable modems, using the same cable that carries the TV signals <ref> [22] </ref>. It is not hard to imagine that within the next five or ten years, the information appliance will be as commonplace as the VCR, and high-speed Internet access as commonplace as cable TV.
Reference: 23. <author> Gelernter, D., Kaminsky, D.: </author> <title> Supercomputing out of recycled garbage: Preliminary experience with Piranha. </title> <booktitle> Proceedings of the 1992 ACM International Conference of Supercomputing. </booktitle> <month> (July </month> <year> 1992). </year>
Reference-contexts: Even nodes with the same type of CPU cannot be assumed to have equal or constant computing capacities, since each can be loaded differently by external tasks (especially in systems which try to exploit users' idle times). For these reasons, models for volunteer computing systems must be adaptively parallel <ref> [23] </ref>. That is, unlike many traditional parallel programming models, they must not assume the existence of a fixed number of nodes, or depend on any static timing information about the system. Various strategies for implementing adaptive parallelism have already been proposed and studied. <p> Since this tuple-space is global and optionally blocking, it can be used both for communication and synchronization between parallel tasks. It can also serve as a work pool, which like in eager scheduling, can allow undone tasks to be redone. Linda was originally used in the Piranha <ref> [23] </ref> system, and more recently implemented in Java by WWWinda [26], Jada [27], and Javelin [28]. In Cilk [29], a task running on a node, A, can spawn a child task, which the node then executes.
Reference: 24. <author> Baratloo, A., Karaul, M., Kedem, Z., Wyckoff, P.: </author> <title> Charlotte: Metacomputing on the Web. </title> <booktitle> Proc. of the 9th International Conference on Parallel and Distributed Computing Systems. </booktitle> <month> (Sep. </month> <note> 1996) http://cs.nyu.edu/milan/charlotte/ </note>
Reference-contexts: That is, unlike many traditional parallel programming models, they must not assume the existence of a fixed number of nodes, or depend on any static timing information about the system. Various strategies for implementing adaptive parallelism have already been proposed and studied. In eager scheduling <ref> [24] </ref>, packets of work to be done are kept in a pool from which worker nodes get any undone work whenever they run out of work to do. In this way, faster workers get more work according to their capability. <p> In this way, faster workers get more work according to their capability. And, if any work is left undone by a slow node, or a node that "dies", it eventually gets reassigned to another worker. Systems that implement eager schedule include Charlotte <ref> [24] </ref> and the factoring demo used in Sect. 4.3. The Linda model [25] provides an associative tuple-space that can be used to store both data and tasks to be done. Since this tuple-space is global and optionally blocking, it can be used both for communication and synchronization between parallel tasks. <p> There is plenty of space in this field for exploration, and indeed many have already started <ref> [16, 18, 24, 28, 31, 32, 43] </ref>.
Reference: 25. <author> Carriero, N., Gelernter, D.: </author> <title> Linda in Context. </title> <journal> Comm. of the ACM. </journal> <month> (Apr. </month> <year> 1989) </year>
Reference-contexts: And, if any work is left undone by a slow node, or a node that "dies", it eventually gets reassigned to another worker. Systems that implement eager schedule include Charlotte [24] and the factoring demo used in Sect. 4.3. The Linda model <ref> [25] </ref> provides an associative tuple-space that can be used to store both data and tasks to be done. Since this tuple-space is global and optionally blocking, it can be used both for communication and synchronization between parallel tasks.
Reference: 26. <author> Gutfreund, Y. S.: </author> <note> The WWWinda Orchestrator. http://info.gte.com/ftp/circus/Orchestrator </note>
Reference-contexts: It can also serve as a work pool, which like in eager scheduling, can allow undone tasks to be redone. Linda was originally used in the Piranha [23] system, and more recently implemented in Java by WWWinda <ref> [26] </ref>, Jada [27], and Javelin [28]. In Cilk [29], a task running on a node, A, can spawn a child task, which the node then executes.
Reference: 27. <author> Rossi, D.: </author> <note> Jada home page. http://www.cs.unibo.it/ rossi/jada/ </note>
Reference-contexts: It can also serve as a work pool, which like in eager scheduling, can allow undone tasks to be redone. Linda was originally used in the Piranha [23] system, and more recently implemented in Java by WWWinda [26], Jada <ref> [27] </ref>, and Javelin [28]. In Cilk [29], a task running on a node, A, can spawn a child task, which the node then executes.
Reference: 28. <author> Cappello, P., Christiansen, B. O., Ionescu, M. F.,, Neary, M. O., Schauser, K. E., Wu, D.: Javelin: </author> <title> Internet-Based Parallel Computing Using Java. </title> <booktitle> ACM Workshop on Java for Science and Engineering Computation. </booktitle> <address> (June 1997) http://www.cs.ucsb.edu/research/superweb/ </address>
Reference-contexts: It can also serve as a work pool, which like in eager scheduling, can allow undone tasks to be redone. Linda was originally used in the Piranha [23] system, and more recently implemented in Java by WWWinda [26], Jada [27], and Javelin <ref> [28] </ref>. In Cilk [29], a task running on a node, A, can spawn a child task, which the node then executes. <p> There is plenty of space in this field for exploration, and indeed many have already started <ref> [16, 18, 24, 28, 31, 32, 43] </ref>.
Reference: 29. <author> Blumofe, R. D., Joerg C. F., Kuszmaul, B. C., Leiserson, C. E., Randall, K. H., Zhou, Y.: Cilk: </author> <title> An Efficient Multithreaded Runtime System. </title> <booktitle> Proceedings of the 5th ACM SIGPLAN Symposium on Principles of Parallel Programming (PPOPP '95). </booktitle> <address> (July 1995) http://theory.lcs.mit.edu/~cilk/ </address>
Reference-contexts: It can also serve as a work pool, which like in eager scheduling, can allow undone tasks to be redone. Linda was originally used in the Piranha [23] system, and more recently implemented in Java by WWWinda [26], Jada [27], and Javelin [28]. In Cilk <ref> [29] </ref>, a task running on a node, A, can spawn a child task, which the node then executes. If another node, B, runs out of work while Node A is still running the child task, it can steal the parent task from Node A and continue to execute it.
Reference: 30. <author> Blumofe, R. D., Lisiecki, P. A.: </author> <title> Adaptive and Reliable Parallel Computing on Networks of Workstations. </title> <booktitle> Proceedings of the USENIX 1997 Annual Technical Symposium. </booktitle> <month> (Jan. </month> <year> 1997) </year>
Reference-contexts: If another node, B, runs out of work while Node A is still running the child task, it can steal the parent task from Node A and continue to execute it. This work-stealing algorithm has been shown to be provably efficient and fault-tolerant. Cilk has been implemented for NOWs <ref> [30] </ref>, and has been implemented using Java applications (but not applets) in ATLAS [31].
Reference: 31. <author> Baldeschwieler, J. E., Blumofe, R. D., Brewer, E. </author> <title> A: ATLAS: An Infrastructure for Global Computing. </title> <booktitle> Proceedings of the Seventh ACM SIGOPS European Workshop: Systems Support for Worldwide Applications. </booktitle> <month> (Sep. </month> <year> 1996) </year>
Reference-contexts: This work-stealing algorithm has been shown to be provably efficient and fault-tolerant. Cilk has been implemented for NOWs [30], and has been implemented using Java applications (but not applets) in ATLAS <ref> [31] </ref>. Project Bayanihan aims to develop a framework that does not limit the programmer to using only one form of adaptive parallelism, but instead makes it easy to implement any of these forms and even develop new ones. Fault-Tolerance. <p> There is plenty of space in this field for exploration, and indeed many have already started <ref> [16, 18, 24, 28, 31, 32, 43] </ref>.
Reference: 32. <author> Brecht, T., Sandhu, H., Shan, M., Talbot, J.,: ParaWeb: </author> <title> Towards World-Wide Supercomputing. </title> <booktitle> Proceedings of the Seventh ACM SIGOPS European Workshop: Systems Support for Worldwide Applications. </booktitle> <month> (Sep. </month> <year> 1996) </year>
Reference-contexts: There is plenty of space in this field for exploration, and indeed many have already started <ref> [16, 18, 24, 28, 31, 32, 43] </ref>.
Reference: 33. <author> Lynch, N. A.: </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kauffman Publishers. </publisher> <year> (1996) </year>
Reference-contexts: Fault-Tolerance. Faults in distributed systems can generally be classified into stopping faults and Byzantine faults <ref> [33] </ref>. Stopping faults cover cases of processors crashing or leaving, and are automatically handled by adaptively parallel systems. Byzantine faults cover all other kinds of faults, including unintentional random faults such as data loss or corruption due to faulty network links, or faulty processors, as well as intentional malicious attacks. <p> In general, however, we can think of Byzantine faults simply as faults that result in the generation of incorrect result packets. Byzantine faults can be handled using replication techniques such as majority voting or the more sophisticated and reliable algorithms in <ref> [33] </ref>. (To prevent sabotage by groups, replicated nodes would preferrably belong to different Internet domains.) However, this has the disadvantage of being very inefficient since a replication factor r means a factor r drop in aggregate computational speed. We can improve efficiency by spot-checking.
Reference: 34. <author> Schneier, B.: </author> <title> Applied Cryptography. 2nd ed. </title> <publisher> John Wiley & Sons. </publisher> <year> (1996) </year>
Reference-contexts: This node can either be an internal saboteur who is actually a participating volunteer, or an external spoofer anode that has not volunteered, but sends messages forged to look like they came from one of the volunteers. Spoofing can be prevented with digital signatures <ref> [34] </ref>. These enable the server to verify that a result packet indeed comes from a volunteer. They can also be used in the other direction, to assure a volunteer that an applet really comes from the server, and not from a spoofer.
Reference: 35. <author> Borland: </author> <title> JBuilder. </title> <note> (1997) http://www.borland.com/jbuilder/ </note>
Reference-contexts: If cryptographically preventing disassembly is not possible, we can resort to dynamic obfuscation techniques to make understanding the disassembled code and isolating the checksum code as difficult as possible. Dynamic obfuscation extends the idea of static obfuscation (such as done in Borland's JBuilder <ref> [35] </ref>) by continously obfuscating code dynamically in time. For example, we can randomly vary the checksum formula and its location within the bytecode from work packet to work packet. This would prevent hackers from manually disassembling and modifying the bytecode once and for all.
Reference: 36. <author> McAfee Associates: </author> <title> Virus Information Library: </title> <note> Polymorphism. http://www.mcafee.com/support/techdocs/vinfo/t0022.asp </note>
Reference-contexts: This would prevent hackers from manually disassembling and modifying the bytecode once and for all. We can also insert dummy code at varying locations. These schemes are inspired by polymorphic computer viruses, which use them to hide themselves from anti-virus programs <ref> [36] </ref>. Although very difficult, de-obfuscating polymorphic viruses is not impossible because viruses, being self-reproductive (by definition), contain the obfuscating code. Thus, once one version has been cracked and disassembled, it is possible to reverse engineer this code and develop an "antidote" which can disassemble other instances of the viruses.
Reference: 37. <author> Hirano, S.: HORB: </author> <title> Extended execution of Java Programs. </title> <booktitle> Proceedings of the First International Conference on World-Wide Computing and its Applications (WWCA97). </booktitle> <address> (March 1997) http://ring.etl.go.jp/openlab/horb/ </address>
Reference-contexts: At present we have a basic prototype using HORB <ref> [37] </ref>, a distributed object library that provides remote objects capabilities in Java similar to those of Sun's RMI [38], but not requiring JDK 1.1. In this section, we provide a brief overview of this prototype framework. The details will be discussed in more depth in a separate paper [39]. Architecture.
Reference: 38. <author> Sun Microsystems: </author> <title> Remote Method Invocation. </title> <address> http://www.javasoft.com/products/jdk/1.1/docs/guide/rmi/ </address>
Reference-contexts: At present we have a basic prototype using HORB [37], a distributed object library that provides remote objects capabilities in Java similar to those of Sun's RMI <ref> [38] </ref>, but not requiring JDK 1.1. In this section, we provide a brief overview of this prototype framework. The details will be discussed in more depth in a separate paper [39]. Architecture. Figure 1 shows a high-level block diagram of a system using the Bayanihan framework. Fig. 1.
Reference: 39. <author> Sarmenta, L. F. G., Hirano, S., Ward, S. A.: </author> <title> Towards Bayanihan: Building an Extensible Framework for Volunteer Computing Using Java ACM 1998 Workshop on Java for High-Performance Network Computing. </title> <note> (submitted) </note>
Reference-contexts: In this section, we provide a brief overview of this prototype framework. The details will be discussed in more depth in a separate paper <ref> [39] </ref>. Architecture. Figure 1 shows a high-level block diagram of a system using the Bayanihan framework. Fig. 1. A Bayanihan system On the client side, an engine runs in its own thread, and takes care of receiving and processing data objects from its corresponding manager on the server.
Reference: 40. <author> Roberts, D., Johnson, R.: </author> <title> Evolving Frameworks: A Pattern Language for Developing Object-Oriented Frameworks. </title> <institution> University of Illinois. </institution> <note> (1997) http://st-www.cs.uiuc.edu/users/droberts/evolve.html </note>
Reference-contexts: Programmers can write a Bayanihan application by simply filling-in hot-spots <ref> [40] </ref> in the framework. They can use existing library components, or define their own classes, provided that these classes either implement the appropriate interfaces (e.g., the work data interface containing the process () method), or extend library classes that implement these interfaces.
Reference: 41. <author> Voelker, G., McNamee, D.: </author> <title> The Java Factoring Project. </title> <note> (Sep. 1995) http://www.cs.washington.edu/homes/dylan/ContestEntry.html </note>
Reference-contexts: This problem, inspired by <ref> [41] </ref>, although somewhat unrealistic, was chosen because its simplicity and predictability make it easy to measure performance and analyze results. packets of size 100000000 each. We used five identical 200MHz dual-Pentium machines (one server, and four clients) connected to a 10Base-T Ethernet hub, and running Windows NT 4.0.
Reference: 42. <author> Delorie, D.: djgpp. </author> <note> http://www.delorie.com/djgpp </note>
Reference-contexts: Table 1. Speedup: 8 workers measurement num = ms pure computation (1 worker) 1828 ave. speed (8 workers) 13571 speedup 7.42 efficiency 92.8% To evaluate the performance of Java, relative to C, we wrote a simple C program, compiled it with djgpp <ref> [42] </ref> (the gcc implementation for MS-DOS). Comparing its performance with the one-worker pure computation performance, we get the results shown in Table 2.
Reference: 43. <institution> Proceedings of the ACM 1997 Workshop on Java for Science and Engineering Computation. </institution> <note> (June 1997) http://www.npac.syr.edu/projects/javaforcse/acmprog/prog.html This article was processed using the L A T E X macro package with LLNCS style </note>
Reference-contexts: There is plenty of space in this field for exploration, and indeed many have already started <ref> [16, 18, 24, 28, 31, 32, 43] </ref>.
References-found: 41

