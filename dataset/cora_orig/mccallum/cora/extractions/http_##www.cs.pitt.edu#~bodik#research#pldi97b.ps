URL: http://www.cs.pitt.edu/~bodik/research/pldi97b.ps
Refering-URL: http://www.cs.pitt.edu/~bodik/research/pldi97b.html
Root-URL: 
Email: fbodik,guptag@cs.pitt.edu  
Title: Partial Dead Code Elimination using Slicing Transformations  
Author: Rastislav Bodk Rajiv Gupta 
Keyword: partial dead code elimination, program slicing, program restructuring, path-sensitive optimization.  
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Dept. of Computer Science University of  
Abstract: We present an approach for optimizing programs that uncovers additional opportunities for optimization of a statement by predicating the statement. In this paper predication algorithms for achieving partial dead code elimination (PDE) are presented. The process of predication embeds a statement in a control flow structure such that the statement is executed only if the execution follows a path along which the value computed by the statement is live. The control flow restructuring performed to achieve predication is expressed through slicing transformations. This approach achieves PDE that is not realizable by existing algorithms. We prove that our algorithm never increases the operation count along any path, and that for acyclic code all partially dead statements are eliminated. The slicing transformation that achieves predication introduces into the program additional conditional branches. These branches are eliminated in a branch deletion step based upon code duplication. We also show how PDE can be used by acyclic schedulers for VLIW processors to reduce critical path lengths along frequently executed paths. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Rastislav Bodk, Rajiv Gupta, and Mary Lou Soffa. </author> <title> Interprocedural conditional branch elimination. </title> <booktitle> SIG-PLAN Notices, 1997. Proceedings of the ACM SIG-PLAN '97 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The branches introduced during the predication of a statement are copies of later branches and hence correlated to those branches. They can be eliminated through code duplication and control flow graph restructuring techniques <ref> [1, 15] </ref>. We are aware of four existing algorithms for PDE. Knoop, Ruthing, and Steffen [13] present an optimal PDE algorithm based on sinking partially dead assignments closer to their uses. Their algorithm can eliminate all partial deadness that can be removed without changing the branching structure of the program. <p> If s is a conditional branch, then due to SSA form, the copy and the original branches are correlated along all paths and 5 the original branch can be removed using branch elimination algorithm <ref> [1, 15] </ref>. 2 Lemma 6. After PDE of an assignment d has been performed, each statement s executes no more frequently than in the original program, for any program input. Proof.
Reference: [2] <author> Preston Briggs and Keith D. Cooper. </author> <title> Effective partial redundancy elimination. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 159-170, </pages> <month> June </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Existing PDE techniques based upon code-motion reduce deadness by sinking partially dead statements to program points such that the number of paths along which the value computed by the statement is dead is reduced <ref> [2, 8, 13, 17] </ref>. Predication improves upon these existing algorithms because it is able to achieve PDE of code statements that are not sinkable. For acyclic graphs our approach generates code containing no partially dead code, which is a result that existing PDE algorithms cannot achieve. <p> Knoop, Ruthing, and Steffen [13] present an optimal PDE algorithm based on sinking partially dead assignments closer to their uses. Their algorithm can eliminate all partial deadness that can be removed without changing the branching structure of the program. Briggs and Cooper <ref> [2] </ref> develop an algorithm for removing partial redundancies. Their algorithm may remove some partially dead code as well but some execution paths may be impaired by sinking partially dead assignments into loops. <p> While not seen as the goal of these schedulers, a limited form of PDE is achieved as a by-product of the code motion applied during scheduling. On the other hand, the PDE optimization <ref> [13, 8, 2] </ref> is expected to be performed by an optimization phase that precedes instruction scheduling. However, separating optimization and scheduling may result in undesirable consequences.
Reference: [3] <author> Pohua P. Chang, Scott A. Mahlke, and Wen-Mei W. Hwu. </author> <title> Using profile information to assist classic code optimizations. </title> <journal> Software-Practice and Experience, </journal> <volume> 21(12) </volume> <pages> 1301-1321, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: In either case, a safe optimization does not seem possible. 4 Using PDE in Acyclic VLIW Scheduling Compilers for VLIW architectures use instruction schedulers that exploit instruction level parallelism for generating fast schedules of frequently executed portions of a program <ref> [3, 9, 16] </ref>. While not seen as the goal of these schedulers, a limited form of PDE is achieved as a by-product of the code motion applied during scheduling.
Reference: [4] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark K. Wegman, and F. Kenneth Zadeck. </author> <title> An efficient method of computing static single assignment form. </title> <booktitle> In 16th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 25-35, </pages> <year> 1989. </year>
Reference-contexts: Our algorithms operate upon a control flow graph G = (N; E; start; end) of the program in the static single assignment (SSA) form <ref> [4] </ref>. In this form, a) each program variable has a single definition and b) each use of a variable is reached by exactly one definition.
Reference: [5] <author> James C. Dehnert, Peter Y.-T. Hsu, and Joseph P. Bratt. </author> <title> Overlapped loop support in the Cydra 5. </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 26-38, </pages> <address> Boston, Mas-sachusetts, </address> <year> 1989. </year>
Reference-contexts: To allow inclusion of multiple frequently taken program paths in the scheduling region, the hyperblock scheduling region [6] contains both conditional branches and control flow merge points. The conditional branches are handled by sequential-izing the region using hardware predicated execution <ref> [5, 12] </ref> or by reverse if-conversion [18]. Consider the hyperblock R1 in Figure 11 (a). Let us assume that exit E3 is the most frequently taken exit while exits E1 and E2 are taken infrequently.
Reference: [6] <author> Scott A. Mahlke et al. </author> <title> Effective compiler support for predicated execution using the hyperblock. </title> <booktitle> In 25th Annual IEEE/ACM International Symposium on Microar-chitecture, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: Our approach can reduce deadness even if this sinking is not possible. PDE is an important optimization for VLIW architectures in which critical path lengths along frequently executed paths can be reduced through PDE [9, 10]. We show how our PDE optimization can improve effectiveness of hyperblock schedulers <ref> [6, 16] </ref> by moving operations that are dead on the dominant path off the scheduling region. Insertion of the predicate flow graph into the program control flow graph introduces into some paths additional assignments and conditional branches. <p> With more parallelism available in VLIW processors, recent research in code scheduling considers scheduling regions that are larger than the trace [9] or the superblock [7]. To allow inclusion of multiple frequently taken program paths in the scheduling region, the hyperblock scheduling region <ref> [6] </ref> contains both conditional branches and control flow merge points. The conditional branches are handled by sequential-izing the region using hardware predicated execution [5, 12] or by reverse if-conversion [18]. Consider the hyperblock R1 in Figure 11 (a). <p> The scheduler in [16] improves upon hyperblock scheduling <ref> [6] </ref> by adding techniques for critical path reduction (CPR) that enable reordering of region exit branches.
Reference: [7] <author> Wen-mei W. Hwu et al. </author> <title> The superblock: An effective technique for VLIW and superscalar compilation. </title> <journal> The Journal of Supercomputing, </journal> <volume> 7(1) </volume> <pages> 229-248, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: With more parallelism available in VLIW processors, recent research in code scheduling considers scheduling regions that are larger than the trace [9] or the superblock <ref> [7] </ref>. To allow inclusion of multiple frequently taken program paths in the scheduling region, the hyperblock scheduling region [6] contains both conditional branches and control flow merge points. The conditional branches are handled by sequential-izing the region using hardware predicated execution [5, 12] or by reverse if-conversion [18].
Reference: [8] <author> Lawrence Feigen, David Klappholz, Robert Cassazza, and Xing Xue. </author> <title> The revival transformation. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 421-434, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Existing PDE techniques based upon code-motion reduce deadness by sinking partially dead statements to program points such that the number of paths along which the value computed by the statement is dead is reduced <ref> [2, 8, 13, 17] </ref>. Predication improves upon these existing algorithms because it is able to achieve PDE of code statements that are not sinkable. For acyclic graphs our approach generates code containing no partially dead code, which is a result that existing PDE algorithms cannot achieve. <p> Briggs and Cooper [2] develop an algorithm for removing partial redundancies. Their algorithm may remove some partially dead code as well but some execution paths may be impaired by sinking partially dead assignments into loops. Feigen et al. <ref> [8] </ref> describe an algorithm that modifies program branching structure by moving a partially dead assignment to the point of the use together with the statements that guarantee preservation of the original program semantics. The algorithm has several serious restrictions. <p> In Figure 1 (a), the statement x:=y*z is partially dead since the value of x computed by the statement is never used if P2 is false. This deadness cannot be eliminated through code sinking techniques (the code-restructuring algorithm in <ref> [8] </ref> can handle this particular case). As shown in Figure 1 (b), by predicating the execution of x:=y*z with P2, PDE can be achieved. In order to ensure that the value of predicate P2 is available before the statement, we also hoist the statement P2:=b&lt;0. <p> While not seen as the goal of these schedulers, a limited form of PDE is achieved as a by-product of the code motion applied during scheduling. On the other hand, the PDE optimization <ref> [13, 8, 2] </ref> is expected to be performed by an optimization phase that precedes instruction scheduling. However, separating optimization and scheduling may result in undesirable consequences.
Reference: [9] <author> Joseph A. Fisher. </author> <title> Trace scheduling: A technique for global microcode compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 30(7), </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: Our approach can reduce deadness even if this sinking is not possible. PDE is an important optimization for VLIW architectures in which critical path lengths along frequently executed paths can be reduced through PDE <ref> [9, 10] </ref>. We show how our PDE optimization can improve effectiveness of hyperblock schedulers [6, 16] by moving operations that are dead on the dominant path off the scheduling region. <p> In either case, a safe optimization does not seem possible. 4 Using PDE in Acyclic VLIW Scheduling Compilers for VLIW architectures use instruction schedulers that exploit instruction level parallelism for generating fast schedules of frequently executed portions of a program <ref> [3, 9, 16] </ref>. While not seen as the goal of these schedulers, a limited form of PDE is achieved as a by-product of the code motion applied during scheduling. <p> With more parallelism available in VLIW processors, recent research in code scheduling considers scheduling regions that are larger than the trace <ref> [9] </ref> or the superblock [7]. To allow inclusion of multiple frequently taken program paths in the scheduling region, the hyperblock scheduling region [6] contains both conditional branches and control flow merge points.
Reference: [10] <author> Rajiv Gupta and Mary Lou Soffa. </author> <title> Region scheduling: An approach for detecting and redistributing parallelism. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 421-431, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Our approach can reduce deadness even if this sinking is not possible. PDE is an important optimization for VLIW architectures in which critical path lengths along frequently executed paths can be reduced through PDE <ref> [9, 10] </ref>. We show how our PDE optimization can improve effectiveness of hyperblock schedulers [6, 16] by moving operations that are dead on the dominant path off the scheduling region.
Reference: [11] <author> Susan Horwitz, Alan J. Demers, and Tim Teitelbaum. </author> <title> An efficient general iterative algorithm for dataflow analysis. </title> <journal> Acta Informatica, </journal> <volume> 24(6) </volume> <pages> 679-694, </pages> <year> 1987. </year>
Reference-contexts: The transitive approach identifies for each assignment a set of faint paths <ref> [11, 13] </ref>, which a superset of the dead paths. Dead paths are identified by the direct approach, and have been used in this paper so far.
Reference: [12] <author> Vinod Kathail, Michael S. Schlansker, and B. Ramakr-ishna Rau. </author> <title> HPL PlayDoh architecture specification: Version 1.0. </title> <type> Technical Report HPL-93-80, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: To allow inclusion of multiple frequently taken program paths in the scheduling region, the hyperblock scheduling region [6] contains both conditional branches and control flow merge points. The conditional branches are handled by sequential-izing the region using hardware predicated execution <ref> [5, 12] </ref> or by reverse if-conversion [18]. Consider the hyperblock R1 in Figure 11 (a). Let us assume that exit E3 is the most frequently taken exit while exits E1 and E2 are taken infrequently.
Reference: [13] <author> Jens Knoop, Oliver Ruthing, and Bernhard Steffen. </author> <title> Partial dead code elimination. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 147-158, </pages> <month> June </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Existing PDE techniques based upon code-motion reduce deadness by sinking partially dead statements to program points such that the number of paths along which the value computed by the statement is dead is reduced <ref> [2, 8, 13, 17] </ref>. Predication improves upon these existing algorithms because it is able to achieve PDE of code statements that are not sinkable. For acyclic graphs our approach generates code containing no partially dead code, which is a result that existing PDE algorithms cannot achieve. <p> The branches introduced during the predication of a statement are copies of later branches and hence correlated to those branches. They can be eliminated through code duplication and control flow graph restructuring techniques [1, 15]. We are aware of four existing algorithms for PDE. Knoop, Ruthing, and Steffen <ref> [13] </ref> present an optimal PDE algorithm based on sinking partially dead assignments closer to their uses. Their algorithm can eliminate all partial deadness that can be removed without changing the branching structure of the program. Briggs and Cooper [2] develop an algorithm for removing partial redundancies. <p> Consequently, the safety of Theorem 7 does not hold in cyclic code. Next, we present a modified PDE algorithm that guarantees safety in cyclic code and we show that the algorithm subsumes the sinking-based PDE algorithm <ref> [13] </ref>. Our cyclic-code PDE algorithm is based on the observation that PFG (d) represents only the minimal set of use region statements that must be hoisted to predicate d. <p> However, when a copy of the use region is created and only the main entry is connected, a single-entry region is formed through which d can be sunk to live frontiers. Actually, the PDE algorithm in <ref> [13] </ref> eliminates deadness of an assignment by sinking to live frontier edges (or further to the uses). Since this algorithm does not restructure the flow graph, PDE is permissible only on single-entry use regions. Our algorithm thus exploits all opportunities for PDE that the sinking algorithm in [13] does. <p> PDE algorithm in <ref> [13] </ref> eliminates deadness of an assignment by sinking to live frontier edges (or further to the uses). Since this algorithm does not restructure the flow graph, PDE is permissible only on single-entry use regions. Our algorithm thus exploits all opportunities for PDE that the sinking algorithm in [13] does. The cyclic code version of our PDE algorithm is simpler than the algorithm from Section 2 because it eliminates the need to compute the slice (PFG) and perform the subse 8 quent conditional branch elimination. <p> While the data dependence graph cannot be made acyclic, the live condition of the partially dead assignment can be derived transitively from program statements that are always live (called relevant in <ref> [13] </ref>), rather than directly from assignments that may remain partially dead after each application of PDE. The transitive approach identifies for each assignment a set of faint paths [11, 13], which a superset of the dead paths. <p> The transitive approach identifies for each assignment a set of faint paths <ref> [11, 13] </ref>, which a superset of the dead paths. Dead paths are identified by the direct approach, and have been used in this paper so far. <p> While not seen as the goal of these schedulers, a limited form of PDE is achieved as a by-product of the code motion applied during scheduling. On the other hand, the PDE optimization <ref> [13, 8, 2] </ref> is expected to be performed by an optimization phase that precedes instruction scheduling. However, separating optimization and scheduling may result in undesirable consequences. <p> After PDE, partially dead statements have been pushed off the hyperblock to the compensation code and the region has been restructured. Any critical path now contains only operations that are live on exit E3. Note that existing PDE algorithms <ref> [13] </ref> are based on code sinking and thus cannot eliminate B from the hyperblock. The CPR scheduler cannot remove A or B from the hyperblock because they are live on P 4, and E3 cannot be lifted across P 4.
Reference: [14] <author> Scott A. Mahlke, William Y. Chen, Wen-mei W. Hwu, B. Ramakrishna Rau, and Michael S. Schlansker. </author> <title> Sentinel scheduling for VLIW and superscalar processors. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 238-247, </pages> <address> Boston, Mas-sachusetts, </address> <year> 1992. </year>
Reference-contexts: The side exits are handled as described in [16]; they are scheduled as early as possible based on their priorities. Note that operations C and D are executed speculatively as suggested in <ref> [14] </ref> because they are issued before the side exit branches. Because of speculation, the execution conditions for C and D are very simple predicates that need not be computed by a long sequence of compare operations.
Reference: [15] <author> Frank Mueller and David B. Whalley. </author> <title> Avoiding conditional branches by code replication. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(6) </volume> <pages> 56-66, </pages> <month> June </month> <year> 1995. </year> <booktitle> Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The branches introduced during the predication of a statement are copies of later branches and hence correlated to those branches. They can be eliminated through code duplication and control flow graph restructuring techniques <ref> [1, 15] </ref>. We are aware of four existing algorithms for PDE. Knoop, Ruthing, and Steffen [13] present an optimal PDE algorithm based on sinking partially dead assignments closer to their uses. Their algorithm can eliminate all partial deadness that can be removed without changing the branching structure of the program. <p> If s is a conditional branch, then due to SSA form, the copy and the original branches are correlated along all paths and 5 the original branch can be removed using branch elimination algorithm <ref> [1, 15] </ref>. 2 Lemma 6. After PDE of an assignment d has been performed, each statement s executes no more frequently than in the original program, for any program input. Proof.
Reference: [16] <author> Michael S. Schlansker and Vinod Kathail. </author> <title> Critical path reduction for scalar programs. </title> <booktitle> In 28th Annual IEEE/ACM International Symposium on Microarchi-tecture, </booktitle> <address> Ann Arbor, Michigan, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Our approach can reduce deadness even if this sinking is not possible. PDE is an important optimization for VLIW architectures in which critical path lengths along frequently executed paths can be reduced through PDE [9, 10]. We show how our PDE optimization can improve effectiveness of hyperblock schedulers <ref> [6, 16] </ref> by moving operations that are dead on the dominant path off the scheduling region. Insertion of the predicate flow graph into the program control flow graph introduces into some paths additional assignments and conditional branches. <p> In either case, a safe optimization does not seem possible. 4 Using PDE in Acyclic VLIW Scheduling Compilers for VLIW architectures use instruction schedulers that exploit instruction level parallelism for generating fast schedules of frequently executed portions of a program <ref> [3, 9, 16] </ref>. While not seen as the goal of these schedulers, a limited form of PDE is achieved as a by-product of the code motion applied during scheduling. <p> In this situation, paths from Entry to E3 are 3 A critical edge leads from a node with multiple successors to a node with multiple predecessors. 10 considered critical paths and a VLIW scheduler attempts to generate short schedules for these paths. The scheduler in <ref> [16] </ref> improves upon hyperblock scheduling [6] by adding techniques for critical path reduction (CPR) that enable reordering of region exit branches. <p> A branch can move upwards across an operation only when the operation is dead on the exit from that branch. Finding a short schedule for the critical path is thus achieved through PDE optimization. The CPR scheduler <ref> [16] </ref> fails to move an exit branch a above another exit branch b if b does not dominate a. In Figure 11 (a), P 4 cannot be scheduled before P 2 and, more importantly, the branch corresponding to E3 cannot be scheduled before P 4 or P 2. <p> Note that all the conditional branches will disappear because the resulting schedule uses predicated execution, as shown in Figure 12. The side exits are handled as described in <ref> [16] </ref>; they are scheduled as early as possible based on their priorities. Note that operations C and D are executed speculatively as suggested in [14] because they are issued before the side exit branches.
Reference: [17] <author> Bernhard Steffen. </author> <title> Property oriented expansion. </title> <booktitle> In SAS/ALP/PLILP'96, </booktitle> <pages> pages 22-41, </pages> <address> Aachen (D), </address> <month> September </month> <year> 1996. </year> <title> Springer Verlag. </title> <booktitle> Proc. Int. Static Analysis Symposium (SAS'96). </booktitle>
Reference-contexts: Existing PDE techniques based upon code-motion reduce deadness by sinking partially dead statements to program points such that the number of paths along which the value computed by the statement is dead is reduced <ref> [2, 8, 13, 17] </ref>. Predication improves upon these existing algorithms because it is able to achieve PDE of code statements that are not sinkable. For acyclic graphs our approach generates code containing no partially dead code, which is a result that existing PDE algorithms cannot achieve. <p> While they wrap the partially dead assignment into its exe cution condition and move it to the point of the use, we leave the assignment in place but embed it into the execution condition that characterizes the paths along which the assignment is live. Finally, Steffen <ref> [17] </ref> describes a PDE algorithm based on code restructuring that is capable of eliminating all partially dead statements, at the cost of introducing non-determinism into the program. Nondeterministic branches are introduced even when acyclic programs are optimized. <p> First, the algorithm attempts to rename the source variable of each -assignment to the destination variable of the assignment, if such renaming is possible. Remaining -assignments are removed by an algorithm derived from the optimization framework in <ref> [17] </ref>. 2 The algorithm is based on path duplication and works as follows. Consider a -assignment a and a set of nodes that use the variable assigned in a. The algorithm creates a separate path for each source variable of the -assignment. <p> Embedding a partially dead assignment may cause partial deadness in statements that compute values used by the assignment. Therefore, our algorithm repeats PDE for all partially dead statements in a reverse topological sort order traversal of the data dependence 2 While the PDE algorithm in <ref> [17] </ref> produces nondeterministic programs, the -assignment elimination algorithm does not. graph. To eliminate deadness of each assignment in the program, each assignment d (and each of its copies) needs to be optimized at most once. <p> However, the assignment to P2 that was hoisted with the predicate flow graph into the loop had to be moved before the loop using loop-invariant code motion. We are not aware of an optimization algorithm that can remove the faintness in Figure 10. Steffen conjectures in <ref> [17] </ref> that by code restructuring and branch reordering, all dead code can be eliminated. We have proved in this paper his hypothesis for the case of acyclic code.
Reference: [18] <author> Nancy J. Warter, Scott A. Mahlke, Wen mei W. Hwu, and B. Ramakrishna Rau. </author> <title> Reverse if-conversion. </title> <journal> SIG-PLAN Notices, </journal> <volume> 28(6) </volume> <pages> 290-299, </pages> <month> June </month> <year> 1993. </year> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: To allow inclusion of multiple frequently taken program paths in the scheduling region, the hyperblock scheduling region [6] contains both conditional branches and control flow merge points. The conditional branches are handled by sequential-izing the region using hardware predicated execution [5, 12] or by reverse if-conversion <ref> [18] </ref>. Consider the hyperblock R1 in Figure 11 (a). Let us assume that exit E3 is the most frequently taken exit while exits E1 and E2 are taken infrequently.
Reference: [19] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> August </month> <year> 1984. </year> <month> 12 </month>
Reference-contexts: The embedding ensures that the assignment is triggered only when the control is going to follow a live path. The PFG is computed through slicing <ref> [19] </ref> of the use region. The backward slice of a program with respect to an edge is the set of statements that determine whether the edge is executed. Definition 2. Let d be an assignment node and U (d) its use region.
References-found: 19

