URL: http://www.cs.toronto.edu/~david/papers-pods96.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: david@cs.toronto.edu  
Title: Point vs. Interval-based Query Languages for Temporal Databases (Extended Abstract)  
Author: David Toman 
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: Department of Computer Science, University of Toronto  
Abstract: In this paper we establish a correspondence between two major views of temporal databases and the corresponding first-order temporal query languages: the point-based view of temporal databases vs. the interval-based view of temporal databases. We show that all first-order queries can be conveniently asked using a point-based first-order query languages in a much more declarative and natural way and then mechanically translated into an interval-based query language, e.g., TSQL2. Such an approach combines the ease of formulating queries in first-order logic (temporal relational calculus) with the efficient query evaluation algorithms developed for the interval-based temporal databases. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul, S., Hull, R., Viannu, V. </author> <title> Foundations of Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Such a translation can be immediately used as an algorithm that allows high-level point-based queries to be compiled into an interval-based query language, e.g., TQUEL or TSQL2 1 . Note that this translation addresses completely different issues than the first-order logic to SQL translations 2 (e.g., <ref> [1, 15] </ref>). Note also that our goal is different than the goal pursued in the area of constraint databases [7]. Our transformation allows us to translate the point-based queries to the existing interval-based query languages. <p> We assume the usual Tarskian semantics for formulas in both of the temporal query languages <ref> [1] </ref> (where j= denotes the satisfaction relation for first-order logic). The usual interval-based query languages (e.g., TQUEL or TSQL2) can be defined in terms of the language L I introduced in Definition 2.8 5 . <p> Before we isolate the class of range-restricted formulas of L P we need to define a subclass of the abstract temporal databases that can be finitely represented by concrete temporal databases: 6 For discussion of topics related to evaluability, safety, and domain independence see, e.g., <ref> [1, 14, 15] </ref>. 6 Definition 4.2 An abstract temporal database is fini--tary if it is an image of a finite concrete temporal database under k:k. <p> The current version of the proposed transformation F depends on the restriction of queries to a single-dimensional model of time. However, the only problem with adopting a multi-dimensional models of time (or 8 This is similar to the problem in the first-order logic to relational algebra translations, e.g., <ref> [1, 15] </ref>, where the conjunctions need to be distributed into disjunctions (in the worst case) to guarantee evaluability of the resulting query. 9 For the purpose of our translation, the enforcement of maximal intervals is not essential, except for performance reasons. 8 space) is the closure with respect to the target
Reference: [2] <author> Allen, J. F. </author> <title> Maintaining Knowledge about Temporal Intervals. </title> <journal> Comm. ACM, </journal> <volume> 16(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: No aggregation or other non first-order features. Remark 2.9 (Interval-based Language L Allen ) (interval-based language based on the Allen's Algebra Operators <ref> [2] </ref>). Let be a database schema. L ::= R i (I; x) j L ^ L j :L j 9x:L j 9I:L j x 1 = x 2 j I 1 I 2 where 2 fprecedes; meets; overlaps; equals; containsg. <p> Clearly, all the queries in this language are definable in L I (follows immediately from the definition of Allen's Algebra operators <ref> [2] </ref>). The opposite direction follows from the observation that, e.g.: I J () (I contains J ) _ (I overlaps J)_ (I meets J ) _ (I precedes J ) (and similarly for all the remaining cases).
Reference: [3] <author> Bohlen, M. H., Chomicki, J., Snodgrass, R. T., Toman, D. </author> <title> Querying TSQL2 Databases with Temporal Logic. </title> <note> To appear in Proc. EDBT'96. </note>
Reference-contexts: This approach provides a clean and declarative semantics of queries. The associated query languages are usually based on first-order logic (relational calculus [14]) or some of its sublogics (e.g., temporal logic <ref> [3] </ref>). A natural assumption in these languages is that the temporal variables in the queries refer to individual time instants. <p> The conclusion follows from the observation that a flat temporal database exists in all the k:k-equivalence classes by Lemma 5.2. 6 Conclusion and Future Work We have established a correspondence between the point-based and the interval-based views of temporal databases and studied properties of this correspondence. In <ref> [3] </ref> a transformation mapping first-order temporal logic formulas to TSQL2 was proposed. The goal of that paper is similar to our goal. However, the presented transformation can not cope with the full first-order logic over temporal databases as it depends on the single-dimensional nature of temporal logic 7 [13].
Reference: [4] <author> Chandra, A. K., Harrel, D. </author> <title> Computable Queries for Relational Data Bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21 </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Then we say that ' is generic with respect to k:k if kD 1 k = kD 2 k k'D 1 k = k'D 2 k 7 This notion is similar to the genericity notion for standard relational queries <ref> [4] </ref>; the definition allows only queries that are representation-independent.
Reference: [5] <author> Chomicki J. </author> <title> Temporal Query Languages: a Survey. </title> <booktitle> Proc. International Conference on Temporal Logic, </booktitle> <address> July 1994, Bonn, Germany, </address> <publisher> Springer-Verlag (LNAI 827), </publisher> <pages> pp. 506-534. </pages>
Reference-contexts: 1 Introduction In this paper we try to fill the gap between two main directions of research in the area of temporal databases and temporal query languages: The first direction studies the temporal databases as two-sorted first-order structures and temporal query languages as suitable languages of logic over such structures <ref> [5] </ref>. This approach provides a clean and declarative semantics of queries. The associated query languages are usually based on first-order logic (relational calculus [14]) or some of its sublogics (e.g., temporal logic [3]). <p> Note also that our goal is different than the goal pursued in the area of constraint databases [7]. Our transformation allows us to translate the point-based queries to the existing interval-based query languages. This approach can serve as a convenient front-end to the existing temporal database management systems <ref> [5, 10] </ref>. <p> few point-based temporal queries and their translations in Appendix A. 2 Temporal Databases and Query Languages This section gives precise definitions of temporal databases and the corresponding first-order query languages. 2.1 Temporal Databases We define two classes of two-sorted first-order structures extended with user-defined relations (following the terminology introduced in <ref> [5] </ref>): 1. the class of Abstract temporal databases (point-based), elements of which serve as the actual representation-independent meanings of the tempo ral databases, and 2. the class of Concrete temporal databases (interval-based) that contains the space-efficient encodings of the abstract temporal databases.
Reference: [6] <author> Chomicki, J., Goldin, D. Q., Kuper, G. </author> <title> Variable Independence and Aggregation Closure. </title> <booktitle> To appear in Proc. ACM Symposium on Principles of Database Systems,, </booktitle> <year> 1996. </year>
Reference-contexts: to this problem: 1. we can enrich the two-dimensional temporal domain with additional elements and constructs (built-in relations) that allow us to capture the semantics of such formulas or 2. we can restrict the two-dimensional queries to those, where such dependency between the two dimensions does not exist (similarly to <ref> [6] </ref>). The extension to dimension higher than two is then straightforward.
Reference: [7] <author> Kanellakis, P. C., Kuper, G. M., Revesz, P. Z. </author> <title> Constraint Query Languages, </title> <booktitle> Proc. 9th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 299-313, </pages> <year> 1990. </year>
Reference-contexts: However, the relational structures that capture the temporal information are usually infinite (as the domain of time instants is infinite in this model) and thus not immediately suitable as practical temporal databases. Finite encodings of such structures are needed, e.g., <ref> [7] </ref>, to make this approach practically usable. The second approach is connected with the more practical side of research in the area of temporal databases. Here special care is given to the development of space-efficient storage techniques of large and often infinite sets of time instants [12]. <p> Note that this translation addresses completely different issues than the first-order logic to SQL translations 2 (e.g., [1, 15]). Note also that our goal is different than the goal pursued in the area of constraint databases <ref> [7] </ref>. Our transformation allows us to translate the point-based queries to the existing interval-based query languages. This approach can serve as a convenient front-end to the existing temporal database management systems [5, 10].
Reference: [8] <author> Ladkin, P. </author> <title> Satisfying FO Constraints About Time Intervals. </title> <booktitle> Proc. </booktitle> <pages> AAAI'88 , pp. 512-517, </pages> <year> 1988. </year>
Reference-contexts: Clearly (1) could be easily met by using unit intervals in the place of point variables through the original query, e.g., t 7! I t and 8t:' 7! 8I:(I = I + ) '[t=I] <ref> [8] </ref>. However, this solution (also clearly) violates the second requirement.
Reference: [9] <author> Snodgrass R. T. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Here special care is given to the development of space-efficient storage techniques of large and often infinite sets of time instants [12]. A classical solution of this problem uses encoding of such sets of time instants using intervals <ref> [9, 11] </ref>. However, a side-effect of such a solution is that the query languages over the interval-based temporal databases are based on the syntax of the actual encoding of sets of time instants, rather than on the underlying meaning of the encoding. <p> The approach is based on a translation of the point-based queries to interval-based queries. Such a translation allows us to use the existing interval-based temporal database systems (based on TQUEL <ref> [9] </ref> or TSQL [11]) as a back-end over which 1 the declarative point-based queries can be asked.
Reference: [10] <author> Snodgrass R. T. </author> <title> Temporal Databases: status and research directions. </title> <booktitle> ACM SIGMOD Record , 19(4) </booktitle> <pages> 83-89, </pages> <year> 1990. </year>
Reference-contexts: Note also that our goal is different than the goal pursued in the area of constraint databases [7]. Our transformation allows us to translate the point-based queries to the existing interval-based query languages. This approach can serve as a convenient front-end to the existing temporal database management systems <ref> [5, 10] </ref>. <p> Lin ) assuming the standard rules for +1 and 1 over Z [ f1; 1g and I " I 0 = ; is a shorthand for V '(t; s; a) :'(t; s; a) Let a 2 jDj such that the formula '(t; s; a) holds for all (t; s) 2 <ref> [10; 20] </ref> fi [20; 40] [ [30; 40] fi [10; 30]. <p> 1 over Z [ f1; 1g and I " I 0 = ; is a shorthand for V '(t; s; a) :'(t; s; a) Let a 2 jDj such that the formula '(t; s; a) holds for all (t; s) 2 [10; 20] fi [20; 40] [ [30; 40] fi <ref> [10; 30] </ref>.
Reference: [11] <author> Snodgrass R.T. </author> <title> (editor). The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> 674+xxiv pages, </address> <year> 1995. </year>
Reference-contexts: Here special care is given to the development of space-efficient storage techniques of large and often infinite sets of time instants [12]. A classical solution of this problem uses encoding of such sets of time instants using intervals <ref> [9, 11] </ref>. However, a side-effect of such a solution is that the query languages over the interval-based temporal databases are based on the syntax of the actual encoding of sets of time instants, rather than on the underlying meaning of the encoding. <p> The approach is based on a translation of the point-based queries to interval-based queries. Such a translation allows us to use the existing interval-based temporal database systems (based on TQUEL [9] or TSQL <ref> [11] </ref>) as a back-end over which 1 the declarative point-based queries can be asked.
Reference: [12] <editor> Tansel, A. et al. (editors). </editor> <title> Temporal Databases: Theory, Design, and Implementation, </title> <publisher> Benjamin Cummings 1993. </publisher>
Reference-contexts: The second approach is connected with the more practical side of research in the area of temporal databases. Here special care is given to the development of space-efficient storage techniques of large and often infinite sets of time instants <ref> [12] </ref>. A classical solution of this problem uses encoding of such sets of time instants using intervals [9, 11]. <p> This fact leads to several problems: * The query languages are complicated as they explicitly refer to the particular encoding of sets of time instants, rather than to the individual time instants themselves (cf. Appendix A). Giving a clear semantics to such temporal query languages is quite difficult <ref> [12] </ref>: the intervals serve merely as a tool that allows finite encoding of infinite point-based temporal databases, while the actual semantics of queries is defined with respect to the point-based temporal databases themselves. * The formulation of queries in the interval-based query language is not natural: the declarative nature of asking <p> quantifier elimination is a part of the translation process where the actual values are not known. * Is complementation in T h () first-order definable (as in Lemma 3.5) in the first-order query language over the concrete temporal databases? Note that a general solution may require a limited second-order quantification <ref> [12] </ref>. Optimization. The formulas produced by the transformation F can be exponential in the size of the input formula. This blowup comes from two sources: 1. The use of Lemma 3.5 on the negated subformulas of the original query.
Reference: [13] <author> Toman, D., Niwinski, D. </author> <title> First-Order Temporal Queries Inexpressible in Temporal Logic. </title> <note> To appear in Proc. EDBT'96. </note>
Reference-contexts: Note that while the relation symbols in the database schema always contain exactly one temporal variable. This is no longer true for arbitrary queries (cf. Appendix A, query 4). This situation can not be avoided in general <ref> [13] </ref>. Theorem 3.6 Let ' 2 L P . Then there exists an equivalent formula in normal form. P r o o f: Essentially we are trying to show that 'kDk = kF (')(D)k for all D 2 D I and ' 2 L P . <p> In [3] a transformation mapping first-order temporal logic formulas to TSQL2 was proposed. The goal of that paper is similar to our goal. However, the presented transformation can not cope with the full first-order logic over temporal databases as it depends on the single-dimensional nature of temporal logic 7 <ref> [13] </ref>. On the other hand, it can use this property of temporal logic to make the transformation simpler. Future research includes the following topics: Other classes of concrete temporal domains.
Reference: [14] <author> Ullman J. D. </author> <title> Principles of Database and Knowledge-base Systems, Vol. </title> <type> 1, 2. </type> <institution> Computer Science Systems, </institution> <year> 1989. </year>
Reference-contexts: This approach provides a clean and declarative semantics of queries. The associated query languages are usually based on first-order logic (relational calculus <ref> [14] </ref>) or some of its sublogics (e.g., temporal logic [3]). A natural assumption in these languages is that the temporal variables in the queries refer to individual time instants. <p> Before we isolate the class of range-restricted formulas of L P we need to define a subclass of the abstract temporal databases that can be finitely represented by concrete temporal databases: 6 For discussion of topics related to evaluability, safety, and domain independence see, e.g., <ref> [1, 14, 15] </ref>. 6 Definition 4.2 An abstract temporal database is fini--tary if it is an image of a finite concrete temporal database under k:k.
Reference: [15] <author> Van Gelder A., Topor R. W. </author> <title> Safety and Translation of Relational Calculus Queries. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 16(2) </volume> <pages> 235-278, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Such a translation can be immediately used as an algorithm that allows high-level point-based queries to be compiled into an interval-based query language, e.g., TQUEL or TSQL2 1 . Note that this translation addresses completely different issues than the first-order logic to SQL translations 2 (e.g., <ref> [1, 15] </ref>). Note also that our goal is different than the goal pursued in the area of constraint databases [7]. Our transformation allows us to translate the point-based queries to the existing interval-based query languages. <p> Before we isolate the class of range-restricted formulas of L P we need to define a subclass of the abstract temporal databases that can be finitely represented by concrete temporal databases: 6 For discussion of topics related to evaluability, safety, and domain independence see, e.g., <ref> [1, 14, 15] </ref>. 6 Definition 4.2 An abstract temporal database is fini--tary if it is an image of a finite concrete temporal database under k:k. <p> The current version of the proposed transformation F depends on the restriction of queries to a single-dimensional model of time. However, the only problem with adopting a multi-dimensional models of time (or 8 This is similar to the problem in the first-order logic to relational algebra translations, e.g., <ref> [1, 15] </ref>, where the conjunctions need to be distributed into disjunctions (in the worst case) to guarantee evaluability of the resulting query. 9 For the purpose of our translation, the enforcement of maximal intervals is not essential, except for performance reasons. 8 space) is the closure with respect to the target
References-found: 15

