URL: ftp://ftp.cs.wisc.edu/tech-reports/reports/92/tr1107.ps.Z
Refering-URL: http://www.cs.wisc.edu/~arch/uwarch/tech_reports/tech_reports.html
Root-URL: 
Title: Sufficient Conditions for Implementing the Data-Race-Free-1 Memory Model  
Author: Sarita V. Adve Mark D. Hill 
Note: This note does not stand alone. It should only be read as a supplement to the main paper [AdH92]. That paper and this note subsume the original technical report [AdH91].  
Address: Madison, Wisconsin 53706  
Date: #1107, September 1992  
Affiliation: Computer Sciences  Computer Sciences Department University of Wisconsin  
Pubnum: Technical Report  
Abstract: The paper, A Unified Formalization of Four Shared-Memory Models [AdH92], defines the data-race-free-1 memory model and informally discusses sufficient conditions for implementing the data-race-free-1 memory model. This note formalizes and gives correctness proofs for the sufficient conditions. 
Abstract-found: 1
Intro-found: 1
Reference: [AdH90] <author> S. V. ADVE and M. D. HILL, </author> <title> Weak Ordering ANew Definition, </title> <booktitle> Proc. 17th Annual Intl. Symp. on Computer Architecture, </booktitle> <month> May </month> <year> 1990, </year> <pages> 2-14. </pages>
Reference-contexts: The second condition places greater restrictions on the hardware allowed; however, it is easier to translate into implementations including ones that do not obey weak ordering [DSB86], release consistency (with sequentially consistent special operations) [GLL90], and data-race-free-0 <ref> [AdH90] </ref> (e.g., the implementation proposal in the companion paper [AdH92]). The rest of this note uses the following terminology. <p> The formalization of the data requirement considers the happens-before-1 relation [AdH92] since on a sequentially consistent machine, happens-before-1 orders all pairs of conflicting operations such that at least one is a data operation. The following formalization of the synchronization requirement considers the happens-before-0 relation (called happens-before in earlier work <ref> [AdH90] </ref>), which orders all pairs of conflicting synchronization operations. Happens-before-0 (denoted hb0 ) is the irreflexive, transitive closure of program order and synchronization-order-0 (denoted so0 ), where X so0 Y if X and Y are conflicting synchronization operations and X (i) Y (i) for some i.
Reference: [AdH91] <author> S. V. ADVE and M. D. HILL, </author> <title> A Unified Formalization of Four Shared-Memory Models, </title> <type> Computer Sciences Technical Report #1051, </type> <institution> University of Wisconsin, Madison, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Bell Laboratories, Cray Research Foundation, and Digital Equipment Corporation. Sarita Adve is also supported by an IBM graduate fellowship. * An earlier version of the formalism, conditions, and proof of this note appeared in the first version of the technical report, A Unified Formalization of Four Shared-Memory Models <ref> [AdH91] </ref>. That technical report has since been updated to the version of the paper that will be published [AdH92]. The altered conditions and proof in this note reflect the changes advised by the referees of the above paper. 1992 Sarita V. Adve and Mark D.
Reference: [AdH92] <author> S. V. ADVE and M. D. HILL, </author> <title> A Unified Formalization of Four Shared-Memory Models, </title> <note> To appear in the IEEE Transactions on Parallel and Distributed Systems, Accepted August 1992. Also available as Computer Sciences Technical Report #1051, </note> <institution> University of Wisconsin, Madison, </institution> <month> September </month> <year> 1991, </year> <note> Revised September 1992. </note>
Reference-contexts: 1. Introduction This note is a companion to a paper that defines the data-race-free-1 memory model <ref> [AdH92] </ref>. This note does not stand alone because it assumes the reader is familiar with the companion paper. This note formalizes and gives correctness proofs for sufficient conditions, discussed informally in the com panion paper, for implementing the data-race-free-1 memory model. <p> That technical report has since been updated to the version of the paper that will be published <ref> [AdH92] </ref>. The altered conditions and proof in this note reflect the changes advised by the referees of the above paper. 1992 Sarita V. Adve and Mark D. <p> This is in contrast to many earlier specifications [DSB86, GLL90, ScD87] which impose constraints on the real time ordering of events. 3. Sufficient Conditions for Implementing Data-Race-Free-1 The definition of data-race-free-1 <ref> [AdH92] </ref> gives the necessary and sufficient condition for implementing data-race-free-1; i.e., hardware is data-race-free-1 if it appears sequentially consistent to data-race-free programs. However, it is difficult to translate this condition directly into an implementation or to check if an implementation obeys this condition. <p> The second condition places greater restrictions on the hardware allowed; however, it is easier to translate into implementations including ones that do not obey weak ordering [DSB86], release consistency (with sequentially consistent special operations) [GLL90], and data-race-free-0 [AdH90] (e.g., the implementation proposal in the companion paper <ref> [AdH92] </ref>). The rest of this note uses the following terminology. The following abbreviations denote the various rela tions introduced in the companion paper [AdH92] and this note: po denotes program order, so1 denotes synchronization-order-1, hb1 denotes happens-before-1, and xo denotes execution order. <p> ones that do not obey weak ordering [DSB86], release consistency (with sequentially consistent special operations) [GLL90], and data-race-free-0 [AdH90] (e.g., the implementation proposal in the companion paper <ref> [AdH92] </ref>). The rest of this note uses the following terminology. The following abbreviations denote the various rela tions introduced in the companion paper [AdH92] and this note: po denotes program order, so1 denotes synchronization-order-1, hb1 denotes happens-before-1, and xo denotes execution order. <p> First Sufficient Condition for Implementing the Data-Race-Free-1 Memory Model The first sufficient condition for implementing the data-race-free-1 memory model consists of the data, synchronization, and control requirements, informally discussed in the companion paper <ref> [AdH92] </ref>. The formalization of the data and control requirements results directly from the discussion in the companion paper [AdH92]. The following discussion motivates the formalization of the synchronization requirement. <p> Sufficient Condition for Implementing the Data-Race-Free-1 Memory Model The first sufficient condition for implementing the data-race-free-1 memory model consists of the data, synchronization, and control requirements, informally discussed in the companion paper <ref> [AdH92] </ref>. The formalization of the data and control requirements results directly from the discussion in the companion paper [AdH92]. The following discussion motivates the formalization of the synchronization requirement. Informally, the synchronization requirement states that for a data-race-free program, conflicting synchronization operations should be seen by a processor in the same order as on a sequentially consistent machine. <p> The formalization of the data requirement considers the happens-before-1 relation <ref> [AdH92] </ref> since on a sequentially consistent machine, happens-before-1 orders all pairs of conflicting operations such that at least one is a data operation. The following formalization of the synchronization requirement considers the happens-before-0 relation (called happens-before in earlier work [AdH90]), which orders all pairs of conflicting synchronization operations. <p> and (iii) for two conflicting synchronization operations X and Y, if X hb0 Y in E sc , then X hb0 The proof of correctness of condition 2.1 follows from the discussion in the companion paper, which shows that the data, synchronization, and control requirements together obey the data-race-free conditions <ref> [AdH92] </ref>. 3 Specifically, the control requirement ensures that for an execution, E drf , of a data-race-free program, Prog, on hardware that obeys condition 2.1, the operations, the hb1 relation, and the hb0 relation are the same as those for a sequentially consistent execution, E sc , of Prog and its <p> We know that the well-formed xo of E sc orders all conflicting sub-operations in a given memory copy in the same way as the corresponding hb0 hb1 orders the corresponding operations. The data and synchronization requirements ensure that there hhhhhhhhhhhhhhhhhh 1. The data requirement in the companion paper <ref> [AdH92] </ref> mentions that all processors should see X before Y (if X and Y satisfy the pre-conditions of the data requirement in condition 2.1 of this note). <p> For most cases, the informal event of a processor P i seeing an operation is equivalent to the more formal event of the sub-operation of the operation executing in P i 's memory copy. However, the paper <ref> [AdH92] </ref> allows processor P i to also see a read operation by another processor P j (when the read returns its value). This is an extra event for which there is no equivalent sub-operation in the memory copy of P j . Due to this extra event, the paper [AdH92] effectively <p> paper <ref> [AdH92] </ref> allows processor P i to also see a read operation by another processor P j (when the read returns its value). This is an extra event for which there is no equivalent sub-operation in the memory copy of P j . Due to this extra event, the paper [AdH92] effectively imposes an unnecessary ordering constraint between the read sub operation in P i and other conflicting write sub-operations in the memory copy of P j . The formalism of this note does not define the extra event and eliminates this unnecessary constraint. 2. <p> In the data-race-free conditions <ref> [AdH92] </ref>, the informal notion that ``a processor should see two conflicting operations in the same order as a sequentially consistent execution'' can now be interpreted as ``the execution order should order conflicting sub-operations in a given memory copy in the same order as an execution order of a sequentially consistent execution.'' <p> Condition 2.2 obeys condition 2.1 and is also made of three sub-conditions respectively corresponding to the data, synchronization and control requirements of condition 2.1. The condition for the data requirement is similar to, but slightly less restrictive than the data requirement conditions in the companion paper <ref> [AdH92] </ref>. Further, it consists of only the actual ordering constraints between sub-operations and also includes the case for two conflicting operations from the same processor. The condition for the synchronization requirement is based on a sufficient condition for sequential consistency proposed by Dubois et al. [ScD87]. <p> A more aggressive implementation of the data requirement appears in the companion paper <ref> [AdH92] </ref>. For the synchronization requirement, part (a) is satisfied if a processor does not issue a synchronization operation until its previous (by po ) synchronization operation completes (i.e., all sub-operations are executed). <p> Thus, the new execution order has a longer prefix than the original E sc , a contradiction. This completes all the cases for sub-step III and completes the entire proof. ` Acknowledgements We thank the anonymous referees of the companion paper <ref> [AdH92] </ref>, Kourosh Gharachorloo, and Richard Zucker for helpful comments on previous versions of this work.
Reference: [ASH88] <author> A. AGARWAL, R. SIMONI, M. HOROWITZ and J. HENNESSY, </author> <title> An Evaluation of Directory Schemes for Cache Coherence, </title> <booktitle> Proc. 15th Annual Intl. Symp. on Computer Architecture, </booktitle> <address> Honolulu, Hawaii, </address> <month> June </month> <year> 1988, </year> <pages> 280-289. </pages>
Reference-contexts: Part (c) is satisfied by implementing a cache coherence protocol <ref> [ASH88] </ref>. For the control requirement, parts (c) and (d) are already satisfied by the data and synchronization requirements respectively.
Reference: [Col92] <author> W. W. COLLIER, </author> <title> Reasoning about Parallel Architectures, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1992. </year>
Reference-contexts: This note formalizes and gives correctness proofs for sufficient conditions, discussed informally in the com panion paper, for implementing the data-race-free-1 memory model. Section 2 develops a formalism to describe shared-memory hardware based on work by Collier <ref> [Col92] </ref>. Section 3 uses this formalism to develop and prove the correctness of the sufficient conditions. 2. A Formalism for Describing Shared-Memory Hardware To formalize conditions for implementing memory models, a formalism to describe non-atomic shared memory operations and interactions between such operations is necessary. <p> A Formalism for Describing Shared-Memory Hardware To formalize conditions for implementing memory models, a formalism to describe non-atomic shared memory operations and interactions between such operations is necessary. We use a formalism based on an abstraction of shared-memory systems developed by Collier <ref> [Col92] </ref> as follows. hhhhhhhhhhhhhhhhhh This work was supported in part by a National Science Foundation Presidential Young Investigator Award (MIPS-8957278) with matching funds from A.T. & T. Bell Laboratories, Cray Research Foundation, and Digital Equipment Corporation.
Reference: [DSB86] <author> M. DUBOIS, C. SCHEURICH and F. A. BRIGGS, </author> <title> Memory Access Buffering in Multiprocessors, </title> <booktitle> Proc. 13th Annual Intl. Symp. on Computer Architecture 14, </booktitle> <month> 2 (June </month> <year> 1986), </year> <pages> 434-442. </pages>
Reference-contexts: However, one can identify a single instant of time at which the update takes effect such that other sub-operations take effect either before or after this time. The notion of sub-operations is similar to that of memory operations performing with respect to a processor defined by Dubois et al. <ref> [DSB86] </ref>. A write sub-operation, W (i), corresponds to the write W performing with respect to processor P i . A read sub-operation, R (i), corresponds to the read R performing with respect to all processors. We find Collier's representation conceptually and notationally simpler. <p> This is in contrast to many earlier specifications <ref> [DSB86, GLL90, ScD87] </ref> which impose constraints on the real time ordering of events. 3. Sufficient Conditions for Implementing Data-Race-Free-1 The definition of data-race-free-1 [AdH92] gives the necessary and sufficient condition for implementing data-race-free-1; i.e., hardware is data-race-free-1 if it appears sequentially consistent to data-race-free programs. <p> The second condition places greater restrictions on the hardware allowed; however, it is easier to translate into implementations including ones that do not obey weak ordering <ref> [DSB86] </ref>, release consistency (with sequentially consistent special operations) [GLL90], and data-race-free-0 [AdH90] (e.g., the implementation proposal in the companion paper [AdH92]). The rest of this note uses the following terminology. <p> They are duplicated in the control requirement for completeness since the data and synchronization requirements could potentially be satisfied in other ways. - 7 - - -- For the data requirement, all implementations of the models of weak ordering <ref> [DSB86] </ref> and release consistency (with sequentially consistent synchronization operations) [GLL90] can be easily seen to satisfy the requirement (with an appropriate interpretation of the constraint of sequentially consistent synchronization operations imposed by these models). A more aggressive implementation of the data requirement appears in the companion paper [AdH92].
Reference: [FrS92] <author> M. FRANKLIN and G. S. SOHI, </author> <title> The Expandable Split Window Paradigm for Exploiting Fine-Grain Parallelism, </title> <booktitle> Proc. 19th Annual Intl. Symp. on Computer Architecture, </booktitle> <month> May </month> <year> 1992, </year> <pages> 58-67. </pages>
Reference-contexts: An example that gives incorrect results if only the data and synchronization requirements hold follows. With recent proposals for superscalar processors <ref> [FrS92] </ref>, this example could be practically possible. <p> Thus, there cannot be a data race, the program is data-race-free, and a data-race-free-1 implementation should appear sequentially consistent to the program. In the absence of the control requirement, an aggressive implementation <ref> [FrS92] </ref> could allow P 0 to write flag2 before its read of x returned a value.
Reference: [GLL90] <author> K. GHARACHORLOO, D. LENOSKI, J. LAUDON, P. GIBBONS, A. GUPTA and J. HENNESSY, </author> <title> Memory Consistency and Event Ordering in Scalable Shared-Memory Multiprocessors, </title> <booktitle> Proc. 17th Annual Intl. Symp. on Computer Architecture, </booktitle> <month> May </month> <year> 1990, </year> <pages> 15-26. </pages>
Reference-contexts: This is in contrast to many earlier specifications <ref> [DSB86, GLL90, ScD87] </ref> which impose constraints on the real time ordering of events. 3. Sufficient Conditions for Implementing Data-Race-Free-1 The definition of data-race-free-1 [AdH92] gives the necessary and sufficient condition for implementing data-race-free-1; i.e., hardware is data-race-free-1 if it appears sequentially consistent to data-race-free programs. <p> The second condition places greater restrictions on the hardware allowed; however, it is easier to translate into implementations including ones that do not obey weak ordering [DSB86], release consistency (with sequentially consistent special operations) <ref> [GLL90] </ref>, and data-race-free-0 [AdH90] (e.g., the implementation proposal in the companion paper [AdH92]). The rest of this note uses the following terminology. <p> They are duplicated in the control requirement for completeness since the data and synchronization requirements could potentially be satisfied in other ways. - 7 - - -- For the data requirement, all implementations of the models of weak ordering [DSB86] and release consistency (with sequentially consistent synchronization operations) <ref> [GLL90] </ref> can be easily seen to satisfy the requirement (with an appropriate interpretation of the constraint of sequentially consistent synchronization operations imposed by these models). A more aggressive implementation of the data requirement appears in the companion paper [AdH92].
Reference: [ScD87] <author> C. SCHEURICH and M. DUBOIS, </author> <title> Correct Memory Operation of Cache-Based Multiprocessors, </title> <booktitle> Proc. Fourteenth Annual Intl. Symp. on Computer Architecture, </booktitle> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1987, </year> <pages> 234-243. - 23 </pages> - 
Reference-contexts: This is in contrast to many earlier specifications <ref> [DSB86, GLL90, ScD87] </ref> which impose constraints on the real time ordering of events. 3. Sufficient Conditions for Implementing Data-Race-Free-1 The definition of data-race-free-1 [AdH92] gives the necessary and sufficient condition for implementing data-race-free-1; i.e., hardware is data-race-free-1 if it appears sequentially consistent to data-race-free programs. <p> Further, it consists of only the actual ordering constraints between sub-operations and also includes the case for two conflicting operations from the same processor. The condition for the synchronization requirement is based on a sufficient condition for sequential consistency proposed by Dubois et al. <ref> [ScD87] </ref>. Condition 2.1 (1) and 2.1 (2) are symmetric, and we could have given similar implementations for each in condition 2.2 (1) and 2.2 (2).
References-found: 9

