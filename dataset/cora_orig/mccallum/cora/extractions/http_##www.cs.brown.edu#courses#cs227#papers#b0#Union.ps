URL: http://www.cs.brown.edu/courses/cs227/papers/b0/Union.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: fmfc,sbz,mhng@cs.brown.edu  
Title: To Form a More Perfect Union (Intersection, Difference)  
Author: Mitch Cherniack Stanley B. Zdonik Marian H. Nodine 
Address: Providence, RI, 02906 USA  
Affiliation: Department of Computer Science, Brown University  
Abstract: The ability to decide whether or not two objects are the same is a fundamental requirement of any database query language. Because no single equality definition is appropriate for all object types, many languages permit users to define their own. The query algebra, AQUA [14] goes so far as to allow user-defined equalities to be supplied as arguments to query operators. These operators generalize standard set operators (union, intersection, difference). The supplied equality predicates help determine what objects are included in the query result, and determine the duplicates that must then be removed. For expressivity, AQUA permits any equivalence relation to act as an equality. But many equivalence relations, when used to decide membership in a set, can result in sets with counterintuitive behavior. This means that AQUA queries can produce unreasonable results. In this paper, we show that equality predicates assume two roles with respect to sets. Distinguishers differentiate between a set's members and implicitly give meaning to standard set properties such as membership and equality of sets. Constructors are used with set operators to build new sets, and determine which objects in input sets should be included in the result. We show that requirements of distinguishers and constructors differ because of how they are used, and that AQUA's set operators are problematic because they use constructors where distinguishers are required. We propose alternatives to AQUA's set operators that address this limitation. Intuitively, our operators differ from AQUA's in that they incorporate entire constructor-based equivalence classes into results rather than choosing arbitrary representatives from these classes. As a result, our operators are deterministic and can be shown to satisfy the same algebraic identities that hold of the set operators they generalize.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Serge Abiteboul, Eric Simon, and Victor Vianu. </author> <title> Non-deterministic languages to express deterministic transformations. </title> <booktitle> In Proceedings of the Ninth ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 218-229, </pages> <address> Nashville, Tennesee, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Guaranteeing shared side-effects for 12 equality predicates is one way to prevent the fission effect. However, since our notion of persistence also establishes that unequal objects do not become equal (i.e., no fusion), it is a tighter constraint on equality definitions. Finally, <ref> [1] </ref> and [9] also consider nondeterminism in database query operators. Abiteboul et. al. [1] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization. <p> However, since our notion of persistence also establishes that unequal objects do not become equal (i.e., no fusion), it is a tighter constraint on equality definitions. Finally, <ref> [1] </ref> and [9] also consider nondeterminism in database query operators. Abiteboul et. al. [1] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization.
Reference: [2] <author> M. P. Atkinson, C. Lecluse, P. Philbrow, and P. Richard. </author> <title> Design issues in a map language. </title> <editor> In Paris Kanellakis and Joachim W. Schmidt, editors, </editor> <title> Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <pages> pages 20-32, </pages> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: Our work was motivated by recognition of the well-definedness problems of AQUA's nondeterministic operators ([14]) that were described in Section 1. Others (<ref> [2] </ref>, [8], [18]) have considered the role of user-defined equalities in query operators. In [2] and [8], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. Our discussion of the duality of equality predicates most resembles observations made by Osborn in [18]. However, her perspective is inspired by querying.
Reference: [3] <author> Henry Baker. </author> <title> Equal rights for functional objects or, the more things change, the more they are the same. </title> <journal> OOPS Messenger, </journal> <volume> 4(4) </volume> <pages> 1-26, </pages> <month> Oc-tober </month> <year> 1993. </year>
Reference-contexts: However, the innocent looking equality operator is quite often taken for granted. Others ([2], [8], [10], [11], [14], <ref> [3] </ref>) have observed that it is often useful or even necessary to allow users to define their own notions of equality. While this idea has been discussed before, there still remains the question of how this capability is best integrated into a database query language. <p> Our thoughts on the requirements on distinguisher equalities resembles work done in [15], [11], [10] and <ref> [3] </ref>. From CLU ([15]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. <p> This idea is carried further in the object-oriented setting in [11] and [10] which argue that equality definitions should vary according to the mutability of an object, and that equality for mutable objects should always depend on comparisons of identity. Baker <ref> [3] </ref> proposes that equal mutable objects should share side-effects. This differs from congruence in that the effects of mutating one of two equal objects is seen from the other. Guaranteeing shared side-effects for 12 equality predicates is one way to prevent the fission effect.
Reference: [4] <author> Catriel Beeri and Yoram Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <editor> In S. Abiteboul and P. C. Kanellakis, editors, </editor> <booktitle> Proceedings of the Third International Conference on Database Theory, number 470 in Lecture Notes in Computer Science, </booktitle> <pages> pages 72-88, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year> <title> EATCS, </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: For the axioms shown, we adopt the algebraic set notation used in Larch [12] that includes insert and ff as set constructors. This is in contrast to the polyadic brace notation, f : : : g, used 5 in <ref> [4] </ref> for example. 1 The pervasiveness of distinguisher equality predicates in these definitions helps argue our point that properties held or not held by ' affect the well-behavedness of the set for which it distinguishes members. Below we describe some unreasonable set behaviors that can result from poorly defined distinguish-ers.
Reference: [5] <author> Mitch Cherniack. </author> <title> Form(ers) over function(s): A combinator-based approach to specifying and optimizing queries. </title> <type> Technical report, </type> <institution> Brown University Department of Computer Science, </institution> <month> May </month> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: Our algebra, KOLA 3 is combinator-based, and includes the set operators described here as well as other operators described in [6]. A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in [7] and <ref> [5] </ref>.
Reference: [6] <author> Mitch Cherniack and Stanley B. Zdonik. </author> <title> Rule languages and internal algebras for rule-based optimizers. </title> <note> submitted to SIGMOD '96. </note>
Reference-contexts: The work described here is part of the development of a general-purpose query algebra that is independent of underlying data models. Our algebra, KOLA 3 is combinator-based, and includes the set operators described here as well as other operators described in <ref> [6] </ref>. A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in [7] and [5].
Reference: [7] <author> Mitch Cherniack and Stanley B. Zdonik. </author> <title> Applying formal methods to the design of a query optimizer. </title> <type> Technical Report CS-95-41, </type> <institution> Brown University Department of Computer Science, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: Our algebra, KOLA 3 is combinator-based, and includes the set operators described here as well as other operators described in [6]. A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in <ref> [7] </ref> and [5].
Reference: [8] <author> Richard Connor, Malcolm Atkinson, Sonia Berman, Quinton Cutts, Graham Kirby, and Ron Morrison. </author> <title> The joy of sets. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <pages> pages 417-433, </pages> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. 14 </note>
Reference-contexts: However, the innocent looking equality operator is quite often taken for granted. Others ([2], <ref> [8] </ref>, [10], [11], [14], [3]) have observed that it is often useful or even necessary to allow users to define their own notions of equality. While this idea has been discussed before, there still remains the question of how this capability is best integrated into a database query language. <p> Our contributions concern recognizing the dual roles that user-defined equality predicates play with respect to sets, and building an equivalence-parameterized and deterministic set algebra. Our work was motivated by recognition of the well-definedness problems of AQUA's nondeterministic operators ([14]) that were described in Section 1. Others ([2], <ref> [8] </ref>, [18]) have considered the role of user-defined equalities in query operators. In [2] and [8], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. <p> Our work was motivated by recognition of the well-definedness problems of AQUA's nondeterministic operators ([14]) that were described in Section 1. Others ([2], <ref> [8] </ref>, [18]) have considered the role of user-defined equalities in query operators. In [2] and [8], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. Our discussion of the duality of equality predicates most resembles observations made by Osborn in [18]. However, her perspective is inspired by querying.
Reference: [9] <author> Jan Van den Bussche and Dirk Van Gucht. </author> <title> Semi-determinism (extended abstract). </title> <booktitle> In Proceedings of the Eleventh ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Guaranteeing shared side-effects for 12 equality predicates is one way to prevent the fission effect. However, since our notion of persistence also establishes that unequal objects do not become equal (i.e., no fusion), it is a tighter constraint on equality definitions. Finally, [1] and <ref> [9] </ref> also consider nondeterminism in database query operators. Abiteboul et. al. [1] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization. We borrow our notion of what makes a nondeterministic operator well-defined from [9]. 5 Conclusions and Further Work This paper <p> Finally, [1] and <ref> [9] </ref> also consider nondeterminism in database query operators. Abiteboul et. al. [1] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization. We borrow our notion of what makes a nondeterministic operator well-defined from [9]. 5 Conclusions and Further Work This paper has proposed a separation between two fundamental uses of equality: distinguishing and constructing new sets. We have shown that three undesirable behaviors of sets can arise if the distinguisher that is used to compare set members is too weak.
Reference: [10] <author> Peter Grogono and Patrice Chalin. </author> <title> Copying, sharing and aliasing. </title> <booktitle> In Colloquium on Object-Orientation in Databases and Software Engineering, </booktitle> <address> Montreal, Quebec, </address> <year> 1994. </year>
Reference-contexts: However, the innocent looking equality operator is quite often taken for granted. Others ([2], [8], <ref> [10] </ref>, [11], [14], [3]) have observed that it is often useful or even necessary to allow users to define their own notions of equality. While this idea has been discussed before, there still remains the question of how this capability is best integrated into a database query language. <p> Our thoughts on the requirements on distinguisher equalities resembles work done in [15], [11], <ref> [10] </ref> and [3]. From CLU ([15]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. This idea is carried further in the object-oriented setting in [11] and [10] which argue that equality definitions should vary according to the mutability of an object, and <p> Our thoughts on the requirements on distinguisher equalities resembles work done in [15], [11], <ref> [10] </ref> and [3]. From CLU ([15]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. This idea is carried further in the object-oriented setting in [11] and [10] which argue that equality definitions should vary according to the mutability of an object, and that equality for mutable objects should always depend on comparisons of identity. Baker [3] proposes that equal mutable objects should share side-effects.
Reference: [11] <author> Peter Grogono and Philip Santas. </author> <title> Equality and assignment in object-oriented languages. </title> <booktitle> In EastEurOOPe'93, </booktitle> <pages> pages 191-201, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: However, the innocent looking equality operator is quite often taken for granted. Others ([2], [8], [10], <ref> [11] </ref>, [14], [3]) have observed that it is often useful or even necessary to allow users to define their own notions of equality. While this idea has been discussed before, there still remains the question of how this capability is best integrated into a database query language. <p> Our thoughts on the requirements on distinguisher equalities resembles work done in [15], <ref> [11] </ref>, [10] and [3]. From CLU ([15]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. This idea is carried further in the object-oriented setting in [11] and [10] which argue that equality definitions should vary according to the mutability of an object, <p> Our thoughts on the requirements on distinguisher equalities resembles work done in [15], <ref> [11] </ref>, [10] and [3]. From CLU ([15]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. This idea is carried further in the object-oriented setting in [11] and [10] which argue that equality definitions should vary according to the mutability of an object, and that equality for mutable objects should always depend on comparisons of identity. Baker [3] proposes that equal mutable objects should share side-effects.
Reference: [12] <author> J.V. Guttag, J.J. Hornung, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specifications. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: These properties include membership ( 2 ' ), equality of sets ( ' fg ) and cardinality (j j ' ). For the axioms shown, we adopt the algebraic set notation used in Larch <ref> [12] </ref> that includes insert and ff as set constructors. <p> We begin by formally defining this operator, and then defining our set operators, [ , " and in terms of ] . Finally, we present proofs of algebraic identities that hold of these operators. These proofs were verified with LP; the theorem prover of Larch <ref> [12] </ref>. 3.1 The Extend Operator (] ) We define the extend operator over sets in terms of a filtering operator, B A . 2 For any two sets A and B, B A consists of all elements in the set B that are equivalent to some element of A.
Reference: [13] <author> Christophe Lecluse, Philippe Richard, and Fernando Velez. </author> <title> O2, an object oriented data model. </title> <booktitle> In Proceedings of the Conference on the Management of Data, </booktitle> <pages> pages 424-433, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The equality of mutable objects will always require comparison of object identifiers; object attributes that distinguish mutable objects in a manner coincident with the way the run-time system determines the objects involved in a function call. (Identifiers can be private (as in the "OID's" of <ref> [13] </ref>) or public, as in declared keys.) Object identifiers are immutable keys by definition, and comparisons of them are equivalence 8 relations. Further, distinguishers for mutable objects that do not compare object identifiers will necessarily lack either persistence or congruence.
Reference: [14] <author> Theodore W. Leung, Gail Mitchell, Bharathi Subramanian, Bennet Vance, Scott L. Vandenberg, and Stanley B. Zdonik. </author> <title> The AQUA data model and algebra. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: However, the innocent looking equality operator is quite often taken for granted. Others ([2], [8], [10], [11], <ref> [14] </ref>, [3]) have observed that it is often useful or even necessary to allow users to define their own notions of equality. While this idea has been discussed before, there still remains the question of how this capability is best integrated into a database query language. <p> Nondeterminism in set operators can be viewed as an expressive enhancement to a query language or algebra. This is the view taken in AQUA <ref> [14] </ref>, which not only allows user-defined equalities, but makes them parameters to set operators. This allows succinct expression of queries that ask for representatives from related sets. <p> Unlike the equality-parameterized operations of <ref> [14] </ref>, our operations are deterministic. One can get the effect of AQUA's nondeterministic operators by applying a representative choosing operation (such as AQUA's dup elim) over any set resulting from the application of one of our operators. This is because our operators have the same functionality as those of [14] except <p> of <ref> [14] </ref>, our operations are deterministic. One can get the effect of AQUA's nondeterministic operators by applying a representative choosing operation (such as AQUA's dup elim) over any set resulting from the application of one of our operators. This is because our operators have the same functionality as those of [14] except that ours incorporate entire equivalence classes into the result rather than choosing representatives. Of course, if representatives are chosen in subqueries, then the same kinds of problematic behaviors described in Section 1 can be reintroduced. But most queries should not need to choose representatives until the last step.
Reference: [15] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: We describe each behavior and show how poor distinguisher definitions are at fault. We then propose constraints on distinguisher definitions that guard against these unintuitive behaviors. 2.1.2 Symptom 1: Equal Sets that are Distinguishable by Querying In CLU <ref> [15] </ref> it is argued that equality definitions should be congruences; two objects should be equal iff they are indistinguishable. This should be no different for sets: equality of sets by extensionality (memberwise equality) should establish two sets to be indistinguishable. <p> Our thoughts on the requirements on distinguisher equalities resembles work done in <ref> [15] </ref>, [11], [10] and [3]. From CLU ([15]) we borrow the idea that two objects should be equal if and only if they are indistinguishable.
Reference: [16] <author> Barbara Liskov, Paul Johnson, Robert Gruber, and Liuba Shrira. </author> <title> A highly available object repository for use in a heterogeneous distributed system. </title> <editor> In Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors, </editor> <title> Implementing Persistent Object Bases, </title> <booktitle> Principles and Practice, Proceedings of the Fourth International Workshop on Persistent Objects, </booktitle> <address> Martha's Vineyard, MA, USA, </address> <month> September </month> <year> 1990. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in [7] and [5]. We are currently concentrating our efforts on integrating KOLA within the Thor <ref> [16] </ref> object 3 KOLA is an acronym for [K]ind [O]f [L]ike [A]QUA 13 server under development at MIT and the EPOQ [17] extensible optimizer under development at Brown. 6 Acknowledgements Special thanks are due to Barbara Liskov and Andrew Myers who inspired our work with thought-provoking questions about what it means
Reference: [17] <author> Marian H. Nodine, Farah B. Abbas, and Mitch Cherniack. </author> <title> The EPOQ query optimizer for object-oriented databases: Design specification, </title> <year> 1994. </year>
Reference-contexts: We are currently concentrating our efforts on integrating KOLA within the Thor [16] object 3 KOLA is an acronym for [K]ind [O]f [L]ike [A]QUA 13 server under development at MIT and the EPOQ <ref> [17] </ref> extensible optimizer under development at Brown. 6 Acknowledgements Special thanks are due to Barbara Liskov and Andrew Myers who inspired our work with thought-provoking questions about what it means for an equality predicate to be well-behaved.
Reference: [18] <author> S. L. Osborn. </author> <title> Identity, equality and query optimization. </title> <editor> In K. R. Dit-trich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems:Proceedings of the 2nd International Workshop on Object-Oriented Database Systems, number 334 in Lecture Notes in Computer Science, </booktitle> <pages> pages 346-351, </pages> <address> Bad Munster am Stein-Ebenburg, FRG, </address> <month> September </month> <year> 1988. </year> <note> Springer-Verlag. </note>
Reference-contexts: Our contributions concern recognizing the dual roles that user-defined equality predicates play with respect to sets, and building an equivalence-parameterized and deterministic set algebra. Our work was motivated by recognition of the well-definedness problems of AQUA's nondeterministic operators ([14]) that were described in Section 1. Others ([2], [8], <ref> [18] </ref>) have considered the role of user-defined equalities in query operators. In [2] and [8], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. <p> In [2] and [8], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. Our discussion of the duality of equality predicates most resembles observations made by Osborn in <ref> [18] </ref>. However, her perspective is inspired by querying. She writes that every object should have an identity that can be used for navigational querying as well as an equality that can be used for associative access, but fixes both predicates to be system-defined.
Reference: [19] <author> Gail M. Shaw and Stanley B. Zdonik. </author> <title> Object-oriented queries: Equivalence and optimization. </title> <editor> In Won Kim, Jean-Marie Nicolas, and Shojiro Nishioe, editors, </editor> <booktitle> Proceedings of the The First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 264-278, </pages> <address> Kyoto, Japan, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: We recognize that there may be any of a number of equivalences that are appropriate for use for associative access and that not every object should have identity (e.g., rational numbers should be differentiated by their values). <ref> [19] </ref> compares equality predicates but by their structure (the depth to which objects are compared) rather than their purpose. Our thoughts on the requirements on distinguisher equalities resembles work done in [15], [11], [10] and [3].
References-found: 19

