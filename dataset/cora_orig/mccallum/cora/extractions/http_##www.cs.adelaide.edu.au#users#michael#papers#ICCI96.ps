URL: http://www.cs.adelaide.edu.au/users/michael/papers/ICCI96.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: fhendra,michaelg@cs.adelaide.edu.au  
Title: Visualisation of Concurrent and Object-Oriented Programs  
Author: Hendra Widjaja and Michael J. Oudshoorn 
Keyword: program visualisation, concurrent, parallel, object-oriented.  
Address: Adelaide Adelaide, South Australia 5005  
Affiliation: Department of Computer Science The University of  
Abstract: Program visualisation can be defined as the application of graphical constructs to an algorithm or a program in order to visualise and understand its execution, methods, elements and purposes. It can be applied to a wide range of programming domains. It can also be used as a tool during program development. One such use is for understanding and debugging concurrent object-oriented programs. This paper describes Visor++, a tool for these purposes. It provides a coherent set of views that can easily be related back to the program being visualised. Furthermore, the tool is designed to have a loosely-coupled architecture, which is relatively easy to change and extend. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Ashton. </author> <title> Algorithms of off-line clock synchronisation. </title> <type> Technical Report TR-COSC 12/95, </type> <institution> Department of Computer Science, University of Canterbury, </institution> <address> New Zealand, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Since CC++ programs can execute on a heterogeneous network of machines, the timestamps of events from different machines may not be synchronised. To compensate for this problem, an off-line clock synchronisation algorithm, called two-point algorithm <ref> [1] </ref>, is used. The idea is to calculate a timestamp correction function B (t) ff + fiA (t), where ff is the initial offset between two clocks, and fi is the relative clock drift between them. Note that this formula is only an estimate of the difference between two clocks.
Reference: [2] <author> P. Ashton. </author> <title> Monitoring the Processing of Interactive Requests on Distributed Systems. </title> <type> Technical Report TR-COSC 07/95, </type> <institution> Department of Computer Science, University of Canterbury, </institution> <address> New Zealand, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: The problem is that they do not represent program events in terms that directly relate back to the program itself [6, 11]. As a result, pin-pointing a problem can be difficult. For example, performance visualisation systems usually provide only one or two types of performance views <ref> [2, 12] </ref>. The performance statistic views do give a global overview of the overall program performance, but they cannot easily attribute performance back to individual program parts. One way out of this problem is to supply views that can relate the displays back to the program. <p> The second issue, closely related to the first, is that existing tools generally only provide a limited number of perspectives. For example, a visualisation system designed for understanding programs may only provide program static structure browsers, and displays of dynamic program execution <ref> [2, 8] </ref>. A limited number of perspectives mean that the mapping of a program dynamic model to the programmer's mental model is not holistic. A full understanding of a program can be better achieved by presenting different aspects of the program to the programmer. <p> This problem usually stems from the fact that the system is tuned for very specific environments. This can also be caused by the fact that the system and its usage necessitate such a design. One example is visualisation systems for operating system events <ref> [2, 11] </ref>. While such a design is very suitable for some usages, it can be very difficult to change and experiment to visualise other, even similar, systems. The above issues multiply in complexity for concurrent and object-oriented programs. Such programs can involve multiple threads, processes, and processors in computation. <p> After the overall program execution is finished, the events are sent to a central control process. Here, the events are processed, and timestamp analysis is carried out to all the events to provide timing correction, and to eliminate causality violations among events <ref> [2, 3, 10] </ref>. The result of this processing is a consolidated event database which is ready for visualisation. Therefore, the whole system is a post-mortem visu-alisation system. This approach has several advantages [20].
Reference: [3] <author> A. Beguelin and E. Seligman. </author> <title> Causality-Preserving Timestamps in Distributed Programs. </title> <type> Technical Report CMU-CS-93-167, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <year> 1993. </year>
Reference-contexts: After the overall program execution is finished, the events are sent to a central control process. Here, the events are processed, and timestamp analysis is carried out to all the events to provide timing correction, and to eliminate causality violations among events <ref> [2, 3, 10] </ref>. The result of this processing is a consolidated event database which is ready for visualisation. Therefore, the whole system is a post-mortem visu-alisation system. This approach has several advantages [20].
Reference: [4] <author> P. Carlin, K.M. Chandy and C. Kesselman. </author> <title> The Compositional C++ Language Definition. </title> <type> Technical Report CS-TR-92-02, </type> <institution> Department of Computer Science, California Insitute of Technology, </institution> <year> 1993. </year>
Reference-contexts: Also, the user can skip portions of the program execution. 4 Implementation To experiment with the concepts and framework proposed in Section 3, Visor++ is implemented to visualise the execution of programs written in CC++ <ref> [4] </ref>, a concurrent object-oriented language derived from C++ [18]. The implementation is described below. 4.1 Overview of CC++ CC++ is a concurrent programming language based on C++, with some extensions. Some of these are discussed below. * Processor objects A processor object is a unit of computation. <p> A computation, in turn, can be composed of one or more processor objects, executing concurrently on the same or different machines. For a processor object to access the variables or functions in another processor object, the global pointer mechanism is used <ref> [4, 5] </ref>. * Threads Threads in a CC++ program are contained in processor-objects, and may be either synchronous or asynchronous.
Reference: [5] <institution> CC++ Designer Team. CC++ Tutorial. Department of Computer Science, California Insitute of Technology, </institution> <year> 1994. </year>
Reference-contexts: A computation, in turn, can be composed of one or more processor objects, executing concurrently on the same or different machines. For a processor object to access the variables or functions in another processor object, the global pointer mechanism is used <ref> [4, 5] </ref>. * Threads Threads in a CC++ program are contained in processor-objects, and may be either synchronous or asynchronous.
Reference: [6] <author> W. DePauw, D. Kimelman and J. Vlissides. </author> <title> Modeling Object-Oriented Program Execution. </title> <booktitle> Proceedings of the 8th European Conference on Object-Oriented Programming 1994, </booktitle> <pages> pages 163-182, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: This model refers to the run-time behaviour of the program. The mapping is done by using program environment run-time control, such as operating systems. This dynamic model can furthermore be mapped into the programmer's mental model, which is a mental representation of the program execution. This mapping is important <ref> [6] </ref>, because it enables the programmer to superimpose the execution mental model with the original mental model to find the differences between the initial program specifications and the final run-time outputs, or in other words, to identify bugs. <p> Some work related with Visor++ is discussed in Section 5, and Section 6 concludes the whole discussion. 2 Motivation and goals Program visualisation can be used for the purpose of debugging and understanding programs. There have been many tools constructed for this purpose <ref> [6, 7] </ref>. In this context, however, visualisation for concurrent and object-oriented programs is still at its early stage [13]. In providing such visualisation, there are several issues that need to be addressed. The first issue is about relating the program dynamic model back to the programmer's mental model. <p> However, the views presented by most of the tools are not easily understood. Sometimes, they still need a large amount of effort of re-interpretation. The problem is that they do not represent program events in terms that directly relate back to the program itself <ref> [6, 11] </ref>. As a result, pin-pointing a problem can be difficult. For example, performance visualisation systems usually provide only one or two types of performance views [2, 12]. <p> The visual displays, and the automatic instrumentation subsystem however, are still being implemented. 5 Related work Many tools have been developed to address the problem of helping to create a program execution mental model. However, relatively few systems have been created for visualising concurrent [13], or object-oriented programs <ref> [6] </ref>. The same situation applies to the combined paradigm of concurrent and object-oriented programs. The IBM Ovation system [6] introduces a number of novel views that show the run-time relationships and interaction among objects in object-oriented programs. <p> However, relatively few systems have been created for visualising concurrent [13], or object-oriented programs <ref> [6] </ref>. The same situation applies to the combined paradigm of concurrent and object-oriented programs. The IBM Ovation system [6] introduces a number of novel views that show the run-time relationships and interaction among objects in object-oriented programs. Inter-object calls, and member-function execution | for example | are visualised by using statistic-based and graph-based views. Ovation also uses automatic source-code instrumentation. Jerding [7] develops GROOVE to visualise object-oriented programs.
Reference: [7] <author> D.F. Jerding and J.T. Stasko. </author> <title> Using Visualisation to Foster Object-Oriented Understanding. </title> <type> Technical Report GIT-GVU-94-33, </type> <institution> Graphics, Visualisation and Usability Centre, College of Computing, Georgia Institute of Technology, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Some work related with Visor++ is discussed in Section 5, and Section 6 concludes the whole discussion. 2 Motivation and goals Program visualisation can be used for the purpose of debugging and understanding programs. There have been many tools constructed for this purpose <ref> [6, 7] </ref>. In this context, however, visualisation for concurrent and object-oriented programs is still at its early stage [13]. In providing such visualisation, there are several issues that need to be addressed. The first issue is about relating the program dynamic model back to the programmer's mental model. <p> The IBM Ovation system [6] introduces a number of novel views that show the run-time relationships and interaction among objects in object-oriented programs. Inter-object calls, and member-function execution | for example | are visualised by using statistic-based and graph-based views. Ovation also uses automatic source-code instrumentation. Jerding <ref> [7] </ref> develops GROOVE to visualise object-oriented programs. It is similar to Visor++ in that it is a post-mortem program visualisation system that also uses automatic source-code instrumentation. GROOVE supports views that represent program execution, similar to the execution view in Visor++.
Reference: [8] <author> M.F. </author> <title> Kleyn and P.C. Gingrich. GraphTrace | Understanding Object-Oriented Systems Using Concurrently Animated Views. </title> <booktitle> In Proceedings of Object-Oriented Programming Systems, Languages, and Applications OOPSLA 1988, </booktitle> <pages> pages 191-205, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: The second issue, closely related to the first, is that existing tools generally only provide a limited number of perspectives. For example, a visualisation system designed for understanding programs may only provide program static structure browsers, and displays of dynamic program execution <ref> [2, 8] </ref>. A limited number of perspectives mean that the mapping of a program dynamic model to the programmer's mental model is not holistic. A full understanding of a program can be better achieved by presenting different aspects of the program to the programmer.
Reference: [9] <author> E. Kraemer and J.T. Stasko. </author> <title> The Visualisation of Parallel Systems: An Overview. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Volume 18, </volume> <pages> pages 105-117, </pages> <year> 1993. </year>
Reference-contexts: The concepts imple mented should also be relatively portable to other similar environments. 3 Visor++ The general framework of Visor++ is shown in Figure 2. The system comprises three general parts. For a general treatise of the issues, problem, and possible solutions for each part, see <ref> [9, 20] </ref>. 3.1 Program instrumentation The first part is program instrumentation, in which program monitoring statements, or "probes" are inserted into a program. In Visor++, instrumentation is done automatically at the source-code level. An instrumentator reads, and parses the source code, and subsequently inserts instrumentation probes. <p> Second, the tool adopts the assumption that the underlying structure of the object code should be similar to that of its associated source code [16, 20]. Otherwise, the source-code level events do not correspond well to the real program execution. Program instrumentation also introduces probe effects <ref> [9, 20] </ref>. This means that either the program execution time is altered/increased, or the original relative ordering of events is altered. This cannot be entirely eliminated, but can only be minimised [9]. Therefore, in Visor++, attempts are made only to minimise these effects. <p> Program instrumentation also introduces probe effects [9, 20]. This means that either the program execution time is altered/increased, or the original relative ordering of events is altered. This cannot be entirely eliminated, but can only be minimised <ref> [9] </ref>. Therefore, in Visor++, attempts are made only to minimise these effects. For example each event requires a processor identifier. But, since this identifier is static, and can be supplied by the monitoring subsystem (see Section 3.2), then each probe does not have to record it by itself.
Reference: [10] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> Volume 21, Number 7, </volume> <pages> pages 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: After the overall program execution is finished, the events are sent to a central control process. Here, the events are processed, and timestamp analysis is carried out to all the events to provide timing correction, and to eliminate causality violations among events <ref> [2, 3, 10] </ref>. The result of this processing is a consolidated event database which is ready for visualisation. Therefore, the whole system is a post-mortem visu-alisation system. This approach has several advantages [20]. <p> As the two-point algorithm is only an estimate, there may still be some inaccuracies. Such inaccuracies typically involve causality violation in event ordering. To overcome this problem, the events are further analysed and their timestamps are corrected so that they obey the Lamport's "happened-before" relationship <ref> [10] </ref>. After all the above processing is carried out, the events are ready for visualisa tion. * Visualisation The views in Figure 3 are implemented through the use of POLKA [17], a graphics package from Georgia Institute of Technology for building visualisation for parallel programs.
Reference: [11] <author> T. Lehr, Z. Segall, D.F. Vrsalovic, E. Caplan, A.L. Chung and C.E. Fineman. </author> <title> Visualising Performance Debugging. </title> <journal> IEEE Computer, </journal> <volume> Volume 22, Number 10, </volume> <pages> pages 38-51, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: However, the views presented by most of the tools are not easily understood. Sometimes, they still need a large amount of effort of re-interpretation. The problem is that they do not represent program events in terms that directly relate back to the program itself <ref> [6, 11] </ref>. As a result, pin-pointing a problem can be difficult. For example, performance visualisation systems usually provide only one or two types of performance views [2, 12]. <p> One way out of this problem is to supply views that can relate the displays back to the program. A source-code view that is displayed coherently with other views can fulfill this role <ref> [11, 19] </ref>. The second issue, closely related to the first, is that existing tools generally only provide a limited number of perspectives. For example, a visualisation system designed for understanding programs may only provide program static structure browsers, and displays of dynamic program execution [2, 8]. <p> This problem usually stems from the fact that the system is tuned for very specific environments. This can also be caused by the fact that the system and its usage necessitate such a design. One example is visualisation systems for operating system events <ref> [2, 11] </ref>. While such a design is very suitable for some usages, it can be very difficult to change and experiment to visualise other, even similar, systems. The above issues multiply in complexity for concurrent and object-oriented programs. Such programs can involve multiple threads, processes, and processors in computation. <p> Ovation also uses automatic source-code instrumentation. Jerding [7] develops GROOVE to visualise object-oriented programs. It is similar to Visor++ in that it is a post-mortem program visualisation system that also uses automatic source-code instrumentation. GROOVE supports views that represent program execution, similar to the execution view in Visor++. PIE <ref> [11] </ref>, developed at Carnegie Mellon University, is a software development environment that also provides visualisation for the performance debugging of thread-based parallel programs. PIE installs instrumentation probes in the operating system, and the binary code of the visualised program.
Reference: [12] <author> S. Lei and K. Zhang. </author> <title> Performance Visualisation of Message-Passing Programs Using Relational Approach. </title> <booktitle> In Proceedings of the 7th International Conference on Parallel and Distributed Systems in Taiwan, </booktitle> <pages> pages 153 - 162. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: The problem is that they do not represent program events in terms that directly relate back to the program itself [6, 11]. As a result, pin-pointing a problem can be difficult. For example, performance visualisation systems usually provide only one or two types of performance views <ref> [2, 12] </ref>. The performance statistic views do give a global overview of the overall program performance, but they cannot easily attribute performance back to individual program parts. One way out of this problem is to supply views that can relate the displays back to the program.
Reference: [13] <author> G. Marwaha and K. Zhang. </author> <title> Parallel Program Visualisation for a Message-Passing System. </title> <booktitle> In Proceedings of the 13th Annual IEEE International Conference on Computers and Communications, Phoenix, USA, </booktitle> <pages> pages 200 - 205. </pages> <publisher> IEEE Press, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: There have been many tools constructed for this purpose [6, 7]. In this context, however, visualisation for concurrent and object-oriented programs is still at its early stage <ref> [13] </ref>. In providing such visualisation, there are several issues that need to be addressed. The first issue is about relating the program dynamic model back to the programmer's mental model. Existing visualisation tools do have this capability. However, the views presented by most of the tools are not easily understood. <p> The visual displays, and the automatic instrumentation subsystem however, are still being implemented. 5 Related work Many tools have been developed to address the problem of helping to create a program execution mental model. However, relatively few systems have been created for visualising concurrent <ref> [13] </ref>, or object-oriented programs [6]. The same situation applies to the combined paradigm of concurrent and object-oriented programs. The IBM Ovation system [6] introduces a number of novel views that show the run-time relationships and interaction among objects in object-oriented programs.
Reference: [14] <author> R.S. Pressman. </author> <title> Software Engineering, A Practitioner's Approach. </title> <publisher> McGraw-Hill, Inc., 3rd edition, </publisher> <year> 1992. </year>
Reference-contexts: Each paradigm needs a different approach, as they utilise different methods of problem solving, and can benefit from visualisations which emphasise those aspects particular to that paradigm. Visuali-sation can also be used throughout the program development life-cycle, e.g. during the testing, verification and maintenance steps <ref> [14] </ref>. The visual aspects of program visualisation can make these tasks easier. A simple model of program development cycle is illustrated in Figure 1. First, a programmer creates a mental model of the software/program.
Reference: [15] <author> B.A. Price, </author> <title> R.M. Baecker and I.S. Small. A Principled Taxonomy of Software Visualisation. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> Volume 4, Number 3, </volume> <pages> pages 211-266, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Program visualisation is the use of graphical artifacts to represent both the static and dynamic aspects of a program <ref> [15, 20] </ref>. It takes advantage of the human visual ability to perceive pictorial representations of a program faster than the corresponding textual information. Generally, such visualisation is used to enhance human understanding of a program or algorithm [20].
Reference: [16] <author> D.A. Reed. </author> <title> Performance Instrumentation Techniques for Parallel Systems, </title> <booktitle> Volume 729 of Lecture Notes in Computer Science, </booktitle> <pages> pages 463-490. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This means, for example, that the tool may not be able to give very accurate program performance information. Second, the tool adopts the assumption that the underlying structure of the object code should be similar to that of its associated source code <ref> [16, 20] </ref>. Otherwise, the source-code level events do not correspond well to the real program execution. Program instrumentation also introduces probe effects [9, 20]. This means that either the program execution time is altered/increased, or the original relative ordering of events is altered.
Reference: [17] <author> J.T. Stasko and E. Kraemer. </author> <title> A Methodology for Building Application-Specific Visualisations of Parallel Programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Volume 18, </volume> <pages> pages 258-264, </pages> <year> 1993. </year>
Reference-contexts: After all the above processing is carried out, the events are ready for visualisa tion. * Visualisation The views in Figure 3 are implemented through the use of POLKA <ref> [17] </ref>, a graphics package from Georgia Institute of Technology for building visualisation for parallel programs. POLKA provides a number of simple functions to create relatively sophisticated program animation. To produce a visualisation, the consolidated event log and the static data repos-itory are provided to the visualisation subsystem.
Reference: [18] <author> B. Stroustroup. </author> <title> The C++ Language Reference Manual. </title> <publisher> Prentice-Hall Publishing Company, </publisher> <address> Englewood Cliffs, N.J, 2nd edition, </address> <year> 1994. </year>
Reference-contexts: Also, the user can skip portions of the program execution. 4 Implementation To experiment with the concepts and framework proposed in Section 3, Visor++ is implemented to visualise the execution of programs written in CC++ [4], a concurrent object-oriented language derived from C++ <ref> [18] </ref>. The implementation is described below. 4.1 Overview of CC++ CC++ is a concurrent programming language based on C++, with some extensions. Some of these are discussed below. * Processor objects A processor object is a unit of computation.
Reference: [19] <author> A. West. </author> <title> Making a Case for Animating C++ Programs. </title> <journal> Dr. Dobb's Journal, </journal> <volume> Volume 19, Number 11, </volume> <pages> pages 54 - 60, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: One way out of this problem is to supply views that can relate the displays back to the program. A source-code view that is displayed coherently with other views can fulfill this role <ref> [11, 19] </ref>. The second issue, closely related to the first, is that existing tools generally only provide a limited number of perspectives. For example, a visualisation system designed for understanding programs may only provide program static structure browsers, and displays of dynamic program execution [2, 8]. <p> PIE installs instrumentation probes in the operating system, and the binary code of the visualised program. Similar to Visor++, it also relates entities in the resulting views back to the source code. The commercial tool LOOK! <ref> [19] </ref> is used for visualising C++ programs. Program instrumentation is supplied at the binary code level and at the source code level. LOOK! has conceptually incorporated many of the features of Visor++, by providing multiple coherent views.
Reference: [20] <author> H. Widjaja and M. Oudshoorn. </author> <title> Devising a Program Visualisation Tool for Concurrent and Object-Oriented Programs: A Survey. </title> <type> Technical Report TR95-14, </type> <institution> Department of Computer Science, University of Adelaide, Australia, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Program visualisation is the use of graphical artifacts to represent both the static and dynamic aspects of a program <ref> [15, 20] </ref>. It takes advantage of the human visual ability to perceive pictorial representations of a program faster than the corresponding textual information. Generally, such visualisation is used to enhance human understanding of a program or algorithm [20]. <p> It takes advantage of the human visual ability to perceive pictorial representations of a program faster than the corresponding textual information. Generally, such visualisation is used to enhance human understanding of a program or algorithm <ref> [20] </ref>. Program visualisation can be used for many programming paradigms, including the concurrent and object-oriented paradigms. Each paradigm needs a different approach, as they utilise different methods of problem solving, and can benefit from visualisations which emphasise those aspects particular to that paradigm. <p> The concepts imple mented should also be relatively portable to other similar environments. 3 Visor++ The general framework of Visor++ is shown in Figure 2. The system comprises three general parts. For a general treatise of the issues, problem, and possible solutions for each part, see <ref> [9, 20] </ref>. 3.1 Program instrumentation The first part is program instrumentation, in which program monitoring statements, or "probes" are inserted into a program. In Visor++, instrumentation is done automatically at the source-code level. An instrumentator reads, and parses the source code, and subsequently inserts instrumentation probes. <p> This means, for example, that the tool may not be able to give very accurate program performance information. Second, the tool adopts the assumption that the underlying structure of the object code should be similar to that of its associated source code <ref> [16, 20] </ref>. Otherwise, the source-code level events do not correspond well to the real program execution. Program instrumentation also introduces probe effects [9, 20]. This means that either the program execution time is altered/increased, or the original relative ordering of events is altered. <p> Second, the tool adopts the assumption that the underlying structure of the object code should be similar to that of its associated source code [16, 20]. Otherwise, the source-code level events do not correspond well to the real program execution. Program instrumentation also introduces probe effects <ref> [9, 20] </ref>. This means that either the program execution time is altered/increased, or the original relative ordering of events is altered. This cannot be entirely eliminated, but can only be minimised [9]. Therefore, in Visor++, attempts are made only to minimise these effects. <p> The result of this processing is a consolidated event database which is ready for visualisation. Therefore, the whole system is a post-mortem visu-alisation system. This approach has several advantages <ref> [20] </ref>. First, it permits a high degree of decoupling between the event collection subsystem and the event display subsystem. Second, this event database may be processed and displayed as many times as the user wants, or processed to feed into other post-mortem visualisation systems.
References-found: 20

