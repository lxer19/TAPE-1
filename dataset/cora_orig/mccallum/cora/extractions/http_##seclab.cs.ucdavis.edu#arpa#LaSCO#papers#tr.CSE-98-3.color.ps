URL: http://seclab.cs.ucdavis.edu/arpa/LaSCO/papers/tr.CSE-98-3.color.ps
Refering-URL: http://seclab.cs.ucdavis.edu/arpa/LaSCO/welcome.html
Root-URL: http://www.cs.ucdavis.edu
Email: -hoagland,pandey,levitt-@cs.ucdavis.edu  
Title: Security Policy Specification Using a Graphical Approach Page 1 Security Policy Specification Using a Graphical
Author: James A. Hoagland Raju Pandey Karl N. Levitt 
Note: 1.0 Introduction  is meant by security has been described in general terms such as confidentiality, integrity, and availability. However, what is precisely meant by secu  
Address: Davis  
Affiliation: Department of Computer Science University of California,  
Pubnum: Technical Report CSE-98-3  
Abstract: A security policy states the acceptable actions of an information system, as the actions bear on security. There is a pressing need for organizations to declare their security policies, even informal statements would be better than the current practice. But, formal policy statements are preferable to support (1) reasoning about policies, e.g., for consistency and completeness, (2) automated enforcement of the policy, e.g., using wrappers around legacy systems or after the fact with an intrusion detection system, and (3) other formal manipulation of policies, e.g., the composition of policies. We present LaSCO, the Language for Security Constraints on Objects, in which a policy consists of two parts: the domain (assumptions about the system) and the requirement (what is allowed assuming the domain is satisfied). Thus policies defined in LaSCO have the appearance of conditional access control statements. LaSCO policies are specified as expressions in logic and as directed graphs, giving a visual view of policy. LaSCO has a simple semantics in first order logic (which we provide), thus permitting policies we write, even for complex policies, to be very perspicuous. LaSCO has syntax to express many of the situations we have found to be useful on policies or, more interesting, the composition of policies. LaSCO has an object-oriented structure, permitting it to be useful to describe policies on the objects and methods of an application written in an object-oriented language, in addition to the traditional policies on operating system objects. A LaSCO specification can be automatically translated into executable code that checks an invocation of a program with respect to a policy. The implementation of LaSCO is in Java, and generates wrappers to check Java programs with respect to a policy. rity (or for something to be secure) for a particular system 1 varies from system to system and possibly depending on the situation. The military would likely have a different definition of what the appropriate security is for their system than a bank, a university, or a home user would. They each have their own needs that should be reected when securing their systems. In addition, one can describe security at various system levels. A security policy is a description of the security goals for a system and how a system should behave in order to meet these goals. An example policy is that the request for a purchase and its approval must be from different users. Since the security goals for a system effect how the security mechanisms on the system are configured, it is important for the security policy to be stated clearly. Additional benefit is obtained if the policy can be directly used to configure the security mechanisms or can be used to formally reason about the effect of the policy. A common security need is to restrict access to the resources on a system. This is reected in a constraint security policy, which states constraints on the system 2 . We focus on constraint security policies in this paper. 1. We use system generally here. It can be almost anything on a computer that contains some sort of entities and can be interacted with or can be seen as executing. Some examples are: a program executing, a file system, an operating system, a workgroup, and 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, J.P., </author> <title> Computer Security Technology Planning Study, ESD-TR-73-51, Vols. I and II, USAF Electronic Systems Division, </title> <address> Bedford, Mass., </address> <month> October </month> <year> 1972. </year>
Reference-contexts: The policy can be specified separately from a program. The language is not tied to any particular enforcement mechanism and the policies stated in it may be used in different ways. For example, policies may be compiled into a program, used by a reference monitor <ref> [1] </ref> to mediate access to system objects, or checked in an offline mode against an audit trail. We can state policies that apply whenever a certain pattern of accesses is encountered.
Reference: [2] <author> Bell, D.E. and L.J. LaPadula, </author> <title> Secure Computer Systems: Mathematical Foundations and Model, </title> <institution> M74-244, The MITRE Corp., Bedford, </institution> <address> Mass., </address> <month> May </month> <year> 1973. </year>
Reference-contexts: If each of the requirement predicates evaluate to true, then the policy is upheld, otherwise the policy had been violated by the system. For purposes of illustration, we now present a simple LaSCO policy graph. The LaSCO representation of the simple security policy of Bell-LaPadula <ref> [2] </ref> is depicted in Figure 2. The policy specifies that if a user is reading a file, the security level of the user must be at least as great at that on the file. <p> Variables in these predicates may be used to state a condition between objects, and if the requirement predicate does not refer to attribute names, the requirement predicate may actually appear on the edge. The access restrictions of Bell-LaPadula <ref> [2] </ref> and Biba [3] fall into this category. As an example, refer back to the simple security property depiction from Section 2.2, Figure 2. 5.1.2 Restricted event parameter access policies Restricted event parameter access policies limit the values of parameters on a event.
Reference: [3] <author> Biba, K.J., </author> <title> Integrity Considerations for Secure Computer Systems, ESD-TR-76-372, Electronic Systems Division, </title> <address> AFSC, Hanscom AFB, MA, April 1977 (The MITRE Corp., MTR-3153). </address>
Reference-contexts: Variables in these predicates may be used to state a condition between objects, and if the requirement predicate does not refer to attribute names, the requirement predicate may actually appear on the edge. The access restrictions of Bell-LaPadula [2] and Biba <ref> [3] </ref> fall into this category. As an example, refer back to the simple security property depiction from Section 2.2, Figure 2. 5.1.2 Restricted event parameter access policies Restricted event parameter access policies limit the values of parameters on a event.
Reference: [4] <author> Brewer, D.F.C., and M.J. Nash, </author> <title> The Chinese Wall Security Policy, </title> <booktitle> In Proceedings of the 1989 IEEE Symposium on Security and Privacy, </booktitle> <address> Oakland, CA, USA: </address> <publisher> IEEE Press, </publisher> <year> 1989. </year>
Reference-contexts: Some policies such as Chinese Wall <ref> [4] </ref> impose restrictions when events that access objects have a common origin. The idea behind the Chinese Wall policy is to prevent conict of interest situations by consultants that may be employed by a number of parties with competing interests.
Reference: [5] <author> Cholvy, Laurence and Frederic Cuppens, </author> <title> Analyzing Consistency of Security Policies. </title> <booktitle> In Proceed ings of the 1997 IEEE Symposium on Security and Privacy. </booktitle> <address> Oakland, CA, USA: </address> <publisher> IEEE Press, </publisher> <year> 1997. </year> <pages> p. 103-112. </pages>
Reference-contexts: The goal with this is to enforce varying security policies without changing the security server. This more structured approach towards overall site policies than LaSCO currently defines is useful in certain situations. Cholvy and Cuppens <ref> [5] </ref> express the policies on a site in terms of deontic logic, which states what is obliged to occur, what is permitted to occur, and what is forbidden to occur and how to deal with inconsistencies.
Reference: [6] <author> Denning, Dorothy, </author> <title> Cryptography and Data Security. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> 1982. </year>
Reference-contexts: This policy is shown in Figure 7. 5.1.3 Attribute-based ACM-type entries policies Policies of this type are restrictions for subjects regarding their access to objects. This is the type of restriction found in access control matrices (ACM) [12] and access control lists (see <ref> [6] </ref>). Individual restrictions are of a positive tense, indicating that that type of access is allowed or a negative tense, stating that the access is not allowed. Note that a particular positive subject-object-access ACM entry cannot be represented in LaSCO. <p> Unlike Mir, LaSCO states policies in terms of system execution (rather than a snapshot), can be applied to systems other than file systems, and has simpler semantics. Access matrices [12] and the related access control lists and capabilities (see <ref> [6] </ref>) are a traditional means of specifying security permissions.
Reference: [7] <author> Edjlali, Guy, Anurag Acharya, and Vipin Chaudhary, </author> <title> "History-based Access-control for Mobile Code." </title> <booktitle> To appear in Proceedings of the Fifth ACM Conference on Computer and Communications Security. </booktitle> <address> San Francisco, CA, USA. </address> <month> November </month> <year> 1998. </year> <title> Security Policy Specification Using a Graphical Approach Page 27 </title>
Reference-contexts: We believe LaSCO can express any Adage policy, but offers the additional benefits of application to different kinds of systems, direct linking to an application program, and formal semantics. Deeds, developed by Edjlali, Acharya, and Chaudhary <ref> [7] </ref>, is a history-based access control mechanism for Java whose goal is to mediate accesses to critical resources by mobile code. LaSCO can also be used for this purpose. As we plan to do, they insert code into Java programs.
Reference: [8] <author> Jajodia, Sushil, Pierangela Samarati, </author> <title> and V.S. Subrahmanian, A Logical Language for Expressing Authorizations. </title> <booktitle> In Proceedings of the 1997 IEEE Symposium on Security and Privacy. </booktitle> <address> Oakland, CA, USA: </address> <publisher> IEEE Press, </publisher> <year> 1997. </year> <pages> p. 31-42. </pages>
Reference-contexts: It succeeds to an extent with both of these, though LaSCO has broader means for achieving this. When making decisions, BEE cannot make reference to other events that have occurred. The Authorization Specification Language is a similar approach <ref> [8] </ref> that expresses the desired authorizations in logic and has conict resolution rules defined in the language. The goal with this is to enforce varying security policies without changing the security server. This more structured approach towards overall site policies than LaSCO currently defines is useful in certain situations.
Reference: [9] <author> Harel, David, </author> <title> On Visual Formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 514-530, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Mir consists of two languages, an instance language and a constraint language [10], both of which are based on Harels hierarchical graphs <ref> [9] </ref>. The instance languages formal semantics is defined in [13] and is peer to our system graph. It describes a file system access control matrix.
Reference: [10] <author> Heydon, Allan, Mark W. Maimone, J.D Tygar, Jeannette M. Wing, and Amy Moormann Zaremski, Mir: </author> <title> Visual Specification of Security. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> 6(10):1185 1197, </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: Mir consists of two languages, an instance language and a constraint language <ref> [10] </ref>, both of which are based on Harels hierarchical graphs [9]. The instance languages formal semantics is defined in [13] and is peer to our system graph. It describes a file system access control matrix.
Reference: [11] <author> Heydon, Allan, and J.D. Tygar, </author> <title> Specifying and Checking Unix Security Constraints. </title> <booktitle> In UNIX Secu rity Symposium III Proceedings. </booktitle> <address> Berkeley, CA, USA: </address> <publisher> USENIX Assoc., </publisher> <year> 1992. </year> <pages> p. 211-226 </pages>
Reference-contexts: The constraint language for which a constraint checker was implemented for the language for Unix <ref> [11] </ref>. Unlike Mir, LaSCO states policies in terms of system execution (rather than a snapshot), can be applied to systems other than file systems, and has simpler semantics. Access matrices [12] and the related access control lists and capabilities (see [6]) are a traditional means of specifying security permissions.
Reference: [12] <author> Lampson, B.W., </author> <title> Protection, </title> <booktitle> In Proceedings of the 5th Symposium on Information Sciences and Sys tems, </booktitle> <address> Princeton University, </address> <month> March </month> <year> 1971. </year>
Reference-contexts: This policy is shown in Figure 7. 5.1.3 Attribute-based ACM-type entries policies Policies of this type are restrictions for subjects regarding their access to objects. This is the type of restriction found in access control matrices (ACM) <ref> [12] </ref> and access control lists (see [6]). Individual restrictions are of a positive tense, indicating that that type of access is allowed or a negative tense, stating that the access is not allowed. Note that a particular positive subject-object-access ACM entry cannot be represented in LaSCO. <p> The constraint language for which a constraint checker was implemented for the language for Unix [11]. Unlike Mir, LaSCO states policies in terms of system execution (rather than a snapshot), can be applied to systems other than file systems, and has simpler semantics. Access matrices <ref> [12] </ref> and the related access control lists and capabilities (see [6]) are a traditional means of specifying security permissions.
Reference: [13] <author> Maimone, M.W., J.D. Tygar, and J.M. Wing, </author> <title> Mir Semantics for Security. </title> <booktitle> In Proceedings of the 1988 Workshop on Visual Languages, </booktitle> <month> Oct </month> <year> 1988. </year> <pages> pp. 45-51. </pages>
Reference-contexts: Mir consists of two languages, an instance language and a constraint language [10], both of which are based on Harels hierarchical graphs [9]. The instance languages formal semantics is defined in <ref> [13] </ref> and is peer to our system graph. It describes a file system access control matrix.
Reference: [14] <author> Miller, D.V. and R.W. Baldwin, </author> <title> Access control by Boolean Expression Evaluation. </title> <booktitle> In Proceedings Fifth Annual Computer Security Applications Conference. </booktitle> <address> Tucson, AZ, USA: </address> <publisher> IEEE Computer Soci ety Press, </publisher> <year> 1990. </year> <month> p.131-139. </month>
Reference-contexts: As we have shown in this paper, LaSCO can include historical context in its access control, and its policies can refer to an object of a particular type based its attributes and how the object relates to others in the policy. BEE <ref> [14] </ref> is an access control mechanism where decisions are based on the result of a boolean expression evaluation for an access right.
Reference: [15] <author> Sandhu, R.S., E.J. Coyne, H.L. Feinstein, and C.E. Youman, </author> <title> Role-based access control: a multi dimensional view. </title> <booktitle> In Proceedings of the 10th Annual Computer Security Applications Conference, </booktitle> <address> Orlando, FL, USA: </address> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: For example, Figure 10 depicts the restriction that if subject sam is accessing an object in category 4, then it must be a read. No other types of access is allowed in this case. 5.1.4 Role-based access control policies Role-based access control (RBAC) (see a review in Sandhu, et.al. <ref> [15] </ref>) is similar to access-matrix type restrictions discussed in Section 5.1.3. The major difference is in the subject. Whereas the subject in an ACM is a user, the subject in RBAC is one of a defined set of roles.
Reference: [16] <author> Sandhu, Ravi S., </author> <title> The Typed Access Matrix Model. </title> <booktitle> In Proceedings of the 1992 IEEE Symposium on Security and Privacy. </booktitle> <address> Oakland, CA, USA: </address> <publisher> IEEE Press, </publisher> <year> 1992. </year> <pages> p. 122-136. </pages>
Reference-contexts: While these are in a convenient form for making automated decisions regarding whether an access is authorized or not, their granularity is individual subjects and objects, which does not make them suitable for stating a policy that is less specific in where the policy applies. TAM <ref> [16] </ref> introduces safety properties into an access control matrix through the use of object typing and defined sets of operations to execute under different conditions.
Reference: [17] <author> Simon, Rich and Mary Ellen Zurko. </author> <title> Adage: An architecture for distributed authorization. </title> <type> Technical report, </type> <institution> Open Group Research Institute, </institution> <year> 1997. </year> <note> http://www.opengroup.org/www/adage/adage-arch draft/adage-arch-draft.ps </note>
Reference-contexts: However for this, it is not as clear how to implement the policies for, for example, an application and the patterns for when the policy matches do not seem to be as intuitive. The Adage architecture <ref> [17] </ref>, developed at the OSF Research Institute, focuses on creating and deploying security policies in a distributed environment. It also focuses on enabling the user to build policy from pieces that the user understands.
Reference: [18] <author> Woo, Thomas Y.C., Simon S. Lam, </author> <title> Authorization in Distributed Systems: A Formal Approach. </title> <booktitle> In Proceedings of the 1992 IEEE Symposium on Security and Privacy. </booktitle> <address> Oakland, CA, USA: </address> <publisher> IEEE Press, </publisher> <year> 1992. </year> <month> p.33-50. </month>
Reference-contexts: However, the approach is limited to expressing policies for agents in terms of what they the obliged, permitted, and forbidden from doing. An approach towards specifying authorizations for subjects over objects that is rather formal is presented in Woo and Lam <ref> [18] </ref>. Precise semantics, allowing for inconsistency and incompleteness in specification, and distributed specification for their logical language are present there.
Reference: [19] <author> Zhao, T.C. and Mark Overmars. </author> <title> Forms Library: A Graphical User Interface Toolkit for X. v.0.88.1. http://bragg.phys.uwm.edu/xforms/. February 1998. Security Policy Specification Using a Graphical Approach James A. </title> <note> Hoagland, </note> <author> Raju Pandey, and Karl N. </author> <note> Levitt hoagland@cs.ucdavis.edu UC Davis Computer Science Technical Report CSE-98-3 July 22, </note> <year> 1998 </year>
Reference-contexts: This will accept schema graphs, generic policies, and policies as input and will facilitate the development of policies for a schema. This will have graphical user interface for X-Windows and is being built using the Forms Library for X (XForms) <ref> [19] </ref>. Using the interface, the user can select aspects of the schema with which to instantiate a generic policy and to edit policies. The policy compiler will accept Java source programs and their schema graphs and the policies that should be enforced by the program.
References-found: 19

