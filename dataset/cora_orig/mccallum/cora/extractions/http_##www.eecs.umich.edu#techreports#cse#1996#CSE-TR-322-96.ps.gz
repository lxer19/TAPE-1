URL: http://www.eecs.umich.edu/techreports/cse/1996/CSE-TR-322-96.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse96.html
Root-URL: http://www.eecs.umich.edu
Title: Recursive Abstract State Machines  
Author: Yuri Gurevich and Marc Spielmann flfl 
Date: December 13, 1996  
Note: Preliminary version  
Abstract: According to the ASM thesis, any algorithm is essentially a Gurevich abstract state machine. The only objection to this thesis, at least in its sequential version, has been that ASMs do not capture recursion properly. To this end, we suggest recursive ASMs. 
Abstract-found: 1
Intro-found: 1
Reference: [Bor95] <author> E. Borger. </author> <title> Annotated bibliography on evolving algebras. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 37-51. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction The abstract state machine (or evolving algebra) thesis [Gur91] asserts that abstract state machines (ASMs, for brevity) express algorithms on their natural level of abstraction in a direct and coding-free manner. The thesis is supported by a wide spectrum of applications <ref> [Bor95] </ref>, [Cas], [Hug]. However, some people have objected that ASMs are iterative in their nature, whereas many algorithms (e.g., Divide and Conquer) are naturally recursive. In many cases recursion is concise, elegant, and inherent to the algorithm.
Reference: [Cas] <author> G. D. Castillo. </author> <note> WWW page Abstract State Machines, http://www.uni-paderborn.de/In-formatik/eas.html. </note>
Reference-contexts: 1 Introduction The abstract state machine (or evolving algebra) thesis [Gur91] asserts that abstract state machines (ASMs, for brevity) express algorithms on their natural level of abstraction in a direct and coding-free manner. The thesis is supported by a wide spectrum of applications [Bor95], <ref> [Cas] </ref>, [Hug]. However, some people have objected that ASMs are iterative in their nature, whereas many algorithms (e.g., Divide and Conquer) are naturally recursive. In many cases recursion is concise, elegant, and inherent to the algorithm.
Reference: [Gur91] <author> Y. Gurevich. </author> <title> Evolving Algebras: An attempt to discover semantics. </title> <journal> Bulletin of the EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year> <note> a slightly revised version in G. </note> <editor> Rozenberg and A. Salomaa, editors, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pages 266-292, </pages> <publisher> World Scientific, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction The abstract state machine (or evolving algebra) thesis <ref> [Gur91] </ref> asserts that abstract state machines (ASMs, for brevity) express algorithms on their natural level of abstraction in a direct and coding-free manner. The thesis is supported by a wide spectrum of applications [Bor95], [Cas], [Hug].
Reference: [Gur95] <author> Y. Gurevich. </author> <title> Evolving Algebras 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Building upon this idea, we suggest a definition of recursive ASMs. The implicit use of distributed computing has an important side benefit: it leads naturally to concurrent recursion. In addition, we reduce recursive ASMs to distributed ASMs as described in the Lipari guide <ref> [Gur95] </ref>. If desired, one can view recursive notation as mere abbreviation. The paper is organized as follows. <p> As a result, the model becomes non-deterministic. Finally, in Section 4 we restrict the general model of Section 3 so that global functions can be changed but determinism is ensured by sequential execution of recursive calls. Conventions The paper is based on the Lipari guide <ref> [Gur95] </ref> and uses some additional conventions. The executor of a one-agent ASM starts in an initial state with Mode = Initial and halts when Mode = Final . <p> In the case of slave agents, the Mode function is actually a unary function Mode (Me). (The distinction between master and slave agents is mostly didactic.) As usual, the semantics of distributed ASMs is given by the class of possible runs <ref> [Gur95] </ref>. Notice that in general this semantics is non-deterministic; different finite runs may lead to different final states.
Reference: [Hug] <author> J. K. Huggins. </author> <title> WWW page Evolving Algebras, </title> <address> http://www.eecs.umich.edu/ealgebras. </address>
Reference-contexts: 1 Introduction The abstract state machine (or evolving algebra) thesis [Gur91] asserts that abstract state machines (ASMs, for brevity) express algorithms on their natural level of abstraction in a direct and coding-free manner. The thesis is supported by a wide spectrum of applications [Bor95], [Cas], <ref> [Hug] </ref>. However, some people have objected that ASMs are iterative in their nature, whereas many algorithms (e.g., Divide and Conquer) are naturally recursive. In many cases recursion is concise, elegant, and inherent to the algorithm.
Reference: [Luc96] <author> E. </author> <title> Lucas. </title> <journal> Recreations mathematiques, </journal> <volume> volume 3, </volume> <pages> pages 55-59. </pages> <note> Gauthier-Villars et fils, Paris, 1891-1896. Reprinted by A. Blanchard, Paris, </note> <year> 1960. </year>
Reference-contexts: In this case a deterministic, sequential evaluation is ensured. Only one agent works, whereas all other agents wait in a hierarchical dependency. Example 4.1 (The Towers of Hanoi). The well-known Towers of Hanoi problem <ref> [Luc96] </ref> is purely sequential: our task is to instruct the player how to move a pile of disks of increasing size from one peg to another using at most 3 pegs in such a way that at no point a larger disk rests 12 on a smaller one.
Reference: [Sav70] <author> W. J. Savitch. </author> <title> Relational between nondeterministic and deterministic tape complexity. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 4 </volume> <pages> 177-192, </pages> <year> 1970. </year> <month> 14 </month>
Reference-contexts: To prove Pspace = NPspace, Walter Savitch has suggested the following recursive algorithm for the REACHABILITY decision problem, which works in space log 2 (GraphSize). Some familiarity with Savitch's solution is helpful <ref> [Sav70] </ref>. (We assume that the input is an ordered graph with constants FirstNode and LastNode and a unary node successor function Succ): if Mode = Initial then Output := Reach (StartNode; GoalNode; log (GraphSize)) Mode := Final endif rec Reach (From; To : node; l : int) : bool if Mode
References-found: 7

