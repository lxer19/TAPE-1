URL: ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/RENDER/i3d97.ps.gz
Refering-URL: http://www.cs.unc.edu/~geom/RENDER/surfacepapers.html
Root-URL: http://www.cs.unc.edu
Title: Accelerated Walkthrough of Large Spline Models  
Author: Subodh Kumar Dinesh Manocha Hansong Zhang Kenneth Hoff 
Keyword: Computer Graphics, Image Generation, NURBS Surface display, Performance, Algorithms  
Address: N. Carolina  
Affiliation: Johns Hopkins University University of  
Abstract: Spline surfaces are routinely used to represent large-scale models for CAD and animation applications. In this paper, we present algorithms for interactive walkthrough of complex NURBS models composed of tens of thousands of patches on current graphics systems. Given a spline model, the algorithm precomputes simplification of a collection of patches and represents them hierarchically. Given a changing viewpoint, the algorithm combines these simplifications with dynamic tessellations to generate appropriate levels of detail. We also propose a system pipeline for parallel implementation on multi-processor configurations. Different components, such as visibility and dynamic tessellation, are divided into independent threads. We describe an implementation of our algorithm and report its performance on an SGI Onyx with RealityEngine 2 graphics accelerator and using three R4400 processors. It is able to render models composed of almost than 40; 000 Bezier patches at 7 15 frames a second, almost an order of magnitude faster than previously known algorithms and implementations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics, </booktitle> <pages> pages 385-397, </pages> <year> 1991. </year>
Reference-contexts: For efficient display, we decompose each NURBS surface into a collection of Bezier patches using knot insertion [8]. A tensor product rational Bezier patch, F (u; v), of degree mfin, defined for D = ufiv; (u; v) 2 <ref> [0; 1] </ref>fi [0; 1], is specified by a mesh of control points, p ij ; and their weights, w ij ; 0 i m; 0 j n: m X n X w ij p ij B i (u)B j (v) i=0 j=0 i (u)B n where the Bernstein function B is <p> For efficient display, we decompose each NURBS surface into a collection of Bezier patches using knot insertion [8]. A tensor product rational Bezier patch, F (u; v), of degree mfin, defined for D = ufiv; (u; v) 2 <ref> [0; 1] </ref>fi [0; 1], is specified by a mesh of control points, p ij ; and their weights, w ij ; 0 i m; 0 j n: m X n X w ij p ij B i (u)B j (v) i=0 j=0 i (u)B n where the Bernstein function B is given by <p> A rational Bezier curve f (t), of degree n, defined for parameter t 2 <ref> [0; 1] </ref>, is specified by a sequence of control points, p k ; and their weights, w k ; 0 k n: f (t) = k=0 n n X w k B k (t) The basic thrust of our approach is to combine dynamic tessellation of surfaces, for high detail, with <p> However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces. <p> In particular Kumar et al. [19] present a dynamic load balancing technique for surface tessellation with negligible overhead. We augment their technique with modified pipeline described in Section 5. 2.2 Dynamic Tessellation Previous algorithms for interactive display <ref> [1, 26] </ref> spend considerable time in computing appropriate view-dependent tessellation bounds and polygonal triangulations. The incremental algorithm in [18, 21] overcome these problems using a combination of off-line and on-line bound computations and incremental triangulations. Their algorithm, in brief, is as follows: 1. Determine visibility.
Reference: [2] <author> C.L. Bajaj. </author> <title> Rational hypersurface display. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(2) </volume> <pages> 117-127, </pages> <year> 1990. </year> <title> (Symposium on Interactive 3D Graphics). </title>
Reference-contexts: However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces.
Reference: [3] <author> J. F. </author> <title> Blinn. Computer Display of Curved Surfaces. </title> <type> Ph.d. thesis, </type> <institution> University of Utah, </institution> <year> 1978. </year>
Reference-contexts: A number of surface rendering techniques are based on ray tracing [14, 25, 31], scan-line generation <ref> [3, 22, 30] </ref>, and pixel level subdivision [4, 28, 27]. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice.
Reference: [4] <author> E. Catmull. </author> <title> A Subdivision Algorithm for Computer Display of Curved Surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: A number of surface rendering techniques are based on ray tracing [14, 25, 31], scan-line generation [3, 22, 30], and pixel level subdivision <ref> [4, 28, 27] </ref>. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed [5, 17, 9, 26, 2, 10, 1, 23, 16].
Reference: [5] <author> J. H. Clark. </author> <title> A fast algorithm for rendering parametric surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 13(2) </volume> <pages> 289-299, </pages> <year> 1979. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces.
Reference: [6] <author> J. Cohen, A. Varshney, D. Manocha, and G. Turk et al. </author> <title> Simplification envelopes. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 119-128, </pages> <year> 1996. </year>
Reference-contexts: Unfortunately, the patch based rendering algorithms produce at least two triangles even for such patches resulting, at times, in triangle proliferation. Simplifying the spline models could ameliorate this problem. A number of techniques have been proposed to simplify polygonal models. Some topology preserving techniques include <ref> [6, 7] </ref>. However, they do not generalize to spline surfaces directly. It is not straightforward to devise a technique that: 1. simplifies splines while preserving topology and guar anteeing small error, and 2. results in a drastic simplification of models. <p> We eliminate this bottleneck by de-coupling this stage from the pipeline. We take advantage of the multiple processors to allow such processing to occur in the "background". 2.3 Simplification Envelopes In order to perform polygonal simplification of polygonal surfaces we employ the technique of Simplification envelopes <ref> [6, 29] </ref>. In brief, for a given *, it guarantees that the resulting simplification is at most * distant from the original surface: 1. For a given surface, generate two offset surfaces, one on either side, each at most * distant from it. 2. <p> Stop if no more vertices can be removed. Each of our super-surfaces is C 0 continuous and contain borders. For each border we construct the border-tubes described by Cohen et al. <ref> [6] </ref> to facilitate crack-prevention. In addition, the properties of super-surfaces allow us to obtain high vertex reduction. 3 Super-surfaces We assume that the input model is a collection of trimmed Bezier patches. <p> Our clustering algorithm partitions an input model into super-surfaces based on surface normals and patch adjacency. A super-surface corresponds to a C 0 continuous mesh of Bezier patches. Furthermore, our algorithm ensures that the variation in normals along the surface boundary is bounded. While algorithm of Cohen et al. <ref> [6] </ref> still guarantees bounded error for surfaces with high curvature and sharp edges, it is not able to remove many vertices for such surfaces. Using pseudo-Gauss maps [21], we are able to ensure that a super-surface is does not have much variation in curvature. <p> Our construction algorithm ensures that each super surface is relatively flat and has low variance in normals and curvature. As a result, the offset envelope approach is able to simplify the models by 30 80%. 4.2 Super-surface Boundary In the terminology of <ref> [6] </ref>, our super-surfaces are surfaces with borders, as opposed to closed surfaces. In order to ensure that the approximation to the border also has a small error, we simplify each border first and then simplify the interior without removing any more vertices from the border. <p> For an approximation b * with high curvature o * may self intersect. We delete such loops from o * , and mark the vertex of the loop (see Figure 7). Note that the semantics of this offset curve is different from that in <ref> [6] </ref>. Their algorithm generates offsets closer to the curve in such cases. While we can use their definition, our technique allows us to make the following claim (see Appendix for the proof): Theorem 1 o * 2 and b * 1 do not intersect, if * 1 * 2 . <p> For each visible leaf node, corresponding to a super-surface with n Bezier patches, our algorithm computes a crack-free tessellation. First, each boundary curve is approximated. The algorithm uses oriented bounding box of each curve to determine its * value <ref> [6] </ref>. This ensures that the same approximation of the curve is used for boundary strip on both its sides, thus preventing cracks. The interior tessellation uses the bounding box of the entire super-surface. <p> Typically, we only computing four or five discrete levels for each super-surface. The additional memory needed is a linear function (with a very small constant) of the number of patches. 7 Conclusion By effectively combining two successful techniques of simplification envelopes <ref> [6] </ref> and incremental dynamic tessellation [18], we have been able to obtain significant simplifications of large spline models while maintaining high detail where necessary.
Reference: [7] <author> M. Eck, T. DeRose, T. Duchamp, H. Hoppe, M. Louns-bery, and W. Stuetzle. </author> <title> Multiresolution analysis of arbitrary meshes. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 173-182, </pages> <year> 1995. </year>
Reference-contexts: Unfortunately, the patch based rendering algorithms produce at least two triangles even for such patches resulting, at times, in triangle proliferation. Simplifying the spline models could ameliorate this problem. A number of techniques have been proposed to simplify polygonal models. Some topology preserving techniques include <ref> [6, 7] </ref>. However, they do not generalize to spline surfaces directly. It is not straightforward to devise a technique that: 1. simplifies splines while preserving topology and guar anteeing small error, and 2. results in a drastic simplification of models.
Reference: [8] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1993. </year>
Reference-contexts: Indeed, Bezier and NURBS surfaces are among the most popular modeling tools for computer aided design. For efficient display, we decompose each NURBS surface into a collection of Bezier patches using knot insertion <ref> [8] </ref>.
Reference: [9] <author> D. Filip, R. Magedson, and R. Markot. </author> <title> Surface algorithms using bounds on derivatives. </title> <booktitle> Computer Aided Geometric Design, </booktitle> <volume> 3(4) </volume> <pages> 295-311, </pages> <year> 1986. </year>
Reference-contexts: However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces. <p> For each triangle, it computes the maximum deviation between each triangle and the surface using bounds on derivatives <ref> [9] </ref>.
Reference: [10] <author> D.R. Forsey and V. Klassen. </author> <title> An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces. </title> <booktitle> In Proceedings of Graphics Interface, </booktitle> <pages> pages 1-8, </pages> <year> 1990. </year>
Reference-contexts: However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces.
Reference: [11] <author> Y. Hazony. </author> <title> Algorithms for parallel processing: Curve and surface definition with Q-splines. </title> <journal> Computers & Graphics, </journal> <volume> 4(3-4):165-176, </volume> <year> 1979. </year>
Reference-contexts: In addition to reducing the number of triangles sent to the triangle rendering pipeline, we also present techniques to efficiently map the walkthrough application onto multiple processors on a shared memory architecture. A number of parallelization techniques are known in the literature <ref> [11, 12, 15, 19] </ref>. In particular Kumar et al. [19] present a dynamic load balancing technique for surface tessellation with negligible overhead.
Reference: [12] <author> B. Hendrickson and R. Leland. </author> <title> A multilevel algorithm for partitioning graphs. </title> <booktitle> Proc. Supercomputing '95, </booktitle> <year> 1995. </year>
Reference-contexts: In addition to reducing the number of triangles sent to the triangle rendering pipeline, we also present techniques to efficiently map the walkthrough application onto multiple processors on a shared memory architecture. A number of parallelization techniques are known in the literature <ref> [11, 12, 15, 19] </ref>. In particular Kumar et al. [19] present a dynamic load balancing technique for surface tessellation with negligible overhead.
Reference: [13] <author> H. Hoppe. </author> <title> Progressive meshes. </title> <booktitle> In Proceedings of ACM SIGGRAPH, </booktitle> <pages> pages 99-108, </pages> <year> 1996. </year>
Reference: [14] <author> J. Kajiya. </author> <title> Ray tracing parametric patches. </title> <journal> ACM Computer Graphics, </journal> <volume> 16(3) </volume> <pages> 245-254, </pages> <year> 1982. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: This affords us better control on allocation of detail for large models, but requires extra processing for seamless integration of parts. 2.1 Related Work There is considerable literature on rendering splines, polygon simplification and parallel rendering algorithms. A number of surface rendering techniques are based on ray tracing <ref> [14, 25, 31] </ref>, scan-line generation [3, 22, 30], and pixel level subdivision [4, 28, 27]. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice.
Reference: [15] <author> G. Karypis and V. Kumar. </author> <title> Multilevel k-way partitioning scheme for irregular graphs. </title> <type> Technical Report TR95-064, </type> <institution> Department of Computer Science, University of Minnesota, </institution> <year> 1995. </year>
Reference-contexts: In addition to reducing the number of triangles sent to the triangle rendering pipeline, we also present techniques to efficiently map the walkthrough application onto multiple processors on a shared memory architecture. A number of parallelization techniques are known in the literature <ref> [11, 12, 15, 19] </ref>. In particular Kumar et al. [19] present a dynamic load balancing technique for surface tessellation with negligible overhead.
Reference: [16] <author> R. Klein and W. Straber. </author> <title> Large mesh generation from boundary models with parametric face representation. </title> <booktitle> In Proc. of ACM SIGGRAPH Symposium on Solid Modeling, </booktitle> <pages> pages 431-440, </pages> <year> 1995. </year>
Reference-contexts: However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces.
Reference: [17] <author> P.A. Koparkar and S. P. Mudur. </author> <title> A new class of algorithms for the processing of parametric curves. </title> <booktitle> Computer-Aided Design, </booktitle> <volume> 15(1) </volume> <pages> 41-45, </pages> <year> 1983. </year>
Reference-contexts: However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces.
Reference: [18] <author> S. Kumar. </author> <title> Interactive Display of Parametric Spline Surfaces. </title> <type> PhD thesis, </type> <institution> University of North Carolina, </institution> <year> 1996. </year>
Reference-contexts: Unfortunately such polygonal approximations require an unduly large number of polygons, thus necessitating the need for polygon simplification. What is more, due to discretization of geometry, even a dense tessellation is sometimes inadequate for zoomed up views. On the other hand, recent advances <ref> [18, 21, 26] </ref> in efficient tessellation of surfaces now allow us to dynamically generate an appropriate number of triangles from the analytic representation based in the user's location in a virtual environment. <p> In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed [5, 17, 9, 26, 2, 10, 1, 23, 16]. Uniform subdivision, in general, is more efficient <ref> [18] </ref>. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces. A variant of [26]'s algorithm has been implemented in SGI GL and OpenGL libraries. <p> In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed [5, 17, 9, 26, 2, 10, 1, 23, 16]. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. <ref> [18, 21] </ref> have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces. A variant of [26]'s algorithm has been implemented in SGI GL and OpenGL libraries. It can display models composed of a few hundred patches at interactive frame rates on an SGI Onyx with RealityEngine 2 . <p> A variant of [26]'s algorithm has been implemented in SGI GL and OpenGL libraries. It can display models composed of a few hundred patches at interactive frame rates on an SGI Onyx with RealityEngine 2 . Kumar et al. <ref> [18, 21] </ref> proposed a faster algorithm that includes back-patch visibility, improved bounds for polygonization and incremental triangulation exploiting frame-to-frame coherence. The resulting pipeline is shown in Figure 1. <p> We augment their technique with modified pipeline described in Section 5. 2.2 Dynamic Tessellation Previous algorithms for interactive display [1, 26] spend considerable time in computing appropriate view-dependent tessellation bounds and polygonal triangulations. The incremental algorithm in <ref> [18, 21] </ref> overcome these problems using a combination of off-line and on-line bound computations and incremental triangulations. Their algorithm, in brief, is as follows: 1. Determine visibility. This includes computation of both view-frustum visibility and back-patch visibility [20]. 2. <p> Stages III and IV are parts of the triangle rendering subsystem. We implemented this pipeline and discovered that approximately half the polygon generation time is spent in step size determination in stage II <ref> [18] </ref>. This number is relatively high; the computational cost of incremental triangulation and tessellation is low due to frame-to-frame coherence. As we apply the algorithm to large models, this becomes a significant bottleneck in the overall pipeline. We employ a spatial hierarchy to solve this problem. <p> v)k 8 2 2 where M 1 = max kF uu (u; v)k; (u;v)2T and M 3 = max kF vv (u; v)k; We can reduce the computations of M 1 , M 2 and M 3 to finding zeros of polynomials and solve them using techniques from elimination theory <ref> [24, 18] </ref>. Thus all local extrema of the deviation function are obtained. Each triangle that we generate corresponds to a triangle D in the domain of the patch. We denote by Dev (), its maximum deviation from the part of the surface it approximates. <p> Every super-surface is tessellated into triangles as a function of the viewpoint by thread T (corresponding to dynamic tessellator). The visibility computations are performed by thread V (on visibility processor). We use a greedy rendering strategy <ref> [18] </ref> and use thread P , the triangle pusher, to pass the current approximation of each super-surface down to the triangle rendering pipeline. A thread may be allocated to more than one processors. <p> Typically, we only computing four or five discrete levels for each super-surface. The additional memory needed is a linear function (with a very small constant) of the number of patches. 7 Conclusion By effectively combining two successful techniques of simplification envelopes [6] and incremental dynamic tessellation <ref> [18] </ref>, we have been able to obtain significant simplifications of large spline models while maintaining high detail where necessary.
Reference: [19] <author> S. Kumar, C. Chang, and D. Manocha. </author> <title> Scalable algorithms for interactive visualization of curved surfaces. </title> <booktitle> In Supercomputing, </booktitle> <address> Pittsburgh, PA, </address> <year> 1996. </year>
Reference-contexts: In addition to reducing the number of triangles sent to the triangle rendering pipeline, we also present techniques to efficiently map the walkthrough application onto multiple processors on a shared memory architecture. A number of parallelization techniques are known in the literature <ref> [11, 12, 15, 19] </ref>. In particular Kumar et al. [19] present a dynamic load balancing technique for surface tessellation with negligible overhead. <p> A number of parallelization techniques are known in the literature [11, 12, 15, 19]. In particular Kumar et al. <ref> [19] </ref> present a dynamic load balancing technique for surface tessellation with negligible overhead. We augment their technique with modified pipeline described in Section 5. 2.2 Dynamic Tessellation Previous algorithms for interactive display [1, 26] spend considerable time in computing appropriate view-dependent tessellation bounds and polygonal triangulations. <p> A thread may be allocated to more than one processors. If multiple processors are available for any thread, we use the lock-free dynamic load-balancing technique of Kumar et al. <ref> [19] </ref> to distribute super-surfaces to those processors. The basic idea of the load-balancing [19] algorithm may be described as follows: 1. Each processor, p, maintains a local work queue Q (p). 2. <p> A thread may be allocated to more than one processors. If multiple processors are available for any thread, we use the lock-free dynamic load-balancing technique of Kumar et al. <ref> [19] </ref> to distribute super-surfaces to those processors. The basic idea of the load-balancing [19] algorithm may be described as follows: 1. Each processor, p, maintains a local work queue Q (p). 2. The basic loop of processor p consists of deleting the next element from Q (p) and performing the correspond ing work. 3. <p> Unfortunately due to restrictions on concurrent access to the graphics hardware, we were limited in our implementation to allocating a single processor to thread P . Hence we decided to keep thread P simple, and chose the solution of Kumar et al. <ref> [19] </ref>: Let T generate two boundary strips B 1 and B 2 . B 1 is a triangulation that uses the new approximation of interior and the old approximation of the boundary curve. B 2 uses the new boundary and the new interior. <p> * Statically allocate the rest N c N p lists to the pro ducers in a round-robin manner. * Each producer adds elements to each of its associated lists in a round-robin fashion. * The ActivityList associated with a given consumer is its work-queue * The load-balancing algorithm mentioned above <ref> [19] </ref> ensures, equitable re-distribution of work among con sumers.
Reference: [20] <author> S. Kumar and D. Manocha. </author> <title> Hierarchical visibility culling for spline models. </title> <booktitle> In Proceedings of Graphics Interface, </booktitle> <pages> pages 142-150, </pages> <address> Toronto, Canada, </address> <year> 1996. </year>
Reference-contexts: The incremental algorithm in [18, 21] overcome these problems using a combination of off-line and on-line bound computations and incremental triangulations. Their algorithm, in brief, is as follows: 1. Determine visibility. This includes computation of both view-frustum visibility and back-patch visibility <ref> [20] </ref>. 2. For each Bezier patch, determine the number of uniform tessellation steps in the u and v dimensions, respectively, required for a smooth image from the current view point. Similarly, for each trimming curve, determine the number of steps. 3.
Reference: [21] <author> S. Kumar, D. Manocha, and A. Lastra. </author> <title> Interactive display of large scale NURBS models. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 51-58, </pages> <address> Monterey, CA, </address> <year> 1995. </year>
Reference-contexts: Unfortunately such polygonal approximations require an unduly large number of polygons, thus necessitating the need for polygon simplification. What is more, due to discretization of geometry, even a dense tessellation is sometimes inadequate for zoomed up views. On the other hand, recent advances <ref> [18, 21, 26] </ref> in efficient tessellation of surfaces now allow us to dynamically generate an appropriate number of triangles from the analytic representation based in the user's location in a virtual environment. <p> In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed [5, 17, 9, 26, 2, 10, 1, 23, 16]. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. <ref> [18, 21] </ref> have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces. A variant of [26]'s algorithm has been implemented in SGI GL and OpenGL libraries. It can display models composed of a few hundred patches at interactive frame rates on an SGI Onyx with RealityEngine 2 . <p> A variant of [26]'s algorithm has been implemented in SGI GL and OpenGL libraries. It can display models composed of a few hundred patches at interactive frame rates on an SGI Onyx with RealityEngine 2 . Kumar et al. <ref> [18, 21] </ref> proposed a faster algorithm that includes back-patch visibility, improved bounds for polygonization and incremental triangulation exploiting frame-to-frame coherence. The resulting pipeline is shown in Figure 1. <p> We augment their technique with modified pipeline described in Section 5. 2.2 Dynamic Tessellation Previous algorithms for interactive display [1, 26] spend considerable time in computing appropriate view-dependent tessellation bounds and polygonal triangulations. The incremental algorithm in <ref> [18, 21] </ref> overcome these problems using a combination of off-line and on-line bound computations and incremental triangulations. Their algorithm, in brief, is as follows: 1. Determine visibility. This includes computation of both view-frustum visibility and back-patch visibility [20]. 2. <p> At each subsequent frame, update the triangulation incrementally making small changes to the current tri angulation and taking advantage of coherence. 5. Send the updated triangles to the triangle rendering pipeline. This pipeline is represented schematically in Figure 1. <ref> [21] </ref> maps stages I and II on the host CPU of the system. Stages III and IV are parts of the triangle rendering subsystem. We implemented this pipeline and discovered that approximately half the polygon generation time is spent in step size determination in stage II [18]. <p> Furthermore, our algorithm ensures that the variation in normals along the surface boundary is bounded. While algorithm of Cohen et al. [6] still guarantees bounded error for surfaces with high curvature and sharp edges, it is not able to remove many vertices for such surfaces. Using pseudo-Gauss maps <ref> [21] </ref>, we are able to ensure that a super-surface is does not have much variation in curvature. We also make use of any natural structure or hierarchy of the input model to speed up the super-surface construction. <p> The decoupling of dynamic tessellation with visibility and rendering threads accounts for most of this speed-up and helps reduce the variation in the frame rate. Furthermore, the tessellation thread does not lag behind the rendering by more than 2 3 frames at most. * Model Simplification: The implementation of <ref> [21] </ref> based on dynamic tessellation (with no static levels of detail) renders this model at 1:4 frames a second (using only processor). As a result, our simplification algorithms accounts for 40 50% improvement in the overall frame rate.
Reference: [22] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn. Scan line methods for displaying parametrically defined surfaces. </title> <journal> Communications of ACM, </journal> <volume> 23(1) </volume> <pages> 23-34, </pages> <year> 1980. </year>
Reference-contexts: A number of surface rendering techniques are based on ray tracing [14, 25, 31], scan-line generation <ref> [3, 22, 30] </ref>, and pixel level subdivision [4, 28, 27]. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice.
Reference: [23] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed NURB surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces.
Reference: [24] <author> D. Manocha and J. Demmel. </author> <title> Algorithms for intersecting parametric and algebraic curves. </title> <booktitle> In Proceedings of Graphics Interface, </booktitle> <pages> pages 232-241, </pages> <year> 1992. </year>
Reference-contexts: v)k 8 2 2 where M 1 = max kF uu (u; v)k; (u;v)2T and M 3 = max kF vv (u; v)k; We can reduce the computations of M 1 , M 2 and M 3 to finding zeros of polynomials and solve them using techniques from elimination theory <ref> [24, 18] </ref>. Thus all local extrema of the deviation function are obtained. Each triangle that we generate corresponds to a triangle D in the domain of the patch. We denote by Dev (), its maximum deviation from the part of the surface it approximates.
Reference: [25] <author> T. Nishita, T.W. Sederberg, and M. Kakimoto. </author> <title> Ray tracing trimmed rational surface patches. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 337-345, </pages> <year> 1990. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: This affords us better control on allocation of detail for large models, but requires extra processing for seamless integration of parts. 2.1 Related Work There is considerable literature on rendering splines, polygon simplification and parallel rendering algorithms. A number of surface rendering techniques are based on ray tracing <ref> [14, 25, 31] </ref>, scan-line generation [3, 22, 30], and pixel level subdivision [4, 28, 27]. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice.
Reference: [26] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 107-117, </pages> <year> 1989. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Unfortunately such polygonal approximations require an unduly large number of polygons, thus necessitating the need for polygon simplification. What is more, due to discretization of geometry, even a dense tessellation is sometimes inadequate for zoomed up views. On the other hand, recent advances <ref> [18, 21, 26] </ref> in efficient tessellation of surfaces now allow us to dynamically generate an appropriate number of triangles from the analytic representation based in the user's location in a virtual environment. <p> However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed <ref> [5, 17, 9, 26, 2, 10, 1, 23, 16] </ref>. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. [26] and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces. <p> In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed [5, 17, 9, 26, 2, 10, 1, 23, 16]. Uniform subdivision, in general, is more efficient [18]. Recently Rockwood et al. <ref> [26] </ref> and Kumar et al. [18, 21] have proposed uniform subdivision based algorithms for interactive display of trimmed surfaces. A variant of [26]'s algorithm has been implemented in SGI GL and OpenGL libraries. <p> In particular Kumar et al. [19] present a dynamic load balancing technique for surface tessellation with negligible overhead. We augment their technique with modified pipeline described in Section 5. 2.2 Dynamic Tessellation Previous algorithms for interactive display <ref> [1, 26] </ref> spend considerable time in computing appropriate view-dependent tessellation bounds and polygonal triangulations. The incremental algorithm in [18, 21] overcome these problems using a combination of off-line and on-line bound computations and incremental triangulations. Their algorithm, in brief, is as follows: 1. Determine visibility.
Reference: [27] <author> M. Shantz and S. Chang. </author> <title> Rendering trimmed NURBS with adaptive forward differencing. </title> <journal> ACM Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 189-198, </pages> <year> 1988. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: A number of surface rendering techniques are based on ray tracing [14, 25, 31], scan-line generation [3, 22, 30], and pixel level subdivision <ref> [4, 28, 27] </ref>. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed [5, 17, 9, 26, 2, 10, 1, 23, 16].
Reference: [28] <author> M. Shantz and S. Lien. </author> <title> Shading bicubic patches. </title> <journal> ACM Computer Graphics, </journal> <volume> 21(4) </volume> <pages> 189-196, </pages> <year> 1987. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: A number of surface rendering techniques are based on ray tracing [14, 25, 31], scan-line generation [3, 22, 30], and pixel level subdivision <ref> [4, 28, 27] </ref>. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice. In particular, a number of algorithms based on uniform and adaptive subdivision have been proposed [5, 17, 9, 26, 2, 10, 1, 23, 16].
Reference: [29] <author> A. Varshney. </author> <title> Hierarchical Geometric Approximations. </title> <type> PhD thesis, </type> <institution> University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: We eliminate this bottleneck by de-coupling this stage from the pipeline. We take advantage of the multiple processors to allow such processing to occur in the "background". 2.3 Simplification Envelopes In order to perform polygonal simplification of polygonal surfaces we employ the technique of Simplification envelopes <ref> [6, 29] </ref>. In brief, for a given *, it guarantees that the resulting simplification is at most * distant from the original surface: 1. For a given surface, generate two offset surfaces, one on either side, each at most * distant from it. 2.
Reference: [30] <author> J.T. Whitted. </author> <title> A scan line algorithm for computer display of curved surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 12(3) </volume> <pages> 8-13, </pages> <year> 1978. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: A number of surface rendering techniques are based on ray tracing [14, 25, 31], scan-line generation <ref> [3, 22, 30] </ref>, and pixel level subdivision [4, 28, 27]. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice.
Reference: [31] <author> J.T. Whitted. </author> <title> An improved illumination model for shaded display. </title> <journal> ACM Computer Graphics, </journal> <volume> 13(3) </volume> <pages> 1-14, </pages> <year> 1979. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: This affords us better control on allocation of detail for large models, but requires extra processing for seamless integration of parts. 2.1 Related Work There is considerable literature on rendering splines, polygon simplification and parallel rendering algorithms. A number of surface rendering techniques are based on ray tracing <ref> [14, 25, 31] </ref>, scan-line generation [3, 22, 30], and pixel level subdivision [4, 28, 27]. However, due to recent advances in hardware based triangle rendering techniques, algorithms based on polygonal decomposition are much faster in practice.
References-found: 31

