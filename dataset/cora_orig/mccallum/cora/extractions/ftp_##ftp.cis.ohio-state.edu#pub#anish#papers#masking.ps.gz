URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/masking.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Title: Designing Masking Fault-tolerance via Nonmasking Fault-tolerance  
Author: Anish Arora Sandeep S. Kulkarni 
Keyword: masking and nonmasking fault-tolerance, component based design, correc tors, detectors, stepwise design formal methods, distributed systems  
Abstract: We present in this paper a component based method for the design of masking fault-tolerant programs. In this method, components are added to a fault-intolerant program in a stepwise manner, first, to transform a fault-intolerant program into a nonmask-ing fault-tolerant one and, then, to enhance the fault-tolerance from nonmasking to masking. We illustrate the method by designing programs for agreement in the presence of Byzantine faults, data transfer in the presence of message loss, triple modulo redundancy in the presence of input corruption, and mutual exclusion in the presence of process fail-stops. These examples also serve to demonstrate that the method accommodates a variety of fault-classes, it provides alternative designs for programs usually designed with extant design methods, and it offers the potential for improved masking fault-tolerant programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bastani, I.-L Yen, and I. Chen. </author> <title> A class of inherently fault-tolerant diffusing programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14 </volume> <pages> 1432-1442, </pages> <year> 1988. </year>
Reference: [2] <author> P. Jalote. </author> <title> Fault-tolerance in Distributed Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference: [3] <author> B. Randell. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions on Software Engg., </journal> <pages> pages 220-232, </pages> <year> 1975. </year>
Reference: [4] <author> J.-C. Laprie. </author> <title> Dependable computing and fault tolerance: Concepts and terminology. </title> <booktitle> Proceedings of the 15th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 2-11, </pages> <year> 1985. </year>
Reference: [5] <author> A. Arora and M. G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, 1993. 
Reference-contexts: Finally, we compare our method with extant methods for designing masking fault-tolerant programs and make concluding remarks in Section 6. 2 Programs, Faults, and Masking and Nonmasking Tolerances In this section, we recall formal definitions of masking and nonmasking fault-tolerance of programs <ref> [5] </ref>, in order to characterize a relationship between these two tolerance types and to motivate our design method, which is presented in Section 3. Programs. A program p is defined recursively to consist of a (possibly empty) program q, a set of "superposition variables", and a set of "superposition actions". <p> However, these states satisfy fault-span of p, say T . Moreover, every state in S also satisfies T . Fault-Tolerance: Masking and Nonmasking. We are now ready to give a formal definition of fault-tolerance <ref> [5] </ref>. Instantiations of this definition yield definitions of masking and nonmasking fault-tolerance. Let p be a program, F be a set of fault actions, and S be an invariant of p. <p> The design of such multitolerant programs is motivated by the insight that the fault-span of a program need not be unique <ref> [5] </ref>. Hence, multiple fault-spans may be associated with a program, for instance, if the program is subject to multiple fault-classes. It follows that the program can be nonmasking tolerant to one of these fault-classes and masking tolerant to another. More generally, we find that multitolerance has several practical applications [12].
Reference: [6] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Note that, since statements of p do not update the variables of q, the only actions of p that update the variables of q are the actions of q. Thus, programs are designed by superposition of variables and actions on underlying programs <ref> [6] </ref>. Superposition actions may access, but not update, the underlying variables, whereas underlying actions may not access or update the superposition variables.
Reference: [7] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> 7 October </month> <year> 1985. </year>
Reference-contexts: Informally, the invariant of a program includes the states reached in the fault-free execution of p. Note that p may have multiple invariants. Informally, the problem specification of p consists of a safety specification and a liveness specification <ref> [7] </ref>. A safety specification identifies a set of "bad" finite computation prefixes that should not appear 3 in any program computation. Dually, a liveness specification identifies a set of "good" computation suffixes such that every computation has a suffix that is in this set. <p> Hence, a program computation satisfies the problem specification iff it satisfies the safety specification and the liveness specification in that specification. (Remark: Our definition of liveness is stronger than Alpern and Schneider's definition <ref> [7] </ref>: the two definitions become identical if the liveness specification is fusion closed; i.e., if computations hff; x; fli and hfi; x; ffii satisfy the liveness specification then computations hff; x; ffii and hfi; x; fli also satisfy the liveness specification, where ff; fi are finite computation prefixes, fl; ffi are
Reference: [8] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: the liveness specification then computations hff; x; ffii and hfi; x; fli also satisfy the liveness specification, where ff; fi are finite computation prefixes, fl; ffi are computation suffixes, and x is a program state.) Techniques for the design of an invariant of the program have been articulated by Dijkstra <ref> [8] </ref>, using the notion of auxiliary variables, and by Gries [9], using the heuristics of state predicate ballooning and shrinking. Techniques for the mechanical calculation of an invariant predicate have been discussed by Alpern and Schneider [10]. Convergence.
Reference: [9] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: x; fli also satisfy the liveness specification, where ff; fi are finite computation prefixes, fl; ffi are computation suffixes, and x is a program state.) Techniques for the design of an invariant of the program have been articulated by Dijkstra [8], using the notion of auxiliary variables, and by Gries <ref> [9] </ref>, using the heuristics of state predicate ballooning and shrinking. Techniques for the mechanical calculation of an invariant predicate have been discussed by Alpern and Schneider [10]. Convergence.
Reference: [10] <author> B. Alpern and F. Schneider. </author> <title> Proving boolean combinations of deterministic properties. </title> <booktitle> Proceedings of the Second Symposium on Logic in Computer Scien ce, </booktitle> <pages> pages 131-137, </pages> <year> 1987. </year>
Reference-contexts: Techniques for the mechanical calculation of an invariant predicate have been discussed by Alpern and Schneider <ref> [10] </ref>. Convergence. A state predicate Q "converges to" R in p iff Q and R are closed in p and, starting from any state where Q holds, every computation of p has a state where R holds. Note that the converges-to relation is transitive. Lemma 2.1.
Reference: [11] <author> A. Arora, M. G. Gouda, and G. Varghese. </author> <title> Constraint satisfaction as a basis for designing nonmasking fault-tolerance. </title> <journal> Journal of High Speed Networks, </journal> <volume> 5(3) </volume> <pages> 293-306, </pages> <year> 1996. </year>
Reference-contexts: Specifically, a large corrector can be designed by parallel and/or sequential composition of small correctors. One simple parallel composition strategy is to superpose small correctors on others. An alternative composition strategy, due to Arora, Gouda, and Varghese <ref> [11] </ref>, is to order the small correctors in a linear manner (or, more generally, a well-founded manner) such that each corrector does not interfere with the recovery task of the correctors lower than it in the chosen ordering.
Reference: [12] <author> A. Arora and S. S. Kulkarni. </author> <title> Multitolerance and its design. </title> <type> Technical Report OSU-CISRC TR37, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <note> Submitted to IEEE Transactions on Software Engineering, Special Issue on Formal Methods. </note>
Reference-contexts: For a detailed discussion of corrector compositions, we refer the reader to <ref> [12] </ref>. 6 Stage 2. For a nonmasking program, say np, even though the problem specification is satisfied after computations of np converge to invariant states, the safety specification need not be satisfied in all computations of np that start at fault-span states. <p> For a discussion of alternative strategies for verifying interference freedom, we refer the reader to <ref> [12] </ref>. 4 Design Examples In this section, we demonstrate that our method is wellsuited for the design of classical examples of masking tolerance, which span a variety of fault-classes. <p> One useful extension of the method would be to design programs that are nonmasking tolerant to one fault-class and masking tolerant to another or, more generally, that possess multiple tolerance properties (see <ref> [12, 26, 25] </ref>). The design of such multitolerant programs is motivated by the insight that the fault-span of a program need not be unique [5]. Hence, multiple fault-spans may be associated with a program, for instance, if the program is subject to multiple fault-classes. <p> Hence, multiple fault-spans may be associated with a program, for instance, if the program is subject to multiple fault-classes. It follows that the program can be nonmasking tolerant to one of these fault-classes and masking tolerant to another. More generally, we find that multitolerance has several practical applications <ref> [12] </ref>. Another useful extension would be to augment the method to allow "tolerance refinement", i.e., to allow refinement of a tolerant program from an abstract level to a concrete level while preserving its tolerance property. <p> Finally, alternative design methods based on detector and corrector compositions would be worth studying. An alternative stepwise method would be to first perform detector composition and then perform corrector composition, which we view as designing masking tolerance via fail-safe tolerance <ref> [12] </ref>. Another alternative (but not stepwise) method would be to compose detectors and correctors simultaneously. It would be especially interesting to compare these methods with respect to design-complexity versus performance-complexity tradeoffs. Acknowledgments.
Reference: [13] <author> G. Tel. </author> <title> Structure of Distributed Algorithms. </title> <type> PhD thesis, </type> <institution> University of Utrecht; also published by Cambridge University Press, </institution> <year> 1989. </year>
Reference-contexts: In reactive programs, e.g. operating systems or plant controllers, only the actions that control progress while maintaining safety are critical. In the rich class of "total" programs for distributed systems <ref> [13] </ref>, e.g. distributed consensus, infima finding, garbage collection, global function computation, reset, routing, snapshot, and termination detection, only the "decider" actions that declare the outcome of the computation are critical.
Reference: [14] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1982. </year>
Reference-contexts: Faults corrupt processes permanently and undetectably such that the corrupted processes are Byzantine. It is wellknown that masking tolerant Byzantine agreement is possible iff there are at least 3f +1 processes, where f is the number of Byzantine processes <ref> [14] </ref>. For ease of exposition, we will restrict our attention to the case where the total number of processes (including g) is 4 and, hence, f is 1. As prescribed by our method, we will design the masking tolerant solution to the Byzantine agreement problem in two stages.
Reference: [15] <author> E. W. Dijkstra and C. S. Scholten. </author> <title> Predicate calculus and program semantics. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: If R:j is true, i.e., the predicate X:j is true for all processes, we omit R:j. Similarly, a formula (9j : R:j : X:j) may be read as there exists a process where both R:j and X:j are true. This notation is from <ref> [15] </ref> Fault Actions. The faults in this example make one process Byzantine, provided that no other process is Byzantine. As discussed in Section 2, these faults would be represented by the following fault action at each j : (8k :: :b:k) ! b:j := true Nonmasking tolerant Byzantine agreement.
Reference: [16] <author> K. Raymond. </author> <title> A tree based algorithm for mutual exclusion. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7 </volume> <pages> 61-77, </pages> <year> 1989. </year> <month> 28 </month>
Reference-contexts: To ensure that no process waits forever for the token, a fair strategy is chosen by which if any process requests access to its critical section then it eventually receives the token. An elegant token-based program is independently due to Raymond <ref> [16] </ref> and Snepscheut [17]; this program uses a fixed tree to circulate the token. The case study is organized as follows. In Section 5.1, we recall (an abstract version of) the intolerant mutual exclusion program of Raymond and Snepscheut. <p> One example of an improved masking tolerant solution designed using the method is our token-based mutual exclusion program. In terms of performance, in the absence of faults, our program performs exactly as its fault-intolerant version (due to Raymond <ref> [16] </ref> and Snepscheut [17]) and thus incurs no extra overhead in this case. By way of contrast, the acyclic-graph-based programs of Dhamdhere and Kulkarni [20] and Chang, Singhal, and Liu [21] incur time overhead for providing fault-tolerance, even in the absence of faults.
Reference: [17] <author> J. L. A. van de Snepscheut. </author> <title> Fair mutual exclusion on a graph of processes. </title> <journal> Distributed Computing, </journal> <volume> 2(2) </volume> <pages> 113-115, </pages> <year> 1987. </year>
Reference-contexts: To ensure that no process waits forever for the token, a fair strategy is chosen by which if any process requests access to its critical section then it eventually receives the token. An elegant token-based program is independently due to Raymond [16] and Snepscheut <ref> [17] </ref>; this program uses a fixed tree to circulate the token. The case study is organized as follows. In Section 5.1, we recall (an abstract version of) the intolerant mutual exclusion program of Raymond and Snepscheut. <p> One example of an improved masking tolerant solution designed using the method is our token-based mutual exclusion program. In terms of performance, in the absence of faults, our program performs exactly as its fault-intolerant version (due to Raymond [16] and Snepscheut <ref> [17] </ref>) and thus incurs no extra overhead in this case. By way of contrast, the acyclic-graph-based programs of Dhamdhere and Kulkarni [20] and Chang, Singhal, and Liu [21] incur time overhead for providing fault-tolerance, even in the absence of faults.
Reference: [18] <author> A. Arora. </author> <title> Efficient reconfiguration of trees: A case study in the methodical design of nonmask-ing fault-tolerance. </title> <booktitle> Proceedings of the Third International Symposium on Formal Techniques in Real Time and Fault-Tolerance, </booktitle> <year> 1994. </year>
Reference-contexts: in the presence of fail-stops eventually the parent tree is constructed, the holder relation is identical to the parent relation and, hence, the root process has the token. 5.2.1 Designing a Corrector N T for the parent Tree For a corrector that reconstructs the parent tree, we reuse Arora's program <ref> [18] </ref> for tree maintenance. This program allows faults to yield program states where there are multiple trees and unrooted trees. Continued execution of the program ensures convergence to a fixpoint state where there is exactly one rooted spanning tree.
Reference: [19] <author> Fred B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: illustrated the generality of the method, in terms of its ability to provide alternative designs for programs usually associated with other well-known design methods for masking fault-tolerance: Specifically, the TMR and Byzantine examples are usually associated with the method of replication or, more generally, the state-machine-approach for designing client-server programs <ref> [19] </ref>. The alternating-bit protocol example is usually associated with the method of exception handling or that of rollback-recovery |with the "timeout" action, M D5, being the exception-handler or recovery-procedure.
Reference: [20] <author> D. M. Dhamdhere and S. S. Kulkarni. </author> <title> A token based k resilient mutual exclusion algorithm for distributed systems. </title> <journal> Information Processing Letters, </journal> <volume> 50 </volume> <pages> 151-157, </pages> <year> 1994. </year>
Reference-contexts: In terms of performance, in the absence of faults, our program performs exactly as its fault-intolerant version (due to Raymond [16] and Snepscheut [17]) and thus incurs no extra overhead in this case. By way of contrast, the acyclic-graph-based programs of Dhamdhere and Kulkarni <ref> [20] </ref> and Chang, Singhal, and Liu [21] incur time overhead for providing fault-tolerance, even in the absence of faults. <p> Moreover, in terms of tolerance, our program is more tolerant than that of <ref> [20] </ref> (which is intolerant to the fail-stop of the process that holds the token), and [22] (which in the worst case is intolerant 26 to more than log n process fail-stops).
Reference: [21] <author> Y. I. Chang, M. Singhal, and M. T. Liu. </author> <title> A fault tolerant algorithm for distributed mutual exclusion. </title> <journal> IEEE Computer Society, </journal> <pages> pages 146-154, </pages> <year> 1990. </year>
Reference-contexts: By way of contrast, the acyclic-graph-based programs of Dhamdhere and Kulkarni [20] and Chang, Singhal, and Liu <ref> [21] </ref> incur time overhead for providing fault-tolerance, even in the absence of faults.
Reference: [22] <author> D. Agrawal and A. Abbadi. </author> <title> An efficient fault-tolerant solution for distributed mutual exclusion. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(1) </volume> <pages> 1-20, </pages> <year> 1991. </year>
Reference-contexts: By way of contrast, the acyclic-graph-based programs of Dhamdhere and Kulkarni [20] and Chang, Singhal, and Liu [21] incur time overhead for providing fault-tolerance, even in the absence of faults. Also, in the tree based program of Agrawal and Abbadi <ref> [22] </ref>, the amount of work performed for each critical section may increase when processes fail (especially when the failed processes are close to the tree root); in our program, failure of a process causes an overhead only during the convergence phase, but not after the program converges. <p> Moreover, in terms of tolerance, our program is more tolerant than that of [20] (which is intolerant to the fail-stop of the process that holds the token), and <ref> [22] </ref> (which in the worst case is intolerant 26 to more than log n process fail-stops). We note in passing that our mutual exclusion program can be systematically extended to tolerate process repairs as well as channel failures and repairs.
Reference: [23] <author> A. Arora and S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <booktitle> Proceedings of the Fourteenth Symposium on Reliable Distributed Systems, Bad Neuenahr, </booktitle> <volume> 14 </volume> <pages> 174-185, </pages> <year> 1995. </year>
Reference-contexts: Also, it can be systematically transformed so that processes cannot access the state of their neighbors atomically but only via asynchronous message passing. For other examples of improved solutions designed using the method, the interested reader is referred to our designs for leader election <ref> [23, 24] </ref>, termination detection [23, 24], and distributed reset [25]. We also note that although superposition was used for detector composition in each of our example designs, superposition is only one of the possible strategies for detector composition. <p> Also, it can be systematically transformed so that processes cannot access the state of their neighbors atomically but only via asynchronous message passing. For other examples of improved solutions designed using the method, the interested reader is referred to our designs for leader election <ref> [23, 24] </ref>, termination detection [23, 24], and distributed reset [25]. We also note that although superposition was used for detector composition in each of our example designs, superposition is only one of the possible strategies for detector composition.
Reference: [24] <author> A. Arora and S. S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <booktitle> ftp://ftp.cis.ohio-state.edu/pub/anish/papers/mask.ps.Z , 27 pages, </booktitle> <month> February </month> <year> 1995. </year>
Reference-contexts: Also, it can be systematically transformed so that processes cannot access the state of their neighbors atomically but only via asynchronous message passing. For other examples of improved solutions designed using the method, the interested reader is referred to our designs for leader election <ref> [23, 24] </ref>, termination detection [23, 24], and distributed reset [25]. We also note that although superposition was used for detector composition in each of our example designs, superposition is only one of the possible strategies for detector composition. <p> Also, it can be systematically transformed so that processes cannot access the state of their neighbors atomically but only via asynchronous message passing. For other examples of improved solutions designed using the method, the interested reader is referred to our designs for leader election <ref> [23, 24] </ref>, termination detection [23, 24], and distributed reset [25]. We also note that although superposition was used for detector composition in each of our example designs, superposition is only one of the possible strategies for detector composition.
Reference: [25] <author> S. S. Kulkarni and A. Arora. </author> <title> Multitolerance in distributed reset. </title> <type> Technical Report OSU-CISRC TR13, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <note> Submitted to Chicago Journal of Theoretical Computer Science, Special Issue on Self-Stabilization. </note>
Reference-contexts: For other examples of improved solutions designed using the method, the interested reader is referred to our designs for leader election [23, 24], termination detection [23, 24], and distributed reset <ref> [25] </ref>. We also note that although superposition was used for detector composition in each of our example designs, superposition is only one of the possible strategies for detector composition. <p> One useful extension of the method would be to design programs that are nonmasking tolerant to one fault-class and masking tolerant to another or, more generally, that possess multiple tolerance properties (see <ref> [12, 26, 25] </ref>). The design of such multitolerant programs is motivated by the insight that the fault-span of a program need not be unique [5]. Hence, multiple fault-spans may be associated with a program, for instance, if the program is subject to multiple fault-classes.
Reference: [26] <author> S. Kulkarni and A. Arora. </author> <title> Stepwise design of tolerances in barrier computations. </title> <type> Technical Report OSU-CISRC TR17, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <note> Submitted to Information Processing Letters. 29 </note>
Reference-contexts: One useful extension of the method would be to design programs that are nonmasking tolerant to one fault-class and masking tolerant to another or, more generally, that possess multiple tolerance properties (see <ref> [12, 26, 25] </ref>). The design of such multitolerant programs is motivated by the insight that the fault-span of a program need not be unique [5]. Hence, multiple fault-spans may be associated with a program, for instance, if the program is subject to multiple fault-classes.
References-found: 26

