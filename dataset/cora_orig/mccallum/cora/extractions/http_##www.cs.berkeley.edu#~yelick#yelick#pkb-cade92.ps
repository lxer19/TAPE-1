URL: http://www.cs.berkeley.edu/~yelick/yelick/pkb-cade92.ps
Refering-URL: http://www.cs.berkeley.edu/~yelick/papers.html
Root-URL: 
Title: A Parallel Completion Procedure for Term Rewriting Systems 1  
Author: Katherine A. Yelick Stephen J. Garland 
Affiliation: University of California at Berkeley MIT and The Hebrew University  
Abstract: We present a parallel completion procedure for term rewriting systems. Despite an extensive literature concerning the well-known sequential Knuth-Bendix completion procedure, little attention has been devoted to designing parallel completion procedures. Because naive parallelizations of sequential procedures lead to over-synchronization and poor performance, we employ a transition-based approach that enables more effective parallelizations. The approach begins with a formulation of the completion procedure as a set of transitions (in the style of Bachmair, Der-showitz, and Hsiang) and proceeds to a highly tuned parallel implementation that runs on a shared memory multiprocessor. The implementation performs well on a number of standard examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <type> Research Report 29, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1988. </year>
Reference-contexts: Note that there is no fairness requirement between any of the other actions. 2 The axioms in Figures 3 and 4 can be viewed as an implementation of Figure 1, and standard refinement mapping techniques <ref> [1] </ref> applied to prove correctness.
Reference: [2] <author> L. Bachmair, N. Dershowitz, and J. Hsiang. </author> <title> Orderings for equational proofs. </title> <booktitle> In Proceedings of the Symposium on Logic in Computer Science, </booktitle> <pages> pages 346-357. </pages> <publisher> IEEE, </publisher> <year> 1986. </year>
Reference-contexts: This paper is divided as follows. Section 2 defines the completion problem. Section 3 describes the issues that arise in finding good parallel solutions. Section 4 presents transition axioms for a completion procedure using the inference rules of Bachmair, Dershowitz, and Hsiang <ref> [2] </ref>. Section 5 transforms these axioms into ones suitable for parallel implementation. Section 6 describes the implementation. Section 7 describes its performance. Sections 8 and 9 describe related work and summarize our results. 2 The Completion Problem We assume a familiarity with the notions of terms and substitutions. <p> Completion procedures can be made failure resistant by allowing the reduction ordering to be enlarged in restricted ways [8]. Completion procedures can be made unfailing by leaving some equations unordered and restricting the application of rewrite rules <ref> [2] </ref>. Because these generalizations do not raise interesting new questions concerning parallelism, we do not consider them in this paper. 3 Design Issues for Parallel Completion Procedures The completion problem provides many opportunities for parallelism. At the same time, it presents many pitfalls. <p> reducing one another to trivial rules, i.e., to rules with identical left and right sides. 4 High-level Transition Axioms for Completion We base the design of our parallel completion procedure not on traditional sequential procedures, but on a reformulation of the original Knuth-Bendix procedure [13] by Bachmair, Dershowitz and Hsiang <ref> [2] </ref> as a set of nondeterministically-applied transition axioms. Figure 1 presents transition axioms for a completion procedure similar to the inference rules in [2]. The state consists of a set of equations E and a set of rewrite rules R. <p> the design of our parallel completion procedure not on traditional sequential procedures, but on a reformulation of the original Knuth-Bendix procedure [13] by Bachmair, Dershowitz and Hsiang <ref> [2] </ref> as a set of nondeterministically-applied transition axioms. Figure 1 presents transition axioms for a completion procedure similar to the inference rules in [2]. The state consists of a set of equations E and a set of rewrite rules R. Initially, E holds the user's input and R is empty. (Our formulation differs slightly from that in [2], which assumes that neither E nor R contains elements that differ only by renamings. <p> Figure 1 presents transition axioms for a completion procedure similar to the inference rules in <ref> [2] </ref>. The state consists of a set of equations E and a set of rewrite rules R. Initially, E holds the user's input and R is empty. (Our formulation differs slightly from that in [2], which assumes that neither E nor R contains elements that differ only by renamings. Such an assumption is difficult to implement.) The procedure stops if and when all guards are false, e.g., because the fail transition sets both E and R to ordering failure. <p> Using the age of rules is mentioned in <ref> [2] </ref>, and the validity of this solution was confirmed by Dershowitz [6]. Any procedure that performs a fair interleaving of these actions solves the completion problem. <p> The nondeterministic description of completion in terms of transition axioms given by Bachmair et al <ref> [2] </ref> is a good starting point for a parallel design, particularly because it avoids some of the unnecessary serialization inherent in parallelizing a conventional sequential program. But there is a large step between their description and the directly implementable transition axioms that describe our procedure.
Reference: [3] <author> B. </author> <title> Buchberger. History and basic features of the critical pair/completion procedure. </title> <journal> Journal of Symbolic Computation, </journal> 3(1&2):3-38, February/April 1987. 
Reference-contexts: 1 Introduction We describe a parallel completion procedure for term rewriting systems. A sequential completion procedure was formulated first by Knuth and Bendix [13]. Extensions, modifications, and applications to algebra, theorem proving, and data type induction are described by Buchberger <ref> [3] </ref> and Dershowitz [5]. Performance is an important factor that limits the applicability of completion procedures, and of term rewriting systems in general. We show how parallelism can lead to significantly better performance. Opportunities for parallelism abound, because completion is not inherently sequential. <p> A completion procedure that has been parallelized successfully is Buchberger's algorithm for computing Grobner Bases <ref> [3] </ref>. Like us, Ponder observed performance problems when using a straightforward parallelization of Buchberger's algorithm [18]. Vidal [22] redesigned the data structures and rearranged the top-level procedure to get superior speed-ups. His procedure does internormalization in a separate sequential phase.
Reference: [4] <author> N. Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 17 </volume> <pages> 279-301, </pages> <year> 1982. </year>
Reference-contexts: Solving the completion problem also involves establishing that a rewriting system is noetherian, which itself is an undecidable problem. The most common approach to proving that a system is noetherian is to use a reduction ordering on terms, i.e., a monotonic well-founded ordering that is stable under substitution <ref> [4] </ref>. If &gt; is a reduction ordering and l &gt; r for every rule l ! r in R, then R is noetherian. Completion procedures generally employ a fixed reduction ordering and halt with failure if this ordering is not powerful enough to orient some equations that arise during completion.
Reference: [5] <author> N. Dershowitz. </author> <title> Completion and its applications. </title> <editor> In H. Ait-Kaci and M. Nivat, editors, </editor> <title> Resolution of Equations in Algebraic Structures, </title> <booktitle> volume II: Rewriting Techniques, </booktitle> <pages> pages 31-86. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction We describe a parallel completion procedure for term rewriting systems. A sequential completion procedure was formulated first by Knuth and Bendix [13]. Extensions, modifications, and applications to algebra, theorem proving, and data type induction are described by Buchberger [3] and Dershowitz <ref> [5] </ref>. Performance is an important factor that limits the applicability of completion procedures, and of term rewriting systems in general. We show how parallelism can lead to significantly better performance. Opportunities for parallelism abound, because completion is not inherently sequential. But straightforward parallelizations of the Knuth-Bendix procedure perform poorly.
Reference: [6] <author> N. Dershowitz, </author> <year> 1990. </year> <title> Private communication. </title>
Reference-contexts: Using the age of rules is mentioned in [2], and the validity of this solution was confirmed by Dershowitz <ref> [6] </ref>. Any procedure that performs a fair interleaving of these actions solves the completion problem.
Reference: [7] <author> N. Dershowitz and N. Lindenstrauss. </author> <title> An abstract machine for concurrent term rewriting. </title> <booktitle> In Proceedings of the Second International Conference on Algebraic and Logic Programming, </booktitle> <address> Berlin. </address> <publisher> LNCS, </publisher> <month> October </month> <year> 1990. </year>
Reference-contexts: These performance results are encouraging. For the larger examples, performance continues to improve as processors are added. This does not guarantee scalability beyond a small number of processors, but neither does it provide evidence against scalability. 8 Related Work Dershowitz and Lindenstrauss <ref> [7] </ref> describe an abstract concurrent machine for rewriting a term by a set a rules, and they use it to compare various rewriting strategies. The parallelism in their model is very fine grained.
Reference: [8] <author> D. Detlefs and R. Forgaard. </author> <title> A procedure for automatically proving termination of a set of rewrite rules. </title> <booktitle> In Proceedings of the First International Conference on Rewriting Techniques and Applications, Dijon, France, </booktitle> <pages> pages 255-270. </pages> <note> LNCS 202, </note> <month> May </month> <year> 1985. </year>
Reference-contexts: Completion procedures typically differ on the set of inputs for which they fail, and their ability to resist failure is one of the qualities by which they are judged. Completion procedures can be made failure resistant by allowing the reduction ordering to be enlarged in restricted ways <ref> [8] </ref>. Completion procedures can be made unfailing by leaving some equations unordered and restricting the application of rewrite rules [2].
Reference: [9] <author> C. Dwork, P. C. Kanellakis, and J. C. Mitchell. </author> <title> On the sequential nature of unification. </title> <journal> Journal of Logic Programming, </journal> <volume> 1 </volume> <pages> 35-50, </pages> <month> June </month> <year> 1984. </year>
Reference: [10] <author> C. Dwork, P. C. Kanellakis, and L. Stockmeyer. </author> <title> Parallel algorithms for term matching. </title> <journal> SIAM Journal of Computing, </journal> <volume> 17(4) </volume> <pages> 711-731, </pages> <month> August </month> <year> 1988. </year>
Reference: [11] <author> S. J. Garland and J. V. Guttag. </author> <title> A guide to LP, the Larch Prover. </title> <type> Technical Report 82, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1991. </year>
Reference-contexts: This is quite different from our implementation, which emphasizes larger grained parallelism; it allows parallel rewriting during internormalization, but does not intentionally schedule multiple rewrites of the same term. Some sequential completion procedures <ref> [11, 14, 15] </ref> also divide the state into components, either to achieve better performance or to facilitate reasoning about correctness.
Reference: [12] <author> S. J. Garland, J. V. Guttag, and J. L. Horning. </author> <title> Debugging Larch Shared Language specifications. </title> <type> Technical Report 60, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1990. </year>
Reference-contexts: When processes are allowed to move, performance is significantly worse: the speed-ups with six processors were about 65% of those in Figure 5. Our parallel completion procedure is consistently faster, even when running on one processor, than the completion procedure provided by the Larch Prover <ref> [12] </ref>. While this comparison is somewhat unfair to the Larch Prover, which has more functionality, the comparison does show that our parallel implementation is fast enough to be of practical use. These performance results are encouraging. For the larger examples, performance continues to improve as processors are added.
Reference: [13] <author> D. E. Knuth and P. B. Bendix. </author> <title> Simple word problems in universal algebras. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pages 263-297. </pages> <address> Perga-mon, Oxford, </address> <year> 1970. </year>
Reference-contexts: 1 Introduction We describe a parallel completion procedure for term rewriting systems. A sequential completion procedure was formulated first by Knuth and Bendix <ref> [13] </ref>. Extensions, modifications, and applications to algebra, theorem proving, and data type induction are described by Buchberger [3] and Dershowitz [5]. Performance is an important factor that limits the applicability of completion procedures, and of term rewriting systems in general. We show how parallelism can lead to significantly better performance. <p> And because highly parallel processes can exhibit nondeterministic behavior, care must be taken to maintain correctness while optimizing performance. We explore these issues by discussing various ways to parallelize the sequential Knuth-Bendix completion procedure <ref> [13] </ref>. This procedure has two alternating phases: internormalization, which rewrites and eliminates equations and rules, and critical pairing, which creates new rules. <p> the names of their variables from reducing one another to trivial rules, i.e., to rules with identical left and right sides. 4 High-level Transition Axioms for Completion We base the design of our parallel completion procedure not on traditional sequential procedures, but on a reformulation of the original Knuth-Bendix procedure <ref> [13] </ref> by Bachmair, Dershowitz and Hsiang [2] as a set of nondeterministically-applied transition axioms. Figure 1 presents transition axioms for a completion procedure similar to the inference rules in [2]. The state consists of a set of equations E and a set of rewrite rules R.
Reference: [14] <author> P. Lescanne. </author> <title> Completion procedures as transition rules + control. </title> <booktitle> In TAPSOFT '89, </booktitle> <pages> pages 28-41. </pages> <note> LNCS 351, </note> <year> 1989. </year>
Reference-contexts: This is quite different from our implementation, which emphasizes larger grained parallelism; it allows parallel rewriting during internormalization, but does not intentionally schedule multiple rewrites of the same term. Some sequential completion procedures <ref> [11, 14, 15] </ref> also divide the state into components, either to achieve better performance or to facilitate reasoning about correctness.
Reference: [15] <author> P. Lescanne. Orme, </author> <title> an implementation of completion procedures as sets of transition rules. </title> <editor> In M. Stickel, editor, </editor> <booktitle> Proceedings of the 10th International Conference on Automated Deduction, </booktitle> <pages> pages 661-662. </pages> <note> LNCS 449, </note> <year> 1990. </year>
Reference-contexts: This is quite different from our implementation, which emphasizes larger grained parallelism; it allows parallel rewriting during internormalization, but does not intentionally schedule multiple rewrites of the same term. Some sequential completion procedures <ref> [11, 14, 15] </ref> also divide the state into components, either to achieve better performance or to facilitate reasoning about correctness.
Reference: [16] <author> U. Martin. </author> <title> Doing algebra with REVE. </title> <type> Technical report, </type> <institution> University of Manchester, </institution> <address> Manchester, England, </address> <year> 1986. </year>
Reference-contexts: Completing group56 produces a complete presentation of a group of order 56. The last example is due to Ursula Martin. The time required to complete group56 depends dramatically on the order in which critical pairs are computed, because one particular critical pair eliminates most of the other rules <ref> [16] </ref>.
Reference: [17] <author> G. E. Peterson and M. E. Stickel. </author> <title> Complete sets of reductions for some equational theories. </title> <journal> J. ACM, </journal> <volume> 28(2) </volume> <pages> 233-264, </pages> <month> Apr. </month> <year> 1981. </year>
Reference-contexts: Some generalizations allow function symbols in R that are not in E, requiring only that $ fl R be a conservative extension of $ fl E . Others include completion modulo equations (such as commutativity) <ref> [17] </ref>. Although these generalizations fall in the class addressed by our approach, we do not consider them in this paper. Solving the completion problem involves generating additional rules, if necessary, to ensure confluence. Such rules can be found using unification and critical-pairing.
Reference: [18] <author> C. Ponder. </author> <title> Evaluation of performance enhancements in algebraic manipulation systems. </title> <type> Technical Report UCB/CSD-88/438, </type> <institution> Computer Science Division, University of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1988. </year>
Reference-contexts: A completion procedure that has been parallelized successfully is Buchberger's algorithm for computing Grobner Bases [3]. Like us, Ponder observed performance problems when using a straightforward parallelization of Buchberger's algorithm <ref> [18] </ref>. Vidal [22] redesigned the data structures and rearranged the top-level procedure to get superior speed-ups. His procedure does internormalization in a separate sequential phase.
Reference: [19] <author> R. Ramesh and I. Ramakrishnan. </author> <title> Optimal speedups for parallel pattern matching in trees. </title> <booktitle> In Proceedings of the 2nd International Conference on Rewriting Techniques and Applications, Bordeaux, France, </booktitle> <pages> pages 274-285. </pages> <note> LNCS 256, </note> <month> May </month> <year> 1987. </year>
Reference: [20] <author> J. K. Slaney and E. W. Lusk. </author> <title> Parallelizing the closure computation in automated deduction. </title> <booktitle> In Proceedings of the 10th International Conference on Automated Deduction, </booktitle> <pages> pages 28-29. </pages> <note> LNCS 449, </note> <year> 1990. </year>
Reference-contexts: The data structures used for our state components differ from these, however, because they are concurrent and have more control information to allow for the additional executions that come from parallelism. Slaney and Lusk <ref> [20] </ref> describe a parallel closure computation, which divides the problem of completing R = fr 1 ; : : : ; r n g into tasks that compute critical pairs between r i and fr 1 ; : : : ; r i g, adding any results not subsumed by R
Reference: [21] <author> R. M. Verma and I. Ramakrishnan. </author> <title> Tight complexity bounds for term matching problems. </title> <booktitle> Information and Computation, </booktitle> <year> 1990. </year>
Reference: [22] <author> J.-P. Vidal. </author> <title> The computation of Grobner bases on shared memory multiprocessors. </title> <type> Technical Report CMU-CS-90-163, </type> <institution> School of Computer Science, Carnegie Mellon University, Pittsburg, </institution> <address> PA, </address> <year> 1990. </year>
Reference-contexts: A completion procedure that has been parallelized successfully is Buchberger's algorithm for computing Grobner Bases [3]. Like us, Ponder observed performance problems when using a straightforward parallelization of Buchberger's algorithm [18]. Vidal <ref> [22] </ref> redesigned the data structures and rearranged the top-level procedure to get superior speed-ups. His procedure does internormalization in a separate sequential phase.
Reference: [23] <author> K. A. Yelick. </author> <title> Using Abstraction in Explicitly Parallel Programs. </title> <type> PhD thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA 02139, </address> <month> December </month> <year> 1990. </year> <note> Also appeared as MIT/LCS/TR-507, </note> <month> July </month> <year> 1991. </year>
Reference-contexts: The situation is even worse without the pipeline, there being two synchronization points per iteration, one after internormalization and one after critical pairing. Unnecessary synchronization points are artifacts of basing parallel programs on sequential programs. Hence we use a different, transition-based approach <ref> [23] </ref> that allows parallelism both between and within critical pairing and internormalization. 3.3 Correctness Achieving performance while maintaining correctness requires care in choosing algorithms and data structures. <p> dequeued from RightRules will be used to compute critical pairs, and sequential implementations have demonstrated the practical importance of computing critical pairs between small rules before larger ones. 6 The Implementation A two-step implementation based on the transition axioms in Figures 3 and 4 follows the transition-based approach described in <ref> [23] </ref>. First, we implement each transition axiom by a transition procedure.
References-found: 23

