URL: http://csr.uvic.ca/~val/Publications/2edgeJune27.ps
Refering-URL: http://csr.uvic.ca/~val/val.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Fully Dynamic 2-Edge Connectivity Algorithm in Polylogarithmic Time per Operation  
Author: Monika Rauch Henzinger and Valerie King 
Note: Copyright c flDigital Equipment Corporation 1997. All rights reserved  
Web: http://www.research.digital.com/SRC/  
Address: 130 Lytton Avenue Palo Alto, California 94301  
Affiliation: Systems Research Center  
Date: 1997 004 June 27, 1997  
Pubnum: SRC Technical Note  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. Eppstein, Z. Galil, G. F. </author> <title> Italiano, Improved Sparsification, </title> <type> Tech. Report 93-20, </type> <institution> Department of Information and Computer Science, University of California, </institution> <address> Irvine, CA 92717. </address>
Reference-contexts: His data structure permitted 2-edge connectivity queries to be answered in O.log n/ time. In 1992, Eppstein et. al. <ref> [1, 2] </ref> improved the update time to O. p n/ using the sparsification technique. If only edge insertions are allowed, the Westbrook-Tarjan data structure [11] maintains the 2-edge connectivity in time O.ff.m; n// per insertion or query.
Reference: [2] <author> D. Eppstein, Z. Galil, G. F. Italiano, A. Nissenzweig, </author> <title> Sparsification ATechnique for Speeding up Dynamic Graph Algorithms Proc. </title> <booktitle> 33rd Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <month> 6069. </month>
Reference-contexts: His data structure permitted 2-edge connectivity queries to be answered in O.log n/ time. In 1992, Eppstein et. al. <ref> [1, 2] </ref> improved the update time to O. p n/ using the sparsification technique. If only edge insertions are allowed, the Westbrook-Tarjan data structure [11] maintains the 2-edge connectivity in time O.ff.m; n// per insertion or query.
Reference: [3] <author> S. Even and Y. Shiloach, </author> <title> An On-Line Edge-Deletion Problem, </title> <editor> J. </editor> <booktitle> ACM 28 (1981), </booktitle> <pages> 14. </pages>
Reference: [4] <author> G. N. Frederickson, </author> <title> Data Structures for On-line Updating of Minimum Spanning Trees, </title> <journal> SIAM J. Comput., </journal> <volume> 14 (1985), </volume> <pages> 781798. </pages>
Reference: [5] <author> G. N. Frederickson, </author> <title> Ambivalent Data Structures for Dynamic 2-edge-connectivity and k smallest spanning trees Proc. </title> <booktitle> 32nd Annual IEEE Symposium on Foundation of Comput. Sci., </booktitle> <year> 1991, </year> <month> 632641. </month>
Reference-contexts: In 1991 <ref> [5] </ref>, Fredrickson introduced a data structure known as topology trees for the fully dynamic 2-edge connectivity problem with a worst case cost of O. p m/ per update, where m is the number of edges in the graph at the time of the update. <p> A bridge is an edge of F that is not covered by nontree edge of G. Two nodes u and v are 2-edge connected iff all edges on .u; v/ are covered <ref> [5] </ref>. Throughout the algorithm, the nontree edges of G are partitioned into levels E 1 ; : : : ; E l , l D d2 log ne.
Reference: [6] <author> M. R. Henzinger and V. King. </author> <title> Randomized Dynamic Graph Algorithms with Polylogarithmic Time per Operation. </title> <booktitle> Proc. 27th ACM Symp. on Theory of Computing, </booktitle> <year> 1995, 519527. </year>
Reference-contexts: Then we delete the nontree edge e. (2) We do not keep a coverage count, but remember for each tree edge simply whether it is covered or not, i.e. a coverage bit. This requires a more complicated 1 A preliminary version of this result appeared in <ref> [6] </ref>. 1 routine for deleting nontree edges than when keeping coverage counts. However it has the advantage that the coverage bit of tree edges are not modified during a swap. Thus we reduced the problem of arbitrary edge deletions to the problem of maintaining the coverage bit. <p> The edges in the initial spanning forest F are weighted 0. When an edge is added to F , its weight is decreased to 0. An efficient data structure for maintaining a minimum spanning tree with a small number of weights can be found in <ref> [6, 7] </ref>. In addition, we keep for each nontree edge a pointer to where it is stored and for each tree edge, its level number and a pointer to its location in each data structure in which it appears. We keep the following invariant. Invariant: 1. <p> each edge which is deleted or inserted or whose weight is changed by a combination of these operations, the amortized expected update cost of the fully dynamic MST algorithm when there are k weights is O.k log 2 n/, so that the cost per deletion is O.log 3 n/ (see <ref> [6, 7] </ref>). To maintain L we use a dynamic tree D.F/ representing F. All edges in paths of L have labels naming the path it is in. 7 * add L.a; b/: adds to L the maximal subpaths of .a; b/ which are edge-disjoint from the other ele-ments of L. <p> This follows the technique used in the fully dynamic connectivity algorithm of <ref> [6] </ref>. Let F be a spanning forest of G. We define l, E i , and F i as in the deletions-only section. Initially, all nontree edges of G are put into E 1 and the other E i are empty.
Reference: [7] <author> M. R. Henzinger and M. </author> <title> Thorup. Improved Sampling with Applications to Dynamic Graph Algorithms. </title> <booktitle> To appear in Proc. 23rd International Colloquium on Automata, Languages, and Programming (ICALP), </booktitle> <publisher> Springer-Verlag 1996. </publisher>
Reference-contexts: The edges in the initial spanning forest F are weighted 0. When an edge is added to F , its weight is decreased to 0. An efficient data structure for maintaining a minimum spanning tree with a small number of weights can be found in <ref> [6, 7] </ref>. In addition, we keep for each nontree edge a pointer to where it is stored and for each tree edge, its level number and a pointer to its location in each data structure in which it appears. We keep the following invariant. Invariant: 1. <p> each edge which is deleted or inserted or whose weight is changed by a combination of these operations, the amortized expected update cost of the fully dynamic MST algorithm when there are k weights is O.k log 2 n/, so that the cost per deletion is O.log 3 n/ (see <ref> [6, 7] </ref>). To maintain L we use a dynamic tree D.F/ representing F. All edges in paths of L have labels naming the path it is in. 7 * add L.a; b/: adds to L the maximal subpaths of .a; b/ which are edge-disjoint from the other ele-ments of L.
Reference: [8] <author> H. Nagamochi and T. Ibaraki, </author> <title> Linear time algorithms for finding a sparse k-connected spanning subgraph of a k-connected graph, </title> <type> Algorithmica 7, </type> <year> 1992, </year> <month> 583596. </month>
Reference: [9] <author> D. D. Sleator, R. E. Tarjan, </author> <title> A Data Structure for Dynamic Trees J. </title> <journal> Comput. System Sci. </journal> <volume> 24 (1983), </volume> <pages> 362381. </pages>
Reference-contexts: This leads to a first naive approach for maintaining 2-edge connectivity dynamically: Keep for each edge e a coverage count, i.e., the number on nontree edges covering e. If T is stored in a dynamic tree data structure with the coverage count as cost <ref> [9] </ref>, then after the insertion and deletion of a nontree edge all coverage counts can be updated in time O.log n/. <p> The size s.T / of a spanning tree is the number of nodes in it. We maintain the following data structures: * F is stored in a dynamic tree data structure D.F / whose edges are labeled only while processing a deletion <ref> [9] </ref>. * For each level i, F is stored in a dynamic tree data structure B.i/ in which each edge of F i has cost 1 and all others have cost 0. * For each level i, the trees of F i are stored in an ET-tree in which all nontree
Reference: [10] <author> R. E. Tarjan, </author> <title> Data Structures and Network Algorithms SIAM (1983), </title> <type> 5770. </type>
Reference-contexts: Note that this means that in the dynamic tree data structure N 0 .i/ vertices rather than edges have costs. Operations analogous to those defined for dynamic trees with edge costs can be implemented with the same time bounds <ref> [10] </ref>. * a dynamic tree data structure C.i/ storing F where an edge e has cost c i .e/ if it is represented by c i .e/ superedges in F j ; j i. * for each 2-edge connected component of F c i , an ET-tree data structure in which

References-found: 10

