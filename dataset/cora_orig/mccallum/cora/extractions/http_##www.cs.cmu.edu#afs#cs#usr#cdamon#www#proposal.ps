URL: http://www.cs.cmu.edu/afs/cs/usr/cdamon/www/proposal.ps
Refering-URL: 
Root-URL: 
Title: Selective Enumeration method for solving relational formulae must be at the core of any tool
Author: Craig A. Damon Daniel Jackson (co-chair) Jeanette Wing (co-chair) Gary Miller Rance Cleaveland 
Degree: A Thesis Proposal  Thesis Committee  
Note: A  In this this thesis, I am  This document was created with FrameMaker 4.0.4  
Date: October 27, 1997  
Affiliation: School of Computer Science Carnegie Mellon University  (North Carolina State University)  
Abstract: Sets, functions and relations are powerful structures for modeling software systems. Relational specifications, built from these constructs, are the most common form of formal specification for software systems. However, in sharp contrast to other formal notations, there is an almost complete lack of automated tools for analyzing relational specifications. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ulman, </author> <title> Compilers: Principles, Techniques and Tools, Second Edition, </title> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Whereas some of this work has been directly incorporated, existing model checkers use a fundamentally different approach to perform their search, limiting the applicability of the work for solving relational formulae. Some of the mechanisms used in selective enumeration draw directly or indirectly from existing compiler optimizations <ref> [ASU86] </ref>. The mechanisms for selecting a partial assignment for consideration in short circuiting draw both from traditional common-sub-expression elimination and from short-circuiting optimization for languages without strict ordering requirements, such as Pascal.
Reference: [BH94] <author> Rudolf Berghammer and Claudia Hattensperger. </author> <title> Computer-Aided Manipulation of Relational Expressions and Formulae Using RALF. </title> <type> Technical Report, </type> <institution> Institut fur Informatik und Praktische Mathematik, Christian-Albrechts Universitat Zu Kiel, Kiel, Germany, </institution> <year> 1994. </year>
Reference-contexts: None of these tools have focused on relational formulae, so little, if any, of this work can be directly applied to solving relational formulae. There have also been tools that use a theorem proving approach to solve relational formulae <ref> [BH94] </ref> or verify properties of relational specifications [ES94; SM96].These tools remove the finite bounds required by Nitpick, thereby providing a true verification or refutation. Unlike Nitpick (or model checkers), theorem proving still requires enormous human effort, generally from an expert user, and provides no counterexamples for investigating invalid claims.
Reference: [BJR97] <author> Grady Booch, Ivar Jacobson, and James Rumbaugh. </author> <title> The Unified Modelling Language for Object-Oriented Development. Documentation Set, version 1.0, Rational Software Corporation, </title> <note> Available at &lt;http://www.rational.com&gt;. </note>
Reference: [Bry92] <author> Randal E. Bryant. </author> <title> Symbolic Boolean Manipulation with Ordered Binary-Decision Diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 24, No. 3, </volume> <month> September </month> <year> 1992, </year> <pages> pp. 293318. </pages>
Reference: [BC+92] <author> J. R. Burch, Edmund M. Clarke, Kenneth L. McMillan, David L. Dill, and L. J. Hwang. </author> <title> Symbolic Model Checking: 1030 States and Beyond. </title> <journal> Information and Computation Vol. </journal> <volume> 98, No. </volume> <month> 2 (June </month> <year> 1992), </year> <pages> pp. 143170. </pages>
Reference: [Che76] <author> Peter P. Chen. </author> <title> The entity-relationship model toward a unified view of data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 1, No. 1, </volume> <year> 1976, </year> <pages> pp. 936. </pages>
Reference: [CE81] <author> Edmund M. Clarke and E. Allen Emerson. </author> <title> Synthesis of synchronization skeletons for branching time temporal logic. Logic of Programs: Workshop (Yorktown Heights, </title> <booktitle> NY), Lecture Notes in Computer Science , Vol. </booktitle> <volume> 131, </volume> <publisher> Springer Verlag, </publisher> <year> 1981, </year> <pages> pp 5271. </pages>
Reference-contexts: Although the techniques employed by other formal-methods tools [CW+96] are quite different from selective enumeration, many of these tools also attempt to verify a formula. The primary research challenge in model checking, introduced in <ref> [CE81] </ref>, has been to reduce the state space explosion. One successful approach translates the problem into a more general, but well understood one, such as boolean satisfiability. As noted in the preceding paragraphs, such solutions come at the cost of sacrificing higher level structure that might be usefully exploited.
Reference: [CW+96] <author> Edmund M. Clarke, Jeanette M. Wing, et al. </author> <title> Formal Methods: State of the Art and Future Directions. </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 28, No. 4, </volume> <month> December </month> <year> 1996, </year> <pages> pp. 626643. </pages>
Reference-contexts: Although it is possible that additional effort on the BDD version could similarly reduce the time required, I believe that the additional semantics available in the relational formula will give an advantage to selective enumeration. Although the techniques employed by other formal-methods tools <ref> [CW+96] </ref> are quite different from selective enumeration, many of these tools also attempt to verify a formula. The primary research challenge in model checking, introduced in [CE81], has been to reduce the state space explosion.
Reference: [CPS93] <author> Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. </author> <title> The Concurrency Workbench: A Semantics-Based Tool for the Verification of Concurrent Systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 1, </volume> <month> Jan-uary </month> <year> 1993, </year> <pages> pp. 3672. </pages>
Reference: [DJ96] <author> Craig A. Damon and Daniel Jackson. </author> <title> Efficient Search as a Means of Executing Specifications. </title> <booktitle> Proceedings Second International Workshop on Tools and Algo rithms for the Construction and Analysis of Systems (TACAS 96) , Passau, Germa ny, Lecture Notes in Computer Science, </booktitle> <volume> Vol. 1055, </volume> <publisher> Springer Verlag, </publisher> <month> March </month> <year> 1996, </year> <pages> pp. 7086. </pages>
Reference: [DJJ96] <author> Craig A. Damon, Daniel Jackson, and Somesh Jha. </author> <title> Checking Relational Specifications with Binary Decision Diagrams. </title> <booktitle> Proceedings 4th ACM SIGSOFT Conference on Foundations of Software Engineering, </booktitle> <address> San Francisco, CA, </address> <month> October </month> <year> 1996, </year> <pages> pp. 7081. </pages>
Reference: [ES94] <author> Marcin Engel and Jens Ulrik Skakkeback. </author> <title> Applying PVS to Z. </title> <type> Technical Report ID/ DTU ME 3/1, </type> <institution> ProCos Project, Department of Computer Science, Technical University of Denmark, Lyngby, Denmark, </institution> <year> 1994. </year>
Reference-contexts: None of these tools have focused on relational formulae, so little, if any, of this work can be directly applied to solving relational formulae. There have also been tools that use a theorem proving approach to solve relational formulae [BH94] or verify properties of relational specifications <ref> [ES94; SM96] </ref>.These tools remove the finite bounds required by Nitpick, thereby providing a true verification or refutation. Unlike Nitpick (or model checkers), theorem proving still requires enormous human effort, generally from an expert user, and provides no counterexamples for investigating invalid claims.
Reference: [Fag77] <author> Ronald Fagin. </author> <title> The Number of Finite Relational Structures. </title> <journal> Discrete Mathematics, 1977, </journal> <volume> Vol. 19, </volume> <pages> pp 50-58. </pages>
Reference: [JD95] <author> Daniel Jackson and Craig A. </author> <title> Damon. </title> <type> Semi-Executable Specifications . Technical Report CMU-CS-95-216, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> November </month> <year> 1995. </year>
Reference: [JD96a] <author> Daniel Jackson and Craig A. Damon. Nitpick: </author> <title> A Checker for Software Specifications (Reference Manual). </title> <type> Technical Report CMU-CS-96-109, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> January </month> <year> 1996. </year>
Reference: [JD96b] <author> Daniel Jackson and Craig A. Damon. </author> <title> Elements of Style: Analyzing a Software Design Feature with a Counterexample Detector. </title> <journal> IEEE Transactions on Software Engineering, July 1996, </journal> <volume> Vol. 22, No. 7, </volume> <pages> pp. 484495. </pages>
Reference: [JJD96] <author> Daniel Jackson, Somesh Jha, and Craig A. Damon. </author> <title> Faster Checking of Software Specifications by Eliminating Isomorphs. </title> <booktitle> Proceedings of ACM Symposium on Principles of Programming Languages (POPL 96), </booktitle> <address> St. Petersburg Beach, FL, </address> <month> Jan-uary </month> <year> 1996, </year> <pages> pp. 7990. </pages>
Reference: [JJD98] <author> Daniel Jackson, Somesh Jha, and Craig A. Damon. </author> <title> Isomorph-free Model Enumeration: A New Method for Checking Relational Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> To appear. </note>
Reference: [Jha96] <author> Somesh Jha. </author> <title> Symmetry and induction in model checking. </title> <type> Doctoral thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: Unfortunately, his techniques do not easily allow for an arbitrary coloring context, as required by our current isomorph-elimination technique. The concept of using symmetries of the problem to reduce the search space for model checking has been investigated by Jha <ref> [Jha96] </ref>, among others. Whereas some of this work has been directly incorporated, existing model checkers use a fundamentally different approach to perform their search, limiting the applicability of the work for solving relational formulae.
Reference: [Jip92] <author> Peter Jipsen. </author> <title> Computer-aided Investigations of Relation Algebras. </title> <type> Doctoral thesis, </type> <institution> Dept. of Mathematics, Vanderbilt University, Nashville, Tennessee, </institution> <month> May </month> <year> 1992. </year>
Reference: [Kum92] <author> Vipin Kumar. </author> <title> Algorithms for constraint satisfaction, A survey. </title> <journal> AI Magazine, </journal> <volume> Vol. 13, No. 1, </volume> <month> Spring </month> <year> 1992, </year> <pages> pp. 3244. </pages>
Reference-contexts: Unlike Nitpick (or model checkers), theorem proving still requires enormous human effort, generally from an expert user, and provides no counterexamples for investigating invalid claims. Solving a relational formula could be structured as a constraint satisfaction problem. Traditional constraint satisfaction approaches <ref> [Kum92; Mac92] </ref>, used to solve problems such as shape recognition [Wal75] or job shop scheduling [SF91], support only a much more limited constraint language. Finite constraint satisfaction, the area most similar to Nitpick, allows only a restricted subset of Horn clauses to express the constraints.
Reference: [Mac92] <author> Alan K. Mackworth. </author> <title> The logic of constraint satisfaction. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 58, </volume> <month> December </month> <year> 1992, </year> <pages> pp. 320. </pages>
Reference-contexts: Unlike Nitpick (or model checkers), theorem proving still requires enormous human effort, generally from an expert user, and provides no counterexamples for investigating invalid claims. Solving a relational formula could be structured as a constraint satisfaction problem. Traditional constraint satisfaction approaches <ref> [Kum92; Mac92] </ref>, used to solve problems such as shape recognition [Wal75] or job shop scheduling [SF91], support only a much more limited constraint language. Finite constraint satisfaction, the area most similar to Nitpick, allows only a restricted subset of Horn clauses to express the constraints.
Reference: [McK81] <author> Brendan D. McKay. </author> <title> Practical graph isomorphism. </title> <journal> Congressus Numerantium (1981), </journal> <pages> pp 499517. </pages>
Reference-contexts: The standard constraint propagation algorithms, including arc consistency and k-consistency, are strongly reminiscent of bounded generation. They are limited, however, to the weaker constraint language. Isomorph elimination draws heavily on many well developed principles of graph theory. McKay <ref> [McK81; McK94] </ref>, in particular, has extensively investigated issues surrounding isomorph-free generation of bi-partite graphs, which include relations and functions. Unfortunately, his techniques do not easily allow for an arbitrary coloring context, as required by our current isomorph-elimination technique.
Reference: [McK94] <author> Brendan D. McKay. </author> <note> Nauty Users Guide, version 1.5. </note> <institution> Computer Science Department, Australian National University, </institution> <address> GPO Box 4, ACT 2601, Australia. </address>
Reference-contexts: The standard constraint propagation algorithms, including arc consistency and k-consistency, are strongly reminiscent of bounded generation. They are limited, however, to the weaker constraint language. Isomorph elimination draws heavily on many well developed principles of graph theory. McKay <ref> [McK81; McK94] </ref>, in particular, has extensively investigated issues surrounding isomorph-free generation of bi-partite graphs, which include relations and functions. Unfortunately, his techniques do not easily allow for an arbitrary coloring context, as required by our current isomorph-elimination technique.
Reference: [SM96] <author> Mark Saaltnik and Irwin Meisels. </author> <title> The Z/Eves Reference Manual (draft). </title> <type> Technical Report TR-96-5493-03, </type> <address> ORA Canada, Ottawa, Canada, </address> <month> December </month> <year> 1995, </year> <month> revised April </month> <year> 1996. </year>
Reference-contexts: None of these tools have focused on relational formulae, so little, if any, of this work can be directly applied to solving relational formulae. There have also been tools that use a theorem proving approach to solve relational formulae [BH94] or verify properties of relational specifications <ref> [ES94; SM96] </ref>.These tools remove the finite bounds required by Nitpick, thereby providing a true verification or refutation. Unlike Nitpick (or model checkers), theorem proving still requires enormous human effort, generally from an expert user, and provides no counterexamples for investigating invalid claims.
Reference: [SF91] <author> Norman M. Sadeh and Mark S. Fox. </author> <title> Variable and Value Ordering Heuristics for Hard Constraint Satisfaction Problems: An Application to Job Shop Scheduling CMU-RI-TR-91-23, </title> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <year> 1991. </year>
Reference-contexts: Solving a relational formula could be structured as a constraint satisfaction problem. Traditional constraint satisfaction approaches [Kum92; Mac92], used to solve problems such as shape recognition [Wal75] or job shop scheduling <ref> [SF91] </ref>, support only a much more limited constraint language. Finite constraint satisfaction, the area most similar to Nitpick, allows only a restricted subset of Horn clauses to express the constraints. For most of the existing constraint satisfaction algorithms, all constraints must be binary (involve no more than two variables).
Reference: [SLM92] <author> Bart Selman, Hector Levesque, and David Mitchell. </author> <title> A new method for solving hard satisfiability problems. </title> <booktitle> Proceedings 10th National Conference on Artificial Intelligence (AAI-92), </booktitle> <address> San Jose, CA, </address> <month> July </month> <year> 1992, </year> <pages> pp. 440446. </pages>
Reference: [Sla94] <author> John K. Slaney. </author> <title> Finder: Finite Domain Enumerator, System Description. </title> <booktitle> Proceedings of 12th International Conference on Automated Deduction, Nancy, France, </booktitle> <editor> Alan Bundy (ed.), </editor> <booktitle> Lecture Notes in Artificial Intelligence , Vol. </booktitle> <volume> 814, </volume> <publisher> Springer Ver-lag, </publisher> <address> Berlin, </address> <year> 1994, </year> <pages> pp. 798801. </pages>
Reference: [Spi92] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual, Second edition, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference: [Tar41] <author> Alfred Tarski. </author> <title> On the calculus of relations. </title> <journal> Journal of Symbolic Logic 7389. </journal>
Reference: [Wal75] <author> D. Waltz. </author> <title> Understanding Line Drawings of Scenes with Shadows. In The Psychology of Computer Vision, </title> <editor> ed. Patrick H. Winston, </editor> <publisher> McGraw Hill, </publisher> <year> 1975, </year> <pages> pp. </pages> <year> 1991. </year>
Reference-contexts: Solving a relational formula could be structured as a constraint satisfaction problem. Traditional constraint satisfaction approaches [Kum92; Mac92], used to solve problems such as shape recognition <ref> [Wal75] </ref> or job shop scheduling [SF91], support only a much more limited constraint language. Finite constraint satisfaction, the area most similar to Nitpick, allows only a restricted subset of Horn clauses to express the constraints.
Reference: [ZZ95] <author> Jian Zhang and Hantao Zhang. </author> <title> Constraint Propagation in Model Generation. </title> <booktitle> Proceedings Principles and Practice of Constraint Programming - CP'95, </booktitle> <editor> Ugo Mon-tanari, Francesca Rossi (Eds.), Cassis, </editor> <address> France, </address> <month> September </month> <year> 1995, </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 976, </volume> <publisher> Springer 1995, </publisher> <pages> pp. 398414. </pages>
Reference: [Zha96] <author> Jian Zhang. </author> <title> Constructing Finite Algebras with Falcon. </title> <journal> Journal of Automated Reasoning, </journal> <volume> Vol. 17, No. 1, </volume> <month> August </month> <year> 1996, </year> <pages> pp. 122. </pages>
References-found: 33

