URL: http://www.cs.columbia.edu/~ezk/research/tp/thesis_proposal.ps
Refering-URL: http://www.cs.columbia.edu/~ezk/research/index.html
Root-URL: http://www.cs.columbia.edu
Email: ezk@cs.columbia.edu  
Title: A File System Component Compiler language and its translator, use it to implement a few
Author: Erez Zadok 
Note: THESIS PROPOSAL The proposed thesis will describe the  
Date: December 6, 1997  
Address: New York, NY 10027  
Affiliation: Computer Science Department Columbia University  
Abstract: File System development is a difficult and time consuming task, the results of which are rarely portable across operating systems. Several proposals to improve the vnode interface to allow for more flexible file system design and implementation have been made in recent years, but none is used in practice because they require costly fundamental changes to kernel interfaces, only operating systems vendors can make those changes, are still non-portable, tend to degrade performance, and do not appear to provide immediate return on such an investment. This proposal advocates a language for describing file systems, called FiST. The associated translator can generate portable C code | kernel resident or not | that implements the described file system. No kernel source code is needed and no existing vnode interface must change. The performance of the file systems automatically generated by FiST can be within a few percent of comparable hand-written file systems. The main benefits to automation are that development and maintenance costs are greatly reduced, and that it becomes practical to prototype, implement, test, debug, and compose a vastly larger set of such file systems with different properties. 
Abstract-found: 1
Intro-found: 1
Reference: [Abrosimov92] <author> V. Abrosimov, F. Armand, and M. I. Ortega. </author> <title> A Distributed Consistency Server for the CHORUS System. Symposium on Experiences with Distributed and Multiprocessor Systems (SEDMS) (Newport Beach, </title> <publisher> CA), </publisher> <pages> pages 129-48. </pages> <publisher> USENIX, </publisher> <month> 26-27 March </month> <year> 1992. </year>
Reference-contexts: HURD file systems are implemented at user level, much the same as in Mach [Accetta86] and CHORUS <ref> [Abrosimov92] </ref>. The novel concept introduced by HURD is that of the translator. A translator is a program that can be attached to a pathname and perform specialized services when that pathname is accessed. For example, in the HURD there is no need for the ftp program.
Reference: [Accetta86] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> USENIX Conference Proceedings (At-lanta, </booktitle> <address> GA), </address> <pages> pages 93-112. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1986. </year>
Reference-contexts: HURD file systems are implemented at user level, much the same as in Mach <ref> [Accetta86] </ref> and CHORUS [Abrosimov92]. The novel concept introduced by HURD is that of the translator. A translator is a program that can be attached to a pathname and perform specialized services when that pathname is accessed. For example, in the HURD there is no need for the ftp program.
Reference: [Anderson92] <author> D. P. Anderson, Y. Osawa, and R. Govindan. </author> <title> The Continuous Media File System (Real-Time Disk Storage and Retrieval of Digital Audio/Video Data). </title> <booktitle> USENIX Conference Proceedings (San Antonio, TX), </booktitle> <pages> pages 157-64. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1992. </year>
Reference-contexts: Four example domains include: 1. Multimedia: with the explosion of the Internet, Web content developers would like a file system that can store HTML, image, and audio files more efficiently so they can be retrieved faster with HTTP servers, or be played back in real-time <ref> [Anderson92, Ramakrishnan93, Fall94, Mercer94, Pasquale94] </ref>. 2. Databases: researchers are looking for methods to improve the performance of Unix file systems, and/or for file systems that provide built-in support for concurrency [Stonebraker81, Stonebraker86]. 3.
Reference: [Bershad88] <author> B. N. Bershad and C. B. Pinkerton. Watchdogs: </author> <title> Extending the UNIX File System. </title> <booktitle> USENIX Conference Proceedings (Dallas, TX), </booktitle> <pages> pages 267-75. </pages> <publisher> USENIX, </publisher> <month> Winter </month> <year> 1988. </year>
Reference-contexts: Apollo's I/O system was extendible through user-level libraries that changed the behavior of the application linking with them [Rees86]; now, modern support for shared libraries [Gingell87a] permits new functionality to be loaded by the run-time linker. One of the first attempts to extend file system functionality was "watchdogs" <ref> [Bershad88] </ref>, a mechanism for trapping file system operations and running user-written code as part of the operation. Vnode stacking was first implemented by Rosenthal (in SunOS 4.1) around 1990 [Rosenthal90].
Reference: [Bishop88] <author> M. A. Bishop. </author> <title> Auditing Files on a Network of UNIX Machines. </title> <booktitle> UNIX Security Workshop (Portland, Oregon), </booktitle> <pages> pages 51-2. </pages> <publisher> USENIX, </publisher> <month> 29-30 August </month> <year> 1988. </year>
Reference-contexts: An easy way to use encryption in file systems [Blaze93, Gutmann96, Boneh96] and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable <ref> [Bishop88, Kardel90] </ref>. Researchers and developers have always needed an environment where they can quickly prototype and test new file system ideas. Several earlier works attempted to provide the necessary flexibility.
Reference: [Blaze93] <author> M. </author> <title> Blaze. A Cryptographic File System for Unix. </title> <booktitle> Proceedings of the first ACM Conference on Computer and Communications Security (Fairfax, </booktitle> <address> VA). </address> <publisher> ACM, </publisher> <month> November, </month> <year> 1993. </year>
Reference-contexts: In contrast, when an out of kernel file system hangs or exits, processes that access the now-dead file system live on, possibly propagating erroneous results to other processes and machines. 2 Examples of out-of-kernel file systems are the Amd [Pendry91, Stewart93] and Automountd [Callaghan89] automounters, Blaze's Cfsd encrypting file system <ref> [Blaze93] </ref>, and Amd derivatives including Hlfsd [Zadok93b], AutoCacher [Minnich93], and Restore-o-Mounter [Moran93]. A few file systems at the user level have been implemented as a user-level library. <p> Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95]. An easy way to use encryption in file systems <ref> [Blaze93, Gutmann96, Boneh96] </ref> and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable [Bishop88, Kardel90]. Researchers and developers have always needed an environment where they can quickly prototype and test new file system ideas. <p> For example Cachefs as described in Appendix B.3.1 and [SunSoft94]. * User-level file systems produced automatically using FiST against user-level hand written ones. For example Cryptfs as described in Appendix B.2.6 and <ref> [Blaze93] </ref>. 40 5 EVALUATION PLAN * FiST generated file systems against another system that provides native stacking, such as UCLA's work [Heidemann94]. * Various FiST generated file systems vs. each other. For example an in-kernel Gzipfs (Appendix B.2.5) against a user-level one. <p> B.2.6 Cryptfs An encryption file system that will use similar algorithms as cfs <ref> [Blaze93] </ref>. For security reasons, all data blocks will be encrypted (both directory and file blocks). Data streams get encrypted before written to the interposed file system (on the way "down"), and decrypted after being read (on the way "up").
Reference: [Boneh96] <author> D. Boneh and R. J. Lipton. </author> <title> A Revocable Backup System. </title> <booktitle> The Sixth USENIX UNIX Security Symposium Proceedings (San Jose, California), </booktitle> <pages> pages 91-6. </pages> <publisher> USENIX, </publisher> <month> 22-25 July </month> <year> 1996. </year>
Reference-contexts: Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95]. An easy way to use encryption in file systems <ref> [Blaze93, Gutmann96, Boneh96] </ref> and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable [Bishop88, Kardel90]. Researchers and developers have always needed an environment where they can quickly prototype and test new file system ideas.
Reference: [Bosch96] <author> P. Bosch and S. J. Mullender. Cut-and-paste file-systems: </author> <title> integrating simulators and filesystems. </title> <address> USENIX (San Diego, CA), </address> <month> January </month> <year> 1996. </year>
Reference-contexts: The most successful of all is the simple (albeit limited) language used by Amd [Pendry91, Stewart93] to describe map entries, their types, semantics, etc. Recent work on file system simulators <ref> [Bosch96] </ref> also moves in this direction, but unfortunately requires a radically different (object oriented) file system interface.
Reference: [Breitstein97] <author> S. R. Breitstein. </author> <title> Inferno Namespaces. Online White-Paper. </title> <booktitle> Lucent Technologies, </booktitle> <month> 11 March </month> <year> 1997. </year> <note> Available via the WWW in http://www.inferno.lucent.com/namespace.html. </note>
Reference-contexts: This model is simple and powerful: operations can be done using simple open, read/write, and close sequences | all without the need for different APIs for networking, file systems, or other daemons <ref> [Breitstein97] </ref>. Inferno allows name spaces to be customized by a client, server, or any application. The mount operation imports a remote name space onto a local point, much like Unix file system mounts work. The bind operation is used to make a name space in one directory appear in another.
Reference: [Callaghan89] <author> B. Callaghan and T. Lyon. </author> <booktitle> The Automounter. USENIX Conference Proceedings (San Diego, </booktitle> <address> CA), </address> <pages> pages 43-51. </pages> <publisher> USENIX, </publisher> <month> Winter </month> <year> 1989. </year>
Reference-contexts: In contrast, when an out of kernel file system hangs or exits, processes that access the now-dead file system live on, possibly propagating erroneous results to other processes and machines. 2 Examples of out-of-kernel file systems are the Amd [Pendry91, Stewart93] and Automountd <ref> [Callaghan89] </ref> automounters, Blaze's Cfsd encrypting file system [Blaze93], and Amd derivatives including Hlfsd [Zadok93b], AutoCacher [Minnich93], and Restore-o-Mounter [Moran93]. A few file systems at the user level have been implemented as a user-level library.
Reference: [Callaghan93] <author> B. Callaghan and S. Singh. </author> <booktitle> The Autofs Automounter. USENIX Conference Proceedings (Cincinnati, </booktitle> <address> OH), </address> <pages> pages 59-68. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1993. </year>
Reference-contexts: If Automountfs will have to know the same, it will violate the symmetry principle of stackable file systems. One solution is to move only part of the automounter code into the kernel, and keep the mount-specific code outside the kernel. This is exactly what Sun had done with Autofs <ref> [Callaghan93] </ref>: most of the code was moved into the kernel, but the actual mounting is initiated by a user-level daemon called automountd. Autofs talks to this daemon using RPCs initiated from the kernel.
Reference: [Cate92] <author> V. Cate. </author> <title> Alex a global filesystem. </title> <booktitle> Proceedings of the File Systems Workshop (Ann Arbor, </booktitle> <address> MI), </address> <pages> pages 1-11. </pages> <publisher> Usenix Association, </publisher> <month> 21-22 May </month> <year> 1992. </year>
Reference-contexts: The ftp translator takes care of logging into the remote server, translating FTP protocol commands to file system commands, and returning result codes back to the user. Originally, a translator-like idea was used by the "Alex" work and allowed for example transparent ftp access via a file system interface <ref> [Cate92] </ref>. 6.1.1 How to Write a Translator HURD defines a common interface for translators.
Reference: [CORBA91] <author> D. E. Corp., H.-P. Company, H. Corp., N. Corp., O. D. Inc., and S. Inc. </author> <title> The Common Object Request Broker: Architecture and Specification, OMG document number 91.12.1, Rev. 1.1. Object Management Group, </title> <note> Draft 10 December 1991. </note>
Reference-contexts: It was designed as a set of cooperating servers on top of a microkernel. Spring uses a modified Interface Definition Language (IDL) [Stone87, Warren87] as outlined in the CORBA specifications <ref> [CORBA91] </ref> to define the interfaces between the different servers. Spring includes several generic modules that provide services that are useful for file systems: * Caching: A module that provides attribute caching of objects. * Coherency: A layer that guarantees object states in different servers are identical.
Reference: [Elmasri94] <author> R. Elmasri and S. B. Navathe. </author> <title> Dynamic Multilevel Indexes Using B-Trees and B+-trees. </title> <booktitle> In Fundamentals of Database Systems, </booktitle> <pages> pages 116-28. </pages> <publisher> Benjamin Cummings, </publisher> <year> 1994. </year>
Reference-contexts: That makes storing state in such a data structure obvious, as there is a one-to-one mapping of source file to auxiliary state file. But what if the auxiliary state that needs to stored requires a more complex data structure, such as a B-tree <ref> [Elmasri94] </ref> or a graph? In that case, there is no simple way to take advantage of Unix's existing file system structures. <p> Initially it will provide a simple lookup table functions that could be used once a state file has been read into memory. Later on it could be expanded to more complex and exotic off-line data structures such as B-trees <ref> [Elmasri94] </ref>. Since files in this file system will be completely under the control of the file system, it could be made hidden from users. User processes would not need to be able to modify these files.
Reference: [Fall94] <author> K. Fall and J. Pasquale. </author> <title> Improving Continuous-Media Playback Performance with In-Kernel Data Paths. </title> <booktitle> IEEE Conference on Multimedia Computing and Systems, </booktitle> <pages> pages 100-9, </pages> <month> May </month> <year> 1994. </year> <note> 80 REFERENCES </note>
Reference-contexts: Four example domains include: 1. Multimedia: with the explosion of the Internet, Web content developers would like a file system that can store HTML, image, and audio files more efficiently so they can be retrieved faster with HTTP servers, or be played back in real-time <ref> [Anderson92, Ramakrishnan93, Fall94, Mercer94, Pasquale94] </ref>. 2. Databases: researchers are looking for methods to improve the performance of Unix file systems, and/or for file systems that provide built-in support for concurrency [Stonebraker81, Stonebraker86]. 3.
Reference: [Fitzhardinge94] <author> J. Fitzhardinge. </author> <title> Userfs user process filesystem. Unpublished software package documentation. </title> <publisher> Softway Pty, Ltd., </publisher> <month> August, </month> <year> 1994. </year> <note> Available via ftp from tsx-11.mit.edu in /pub/linux/ALPHA/userfs. </note>
Reference-contexts: One such example is Systas [Lord96], a file system for Linux that adds an extra measure of flexibility by allowing users to write Scheme code to implement the file system semantics. Another, also for Linux, is Userfs <ref> [Fitzhardinge94] </ref>. For example, to write a new file system using Userfs, the implementor fills in a set of C++ stub file system calls | the file system's version of open, close, lookup, read, write, unlink, etc. Developers have all the flexibility of user level C++ programs.
Reference: [Forin94] <author> A. Forin and G. Malan. </author> <title> An MS-DOS Filesystem for UNIX. </title> <booktitle> USENIX Conference Proceedings (San Francisco, </booktitle> <address> CA), </address> <pages> pages 337-54. </pages> <publisher> USENIX, </publisher> <month> Winter </month> <year> 1994. </year>
Reference-contexts: The cache is stored in a UFS [LoVerso91] physical file system. Each of the three replicas is stored in a different type of physical file system, UFS, NFS, and PCFS <ref> [Forin94] </ref>. One could design a single file system that includes all of this functionality. However, the result would probably be complex and difficult to debug and maintain. Alternatively, one could decompose such a file system into a set of components: 1. <p> NFS [Sandberg85, Pawlowski94], that uses the network as its file system "device." 1 * The High-Sierra file system (HSFS, ISO9660) for CD-ROMs [Kao89]. * The FAT-based file system originally developed for DOS [Tanenbaum92], and later adapted for Unix machines to access a floppy as a native PC-based file system (PCFS) <ref> [Forin94] </ref>. Such file systems are difficult to port because they are coupled to the surrounding operating system: system call handlers call the file system code and the file system code calls device drivers.
Reference: [Gingell87a] <author> R. A. Gingell, M. Lee, X. T. Dang, and M. S. Weeks. </author> <title> Shared Libraries in SunOS. </title> <booktitle> USENIX Conference Proceedings (Phoenix, </booktitle> <address> AZ), </address> <pages> pages 131-45. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1987. </year>
Reference-contexts: Several earlier works attempted to provide the necessary flexibility. Apollo's I/O system was extendible through user-level libraries that changed the behavior of the application linking with them [Rees86]; now, modern support for shared libraries <ref> [Gingell87a] </ref> permits new functionality to be loaded by the run-time linker. One of the first attempts to extend file system functionality was "watchdogs" [Bershad88], a mechanism for trapping file system operations and running user-written code as part of the operation. <p> See <ref> [Gingell87a, Gingell87b] </ref> for more details. * vop addmap adds more pages to a memory-mapped file. * vop delmap removes some pages from a memory-mapped file. * vop poll polls for events on the file.
Reference: [Gingell87b] <author> R. A. Gingell, J. P. Moran, and W. A. Shannon. </author> <title> Virtual Memory Architecture in SunOS. </title> <booktitle> USENIX Conference Proceedings (Phoenix, </booktitle> <address> AZ), </address> <pages> pages 81-94. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1987. </year>
Reference-contexts: See <ref> [Gingell87a, Gingell87b] </ref> for more details. * vop addmap adds more pages to a memory-mapped file. * vop delmap removes some pages from a memory-mapped file. * vop poll polls for events on the file.
Reference: [Glover93] <author> F. Glover. </author> <title> A Specification of Trusted NFS (TNFS) Protocol Extensions. </title> <type> Technical report. </type> <institution> Internet Engineering Task Force, </institution> <month> 1 March </month> <year> 1993. </year>
Reference-contexts: Security: more secure file systems are sought, especially ones that securely export files over the network <ref> [Steiner88, Haynes92, Glover93, Takahashi95] </ref>. An easy way to use encryption in file systems [Blaze93, Gutmann96, Boneh96] and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable [Bishop88, Kardel90].
Reference: [Golub90] <author> D. Golub. ddb(4). </author> <title> Mach Operating System Reference Manual, </title> <type> Section 4. </type> <institution> Carnegie Mellon University, </institution> <month> 8 August </month> <year> 1990. </year>
Reference-contexts: Every small change takes a long edit-compile-run-debug cycle, with kernel crashes and lack of debugging tools <ref> [Golub90, Stallman94, SMCC94a] </ref> making the task frustrating. Worse, file system code developed for one operating system is almost never portable to another.
Reference: [Gutmann96] <author> P. Gutmann. </author> <title> Secure Deletion of Data from Magnetic and Solid-State Memory. </title> <booktitle> The Sixth USENIX UNIX Security Symposium Proceedings (San Jose, California), </booktitle> <pages> pages 77-89. </pages> <publisher> USENIX, </publisher> <month> 22-25 July </month> <year> 1996. </year>
Reference-contexts: Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95]. An easy way to use encryption in file systems <ref> [Blaze93, Gutmann96, Boneh96] </ref> and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable [Bishop88, Kardel90]. Researchers and developers have always needed an environment where they can quickly prototype and test new file system ideas.
Reference: [Guy90] <author> R. G. Guy, J. S. Heidemann, W. Mak, T. W. Page Jr., G. J. Popek, and D. Rothmeier. </author> <title> Implementation of the Ficus replicated file system. </title> <booktitle> USENIX Conference Proceedings, </booktitle> <pages> pages 63-71. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Rosenthal's interface was never made public or incorporated into Sun's operating systems. A few similar works followed Rosenthal, such as further prototypes for extended file systems in SunOS [Skinner93], and the Ficus layered file system <ref> [Guy90, Heidemann91] </ref> at UCLA. 2.2.2.1 Interposition and Composition Later works [Rosenthal92, Skinner93] established the current terminology for the field, discarding "stacking" in favor of "interposition" and "composition." The term "stacking" was considered at once to have too many implications, to be too vague, and to imply only a linear LIFO structure
Reference: [Haemer94] <author> J. S. Haemer. </author> <title> Imake Rhymes with Mistake. </title> <journal> ;login:, </journal> <volume> 19(1) </volume> <pages> 32-3. </pages> <publisher> USENIX, </publisher> <month> January-February </month> <year> 1994. </year>
Reference-contexts: To answer some of them correctly one had to be a Unix expert to begin with. More sophisticated solutions used the X11 Imake utility which abstracted the differences using preprocessing (via cpp) of several pre-written template files. Imake's usefulness never extended beyond that of the X11 domain of applications <ref> [Haemer94] </ref>. All of these solutions suffered from one major problem | they were static. That is, the portability offered was only as good as what the programmers of the package included.
Reference: [Haynes92] <author> R. A. Haynes and S. M. Kelly. </author> <title> Software Security for a Network Storage Service. </title> <booktitle> UNIX Security III Symposium Proceedings (Baltimore, Maryland), </booktitle> <pages> pages 253-65. </pages> <publisher> USENIX, </publisher> <month> 14-16 September </month> <year> 1992. </year>
Reference-contexts: Security: more secure file systems are sought, especially ones that securely export files over the network <ref> [Steiner88, Haynes92, Glover93, Takahashi95] </ref>. An easy way to use encryption in file systems [Blaze93, Gutmann96, Boneh96] and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable [Bishop88, Kardel90].
Reference: [Heidemann91] <author> J. S. Heidemann and G. J. Popek. </author> <title> A layered approach to file system development. </title> <type> Technical report CSD-910007. </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: Rosenthal's interface was never made public or incorporated into Sun's operating systems. A few similar works followed Rosenthal, such as further prototypes for extended file systems in SunOS [Skinner93], and the Ficus layered file system <ref> [Guy90, Heidemann91] </ref> at UCLA. 2.2.2.1 Interposition and Composition Later works [Rosenthal92, Skinner93] established the current terminology for the field, discarding "stacking" in favor of "interposition" and "composition." The term "stacking" was considered at once to have too many implications, to be too vague, and to imply only a linear LIFO structure
Reference: [Heidemann94] <author> J. S. Heidemann and G. J. Popek. </author> <title> File System Development with Stackable Layers. </title> <journal> Transactions on Computing Systems, </journal> <volume> 12(1) </volume> <pages> 58-89. </pages> <address> (New York, New York), </address> <publisher> ACM, </publisher> <month> February, </month> <year> 1994. </year>
Reference-contexts: This "virtual file system" concept has proven very useful, and nearly every version of Unix includes some version of vnodes and a vnode interface. One notable improvement to the vnode concept is "vnode stack File System ing," <ref> [Rosenthal92, Heidemann94, Skinner93] </ref> a technique for mod-ularizing file system functions. The idea is to allow one vnode interface to call another. Before stacking existed, there was only a single vnode interface. Higher level operating systems code called the vnode interface which in turn called code for a specific file system. <p> The implementation of Replicfs calls three different file systems. Fan-in can exist, too. There is no reason to restrict the stacking concept to a linear stack or chain of file systems. 1.1 The Problem Despite the promise of vnode stacking, not one of several proposed implementations <ref> [Rosenthal90, Rosenthal92, Heidemann94, Skinner93] </ref> has made it into mainstream operating systems, even though several of the proposals were made by an operating system vendor (Sun Microsystems). All previous proposals for vnode stacking required substantial changes to the definitions of the vnode and the vnode interface. <p> Therefore, the overhead of the first version of Wrapfs is comparable to the mechanisms implemented by Skinner and Wong [Skinner93] (up to 10%) and the UCLA stackable layers project <ref> [Heidemann94] </ref> (3%). 3.7 User Level Operation The FiST compiler can easily generate either kernel-resident or user-level code from the same input. Kernel code implements the vnode interface. User level code implements the NFS interface. The vnode interface was designed to accommodate version 2 of the NFS protocol. <p> For example Cryptfs as described in Appendix B.2.6 and [Blaze93]. 40 5 EVALUATION PLAN * FiST generated file systems against another system that provides native stacking, such as UCLA's work <ref> [Heidemann94] </ref>. * Various FiST generated file systems vs. each other. For example an in-kernel Gzipfs (Appendix B.2.5) against a user-level one. For each category, I will run the following tests: 1. Compare the performance of the file systems with similar or identical functionality. 2.
Reference: [Kao89] <author> P.-H. Kao, B. Gates, B. Thompson, and D. McCluskey. </author> <title> Support of the ISO-9660/HSG CDROM File System in HP-UX. </title> <booktitle> USENIX Conference Proceedings (Baltimore, MD), </booktitle> <pages> pages 189-202. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1989. </year>
Reference-contexts: [LoVerso91], an optimized version of FFS. * The LFS "log structured" file system, optimized for sequential writes [Rosenblum91] on hard disks. 2.1 Types of File Systems 5 * NFS [Sandberg85, Pawlowski94], that uses the network as its file system "device." 1 * The High-Sierra file system (HSFS, ISO9660) for CD-ROMs <ref> [Kao89] </ref>. * The FAT-based file system originally developed for DOS [Tanenbaum92], and later adapted for Unix machines to access a floppy as a native PC-based file system (PCFS) [Forin94].
Reference: [Kardel90] <author> F. Kardel. </author> <title> Frozen Files. </title> <booktitle> UNIX Security II Workshop Proceedings (Portland, Oregon), </booktitle> <pages> pages 83-6. </pages> <publisher> USENIX, </publisher> <month> 27-28 August </month> <year> 1990. </year>
Reference-contexts: An easy way to use encryption in file systems [Blaze93, Gutmann96, Boneh96] and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable <ref> [Bishop88, Kardel90] </ref>. Researchers and developers have always needed an environment where they can quickly prototype and test new file system ideas. Several earlier works attempted to provide the necessary flexibility.
Reference: [Kernighan96] <author> B. W. Kernighan. </author> <title> A Descent into Limbo. Online White-Paper. </title> <booktitle> Lucent Technologies, </booktitle> <month> 12 July </month> <year> 1996. </year> <note> Available via the WWW in http://www.inferno.lucent.com/inferno/limbotut.html. REFERENCES 81 </note>
Reference-contexts: also unify the contents of two directories. 44 6 RELATED WORK For Inferno to offer a new file system functionality that might otherwise be achieved via vnode stacking, an application has to mount and bind the right name spaces, add its own as required (implemented via the Limbo programming language <ref> [Kernighan96] </ref>), and then offer them for importation (which can be done securely). Inferno's main disadvantage is a familiar one. It is a brand new operating system, and employs a new programming language and model. Inferno is not likely to be as portable and in wide use for years to come.
Reference: [Khalidi93] <author> Y. A. Khalidi and M. N. Nelson. </author> <title> Extensible File Systems in Spring. </title> <booktitle> Proceedings of the 14th Symposium on Operating Systems Principles (Asheville, </booktitle> <publisher> North Carolina). ACM, </publisher> <month> December, </month> <year> 1993. </year>
Reference-contexts: However, even with caching extensively employed, basic file system operations (without stacking) still took on average 2-7 times longer than the highly optimized SunOS 4.1.3 <ref> [Khalidi93] </ref>. So while it is clear that caching helped to alleviate some overheads, many more remain. Compare that to FiST's total overhead for a single stack layer of about 3-6% (Section 3.6.2) and you see that FiST is more capable of commercial grade performance.
Reference: [Kistler91] <author> J. J. Kistler and M. Satyanarayanan. </author> <title> Disconnected Operation in the Coda File System. </title> <booktitle> Thirteenth ACM Symposium on Operating Systems Principles (Asilomar Conference Center, Pacific Grove, U.S.), </booktitle> <volume> volume 25, number 5, </volume> <pages> pages 213-25. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95].
Reference: [Kistler93] <author> J. J. Kistler. </author> <title> Disconnected Operation in a Distributed File System (Report CMU-CS-93-156). </title> <type> Technical report. </type> <institution> Carnegie Mellon University, Pittsburgh, U.S., </institution> <year> 1993. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95].
Reference: [Kleiman86] <author> S. R. Kleiman. Vnodes: </author> <title> An Architecture for Multiple File System Types in Sun UNIX. </title> <booktitle> USENIX Conference Proceedings (Atlanta, </booktitle> <address> GA), </address> <pages> pages 238-47. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1986. </year>
Reference-contexts: The "vnode interface" is an interface within an operating system's file system module. It allows higher level operating system modules to perform operations on vnodes. The vnode interface was invented by Sun Microsystems to facilitate the coexistence of multiple file systems <ref> [Kleiman86] </ref>, specifically the local file system that manages disk storage and the NFS [Sun89, Pawlowski94] remote file system. When a vnode represents storage (such as a file or directory), it does not expose what type of physical file system implements the storage. <p> is a higher-level language it would allow relatively easy changes to file systems, the same way interpreted languages do. 2.2 The Vnode Interface 2.2.1 The Original Vnode Interface The vnode interface 3 was invented over a decade ago to facilitate the implementation of multiple file systems in one operating system <ref> [Kleiman86] </ref>, and it has been very successful at that. It is now universally present in Unix operating systems. Readers not familiar with the vnode interface may refer to Appendix A for a tutorial on the subject. <p> The performance degradation added by my mechanism would be small. 47 A Appendix: Vnode Interface Tutorial This section provides a simple introduction to the vnode interface. The information herein is gathered from pivotal papers on the subject <ref> [Kleiman86, Rosenthal90] </ref> and from system C header files | specifically &lt;sys/vfs.h&gt; and &lt;sys/vnode.h&gt;. The two important data structures used in the vnode interface are struct vfs and struct vnode, depicted in Figures 21 and 25, respectively.
Reference: [Kramer88] <author> S. M. Kramer. </author> <title> On Incorporating Access Control Lists into the UNIX Operating System. </title> <booktitle> UNIX Security Workshop (Portland, Oregon), </booktitle> <pages> pages 38-48. </pages> <publisher> USENIX, </publisher> <month> 29-30 August </month> <year> 1988. </year>
Reference-contexts: Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95]. An easy way to use encryption in file systems [Blaze93, Gutmann96, Boneh96] and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) <ref> [Kramer88, Pawlowski94] </ref> are also highly desirable [Bishop88, Kardel90]. Researchers and developers have always needed an environment where they can quickly prototype and test new file system ideas. Several earlier works attempted to provide the necessary flexibility.
Reference: [Kuenning94] <author> G. Kuenning, G. J. Popek, and P. Reiher. </author> <title> An Analysis of Trace Data for Predictive File Caching in Mobile Computing. </title> <booktitle> USENIX Summer 1994 Conference (To Appear) (Boston, U.S.), </booktitle> <year> 1994. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95].
Reference: [Lord96] <author> T. Lord. </author> <note> Subject: SNFS - Scheme-extensible NFS. Unpublished USENET article. emf.net, 30 October 1996. Available via ftp in ftp://emf.net:users/lord/systas-1.1.tar.gz. </note>
Reference-contexts: A few file systems at the user level have been implemented as a user-level library. One such example is Systas <ref> [Lord96] </ref>, a file system for Linux that adds an extra measure of flexibility by allowing users to write Scheme code to implement the file system semantics. Another, also for Linux, is Userfs [Fitzhardinge94].
Reference: [LoVerso91] <author> S. LoVerso, N. Paciorek, A. Langerman, and G. Feinberg. </author> <title> The OSF/1 UNIX Filesystem (UFS). </title> <booktitle> USENIX Conference Proceedings (Dallas, TX), </booktitle> <pages> pages 207-18. </pages> <publisher> USENIX, </publisher> <month> 21-25 January </month> <year> 1991. </year>
Reference-contexts: One of the replicas of the source file system is itself encrypted, presumably with a key different from that of the encrypted cache. The cache is stored in a UFS <ref> [LoVerso91] </ref> physical file system. Each of the three replicas is stored in a different type of physical file system, UFS, NFS, and PCFS [Forin94]. One could design a single file system that includes all of this functionality. However, the result would probably be complex and difficult to debug and maintain. <p> These file systems are usually aware of and often optimized for specific device characteristics, as shown in Figure 2. Examples of such file systems include * The Berkeley Fast File System (FFS) [McKusick84] for physical disks. * Sun Microsystem's UFS <ref> [LoVerso91] </ref>, an optimized version of FFS. * The LFS "log structured" file system, optimized for sequential writes [Rosenblum91] on hard disks. 2.1 Types of File Systems 5 * NFS [Sandberg85, Pawlowski94], that uses the network as its file system "device." 1 * The High-Sierra file system (HSFS, ISO9660) for CD-ROMs [Kao89].
Reference: [Lucent97] <institution> Lucent. Inferno: la Commedia Interattiva. Online White-Paper. Lucent Technologies, </institution> <month> 13 March </month> <year> 1997. </year> <note> Available via the WWW in http://inferno.lucent.com/inferno/infernosum.html. </note>
Reference-contexts: The Inferno network operating system was designed to be compact while fully functional, and fit in a small amount of memory. It is designed to run on devices such as set-top boxes, PDAs, and other embedded systems <ref> [Lucent97] </ref>. In Inferno, everything is represented by files. Therefore, file systems are indistinguishable from other services; they are all part of the Inferno name space. Even devices appear as small directories with a few files named "data," "ctl," "status," etc.
Reference: [MacKenzie95] <author> D. MacKenzie. Autoconf: </author> <title> Creating Automatic Configuration Scripts. User Manual, Edition 2.7, for Autoconf version 2.7. Free Software Foundation, </title> <month> November </month> <year> 1995. </year>
Reference-contexts: I was surprised and pleased to find that the latest GNU tools were able to properly build and link Solaris kernel modules. For more details on how I will achieve portability using GNU Autoconf <ref> [MacKenzie95] </ref>, see Appendix E. 3.6.2 Performance The tests I ran included 24 hours of continuous application of common user programs: ls, du, find, mkdir and rm. These programs were invoked from a simple driver shell script that ran each one of them in turn. <p> As of this writing, much work on Amd was done to prepare it for FiST. I have converted Amd to using GNU Autoconf, and in the process learned much and wrote many useful M4 tests <ref> [MacKenzie95] </ref>. Amd is near ready to handle FiST generated file system modules. 3.7 User Level Operation 23 No. <p> Often, complex installations tend to have poor configurations. A good solution to portability must be able to handle all of these cases. The Free Software Foundation (FSF) solved these problems using a dynamic, automatic configuration system called Autoconf <ref> [MacKenzie95] </ref>, which I plan to use with FiST. Autoconf is a large collection of highly portable M4 macros and Bourne shell scripts that perform on-the-fly feature tests to determine differences among systems.
Reference: [Marsh94] <author> B. Marsh, F. Douglis, and P. Krishnan. </author> <title> Flash Memory File Caching for Mobile Computers. </title> <type> Technical report. </type> <institution> Matsushita Information Technology Laboratory, U.S., </institution> <year> 1994. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95].
Reference: [McKusick84] <author> M. K. McKusick, W. N. Joy, S. J. Le*er, and R. S. Fabry. </author> <title> A fast file system for UNIX. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-97, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: These file systems are usually aware of and often optimized for specific device characteristics, as shown in Figure 2. Examples of such file systems include * The Berkeley Fast File System (FFS) <ref> [McKusick84] </ref> for physical disks. * Sun Microsystem's UFS [LoVerso91], an optimized version of FFS. * The LFS "log structured" file system, optimized for sequential writes [Rosenblum91] on hard disks. 2.1 Types of File Systems 5 * NFS [Sandberg85, Pawlowski94], that uses the network as its file system "device." 1 * The
Reference: [Mercer94] <author> C. Mercer, S. Savage, and H. Tokuda. </author> <title> Processor Capacity Reserves: Operating System Support for Multimedia Applications. </title> <booktitle> Proceedings of the IEEE International Conference on Multimedia Computing and Systems, </booktitle> <pages> pages 90-9, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Four example domains include: 1. Multimedia: with the explosion of the Internet, Web content developers would like a file system that can store HTML, image, and audio files more efficiently so they can be retrieved faster with HTTP servers, or be played back in real-time <ref> [Anderson92, Ramakrishnan93, Fall94, Mercer94, Pasquale94] </ref>. 2. Databases: researchers are looking for methods to improve the performance of Unix file systems, and/or for file systems that provide built-in support for concurrency [Stonebraker81, Stonebraker86]. 3.
Reference: [Minnich93] <author> R. G. Minnich. </author> <title> The AutoCacher: A File Cache Which Operates at the NFS Level. </title> <booktitle> USENIX Technical Conference Proceedings (San Diego, </booktitle> <address> CA), </address> <pages> pages 77-83. </pages> <publisher> USENIX, </publisher> <month> Winter </month> <year> 1993. </year> <note> 82 REFERENCES </note>
Reference-contexts: system hangs or exits, processes that access the now-dead file system live on, possibly propagating erroneous results to other processes and machines. 2 Examples of out-of-kernel file systems are the Amd [Pendry91, Stewart93] and Automountd [Callaghan89] automounters, Blaze's Cfsd encrypting file system [Blaze93], and Amd derivatives including Hlfsd [Zadok93b], AutoCacher <ref> [Minnich93] </ref>, and Restore-o-Mounter [Moran93]. A few file systems at the user level have been implemented as a user-level library. One such example is Systas [Lord96], a file system for Linux that adds an extra measure of flexibility by allowing users to write Scheme code to implement the file system semantics.
Reference: [Mitchel94] <author> J. G. Mitchel, J. J. Giobbons, G. Hamilton, P. B. Kessler, Y. A. Khalidi, P. Kougiouris, P. W. Madany, M. N. Nelson, M. L. Powell, and S. R. Radia. </author> <title> An Overview of the Spring System. </title> <booktitle> CompCon Conference Proceedings (San Francisco, California). CompCon, </booktitle> <year> 1994. </year>
Reference-contexts: Finally, there is no language available for producing modules that will work within StackFS. Still, PLC's products are the only known commercially available stackable file system implementation. 6.4 Spring Spring is an object oriented research operating system built by Sun Microsystems Laboratories <ref> [Mitchel94] </ref>. It was designed as a set of cooperating servers on top of a microkernel. Spring uses a modified Interface Definition Language (IDL) [Stone87, Warren87] as outlined in the CORBA specifications [CORBA91] to define the interfaces between the different servers.
Reference: [Moran93] <author> J. Moran and B. Lyon. </author> <title> The Restore-o-Mounter: The File Motel Revisited. </title> <booktitle> USENIX Conference Proceedings (Cincinnati, </booktitle> <address> OH), </address> <pages> pages 45-58. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1993. </year>
Reference-contexts: exits, processes that access the now-dead file system live on, possibly propagating erroneous results to other processes and machines. 2 Examples of out-of-kernel file systems are the Amd [Pendry91, Stewart93] and Automountd [Callaghan89] automounters, Blaze's Cfsd encrypting file system [Blaze93], and Amd derivatives including Hlfsd [Zadok93b], AutoCacher [Minnich93], and Restore-o-Mounter <ref> [Moran93] </ref>. A few file systems at the user level have been implemented as a user-level library. One such example is Systas [Lord96], a file system for Linux that adds an extra measure of flexibility by allowing users to write Scheme code to implement the file system semantics.
Reference: [Mummert95] <author> L. B. Mummert, M. R. Ebling, and M. Satyanarayanan. </author> <title> Exploiting weak connectivity for mobile file access. </title> <booktitle> Fifteenth ACM Symposium on Operating Systems Principles (Copper Mountain Resort, </booktitle> <institution> CO). Association for Computing Machinery SIGOPS, </institution> <month> 3-6 December </month> <year> 1995. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95].
Reference: [Pasquale94] <author> J. Pasquale, E. Anderson, and K. Muller. </author> <title> Container Shipping: Operating System Support for I/O-Intensive Applications. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 84-93, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Four example domains include: 1. Multimedia: with the explosion of the Internet, Web content developers would like a file system that can store HTML, image, and audio files more efficiently so they can be retrieved faster with HTTP servers, or be played back in real-time <ref> [Anderson92, Ramakrishnan93, Fall94, Mercer94, Pasquale94] </ref>. 2. Databases: researchers are looking for methods to improve the performance of Unix file systems, and/or for file systems that provide built-in support for concurrency [Stonebraker81, Stonebraker86]. 3.
Reference: [Pawlowski94] <author> B. Pawlowski, C. Juszczak, P. Staubach, C. Smith, D. Lebel, and D. Hitz. </author> <title> NFS Version 3 Design and Implementation. </title> <booktitle> USENIX Conference Proceedings (Boston, </booktitle> <address> Massachusetts), </address> <pages> pages 137-52. </pages> <publisher> USENIX, </publisher> <month> 6-10 June </month> <year> 1994. </year>
Reference-contexts: It allows higher level operating system modules to perform operations on vnodes. The vnode interface was invented by Sun Microsystems to facilitate the coexistence of multiple file systems [Kleiman86], specifically the local file system that manages disk storage and the NFS <ref> [Sun89, Pawlowski94] </ref> remote file system. When a vnode represents storage (such as a file or directory), it does not expose what type of physical file system implements the storage. <p> Examples of such file systems include * The Berkeley Fast File System (FFS) [McKusick84] for physical disks. * Sun Microsystem's UFS [LoVerso91], an optimized version of FFS. * The LFS "log structured" file system, optimized for sequential writes [Rosenblum91] on hard disks. 2.1 Types of File Systems 5 * NFS <ref> [Sandberg85, Pawlowski94] </ref>, that uses the network as its file system "device." 1 * The High-Sierra file system (HSFS, ISO9660) for CD-ROMs [Kao89]. * The FAT-based file system originally developed for DOS [Tanenbaum92], and later adapted for Unix machines to access a floppy as a native PC-based file system (PCFS) [Forin94]. <p> Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95]. An easy way to use encryption in file systems [Blaze93, Gutmann96, Boneh96] and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) <ref> [Kramer88, Pawlowski94] </ref> are also highly desirable [Bishop88, Kardel90]. Researchers and developers have always needed an environment where they can quickly prototype and test new file system ideas. Several earlier works attempted to provide the necessary flexibility. <p> Therefore, there is a straightforward mapping of vnode operations to NFS operations, as shown in Table 3. Accordingly, the same "engine" can easily generate both kernel vnode-layer code and NFS code. See the examples in Appendix C. Automatically generating code for the latest NFS protocol (version 3) <ref> [Pawlowski94] </ref> is only marginally more difficult, as can be seen in Table 4. There are several new calls that exist only in version 3 of NFS, but they can be safely ignored because there is no direct mapping from a vnode operation to them.
Reference: [Pendry91] <author> J.-S. Pendry and N. Williams. </author> <title> Amd The 4.4 BSD Automounter. User Manual, edition 5.3 alpha. </title> <institution> Imperial College of Science, Technology, and Medicine, </institution> <address> London, England, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: In contrast, when an out of kernel file system hangs or exits, processes that access the now-dead file system live on, possibly propagating erroneous results to other processes and machines. 2 Examples of out-of-kernel file systems are the Amd <ref> [Pendry91, Stewart93] </ref> and Automountd [Callaghan89] automounters, Blaze's Cfsd encrypting file system [Blaze93], and Amd derivatives including Hlfsd [Zadok93b], AutoCacher [Minnich93], and Restore-o-Mounter [Moran93]. A few file systems at the user level have been implemented as a user-level library. <p> Several past works | such as Skinner and Wong's "Interposer Toolkit" | began to address the issue of describing file systems using a higher-level language. The most successful of all is the simple (albeit limited) language used by Amd <ref> [Pendry91, Stewart93] </ref> to describe map entries, their types, semantics, etc. Recent work on file system simulators [Bosch96] also moves in this direction, but unfortunately requires a radically different (object oriented) file system interface. <p> Hlfs could be used in conjunction with a cryptographic file system to provide user-specific encryption file systems. B.2.11 Automountfs A file system that would perform automounter functions much like Amd <ref> [Pendry91] </ref> does, but in the kernel. It can therefore avoid locking and work much faster. There is only one problem: Amd as it stands knows about the underlying types of file systems that it automounts.
Reference: [Pendry95] <author> J.-S. Pendry and M. K. McKusick. </author> <title> Union mounts in 4.4BSD-Lite. </title> <booktitle> Conference Proceedings of the USENIX 1995 Technical Conference on UNIX and Advanced Computing Systems (New Orleans), </booktitle> <pages> pages 25-33. </pages> <publisher> Usenix Association, </publisher> <month> 16-20 January </month> <year> 1995. </year>
Reference-contexts: BSD's nullfs does not create any infrastructure for stacking; all it does is allow mounting one part of the file system in a different location. It proved useful as a template from which 4.4 BSD's Union file system was written <ref> [Pendry95] </ref>. The latter was developed by extending nullfs to merge the mount point file system and the mounted one, rather than blindly forward vnode and VFS operations to the new mount point. <p> B.2.9 Unionfs A file system that presents the union of all the files and directories of several file systems. Special mount options are needed to define the semantics of collision resolution <ref> [Pendry95] </ref>. 9 This is what's called "security by obscurity." 60 B APPENDIX: TYPICAL STACKABLE FILE SYSTEMS B.2.10 Hlfs A file system that uses the user credentials (primarily uid and gid) to create symbolic links different for each user and group, much the way Hlfsd does [Zadok93b].
Reference: [Pike90] <author> R. Pike, D. Presotto, K. Thompson, and H. Trickey. </author> <title> Plan 9 from Bell Labs. </title> <booktitle> Proceedings of Summer UKUUG Conference, </booktitle> <pages> pages 1-9, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Nevertheless, the HURD offers an interface that is comparable to the vnode one and more. 6.2 Plan 9 Plan 9 was developed at Bell Labs in the late 1980's <ref> [Pike90, Pike91, Presotto93] </ref>. The Plan 9 approach to file system extension is similar to that of Unix. The Plan 9 mount system call provides a file descriptor that can be a user process or remote file server.
Reference: [Pike91] <author> R. Pike, D. Presotto, K. Thompson, and H. Trickey. </author> <title> Plan 9, a distributed system. </title> <booktitle> Proceedings of Spring EurOpen Conference, </booktitle> <pages> pages 43-50, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Nevertheless, the HURD offers an interface that is comparable to the vnode one and more. 6.2 Plan 9 Plan 9 was developed at Bell Labs in the late 1980's <ref> [Pike90, Pike91, Presotto93] </ref>. The Plan 9 approach to file system extension is similar to that of Unix. The Plan 9 mount system call provides a file descriptor that can be a user process or remote file server.
Reference: [PLC96] <author> PLC. StackFS: </author> <title> The Stackable File System Architecture. Online White-Paper. Programmed Logic Corporation, </title> <note> 1996. Available via the WWW in http://www.plc.com/st-wp.html. </note>
Reference-contexts: Among their offerings are a compression file system, a 64-bit file system, a high-throughput file system utilizing transactions, and a stackable file system. PLC's StackFS <ref> [PLC96] </ref> is very similar to my wrapper file system described in Appendix B.2.1. StackFS allows for different modules to be plugged in a variety of ways to provide new functionality. Modules offering 64-bit access, mirroring, union, hierarchical storage management (HSM), FTP, Caching, and others are available.
Reference: [Presotto93] <author> D. Presotto and P. Winterbottom. </author> <title> The Organization of Networks in Plan 9. </title> <booktitle> USENIX Technical Conference Proceedings (San Diego, </booktitle> <address> CA), </address> <pages> pages 271-80. </pages> <publisher> USENIX, </publisher> <month> Winter </month> <year> 1993. </year>
Reference-contexts: Nevertheless, the HURD offers an interface that is comparable to the vnode one and more. 6.2 Plan 9 Plan 9 was developed at Bell Labs in the late 1980's <ref> [Pike90, Pike91, Presotto93] </ref>. The Plan 9 approach to file system extension is similar to that of Unix. The Plan 9 mount system call provides a file descriptor that can be a user process or remote file server.
Reference: [Ramakrishnan93] <author> K. Ramakrishnan, L. Vaitzblit, C. Gray, U. Vahalia, D. Ting, P. Tzelnic, S. Glasner, and W. Duso. </author> <title> Operating System Support for a Video-on-Demand File Service. </title> <booktitle> Proceedings of 4th Int. Workshop on Network and Operating Systems Support for Digital Audio and Video (Lancaster, </booktitle> <address> UK), </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Four example domains include: 1. Multimedia: with the explosion of the Internet, Web content developers would like a file system that can store HTML, image, and audio files more efficiently so they can be retrieved faster with HTTP servers, or be played back in real-time <ref> [Anderson92, Ramakrishnan93, Fall94, Mercer94, Pasquale94] </ref>. 2. Databases: researchers are looking for methods to improve the performance of Unix file systems, and/or for file systems that provide built-in support for concurrency [Stonebraker81, Stonebraker86]. 3.
Reference: [Rees86] <author> J. Rees, P. H. Levine, N. Mishkin, and P. J. Leach. </author> <title> An Extensible I/O System. </title> <booktitle> USENIX Conference Proceedings (Atlanta, </booktitle> <address> GA), </address> <pages> pages 114-25. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1986. </year>
Reference-contexts: Researchers and developers have always needed an environment where they can quickly prototype and test new file system ideas. Several earlier works attempted to provide the necessary flexibility. Apollo's I/O system was extendible through user-level libraries that changed the behavior of the application linking with them <ref> [Rees86] </ref>; now, modern support for shared libraries [Gingell87a] permits new functionality to be loaded by the run-time linker. One of the first attempts to extend file system functionality was "watchdogs" [Bershad88], a mechanism for trapping file system operations and running user-written code as part of the operation.
Reference: [Ritchie84] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-910, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: The vnodes are chained together. A vnode interface operation proceeds from the head of the chain to the tail, operating on each vnode, and aborting if an error occurs. This mechanism, which is similar to the way Stream I/O modules <ref> [Ritchie84] </ref> operate, is depicted in Figure 5. 10 2 BACKGROUND This simple interface alone was capable of combining several instances of existing UFS or NFS file systems to provide replication, caching, and fall-back file systems, among other services.
Reference: [Rodriguez86] <author> R. Rodriguez, M. Koehler, and R. Hyde. </author> <title> The generic file system. </title> <booktitle> 1986 Summer USENIX Technical Conference (Atlanta, </booktitle> <address> GA, </address> <month> June </month> <year> 1986), </year> <pages> pages 260-9. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year> <note> REFERENCES 83 </note>
Reference-contexts: It is now universally present in Unix operating systems. Readers not familiar with the vnode interface may refer to Appendix A for a tutorial on the subject. The designers of the original vnode interface envisioned "pluggable" file system modules <ref> [Rodriguez86] </ref>, but this capability was not present at the beginning. Through the 1980s Sun made at least three revisions of the interface designed to enhance plugability [Rosenthal90].
Reference: [Rosenblum91] <author> M. Rosenblum and J. K. Ousterhout. </author> <title> The design and implementation of a log-structured file system. </title> <booktitle> Proceedings of 13th ACM Symposium on Operating Systems Principles (Asilomar, </booktitle> <address> Pacific Grove, CA), </address> <pages> pages 1-15. </pages> <institution> Association for Computing Machinery SIGOPS, </institution> <month> 13 October </month> <year> 1991. </year>
Reference-contexts: Examples of such file systems include * The Berkeley Fast File System (FFS) [McKusick84] for physical disks. * Sun Microsystem's UFS [LoVerso91], an optimized version of FFS. * The LFS "log structured" file system, optimized for sequential writes <ref> [Rosenblum91] </ref> on hard disks. 2.1 Types of File Systems 5 * NFS [Sandberg85, Pawlowski94], that uses the network as its file system "device." 1 * The High-Sierra file system (HSFS, ISO9660) for CD-ROMs [Kao89]. * The FAT-based file system originally developed for DOS [Tanenbaum92], and later adapted for Unix machines to
Reference: [Rosenthal90] <author> D. S. H. Rosenthal. </author> <title> Evolving the Vnode Interface. </title> <booktitle> USENIX Conference Proceedings (Anaheim, </booktitle> <address> CA), </address> <pages> pages 107-18. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1990. </year>
Reference-contexts: The implementation of Replicfs calls three different file systems. Fan-in can exist, too. There is no reason to restrict the stacking concept to a linear stack or chain of file systems. 1.1 The Problem Despite the promise of vnode stacking, not one of several proposed implementations <ref> [Rosenthal90, Rosenthal92, Heidemann94, Skinner93] </ref> has made it into mainstream operating systems, even though several of the proposals were made by an operating system vendor (Sun Microsystems). All previous proposals for vnode stacking required substantial changes to the definitions of the vnode and the vnode interface. <p> The designers of the original vnode interface envisioned "pluggable" file system modules [Rodriguez86], but this capability was not present at the beginning. Through the 1980s Sun made at least three revisions of the interface designed to enhance plugability <ref> [Rosenthal90] </ref>. <p> One of the first attempts to extend file system functionality was "watchdogs" [Bershad88], a mechanism for trapping file system operations and running user-written code as part of the operation. Vnode stacking was first implemented by Rosenthal (in SunOS 4.1) around 1990 <ref> [Rosenthal90] </ref>. His work was both the first implementation of the plugability concept and also a clean-up effort in response to changes that had been required to support integration of SunOS and System V and to merge the file system's buffer cache with the virtual memory system. <p> This was partially done by removing old vnode calls such as vn bread and adding new ones such as vn map <ref> [Rosenthal90] </ref>. Changing the vnode interface was akin to changing the "language" with which a file system implementor "spoke" with the kernel. Several past works | such as Skinner and Wong's "Interposer Toolkit" | began to address the issue of describing file systems using a higher-level language. <p> The performance degradation added by my mechanism would be small. 47 A Appendix: Vnode Interface Tutorial This section provides a simple introduction to the vnode interface. The information herein is gathered from pivotal papers on the subject <ref> [Kleiman86, Rosenthal90] </ref> and from system C header files | specifically &lt;sys/vfs.h&gt; and &lt;sys/vnode.h&gt;. The two important data structures used in the vnode interface are struct vfs and struct vnode, depicted in Figures 21 and 25, respectively.
Reference: [Rosenthal92] <author> D. S. H. Rosenthal. </author> <title> Requirements for a "Stacking" Vnode/VFS Interface. Unix International document SD-01-02-N014. </title> <booktitle> UNIX International, </booktitle> <year> 1992. </year>
Reference-contexts: This "virtual file system" concept has proven very useful, and nearly every version of Unix includes some version of vnodes and a vnode interface. One notable improvement to the vnode concept is "vnode stack File System ing," <ref> [Rosenthal92, Heidemann94, Skinner93] </ref> a technique for mod-ularizing file system functions. The idea is to allow one vnode interface to call another. Before stacking existed, there was only a single vnode interface. Higher level operating systems code called the vnode interface which in turn called code for a specific file system. <p> The implementation of Replicfs calls three different file systems. Fan-in can exist, too. There is no reason to restrict the stacking concept to a linear stack or chain of file systems. 1.1 The Problem Despite the promise of vnode stacking, not one of several proposed implementations <ref> [Rosenthal90, Rosenthal92, Heidemann94, Skinner93] </ref> has made it into mainstream operating systems, even though several of the proposals were made by an operating system vendor (Sun Microsystems). All previous proposals for vnode stacking required substantial changes to the definitions of the vnode and the vnode interface. <p> Rosenthal's interface was never made public or incorporated into Sun's operating systems. A few similar works followed Rosenthal, such as further prototypes for extended file systems in SunOS [Skinner93], and the Ficus layered file system [Guy90, Heidemann91] at UCLA. 2.2.2.1 Interposition and Composition Later works <ref> [Rosenthal92, Skinner93] </ref> established the current terminology for the field, discarding "stacking" in favor of "interposition" and "composition." The term "stacking" was considered at once to have too many implications, to be too vague, and to imply only a linear LIFO structure with no fan-in or fan-out. <p> Interposition is the new term for stacking. The defining papers <ref> [Rosenthal92, Skinner93] </ref> explain a particular implementation of interposition based on a new definition of vnode. The new vnode contains only the public fields of the old vnode and a new data structure called a pvnode contains the private fields of the old vnode. <p> Interposed functionality is represented by one pvnode per open file. Pvnodes may contain pointers to other vnodes, with the effect that all the linked vnodes may need to be regarded as a single object. This effect is called composition. Composition, in particular, requires the following two capabilities <ref> [Rosenthal92] </ref>: 1. The ability to lock a complete interposition chain with one operation. 4 Actually a DAG, to provide fan-in and fan-out. 2.3 Barriers to File System Experimentation 11 2. Treating an interposition chain as an atomic unit.
Reference: [Sandberg85] <author> R. Sandberg, D. Goldberg, S. Kleiman, D. Walsh, and B. Lyon. </author> <title> Design and implementation of the Sun Network Filesystem. </title> <booktitle> USENIX Association Summer Conference Proceedings of 1985 (11-14 June 1985, </booktitle> <address> Portland, OR), </address> <pages> pages 119-30. </pages> <publisher> USENIX Association, </publisher> <address> El Cerrito, CA, </address> <year> 1985. </year>
Reference-contexts: Examples of such file systems include * The Berkeley Fast File System (FFS) [McKusick84] for physical disks. * Sun Microsystem's UFS [LoVerso91], an optimized version of FFS. * The LFS "log structured" file system, optimized for sequential writes [Rosenblum91] on hard disks. 2.1 Types of File Systems 5 * NFS <ref> [Sandberg85, Pawlowski94] </ref>, that uses the network as its file system "device." 1 * The High-Sierra file system (HSFS, ISO9660) for CD-ROMs [Kao89]. * The FAT-based file system originally developed for DOS [Tanenbaum92], and later adapted for Unix machines to access a floppy as a native PC-based file system (PCFS) [Forin94].
Reference: [Satyanarayanan90] <author> M. Satyanarayanan, J. J. Kistler, P. Kumar, M. E. Okasaki, E. H. Siegel, and D. C. Steere. Coda: </author> <title> A Highly Available File System for a Distributed Workstation Environment. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39 </volume> <pages> 447-59, </pages> <year> 1990. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95].
Reference: [Skinner93] <author> G. C. Skinner and T. K. Wong. </author> <title> "Stacking" Vnodes: A Progress Report. </title> <booktitle> USENIX Conference Proceedings (Cincinnati, </booktitle> <address> OH), </address> <pages> pages 161-74. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1993. </year>
Reference-contexts: This "virtual file system" concept has proven very useful, and nearly every version of Unix includes some version of vnodes and a vnode interface. One notable improvement to the vnode concept is "vnode stack File System ing," <ref> [Rosenthal92, Heidemann94, Skinner93] </ref> a technique for mod-ularizing file system functions. The idea is to allow one vnode interface to call another. Before stacking existed, there was only a single vnode interface. Higher level operating systems code called the vnode interface which in turn called code for a specific file system. <p> The implementation of Replicfs calls three different file systems. Fan-in can exist, too. There is no reason to restrict the stacking concept to a linear stack or chain of file systems. 1.1 The Problem Despite the promise of vnode stacking, not one of several proposed implementations <ref> [Rosenthal90, Rosenthal92, Heidemann94, Skinner93] </ref> has made it into mainstream operating systems, even though several of the proposals were made by an operating system vendor (Sun Microsystems). All previous proposals for vnode stacking required substantial changes to the definitions of the vnode and the vnode interface. <p> Rosenthal's interface was never made public or incorporated into Sun's operating systems. A few similar works followed Rosenthal, such as further prototypes for extended file systems in SunOS <ref> [Skinner93] </ref>, and the Ficus layered file system [Guy90, Heidemann91] at UCLA. 2.2.2.1 Interposition and Composition Later works [Rosenthal92, Skinner93] established the current terminology for the field, discarding "stacking" in favor of "interposition" and "composition." The term "stacking" was considered at once to have too many implications, to be too vague, and <p> Rosenthal's interface was never made public or incorporated into Sun's operating systems. A few similar works followed Rosenthal, such as further prototypes for extended file systems in SunOS [Skinner93], and the Ficus layered file system [Guy90, Heidemann91] at UCLA. 2.2.2.1 Interposition and Composition Later works <ref> [Rosenthal92, Skinner93] </ref> established the current terminology for the field, discarding "stacking" in favor of "interposition" and "composition." The term "stacking" was considered at once to have too many implications, to be too vague, and to imply only a linear LIFO structure with no fan-in or fan-out. <p> Interposition is the new term for stacking. The defining papers <ref> [Rosenthal92, Skinner93] </ref> explain a particular implementation of interposition based on a new definition of vnode. The new vnode contains only the public fields of the old vnode and a new data structure called a pvnode contains the private fields of the old vnode. <p> It is also binary compatible across Solaris 2.4 and 2.5 (SPARC architecture). Loadable kernel modules are rarely binary compatible across operating system revisions, as was mentioned in Skinner and Wong's work <ref> [Skinner93] </ref>. I started this work with proprietary Solaris kernel sources. I extracted from these sources the minimum requirements for building file system modules, and then rewrote the code. At this point, I no longer require any access to proprietary sources. <p> Therefore, the overhead of the first version of Wrapfs is comparable to the mechanisms implemented by Skinner and Wong <ref> [Skinner93] </ref> (up to 10%) and the UCLA stackable layers project [Heidemann94] (3%). 3.7 User Level Operation The FiST compiler can easily generate either kernel-resident or user-level code from the same input. Kernel code implements the vnode interface. User level code implements the NFS interface.
Reference: [SMCC90] <author> SMCC. syslogd(8). </author> <title> SunOS 4.1 Reference Manual, </title> <type> Section 8. </type> <institution> Sun Microsystems, Incorporated, </institution> <month> January, </month> <year> 1990. </year>
Reference-contexts: Therefore, at the moment, I see no reason to allow Statefs to be directly interposed upon. B.2.4 Snoopfs A file system that will tell you who accessed what files or directories, and when. The file system will record, via direct console messages or syslog <ref> [SMCC90] </ref>, the uid and gid of a process accessing files in this file system, the names of the files or directories, and the time of access.
Reference: [SMCC91] <author> SMCC. config(8). </author> <title> SunOS 4.1 Reference Manual, </title> <type> Section 8. </type> <institution> Sun Microsystems, Incorporated, </institution> <month> 10 April </month> <year> 1991. </year>
Reference-contexts: able to generate runnable user-level file system code as described in Section 4.10. * The translator should generate kernel modules that can be dynamically loaded into a running kernel using facilities such as modload [SMCC93a], or linked with other kernel objects to produce a static image of a new kernel <ref> [SMCC91] </ref>. The latter can then be copied over to the root directory and run when the machine is next rebooted. * The translator should take the worst-case approach. Any minor problem with the input file or the code generation phase should result in fatal errors.
Reference: [SMCC93a] <author> SMCC. modload(1M). </author> <title> SunOS 5.5 Reference Manual, </title> <institution> Section 1M. Sun Microsystems, Incorporated, </institution> <month> 1 December </month> <year> 1993. </year>
Reference-contexts: should generate runnable kernel-resident code as described in Section 4.3.1. * The translator should also be able to generate runnable user-level file system code as described in Section 4.10. * The translator should generate kernel modules that can be dynamically loaded into a running kernel using facilities such as modload <ref> [SMCC93a] </ref>, or linked with other kernel objects to produce a static image of a new kernel [SMCC91]. The latter can then be copied over to the root directory and run when the machine is next rebooted. * The translator should take the worst-case approach.
Reference: [SMCC93b] <author> SMCC. </author> <title> Overview of Online: </title> <booktitle> DiskSuite. In Online DiskSuite 2.0 Administration Guide, </booktitle> <pages> pages 31-6. SunSoft, </pages> <month> May, </month> <year> 1993. </year>
Reference-contexts: They typically implement "meta" operations on files or groups of files, relying on other device level file systems for file access. Examples include Solaris' Cachefs [SunSoft94], and the Online Disk-Suite (OLDS) of file systems (offering mirroring, striping, and device concatenation) <ref> [SMCC93b] </ref>. For example, the mirroring file system of the Online Disk-Suite is a module that stacks on top of two or more physical file systems. Each vnode operation in the mirroring file system performs "meta" operations on the native file systems it stacked on top of.
Reference: [SMCC94a] <author> SMCC. kadb(1M). </author> <title> SunOS 5.4 Reference Manual, </title> <institution> Section 1M. Sun Microsystems, Incorporated, </institution> <month> 2 June </month> <year> 1994. </year>
Reference-contexts: Every small change takes a long edit-compile-run-debug cycle, with kernel crashes and lack of debugging tools <ref> [Golub90, Stallman94, SMCC94a] </ref> making the task frustrating. Worse, file system code developed for one operating system is almost never portable to another.
Reference: [SMCC94b] <author> SMCC. swap(1M). </author> <title> SunOS 5.5 Reference Manual, </title> <institution> Section 1M. Sun Microsystems, Incorporated, </institution> <month> 2 March </month> <year> 1994. </year>
Reference-contexts: This function has to manually create and initialize all of these resources. * vfs swapvp returns a vnode specific to a particular device onto which the system can swap. It is used for example when adding a file as a virtual swap device via the swap -a command <ref> [SMCC94b] </ref>. The VFS operations get invoked transparently via macros that dereference the operations vector's field for that operation, and pass along the vfs and the arguments it needs. Each VFS operation has a macro associated with it, located in &lt;sys/vfs.h&gt;.
Reference: [SMCC95] <author> SMCC. crash(1M). </author> <title> SunOS 5.5 Reference Manual, </title> <institution> Section 1M. Sun Microsystems, Incorporated, </institution> <month> 25 January </month> <year> 1995. </year>
Reference-contexts: This is used as the last action performed when a kernel panics and needs to save state for post-mortem recovery by tools such as crash <ref> [SMCC95] </ref>. * vop pathconf supports the POSIX path configuration standard. This call returns various con figurable file or directory variables. * vop pageio performs I/O directly on mapped pages of a file. * vop dumpctl works in conjunction with vop dump.
Reference: [Stallman94] <author> R. M. Stallman and R. H. Pesch. </author> <title> The GNU Source-Level Debugger. User Manual, Edition 4.12, for GDB version 4.13. Free Software Foundation, </title> <month> January </month> <year> 1994. </year>
Reference-contexts: Every small change takes a long edit-compile-run-debug cycle, with kernel crashes and lack of debugging tools <ref> [Golub90, Stallman94, SMCC94a] </ref> making the task frustrating. Worse, file system code developed for one operating system is almost never portable to another.
Reference: [Steiner88] <author> J. G. Steiner, C. Neuman, and J. I. Schiller. </author> <title> Kerberos: An Authentication Service for Open Network Systems. </title> <booktitle> USENIX Conference Proceedings (Dallas, TX), </booktitle> <pages> pages 191-202. </pages> <publisher> USENIX, </publisher> <month> Winter </month> <year> 1988. </year> <note> 84 REFERENCES </note>
Reference-contexts: Security: more secure file systems are sought, especially ones that securely export files over the network <ref> [Steiner88, Haynes92, Glover93, Takahashi95] </ref>. An easy way to use encryption in file systems [Blaze93, Gutmann96, Boneh96] and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable [Bishop88, Kardel90].
Reference: [Stewart93] <author> J. N. Stewart. </author> <title> AMD The Berkeley Automounter, Part 1. ;login:, </title> <booktitle> 18(3):19. USENIX, </booktitle> <month> May/June </month> <year> 1993. </year>
Reference-contexts: In contrast, when an out of kernel file system hangs or exits, processes that access the now-dead file system live on, possibly propagating erroneous results to other processes and machines. 2 Examples of out-of-kernel file systems are the Amd <ref> [Pendry91, Stewart93] </ref> and Automountd [Callaghan89] automounters, Blaze's Cfsd encrypting file system [Blaze93], and Amd derivatives including Hlfsd [Zadok93b], AutoCacher [Minnich93], and Restore-o-Mounter [Moran93]. A few file systems at the user level have been implemented as a user-level library. <p> Several past works | such as Skinner and Wong's "Interposer Toolkit" | began to address the issue of describing file systems using a higher-level language. The most successful of all is the simple (albeit limited) language used by Amd <ref> [Pendry91, Stewart93] </ref> to describe map entries, their types, semantics, etc. Recent work on file system simulators [Bosch96] also moves in this direction, but unfortunately requires a radically different (object oriented) file system interface.
Reference: [Stone87] <author> D. L. Stone and J. R. Nestor. </author> <title> IDL: background and status. </title> <journal> SIGPLAN Notices, </journal> <volume> 22(11) </volume> <pages> 5-9, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: It was designed as a set of cooperating servers on top of a microkernel. Spring uses a modified Interface Definition Language (IDL) <ref> [Stone87, Warren87] </ref> as outlined in the CORBA specifications [CORBA91] to define the interfaces between the different servers.
Reference: [Stonebraker81] <author> M. Stonebraker. </author> <title> Operating system support for database management. </title> <journal> Communications of the ACM, </journal> <volume> 24(7) </volume> <pages> 412-18, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Databases: researchers are looking for methods to improve the performance of Unix file systems, and/or for file systems that provide built-in support for concurrency <ref> [Stonebraker81, Stonebraker86] </ref>. 3. Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95]. 4.
Reference: [Stonebraker86] <author> M. Stonebraker and A. Kumar. </author> <title> Operating system support for data management. </title> <journal> Database Engineering, </journal> <volume> 9(3) </volume> <pages> 43-51, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Databases: researchers are looking for methods to improve the performance of Unix file systems, and/or for file systems that provide built-in support for concurrency <ref> [Stonebraker81, Stonebraker86] </ref>. 3. Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95]. 4.
Reference: [Sun89] <author> Sun Microsystems, Incorporated. NFS: </author> <title> Network File System protocol specification, </title> <type> Technical report RFC-1094, </type> <month> March </month> <year> 1989. </year>
Reference-contexts: It allows higher level operating system modules to perform operations on vnodes. The vnode interface was invented by Sun Microsystems to facilitate the coexistence of multiple file systems [Kleiman86], specifically the local file system that manages disk storage and the NFS <ref> [Sun89, Pawlowski94] </ref> remote file system. When a vnode represents storage (such as a file or directory), it does not expose what type of physical file system implements the storage.
Reference: [SunSoft94] <author> SunSoft. </author> <title> Cache File System (CacheFS). A White-Paper. </title> <institution> Sun Microsystems, Incorporated, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: They typically implement "meta" operations on files or groups of files, relying on other device level file systems for file access. Examples include Solaris' Cachefs <ref> [SunSoft94] </ref>, and the Online Disk-Suite (OLDS) of file systems (offering mirroring, striping, and device concatenation) [SMCC93b]. For example, the mirroring file system of the Online Disk-Suite is a module that stacks on top of two or more physical file systems. <p> For example Cachefs as described in Appendix B.3.1 and <ref> [SunSoft94] </ref>. * User-level file systems produced automatically using FiST against user-level hand written ones. <p> Generally the state would be stored on a local hard-disk, but remote file servers can be used just as easily. B.3.1 Cachefs This is very similar to Sun's Cachefs <ref> [SunSoft94] </ref>. However, Sun's implementation allows for writes through the cache. For simplicity, my initial implementation would pass writing operations directly to the source file system being cached. B.3 Persistent File Systems 61 B.3.2 Replicfs A simple replicated (mirroring) file system.
Reference: [Tait91] <author> C. Tait and D. Duchamp. </author> <title> Service Interface and Replica Consistency Algorithm for Mobile File System Clients. </title> <booktitle> 1st International Conference on Parallel and Distributed Information Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95].
Reference: [Tait92] <author> C. D. Tait and D. Duchamp. </author> <title> An Efficient Variable-Consistency Replicated File Service. </title> <type> Technical report. </type> <institution> Department of Computer Science, Columbia University, New York, U.S., </institution> <year> 1992. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95].
Reference: [Takahashi95] <author> T. Takahashi, A. Shimbo, and M. Murota. </author> <title> File-Based Network Collaboration System. </title> <booktitle> The Fifth USENIX UNIX Security Symposium Proceedings (Salt Lake City, Utah), </booktitle> <pages> pages 95-104. </pages> <publisher> USENIX, </publisher> <month> 5-7 June </month> <year> 1995. </year>
Reference-contexts: Security: more secure file systems are sought, especially ones that securely export files over the network <ref> [Steiner88, Haynes92, Glover93, Takahashi95] </ref>. An easy way to use encryption in file systems [Blaze93, Gutmann96, Boneh96] and the ability to provide special semantics via facilities such as general purpose Access Control Lists (ACLs) [Kramer88, Pawlowski94] are also highly desirable [Bishop88, Kardel90].
Reference: [Tanenbaum92] <author> A. S. Tanenbaum. </author> <title> The MS-DOS File System. </title> <booktitle> In Modern Operating Systems, </booktitle> <pages> pages 340-2. </pages> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: structured" file system, optimized for sequential writes [Rosenblum91] on hard disks. 2.1 Types of File Systems 5 * NFS [Sandberg85, Pawlowski94], that uses the network as its file system "device." 1 * The High-Sierra file system (HSFS, ISO9660) for CD-ROMs [Kao89]. * The FAT-based file system originally developed for DOS <ref> [Tanenbaum92] </ref>, and later adapted for Unix machines to access a floppy as a native PC-based file system (PCFS) [Forin94].
Reference: [Warren87] <author> W. B. Warren, J. Kickenson, and R. Snodgrass. </author> <title> A tutorial introduction to using IDL. </title> <journal> SIGPLAN Notices, </journal> <volume> 22(11) </volume> <pages> 18-34, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: It was designed as a set of cooperating servers on top of a microkernel. Spring uses a modified Interface Definition Language (IDL) <ref> [Stone87, Warren87] </ref> as outlined in the CORBA specifications [CORBA91] to define the interfaces between the different servers.
Reference: [Zadok93a] <author> E. Zadok and D. Duchamp. </author> <title> Discovery and Hot Replacement of Replicated Read-Only File Systems, with Application to Mobile Computing. </title> <booktitle> USENIX Conference Proceedings (Cincinnati, </booktitle> <address> OH), </address> <pages> pages 69-85. </pages> <publisher> USENIX, </publisher> <month> Summer </month> <year> 1993. </year>
Reference-contexts: Mobility: replicated and distributed file systems with disconnected and caching operations figure heavily in an environment where network latency and reliability is highly variable <ref> [Satyanarayanan90, Kistler91, Tait91, Tait92, Kistler93, Zadok93a, Kuenning94, Marsh94, Mummert95] </ref>. 4. Security: more secure file systems are sought, especially ones that securely export files over the network [Steiner88, Haynes92, Glover93, Takahashi95]. <p> This could be useful by other stackable file systems that need to know file names later than when they were originally looked up. This could for example be used in work such as Zadok and Duchamp's <ref> [Zadok93a] </ref> where the need arose for mapping open vnodes to their pathnames for purposes of simple replication. B.3 Persistent File Systems Persistent file systems contain state that should not be lost; therefore it must be written to permanent media. <p> A true file version number, could be a much more efficient and reliable method to tell that, for example, one binary of emacs is for version 19.33, and another is for version 19.34. For an expanded discussion on file equivalence in a replicated environment, see <ref> [Zadok93a] </ref>. A special use for Versionfs would be a file system that is used by multiple software developers to manage source files in a large software project. Such a file system could remove the need to use tools such as RCS or CVS.
Reference: [Zadok93b] <author> E. Zadok and A. Dupuy. HLFSD: </author> <title> Delivering Email to Your $HOME. </title> <booktitle> Systems Administration (LISA VII) Conference (Monterey, </booktitle> <address> CA), </address> <pages> pages 243-54. </pages> <publisher> USENIX, </publisher> <month> 1-5 November </month> <year> 1993. </year>
Reference-contexts: kernel file system hangs or exits, processes that access the now-dead file system live on, possibly propagating erroneous results to other processes and machines. 2 Examples of out-of-kernel file systems are the Amd [Pendry91, Stewart93] and Automountd [Callaghan89] automounters, Blaze's Cfsd encrypting file system [Blaze93], and Amd derivatives including Hlfsd <ref> [Zadok93b] </ref>, AutoCacher [Minnich93], and Restore-o-Mounter [Moran93]. A few file systems at the user level have been implemented as a user-level library. <p> the semantics of collision resolution [Pendry95]. 9 This is what's called "security by obscurity." 60 B APPENDIX: TYPICAL STACKABLE FILE SYSTEMS B.2.10 Hlfs A file system that uses the user credentials (primarily uid and gid) to create symbolic links different for each user and group, much the way Hlfsd does <ref> [Zadok93b] </ref>. Hlfs could be used in conjunction with a cryptographic file system to provide user-specific encryption file systems. B.2.11 Automountfs A file system that would perform automounter functions much like Amd [Pendry91] does, but in the kernel. It can therefore avoid locking and work much faster.
References-found: 87

