URL: http://www.cs.virginia.edu/~nr/pubs/relocating-pldi.ps
Refering-URL: http://www.cs.virginia.edu/~nr/pubs/index.html
Root-URL: http://www.cs.virginia.edu
Email: nr@cs.purdue.edu  
Title: on Programming Language Design and Implementation Relocating Machine Instructions by Currying a -term into two
Author: Norman Ramsey 
Web: http://www.cs.purdue.edu/homes/nr  
Address: Building, West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences, Purdue University 1398 Computer Science  
Note: Reprinted from Proceedings of the ACM SIGPLAN '96 Conference  Currying rewrites  
Abstract: The New Jersey Machine-Code Toolkit is an application generator. It helps programmers create applications that manipulate machine code, including linkers. Guided by a short instruction-set specification, the toolkit generates the bit-manipulating code. Instructions are described by constructors, which denote functions mapping lists of operands to instructions' binary representations. Any operand can be designated as "relocatable," meaning that the operand's value need not be known at the time the instruction is encoded. For instructions with relocatable operands, the toolkit computes relocating transformations. Tool writers can use the toolkit to create machine-independent software that relocates machine instructions. mld, a retargetable linker built with the toolkit, needs only 20 lines of C code for relocation, and that code is machine-independent. The toolkit discovers relocating transformations by currying encoding functions. An attempt to encode an instruction with a relocatable operand results in the creation of a closure. The closure can be applied when the values of the relocatable operands become known. Currying provides a general, machine-independent method of relocation. Copyright c fl 1996 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that new copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept, ACM Inc., Fax +1 (212) 869-0481, or &lt;permissions@acm.org&gt;. different inner -terms|one for each instruction that uses a relocatable address. Hoisting some of the computation out of the second into the first makes many of the second s identical|a handful are enough for a whole instruction set. This optimization reduces the size of machine-dependent assembly and linking code by 15-20% for the MIPS, SPARC, and PowerPC, and by about 30% for the Pentium. It also makes the second s equivalent to relocating transformations named in standard object-file formats. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Appel, Andrew W. </author> <year> 1992. </year> <title> Compiling with Continuations. </title> <publisher> Cambridge: Cambridge University Press. </publisher>
Reference-contexts: To generate C or Modula-3 code, it helps to convert to an explicit closure-passing style <ref> (Appel 1992, Chapter 10) </ref>. Converted functions, i.e., function values, are represented by closures. A closure is a record containing a -term, which represents the function's algorithmic content, and the values of the function's free variables.
Reference: <author> Ball, Thomas and James R. Larus. </author> <year> 1992 </year> <month> (January). </month> <title> Optimally profiling and tracing programs. </title> <booktitle> In Conference Record of the 19th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <address> Albu-querque, NM. </address>
Reference-contexts: This new technique for relocating machine instructions is an enabling technology for building machine-independent tools for static, incremental, and dynamic linking. It will also simplify the construction of re-targetable tools that transform object code. Object-code transformation, which is growing in importance, is used for profiling and tracing <ref> (Ball and Larus 1992) </ref>, testing (Hastings and Joyce 1992), enforcing protection (Wahbe et al. 1993), optimization (Srivastava and Wall 1993), and binary translation (Sites et al. 1993). There are even frameworks for creating applications that transform object code (Johnson 1990; Larus and Schnarr 1995; Srivastava and Eustace 1994).
Reference: <author> Briggs, Preston and Keith D. Cooper. </author> <year> 1994 </year> <month> (June). </month> <title> Effective partial redundancy elimination. </title> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 29(6) </volume> <pages> 159-170. </pages>
Reference: <author> Fernandez, Mary F. </author> <year> 1995 </year> <month> (June). </month> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, in SIG-PLAN Notices, </booktitle> <volume> 30(6) </volume> <pages> 103-115. </pages>
Reference-contexts: Bytecodes would also yield a space savings; with a suitable choice of bytecodes, it would be easy to represent the bltzal transformation in 13 bytes. 6 Experimental results I have implemented currying and hoisting in the New Jersey Machine-Code Toolkit (Ramsey and Fernan-dez 1995). mld <ref> (Fernandez 1995) </ref>, a retargetable, optimizing linker, uses encoding functions and relocating transformations generated by the toolkit. mld needs only 20 lines of C code for relocation, and it uses the same code on all platforms; the code keeps a list of relocation closures and applies them when the addresses on which
Reference: <author> Fraser, Christopher W. and David R. Hanson. </author> <year> 1982 </year> <month> (April). </month> <title> A machine-independent linker. </title> <journal> Software|Practice & Experience, </journal> <volume> 12(4) </volume> <pages> 351-366. </pages>
Reference: <author> Gircys, Gintaras R. </author> <year> 1988 </year> <month> (November). </month> <title> Understanding and Using COFF. Nutshell Handbooks. </title> <address> Sebastopol, CA: </address> <publisher> O'Reilly & Associates. </publisher>
Reference-contexts: The final argument to emit_at is the size of the token being emitted; that size has been omitted from the other examples in this paper. The closure shown in Figure 1 has the same information as a "relocation entry" used in standard 231 object-code formats like COFF <ref> (Gircys 1988) </ref> and ELF (Prentice Hall 1993a). For example, a COFF relocation entry contains an r_vaddr that corresponds to the loc field; both store the location of the instruction to be relocated.
Reference: <author> Hanson, David R. </author> <year> 1990 </year> <month> (January). </month> <title> Fast allocation and deallocation of memory based on object lifetimes. </title> <journal> Software|Practice & Experience, </journal> <volume> 20(1) </volume> <pages> 5-12. </pages>
Reference-contexts: I do not know why espresso is different. The measured code is artificial, and I am willing to conclude only that the costs are comparable. One source of artificiality is that mld does not store "sections" in contiguous memory locations, because it uses a lifetime-based memory allocator <ref> (Hanson 1990) </ref> and it does not know section sizes in advance. As a consequence, every time an instruction is relocated, the relocation code must search for the contiguous block containing that instruction.
Reference: <author> Hastings, Reed and Bob Joyce. </author> <year> 1992 </year> <month> (January). </month> <title> Purify: Fast detection of memory leaks and access errors. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 125-136. </pages>
Reference-contexts: It will also simplify the construction of re-targetable tools that transform object code. Object-code transformation, which is growing in importance, is used for profiling and tracing (Ball and Larus 1992), testing <ref> (Hastings and Joyce 1992) </ref>, enforcing protection (Wahbe et al. 1993), optimization (Srivastava and Wall 1993), and binary translation (Sites et al. 1993). There are even frameworks for creating applications that transform object code (Johnson 1990; Larus and Schnarr 1995; Srivastava and Eustace 1994).
Reference: <author> Johnson, Stephen C. </author> <year> 1990. </year> <title> Postloading for fun and profit. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 325-330. </pages>
Reference: <author> Jones, Neil D., Peter Sestoft, and Harald Stndergaard. </author> <year> 1989. </year> <title> Mix: A self-applicable partial evaluator for experiments in compiler generation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(1) </volume> <pages> 9-50. </pages>
Reference-contexts: It simplifies the inner s, creating opportunities for them to be shared. Hoisting is very closely related to fully lazy lambda-lifting (Peyton Jones 1987, Chapter 15), and the analysis required to implement it is reminiscent of the binding-time analyses used in partial evaluation <ref> (Jones, Sestoft, and Stndergaard 1989) </ref>. Unlike these other techniques, hoisting is not intended to make programs run faster. Hoisting might result in marginally faster linking, but its purpose is to reduce the number of different -terms needed to implement relocation. Hoisting is implemented by a variation on closure conversion.
Reference: <author> Jones, Douglas W. </author> <year> 1983 </year> <month> (August). </month> <title> Assembly language as object code. </title> <journal> Software|Practice & Experience, </journal> <volume> 13(8). </volume>
Reference: <author> Kane, Gerry. </author> <year> 1988. </year> <title> MIPS RISC Architecture. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: The toolkit includes a library of other functions that complete the API. 227 Tokens and fields A machine description includes the names, sizes, and positions of the fields used to form tokens. The information can be found in architecture manuals. For example, the MIPS manual <ref> (Kane 1988, p A-3) </ref> gives this informal field specification: 31 26 25 21 20 16 15 0 op rs rt immediate 31 26 25 0 op target 31 26 25 21 20 16 15 11 10 6 5 0 op rs rt rd shamt funct This informal specification can be formalized <p> The equation in braces specifies the relationship between the target address addr and the offset used in the instruction's binary representation: A branch target address is computed from the sum of the address of the instruction in the delay slot and the 16-bit offset, [sign-extended and multi plied by 4] <ref> (Kane 1988, p A-23) </ref>. The toolkit solves this equation to compute offset as a function of addr and the program counter.
Reference: <author> Larus, James R. and Eric Schnarr. </author> <year> 1995 </year> <month> (June). </month> <title> EEL: machine-independent executable editing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation. </booktitle>
Reference: <editor> Peyton Jones, Simon L. </editor> <booktitle> 1987. The Implementation of Functional Programming Languages. International Series in Computer Science. </booktitle> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. Prentice Hall. </publisher> <year> 1993a. </year> <title> System V Application Binary Interface. </title> <booktitle> Third edition. </booktitle> <address> Englewood Cliffs, NJ. </address> <publisher> Unix Press. Prentice Hall. </publisher> <year> 1993b. </year> <title> System V Application Binary Interface, SPARC Architecture Processor Supplement. </title> <booktitle> Third edition. </booktitle> <address> Englewood Cliffs, NJ. </address> <publisher> Unix Press. </publisher>
Reference-contexts: Hoisting some of the computation out of the inner into the outer makes many of the inner s identical|a handful are enough for a whole instruction set. This optimization is closely related to fully lazy lambda-lifting <ref> (Peyton Jones 1987) </ref>. It reduces the size of machine-dependent assembly and linking code by 15-20% for the MIPS, SPARC, and PowerPC, and by about 30% for the Pentium. It also makes the relocating transformations discovered by the toolkit equivalent to those that are now implemented by hand. <p> I call this movement hoisting, by analogy with the CPS transformation that moves variable definitions from one scope to another. It simplifies the inner s, creating opportunities for them to be shared. Hoisting is very closely related to fully lazy lambda-lifting <ref> (Peyton Jones 1987, Chapter 15) </ref>, and the analysis required to implement it is reminiscent of the binding-time analyses used in partial evaluation (Jones, Sestoft, and Stndergaard 1989). Unlike these other techniques, hoisting is not intended to make programs run faster.
Reference: <author> Proebsting, Todd A. </author> <year> 1995 </year> <month> (January). </month> <title> Optimizing an ANSI C interpreter with superoperators. </title> <booktitle> In Conference Record of the 22nd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 322-332, </pages> <address> San Francisco, California. </address>
Reference-contexts: Assuming a reasonable byte-coded representation of -terms, the mapping could probably be represented in 100 bytes per object file. It could be made even smaller by using Proebsting's "superoperator" technique <ref> (Proebsting 1995) </ref>. 7 Discussion Hoisting works well on the RISC machines because most instructions occupy a single token. It works less well on the Pentium, because the toolkit creates a single closure for an encoding of an instruction even when that encoding is a sequence of tokens.
Reference: <author> Ramsey, Norman and Mary F. Fernandez. </author> <year> 1994 </year> <month> (October). </month> <title> New Jersey Machine-Code Toolkit architecture specifications. </title> <type> Technical Report TR-470-94, </type> <institution> Department of Computer Science, Princeton University. </institution> . <year> 1995 </year> <month> (January). </month> <title> The New Jersey Machine-Code Toolkit. </title> <booktitle> In Proceedings of the 1995 USENIX Technical Conference, </booktitle> <pages> pages 289-302, </pages> <address> New Orleans, LA. </address>
Reference: <author> Ramsey, Norman. </author> <year> 1992 </year> <month> (December). </month> <title> A Retargetable Debugger. </title> <type> PhD thesis, </type> <institution> Princeton University, Department of Computer Science. </institution> <note> Also Technical Report CS-TR-403-92. </note>
Reference-contexts: A final refinement is needed to write relocation closures to disk. In memory, the relocating transformation is represented as a function pointer, which is neither machine-independent nor meaningful when written to disk. Instead, we describe relocating transformations using a subset of PostScript <ref> (Ramsey 1992) </ref>, extended with special operators to get addresses and values out of closures.
Reference: <author> Sites, Richard L., Anton Chernoff, Matthew B. Kirk, Mau--rice P. Marks, and Scott G. Robinson. </author> <year> 1993 </year> <month> (Febru-ary). </month> <title> Binary translation. </title> <journal> Communications of the ACM, </journal> <volume> 36(2) </volume> <pages> 69-81. </pages>
Reference-contexts: It will also simplify the construction of re-targetable tools that transform object code. Object-code transformation, which is growing in importance, is used for profiling and tracing (Ball and Larus 1992), testing (Hastings and Joyce 1992), enforcing protection (Wahbe et al. 1993), optimization (Srivastava and Wall 1993), and binary translation <ref> (Sites et al. 1993) </ref>. There are even frameworks for creating applications that transform object code (Johnson 1990; Larus and Schnarr 1995; Srivastava and Eustace 1994).
Reference: <author> Srivastava, Amitabh and Alan Eustace. </author> <year> 1994 </year> <month> (June). </month> <title> Atom: A system for building customized program analysis tools. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 196-205. </pages>
Reference: <author> Srivastava, Amitabh and David W. Wall. </author> <year> 1993 </year> <month> (March). </month> <title> A practical system for intermodule code optimization. </title> <journal> Journal of Programming Languages, </journal> <volume> 1 </volume> <pages> 1-18. </pages> <note> Also available as WRL Research Report 92/6, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: It will also simplify the construction of re-targetable tools that transform object code. Object-code transformation, which is growing in importance, is used for profiling and tracing (Ball and Larus 1992), testing (Hastings and Joyce 1992), enforcing protection (Wahbe et al. 1993), optimization <ref> (Srivastava and Wall 1993) </ref>, and binary translation (Sites et al. 1993). There are even frameworks for creating applications that transform object code (Johnson 1990; Larus and Schnarr 1995; Srivastava and Eustace 1994).
Reference: <author> Szymanski, Thomas G. </author> <year> 1978 </year> <month> (April). </month> <title> Assembling code for machines with span-dependent instructions. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 300-308. </pages>
Reference-contexts: For similar reasons, the 2 in ( ) &gt;&gt; 2 is not moved to the closure. 3 The toolkit's library of machine-independent assembly and linking code represents a relocatable address as a label plus a constant offset. This representation is adequate for almost all Unix applications <ref> (Szymanski 1978) </ref>, but application writers could substitute another representation. 230 htype of closurei typedef struct O1_1_closure - ClosureHeader h; /* contains lambda-term, etc ... */ ClosureLocation loc; struct - RAddr a1; unsigned u1; - v; - *O1_1_Closure; hrelocating transformationi static void _clofun_1 (O1_1_Closure _c, Emitter emit_at) - emit_at (_c-&gt;loc, _c-&gt;v.u1 |
Reference: <author> Wahbe, Robert, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <year> 1993 </year> <month> (December). </month> <title> Efficient software-based fault isolation. </title> <booktitle> In Proc. Fourteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 203-216. 236 </pages>
Reference-contexts: It will also simplify the construction of re-targetable tools that transform object code. Object-code transformation, which is growing in importance, is used for profiling and tracing (Ball and Larus 1992), testing (Hastings and Joyce 1992), enforcing protection <ref> (Wahbe et al. 1993) </ref>, optimization (Srivastava and Wall 1993), and binary translation (Sites et al. 1993). There are even frameworks for creating applications that transform object code (Johnson 1990; Larus and Schnarr 1995; Srivastava and Eustace 1994).
References-found: 22

