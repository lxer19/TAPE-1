URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-bellot.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: Email: Patrick.Bellot@inf.enst.fr,  
Phone: Tel: 33-1 45 81 78 81, Fax: 33-1 45 81 31 19.  
Title: Synthesizing Imperative Object-Oriented Programs using a Logic of Actions 1  
Author: Patrick BELLOT 
Keyword: Key words: imperative program synthesis, logic of actions, linearity, realizability, object oriented programming, logical specifications.  
Address: 46 rue Barrault, 75634 Paris Cedex 13, France  
Affiliation: Ecole Nationale Superieure des Telecommunications Computer Science department, Software Engineering group  
Abstract: In the article, we present a logical system which allows to specify and to synthesize imperative object-oriented programs. It is a logic of actions. Formulae can describe actions, situations and mathematical assertions. The specifications are written in this logic which is a linear sequent calculus. Then a proof of the assertion is done. The proof uses logical and extra-logical axioms and inference rules. Proofs in this logic may have very simple linear structures. Then a program is extracted from the proof using a realization technique. This program is an object-oriented program which relies heavily on threads for parallelism and synchronization. We give two examples. The first is the well-known World of Blocks. The second example is called the Candy Machine and is an example of communicating process. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> BELLOT, P. </author> <title> Logics, languages and specifications, </title> <booktitle> the science of information processing. </booktitle> <address> In accessible par http://www.enst.fr/bellot (ENST Paris (France), </address> <note> 1997 (to be continued)). </note>
Reference-contexts: 1 ; R 2 : A 2 ; : : : ; R n : A n ` S 1 : B 1 ; S 2 : B 2 ; : : : ; S m : B m meaning that if R i realizes A i for i 2 <ref> [1; n] </ref> then S j realizes B j for j 2 [1; m]. On both sides of the assertion sign `, the realized formulae are implicitly linked by a conjunction. It means that all formulae and all realizations are available at the same time. <p> ; R n : A n ` S 1 : B 1 ; S 2 : B 2 ; : : : ; S m : B m meaning that if R i realizes A i for i 2 [1; n] then S j realizes B j for j 2 <ref> [1; m] </ref>. On both sides of the assertion sign `, the realized formulae are implicitly linked by a conjunction. It means that all formulae and all realizations are available at the same time. The R i ; i 2 [1; n] are all different realizations variables. <p> <ref> [1; n] </ref> then S j realizes B j for j 2 [1; m]. On both sides of the assertion sign `, the realized formulae are implicitly linked by a conjunction. It means that all formulae and all realizations are available at the same time. The R i ; i 2 [1; n] are all different realizations variables. The S j ; j 2 [1; m] are realizations built using the realization variables R i ; i 2 [1; n] and individual variables occurring in the formulae B 1 ; : : : ; B m . <p> It means that all formulae and all realizations are available at the same time. The R i ; i 2 [1; n] are all different realizations variables. The S j ; j 2 <ref> [1; m] </ref> are realizations built using the realization variables R i ; i 2 [1; n] and individual variables occurring in the formulae B 1 ; : : : ; B m . <p> It means that all formulae and all realizations are available at the same time. The R i ; i 2 <ref> [1; n] </ref> are all different realizations variables. The S j ; j 2 [1; m] are realizations built using the realization variables R i ; i 2 [1; n] and individual variables occurring in the formulae B 1 ; : : : ; B m . We also assume the realizations R i ; i 2 [1; n] to be independent, i.e. they can be executed in any order, sequentially or concurrently, without changing their semantics. <p> The S j ; j 2 [1; m] are realizations built using the realization variables R i ; i 2 <ref> [1; n] </ref> and individual variables occurring in the formulae B 1 ; : : : ; B m . We also assume the realizations R i ; i 2 [1; n] to be independent, i.e. they can be executed in any order, sequentially or concurrently, without changing their semantics. That is a rather strong assumption which appears to be realistic. The axiomatization. The axiomatization has been made difficult because of the necessity of being linear. <p> Brute realizations can oftenly be transformed in simpler realizations doing the same work. A trivial example is the simplification of c ( (A; B)) in (B; A). Numerous purely syntactic simplification rules are given in <ref> [1] </ref>. Using the realization. To use this realization, we need two blocks a and b such that a b is a stack. We need c, floor or block, on which b is. We need d, floor or block, such that top (d). <p> We can also have a logical specification U spec of the other actor, for instance the user in the case of the Candy machine. By transposing the user action , with the ? operation <ref> [1] </ref>, and by studying F spec U ? spec , we can hope to prove the correctness of the specifications. Transposition is syntactically defined [1] but even if it works for the linear menu, it is not clear that it will work for the Candy Machine for instance. Other example. <p> By transposing the user action , with the ? operation <ref> [1] </ref>, and by studying F spec U ? spec , we can hope to prove the correctness of the specifications. Transposition is syntactically defined [1] but even if it works for the linear menu, it is not clear that it will work for the Candy Machine for instance. Other example. Hanoj Towers is an example which has to be developed in order to finalize and 9 axiomatizations.
Reference: [2] <author> BELLOT, P., COTTIN, J.-P., DEMAILLE, A., LENEUTRE, J., AND ZARPAS, E. </author> <title> A logic of actions for imperative program synthesis. </title> <booktitle> In Logic Colloquium'96, </booktitle> <address> LC'96 (San Sebastian (Spain), </address> <month> july </month> <year> 1996), </year> <note> J. Larrazabal, Ed. </note>
Reference: [3] <author> BELLOT, P., COTTIN, J.-P., DEMAILLE, A., LENEUTRE, J., AND ZARPAS, E. </author> <title> Towards bug free software engineering for telecommunication. </title> <booktitle> In proceeding of The Eighth International Conference (Joint Europe-USA Conference) on Artificial Intelligence Applications, </booktitle> <address> Expersys'96 (Paris (France), </address> <month> october </month> <year> 1996). </year>
Reference-contexts: We admit fi 1 ; ; fi 2 ` ; fi 2 as a generalized instance of ` . Using linear proof and generalized instances of axioms, proofs are much more simpler than classical tree-like proofs. It seems <ref> [3, 4, 25] </ref> that human and automatic search for proofs is also less complex. We will see an example of such a simple proof in section 5. The conjunction. A B, read it A times B, means executing concurrently A and B.
Reference: [4] <author> BELLOT, P., COTTIN, J.-P., LENEUTRE, J., AND ZARPAS, E. </author> <title> Automated deduction for protocols design. </title> <booktitle> In Third Workshop on Automated Reasoning: Bridging the Gap between Theory and Practice (Brighton (England), </booktitle> <month> april </month> <year> 1996), </year> <title> I. Gent, </title> <publisher> Ed. </publisher>
Reference-contexts: We admit fi 1 ; ; fi 2 ` ; fi 2 as a generalized instance of ` . Using linear proof and generalized instances of axioms, proofs are much more simpler than classical tree-like proofs. It seems <ref> [3, 4, 25] </ref> that human and automatic search for proofs is also less complex. We will see an example of such a simple proof in section 5. The conjunction. A B, read it A times B, means executing concurrently A and B.
Reference: [5] <author> BELLOT, P., LENEUTRE, J., ROBINET, B., AND ZARPAS, E. </author> <title> Prolegomena of a logic of causality and dynamicity. </title> <journal> Studia Logica, </journal> <note> an International journal for Symbolic Logic, 61 (1998), 393421. </note>
Reference: [6] <author> BELLOT, P., LENEUTRE, J., AND ZARPAS, E. </author> <title> The B-logic, from the Big Bang to the Big Crunch. </title> <booktitle> In Logic Colloquium'94, </booktitle> <address> LC'94 (Clermont-Ferrand (France), </address> <month> july </month> <year> 1994), </year> <editor> D. Richard, </editor> <publisher> Ed. </publisher>
Reference: [7] <author> BERGER, U. </author> <title> Program extraction from normalization proofs. </title> <booktitle> In TCLA'93, Typed Lambda Cal--culi and Applications (Berlin, 1993), vol. 664 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 91106. </pages>
Reference-contexts: We make the distinction between computing-by-proof and programming-by-proof. Computing by proof is concerned with computations, the object of functional programming languages such as LISP or SML. Programming is mainly concerned with actions such as sorting a disk file. In this case, classical program synthesizing systems such as <ref> [7, 14, 16, 19, 21, 22, 23] </ref> are not adapted because they rely on more or less classical logics and produce -expressions. Even if imperative execution can be modeled with functions, it is not realistic. Logics and actions.
Reference: [8] <author> BIBEL, W., AND HORNING, K. </author> <title> Lops : a system based on a strategical approach to program synthesis. </title> <note> In in [9] (1984). </note>
Reference-contexts: Transformations and proofs-as-programs. As in most transformational synthesis or proofs-as-programs systems, the main stumbling rock is the proof and the way it can be obtained. The proof determines the tractability of the program. In transformational systems like LOPS <ref> [8] </ref>, proofs are transformations of specifications into executable logic programs. In our system, programs are extracted from proofs of the specifications. We don't think there is a great difference between the two approaches: they seem to be the same work under different presentations.
Reference: [9] <author> BIERMANN, A., GUIHO, G., AND KODRATOFF, Y. </author> <title> An Overview of Automatic Program Construction Techniques. </title> <publisher> Macmillan, </publisher> <address> Boston/Dordrecht/London, </address> <year> 1984. </year>
Reference: [10] <author> FLENER, P. </author> <title> Logic Program Synthesis from Incomplete Information. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston/Dordrecht/London, </address> <year> 1995. </year>
Reference-contexts: However, this would be unfair because the way the theorem is proved is closely linked to the program as we already mentioned it. Programming or proving ? In <ref> [10] </ref>, Tessler theorem is quoted Automatic programming is whatever has not been compiled yet !. This appears as definitively true in the case of proofs-as-programs systems: proving is just another form of programming. For instance, choosing an induction rule or another means choosing one kind of iteration or another.
Reference: [11] <author> GIRARD, J.-Y. </author> <title> Linear logic. </title> <booktitle> Theoretical Computer Science 50, 1 (1987), </booktitle> <pages> 1102. </pages>
Reference-contexts: But some actions may have no quantifiable consequences such as displaying an information on a screen. Alternatively, we can add a temporal parameter in formulae but temporal logics are far more complex and still talk about situations. Moreover, as J-Y. Girard showed it <ref> [11, 12, 13] </ref>, the structural rules of classical and intuitionistic logics do not take into account the notion of resources which is essential when we deal with real world problems. One could decide to use non-commutative or partially non-commutative logics but the syntax of these logics is only for specialists.
Reference: [12] <author> GIRARD, J.-Y. </author> <title> Introduction OEa la logique lineaire. In Logique et Informatique : une introduction, </title> <editor> B. Courcelle, Ed. </editor> <publisher> INRIA, </publisher> <year> 1989. </year>
Reference-contexts: But some actions may have no quantifiable consequences such as displaying an information on a screen. Alternatively, we can add a temporal parameter in formulae but temporal logics are far more complex and still talk about situations. Moreover, as J-Y. Girard showed it <ref> [11, 12, 13] </ref>, the structural rules of classical and intuitionistic logics do not take into account the notion of resources which is essential when we deal with real world problems. One could decide to use non-commutative or partially non-commutative logics but the syntax of these logics is only for specialists.
Reference: [13] <author> GIRARD, J.-Y. </author> <title> Towards a geometry of interaction. </title> <booktitle> Contemporary Mathematics 92 (1989), </booktitle> <pages> 69108. </pages>
Reference-contexts: But some actions may have no quantifiable consequences such as displaying an information on a screen. Alternatively, we can add a temporal parameter in formulae but temporal logics are far more complex and still talk about situations. Moreover, as J-Y. Girard showed it <ref> [11, 12, 13] </ref>, the structural rules of classical and intuitionistic logics do not take into account the notion of resources which is essential when we deal with real world problems. One could decide to use non-commutative or partially non-commutative logics but the syntax of these logics is only for specialists.
Reference: [14] <author> HOWE, D. </author> <title> Reasoning about functional programs in nuprl. </title> <booktitle> In Functional Programming, Con-currency, Simulation, and Automated Reasoning (1991), vol. 693 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-verlag, </publisher> <pages> pp. 145164. </pages>
Reference-contexts: We make the distinction between computing-by-proof and programming-by-proof. Computing by proof is concerned with computations, the object of functional programming languages such as LISP or SML. Programming is mainly concerned with actions such as sorting a disk file. In this case, classical program synthesizing systems such as <ref> [7, 14, 16, 19, 21, 22, 23] </ref> are not adapted because they rely on more or less classical logics and produce -expressions. Even if imperative execution can be modeled with functions, it is not realistic. Logics and actions.
Reference: [15] <author> KLEENE, S. </author> <title> Realizability. </title> <booktitle> In Colloquium on Constructivity in Mathematics, </booktitle> <address> Amsterdam, 1957 (1959), </address> <publisher> North-Holland, Amsterdam. </publisher>
Reference-contexts: Situations as actions. This two meanings are the same as far as we think a situation formula as the action of doing things in such a way that the situation formula holds. The realizations. Realizability <ref> [15] </ref> is a technique allowing to associate some object to a proved formulae. The object, called the realization, is built with the proof of the formula. Our realizations are objects in the sense of object-oriented programming. They all have a method prove () which realizes the formula.
Reference: [16] <editor> KRIVINE, J.-L. Lambda-calcul types et modOEeles. </editor> <publisher> Masson, </publisher> <address> Paris (France), </address> <year> 1990. </year>
Reference-contexts: We make the distinction between computing-by-proof and programming-by-proof. Computing by proof is concerned with computations, the object of functional programming languages such as LISP or SML. Programming is mainly concerned with actions such as sorting a disk file. In this case, classical program synthesizing systems such as <ref> [7, 14, 16, 19, 21, 22, 23] </ref> are not adapted because they rely on more or less classical logics and produce -expressions. Even if imperative execution can be modeled with functions, it is not realistic. Logics and actions.
Reference: [17] <author> MASSERON, M., TOLLU, C., AND VAUZEILLES, J. </author> <title> Generating plans in linear logic, part I: Actions as proofs. </title> <booktitle> Theoretical Computer Science 113, 2 (1993), </booktitle> <pages> 349370. </pages>
Reference-contexts: One advantage of an object-oriented implementation is that it can be easily extended with other types of data, realizations or formulae. 5 4 Axiomatization of the world of blocks The world of blocks <ref> [17, 18] </ref> is a floor on which there is blocks. Given two configurations of blocks called initial and final, the problem is to find the block movements needed to get the final situation from the initial one. An example is given on the figure below.
Reference: [18] <author> MASSERON, M., TOLLU, C., AND VAUZEILLES, J. </author> <title> Generating plans in linear logic, part II: A geometry of conjunctive actions. </title> <booktitle> Theoretical Computer Science 113, 2 (1993), </booktitle> <pages> 371376. </pages>
Reference-contexts: One advantage of an object-oriented implementation is that it can be easily extended with other types of data, realizations or formulae. 5 4 Axiomatization of the world of blocks The world of blocks <ref> [17, 18] </ref> is a floor on which there is blocks. Given two configurations of blocks called initial and final, the problem is to find the block movements needed to get the final situation from the initial one. An example is given on the figure below.
Reference: [19] <author> NEPEJVODA, N. </author> <title> A bridge between constructive logic and computer programming. </title> <booktitle> Theoretical Computer Science 90 (1991), </booktitle> <pages> 253270. </pages>
Reference-contexts: We make the distinction between computing-by-proof and programming-by-proof. Computing by proof is concerned with computations, the object of functional programming languages such as LISP or SML. Programming is mainly concerned with actions such as sorting a disk file. In this case, classical program synthesizing systems such as <ref> [7, 14, 16, 19, 21, 22, 23] </ref> are not adapted because they rely on more or less classical logics and produce -expressions. Even if imperative execution can be modeled with functions, it is not realistic. Logics and actions.
Reference: [20] <author> PARIGOT, M. </author> <title> Programming with proofs: a second order type theory. </title> <booktitle> In ESOP'88, Second European Symposium on programming (Nancy, 1988), vol. 300 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 145159. </pages>
Reference-contexts: If, instead, we consider it to be a n-blocks stack upon one bottom block, we get a very different program: to move a 10-blocks stacks, it needs about 8000 threads and 60000 objects. Yes, you read well! But this is also true for other similar systems <ref> [20] </ref>. About the theory. It seems very difficult to prove the soundness of this approach either by a semantic method or by a syntactic method. At the present time, it is a serious drawback. About execution. Each piece of code is small, simple and have a clear semantics.
Reference: [21] <author> PARIGOT, M. </author> <title> Classical proofs as programs. </title> <booktitle> In KGC'93, Third K. Godel Colloquium, Computational logic and Proof theory, Brno (1993). </booktitle>
Reference-contexts: We make the distinction between computing-by-proof and programming-by-proof. Computing by proof is concerned with computations, the object of functional programming languages such as LISP or SML. Programming is mainly concerned with actions such as sorting a disk file. In this case, classical program synthesizing systems such as <ref> [7, 14, 16, 19, 21, 22, 23] </ref> are not adapted because they rely on more or less classical logics and produce -expressions. Even if imperative execution can be modeled with functions, it is not realistic. Logics and actions.
Reference: [22] <author> PAULIN-MOHRING, C. </author> <title> Realisabilite et extraction de programmes. In Logique et informatique : une introduction, </title> <editor> B. Courcelle, Ed. </editor> <publisher> INRIA, </publisher> <year> 1989, </year> <pages> pp. 163180. </pages>
Reference-contexts: We make the distinction between computing-by-proof and programming-by-proof. Computing by proof is concerned with computations, the object of functional programming languages such as LISP or SML. Programming is mainly concerned with actions such as sorting a disk file. In this case, classical program synthesizing systems such as <ref> [7, 14, 16, 19, 21, 22, 23] </ref> are not adapted because they rely on more or less classical logics and produce -expressions. Even if imperative execution can be modeled with functions, it is not realistic. Logics and actions.
Reference: [23] <author> TATSUTA, M. </author> <title> Program synthesis using realizability. </title> <booktitle> Theoretical Computer Science 90 (1991), </booktitle> <pages> 309353. </pages>
Reference-contexts: We make the distinction between computing-by-proof and programming-by-proof. Computing by proof is concerned with computations, the object of functional programming languages such as LISP or SML. Programming is mainly concerned with actions such as sorting a disk file. In this case, classical program synthesizing systems such as <ref> [7, 14, 16, 19, 21, 22, 23] </ref> are not adapted because they rely on more or less classical logics and produce -expressions. Even if imperative execution can be modeled with functions, it is not realistic. Logics and actions.
Reference: [24] <author> TURNER, K. </author> <title> Using Fromal Description Techniques An Introduction to Estelle, Lotos and SDL. Wiley Series in Communication and Distributed Systems, </title> <year> 1993. </year>
Reference-contexts: In the first case, he receives a candy a. In the second case, he receives a candy b. Such a communicating process is specified as a protocol written in SDL, Specification Description Language <ref> [24] </ref>, which graphical syntax is shown in the figure below. The machine can be in two states: running and paid. Initially in the running state, it is waiting for an input message coin or a message end. If it receives coin, it goes in state paid.
Reference: [25] <author> ZARPAS, E. </author> <title> Demonstration automatique dans une logique des actions (thesis). </title> <type> Tech. rep., </type> <institution> ENST, Paris (France), </institution> <year> 1997. </year> <month> 12 </month>
Reference-contexts: We admit fi 1 ; ; fi 2 ` ; fi 2 as a generalized instance of ` . Using linear proof and generalized instances of axioms, proofs are much more simpler than classical tree-like proofs. It seems <ref> [3, 4, 25] </ref> that human and automatic search for proofs is also less complex. We will see an example of such a simple proof in section 5. The conjunction. A B, read it A times B, means executing concurrently A and B.
References-found: 25

