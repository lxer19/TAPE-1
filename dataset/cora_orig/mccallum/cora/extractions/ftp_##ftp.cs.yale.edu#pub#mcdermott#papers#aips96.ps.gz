URL: ftp://ftp.cs.yale.edu/pub/mcdermott/papers/aips96.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/mcdermott.html
Root-URL: http://www.cs.yale.edu
Email: e-mail: mcdermott@cs.yale.edu  
Phone: phone: 203-432-1281 fax: 203-432-0593  
Title: A Heuristic Estimator for Means-Ends Analysis in Planning  
Author: Drew McDermott 
Keyword: planning, search, means-ends analysis Reinventing GPS  
Address: 51 Prospect Street, P.O. Box 808285 New Haven, CT 06520-8285  
Affiliation: Yale Computer Science Department  
Abstract: Means-ends analysis is a seemingly well understood search technique, which can be described, using planning terminology, as: keep adding actions that are feasible and achieve pieces of the goal. Unfortunately, it is often the case that no action is both feasible and relevant in this sense. The traditional answer is to make subgoals out of the preconditions of relevant but infeasible actions. These subgoals become part of the search state. An alternative, surprisingly good, idea is to recompute the entire subgoal hierarchy after every action. This hierarchy is represented by a greedy regression-match graph. The actions near the leaves of this graph are feasible and relevant to a sub. . . subgoals of the original goal. Furthermore, each subgoal is assigned an estimate of the number of actions required to achieve it. This number can be shown in practice to be a useful heuristic estimator for domains that are otherwise intractable. Means-ends analysis is one of the oldest ideas in AI. It was named and studied by Newell, Shaw, and Si-mon in the 1950s, and was the key idea behind the General Problem Solver (GPS) (Newell & Simon 1961; Ernst & Newell 1969) In the late sixties, Fikes, Nils-son, and Raphael embodied the idea in their planner, Strips (Fikes & Nilsson 1971). It is still an important technique today, especially as embodied the Prodigy planner (Fink & Veloso 1994)). As used by planners, means-ends analysis can be described thus: We are given a set of action specifications, an initial situation, and a goal-situation description. The problem is to find a sequence of actions that, if carried out starting in the initial situation, would get to a situation that satisfies the goal description. Action specifications define the meanings of action terms fl This work by supported by ARPA and administered by ONR under Contract Number N00014-93-1-1235 by specifying preconditions, addlists, and deletelists in the usual way. For example, we might define the action take out(?x,?b) thus: Action: take out(?x,?b) Preconditions: in(?x,?b) ^ exposed(?b) Effects: Del: in(?x,?b) Add: exposed(?x) That is, if ?x is in container ?b, and ?b is "exposed" (not inside anything), then the result of executing take out(?x,?b) is that ?x ceases to be inside ?b, and becomes exposed. In a nutshell, the idea behind means-ends analysis is to build action sequences by continually adding actions whose addlists contain conjuncts that correspond to pieces of the goal-situation description. I will use the term plan prefix for an action sequence that the planner is trying to extend to be a solution to a planning problem. The search space is the set of all plan prefixes. The search begins with the empty prefix. The goal is a sequence such that executing it gets the world to a situation that satisfies the goal-situation description. If I is the initial situation, then let r(I; s) be the situation resulting from executing action sequence s starting in I. If the search has reached prefix s, then s can be extended to s; A, where A is an action such that: (1) A is feasible (has all preconditions satisfied) in r(I; s); (2) some conjunct in A's addlist occurs in the goal-situation description and is not already true in r(I; s). The main bug with this idea is, of course, that for almost all interesting problems, we can't hope to satisfy both condition (1) and condition (2) on the action that extends a plan prefix. That is, many actions that would add a goal conjunct are not feasible in r(I; s). The solution that has been adopted since Newell, Shaw, and Simon invented means-ends analysis is to make search states more complicated, by keeping track of a hierarchy of subgoals as well as a plan prefix. In this paper I consider the following alternative: Keep search states simple, just sequences of actions, 
Abstract-found: 1
Intro-found: 1
Reference: <author> Barrett, A., and Weld, D. S. </author> <year> 1994. </year> <title> Partial-order planning: evaluating possible efficiency gains. </title> <booktitle> Artificial Intelligence 67(1) </booktitle> <pages> 71-112. </pages>
Reference-contexts: Many of these problems involve context-dependent effects. Unpop can solve all of them, and only exhibits exponential behavior on one (which I discuss below). For a more systematic comparison of Unpop with previous planners, I ran it in best-first mode on some of the artificial problem spaces of <ref> (Barrett & Weld 1994) </ref>. In most of these problem spaces, the number of plan prefixes examined by the planner grew linearly or quadratically with the size of the problem. The run time grew faster, because as problems grow, the size of the regression-match graph grows, too. <p> Hence Unpop tries very hard to find a way to avoid unscrewing all the screws, and considers all possible ways of unscrewing two or three before finally exploring plan prefixes in which all four are unscrewed. Another example is Barrett and Weld's <ref> (Barrett & Weld 1994) </ref> domain D m S 2? . Yet another example is the "Rocket" domain discussed by (Blum & Furst 1995). <p> The resulting situation-space search algorithm searches many fewer states than traditional planners on a large class of problems, although it takes longer than usual per state. A key lesson is that results such as those of <ref> (Barrett & Weld 1994) </ref> on the inferiority of total-order planners versus partial-order planners may not apply when the planners are given more accurate heuristic estimators. The fact that a search space is exponential matters less if the searcher can avoid looking at most of it.
Reference: <author> Blum, A. L., and Furst, M. L. </author> <year> 1995. </year> <title> Fast planning through planning graph analysis. </title> <booktitle> In Proc. Ijcai. </booktitle>
Reference-contexts: Another example is Barrett and Weld's (Barrett & Weld 1994) domain D m S 2? . Yet another example is the "Rocket" domain discussed by <ref> (Blum & Furst 1995) </ref>. In this domain a rocket can only be used once, a fact expressed by having the action of flying a rocket delete the precondition has-fuel (rocket), which is not added by any action. <p> One is the system of Smith and Peot (Smith & Peot 1993), which used a data structure called an "operator graph" that is essentially a regression-match graph without the matches. The planner of <ref> (Blum & Furst 1995) </ref> used a data structure called a "planning graph" that is similar in spirit to a regression-match graph, but "looks forward" from the current situation all the way to the end rather than "looking back" from goals all the way to the current situation, as the regression-match graph
Reference: <author> Ernst, G. W., and Newell, A. </author> <year> 1969. </year> <title> GPS: A Case Study in Generality and Problem Solving. </title> <publisher> Academic Press. </publisher>
Reference: <author> Fikes, R., and Nilsson, N. J. </author> <year> 1971. </year> <title> Strips: A new approach to the application of theorem proving to problem solving. </title> <booktitle> Artificial Intelligence 2 189-208. </booktitle>
Reference: <author> Fink, E., and Veloso, M. </author> <year> 1994. </year> <title> Prodigy planning algorithm. </title> <type> Technical Report 94-123, </type> <institution> CMU School of Computer Science. </institution>
Reference-contexts: On the other hand, the recent history of research in automated planning tends to have a depressing surplus of completeness results and shortage of heuristic estimators. If you really want completeness, you could plug the Unpop heuristic estimator into a complete goal-directed planning framework such as that of <ref> (Fink & Veloso 1994) </ref>. Results and Related Work The program has no trouble with the standard "toy" problems in the literature, where solutions are plans with about five or six steps. My main test domain has been the Manhattan world.
Reference: <author> Harvey, W. D., and Ginsberg, M. L. </author> <year> 1995. </year> <title> Limited discrepancy search. </title> <booktitle> In Proc. Ijcai95, </booktitle> <pages> 607-613. </pages>
Reference: <author> McAllester, D., and Rosenblitt, D. </author> <year> 1991. </year> <title> Systematic nonlinear planning. </title> <booktitle> In Proc. AAAI 9, </booktitle> <pages> 634-639. </pages>
Reference: <author> Newell, A., and Simon, H. </author> <year> 1961. </year> <title> Gps: a program that simulates human thought. </title> <booktitle> In Lernende Auto-maten, </booktitle> <pages> 279-293. </pages> <note> R. Oldenbourg KG. Reprinted in Feigenbaum and Feldman 1963. </note>
Reference: <author> Pednault, E. P. D. </author> <year> 1989. </year> <title> Adl: Exploring the middle ground between Strips and the situation calculus. </title> <booktitle> In Proc. Knowledge Representation Conf, </booktitle> <pages> 324-332. </pages>
Reference-contexts: In that case, p is called a preservation precondition. Intuitively, there will be circumstances where p must be achieved before an action A in order to prevent A from deleting e. The classic example is due to Pednault <ref> (Pednault 1989) </ref>: If a briefcase is carried from one place to another, then an object moves to its location if and only if the object is in the briefcase.
Reference: <author> Penberthy, J. S., and Weld, D. S. </author> <year> 1992. </year> <title> Ucpop: A sound, complete, partial order planner for Adl. </title> <publisher> KR-92. </publisher>
Reference-contexts: The construct p ) e indicates a conditional effect; the effect e occurs if p is true just before the action is executed. (This and other aspects of my notation are taken from <ref> (Penberthy & Weld 1992) </ref>.) For example, if the robot is already carrying an object ?k1, picking up ?key will cause it to let go of ?k1. shapes represent keys; the black squares with white shapes inscribed represent locks, which are initially all locked.
Reference: <author> Smith, D. E., and Peot, M. A. </author> <year> 1993. </year> <title> Postponing threats in partial-order planning. </title> <booktitle> In Proc. AAAI 11, </booktitle> <pages> 500-506. </pages>
Reference-contexts: The cost depends on the situation when the action is executed, which differs from the current situation. Two other planners have used data structures similar to regression-match graphs to look for exactly this kind of information. One is the system of Smith and Peot <ref> (Smith & Peot 1993) </ref>, which used a data structure called an "operator graph" that is essentially a regression-match graph without the matches.
Reference: <author> Weld, D. </author> <year> 1994. </year> <title> An introduction to least-commitment planning. </title> <journal> AI Magazine. </journal>
Reference-contexts: Many of these problems involve context-dependent effects. Unpop can solve all of them, and only exhibits exponential behavior on one (which I discuss below). For a more systematic comparison of Unpop with previous planners, I ran it in best-first mode on some of the artificial problem spaces of <ref> (Barrett & Weld 1994) </ref>. In most of these problem spaces, the number of plan prefixes examined by the planner grew linearly or quadratically with the size of the problem. The run time grew faster, because as problems grow, the size of the regression-match graph grows, too. <p> Hence Unpop tries very hard to find a way to avoid unscrewing all the screws, and considers all possible ways of unscrewing two or three before finally exploring plan prefixes in which all four are unscrewed. Another example is Barrett and Weld's <ref> (Barrett & Weld 1994) </ref> domain D m S 2? . Yet another example is the "Rocket" domain discussed by (Blum & Furst 1995). <p> The resulting situation-space search algorithm searches many fewer states than traditional planners on a large class of problems, although it takes longer than usual per state. A key lesson is that results such as those of <ref> (Barrett & Weld 1994) </ref> on the inferiority of total-order planners versus partial-order planners may not apply when the planners are given more accurate heuristic estimators. The fact that a search space is exponential matters less if the searcher can avoid looking at most of it.
References-found: 12

