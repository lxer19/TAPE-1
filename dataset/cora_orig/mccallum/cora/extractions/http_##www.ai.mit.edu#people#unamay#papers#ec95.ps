URL: http://www.ai.mit.edu/people/unamay/papers/ec95.ps
Refering-URL: http://www.ai.mit.edu/people/unamay/papers.html
Root-URL: 
Email: unamay@santafe.edu oppacher@scs.carleton.ca  
Title: Hybridized Crossover-Based Search Techniques for Program Discovery  
Author: Una-May O'Reilly and Franz Oppacher 
Address: 1125 Colonel By Drive, Ottawa, CANADA, K1S 5B6  
Affiliation: School of Computer Science, Carleton University  
Abstract: We address the problem of program discovery as defined by Genetic Programming. By combining a hierarchical crossover operator with two traditional single point search algorithms: Simulated Annealing and Stochastic Iterated Hill Climbing, we have solved some problems processing fewer candidate solutions and with a greater probability of success than Genetic Programming. We have also enhanced Genetic Programming by hybridizing it with the simple idea of hill climbing from a few individuals, at a fixed interval of generations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aarts, E., Korst, J., </author> <title> Simulated Annealing and Boltzmann Machines. </title> <publisher> Wiley. </publisher> <year> 1989 </year>
Reference-contexts: Another obvious goal is to capitalize upon the strategies of other adaptive search methods by incorporating them into an enhanced version of GP that outperforms the canonical GP. In [5] we reported that by using a novel operator, HVL-Mutate, both iterated hill climbing and Simulated Annealing <ref> [1] </ref> can accomplish program discovery tasks, sometimes processing significantly fewer candidate solutions to find a correct solution or finding a solution more reliably. HVL-Mutate changes the parse tree of candidate solution (program or S-expression) via shrinking, growth or internal substitution while preserving syntactic correctness.
Reference: [2] <author> Jones, Terry. </author> <title> Crossover, Macromutation, and Population-based Search, </title> <booktitle> in Proceedings of the Sixth Interna tional Conference on Genetic Algorithms, </booktitle> <editor> L. J. Eshelman, Editor, </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1995, </year> <pages> pages 73-80. </pages>
Reference-contexts: This paper investigates the nature of crossover when it is used as the move operator in hill climbing and Simulated Annealing. Starting from the idea of crossover hill climbing, XOHC, which is used in <ref> [2] </ref> on the fixed length binary string representation of GAs, we implement a similar XOHC algorithm for hierarchical variable length representations by replacing GA crossover with GP crossover. Next, we combine crossover with Simulated Annealing, XOSA.
Reference: [3] <author> Koza, J. R., </author> <title> Genetic Programming; On the Programming of Computers by Means of Natural Selection, </title> <publisher> Bradford Books, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction An important question to the Genetic Programming (GP) <ref> [3] </ref> community is whether the evolution-based approach to program discovery, as espoused by GP, is generally superior to other adaptive search techniques. Another obvious goal is to capitalize upon the strategies of other adaptive search methods by incorporating them into an enhanced version of GP that outperforms the canonical GP. <p> At the outset, a mate and the current solution are randomly generated. For a specified number of attempts, mate-xo-tries-limit, candidates are generated via crossover from this pair. Our version of GP crossover retains the essential spirit of GP crossover in <ref> [3] </ref> but is a simple two-parent to one-child function rather than a two-parent to two-children version. A randomly chosen subtree is copied from the random mate and replaces a subtree randomly removed from the current solution. <p> The task, primitive set, test suite and fitness function of the first 3 problems are well described in <ref> [3] </ref>. The task of a sorting program is to arrange the elements of an array in ascending order. A description of the primitives and test suite used is in [5].
Reference: [4] <author> Koza, J. R., </author> <title> Genetic Programming II: Automatic Discovery of Reusable Programs, </title> <publisher> Bradford Books, </publisher> <year> 1994. </year>
Reference-contexts: (10.9) GP + XOHC, Pop, f = 5 e = 500; g = 2 100.0 100.0 5.3 5.3 (3.3) GP + XOHC, Random, f = 5 e = 100; g = 3 100.0 100.0 10.6 10.6 (6.3) experiment could be tackled with problems that use Automatically Defined Functions as per <ref> [4] </ref>. Given the strong performance of XOHC, XOSA was predicted to have merit but its results were disappointing. We believe that crossover was unable to provide sufficiently small tweaks of candidate solutions near the end of the run when the temperature was low.
Reference: [5] <author> O'Reilly, U. M. and F. </author> <title> Oppacher (1994). Program Search with a Hierarchical Variable Length Representation: Genetic Programming, Simulated Annealing and Hill Climbing, in Parallel Problem Solving from Nature III, </title> <editor> Davidor, Schwefel, Manner (Eds), </editor> <publisher> Springer Verlag (LNCS), Berlin,1994, </publisher> <pages> pages 397-406. </pages>
Reference-contexts: Another obvious goal is to capitalize upon the strategies of other adaptive search methods by incorporating them into an enhanced version of GP that outperforms the canonical GP. In <ref> [5] </ref> we reported that by using a novel operator, HVL-Mutate, both iterated hill climbing and Simulated Annealing [1] can accomplish program discovery tasks, sometimes processing significantly fewer candidate solutions to find a correct solution or finding a solution more reliably. <p> The task, primitive set, test suite and fitness function of the first 3 problems are well described in [3]. The task of a sorting program is to arrange the elements of an array in ascending order. A description of the primitives and test suite used is in <ref> [5] </ref>. In Sort-A the raw fitness of a program is the sum of the number of elements found in the correct position after running the program. In Sort-B the raw fitness is the summed permutation order of each array after each execution.
References-found: 5

