URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR350.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: sdlee@cs.indiana.edu dfried@cs.indiana.edu  
Title: First-Class Extents  
Author: Shinn-Der Lee and Daniel P. Friedman 
Date: August 4, 1992  
Address: Bloomington, Indiana 47405  
Affiliation: Computer Science Department Indiana University  
Abstract: Adding environments as first-class values to a language can greatly enhance its expressiveness. But first-class environments do not mesh well into a lexically scoped language since they rely on identifiers (variable names). By distinguishing variables from identifiers and therefore extents from environments, we present an alternative: first-class extents. First-class extents are defined on variables rather than identifiers and are therefore immune to name capturing problems that plague first-class environments. Then by distinguishing variables from locations and therefore extents from stores, our first-class extents can coexist with imperative features and still allow tail-recursion to be properly implemented as iteration. To test our claims, we extend Scheme with a collection of features that are essential to first-class extents, give a denotational semantics for the extension, and demonstrate that it can be fully embedded into Scheme albeit losing tail-recursiveness. Then we show how first-class extents lead to a way of extending Scheme with object-oriented programming features. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Abelson and G. J. Sussman with J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction In traditional languages a variable with the name i is mapped to a value v by an environment map : Adding environments as first-class values to a language can greatly enhance its expressiveness. MIT Scheme <ref> [1, 15] </ref>, T [18], and Symmetric Lisp [8] have shown that records, structures, closures, modules, classes, abstract data types, and inheritance can all be expressed with first-class environments. <p> First, Scheme has only a few basic constructs, greatly simplifying the presentation. Second, first-class extents are compatible with Scheme's static scope; first-class environments, however, are not. Third, a specialized use of first-class extents already exists in most Scheme implementations, it is the fluid binding operation fluid-let <ref> [1] </ref>. Extending an imperative language such as Scheme with first-class extents raises an immediate concern: the interaction between dynamic extent and side effects. The two notions must be separated. <p> When id is already bound define becomes an assignment, as does def. With def an extent consisting of bindings of a number of variables can be incrementally constructed using the make-extent syntax defined in Figure 2. Finally the definition of fluid-let <ref> [1] </ref> in Figure 3 in terms of first-class extents shows why we claim that fluid-let is a specialized use of first-class extents. 5 (fluid-let ((id exp)) body) =&gt; (with-extent (make-extent (id exp)) body) 2.3 An Example Next, as an example we develop a simple register machine similar to that described in
Reference: [2] <author> N. Adams and J. Rees. </author> <title> Object-oriented programming in Scheme. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 277-288, </pages> <year> 1988. </year>
Reference-contexts: As a result when combined with the fact that writing object-oriented code is the same as writing ordinary Scheme code, we can say that our system is a natural extension of Scheme. In other Scheme-based object systems <ref> [2, 16] </ref>, an object is a dispatcher simulating an environment. But unlike an ordinary environment that associates identifiers with values, a dispatcher maps values (symbols for instance) to values. Thus an object's attributes are accessed through procedure invocations rather than by ordinary Scheme variable references. <p> Yet the most critical deficiency is that ordinary Scheme is not an object since it cannot be made into a dispatcher. This is another reason why the object-oriented code of <ref> [2, 16] </ref> is not Scheme-like. Clearly the object-oriented programming style induced by implementing an object as a dispatcher does not integrate well with Scheme's programming style. 4 Related Work Consider the register abstract data type of Figure 4.
Reference: [3] <author> Cadence Research Systems. </author> <title> Chez Scheme System Manual Revision 2.1, </title> <month> September </month> <year> 1991. </year>
Reference: [4] <editor> W. Clinger and J. Rees (editors). </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <year> 1991. </year>
Reference-contexts: They are therefore immune to name capturing and ff-conversion anomalies. With first-class extents we retain most of the expressiveness of first-class environments and still enjoy the security and modularity of static scope. In this report we use Scheme <ref> [4] </ref> to test our claims. We choose Scheme for three reasons. First, Scheme has only a few basic constructs, greatly simplifying the presentation. Second, first-class extents are compatible with Scheme's static scope; first-class environments, however, are not. <p> In section 4 we compare our first-class extents to related work on first-class environments and first-class stores. Finally we state our conclusion in section 5. 2 FCE This section extends Scheme <ref> [4] </ref> with a set of essential first-class extent features. The extension is called FCE and a complete formal description of it, in the form of a denotational 3 semantics, is deferred to the appendix. We first introduce two basic operations: make-empty-extent and with-extent .
Reference: [5] <author> W. Cook and J. Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-443, </pages> <year> 1989. </year>
Reference-contexts: The message will always refer to the latest bindings defined in the receiving object. In this way we achieve self-reference in object inheritance <ref> [5, 12, 17] </ref> without resorting to any explicit mechanism such as the pseudo variable self. We use the syntactic extension with-object defined in Figure 13 to pass the message msg to the object obj .
Reference: [6] <author> G. L. Drescher. </author> <title> Object Scheme: Object inheritance as fluid binding. </title> <type> Technical report, </type> <institution> Thinking Machines Corporation, </institution> <year> 1990. </year>
Reference-contexts: They are described in detail in the appendix. 3 Object-Oriented Programming In this section we demonstrate how the addition of first-class extents leads to an unusual approach to object-oriented programming. Our object system is almost a reconstruction of Object Scheme <ref> [6] </ref>. Instead of spelling out an object system in detail we simply sketch how some of the most fundamental object-oriented mechanisms can be programmed with FCE. First, we consider the characterization and representation of an object, and the construction of an object's inheritance hierarchy. <p> On the other hand, an object with a superobject superobject can be constructed by (extend-object own-attrs superobject). In a system with multiple inheritance, an object can have many superobjects. Object systems like Object Scheme <ref> [6] </ref> and CLOS [11] use topological sorting algorithms to produce a total ordering of the inheritance graph. We enforce no specific multiple inheritance mechanism. <p> Our system is derived from Object Scheme <ref> [6] </ref>. The difference between the two systems is in the way unshadowing is accomplished. The counterpart of with-shadowed in Object Scheme is the shadowed operation. <p> The three major features discussed are an incremental definition operation, an unshadowing operation, and an effective extents mechanism. In particular we have incorporated these features into Scheme. Based on first-class extents we have reconstructed Drescher's Object Scheme <ref> [6] </ref> in which object-oriented programming is a natural extension of Scheme's fluid binding. Object Scheme is significantly different from other Scheme object systems. In particular an object's attributes, including instance variables, class variables, and methods, are all denoted by lexical variables rather than symbols.
Reference: [7] <author> B. F. Duba, M. Felleisen, and D. P. Friedman. </author> <title> Dynamic identifiers can be neat. </title> <type> Technical Report 220, </type> <institution> Computer Science Department, Indiana University, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: One might be tempted not to make this distinction, but to use the original * to model both extent and side effects. That, however, would mean that the language is not properly tail-recursive, since extent must be simulated by side effects with shallow binding <ref> [7] </ref>. The rest of this report is organized as follows. In section 2 we describe FCE, an extension of Scheme with a collection of operations that is essential to first-class extents. We then show that FCE can be embedded into Scheme.
Reference: [8] <author> D. Gelernter, S. Jagannathan, and T. </author> <title> London. Environments as first class objects. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 98-110, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction In traditional languages a variable with the name i is mapped to a value v by an environment map : Adding environments as first-class values to a language can greatly enhance its expressiveness. MIT Scheme [1, 15], T [18], and Symmetric Lisp <ref> [8] </ref> have shown that records, structures, closures, modules, classes, abstract data types, and inheritance can all be expressed with first-class environments. But since first-class environments rely on identifiers (variable names), ff-conversion (renaming) of variables could lead to context anomalies due to inadvertent name capturing.
Reference: [9] <author> C. T. Haynes and D. P. Friedman. </author> <title> Embedding continuations in procedural objects. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 582-598, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: In summary, we have introduced twelve basic FCE operations: eight procedures get- base-extent, make-empty-extent, use-extent, extent?, empty-extent?, get-effective- extent, use-effective-extent, and effective-extent?, and four special forms def, def ?, use-shadowed, and shadowed?. 2.8 Embedding FCE can be fully embedded <ref> [9] </ref> into Scheme. That is, every basic FCE expression can be defined by an equivalent Scheme expression that gives its meaning. Such an embedding shows that Scheme is as expressive as FCE. It also enables us to study the interactions between first-class extents and Scheme more directly.
Reference: [10] <author> G. F. Johnson and D. Duggan. </author> <title> Stores and partial continuations as first-class objects in a language and its environment. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 158-168, </pages> <year> 1988. </year>
Reference-contexts: For instance, program module interfaces, the interconnections between separately compilable program units, must rely on some protocol that ultimately must be expressed at the symbolic level. The identifiers of first-class environments best serve this purpose. Stores have also been made first-class values. The language GL <ref> [10] </ref> uses first-class stores in testing and debugging programs. With first-class stores, a location can denote multiple "versions" of values. These versions must be stored somewhere. In a multiple memory module architecture, such as SIMD, they could be in the same location of different memory modules.
Reference: [11] <author> G. L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: On the other hand, an object with a superobject superobject can be constructed by (extend-object own-attrs superobject). In a system with multiple inheritance, an object can have many superobjects. Object systems like Object Scheme [6] and CLOS <ref> [11] </ref> use topological sorting algorithms to produce a total ordering of the inheritance graph. We enforce no specific multiple inheritance mechanism. Instead we require that the superobjects, represented by lists of extents, are combined into a single superobject that is in the form of a list of extents. <p> It attaches an empty extent in front of the class object denoted by the variable this-class. An immediate consequence of this is that we can define a generic function <ref> [11] </ref> to instantiate an arbitrary class, provided that the class has a properly defined new-instance method and a variable named this-class that denotes the class itself. We call this generic function new and define it in Figure 15.
Reference: [12] <author> S. N. Kamin. </author> <title> Inheritance in Smalltalk-80: A denotational definition. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 80-87, </pages> <year> 1988. </year>
Reference-contexts: The message will always refer to the latest bindings defined in the receiving object. In this way we achieve self-reference in object inheritance <ref> [5, 12, 17] </ref> without resorting to any explicit mechanism such as the pseudo variable self. We use the syntactic extension with-object defined in Figure 13 to pass the message msg to the object obj .
Reference: [13] <author> E. Kohlbecker, D. P. Friedman, M. Felleisen, and B. Duba. </author> <title> Hygienic macro expansion. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-161, </pages> <year> 1986. </year>
Reference: [14] <author> J. McCarthy. </author> <title> Towards a mathematical science of computation. </title> <booktitle> In Proceedings of IFIP Congress 63, </booktitle> <pages> pages 21-28. </pages> <publisher> North-Holland, </publisher> <year> 1963. </year>
Reference-contexts: Each sequence of instructions consists of any number of assign or fetch instructions followed by one of the other three instructions: halt , goto, or branch. This ensures that the thunks are in iterative form <ref> [14] </ref>. The entry point of a program is by convention always the label start. For instance, Figure 6 shows a program that computes the greatest common divisor (GCD) of the two numbers found in registers r0 and r1 . The answer is returned through r0 .
Reference: [15] <author> J. S. Miller and G. J. Rozas. </author> <title> Free variables and first-class environments. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(2) </volume> <pages> 107-141, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction In traditional languages a variable with the name i is mapped to a value v by an environment map : Adding environments as first-class values to a language can greatly enhance its expressiveness. MIT Scheme <ref> [1, 15] </ref>, T [18], and Symmetric Lisp [8] have shown that records, structures, closures, modules, classes, abstract data types, and inheritance can all be expressed with first-class environments. <p> in Figure 3 in terms of first-class extents shows why we claim that fluid-let is a specialized use of first-class extents. 5 (fluid-let ((id exp)) body) =&gt; (with-extent (make-extent (id exp)) body) 2.3 An Example Next, as an example we develop a simple register machine similar to that described in <ref> [15] </ref>. The machine has three registers, namely r0, r1, and r2. The abstract data type of registers is shown in Figure 4. In it each register created by make-reg is a separate extent and the exact same variable contents is being used in each of the registers. <p> Thus (let ((contents "unspecified")) (with-extent reg (def contents contents))) does no harm to the contents of the register reg , since this contents is a different variable from the one used by fetch and assign. In contrast, consider the same abstract data type defined in <ref> [15] </ref> using MIT Scheme's first-class environments; see Figure 16. Because a register's contents is associated with the symbol 'contents, anyone can read and write a register. There is no security to the abstract data type.
Reference: [16] <author> K. Ntrmark. </author> <title> Simulation of object-oriented concepts and mechanisms in Scheme. </title> <type> Technical Report R 90-01, </type> <institution> Institute of Electronic Systems, Aalborg University, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: As a result when combined with the fact that writing object-oriented code is the same as writing ordinary Scheme code, we can say that our system is a natural extension of Scheme. In other Scheme-based object systems <ref> [2, 16] </ref>, an object is a dispatcher simulating an environment. But unlike an ordinary environment that associates identifiers with values, a dispatcher maps values (symbols for instance) to values. Thus an object's attributes are accessed through procedure invocations rather than by ordinary Scheme variable references. <p> Yet the most critical deficiency is that ordinary Scheme is not an object since it cannot be made into a dispatcher. This is another reason why the object-oriented code of <ref> [2, 16] </ref> is not Scheme-like. Clearly the object-oriented programming style induced by implementing an object as a dispatcher does not integrate well with Scheme's programming style. 4 Related Work Consider the register abstract data type of Figure 4.
Reference: [17] <author> U. S. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: The message will always refer to the latest bindings defined in the receiving object. In this way we achieve self-reference in object inheritance <ref> [5, 12, 17] </ref> without resorting to any explicit mechanism such as the pseudo variable self. We use the syntactic extension with-object defined in Figure 13 to pass the message msg to the object obj .
Reference: [18] <author> J. A. Rees, N. I. Adams, and J. R. Meehan. </author> <title> The T Manual. </title> <institution> Computer Science Department, Yale University, </institution> <year> 1984. </year>
Reference-contexts: 1 Introduction In traditional languages a variable with the name i is mapped to a value v by an environment map : Adding environments as first-class values to a language can greatly enhance its expressiveness. MIT Scheme [1, 15], T <ref> [18] </ref>, and Symmetric Lisp [8] have shown that records, structures, closures, modules, classes, abstract data types, and inheritance can all be expressed with first-class environments. But since first-class environments rely on identifiers (variable names), ff-conversion (renaming) of variables could lead to context anomalies due to inadvertent name capturing.
Reference: [19] <author> J. E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT, </publisher> <year> 1981. </year> <month> 23 </month>
References-found: 19

