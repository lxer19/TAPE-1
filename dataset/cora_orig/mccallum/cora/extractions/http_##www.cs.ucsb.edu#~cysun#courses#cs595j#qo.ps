URL: http://www.cs.ucsb.edu/~cysun/courses/cs595j/qo.ps
Refering-URL: http://www.cs.ucsb.edu/~ambuj/Courses/595J/index.html
Root-URL: http://www.cs.ucsb.edu
Email: fmchughj,widomg@db.stanford.edu,  
Title: Query Optimization for Semistructured Data  
Author: Jason McHugh, Jennifer Widom 
Web: http://www-db.stanford.edu  
Affiliation: Stanford University  
Abstract: With the emerging prevalence of semistructured data|data that may be irregular or incomplete|it is important to develop efficient query processing techniques for such data. This paper describes the query processor of Lore, a DBMS for semistructured data, and focuses particularly on the cost-based query optimization techniques we have developed and implemented for a semistructured environment. While all of the usual problems associated with cost-based query optimization apply to semistructured data as well, a number of additional problems arise, such as vastly different query execution strategies for different semistructured databases, more complicated notions of database statistics, and novel uses of indexing. We introduce very flexible logical query plans that can be transformed into a wide variety of physical plans, define appropriate database statistics and a cost model, and describe plan enumeration including heuristics for reducing the search space. Our optimizer is fully implemented for most of the Lore query language, and preliminary performance results are reported. 
Abstract-found: 1
Intro-found: 1
Reference: [Abi97] <author> S. Abiteboul. </author> <title> Querying semistructured data. </title> <booktitle> In Proceedings of the International Conference on Database Theory, </booktitle> <pages> pages 1-18, </pages> <address> Delphi, Greece, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Several recent trends, including the integration of data from heterogeneous sources and the emergence of the World-Wide Web, have sparked a great deal of interest in semistructured data <ref> [Abi97, Suc97] </ref>. Unlike well-structured relational, object-relational, or object-oriented data, semistructured data need not adhere to a fixed schema defined in advance. Rather, the schema may evolve as rapidly as the data does and in unpredictable ways.
Reference: [AGM + 97] <author> S. Abiteboul, R. Goldman, J. McHugh, V. Vassalos, and Y. Zhuge. </author> <title> Views for semistructured data. </title> <booktitle> In Proceedings of the Workshop on Management of Semistructured Data, </booktitle> <pages> pages 83-90, </pages> <address> Tucson, Arizona, </address> <month> May </month> <year> 1997. </year> <month> 24 </month>
Reference-contexts: Most of Lorel is functional within the Lore system, including some subqueries, aggregation and arithmetic operations, constructed results, a declarative update language, and view facilities <ref> [AGM + 97, AMR + 97] </ref>. Missing features at the time of writing include full support for arbitrary subqueries, Groupby and OrderBy clauses, external functions and predicates, and full regular expressions appearing within path expressions (although a useful subset of regular expressions is supported).
Reference: [AMR + 97] <author> S. Abiteboul, J. McHugh, M. Rys, V. Vassalos, and J. Wiener. </author> <title> Incremental maintenance for materialized views over semistructured data. </title> <type> Technical report, </type> <institution> Stanford University Database Group, </institution> <year> 1997. </year>
Reference-contexts: Most of Lorel is functional within the Lore system, including some subqueries, aggregation and arithmetic operations, constructed results, a declarative update language, and view facilities <ref> [AGM + 97, AMR + 97] </ref>. Missing features at the time of writing include full support for arbitrary subqueries, Groupby and OrderBy clauses, external functions and predicates, and full regular expressions appearing within path expressions (although a useful subset of regular expressions is supported).
Reference: [AQM + 96] <author> S. Abiteboul, D. Quass, J. McHugh, J. Widom, and J. Wiener. </author> <title> The Lorel query language for semistructured data. </title> <journal> Journal of Digital Libraries, </journal> <volume> 1(1) </volume> <pages> 68-88, </pages> <month> November </month> <year> 1996. </year>
Reference-contexts: Section 3 introduces the Object Exchange Model (OEM) [PGMW95], Lore's self-describing graph-based model for semistructured data. Section 3 also briefly describes Lore's query language Lorel (for Lore Language), mentioning the basic features needed to understand the query optimization process. Details on the full language can be found in <ref> [AQM + 96] </ref>. Section 4 motivates the variety of query execution strategies we can generate through several examples. Section 5 then describes our logical query plans, followed by Section 6 that covers physical plans. Our cost model and statistics are given in Section 7. <p> Details of the syntax and semantics of the current version of Lorel can be found in <ref> [AQM + 96] </ref>. The overall architecture of the Lore system, including the simple query processing strategy we used prior to developing our cost-based query optimizer, can be found in [MAG + 97]. <p> For motivation and further details on the overall Lore system see [MAG + 97]. See <ref> [AQM + 96] </ref> for details on Lorel, Lore's query language. 3.1 Data Model Lore's data model is the Object Exchange Model (OEM), which is designed for semistructured data [PGMW95]. Data in this model can be thought of as a labeled directed graph. <p> Lorel supports a shorthand to write this path expression as "DBGroup.Member.Age y", and further shorthands to eliminate variables such as y <ref> [AQM + 96] </ref>, however for clarity we avoid shorthands in the 4 examples in this paper. Note that this definition of a path expression is more restrictive than Lorel's general path expressions described in [AQM + 96] because in this paper we do not consider regular expressions or "wildcards" appearing within <p> write this path expression as "DBGroup.Member.Age y", and further shorthands to eliminate variables such as y <ref> [AQM + 96] </ref>, however for clarity we avoid shorthands in the 4 examples in this paper. Note that this definition of a path expression is more restrictive than Lorel's general path expressions described in [AQM + 96] because in this paper we do not consider regular expressions or "wildcards" appearing within the path expression. This restriction is further discussed in Section 3.5. 3.2 Query Language Lorel is the query language supported by the Lore DBMS. <p> A shorthand in Lorel allows simply "x.Age &lt; 30" as the Where clause, which is preprocessed automatically into the query as shown <ref> [AQM + 96] </ref>. 5 execution strategy for the query. As we will show in Section 5, generating logical query plans is fairly straightforward, but special care needed to be taken to ensure that the logical query plans are flexible enough to be transformed into vastly different physical query plans. <p> Because of type coercion, multiple B+-trees need to be accessed during a Vindex operation. Currently in Lore, three B+-trees are maintained to coerce the atomic types string, integer, and real among themselves. Depending upon the type of the value in the predicate, two of the B+-trees will be used <ref> [AQM + 96] </ref>. For each, we first traverse down to a depth at most BLevel l;t , where BLevel l;t is the height for the Vindex B+-tree for label l and type t. We assume that each node in the tree requires a page fetch.
Reference: [BDHS96] <author> P. Buneman, S. Davidson, G. Hillebrand, and D. Suciu. </author> <title> A query language and optimization techniques for unstructured data. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 505-516, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: "lightweight" system for "lightweight" objects [QRS + 95]. 1 naively selected from one or two types of simple query plans.) To the best of our knowledge ours is the first complete cost-based optimizer for queries over semistructured data, and because our data model and query language are similar to others <ref> [Cat94, BDHS96] </ref> our approach should certainly be applicable to other ongoing work in the area. <p> The overall architecture of the Lore system, including the simple query processing strategy we used prior to developing our cost-based query optimizer, can be found in [MAG + 97]. The UnQL query language <ref> [BDHS96, FS98] </ref> is based on a data model similar to ours and also is designed specifically for semistructured data. For query optimization, a translation from UnQL to UnCAL is defined [BDHS96], which provides a formal basis for deriving optimization rewrite rules such as pushing selections down. <p> The UnQL query language [BDHS96, FS98] is based on a data model similar to ours and also is designed specifically for semistructured data. For query optimization, a translation from UnQL to UnCAL is defined <ref> [BDHS96] </ref>, which provides a formal basis for deriving optimization rewrite rules such as pushing selections down. However, UnQL does not have a cost-based optimizer as far as we know, and no performance results have been reported.
Reference: [BF97] <author> E. Bertino and P. Foscoli. </author> <title> On modeling cost functions for object-oriented databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 9(3) </volume> <pages> 500-508, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: Thus, query processing in Lore is more complicated than in Model 204, which concentrated primarily on clever bit-mapped indexing structures to achieve high performance. Some recent papers have specified cost models for object-oriented DBMS's, e.g., <ref> [BF97, GGT95] </ref>. Because Lore does not guarantee the object clustering properties assumed by these cost models and does not provide a fixed schema, we were unable to adapt these models immediately for our purposes, and our current cost model is quite a bit more simplistic.
Reference: [Cat94] <author> R.G.G. Cattell. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, California, </address> <year> 1994. </year>
Reference-contexts: "lightweight" system for "lightweight" objects [QRS + 95]. 1 naively selected from one or two types of simple query plans.) To the best of our knowledge ours is the first complete cost-based optimizer for queries over semistructured data, and because our data model and query language are similar to others <ref> [Cat94, BDHS96] </ref> our approach should certainly be applicable to other ongoing work in the area.
Reference: [CCM96] <author> V. Christophides, S. Cluet, and G. Moerkotte. </author> <title> Evaluating queries with generalized path expressions. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 413-422, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Other recent work has focused on optimizing the evaluation of generalized path expressions, which describe traversals through data and may contain regular expressions. In <ref> [CCM96] </ref> an algebraic framework for the optimization of generalized path expressions is proposed, including an approach that avoids exponential input to the query optimizer and offers flexibility in the ordering of operations. <p> We expect that optimization techniques designed specifically for generalized path expressions, such as those in <ref> [CCM96, FS98] </ref>, can be incorporated into our cost-based query optimizer and we hope to do so in the near future. <p> There has been good work on these topics <ref> [CCM96, FS98] </ref> and it is our hope to incorporate some of this work into our optimizer. In addition, the Tindex is new to Lore so it is not yet considered by the optimizer.
Reference: [FNPS79] <author> R. Fagin, J. Nievergelt, N. Pippenger, and H. </author> <title> Strong. Extendible hashing A fast access method for dynamic files. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(3) </volume> <pages> 315-344, </pages> <month> September </month> <year> 1979. </year>
Reference-contexts: We assume that each node in the tree requires a page fetch. We then add I/O cost based on the total number of estimated answers, encapsulated in the Selectivity function described below. The Lindex operator is implemented using extendible hashing <ref> [FNPS79] </ref>, and our cost estimate assumes no overflow buckets. Thus, it requires two page fetches (one for the directory and one for the hash bucket) and one additional page fetch for every possible parent.
Reference: [FS98] <author> M. Fernandez and D. Suciu. </author> <title> Optimizing regular path expressions using graph schemas. </title> <type> Technical report, </type> <institution> AT&T Laboratories, </institution> <year> 1998. </year> <booktitle> To appear in Proceedings of the Fourteenth International Conference on Data Engineering, </booktitle> <address> Orlando, Florida, </address> <month> February </month> <year> 1998. </year>
Reference-contexts: The overall architecture of the Lore system, including the simple query processing strategy we used prior to developing our cost-based query optimizer, can be found in [MAG + 97]. The UnQL query language <ref> [BDHS96, FS98] </ref> is based on a data model similar to ours and also is designed specifically for semistructured data. For query optimization, a translation from UnQL to UnCAL is defined [BDHS96], which provides a formal basis for deriving optimization rewrite rules such as pushing selections down. <p> In [CCM96] an algebraic framework for the optimization of generalized path expressions is proposed, including an approach that avoids exponential input to the query optimizer and offers flexibility in the ordering of operations. In <ref> [FS98] </ref> two optimization techniques for generalized path expressions are presented, query pruning and query rewriting using state extents. <p> We expect that optimization techniques designed specifically for generalized path expressions, such as those in <ref> [CCM96, FS98] </ref>, can be incorporated into our cost-based query optimizer and we hope to do so in the near future. <p> There has been good work on these topics <ref> [CCM96, FS98] </ref> and it is our hope to incorporate some of this work into our optimizer. In addition, the Tindex is new to Lore so it is not yet considered by the optimizer.
Reference: [GGMR97] <author> J. Grant, J. Gryz, J. Minker, and L. Raschid. </author> <title> Semantic query optimization for object databases. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Data Engineering, </booktitle> <pages> pages 444-454, </pages> <address> Birmingham, UK, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: Similar comparisons can be drawn between our work and other recent OODB optimization work, e.g., <ref> [GGMR97, KMP93, OMS95, SO95] </ref>. 3 Preliminaries We first introduce the context of our query optimization work by describing the data model and query language of Lore, the basic architecture of the Lore query processor, and a description of indexing in Lore.
Reference: [GGT95] <author> G. Gardarin, J. Gruser, and Z. Tang. </author> <title> A cost model for clustered object-oriented databases. </title> <booktitle> In Proceedings of the Twenty-First International Conference on Very Large Data Bases, </booktitle> <pages> pages 323-334, </pages> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Thus, query processing in Lore is more complicated than in Model 204, which concentrated primarily on clever bit-mapped indexing structures to achieve high performance. Some recent papers have specified cost models for object-oriented DBMS's, e.g., <ref> [BF97, GGT95] </ref>. Because Lore does not guarantee the object clustering properties assumed by these cost models and does not provide a fixed schema, we were unable to adapt these models immediately for our purposes, and our current cost model is quite a bit more simplistic.
Reference: [GGT96] <author> G. Gardarin, J. Gruser, and Z. Tang. </author> <title> Cost-based selection of path expression processing algorithms in object-oriented databases. </title> <booktitle> In Proceedings of the Twenty-Second International Conference on Very Large Data Bases, </booktitle> <pages> pages 390-401, </pages> <address> Bombay, India, </address> <year> 1996. </year>
Reference-contexts: We expect that optimization techniques designed specifically for generalized path expressions, such as those in [CCM96, FS98], can be incorporated into our cost-based query optimizer and we hope to do so in the near future. In the context of query optimization for standard (well-structured) object-oriented DBMS's, <ref> [GGT96] </ref> proposes a set of algorithms to search for objects satisfying path expressions containing predicates, and analyzes their relative performance.
Reference: [Gra93] <author> G. Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <year> 1993. </year>
Reference-contexts: A physical query plan is a tree composed of physical operators that are implemented by the query execution engine and perform the low-level steps required to execute the query and construct the result. We use a recursive iterator approach in query processing, as described in, e.g., <ref> [Gra93] </ref>. With iterators, execution begins at the top of the tree-structured query plan, with each node in the plan requesting a "tuple" at a time from its children and performing some operation on the tuple (s).
Reference: [GW97] <author> R. Goldman and J. Widom. Dataguides: </author> <title> Enabling query formulation and optimization in semistructured databases. </title> <booktitle> In Proceedings of the Twenty-Third International Conference on Very Large Data Bases, </booktitle> <pages> pages 436-445, </pages> <address> Athens, Greece, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: The edge index, which we term the Bindex, supports finding all parent-child object pairs that are connected via a specified labeled edge. Our full text index, or Tindex, supports finding atomic string values that match an information-retrieval style pattern. In addition to these indexes, Lore's DataGuide <ref> [GW97] </ref> provides 6 the functionality of a path index, or Pindex. Since a frequent use of Lore is as a read-only query engine for data imported from the World-Wide Web, we have found that the overhead of building, storing, and maintaining all of these indexes usually is worthwhile. <p> Aggregation SourceVar, Op, DestVar Perform the aggregation operation, Op, over SourceVar. In addition, this operator can be used to ensure that at least one object was successfully bound to SourceVar. 13 3. TargetSet: Lore maintains a dynamic "structural summary" of the current data called a DataGuide <ref> [GW97] </ref>. The DataGuide also can be used as a path index enabling quick retrieval of oid's for all objects reachable via a given path expression. The set of oids is called the Target Set for a path expression. <p> Although the lack of a schema makes it appear difficult to collect and store statistics, it turns out that the DataGuide <ref> [GW97] </ref>, introduced earlier in Section 6, is the perfect vehicle. Roughly, the DataGuide, which is a "structural summary" of the database, maintains statistics for each distinct path expres 16 sion by annotating corresponding single paths in the DataGuide. <p> Further details on how the DataGuide computes and stores statistics for path expressions appear in <ref> [GW97] </ref>. As mentioned earlier, our cost metric is based on the estimated number of objects fetched during evaluation of the query.
Reference: [KMP93] <author> A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> A blackboard architecture for query optimization in object bases. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 543-554, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Similar comparisons can be drawn between our work and other recent OODB optimization work, e.g., <ref> [GGMR97, KMP93, OMS95, SO95] </ref>. 3 Preliminaries We first introduce the context of our query optimization work by describing the data model and query language of Lore, the basic architecture of the Lore query processor, and a description of indexing in Lore.
Reference: [MAG + 97] <author> J. McHugh, S. Abiteboul, R. Goldman, D. Quass, and J. Widom. </author> <title> Lore: A database management system for semistructured data. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 26(3) </volume> <pages> 54-66, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: We decided to build Lore from scratch so that we could experiment with how the semistructured nature of our data affects each component of the DBMS. For an overview of the Lore system and discussion of the issues we have addressed in its various components see <ref> [MAG + 97] </ref>. Lore has evolved into a full-feature multi-user DBMS and is available to the public; see www-db.stanford.edu/lore. <p> Details of the syntax and semantics of the current version of Lorel can be found in [AQM + 96]. The overall architecture of the Lore system, including the simple query processing strategy we used prior to developing our cost-based query optimizer, can be found in <ref> [MAG + 97] </ref>. The UnQL query language [BDHS96, FS98] is based on a data model similar to ours and also is designed specifically for semistructured data. <p> For motivation and further details on the overall Lore system see <ref> [MAG + 97] </ref>. See [AQM + 96] for details on Lorel, Lore's query language. 3.1 Data Model Lore's data model is the Object Exchange Model (OEM), which is designed for semistructured data [PGMW95]. Data in this model can be thought of as a labeled directed graph. <p> Select m1.Name, m2.Name From DBGroup.Member m1, m1.Project p1, DBGroup.Member m2, m2.Project p2 Where p1 = p2 and exists a1 in m1.Age: exists a2 in m2.Age: abs (a1 - a2) &gt; 10 3.3 Lore Query Processing The general architecture of the Lore system looks very much like a traditional DBMS <ref> [MAG + 97] </ref>. The components most relevant to this paper are the query compilation and query execution components shown in Figure 2. After a query is parsed, it is preprocessed to convert the Lorel shorthands into a more traditional OQL form. <p> When comparing values of different types, Lore always attempts to coerce the values into comparable types. The current indexing system deals with coercions involving integers, reals, and strings only, although it can easily be generalized. Further details on how the Vindex handles coercion can be found in <ref> [MAG + 97] </ref>. 3.5 Relevant Lorel Subsets Like SQL and OQL, Lorel is a big language. Most of Lorel is functional within the Lore system, including some subqueries, aggregation and arithmetic operations, constructed results, a declarative update language, and view facilities [AGM + 97, AMR + 97].
Reference: [OMS95] <author> M. T. Ozsu, A. Munoz, and D. Szafron. </author> <title> An extensible query optimizer for an objectbase management system. </title> <booktitle> In Proceedings of the Fourth International Conference on Information and Knowledge Management, </booktitle> <pages> pages 188-196, </pages> <address> Baltimore, Maryland, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Similar comparisons can be drawn between our work and other recent OODB optimization work, e.g., <ref> [GGMR97, KMP93, OMS95, SO95] </ref>. 3 Preliminaries We first introduce the context of our query optimization work by describing the data model and query language of Lore, the basic architecture of the Lore query processor, and a description of indexing in Lore.
Reference: [O'N87] <author> Patrick O'Neil. </author> <title> Model 204 architecture and performance. </title> <booktitle> In Proceedings of the 2nd International Workshop on High Performance Transaction Systems (HPTS), </booktitle> <pages> pages 40-59, </pages> <address> Asilomar, CA, </address> <year> 1987. </year>
Reference-contexts: However, UnQL does not have a cost-based optimizer as far as we know, and no performance results have been reported. A much earlier system, Model 204 <ref> [O'N87] </ref>, was based on self-describing record structures that can be thought of as semistructured data. Lore's data model is more powerful in that it includes arbitrary object nesting, so Lore's query language 2 is richer than the language of Model 204.
Reference: [PGMW95] <author> Y. Papakonstantinou, H. Garcia-Molina, and J. Widom. </author> <title> Object exchange across heterogeneous information sources. </title> <booktitle> In Proceedings of the Eleventh International Conference on Data Engineering, </booktitle> <pages> pages 251-260, </pages> <address> Taipei, Taiwan, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: Finally, since our search space is at least as large as one finds in a conventional optimizer, we needed to develop pruning heuristics appropriate to our query plan enumeration strategy. Section 2 surveys related work. Section 3 introduces the Object Exchange Model (OEM) <ref> [PGMW95] </ref>, Lore's self-describing graph-based model for semistructured data. Section 3 also briefly describes Lore's query language Lorel (for Lore Language), mentioning the basic features needed to understand the query optimization process. Details on the full language can be found in [AQM + 96]. <p> For motivation and further details on the overall Lore system see [MAG + 97]. See [AQM + 96] for details on Lorel, Lore's query language. 3.1 Data Model Lore's data model is the Object Exchange Model (OEM), which is designed for semistructured data <ref> [PGMW95] </ref>. Data in this model can be thought of as a labeled directed graph. For example, the very small OEM database shown in Figure 1 contains (fictitious) information about the Stanford Database Group.
Reference: [PSC84] <author> G. Piatetsky-Shapiro and C. Connell. </author> <title> Accurate estimation of the number of tuples satisfying a condition. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 256-276, </pages> <address> Boston, MA, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: When estimating the number of atomic objects that will satisfy a given predicate, the usual formulas, e.g., those given in <ref> [SAC + 79, PSC84] </ref>, are insufficient in our semistructured environment due to the extensive type coercion that Lore performs. <p> Determined recur sively; details omitted. * Selectivity (P red): the estimated selectivity of predicate Pred. We use <ref> [SAC + 79, PSC84] </ref> as a base with extensions to handle type coercion. * Struct (plan): the estimated number of object fetches to read and write the set of intermediate structures returned by subplan plan.
Reference: [QRS + 95] <author> D. Quass, A. Rajaraman, Y. Sagiv, J. Ullman, and J. Widom. </author> <title> Querying semistructured heterogeneous information. </title> <booktitle> In Proceedings of the Fourth International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 319-344, </pages> <address> Singapore, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: and implemented. (Earlier versions of Lore's query processor fl This work was supported by the Air Force Rome Laboratories and DARPA under Contracts F30602-95-C-0119 and F30602-96-1-031. 1 The name Lore derives from Lightweight Object Repository, initially indicative of the fact that we were building a "lightweight" system for "lightweight" objects <ref> [QRS + 95] </ref>. 1 naively selected from one or two types of simple query plans.) To the best of our knowledge ours is the first complete cost-based optimizer for queries over semistructured data, and because our data model and query language are similar to others [Cat94, BDHS96] our approach should certainly <p> Finally, some preliminary performance results are reported in Section 9, although exhaustive performance evaluation is not the focus of this paper. 2 Related Work The first version of the Lorel query language and initial ideas for the Lore system were presented in <ref> [QRS + 95] </ref>. Details of the syntax and semantics of the current version of Lorel can be found in [AQM + 96].
Reference: [SAC + 79] <author> P. Selinger, M. Astrahan, D. Chamberlin, R. Lorie, and T. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, MA, </address> <month> June </month> <year> 1979. </year>
Reference-contexts: When estimating the number of atomic objects that will satisfy a given predicate, the usual formulas, e.g., those given in <ref> [SAC + 79, PSC84] </ref>, are insufficient in our semistructured environment due to the extensive type coercion that Lore performs. <p> Determined recur sively; details omitted. * Selectivity (P red): the estimated selectivity of predicate Pred. We use <ref> [SAC + 79, PSC84] </ref> as a base with extensions to handle type coercion. * Struct (plan): the estimated number of object fetches to read and write the set of intermediate structures returned by subplan plan.
Reference: [SO95] <author> D. D. Straube and M. T. Ozsu. </author> <title> Query optimization and execution plan generation in object-oriented database systems. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(2) </volume> <pages> 210-227, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Similar comparisons can be drawn between our work and other recent OODB optimization work, e.g., <ref> [GGMR97, KMP93, OMS95, SO95] </ref>. 3 Preliminaries We first introduce the context of our query optimization work by describing the data model and query language of Lore, the basic architecture of the Lore query processor, and a description of indexing in Lore.
Reference: [Suc97] <editor> D. Suciu, editor. </editor> <booktitle> Proceedings of the Workshop on Management of Semistructured Data. </booktitle> <address> Tucson, Arizona, </address> <month> May </month> <year> 1997. </year> <month> 26 </month>
Reference-contexts: 1 Introduction Several recent trends, including the integration of data from heterogeneous sources and the emergence of the World-Wide Web, have sparked a great deal of interest in semistructured data <ref> [Abi97, Suc97] </ref>. Unlike well-structured relational, object-relational, or object-oriented data, semistructured data need not adhere to a fixed schema defined in advance. Rather, the schema may evolve as rapidly as the data does and in unpredictable ways.
References-found: 25

