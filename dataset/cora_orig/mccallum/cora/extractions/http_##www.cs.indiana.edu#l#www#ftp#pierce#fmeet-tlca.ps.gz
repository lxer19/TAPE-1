URL: http://www.cs.indiana.edu/l/www/ftp/pierce/fmeet-tlca.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: Intersection Types and Bounded Polymorphism  
Author: Benjamin C. Pierce 
Abstract: Intersection types and bounded quantification are complementary extensions of first-order a statically typed programming language with subtyp-ing. We define a typed -calculus combining these extensions, illustrate its properties, and develop proof-theoretic results leading to algorithms for subtyp-ing and typechecking. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Franco Barbanera and Mariangiola Dezani-Ciancaglini. </author> <title> Intersection and union types. </title> <booktitle> In Ito and Meyer [21], </booktitle> <pages> pages 651-674. </pages>
Reference-contexts: This shortcoming, while not serious in practice, has motivated the investigation of a dual notion of union types <ref> [1, 20, 26] </ref>.) The refinement in the types of true, false, and if can now be exploited in typing new functions: &gt; or = &gt; "x:True,False,Bool. "y:True,False,Bool. &gt; for R in True,False,Bool. &gt; if [R] x true y; or : Bool-&gt;(Bool->Bool/"True-&gt;True) /" False-&gt;False->False /" True-&gt;Bool->True In fact, we can carry out
Reference: [2] <author> H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. </author> <title> A filter lambda model and the completeness of type assignment. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 48(4) </volume> <pages> 931-940, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction Among the intriguing properties of intersection types <ref> [2, 12, 14, 29, 33] </ref> is their ability to carry detailed information about the way a function behaves when used in different contexts.
Reference: [3] <author> Val Breazu-Tannen, Thierry Coquand, Carl Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: Intersection types are also used in Forsythe to give an elegant treatment of mutable reference cells by combining the more primitive concepts of "sources for values" and "destinations for values." Bounded quantification <ref> [11, 3, 15, 10] </ref>, on the other hand, integrates parametric polymorphism [18, 30] with subtyping by allowing a quantified type to give an upper bound for its parameter; for example, an inhabitant of 8ff Student: List (ff)!List (ff) takes as its first parameter an arbitrary subtype of the type Student and <p> The algorithm presented here generalizes both Reynolds' decision procedure for the subtype relation of Forsythe [personal communication, 1988] and the standard subtyping algorithm for F <ref> [3, 15] </ref>. Because of the axioms Sub-Dist-IA and Sub-Dist-IQ, we cannot check whether ` t just by comparing the outermost constructors of and t and making recursive calls. <p> since F fi itself has many well-studied models, but it still yields a useful soundness theorem relating the semantics to the F ^ type system: valid F ^ typing derivations are translated to well-typed (and hence well-behaved) F fi terms.) However, this construction has not been shown to be coherent <ref> [3] </ref>, because the standard proof of this property for ^ [32] relies on the existence of least upper bounds in the subtype relation | a property that F ^ does not share.
Reference: [4] <author> Kim B. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming languages. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: This calculus, called F ^ ("F-meet"), provides a formal basis for new programming languages combining the benefits of existing languages based on intersection types [31] or bounded quantification <ref> [8, 24, 4] </ref> alone: a simple, semantically clean mechanism for overloading functions, the possibility of code optimization during typechecking, Forsythe's treatment of references, and all the well-known benefits of parametric polymorphism. <p> F ^ has also been used by Ma [22] as the basis for a syntactical analysis of parametricity in System F. Recent accounts of object-oriented inheritance using higher-order extensions of bounded quantification <ref> [4, 9, 23, 28] </ref> suggest that a higher-order generalization of F ^ would be an appropriate setting for a type theoretic account of multiple inheritance. The following section establishes some notational conventions and reviews the definitions of the pure systems of intersections and bounded quantification.
Reference: [5] <author> Kim B. Bruce and Giuseppe Longo. </author> <title> A modest model of records, inheritance, and bounded quantification. </title> <journal> Information and Computation, </journal> <volume> 87 </volume> <pages> 196-240, </pages> <year> 1990. </year> <note> To appear in [19]. An earlier version appeared in the proceedings of the IEEE Symposium on Logic in Computer Science, </note> <year> 1988. </year>
Reference-contexts: Proof: Straightforward induction, using the properties of allbasis and arrowbasis for the application cases. 7 Semantics A straightforward untyped semantics can be given for F ^ by extending Bruce and Longo's partial equivalence relation model for F <ref> [5] </ref>. The ^ type constructor is interpreted as intersection of PERs, and the bounded quantifier is interpreted as an infinite intersection.
Reference: [6] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year> <title> Preliminary version in Semantics of Data Types, </title> <editor> Kahn, MacQueen, and Plotkin, eds., </editor> <publisher> Springer-Verlag LNCS 173, </publisher> <year> 1984. </year>
Reference-contexts: as possible. 2.1 Simply Typed -Calculus with Subtyping The first-order -calculus with intersection types (called ^ here) and the second-order -calculus with bounded quantification (called F ) can both be presented as extensions of the simply typed -calculus enriched with a subtyping relation ( ), a system proposed by Cardelli <ref> [6] </ref> as a "core calculus of subtyping" in a foundational framework for object-oriented programming languages.
Reference: [7] <author> Luca Cardelli. F-sub, </author> <title> the system. </title> <type> Unpublished manuscript, </type> <month> July </month> <year> 1991. </year>
Reference-contexts: Another consideration for any language based on second-order polymorphism is the problem of verbosity. Without some means of abbreviation or partial type inference, even modest programs quickly become overburdened with type annotations. Cardelli's partial type inference method for F <ref> [7] </ref> offers one promising direction of investigation. Another possibility is to use a !-order extension of F ^ , in which type operators could be used to express type information more succinctly.
Reference: [8] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> An earlier version appeared as DEC Systems Research Center Research Report #45, Febru-ary 1989. </note>
Reference-contexts: This calculus, called F ^ ("F-meet"), provides a formal basis for new programming languages combining the benefits of existing languages based on intersection types [31] or bounded quantification <ref> [8, 24, 4] </ref> alone: a simple, semantically clean mechanism for overloading functions, the possibility of code optimization during typechecking, Forsythe's treatment of references, and all the well-known benefits of parametric polymorphism.
Reference: [9] <author> Luca Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. </title> <note> Research report 81, DEC Systems Research Center, January 1992. To appear in [19]. </note>
Reference-contexts: F ^ has also been used by Ma [22] as the basis for a syntactical analysis of parametricity in System F. Recent accounts of object-oriented inheritance using higher-order extensions of bounded quantification <ref> [4, 9, 23, 28] </ref> suggest that a higher-order generalization of F ^ would be an appropriate setting for a type theoretic account of multiple inheritance. The following section establishes some notational conventions and reviews the definitions of the pure systems of intersections and bounded quantification.
Reference: [10] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <booktitle> In Ito and Meyer [21], </booktitle> <pages> pages 750-770. </pages>
Reference-contexts: Intersection types are also used in Forsythe to give an elegant treatment of mutable reference cells by combining the more primitive concepts of "sources for values" and "destinations for values." Bounded quantification <ref> [11, 3, 15, 10] </ref>, on the other hand, integrates parametric polymorphism [18, 30] with subtyping by allowing a quantified type to give an upper bound for its parameter; for example, an inhabitant of 8ff Student: List (ff)!List (ff) takes as its first parameter an arbitrary subtype of the type Student and
Reference: [11] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Intersection types are also used in Forsythe to give an elegant treatment of mutable reference cells by combining the more primitive concepts of "sources for values" and "destinations for values." Bounded quantification <ref> [11, 3, 15, 10] </ref>, on the other hand, integrates parametric polymorphism [18, 30] with subtyping by allowing a quantified type to give an upper bound for its parameter; for example, an inhabitant of 8ff Student: List (ff)!List (ff) takes as its first parameter an arbitrary subtype of the type Student and
Reference: [12] <author> Felice Cardone and Mario Coppo. </author> <title> Two extensions of Curry's type inference system. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, number 31 in APIC Studies in Data Processing, </booktitle> <pages> pages 19-76. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Among the intriguing properties of intersection types <ref> [2, 12, 14, 29, 33] </ref> is their ability to carry detailed information about the way a function behaves when used in different contexts.
Reference: [13] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: The rules for variables, abstractions, and applications are exactly the same as in the ordinary simply typed -calculus <ref> [13] </ref>.
Reference: [14] <author> M. Coppo and M. Dezani-Ciancaglini. </author> <title> A new type-assignment for -terms. </title> <journal> Archiv. Math. Logik, </journal> <volume> 19 </volume> <pages> 139-156, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction Among the intriguing properties of intersection types <ref> [2, 12, 14, 29, 33] </ref> is their ability to carry detailed information about the way a function behaves when used in different contexts.
Reference: [15] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption: </title> <booktitle> Minimum typng and type-checking in f . Mathematical Structures in Computer Science, </booktitle> <volume> 2 </volume> <pages> 55-91, </pages> <year> 1992. </year> <note> To appear in [19]. </note>
Reference-contexts: Intersection types are also used in Forsythe to give an elegant treatment of mutable reference cells by combining the more primitive concepts of "sources for values" and "destinations for values." Bounded quantification <ref> [11, 3, 15, 10] </ref>, on the other hand, integrates parametric polymorphism [18, 30] with subtyping by allowing a quantified type to give an upper bound for its parameter; for example, an inhabitant of 8ff Student: List (ff)!List (ff) takes as its first parameter an arbitrary subtype of the type Student and <p> The algorithm presented here generalizes both Reynolds' decision procedure for the subtype relation of Forsythe [personal communication, 1988] and the standard subtyping algorithm for F <ref> [3, 15] </ref>. Because of the axioms Sub-Dist-IA and Sub-Dist-IQ, we cannot check whether ` t just by comparing the outermost constructors of and t and making recursive calls. <p> where all intersections appear on the outside or on the left of arrows or quantifiers. (The advantage of this presentation is that it does not need distributivity rules.) The algorithm is then shown to be complete for this system by an extension of the method used by Curien and Ghelli <ref> [15] </ref> for showing the completeness of the subtyping algorithm for F : give a system of rewriting rules on derivations in this system, eliminating instances of transitivity by pushing them toward the leaves of the derivation, find a terminating reduction strategy for these rules, and observe that the resulting normal-form derivations
Reference: [16] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: Types, terms, contexts, and statements that differ only in the names of bound variables are considered identical. (That is., we think of variables not as names but as pointers into the surrounding context, as suggested by deBruijn <ref> [16] </ref>.) Examples are set in a typewriter font; -calculus notation is transliterated as follows: &gt; is written as T, as ", fl as "", 8 as All, and as &lt;. Lines of input to the typechecker are prefixed with &gt; and followed by the system's response.
Reference: [17] <author> Giorgio Ghelli. </author> <title> A static type system for message passing. </title> <booktitle> In Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 129-143, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year> <journal> Distributed as SIGPLAN Notices, </journal> <volume> Volume 26, Number 11, </volume> <month> November </month> <year> 1991. </year>
Reference-contexts: This relation is undecidable [27, 25], so a semi-decision procedure is the best we can hope for; however, the same algorithm forms a decision procedure for a large fragment of F ^ , believed to contain all but some extremely pathological terms <ref> [17] </ref>. The algorithm presented here generalizes both Reynolds' decision procedure for the subtype relation of Forsythe [personal communication, 1988] and the standard subtyping algorithm for F [3, 15].
Reference: [18] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Intersection types are also used in Forsythe to give an elegant treatment of mutable reference cells by combining the more primitive concepts of "sources for values" and "destinations for values." Bounded quantification [11, 3, 15, 10], on the other hand, integrates parametric polymorphism <ref> [18, 30] </ref> with subtyping by allowing a quantified type to give an upper bound for its parameter; for example, an inhabitant of 8ff Student: List (ff)!List (ff) takes as its first parameter an arbitrary subtype of the type Student and returns a function on lists of values of this type.
Reference: [19] <author> Carl A. Gunter and John C. Mitchell. </author> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference: [20] <author> Susumu Hayashi. </author> <title> Singleton, union and intersection types for program extraction. </title> <booktitle> In Ito and Meyer [21], </booktitle> <pages> pages 701-730. </pages> <note> To appear in Information and Computation. </note>
Reference-contexts: This shortcoming, while not serious in practice, has motivated the investigation of a dual notion of union types <ref> [1, 20, 26] </ref>.) The refinement in the types of true, false, and if can now be exploited in typing new functions: &gt; or = &gt; "x:True,False,Bool. "y:True,False,Bool. &gt; for R in True,False,Bool. &gt; if [R] x true y; or : Bool-&gt;(Bool->Bool/"True-&gt;True) /" False-&gt;False->False /" True-&gt;Bool->True In fact, we can carry out
Reference: [21] <editor> T. Ito and A. R. Meyer, editors. </editor> <booktitle> Theoretical Aspects of Computer Software (Sendai, Japan), number 526 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1991. </year>
Reference: [22] <author> QingMing Ma. </author> <title> Parametricity as subtyping. </title> <booktitle> In Proceedings of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albequerque, NM, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: F ^ has also been used by Ma <ref> [22] </ref> as the basis for a syntactical analysis of parametricity in System F. Recent accounts of object-oriented inheritance using higher-order extensions of bounded quantification [4, 9, 23, 28] suggest that a higher-order generalization of F ^ would be an appropriate setting for a type theoretic account of multiple inheritance.
Reference: [23] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year> <note> To appear in [19]. </note>
Reference-contexts: F ^ has also been used by Ma [22] as the basis for a syntactical analysis of parametricity in System F. Recent accounts of object-oriented inheritance using higher-order extensions of bounded quantification <ref> [4, 9, 23, 28] </ref> suggest that a higher-order generalization of F ^ would be an appropriate setting for a type theoretic account of multiple inheritance. The following section establishes some notational conventions and reviews the definitions of the pure systems of intersections and bounded quantification.
Reference: [24] <author> John Mitchell, Sigurd Meldal, and Neel Madhav. </author> <title> An extension of Standard ML modules with subtyping and inheritance. </title> <booktitle> In Proceedings of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 270-278, </pages> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: This calculus, called F ^ ("F-meet"), provides a formal basis for new programming languages combining the benefits of existing languages based on intersection types [31] or bounded quantification <ref> [8, 24, 4] </ref> alone: a simple, semantically clean mechanism for overloading functions, the possibility of code optimization during typechecking, Forsythe's treatment of references, and all the well-known benefits of parametric polymorphism.
Reference: [25] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Poly-morphism. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> December </month> <year> 1991. </year> <note> Available as School of Computer Science technical report CMU-CS-91-205. </note>
Reference-contexts: Section 7 discusses semantic issues, and Section 8 offers directions for future research. A more detailed presentation of these results can be found in <ref> [25] </ref>. 2 Background The metavariables ff and fi range over type variables; , t , , , and range over types; e and f range over terms; and x and y range over term variables. <p> This relation is undecidable <ref> [27, 25] </ref>, so a semi-decision procedure is the best we can hope for; however, the same algorithm forms a decision procedure for a large fragment of F ^ , believed to contain all but some extremely pathological terms [17].
Reference: [26] <author> Benjamin C. Pierce. </author> <title> Programming with intersection types, union types, and poly-morphism. </title> <type> Technical Report CMU-CS-91-106, </type> <institution> Carnegie Mellon University, </institution> <month> Febru-ary </month> <year> 1991. </year>
Reference-contexts: This shortcoming, while not serious in practice, has motivated the investigation of a dual notion of union types <ref> [1, 20, 26] </ref>.) The refinement in the types of true, false, and if can now be exploited in typing new functions: &gt; or = &gt; "x:True,False,Bool. "y:True,False,Bool. &gt; for R in True,False,Bool. &gt; if [R] x true y; or : Bool-&gt;(Bool->Bool/"True-&gt;True) /" False-&gt;False->False /" True-&gt;Bool->True In fact, we can carry out
Reference: [27] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <journal> Information and Computation, </journal> <note> 1993. To appear; also to appear in [19]. Preliminary version in proceedings of POPL '91. </note>
Reference-contexts: This relation is undecidable <ref> [27, 25] </ref>, so a semi-decision procedure is the best we can hope for; however, the same algorithm forms a decision procedure for a large fragment of F ^ , believed to contain all but some extremely pathological terms [17].
Reference: [28] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Object-oriented programming without recursive types. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year> <note> Also available as University of Edinburgh technical report number ECS-LFCS-92-225. </note>
Reference-contexts: F ^ has also been used by Ma [22] as the basis for a syntactical analysis of parametricity in System F. Recent accounts of object-oriented inheritance using higher-order extensions of bounded quantification <ref> [4, 9, 23, 28] </ref> suggest that a higher-order generalization of F ^ would be an appropriate setting for a type theoretic account of multiple inheritance. The following section establishes some notational conventions and reviews the definitions of the pure systems of intersections and bounded quantification.
Reference: [29] <author> Garrell Pottinger. </author> <title> A type assignment for the strongly normalizable -terms. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pages 561-577. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: 1 Introduction Among the intriguing properties of intersection types <ref> [2, 12, 14, 29, 33] </ref> is their ability to carry detailed information about the way a function behaves when used in different contexts.
Reference: [30] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, </booktitle> <pages> pages 408-425, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag LNCS 19. </publisher>
Reference-contexts: Intersection types are also used in Forsythe to give an elegant treatment of mutable reference cells by combining the more primitive concepts of "sources for values" and "destinations for values." Bounded quantification [11, 3, 15, 10], on the other hand, integrates parametric polymorphism <ref> [18, 30] </ref> with subtyping by allowing a quantified type to give an upper bound for its parameter; for example, an inhabitant of 8ff Student: List (ff)!List (ff) takes as its first parameter an arbitrary subtype of the type Student and returns a function on lists of values of this type.
Reference: [31] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: A compiler for a language with intersection types might even provide two different object-code sequences for the different versions of +, one using a floating point addition instruction and one using integer addition. Reynolds' Forsythe language <ref> [31] </ref> illustrates this coherent overloading in the context of a practical type system organized around a notion of subtyping. <p> This calculus, called F ^ ("F-meet"), provides a formal basis for new programming languages combining the benefits of existing languages based on intersection types <ref> [31] </ref> or bounded quantification [8, 24, 4] alone: a simple, semantically clean mechanism for overloading functions, the possibility of code optimization during typechecking, Forsythe's treatment of references, and all the well-known benefits of parametric polymorphism. <p> or Real (or Int^Real, or indeed | assuming we could write it | Int _ Real) gives a typing that is too restrictive: &gt; double1 = "x:Int. plus x x; double1 : Int -&gt; Int &gt; double2 = "x:Real. plus x x; double2 : Real -&gt; Real This led Reynolds <ref> [31] </ref> to introduce a generalized form of -abstraction allowing explicit programmer-controlled generation of alternative typings for terms: e ::= : : : j x:t 1 ::t n : e The typing rule for this form allows the typechecker to make a choice of any of the 's as the type of <p> The ^ type constructor is interpreted as intersection of PERs, and the bounded quantifier is interpreted as an infinite intersection. More refined models have been given for intersections (c.f. <ref> [31] </ref>) interpreting ^ as a limit in the semantic category, and a typed semantics of F ^ can be given along these lines as well, by translating F ^ typing derivations into the pure second-order -calculus with surjective pairing, system F fi . (This style of presentation avoids some of the
Reference: [32] <author> John C. Reynolds. </author> <title> The coherence of languages with intersection types. </title> <booktitle> In Ito and Meyer [21], </booktitle> <pages> pages 675-700. </pages>
Reference-contexts: still yields a useful soundness theorem relating the semantics to the F ^ type system: valid F ^ typing derivations are translated to well-typed (and hence well-behaved) F fi terms.) However, this construction has not been shown to be coherent [3], because the standard proof of this property for ^ <ref> [32] </ref> relies on the existence of least upper bounds in the subtype relation | a property that F ^ does not share.
Reference: [33] <author> P. </author> <title> Salle. Une extension de la theorie des types en -calcul. </title> <address> pages 398-410. </address> <publisher> Springer-Verlag, </publisher> <year> 1982. </year> <note> Lecture Notes in Computer Science No. 62. </note>
Reference-contexts: 1 Introduction Among the intriguing properties of intersection types <ref> [2, 12, 14, 29, 33] </ref> is their ability to carry detailed information about the way a function behaves when used in different contexts.
References-found: 33

