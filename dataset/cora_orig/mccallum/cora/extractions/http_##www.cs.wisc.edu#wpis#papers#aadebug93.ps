URL: http://www.cs.wisc.edu/wpis/papers/aadebug93.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: 
Email: tom@cs.wisc.edu horwitz@cs.wisc.edu  
Title: Slicing Programs with Arbitrary Control Flow understanding program behavior. Given a program point p and
Author: THOMAS BALL SUSAN HORWITZ 
Note: other applications that involve  
Address: Wisconsin/1210 W. Dayton St./Madison, WI 53706/USA  
Affiliation: Computer Sciences Department/University of  
Abstract: This paper addresses the problem of slicing programs with arbitrary control flow. Previous slicing algo rithms do not always form semantically correct program projections when applied to such programs. We give the first algorithm for slicing programs with complex control flow and a proof of its correctness. Our algorithm works for programs with completely arbitrary control flow, including irreducible control flow.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A., Sethi, R., and Ullman, J., </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: Our algorithm works for programs with completely arbitrary control flow, including irreducible control flow <ref> [1] </ref>. (As given here, our algorithm has a slight technical restriction: A program is sliced with respect to a point p and the set of variables used or defined at p rather than an arbitrary set of variables. <p> We focus on the Ottensteins' algorithm and consider the problems that arise if one tries to apply this algorithm to programs with unstructured control flow. The Ottensteins' algorithm makes use of two program representations: the control flow graph <ref> [1] </ref> and the program dependence graph [4]. Vertices in the control flow graph represent statements and predicates in the program and edges represent the flow of control in the program. The program dependence graph has the same vertex set as the control flow graph. <p> We assume that the reader is familiar with the standard control flow translations of the control constructs specified in Section 2.1 <ref> [1] </ref>. In the standard translation from a program to a CFG, the CFG includes a vertex for every assignment statement, output statement, and predicate in the program. The edges of the CFG represent the flow of control (the ENTRY vertex's true-successor is the first statement in the program).
Reference: 2. <author> Baker, B., </author> <title> An algorithm for structuring flowgraphs, </title> <journal> JACM 24(1) pp. </journal> <month> 98-120 (January </month> <year> 1977). </year>
Reference-contexts: For example, given a program P with standard CFG G, one could construct the minimal flow/path-projection of G with respect to some vertex (using backwards-closure in the PDG to identify the required vertices) and then synthesize a program from that CFG using a structuring algorithm such as Baker's <ref> [2] </ref>. However, in a language with unstructured control flow, there can be many programs with the same CFG.
Reference: 3. <author> Ball, T. and Horwitz, S., </author> <title> Slicing programs with arbitrary control flow, </title> <type> Technical Report 1128, </type> <institution> Department of Computer Sciences, University of WisconsinMadison (December 1992). </institution>
Reference-contexts: Section 2 provides background material, including a discussion of the language under consideration, and the definitions of control flow graph and program dependence graph. Section 3 presents our slicing algorithm and gives an outline of its proof of correctness (a full proof can be found in <ref> [3] </ref>). Section 4 discusses the issues of minimal slices, and of the extensibility of our slicing algorithm. Section 5 summarizes our results. 2. BACKGROUND 2.1. <p> Proof of Correctness In this section we sketch a proof that our slicing algorithm produces a program projection with the desired semantic property. Because of space limitations, we are unable to give the full proof here. Details of the proof can be found in <ref> [3] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 A precise definition of what it means to eliminate a program component is given in [3]. In short, the elimination operation is defined in terms of the program's abstract-syntax tree; every vertex in the program's PDG corresponds to a node in the abstract-syntax tree. <p> Because of space limitations, we are unable to give the full proof here. Details of the proof can be found in <ref> [3] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 A precise definition of what it means to eliminate a program component is given in [3]. In short, the elimination operation is defined in terms of the program's abstract-syntax tree; every vertex in the program's PDG corresponds to a node in the abstract-syntax tree. <p> To prove this, we have shown that the relationships pictured below hold (see <ref> [3] </ref> for details).
Reference: 4. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(3) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: We focus on the Ottensteins' algorithm and consider the problems that arise if one tries to apply this algorithm to programs with unstructured control flow. The Ottensteins' algorithm makes use of two program representations: the control flow graph [1] and the program dependence graph <ref> [4] </ref>. Vertices in the control flow graph represent statements and predicates in the program and edges represent the flow of control in the program. The program dependence graph has the same vertex set as the control flow graph. <p> of the variables used or defined at the point with respect to which the slice is taken. 4 H (s) may or may not terminate normally in this case. 5 In addition to control and flow dependences, program dependence graphs usually include either def-order dependences [5] or output and anti-dependences <ref> [4] </ref>. These additional edges are not needed for program slicing, and so are omitted from the definition given here. We also do not need to distinguish between loop-independent and loop-carried dependences (which are ill-defined for irreducible control flow).
Reference: 5. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> On the adequacy of program dependence graphs for representing programs, pp. </title> <booktitle> 146-157 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), (1988). </year>
Reference-contexts: only to preserve the values of the variables used or defined at the point with respect to which the slice is taken. 4 H (s) may or may not terminate normally in this case. 5 In addition to control and flow dependences, program dependence graphs usually include either def-order dependences <ref> [5] </ref> or output and anti-dependences [4]. These additional edges are not needed for program slicing, and so are omitted from the definition given here. We also do not need to distinguish between loop-independent and loop-carried dependences (which are ill-defined for irreducible control flow).
Reference: 6. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Transactions on Programming Languages and Systems 11(3) pp. </journal> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: 1. INTRODUCTION Program slicing, a program transformation originally defined by Mark Weiser [12], is useful in program debug ging [9], program maintenance <ref> [6] </ref>, and other applications that involve understanding program behavior [8].
Reference: 7. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Transactions on Programming Languages and Systems 12(1) pp. </journal> <month> 26-60 (January </month> <year> 1990). </year>
Reference: 8. <author> Horwitz, S., </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June </month> <year> 1990), </year> <pages> pp. </pages> <month> 234-246 (June </month> <year> 1990). </year>
Reference-contexts: 1. INTRODUCTION Program slicing, a program transformation originally defined by Mark Weiser [12], is useful in program debug ging [9], program maintenance [6], and other applications that involve understanding program behavior <ref> [8] </ref>. Given a program point p and a set of variables V, the goal of slicing is to create a projection of the program (by eliminating some statements), such that the projection and the original program compute the same values for all variables in V at point p. Example.
Reference: 9. <author> Korel, B., </author> <title> PELASProgram error-locating assistant system, </title> <journal> IEEE Transactions on Software Engineering SE-14(9) pp. </journal> <month> 1253-1260 (September </month> <year> 1988). </year>
Reference-contexts: 1. INTRODUCTION Program slicing, a program transformation originally defined by Mark Weiser [12], is useful in program debug ging <ref> [9] </ref>, program maintenance [6], and other applications that involve understanding program behavior [8].
Reference: 10. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> April 23-25, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: Extending the algorithm is straightforward.) Algorithms for slicing programs with structured control flow have been defined by Weiser [12] and by the Otten-steins <ref> [10] </ref>. Neither of these algorithms works correctly for programs with unstructured control flow. We focus on the Ottensteins' algorithm and consider the problems that arise if one tries to apply this algorithm to programs with unstructured control flow.
Reference: 11. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing and program integration, pp. </title> <booktitle> 360-374 in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science Vol. </booktitle> <volume> 352, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (March 1989). </address>
Reference: 12. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year> <title> From: </title> <booktitle> Proc. of the 1st International Workshop on Automated and Algorithmic Debugging (1993): </booktitle> <volume> LNCS Vol 749 </volume>
Reference-contexts: 1. INTRODUCTION Program slicing, a program transformation originally defined by Mark Weiser <ref> [12] </ref>, is useful in program debug ging [9], program maintenance [6], and other applications that involve understanding program behavior [8]. <p> Extending the algorithm is straightforward.) Algorithms for slicing programs with structured control flow have been defined by Weiser <ref> [12] </ref> and by the Otten-steins [10]. Neither of these algorithms works correctly for programs with unstructured control flow. We focus on the Ottensteins' algorithm and consider the problems that arise if one tries to apply this algorithm to programs with unstructured control flow.
References-found: 12

