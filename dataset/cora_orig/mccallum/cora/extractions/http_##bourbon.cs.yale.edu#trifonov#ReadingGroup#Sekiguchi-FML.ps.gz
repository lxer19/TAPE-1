URL: http://bourbon.cs.yale.edu/trifonov/ReadingGroup/Sekiguchi-FML.ps.gz
Refering-URL: http://bourbon.cs.yale.edu/trifonov/ReadingGroup/
Root-URL: http://www.cs.yale.edu
Email: e-mail: fcocoa,yonezawag@is.s.u-tokyo.ac.jp  
Phone: Tel.: +81-3-3812-2111 ex. 4118 Fax: +81-3-5689-4365  
Title: Formulating Mobile Languages  
Author: Tatsurou Sekiguchi and Akinori Yonezawa 
Address: 7-3-1 Hongo, Bunkyo-ku, Tokyo, Japan 113  
Affiliation: Department of Information Science, Faculty of Science, University of Tokyo  
Abstract: This paper describes formal models of mobile computations, where dynamic transmission of code, data and execution environments is represented. Our models provide a foundation of mobile languages. We show that our models can represent the mobile mechanisms in Obliq, Telescript, Java, Facile and Kali-Scheme. The relation between code mobility and partial continuations are discussed. The correctness criteria for data mobility are presented and the correctness of the data movement is proved.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This makes difficult to compare them in a common framework. We take another approach. We introduce two simple models of distributed computations; one is based on untyped call-by-value -calculus with stores and the other is based on untyped imperative object calculus <ref> [1] </ref>. The basic idea behind them is data movement protocols [14] and partial continuations [7, 6]. Copying policies are specified by data movement protocols, which say how a value is moved to another site. <p> Then it sends a value by c:send. A receiver waits until a value is set to the channel by c:receive. 3.1 Obliq Obliq [2] is a simple distributed object-oriented language. The sequential subset of the semantics agrees with imp&f <ref> [1] </ref>, which is an extension of imp& with fields and procedures.
Reference: [2] <author> Luca Cardelli. </author> <title> A Language with Distributed Scope. </title> <booktitle> In Conference Record of the 22th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 286-297, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Mobile languages <ref> [2, 17, 10, 11, 5, 4] </ref> encourages a programming style in which code, data and execution environments are dynamically moved. Behind this paradigm, there must be a presupposition that location-dependent operations and services should be exploited positively. <p> But these models have a problem to describe existing mobile language systems such that it is hard to represent different copying policies for different mobile language systems. For instance, some system [16] duplicates all the values reachable from the target value, but Obliq <ref> [2] </ref> duplicates partly and the values that are not duplicated are referred to by remote references. In a modal logical system where modality means locations, copy operation must include operations on modality. Thus to compare different copying policies of mobile languages, different operations on modality are needed. <p> Then it sends a value by c:send. A receiver waits until a value is set to the channel by c:receive. 3.1 Obliq Obliq <ref> [2] </ref> is a simple distributed object-oriented language. The sequential subset of the semantics agrees with imp&f [1], which is an extension of imp& with fields and procedures.
Reference: [3] <author> Nicholas Carriero and David Gelernter. </author> <title> Linda in Context. </title> <journal> Communications of the ACM, </journal> <volume> 32(4) </volume> <pages> 444-458, </pages> <year> 1989. </year>
Reference-contexts: One of the difficulty in constructing a formal model for mobile language systems is the fact that a theoretical model is often missing the notion of locations so far because it is simpler. A typical instance of such a model is Linda's tuple space <ref> [3] </ref>. Several models [8, 12] based on modal logic where modality means locations are proposed, in which locations can be directly represented. But these models have a problem to describe existing mobile language systems such that it is hard to represent different copying policies for different mobile language systems.
Reference: [4] <author> Henry Cejtin, Suresh Jagannathan, and Richard Kelsey. </author> <title> Higher-Order Distributed Objects. </title> <journal> In ACM Transactions on Programming Languages and Systems, </journal> <note> 1995. http://www.neci.nj.nec.com/PLS/kali.html. </note>
Reference-contexts: 1 Introduction Mobile languages <ref> [2, 17, 10, 11, 5, 4] </ref> encourages a programming style in which code, data and execution environments are dynamically moved. Behind this paradigm, there must be a presupposition that location-dependent operations and services should be exploited positively. <p> Send macro stores a value at the address of given channel in the place where the channel was created. receive macro waits until a value will be stored in the channel. A receiver must be in the place where the channel was created. 2.6 Kali Scheme Kali-Scheme <ref> [4] </ref> is a distributed implementation of Scheme interpreter that allows transmission of higher-order values including continuations. When values are transmitted to a remote place, they are in principle duplicated there provided that sharing within transmitted values is preserved. An operation for remove evaluation is provided.
Reference: [5] <author> Colusa. Omniware: </author> <title> A Universal Substrate for Mobile Code. </title> <note> 1995. Colusa Software white paper. Available at http://www.colusa.com. </note>
Reference-contexts: 1 Introduction Mobile languages <ref> [2, 17, 10, 11, 5, 4] </ref> encourages a programming style in which code, data and execution environments are dynamically moved. Behind this paradigm, there must be a presupposition that location-dependent operations and services should be exploited positively.
Reference: [6] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Abstracting Control. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-160, </pages> <year> 1990. </year>
Reference-contexts: We take another approach. We introduce two simple models of distributed computations; one is based on untyped call-by-value -calculus with stores and the other is based on untyped imperative object calculus [1]. The basic idea behind them is data movement protocols [14] and partial continuations <ref> [7, 6] </ref>. Copying policies are specified by data movement protocols, which say how a value is moved to another site. We have investigated many mobile language systems and found out that 6 types are sufficient to represent copying policies in almost all systems. <p> n g) = (takeaway)x 1 ; :::; (takeaway)x n It is easy to see that every object bound by an owner variable has takeaway type. 4 Code mobility and partial continuations The code movement mechanism may seem ad hoc, but it can be understood naturally in view of partial continuations <ref> [6, 7] </ref>. Though a concurrent system is required to express agent movement since we must have a start and a destination places, since we want to concentrate on control structures in this section, the reduction rules are modified so that it becomes a sequential system.
Reference: [7] <author> Matthias Felleisen, Mitchell Wand, Daniel P. Friedman, and Bruce F. Duba. </author> <title> Abstract Continuations: A Mathematical Semantics for Handling Functional Jumps. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 52-62, </pages> <year> 1988. </year>
Reference-contexts: We take another approach. We introduce two simple models of distributed computations; one is based on untyped call-by-value -calculus with stores and the other is based on untyped imperative object calculus [1]. The basic idea behind them is data movement protocols [14] and partial continuations <ref> [7, 6] </ref>. Copying policies are specified by data movement protocols, which say how a value is moved to another site. We have investigated many mobile language systems and found out that 6 types are sufficient to represent copying policies in almost all systems. <p> We will show that the relation is correct in a sense that it preserves referring structures. The area of code and execution environments moved to another site is specified by partial continuations. We will show that an agent transmission operation can be considered as escape-and abort-operations <ref> [7] </ref>. 1 p 2 Place t 2 DMP ::= copy j resident j carry j proper j takeaway j ubiq a 2 Addr a@p 2 Rem = Addr fi Place v 2 Val ::= () j p j a j a@p j go j placeof j x:e e 2 Exp ::= <p> n g) = (takeaway)x 1 ; :::; (takeaway)x n It is easy to see that every object bound by an owner variable has takeaway type. 4 Code mobility and partial continuations The code movement mechanism may seem ad hoc, but it can be understood naturally in view of partial continuations <ref> [6, 7] </ref>. Though a concurrent system is required to express agent movement since we must have a start and a destination places, since we want to concentrate on control structures in this section, the reduction rules are modified so that it becomes a sequential system. <p> A translation mapping T P [[]] defined below from the above calculus to Felleisen's framework <ref> [7] </ref> of control and prompt shows the relationship between code mobility and partial continuations. T P [[x]] = x T P [[x:e]] = x:T P [[e]] T P [[go]] = (escape k k) T P [[hei]] = (#T P [[e]]) An agent-expression corresponds to a prompt expression.
Reference: [8] <author> Cedric Fournet and Georges Gonthier. </author> <title> A Calculus of Mobile Agents. </title> <booktitle> In CONCUR'96: Concurrency Theory, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 406-421, </pages> <year> 1996. </year>
Reference-contexts: One of the difficulty in constructing a formal model for mobile language systems is the fact that a theoretical model is often missing the notion of locations so far because it is simpler. A typical instance of such a model is Linda's tuple space [3]. Several models <ref> [8, 12] </ref> based on modal logic where modality means locations are proposed, in which locations can be directly represented. But these models have a problem to describe existing mobile language systems such that it is hard to represent different copying policies for different mobile language systems.
Reference: [9] <institution> General Magic Inc. </institution> <note> Telescript Programming Guide. Version 1.0 alpha 2. </note>
Reference-contexts: The semantics of remote method update and cloning of a remote object is also defined as follows respectively: (a@q):l := &(y)e = RPC (a@q; &(x)(a@q):l := &(y)e; c:receive) clone (a@q) def = RPC (a@q; &(x)(copy)clone (a@q):l; (resident)c:receive) 3.2 Telescript Telescript has ownership mechanism <ref> [9] </ref> that is used to specify the area of objects moved to another place together and for garbage collection. When some object goes to other place, all values owned by the object will be also taken there and all references pointing to non-owned values are nullified.
Reference: [10] <author> James Gosling and Henry McGilton. </author> <title> The Java Language Environment. 1995. </title> <type> White paper. </type> <institution> Sun Microsystems. </institution> <note> Available at http://java.sun.com/. </note>
Reference-contexts: 1 Introduction Mobile languages <ref> [2, 17, 10, 11, 5, 4] </ref> encourages a programming style in which code, data and execution environments are dynamically moved. Behind this paradigm, there must be a presupposition that location-dependent operations and services should be exploited positively.
Reference: [11] <author> Frederick Colville Knabe. </author> <title> Language Support for Mobile Agents. </title> <type> PhD thesis, </type> <institution> Computer Science Carnegie Mellon University, </institution> <year> 1995. </year>
Reference-contexts: 1 Introduction Mobile languages <ref> [2, 17, 10, 11, 5, 4] </ref> encourages a programming style in which code, data and execution environments are dynamically moved. Behind this paradigm, there must be a presupposition that location-dependent operations and services should be exploited positively. <p> Non-owner references in Telescript is of this type. A value of a takeaway type is considered to be inherently possessed by an agent. Finally, A ubiq (uitous) type is used to represent a common interface supposed to be facilitated by both the start and the destination place. Facile <ref> [11] </ref> has this type of values called proxy structures. These protocols are graphically represented in Fig 3. Data movement operations using these protocols is formulated by effects of data movement. <p> An agent goes to place p, evaluates e there, and sends back the value to his birthplace through the channel. 2.7 Facile Facile <ref> [11] </ref> is an extension of Standard ML added mobility, where there are two kinds of functions; transmissible functions and non transmissible ones. The compiler generates transmissible representations for transmissible functions. Non transmissible functions are never transmitted outside. The distinction of functions must be annotated by a programmer.
Reference: [12] <author> Naoki Kobayashi, Toshihiro Shimizu, and Akinori Yonezawa. </author> <title> Distributed Concurrent Linear Logic Programming. </title> <publisher> submitting. </publisher>
Reference-contexts: One of the difficulty in constructing a formal model for mobile language systems is the fact that a theoretical model is often missing the notion of locations so far because it is simpler. A typical instance of such a model is Linda's tuple space [3]. Several models <ref> [8, 12] </ref> based on modal logic where modality means locations are proposed, in which locations can be directly represented. But these models have a problem to describe existing mobile language systems such that it is hard to represent different copying policies for different mobile language systems.
Reference: [13] <author> Christian Queinnec and Bernard Serpette. </author> <title> A Dynamic Extent Control Operator for Partial Continuations. </title> <booktitle> In Conference Record of POPL'91: 18th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-184, </pages> <year> 1991. </year>
Reference-contexts: Intuitively, go-expression can be interpreted as transmitting the partial continuation to the destination place in view of the agent, and as aborting operation up to the prompt expression in view of the current place. Queinnec proposes splitter operator <ref> [13] </ref> that composes abort and escape operations. The semantics of go is familiar with that kind of operators. 12 5 Correctness of the data movement relation This section shows the correctness of the data movement relation ) in a sense that it preserves referring structures.
Reference: [14] <author> Tatsurou Sekiguchi and Akinori Yonezawa. </author> <title> A Calculus with Code Mobility. </title> <booktitle> In Proceedings of Second IFIP International Conference on Formal Methods for Open Object-based Distributed Systems, </booktitle> <year> 1997. </year> <note> Available at ftp://yl.is.s.u-tokyo.ac.jp/pub/papers/cocoa-fmoods97-a4.ps.gz. 15 </note>
Reference-contexts: We take another approach. We introduce two simple models of distributed computations; one is based on untyped call-by-value -calculus with stores and the other is based on untyped imperative object calculus [1]. The basic idea behind them is data movement protocols <ref> [14] </ref> and partial continuations [7, 6]. Copying policies are specified by data movement protocols, which say how a value is moved to another site. We have investigated many mobile language systems and found out that 6 types are sufficient to represent copying policies in almost all systems. <p> We use let-expressions as a syntactic macro such that let x = e 1 in e 2 (x:e 2 )e 1 and e 1 ; e 2 to denote let x = e 1 in e 2 if x 62 FV (e 2 ). Our previous paper <ref> [14] </ref> describes the semantics in detail.
Reference: [15] <author> James W. Stamos and David K. Gifford. </author> <title> Remote Evaluation. </title> <journal> In ACM Transactions on Programming Languages and Systems, </journal> <volume> volume 12, </volume> <pages> pages 537-565, </pages> <year> 1990. </year>
Reference-contexts: resident 0; ref copy x) T K [[proxy creator]] = (gid; val):placeof gid T K [[proxy value]] = (gid; val):!val T K [[set proxy value!]] = (gid; val)v:set val v T K [[remote run!]] = pf v:hgo p; f vi The function remote run! is quite similar to REV request <ref> [15] </ref> though REV is synchronous. Synchronous version of remote evaluation is constructed with synchronous channel as follows: reval (e; p) let c = make channel (); = hgo p; send c ei in receive c This macro defines evaluation of expression e at place p.
Reference: [16] <author> Markus Straer, Joachim Baumann, and Fritz Hohl. </author> <title> Mole a java based mobile agent system. </title> <booktitle> ECOOP'96 Workshop on Mobile Object Systems, </booktitle> <year> 1996. </year>
Reference-contexts: But these models have a problem to describe existing mobile language systems such that it is hard to represent different copying policies for different mobile language systems. For instance, some system <ref> [16] </ref> duplicates all the values reachable from the target value, but Obliq [2] duplicates partly and the values that are not duplicated are referred to by remote references. In a modal logical system where modality means locations, copy operation must include operations on modality.
Reference: [17] <author> James E. White. </author> <title> Mobile Agents. </title> <editor> In Jeffrey Bradshaw, editor, </editor> <booktitle> Software Agents. </booktitle> <publisher> The MIT Press, </publisher> <year> 1996. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Mobile languages <ref> [2, 17, 10, 11, 5, 4] </ref> encourages a programming style in which code, data and execution environments are dynamically moved. Behind this paradigm, there must be a presupposition that location-dependent operations and services should be exploited positively.
References-found: 17

