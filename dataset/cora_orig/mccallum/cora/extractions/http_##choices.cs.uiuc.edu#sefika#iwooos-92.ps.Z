URL: http://choices.cs.uiuc.edu/sefika/iwooos-92.ps.Z
Refering-URL: http://choices.cs.uiuc.edu/sefika/info.html
Root-URL: http://www.cs.uiuc.edu
Title: Proxies, Application Interfaces, and Distributed Systems  
Author: Amitabh Dave, Mohlalefi Sefika and Roy H. Campbell 
Address: Urbana, IL 61820  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: Proxy objects are local representatives of remote objects in a distributed system. We use proxies to construct a transparent application programming interface (API) for the Choices distributed operating system. In earlier work, proxies were used in Choices to provide a protected, object-oriented interface to system objects. The addition of RemoteProxies allows applications to access all resources in a uniform way by simply invoking methods on objects, irrespective of whether they are local, in the kernel, in a different user virtual address space or remote. We also extend proxies as defined by Shapiro[10] to optimize access to remote and protected objects and to provide support for changing server interfaces. We describe a new remote procedure call (RPC) facility for invoking methods on remote objects through the proxy mechanism. The API is made dynamically reconfigurable by using table lookup to perform all functions normally provided by stubs in conventional RPC implementations[11]. Last, the API permits new versions of a service to be introduced without requiring recompilation of application client code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brian N. Bershad, Thomas E. Anderson, Ed-ward D. Lazowska, and Henry M. Levy. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Remote procedure calls (RPCs) go one step further and hide the message passing system. RPCs have been shown to work well both for cross-machine calls as well as cross-domain calls on the same machine <ref> [1] </ref>. Current implementations of RPCs force applications to link with libraries of stub functions which implement the actual remote calls. This makes it difficult to change server interfaces dynamically. The RPC stubs are usually built from the definitions of the procedures.
Reference: [2] <author> David W. Dykstra. </author> <title> Object-Oriented Hierarchies Across Protection Boundaries. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Proxy objects are local representatives of remote objects in a distributed system [10]. The Choices API mechanism is built using proxy objects <ref> [2, 9] </ref>. In distributed Choices, proxy objects represent other objects that cannot be accessed directly from an application. Proxy objects provide indirection and late, run time binding. A method invocation on a proxy results in a corresponding method invocation on the object it represents. <p> Besides providing this form of access to existing kernel objects, new kernel objects may be created using the C++ new operator. Dykstra shows how the proxy interface can be used to extend a Choices class hierarchy by subclassing kernel classes in user space <ref> [2] </ref>. 3.1 Proxy objects Applications invoke a method on a kernel object by invoking the corresponding method on its Object-Proxy [9]. Messages sent to an ObjectProxy are forwarded to the corresponding kernel object. <p> The result of a new operation is the creation of a new object in the local address space, in the kernel or in a remote address space. Local classes are handled by the language implementation and the handling of kernel classes is described by Dykstra <ref> [2] </ref>. Creating objects of remote classes is handled by the Object-Server object. A new on a remote class is handled by invoking the construct method of the appropriate ObjectServer. The correct ObjectServer object is located by NameServer lookup.
Reference: [3] <author> Richard Rashid et. al. </author> <title> Mach: A foundation for open systems. </title> <booktitle> In Proceedings of the Second Workshop on Workstation Operating Systems, </booktitle> <pages> pages 109-113, </pages> <address> Pacific Grove, California, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: We also define some additional properties which might be useful, including failure handling, performance measurements and server versions. Different mechanisms including ports, stubs, capabilities and virtual memory have been proposed as abstractions to simplify distributed programming and provide protected and transparent access to remote services <ref> [8, 3, 5] </ref>. Proxies subsume the functionality provided by ports, stubs and capabilities [10]. Comandos [5, 6] uses references to identify objects and uses a run time support library which is linked to user programs to perform object invocations.
Reference: [4] <author> Andrzej Goscinski. </author> <title> Distributed Operating Systems The Logical Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Existing systems provide transparent application interfaces in several ways. For example, in message passing systems, ports are location independant communication entities that represent servers. Restricting access to all system resources through these ports makes the interface transparent <ref> [4] </ref>. However, applications must distinguish between those resources that can be reached directly and those that can be accessed through the message passing system. Objects of the same class that reside on different remote systems must be accessed using different ports. <p> Optimization of access depending on the location of the object, is handled by customizing the proxy. This provides a more uniform interface. The remote procedure call (RPC) is a common abstraction used to provide easy and transparent access to services in a distributed system <ref> [4] </ref>. A common way of implementing RPC is by providing stubs for each of the remote functions in a library which is then linked with applications [11].
Reference: [5] <author> Paulo Guedes and Jose Alves Marques. </author> <title> Operating system support for an object-oriented environment. </title> <booktitle> In Proceedings of the Second Workshop on Workstation Opeerating Systems, </booktitle> <pages> pages 37-42, </pages> <address> Pacific Grove, California, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: We also define some additional properties which might be useful, including failure handling, performance measurements and server versions. Different mechanisms including ports, stubs, capabilities and virtual memory have been proposed as abstractions to simplify distributed programming and provide protected and transparent access to remote services <ref> [8, 3, 5] </ref>. Proxies subsume the functionality provided by ports, stubs and capabilities [10]. Comandos [5, 6] uses references to identify objects and uses a run time support library which is linked to user programs to perform object invocations. <p> Different mechanisms including ports, stubs, capabilities and virtual memory have been proposed as abstractions to simplify distributed programming and provide protected and transparent access to remote services [8, 3, 5]. Proxies subsume the functionality provided by ports, stubs and capabilities [10]. Comandos <ref> [5, 6] </ref> uses references to identify objects and uses a run time support library which is linked to user programs to perform object invocations. Specifically the invoke library function, which takes the method name as a parameter is used to implement a method call.
Reference: [6] <author> Chris Horn. </author> <title> Is object orientation a good thing for distributed systems. </title> <booktitle> In Proceedings of the Euro pean Workshop on Progress in Distributed Oper--ating Systems and Distributed Systems Management, </booktitle> <pages> pages 60-74, </pages> <address> Berlin, Germany, </address> <month> April </month> <year> 1989. </year>
Reference-contexts: Different mechanisms including ports, stubs, capabilities and virtual memory have been proposed as abstractions to simplify distributed programming and provide protected and transparent access to remote services [8, 3, 5]. Proxies subsume the functionality provided by ports, stubs and capabilities [10]. Comandos <ref> [5, 6] </ref> uses references to identify objects and uses a run time support library which is linked to user programs to perform object invocations. Specifically the invoke library function, which takes the method name as a parameter is used to implement a method call.
Reference: [7] <author> Nayeem Islam and Roy H. Campbell. </author> <title> "Design Considerations for Shared Memory Multiprocessor Message Systems". </title> <note> In IEEE Transactions on Parallel and Distributed Systems(to appear), Oc-tober 1992. </note>
Reference-contexts: It is often sufficient to update the tables with the new class definition. 5.3 Implementation details The RPC system is built on top of the Choices message passing system <ref> [7] </ref>. The proxy object mechanism uses information generated by Proxify++ in the form of proxy object tables to implement method calls to the objects corresponding to the proxy.
Reference: [8] <author> Sape J. Mullender, Guido van Rossum, An-drew S. Tannenbaum, Robbert van Renesse, and Hans van Staveren. </author> <title> Amoeba a distributed operating system for the 1990s. </title> <journal> Computer, </journal> <volume> 23(5) </volume> <pages> 44-56, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: We also define some additional properties which might be useful, including failure handling, performance measurements and server versions. Different mechanisms including ports, stubs, capabilities and virtual memory have been proposed as abstractions to simplify distributed programming and provide protected and transparent access to remote services <ref> [8, 3, 5] </ref>. Proxies subsume the functionality provided by ports, stubs and capabilities [10]. Comandos [5, 6] uses references to identify objects and uses a run time support library which is linked to user programs to perform object invocations.
Reference: [9] <author> Vincent F. Russo. </author> <title> An Object-Oriented Operating System. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: Proxy objects are local representatives of remote objects in a distributed system [10]. The Choices API mechanism is built using proxy objects <ref> [2, 9] </ref>. In distributed Choices, proxy objects represent other objects that cannot be accessed directly from an application. Proxy objects provide indirection and late, run time binding. A method invocation on a proxy results in a corresponding method invocation on the object it represents. <p> Dykstra shows how the proxy interface can be used to extend a Choices class hierarchy by subclassing kernel classes in user space [2]. 3.1 Proxy objects Applications invoke a method on a kernel object by invoking the corresponding method on its Object-Proxy <ref> [9] </ref>. Messages sent to an ObjectProxy are forwarded to the corresponding kernel object. Object-Proxys are dynamically created by the kernel during name server lookup of the kernel object and are protected by allocating them in application read-only memory. An ObjectProxy shares a virtual function table with other similar proxy objects.
Reference: [10] <author> Marc Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proc. 6th. Intl. Conf. on Distributed Computer Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: Proxy objects are local representatives of remote objects in a distributed system <ref> [10] </ref>. The Choices API mechanism is built using proxy objects [2, 9]. In distributed Choices, proxy objects represent other objects that cannot be accessed directly from an application. Proxy objects provide indirection and late, run time binding. <p> Using the same RPC mechanism to marshall a method call to each of these different locations imposes unnecessary overhead. In contrast, our proposed implementation is both transparent and reconfigurable on the fly. Proxies are the key to our API provisions. Shapiro <ref> [10] </ref> proposed proxies, which act as the local representatives for groups of distributed servers. We interpret a proxy in more general terms as the local representive of any object which exists in a different address space. <p> Thus, applications can access the Standard NameServers without requiring a lookup. 3 Proxy objects and the kernel Proxy objects were introduced into Choices to provide applications with a protected, object-oriented interface to system objects <ref> [10] </ref>. The ObjectProxy class defines proxy objects. Before an application can invoke a method on a system object, it must first obtain a proxy object for that object from the name server. A method call to an ObjectProxy results in a method call to the corresponding system object. <p> The application interface is generated automatically by running all Choices header files through Proxify++ 1 . 4 Proxies and distributed systems Shapiro introduced proxy objects as local representatives of remote services in a distributed system <ref> [10] </ref>. Proxies in Choices are local representatives of objects located outside the address space of an application. They are allocated dynamically when an application "looks up" the address of a proxiable object that has been registered with or bound to the nameserver. <p> The parameters of this mechanism can be changed dynamically to allow objects to move while they are used. According to the proxy principle <ref> [10] </ref>, the proxy is the only visible interface to a service. To the application, interacting with the proxy is identical to interacting with the actual object as if it were a local object. <p> Our design for distributed Choices makes extensive use of proxies. In the following discussion, the term client refers to an application that invokes a method. The term server refers to an object upon which the method is being invoked. We extend the basic services proposed for proxies in <ref> [10] </ref> to include dynamic subtyping, multiple versions of server interfaces, instrumentation of client invocations of server methods, and local client caching of remote server information. We now give a more detailed description of the functions provided by a proxy. <p> A process may serve more than one object. Registration with the NameServer and binding a process is handled at object creation time by the ObjectServer. 6 Related work Proxies were defined by Shapiro <ref> [10] </ref> as server representatives. He specified several desirable functions including access protocols, buffering, access control and communication functions. We use proxies as an interface to all objects not in the local address space. The use of proxies is transparent to the programmer. <p> Different mechanisms including ports, stubs, capabilities and virtual memory have been proposed as abstractions to simplify distributed programming and provide protected and transparent access to remote services [8, 3, 5]. Proxies subsume the functionality provided by ports, stubs and capabilities <ref> [10] </ref>. Comandos [5, 6] uses references to identify objects and uses a run time support library which is linked to user programs to perform object invocations. Specifically the invoke library function, which takes the method name as a parameter is used to implement a method call.
Reference: [11] <author> B. H. Tay and A. L. Ananda. </author> <title> A Survey of Remote Procedure Calls. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(3) </volume> <pages> 68-79, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The remote procedure call (RPC) is a common abstraction used to provide easy and transparent access to services in a distributed system [4]. A common way of implementing RPC is by providing stubs for each of the remote functions in a library which is then linked with applications <ref> [11] </ref>.
References-found: 11

