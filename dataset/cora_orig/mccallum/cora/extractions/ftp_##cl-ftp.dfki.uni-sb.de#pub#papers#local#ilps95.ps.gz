URL: ftp://cl-ftp.dfki.uni-sb.de/pub/papers/local/ilps95.ps.gz
Refering-URL: http://cl-www.dfki.uni-sb.de/cl/papers/cl-abstracts.html
Root-URL: 
Email: erbach@dfki.uni-sb.de  skm@cogsci.ed.ac.uk  
Title: Visions for Logic-Based Natural Language Processing  
Author: Gregor Erbach Suresh Manandhar 
Address: Saarbrucken, Germany  Edinburgh  
Affiliation: German Research Center for Artificial Intelligence  Language Technology Group Human Communication Research Centre University of  
Abstract: The purpose of this paper is to outline the requirements that the field of Natural Language Processing (NLP) has for a declarative successor to Prolog. Logic programming approaches play a major role in NLP, and likewise considerations of NLP have had a strong influence on logic programming ( [ Colmerauer, 1978 ] , [ Pereira and Warren, 1980 ] , [ Smolka, 1992 ] ). We will review the state of the art in NL grammar formalisms and processing algorithms in the logic programming paradigm, from the perspective of research in grammatical theory (Computational Linguistics) and from the perspective of applied NLP (Language Engineering). The relationship to Prolog and to current developments in (C)LP will be discussed. We will outline the requirements for a logic programming language that will both support the current practice in NLP and provide a platform which can accommodate future research results. 
Abstract-found: 1
Intro-found: 1
Reference: [ At-Kaci and Nasr, 1986 ] <author> Hassan At-Kaci and Roger Nasr. </author> <title> login: A logical programming language with built-in inheritance. </title> <booktitle> In Proceedings of the 13th ACM Symposium an Principles of Programming Languages, </booktitle> <pages> pages 219-228, </pages> <address> St. Petersburg, Florida, </address> <year> 1986. </year>
Reference-contexts: A good overview of feature constraint logics for NLP is given in [ Smolka, 1992 ] . In logic programming, feature constraints have become fairly common. Following the pioneering work of At-Kaci <ref> [ At-Kaci, 1984; At-Kaci and Nasr, 1986 ] </ref> , they have been introduced into various logic programming languages.
Reference: [ At-Kaci, 1984 ] <author> Hassan At-Kaci. </author> <title> A Lattice-Theoretic Approach to Computation Based on a Calculus of Partially-Ordered Type Structures. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1984. </year>
Reference-contexts: A good overview of feature constraint logics for NLP is given in [ Smolka, 1992 ] . In logic programming, feature constraints have become fairly common. Following the pioneering work of At-Kaci <ref> [ At-Kaci, 1984; At-Kaci and Nasr, 1986 ] </ref> , they have been introduced into various logic programming languages.
Reference: [ Alshawi and Crouch, 1992 ] <author> Hiyan Alshawi and Richard Crouch. </author> <title> Monotonic semantic interpretation. </title> <booktitle> In Proceedings of the 30th Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 32 - 39, </pages> <address> Newark, Delaware, </address> <year> 1992. </year>
Reference-contexts: Underspecification techniques are especially important for problems in semantic representation such as the encoding of quantifier scoping possibilities <ref> [ Alshawi and Crouch, 1992 ] </ref> . 2.7 Lean Formalisms The implementation of typed feature structures, constraints, disjunction handling, and alternative deduction strategies on top of a high-level language such as Prolog leads to a serious loss of efficiency, which hinders the development of NLP applications which make use of these
Reference: [ Alshawi et al., 1991 ] <author> H. Alshawi, D. J. Arnold, R. Backofen, D. M. Carter, J. Lindop, K. Netter, J. Tsujii, and H. Uszkoreit. </author> <title> Eurotra 6/1: Rule formalism and virtual machine design study | Final report. </title> <type> Technical report, </type> <institution> SRI International, </institution> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: In order to overcome these problems, some recent formalisms (e.g. the Core Language Engine CLE [ Alshawi, 1991 ] , the Advanced Linguistic Engineering Platform ALEP <ref> [ Alshawi et al., 1991 ] </ref> , ProFIT [ Erbach, 1995 ] ) have made use of a compilation of typed feature structures into Prolog terms, so that Prolog's term unification can be used at runtime. These systems have been successfully used for representing linguistic knowledge for NLP applications.
Reference: [ Alshawi, 1991 ] <author> Hiyan Alshawi, </author> <title> editor. The Core Language Engine. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In order to overcome these problems, some recent formalisms (e.g. the Core Language Engine CLE <ref> [ Alshawi, 1991 ] </ref> , the Advanced Linguistic Engineering Platform ALEP [ Alshawi et al., 1991 ] , ProFIT [ Erbach, 1995 ] ) have made use of a compilation of typed feature structures into Prolog terms, so that Prolog's term unification can be used at runtime.
Reference: [ Bottcher, 1993 ] <author> Martin Bottcher. </author> <title> Disjunctions and inheritance in the context feature structure system. </title> <booktitle> In EACL93, </booktitle> <pages> pages 54 - 60, </pages> <address> Utrecht, NL, </address> <year> 1993. </year>
Reference: [ Brachman and Schmolze, 1985 ] <author> R.J. Brachman and J.G. Schmolze. </author> <title> An overview of the KL-ONE knowledge representation system. </title> <journal> Cognitive Science, </journal> <volume> 9(2) </volume> <pages> 171-216, </pages> <year> 1985. </year>
Reference-contexts: Set descriptions permit multiple values for the same feature symbol in the same way as knowledge representation languages such as KL-ONE <ref> [ Brachman and Schmolze, 1985 ] </ref> 2 . Set constraints are widely used in linguistic theories to model phenomena whose handling involves storing and passing information about possibly large collections of certain linguistic objects such as subcat-egorisation frames, discourse referents, quantifiers, extraposed or fronted constituents etc.
Reference: [ Carpenter and Penn, 1994 ] <author> Bob Carpenter and Gerald Penn. </author> <title> The Attribute Logic Engine: User's Guide (Version 2.0.1). </title> <institution> Carnegie-Mellon University, Pittsburgh, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: These systems have been successfully used for representing linguistic knowledge for NLP applications. However, these systems do not allow currently support multiple inheritance. In order to handle multiple inheritance, the Attribute Logic Engine ALE <ref> [ Carpenter and Penn, 1994 ] </ref> therefore takes a different approach by compiling typed feature structure unification into a set of primitive instructions [ Carpenter, 1993 ] .
Reference: [ Carpenter, 1992 ] <author> Bob Carpenter. </author> <title> The logic of typed feature structures. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1992. </year>
Reference-contexts: Single inheritance is generally considered insufficient since it does not allow cross-classification of linguistic descriptions. Most typed feature systems generally provide some form of multiple inheritance. For instance, Carpenter's formalisation of typed feature structures <ref> [ Carpenter, 1992 ] </ref> requires the inheritance lattice to be specified as a BCPO (bounded complete partial order). On the other hand, the ProFIT typed feature system allows either single inheritance or multi-dimensional inheritance which can be employed for cross-classification [ Erbach, 1994b ] .
Reference: [ Carpenter, 1993 ] <author> Bob Carpenter. </author> <title> Compiling typed attribute-value logic grammars. </title> <booktitle> In Third International Workshop on Parsing Technologies, </booktitle> <pages> pages 39 - 48, </pages> <address> Tilburg, NL and Durbuy, B, </address> <year> 1993. </year>
Reference-contexts: However, these systems do not allow currently support multiple inheritance. In order to handle multiple inheritance, the Attribute Logic Engine ALE [ Carpenter and Penn, 1994 ] therefore takes a different approach by compiling typed feature structure unification into a set of primitive instructions <ref> [ Carpenter, 1993 ] </ref> . This approach is currently implemented on top of Prolog by making use of open data structures and efficient indexing techniques, but a reimplementation in a lower-level language using an abstract machine approach is planned in order to speed up the system.
Reference: [ Chomsky, 1981 ] <author> Noam Chomsky. </author> <title> Lectures on Government and Binding. Studies in Generative Grammar. </title> <publisher> Foris, </publisher> <address> Dordrecht, </address> <year> 1981. </year>
Reference-contexts: Also there is a trend in grammatical theory away from construction-specific rules towards general well-formedness conditions (grammatical principles), which can be naturally expressed as constraints that need to satisfied universally. This can be evidenced within the so called principle-based grammatical theories such as the government-binding theory <ref> [ Chomsky, 1981; Lasnik, 1991 ] </ref> and HPSG [ Pollard and Sag, 1994 ] .
Reference: [ Colmerauer, 1978 ] <author> Alain Colmerauer. </author> <title> Metamorphosis grammar. </title> <editor> In Leonard Bolc, editor, </editor> <title> Natural Language Communication with Computers. </title> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1978. </year>
Reference: [ Dalrymple et al., 1991 ] <author> Mary Dalrymple, Stuart M. Shieber, and Fernando C. N. Pereira. </author> <title> Ellipsis and higher-order unification. </title> <journal> Linguistics and Philosophy, </journal> <volume> 14(4) </volume> <pages> 399-452, </pages> <year> 1991. </year>
Reference-contexts: At this stage, it would be premature to decide on one type system. 2.4 Higher-Order Unification A standard approach for treating ellipsis in NLP makes crucial use of higher-order unification <ref> [ Dalrymple et al., 1991 ] </ref> .
Reference: [ Dorre and Dorna, 1993 ] <author> Jochen Dorre and Michael Dorna. </author> <title> CUF A formalism for linguistic knowledge representation. </title> <editor> In Jochen Dorre, editor, </editor> <title> Computational Aspects of Constraint-Based Linguistic Description. </title> <booktitle> Deliverable R1.2.A. DYANA-2 ESPRIT Basic Research Project 6852, </booktitle> <year> 1993. </year>
Reference-contexts: This CLP scheme has been adopted in NLP in systems such as CUF <ref> [ Dorre and Dorna, 1993 ] </ref> . The CLP scheme also permits the addition of new constraint solvers in addition to feature constraints and this approach is currently being experimented with in formalisms such as CL-ONE [ Erbach et al., 1995 ] .
Reference: [ Dorre and Eisele, 1990 ] <author> Jochen Dorre and Andreas Eisele. </author> <title> Feature logic with disjunctive unification. </title> <editor> In Hans Karlgren, editor, </editor> <booktitle> Coling 90: Papers presented to the the Thirteenth International Conference on Computational Linguistics, </booktitle> <pages> pages 100-105, </pages> <address> Helsinki, Finland, 1990. </address> <publisher> Helsinki University. </publisher>
Reference: [ Erbach et al., 1995 ] <editor> G. Erbach, M. van der Kraan, S. Manandhar, H. Ruessink, W. Skut, and C. Thiersch. </editor> <title> Extending unification formalisms. </title> <booktitle> In 2nd Language Engineering Convention, </booktitle> <address> London, </address> <year> 1995. </year>
Reference-contexts: This CLP scheme has been adopted in NLP in systems such as CUF [ Dorre and Dorna, 1993 ] . The CLP scheme also permits the addition of new constraint solvers in addition to feature constraints and this approach is currently being experimented with in formalisms such as CL-ONE <ref> [ Erbach et al., 1995 ] </ref> . Typed feature formalisms A lot of effort within the NLP community has been directed towards a class of grammar formalisms known as typed feature formalisms. Broadly speaking, typed feature formalisms are Horn-extensions over feature descriptions. <p> Symbolic constraints such as set descriptions and set operations [ Manandhar, 1994 ] , linear precedence constraints [ Manandhar, 1995 ] , guarded constraints over these constraints <ref> [ Erbach et al., 1995 ] </ref> , tree descriptions [ Vijay-Shanker, 1992 ] are among those that have been investigated. Set descriptions permit multiple values for the same feature symbol in the same way as knowledge representation languages such as KL-ONE [ Brachman and Schmolze, 1985 ] 2 .
Reference: [ Erbach, 1994a ] <author> Gregor Erbach. </author> <title> Bottom-up Earley Deduction. </title> <booktitle> In COLING, </booktitle> <pages> pages 796 - 802, </pages> <address> Kyoto, </address> <year> 1994. </year>
Reference-contexts: avoid prediction loops [ Shieber, 1985 ] , the use of the algorithm for both parsing and generation through a modification of the indexing scheme [ Shieber, 1988; Neumann, 1994b ] , extensions for the memoisation of coroutined constraints [ Johnson and Dorre, 1995 ] , and a bottom-up variant <ref> [ Erbach, 1994a ] </ref> . Only recently, memoisation techniques (OLDT resolution) have been incorporated into logic programming languages such as XSB Prolog [ Warren, 1992 ] .
Reference: [ Erbach, 1994b ] <author> Gregor Erbach. </author> <title> Multi-dimensional inheritance. </title> <editor> In H. Trost, editor, </editor> <booktitle> Proceedings of KONVENS '94, </booktitle> <pages> pages 102 - 111, </pages> <address> Vienna, 1994. </address> <publisher> Springer. </publisher>
Reference-contexts: For instance, Carpenter's formalisation of typed feature structures [ Carpenter, 1992 ] requires the inheritance lattice to be specified as a BCPO (bounded complete partial order). On the other hand, the ProFIT typed feature system allows either single inheritance or multi-dimensional inheritance which can be employed for cross-classification <ref> [ Erbach, 1994b ] </ref> . Some expressive formalisms, such as TDL [ Krieger and Schafer, 1994 ] , use a more expressive type system with relational types, full negation, lazy type expansion etc. A system such as CUF allows type axioms to be stated using the full propositional calculus.
Reference: [ Erbach, 1995 ] <author> Gregor Erbach. </author> <title> ProFIT: Prolog with features, inheritance and templates. </title> <booktitle> In Seventh Conference of the European Chapter of the Association for Computational Linguistics (EACL), </booktitle> <address> Dublin, </address> <year> 1995. </year>
Reference-contexts: In Prolog-based systems such as ProFIT <ref> [ Erbach, 1995 ] </ref> , finite domains with N possible values are implemented by compilation into a term with N + 1 arguments [ Mellish, 1988; Mellish, 1992 ] . <p> In order to overcome these problems, some recent formalisms (e.g. the Core Language Engine CLE [ Alshawi, 1991 ] , the Advanced Linguistic Engineering Platform ALEP [ Alshawi et al., 1991 ] , ProFIT <ref> [ Erbach, 1995 ] </ref> ) have made use of a compilation of typed feature structures into Prolog terms, so that Prolog's term unification can be used at runtime. These systems have been successfully used for representing linguistic knowledge for NLP applications.
Reference: [ Haridi and Janson, 1990 ] <author> Seif Haridi and Sverker Janson. </author> <title> Kernel Andorra Prolog and its computation model. </title> <booktitle> In International Conference in Logic Programming (ICLP), </booktitle> <pages> pages 31-46, </pages> <year> 1990. </year>
Reference-contexts: For example, CUF is a formalism which follow a CLP scheme and employs the Andorra resolution strategy <ref> [ Haridi and Janson, 1990 ] </ref> , which prefers deterministic goal reduction. On the other hand, systems such as ALE employ a bottom-up chart parser.
Reference: [ Hohfeld and Smolka, 1988 ] <author> Markus Hohfeld and Gert Smolka. </author> <title> Definite relations over constraint languages. </title> <type> LILOG Report 53, </type> <institution> IBM Deutschland, Stuttgart, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: Constraint Logic Programming In logic programming | following early work such as CHIP | and the development of the CLP scheme [ Jaffar and Lassez, 1987 ] <ref> [ Hohfeld and Smolka, 1988 ] </ref> , Constraint Logic Programming has become an important paradigm and an area of much active research. This CLP scheme has been adopted in NLP in systems such as CUF [ Dorre and Dorna, 1993 ] .
Reference: [ Holzbaur, 1992 ] <author> C. Holzbaur. </author> <title> DMCAI CLP reference manual. </title> <type> Technical Report TR-92-24, </type> <institution> Osterreichisches Forschungsinstitut fur Artificial Intelligence, Vienna, </institution> <year> 1992. </year>
Reference-contexts: These constraints are used for modelling partially free word order in languages such as German or Bulgarian, and also for underspecified representation of quantifier scoping possibilities. With the introduction of attributed variables <ref> [ Holzbaur, 1992 ] </ref> , it has become possible to implement constraint solvers in systems such as Sicstus 3.
Reference: [ Jaffar and Lassez, 1987 ] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings 14th POPL, </booktitle> <year> 1987. </year>
Reference-contexts: Constraint Logic Programming In logic programming | following early work such as CHIP | and the development of the CLP scheme <ref> [ Jaffar and Lassez, 1987 ] </ref> [ Hohfeld and Smolka, 1988 ] , Constraint Logic Programming has become an important paradigm and an area of much active research. This CLP scheme has been adopted in NLP in systems such as CUF [ Dorre and Dorna, 1993 ] .
Reference: [ Johnson and Dorre, 1995 ] <author> Mark Johnson and Jochen Dorre. </author> <title> Memoization of coroutined constraints. </title> <booktitle> In Proceedings of the 32rd Annual Meeting of the Association for Computational Linguistics, </booktitle> <address> Cambridge, </address> <year> 1995. </year> <title> (Computation and Language e-print archive cmp-lg/9504028). </title>
Reference-contexts: Refinements include the restriction technique to avoid prediction loops [ Shieber, 1985 ] , the use of the algorithm for both parsing and generation through a modification of the indexing scheme [ Shieber, 1988; Neumann, 1994b ] , extensions for the memoisation of coroutined constraints <ref> [ Johnson and Dorre, 1995 ] </ref> , and a bottom-up variant [ Erbach, 1994a ] . Only recently, memoisation techniques (OLDT resolution) have been incorporated into logic programming languages such as XSB Prolog [ Warren, 1992 ] .
Reference: [ Kaplan and Bresnan, 1982 ] <author> Ronald Kaplan and Joan Bresnan. </author> <title> Lexical Functional Grammar: a formal system for grammatical representation. In Joan Bresnan, editor, The Mental Representation of Grammatical Relations, </title> <booktitle> chapter 4, </booktitle> <pages> pages 173 - 281. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1982. </year>
Reference-contexts: Further research into more efficient memoisation schemes is probably needed. 2.2 Feature Structures In computational linguistics, feature structures (attribute-value matrices) have for a long time been preferred over Prolog terms (e.g. PATR [ Shieber et al., 1983 ] or Lexical Functional Grammar <ref> [ Kaplan and Bresnan, 1982 ] </ref> ) because they allow a more perspicuous and compact encoding of linguistic knowledge.
Reference: [ Kasper and Rounds, 1986 ] <author> Robert Kasper and William Rounds. </author> <title> A logical semantics for feature structures. </title> <booktitle> In 24th Annual Meeting of the Association for Computational Linguistics, </booktitle> <address> Columbia University, New York, </address> <pages> pages 257-265, </pages> <year> 1986. </year>
Reference-contexts: Broadly speaking, typed feature formalisms are Horn-extensions over feature descriptions. They can loosely be understood as specific instantia-tions of the CLP (FT) paradigm where FT stands for a specific version of feature logic <ref> [ Kasper and Rounds, 1986 ] </ref> [ Smolka, 1992 ] with types and inheritance.
Reference: [ Kay, 1980 ] <author> Martin Kay. </author> <title> Algorithm schemata and data structures in syntactic processing. </title> <type> Technical report, </type> <institution> Xerox PARC, </institution> <address> Palo Alto, CA, </address> <month> October, </month> <year> 1980 1980. </year>
Reference-contexts: The advantages of bottom-up and top-down processing are often combined by making use of a precompiled reachability relation <ref> [ Kay, 1980 ] </ref> . In logic programming, bottom-up approaches are found for example in the area of deductive databases.
Reference: [ Krieger and Schafer, 1994 ] <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> T DL|a type description language for constraint-based grammars. </title> <booktitle> In Proceedings of the 15th International Conference on Computational Linguistics, </booktitle> <address> Kyoto, </address> <year> 1994. </year>
Reference-contexts: On the other hand, the ProFIT typed feature system allows either single inheritance or multi-dimensional inheritance which can be employed for cross-classification [ Erbach, 1994b ] . Some expressive formalisms, such as TDL <ref> [ Krieger and Schafer, 1994 ] </ref> , use a more expressive type system with relational types, full negation, lazy type expansion etc. A system such as CUF allows type axioms to be stated using the full propositional calculus. However, CUF does not permit variables in type definitions.
Reference: [ Lasnik, 1991 ] <author> Noam Chomsky & Howard Lasnik. </author> <title> Principles and parameters theory. </title> <editor> In et al. J. Ja-cobs, editor, </editor> <booktitle> Syntax: an international handbook of contemporary research. </booktitle> <publisher> Walter de Gruyter, </publisher> <address> Berlin, </address> <note> (to appear) edition, </note> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Also there is a trend in grammatical theory away from construction-specific rules towards general well-formedness conditions (grammatical principles), which can be naturally expressed as constraints that need to satisfied universally. This can be evidenced within the so called principle-based grammatical theories such as the government-binding theory <ref> [ Chomsky, 1981; Lasnik, 1991 ] </ref> and HPSG [ Pollard and Sag, 1994 ] .
Reference: [ Manandhar, 1993 ] <author> Suresh Manandhar. </author> <title> Relational Extensions to Feature Logic: Applications to Constraint Based Grammars. </title> <type> PhD thesis, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1993. </year>
Reference-contexts: Compared to the relatively inefficient implementation of distributed disjunctions on top of Prolog, their re-implementation in C, which is used in the XEROX Language Engineering system (XLE), is very efficient. 2 See <ref> [ Manandhar, 1993 ] </ref> for a comparison between feature logics and terminological logics employed in knowledge representation languages such as KL-ONE. Finite Domains Finite domains are useful where disjunctions are not distributed over different parts of the structure.
Reference: [ Manandhar, 1994 ] <author> Suresh Manandhar. </author> <title> An attributive logic of set descriptions and set operations. </title> <booktitle> In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 255 - 262, </pages> <address> Las Cruces, NM, </address> <year> 1994. </year>
Reference-contexts: Symbolic constraints such as set descriptions and set operations <ref> [ Manandhar, 1994 ] </ref> , linear precedence constraints [ Manandhar, 1995 ] , guarded constraints over these constraints [ Erbach et al., 1995 ] , tree descriptions [ Vijay-Shanker, 1992 ] are among those that have been investigated. <p> A set constraint language has been implemented which makes use of membership constraints, cardi-nality constraints, disjointness constraints, and union and intersection constraints. A sound and complete constraint solver for these constraints has been implemented <ref> [ Manandhar, 1994 ] </ref> . Linear precedence constraints allow an underspecified representation of the order among the elements of a set [ Manandhar, 1995 ] .
Reference: [ Manandhar, 1995 ] <author> Suresh Manandhar. </author> <title> Deterministic consistency checking of LP constraints. </title> <booktitle> In Proceedings of the 7th European Conference of the Association for Computational Linguistics, </booktitle> <address> Dublin, </address> <year> 1995. </year>
Reference-contexts: Symbolic constraints such as set descriptions and set operations [ Manandhar, 1994 ] , linear precedence constraints <ref> [ Manandhar, 1995 ] </ref> , guarded constraints over these constraints [ Erbach et al., 1995 ] , tree descriptions [ Vijay-Shanker, 1992 ] are among those that have been investigated. <p> A sound and complete constraint solver for these constraints has been implemented [ Manandhar, 1994 ] . Linear precedence constraints allow an underspecified representation of the order among the elements of a set <ref> [ Manandhar, 1995 ] </ref> . Unlike lists, where the order is completely fixed, or sets, where the order is completely open, linear precedence constraints allow to specify which elements must stand in a precedence relation.
Reference: [ Matiasek, 1994 ] <author> Johannes Matiasek. </author> <title> Principle-based Processing of Natural Language using CLP Techniques. </title> <type> PhD thesis, </type> <institution> Technische Universitat, Vienna, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: This mechanism is very useful for NLP because it permits the experimentation with and application of new kinds of constraints solvers (e.g. the handling of grammatical principles as type constraints <ref> [ Matiasek, 1994 ] </ref> , or morphology as a constraint between surface and lexical forms [ Trost and Matiasek, 1994 ] ). 2.6 Disjunction Disjunction handling is an important problem for NLP due to the lexical and structural ambiguity inherent in natural language [ Trost, 1993 ] .
Reference: [ Matsumoto et al., 1983 ] <author> Yuji Matsumoto, Hozumi Tanaka, H. Hirakawa, Hideo Miyoshi, and Hideki Yasukawa. </author> <title> BUP: a bottom-up parser embedded in Prolog. </title> <journal> New Generation Computing, </journal> <volume> 1 </volume> <pages> 145-158, </pages> <year> 1983. </year>
Reference-contexts: Therefore NL parsers and generators often make use of bottom-up methods, e.g., left-corner parsing and its compilation into a Prolog program (BUP) <ref> [ Matsumoto et al., 1983 ] </ref> , semantic-head driven generation [ Shieber et al., 1990 ] , head-corner parsing [ van Noord, 1991 ] . The advantages of bottom-up and top-down processing are often combined by making use of a precompiled reachability relation [ Kay, 1980 ] .
Reference: [ Maxwell III and Kaplan, 1991 ] <author> John T. Maxwell III and Ronald M. Kaplan. </author> <title> A method for disjunctive constraint satisfaction. </title> <editor> In Masaru Tomita, editor, </editor> <booktitle> Current issues in parsing technology, </booktitle> <pages> pages 173 - 190. </pages> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1991. </year>
Reference: [ Mellish, 1988 ] <author> Christopher S. Mellish. </author> <title> Implementing systemic classification by unification. </title> <journal> Computational Linguistics, </journal> <volume> 14(1) </volume> <pages> 40-51, </pages> <year> 1988. </year>
Reference-contexts: In Prolog-based systems such as ProFIT [ Erbach, 1995 ] , finite domains with N possible values are implemented by compilation into a term with N + 1 arguments <ref> [ Mellish, 1988; Mellish, 1992 ] </ref> . Underspecification Underspecification techniques have been used to avoid disjunctions by constructing type hierarchies or term representations, in which one term can stand for a set of values and a choice among these values takes place by further instantiation of the term.
Reference: [ Mellish, 1992 ] <author> Christopher S. Mellish. </author> <title> Term-encodable description spaces. </title> <editor> In D. R. Brough, editor, </editor> <booktitle> Logic Programming: New Frontiers, </booktitle> <pages> pages 189 - 207. </pages> <publisher> Intellect, Oxford, </publisher> <year> 1992. </year>
Reference-contexts: In Prolog-based systems such as ProFIT [ Erbach, 1995 ] , finite domains with N possible values are implemented by compilation into a term with N + 1 arguments <ref> [ Mellish, 1988; Mellish, 1992 ] </ref> . Underspecification Underspecification techniques have been used to avoid disjunctions by constructing type hierarchies or term representations, in which one term can stand for a set of values and a choice among these values takes place by further instantiation of the term.
Reference: [ Neumann, 1994a ] <author> Gunter Neumann. </author> <title> Application of explanation-based learning for efficient processing of constraint-based grammars. </title> <booktitle> In Proceedings of the Tenth IEEE Conference on Artificial Intelligence for Applications, </booktitle> <pages> pages 208-215, </pages> <address> San Antonio, Texas, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: Explanation-based learning is a partial deduction technique that has been used to speed up NL parsing and generation by replacing sequences of frequently occurring rule applications (inference steps) by one compiled rule <ref> [ Neumann, 1994a; Samuelsson, 1994a ] </ref> . Approaches derived from LR-parsing compile a grammar into a condition-action table which has the benefit that different rules (or clauses) with a common prefix don't lead to separate threads in the computation.
Reference: [ Neumann, 1994b ] <author> Gunter Neumann. </author> <title> A Uniform Computational Model for Natural Language Parsing and Generation. </title> <type> PhD thesis, </type> <institution> Universitat des Saarlandes, Saarbrucken, </institution> <year> 1994. </year>
Reference-contexts: Refinements include the restriction technique to avoid prediction loops [ Shieber, 1985 ] , the use of the algorithm for both parsing and generation through a modification of the indexing scheme <ref> [ Shieber, 1988; Neumann, 1994b ] </ref> , extensions for the memoisation of coroutined constraints [ Johnson and Dorre, 1995 ] , and a bottom-up variant [ Erbach, 1994a ] .
Reference: [ Pereira and Warren, 1980 ] <author> Fernando C.N. Pereira and David H.D. Warren. </author> <title> Definite Clause Grammars for language analysis a survey of the formalism and a comparison with Augmented Transition Networks. </title> <journal> Artificial Intelligence, </journal> <volume> 13(3) </volume> <pages> 231-278, </pages> <year> 1980. </year>
Reference: [ Pereira and Warren, 1983 ] <author> Fernando C.N. Pereira and David H.D. Warren. </author> <title> Parsing as deduction. </title> <booktitle> In Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 137-144, </pages> <year> 1983. </year>
Reference-contexts: A key idea is to express a grammar as a set of statements in a logic (e.g. Horn clauses), and to use a theorem prover (e.g. resolution) in order to parse or generate NL sentences. The original slogan parsing as deduction <ref> [ Pereira and Warren, 1983 ] </ref> is nowadays extended to bidirectional linguistic deduction in which the same grammar can be employed both for parsing and generation. However, Prolog has turned out to be insufficient for the purposes of NLP for a number of reasons (inefficient search strategy, unexpressive constraint language). <p> Tabulation Due to the amount of search involved in NLP, Prolog's backtracking search is rather inefficient, and tabulation (memoing) techniques should be used in order to store and re-use partial results. The earliest application of tabulation in logic programming is Earley Deduction <ref> [ Pereira and Warren, 1983 ] </ref> , which adapts the basic idea of Earley's context-free parsing algorithm as a proof procedure for logic programs, and especially DCG parsing.
Reference: [ Pollard and Sag, 1994 ] <author> Carl Pollard and Ivan Sag. </author> <title> Head-driven Phrase Structure Grammar. </title> <publisher> University of Chicago Press, </publisher> <address> Chicago, </address> <year> 1994. </year>
Reference-contexts: This can be evidenced within the so called principle-based grammatical theories such as the government-binding theory [ Chomsky, 1981; Lasnik, 1991 ] and HPSG <ref> [ Pollard and Sag, 1994 ] </ref> . <p> and have been integrated in the Oz language [ Smolka et al., 1995 ] . 2.3 Types and Typed Feature Structures Types and inheritance between types are important devices for the hierarchical structuring of linguistic knowledge, and are widely used in influential linguistic theories such as head-driven phrase structure grammar <ref> [ Pollard and Sag, 1994 ] </ref> . However, the notions of type (or sort) can mean different things in different grammatical formalisms, which can be a source of confusion. Single inheritance is generally considered insufficient since it does not allow cross-classification of linguistic descriptions.
Reference: [ Samuelsson, 1994a ] <author> Christer Samuelsson. </author> <title> Fast Natural-Language Parsing Using Explanation-Based Learning. </title> <type> PhD thesis, </type> <institution> The Royal Institute of Technology and Stockholm University, Stockholm, </institution> <month> Feb </month> <year> 1994. </year>
Reference-contexts: Explanation-based learning is a partial deduction technique that has been used to speed up NL parsing and generation by replacing sequences of frequently occurring rule applications (inference steps) by one compiled rule <ref> [ Neumann, 1994a; Samuelsson, 1994a ] </ref> . Approaches derived from LR-parsing compile a grammar into a condition-action table which has the benefit that different rules (or clauses) with a common prefix don't lead to separate threads in the computation.
Reference: [ Samuelsson, 1994b ] <author> Christer Samuelsson. </author> <title> Notes on LR parser design. </title> <booktitle> In Proceedings of the 15th International Conference on Computational Linguistics, </booktitle> <pages> pages 386 - 390, </pages> <address> Kyoto, </address> <year> 1994. </year>
Reference-contexts: Approaches derived from LR-parsing compile a grammar into a condition-action table which has the benefit that different rules (or clauses) with a common prefix don't lead to separate threads in the computation. LR-based techniques have been applied to parsing and generation <ref> [ Samuelsson, 1994b; Samuelsson, 1995 ] </ref> . Termination problems can arise when the same program (logic grammar) is used for parsing and generation because the termination is dependent on the instantiation of arguments and the flow of information between different goals of a clause.
Reference: [ Samuelsson, 1995 ] <author> Christer Samuelsson. </author> <title> An efficient algorithm for surface generation. </title> <booktitle> In IJCAI 95, </booktitle> <address> Montreal, </address> <year> 1995. </year>
Reference-contexts: Approaches derived from LR-parsing compile a grammar into a condition-action table which has the benefit that different rules (or clauses) with a common prefix don't lead to separate threads in the computation. LR-based techniques have been applied to parsing and generation <ref> [ Samuelsson, 1994b; Samuelsson, 1995 ] </ref> . Termination problems can arise when the same program (logic grammar) is used for parsing and generation because the termination is dependent on the instantiation of arguments and the flow of information between different goals of a clause.
Reference: [ Shieber et al., 1983 ] <author> Stuart M. Shieber, Hans Uszkoreit, Fernando C. N. Pereira, Jane J. Robin-son, and Mabry Tyson. </author> <title> The formalism and implementation of PATR-II. </title> <editor> In Barbara J. Grosz and Mark E. Stickel, editors, </editor> <booktitle> Research on Interactive Acquisition and Use of Knowledge, </booktitle> <pages> pages 39-79. </pages> <publisher> SRI International, </publisher> <address> Menlo Park, CA, </address> <year> 1983. </year>
Reference-contexts: Further research into more efficient memoisation schemes is probably needed. 2.2 Feature Structures In computational linguistics, feature structures (attribute-value matrices) have for a long time been preferred over Prolog terms (e.g. PATR <ref> [ Shieber et al., 1983 ] </ref> or Lexical Functional Grammar [ Kaplan and Bresnan, 1982 ] ) because they allow a more perspicuous and compact encoding of linguistic knowledge.
Reference: [ Shieber et al., 1990 ] <author> Stuart M. Shieber, Gertjan van Noord, Fernando C. N. Pereira, and R. C. Moore. </author> <title> Semantic-head-driven generation. </title> <journal> Computational Linguistics, </journal> <volume> 16(1) </volume> <pages> 30-42, </pages> <year> 1990. </year>
Reference-contexts: Therefore NL parsers and generators often make use of bottom-up methods, e.g., left-corner parsing and its compilation into a Prolog program (BUP) [ Matsumoto et al., 1983 ] , semantic-head driven generation <ref> [ Shieber et al., 1990 ] </ref> , head-corner parsing [ van Noord, 1991 ] . The advantages of bottom-up and top-down processing are often combined by making use of a precompiled reachability relation [ Kay, 1980 ] .
Reference: [ Shieber, 1985 ] <author> Stuart M. Shieber. </author> <title> Using restriction to extend parsing algorithms for complex-feature-based formalisms. </title> <booktitle> In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 145-152, </pages> <year> 1985. </year>
Reference-contexts: The earliest application of tabulation in logic programming is Earley Deduction [ Pereira and Warren, 1983 ] , which adapts the basic idea of Earley's context-free parsing algorithm as a proof procedure for logic programs, and especially DCG parsing. Refinements include the restriction technique to avoid prediction loops <ref> [ Shieber, 1985 ] </ref> , the use of the algorithm for both parsing and generation through a modification of the indexing scheme [ Shieber, 1988; Neumann, 1994b ] , extensions for the memoisation of coroutined constraints [ Johnson and Dorre, 1995 ] , and a bottom-up variant [ Erbach, 1994a ]
Reference: [ Shieber, 1988 ] <author> Stuart M. Shieber. </author> <title> A uniform architecture for parsing and generation. </title> <journal> In COLING-88, </journal> <pages> pages 614-619, </pages> <year> 1988. </year>
Reference-contexts: Refinements include the restriction technique to avoid prediction loops [ Shieber, 1985 ] , the use of the algorithm for both parsing and generation through a modification of the indexing scheme <ref> [ Shieber, 1988; Neumann, 1994b ] </ref> , extensions for the memoisation of coroutined constraints [ Johnson and Dorre, 1995 ] , and a bottom-up variant [ Erbach, 1994a ] .
Reference: [ Smolka et al., 1995 ] <author> Gert Smolka, Martin Henz, and Jorg Wurtz. </author> <title> Object-oriented concurrent constraint programming in Oz. </title> <editor> In P. van Hentenryck and V. Saraswat, editors, </editor> <booktitle> Principles and Practice of Constraint Programming, chapter 2, </booktitle> <pages> pages 27-48. </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Following the pioneering work of At-Kaci [ At-Kaci, 1984; At-Kaci and Nasr, 1986 ] , they have been introduced into various logic programming languages. Efficient implementation methods exist for open and closed feature structures, and have been integrated in the Oz language <ref> [ Smolka et al., 1995 ] </ref> . 2.3 Types and Typed Feature Structures Types and inheritance between types are important devices for the hierarchical structuring of linguistic knowledge, and are widely used in influential linguistic theories such as head-driven phrase structure grammar [ Pollard and Sag, 1994 ] .
Reference: [ Smolka, 1992 ] <author> Gert Smolka. </author> <title> Feature constraint logics for unification grammars. </title> <journal> Journal of Logic Programming, </journal> <volume> 12:51 - 87, </volume> <year> 1992. </year>
Reference-contexts: Broadly speaking, typed feature formalisms are Horn-extensions over feature descriptions. They can loosely be understood as specific instantia-tions of the CLP (FT) paradigm where FT stands for a specific version of feature logic [ Kasper and Rounds, 1986 ] <ref> [ Smolka, 1992 ] </ref> with types and inheritance. <p> Closed feature structures are generally used in typed feature structures, where a fixed set of features is declared to be appropriate for a particular type. A good overview of feature constraint logics for NLP is given in <ref> [ Smolka, 1992 ] </ref> . In logic programming, feature constraints have become fairly common. Following the pioneering work of At-Kaci [ At-Kaci, 1984; At-Kaci and Nasr, 1986 ] , they have been introduced into various logic programming languages.
Reference: [ Strzalkowski, 1991 ] <author> Tomek Strzalkowski. </author> <title> A general computational method for grammar inversion. </title> <editor> In Tomek Strzalkowski, editor, </editor> <booktitle> ACL SIG workshop "Reversible Grammar in Natural Language Processing", </booktitle> <pages> pages 91 - 99, </pages> <address> Berkeley, CA, </address> <year> 1991. </year>
Reference-contexts: Termination problems can arise when the same program (logic grammar) is used for parsing and generation because the termination is dependent on the instantiation of arguments and the flow of information between different goals of a clause. The Essential Argument Algorithm <ref> [ Strzalkowski, 1991 ] </ref> distinguishes input and output arguments of DCGs, and uses re-ordering of goals within and across clauses in order to derive grammars that are specialised for parsing or generation, in the sense that the input arguments (the semantics in case of generation, and the surface string in case
Reference: [ Trost and Matiasek, 1994 ] <author> Harald Trost and Johannes Matiasek. </author> <title> Morphology with a null-interface. </title> <booktitle> In Proceedings of the 15th International Conference on Computational Linguistics, </booktitle> <address> Kyoto, Japan, </address> <year> 1994. </year>
Reference-contexts: This mechanism is very useful for NLP because it permits the experimentation with and application of new kinds of constraints solvers (e.g. the handling of grammatical principles as type constraints [ Matiasek, 1994 ] , or morphology as a constraint between surface and lexical forms <ref> [ Trost and Matiasek, 1994 ] </ref> ). 2.6 Disjunction Disjunction handling is an important problem for NLP due to the lexical and structural ambiguity inherent in natural language [ Trost, 1993 ] . The creation of choice points for these cases of ambiguity would lead to serious efficiency problems.
Reference: [ Trost, 1993 ] <editor> Harald Trost, editor. </editor> <title> Feature Formalisms and Linguistic Ambiguity. </title> <publisher> Ellis Horwood, </publisher> <address> Chichester, </address> <year> 1993. </year>
Reference-contexts: handling of grammatical principles as type constraints [ Matiasek, 1994 ] , or morphology as a constraint between surface and lexical forms [ Trost and Matiasek, 1994 ] ). 2.6 Disjunction Disjunction handling is an important problem for NLP due to the lexical and structural ambiguity inherent in natural language <ref> [ Trost, 1993 ] </ref> . The creation of choice points for these cases of ambiguity would lead to serious efficiency problems. There are two approaches other than backtracking to disjunction handling in grammar formalisms: distributed disjunctions and finite domains.
Reference: [ Uszkoreit, 1991 ] <author> Hans Uszkoreit. </author> <title> Strategies for adding control information to declarative grammars. </title> <booktitle> In Proceedings of the 29th Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 237-245, </pages> <address> Berkeley, CA, </address> <year> 1991. </year>
Reference-contexts: Within CLP based systems, this can be implemented through a dynamic goal selection function which for a selected atom chooses clauses with the highest preference first <ref> [ Uszkoreit, 1991 ] </ref> . In future language processing systems such best-first selection strategies are likely to play an important role. An equally important problem is the handling of ill-formed (ungrammatical) input as it occurs in applied systems. <p> In Computational Linguistics research, this new trend is also reflected in the shift from competence models to performance models <ref> [ Uszkoreit, 1991 ] </ref> . A programming language for natural language must support research into the integration of declarative logical models and statistical language models.
Reference: [ van Noord, 1991 ] <author> Gertjan van Noord. </author> <title> Head corner parsing for discontinuous constituency. </title> <booktitle> In 29th Annual Meeting of the Association for Computational Linguistics, </booktitle> <address> Berkeley, </address> <year> 1991. </year>
Reference-contexts: Therefore NL parsers and generators often make use of bottom-up methods, e.g., left-corner parsing and its compilation into a Prolog program (BUP) [ Matsumoto et al., 1983 ] , semantic-head driven generation [ Shieber et al., 1990 ] , head-corner parsing <ref> [ van Noord, 1991 ] </ref> . The advantages of bottom-up and top-down processing are often combined by making use of a precompiled reachability relation [ Kay, 1980 ] . In logic programming, bottom-up approaches are found for example in the area of deductive databases.
Reference: [ Vijay-Shanker, 1992 ] <author> K Vijay-Shanker. </author> <title> Using descriptions of trees in a tree adjoining grammar. </title> <booktitle> Computational Linguistics, </booktitle> <pages> pages 519 - 530, </pages> <year> 1992. </year>
Reference-contexts: Symbolic constraints such as set descriptions and set operations [ Manandhar, 1994 ] , linear precedence constraints [ Manandhar, 1995 ] , guarded constraints over these constraints [ Erbach et al., 1995 ] , tree descriptions <ref> [ Vijay-Shanker, 1992 ] </ref> are among those that have been investigated. Set descriptions permit multiple values for the same feature symbol in the same way as knowledge representation languages such as KL-ONE [ Brachman and Schmolze, 1985 ] 2 .
Reference: [ Warren, 1992 ] <author> David S. Warren. </author> <title> Memoing for logic programs. </title> <journal> Communications of the ACM, </journal> <volume> 35(3):93 - 111, </volume> <year> 1992. </year>
Reference-contexts: Only recently, memoisation techniques (OLDT resolution) have been incorporated into logic programming languages such as XSB Prolog <ref> [ Warren, 1992 ] </ref> . This is an important development for NLP because traditional Prolog-based implementations of chart parsers suffer from a loss of efficiency due to the copying of structures when items are stored.
Reference: [ Wilson and Borning, 1993 ] <author> Molly Wilson and Alan Borning. </author> <title> Hierarchical constraint logic programming. </title> <type> Technical Report 93-01-02a, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: In order to handle this problem, where not all constraints of the grammar can be satisfied in parsing a sentence, future constraint-based linguistic processing will require dynamic and preferential constraint satisfaction. Thus research in areas such as hierarchical constraint logic programming <ref> [ Wilson and Borning, 1993 ] </ref> has potential applications for such NLP tasks.
References-found: 59

