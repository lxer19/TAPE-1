URL: file://ftp.win.tue.nl/pub/techreports/tbasten/vtc.ps.gz
Refering-URL: http://wwwis.win.tue.nl/~tbasten/publications.html
Root-URL: http://www.win.tue.nl
Phone: 2  
Title: Vector Time and Causality among Abstract Events in Distributed Computations  
Author: Twan Basten Thomas Kunz James P. Black Michael H. Coffin and David J. Taylor 
Keyword: Key words: Distributed systems Event abstraction Causality- Precedence relation Partial order Vector time Logical time  
Address: The Netherlands  Waterloo, Waterloo, Ontario, Canada  
Affiliation: 1 Department of Mathematics and Computing Science, Eindhoven University of Technology, Eindhoven,  Department of Computer Science, University of  
Abstract: An important problem in analyzing distributed computations is the amount of information. In event-based models, even for simple applications, the number of events is large and the causal structure is complex. Event abstraction can be used to reduce the apparent complexity of a distributed computation. This paper discusses one important aspect of event abstraction: causality among abstract events. Following Lamport [24], two causality relations are defined on abstract events, called weak and strong precedence. A general theoretical framework based on logical vector time is developed in which several meaningful timestamps for abstract events are derived. These timestamps can be used to efficiently determine causal relationships between arbitrary abstract events. The class of convex abstract events is identified as a subclass of abstract events that is general enough to be widely applicable and restricted enough to simplify timestamping schemes used for characterizing weak precedence. We explain why such a simplification seems not possible for strong precedence. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Ahuja, A.D. Kshemkalyani, and T. Carlson. </author> <title> A basic unit of computation in distributed systems. </title> <booktitle> In IEEE Proceedings of the 10th. International Conference on Distributed Computing Systems, </booktitle> <pages> pages 12-19, </pages> <address> Paris, France, May/June 1990. </address> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA. </address>
Reference-contexts: They are restricted in the sense that, in the terminology of this paper, each abstract event can contain primitive events from only a single process. A different approach is taken in <ref> [1, 2] </ref>. In these papers, the notions of atoms and molecules as abstract events are introduced, as well as precedence relations on such abstract events. Without going into detail, we will explain what we believe to be a serious shortcoming of this approach to event abstraction. <p> Without going into detail, we will explain what we believe to be a serious shortcoming of this approach to event abstraction. Consider the example of Figure 5 (b). In the terminology of <ref> [1, 2] </ref>, abstract events A, B, and C are all atoms. Since the precedence relation in [1, 2] is transitive, this implies that A precedes C, although none of the primitive events in A is related to any of the events in C. In our opinion, this is undesirable. <p> Without going into detail, we will explain what we believe to be a serious shortcoming of this approach to event abstraction. Consider the example of Figure 5 (b). In the terminology of <ref> [1, 2] </ref>, abstract events A, B, and C are all atoms. Since the precedence relation in [1, 2] is transitive, this implies that A precedes C, although none of the primitive events in A is related to any of the events in C. In our opinion, this is undesirable.
Reference: 2. <author> M. Ahuja and S. Mishra. </author> <title> Units of computation in fault-tolerant distributed systems. </title> <booktitle> In IEEE Proceedings of the 14th. International Conference on Distributed Computing Systems, </booktitle> <pages> pages 626-633, </pages> <address> Poznan, Poland, June 1994. </address> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA. </address>
Reference-contexts: They are restricted in the sense that, in the terminology of this paper, each abstract event can contain primitive events from only a single process. A different approach is taken in <ref> [1, 2] </ref>. In these papers, the notions of atoms and molecules as abstract events are introduced, as well as precedence relations on such abstract events. Without going into detail, we will explain what we believe to be a serious shortcoming of this approach to event abstraction. <p> Without going into detail, we will explain what we believe to be a serious shortcoming of this approach to event abstraction. Consider the example of Figure 5 (b). In the terminology of <ref> [1, 2] </ref>, abstract events A, B, and C are all atoms. Since the precedence relation in [1, 2] is transitive, this implies that A precedes C, although none of the primitive events in A is related to any of the events in C. In our opinion, this is undesirable. <p> Without going into detail, we will explain what we believe to be a serious shortcoming of this approach to event abstraction. Consider the example of Figure 5 (b). In the terminology of <ref> [1, 2] </ref>, abstract events A, B, and C are all atoms. Since the precedence relation in [1, 2] is transitive, this implies that A precedes C, although none of the primitive events in A is related to any of the events in C. In our opinion, this is undesirable.
Reference: 3. <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. </title> <editor> In S.J. Mullender, editor, </editor> <booktitle> Distributed Systems (2nd. edition), chapter 4, </booktitle> <pages> pages 55-96. </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: A good starting point for an introduction to several of these issues that play an important role in distributed computing is <ref> [3] </ref>. Experience shows that even for simple distributed applications, the amount of behavioral information is very large, and the causality structure is very complex. It is well known that human beings have difficulties managing too much information at once.
Reference: 4. <author> T. Basten. </author> <title> Breakpoints and time in distributed computations. </title> <editor> In G. Tel and P.M.B. Vitanyi, editors, </editor> <booktitle> Distributed Algorithms, 8th. International Workshop, WDAG '94, Proceedings, volume 857 of Lecture Notes in Computer Science, </booktitle> <pages> pages 340-355, </pages> <address> Terschelling, The Netherlands, September/October 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1994. </year>
Reference-contexts: To determine causal relationships between events, logical-timestamp schemes have been proposed [16, 23, 27]. Logical time has been used for many different purposes: implementing causal broadcasts [9], measuring concurrency [10], detecting global predicates [14, 26], implementing distributed breakpoints <ref> [4, 19] </ref>, computing consistent global snapshots [27], and visualizing program ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. 1 behavior [32]. <p> A more extensive treatment of reversed vector time than presented in this subsection can be found in [5]. An application of reversed vector time to distributed breakpoints is described in <ref> [4] </ref>. The notions of causal future and reversed vector time are based on the successor relation O, which is defined as the dual of OE.
Reference: 5. <author> T. Basten, T. Kunz, J.P. Black, M.H. Coffin, </author> <title> and D.J. Taylor. Time and the order of abstract events in distributed computations. </title> <note> Computing Science Note 94/06, </note> <institution> Eindhoven University of Technology, Department of Mathematics and Computing Science, Eindhoven, </institution> <address> The Netherlands, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: A more extensive treatment of reversed vector time than presented in this subsection can be found in <ref> [5] </ref>. An application of reversed vector time to distributed breakpoints is described in [4]. The notions of causal future and reversed vector time are based on the successor relation O, which is defined as the dual of OE. <p> Hence, also for abstract events T c is equal to T ci , which concludes the proof. (See <ref> [5] </ref> for the details of the induction proof.) 2 Definition 8.6 and Property 8.7 show that timestamp T c and, hence, the precedence test of Theorem 8.5 satisfy the criterion of hierarchical applicability. In addition, they show that indeed a single timestamp is sufficient to characterize weak precedence.
Reference: 6. <author> P.C. Bates. </author> <title> Debugging heterogeneous distributed systems using event-based models of behavior. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(1) </volume> <pages> 1-31, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The price that we have paid is that weak precedence is not a partial order. So far, we have only mentioned work that explicitly addresses the question of causality among (relatively) general abstract events. Some papers describing event abstraction simply ignore the issue of causality <ref> [6, 7, 19] </ref>. Others limit their attention to abstract events with specific structural properties [8, 33].
Reference: 7. <author> P.C. Bates and J.C. Wileden. </author> <title> High-level debugging of distributed systems: The behavioral abstraction approach. </title> <journal> The Journal of Systems and Software, </journal> <volume> 3(4) </volume> <pages> 255-264, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: The price that we have paid is that weak precedence is not a partial order. So far, we have only mentioned work that explicitly addresses the question of causality among (relatively) general abstract events. Some papers describing event abstraction simply ignore the issue of causality <ref> [6, 7, 19] </ref>. Others limit their attention to abstract events with specific structural properties [8, 33].
Reference: 8. <author> E. Best and B. Randell. </author> <title> A formal model of atomicity in asynchronous systems. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 93-124, </pages> <year> 1981. </year>
Reference-contexts: So far, we have only mentioned work that explicitly addresses the question of causality among (relatively) general abstract events. Some papers describing event abstraction simply ignore the issue of causality [6, 7, 19]. Others limit their attention to abstract events with specific structural properties <ref> [8, 33] </ref>. While this allows them to prove certain desirable properties for their abstract events, it severely limits the modeling power. 5 Timestamping Abstract Events 5.1 Timestamps and Precedence Tests for Abstract Events This subsection discusses some basic issues with respect to timestamps and precedence tests for abstract events. <p> Convexity is useful as well. First, convex abstract events are easier to recognize automatically than arbitrary abstract events, because it is not necessary to filter out interfering events. Second, they are more general and therefore more widely applicable than, for example, contractions <ref> [8, 13] </ref>. A contraction is an abstract event whose internal structure is restricted in such a way that it may be considered to occur atomically.
Reference: 9. <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year>
Reference-contexts: In [23], Lamport argues that causality among primitive events is a partial order. To determine causal relationships between events, logical-timestamp schemes have been proposed [16, 23, 27]. Logical time has been used for many different purposes: implementing causal broadcasts <ref> [9] </ref>, measuring concurrency [10], detecting global predicates [14, 26], implementing distributed breakpoints [4, 19], computing consistent global snapshots [27], and visualizing program ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. 1 behavior [32].
Reference: 10. <author> B. Charron-Bost. </author> <title> Combinatorics and geometry of consistent cuts: Application to concurrency theory. </title> <editor> In J.-C. Bermond and M. Raynal, editors, </editor> <booktitle> Distributed Algorithms, 3rd. International Workshop, WDAG '89, Proceedings, volume 392 of Lecture Notes in Computer Science, </booktitle> <pages> pages 45-56, </pages> <address> Nice, France, September 1989. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany. </address>
Reference-contexts: In [23], Lamport argues that causality among primitive events is a partial order. To determine causal relationships between events, logical-timestamp schemes have been proposed [16, 23, 27]. Logical time has been used for many different purposes: implementing causal broadcasts [9], measuring concurrency <ref> [10] </ref>, detecting global predicates [14, 26], implementing distributed breakpoints [4, 19], computing consistent global snapshots [27], and visualizing program ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. 1 behavior [32]. <p> The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [27, 28], Charron-Bost <ref> [10, 11, 12] </ref>, and Fidge [16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [23]. <p> Event e 0 precedes event e 1 since all the predecessors of e 0 are also predecessors of e 1 . e 0 T:e 0 e 1 Definition 3.5. (Causal past <ref> [10, 28, 30] </ref>) The function p: : E ! 2 E defines the causal past of an event as follows. For any e 2 E, pe = fe 0 2 E j e 0 eg. Note that pe is a consistent cut. <p> Note that p -e = pe n feg. The causal past in some process i of an event is the set of all its predecessors in i. Definition 3.7. (Causal past in a process <ref> [10] </ref>) For any i 2 P, the function p i : : E ! 2 E i defines the causal past in process i of an event. For any e 2 E, p i e = pe " E i = fe 0 2 E i j e 0 eg.
Reference: 11. <author> B. Charron-Bost. </author> <title> Concerning the size of logical clocks in distributed systems. </title> <journal> Information Processing Letters, </journal> <volume> 39 </volume> <pages> 11-16, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [27, 28], Charron-Bost <ref> [10, 11, 12] </ref>, and Fidge [16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [23]. <p> A vector timestamp of size N is assigned to every event such that component i 2 P of the timestamp is equal to the number of predecessors of the event in process i. 7 Definition 3.13. (Timestamp function <ref> [11, 28] </ref>) The function T : E ! IN N defines a timestamp for every event as follows. For any event e 2 E and process i 2 P, T:e:i = jp i ej. The vector representation of timestamps is possible only because the number of processes is known.
Reference: 12. <author> B. Charron-Bost, F. Mattern, and G. Tel. </author> <title> Synchronous, asynchronous, and causally ordered communication. </title> <journal> Distributed Computing, </journal> <volume> 9(4) </volume> <pages> 173-191, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [27, 28], Charron-Bost <ref> [10, 11, 12] </ref>, and Fidge [16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [23]. <p> We prefer this model of synchronous communication over another model of synchronous communication in the literature <ref> [12, 13, 16] </ref>, which models a synchronous communication as two unrelated events; this model has the disadvantage that a synchronous communication cannot be distinguished from a pair of concurrent events. Let denote the reflexive closure of the precedence relation OE. The relation can be used to express concurrency among events.
Reference: 13. <author> W.-H. Cheung. </author> <title> Process and event abstraction for debugging distributed programs. </title> <type> PhD thesis, </type> <institution> University of Waterloo, Department of Computer Science, Waterloo, </institution> <address> Ontario, Canada, </address> <year> 1989. </year> <note> Also appeared as CCNG Technical Report T-189, 1989. 31 </note>
Reference-contexts: We prefer this model of synchronous communication over another model of synchronous communication in the literature <ref> [12, 13, 16] </ref>, which models a synchronous communication as two unrelated events; this model has the disadvantage that a synchronous communication cannot be distinguished from a pair of concurrent events. Let denote the reflexive closure of the precedence relation OE. The relation can be used to express concurrency among events. <p> Convexity is useful as well. First, convex abstract events are easier to recognize automatically than arbitrary abstract events, because it is not necessary to filter out interfering events. Second, they are more general and therefore more widely applicable than, for example, contractions <ref> [8, 13] </ref>. A contraction is an abstract event whose internal structure is restricted in such a way that it may be considered to occur atomically.
Reference: 14. <author> R. Cooper and K. Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 163-173, </pages> <address> Santa Cruz, CA, </address> <month> May </month> <year> 1991. </year> <note> The proceedings appeared also as ACM SIGPLAN Notices, 26(12), </note> <month> December </month> <year> 1991. </year>
Reference-contexts: In [23], Lamport argues that causality among primitive events is a partial order. To determine causal relationships between events, logical-timestamp schemes have been proposed [16, 23, 27]. Logical time has been used for many different purposes: implementing causal broadcasts [9], measuring concurrency [10], detecting global predicates <ref> [14, 26] </ref>, implementing distributed breakpoints [4, 19], computing consistent global snapshots [27], and visualizing program ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. 1 behavior [32].
Reference: 15. <author> C.J. Fidge. </author> <title> Partial orders for parallel debugging. </title> <journal> ACM Sigplan Notices, </journal> <volume> 24(1) </volume> <pages> 183-194, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Another variant of the weak precedence relation appears in the area of distributed databases [29], where abstract events correspond to transactions. Restricted versions of both weak and strong precedence formulated in terms of states instead of events appear in <ref> [15, 17, 18] </ref>. They are restricted in the sense that, in the terminology of this paper, each abstract event can contain primitive events from only a single process. A different approach is taken in [1, 2].
Reference: 16. <author> C.J. Fidge. </author> <title> Logical time in distributed computing systems. </title> <journal> IEEE Computer, </journal> <volume> 24(8) </volume> <pages> 28-33, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Neither event precedes the other and they are said to be concurrent. In [23], Lamport argues that causality among primitive events is a partial order. To determine causal relationships between events, logical-timestamp schemes have been proposed <ref> [16, 23, 27] </ref>. <p> The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [27, 28], Charron-Bost [10, 11, 12], and Fidge <ref> [16] </ref>. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [23]. The set of primitive events E is the union of N mutually disjoint sets of events, E 0 ; : : : ; E N 1 , where N is the number of processes. <p> The definitions given so far model a distributed computation if and only if the precedence relation is an irreflexive partial order. The relation OE extends the "happens before" relation as defined by Lamport [23] to synchronous communication in a natural way. Condition C2, originally given by Fidge <ref> [16] </ref>, means that a synchronous communication can be interpreted as if it occurred atomically. That is, no other events 5 can occur causally between the two events participating in a synchronous communication. <p> We prefer this model of synchronous communication over another model of synchronous communication in the literature <ref> [12, 13, 16] </ref>, which models a synchronous communication as two unrelated events; this model has the disadvantage that a synchronous communication cannot be distinguished from a pair of concurrent events. Let denote the reflexive closure of the precedence relation OE. The relation can be used to express concurrency among events. <p> Since the precedence relation is a partial order, it is not possible to use physical time or any other totally ordered set as a characterization. For this reason, Mattern [27] and Fidge <ref> [16] </ref> independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [23]. In this subsection, we summarize some definitions and results given by Mattern [27, 28] and Schwarz and Mattern [30]. (Note that [28] is a revised version of [27]. <p> However, vector representation of timestamps is not essential. If the number of processes is not known, the timestamp of an event can be defined as a set of pairs, where each pair consists of a process identifier and the corresponding timestamp component <ref> [16] </ref>. An example of the assignment of vector timestamps to events is given in Figure 4, showing a standard process-time diagram. Horizontal lines represent processes. Time increases from left to right. Events are depicted as dots. Arrows represent the communication relation .
Reference: 17. <author> E. Fromentin and M. Raynal. </author> <title> Local states in distributed computations: A few relations and formulas. </title> <journal> ACM Operating Systems Review, </journal> <volume> 28(2) </volume> <pages> 65-72, </pages> <year> 1994. </year>
Reference-contexts: For this purpose, an event-based representation of distributed computations is most convenient, whereas for other purposes, such as for example distributed-predicate detection, a state-based representation is more appropriate. We do not discuss the advantages and disadvantages of both representations in detail. In <ref> [17] </ref>, timestamps and causality relations are defined for a state 2 based representation of computations. The two representations yield very similar formulas. The results presented in this paper can easily be translated to a state-based representation of distributed computations. <p> Another variant of the weak precedence relation appears in the area of distributed databases [29], where abstract events correspond to transactions. Restricted versions of both weak and strong precedence formulated in terms of states instead of events appear in <ref> [15, 17, 18] </ref>. They are restricted in the sense that, in the terminology of this paper, each abstract event can contain primitive events from only a single process. A different approach is taken in [1, 2].
Reference: 18. <author> E. Fromentin and M. Raynal. </author> <title> Characterizing and detecting the set of global states seen by all observers of a distributed computation. </title> <booktitle> In IEEE Proceedings of the 15th. International Conference on Distributed Computing Systems, </booktitle> <pages> pages 431-438. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1995. </year>
Reference-contexts: Another variant of the weak precedence relation appears in the area of distributed databases [29], where abstract events correspond to transactions. Restricted versions of both weak and strong precedence formulated in terms of states instead of events appear in <ref> [15, 17, 18] </ref>. They are restricted in the sense that, in the terminology of this paper, each abstract event can contain primitive events from only a single process. A different approach is taken in [1, 2].
Reference: 19. <author> D. Haban and W. Weigel. </author> <title> Global events and global breakpoints in distributed systems. </title> <booktitle> In Proceedings of the 21st. Annual Hawaii International Conference on System Sciences, </booktitle> <volume> Volume II, </volume> <pages> pages 166-175, </pages> <address> Kailua-Kona, Hawaii, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: To determine causal relationships between events, logical-timestamp schemes have been proposed [16, 23, 27]. Logical time has been used for many different purposes: implementing causal broadcasts [9], measuring concurrency [10], detecting global predicates [14, 26], implementing distributed breakpoints <ref> [4, 19] </ref>, computing consistent global snapshots [27], and visualizing program ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. 1 behavior [32]. <p> The price that we have paid is that weak precedence is not a partial order. So far, we have only mentioned work that explicitly addresses the question of causality among (relatively) general abstract events. Some papers describing event abstraction simply ignore the issue of causality <ref> [6, 7, 19] </ref>. Others limit their attention to abstract events with specific structural properties [8, 33]. <p> Two criteria for timestamps and precedence tests are introduced: efficiency and hierarchical applicability. Furthermore, it is argued that, in general, one timestamp is not sufficient to determine precedence among abstract events. The basic work on timestamping abstract events with vector timestamps is the paper of Haban and Weigel <ref> [19] </ref>. However, as mentioned, this work lacks a good analysis of causality among abstract events. The causality relation among abstract events is defined implicitly by their timestamps. As shown by Schwarz and Mattern in [30], this leads in some cases to counterintuitive and undesirable precedences among abstract events.
Reference: 20. <author> J. Kundu and J.E. Cuny. </author> <title> A scalable, visual interface for debugging with event-based behavioral abstraction. </title> <booktitle> In Frontiers '95. Proceedings of the 5th. Symposium on the Frontiers of Massively Parallel Computation, </booktitle> <pages> pages 472-479, </pages> <year> 1995. </year>
Reference-contexts: As explained in more detail in Section 4, this means that part of the first abstract event causally affects part of the second event. In our opinion, such causal relationships are very important in debugging distributed applications, which is confirmed by, for example, <ref> [20] </ref>. The abstract visualization shown in Figure 2 is built using the timestamp scheme of Section 8. The above example was deliberately kept simple. However, we have traced distributed applications that generate many thousands of events and built event-abstraction hierarchies with many hundreds of abstract events. <p> As already mentioned, the definitions given above are taken from the work of Lamport [24, 25], in which an extensive motivation for both relations is given. A variant of the weak precedence relation, applied in the context of debugging distributed programs, appears in <ref> [20] </ref>. As already mentioned in Section 2, we also believe that weak precedence plays an important role in this area. Another variant of the weak precedence relation appears in the area of distributed databases [29], where abstract events correspond to transactions.
Reference: 21. <author> T. Kunz. </author> <title> Visualizing abstract events. </title> <booktitle> In Proceedings of the 1994 CAS Conference, </booktitle> <pages> pages 334-343, </pages> <address> Toronto, Ontario, Canada, </address> <month> November </month> <year> 1994. </year> <institution> IBM Canada Ltd. Laboratory, Centre for Advanced Studies. </institution>
Reference-contexts: An abstract event is depicted by an open, vertical rectangle, stretching over the range of all processes involved. The intersection of this rectangle with a process is drawn as a filled square if primitive events from this process are constituents of the abstract event (see also <ref> [21] </ref>). The first abstract event corresponds to the action "put a string into the buffer." The second abstract event corresponds to getting the next command from the user. The third abstract event fetches a string from the buffer and displays it.
Reference: 22. <author> T. Kunz, J.P. Black, D.J. Taylor, and T. Basten. </author> <title> Target-system-independent visualizations of complex distributed-application executions. </title> <journal> The Computer Journal, special issue on software engineering for distributed systems, </journal> <note> 1997. To appear. </note>
Reference-contexts: We are currently in the process of applying the visualization tool to long-running distributed applications, exploring issues such as managing the growth of the trace files. A more detailed explanation of the current state of the implementation of our debugger for distributed programs can be found in <ref> [22] </ref>. 4 3 Basic Definitions and Results In this paper, a distributed system is a collection of many loosely-coupled machines. These machines do not share any system resources and are only connected by a communication network. Communication channels may be lossy and delivery order may or may not be guaranteed.
Reference: 23. <author> L. Lamport. </author> <title> Time, clocks and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Causality can be expressed in terms of precedence. Sending a message, for example, always precedes receiving the message. However, sending a message might be unrelated to a write action on a local file in another process. Neither event precedes the other and they are said to be concurrent. In <ref> [23] </ref>, Lamport argues that causality among primitive events is a partial order. To determine causal relationships between events, logical-timestamp schemes have been proposed [16, 23, 27]. <p> Neither event precedes the other and they are said to be concurrent. In [23], Lamport argues that causality among primitive events is a partial order. To determine causal relationships between events, logical-timestamp schemes have been proposed <ref> [16, 23, 27] </ref>. <p> The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [27, 28], Charron-Bost [10, 11, 12], and Fidge [16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport <ref> [23] </ref>. The set of primitive events E is the union of N mutually disjoint sets of events, E 0 ; : : : ; E N 1 , where N is the number of processes. Each of these sets represents a local computation. It is assumed that E is finite. <p> The definitions given so far model a distributed computation if and only if the precedence relation is an irreflexive partial order. The relation OE extends the "happens before" relation as defined by Lamport <ref> [23] </ref> to synchronous communication in a natural way. Condition C2, originally given by Fidge [16], means that a synchronous communication can be interpreted as if it occurred atomically. That is, no other events 5 can occur causally between the two events participating in a synchronous communication. <p> For this reason, Mattern [27] and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport <ref> [23] </ref>. In this subsection, we summarize some definitions and results given by Mattern [27, 28] and Schwarz and Mattern [30]. (Note that [28] is a revised version of [27].
Reference: 24. <author> L. Lamport. </author> <title> On interprocess communication, part I: Basic formalism. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 77-85, </pages> <year> 1986. </year>
Reference-contexts: Therefore, in this paper, we study vector time, which is one particular type of logical time, and causality among abstract events. Our goal is to present a general theoretical framework that is useful for a wide variety of applications using vector time. Following Lamport <ref> [24] </ref>, two precedence relations on abstract events are defined, called weak and strong precedence. Together they capture all important aspects of causality among abstract events. The main contribution of this paper is that timestamp schemes and accompanying precedence tests are derived to efficiently determine causal relationships between abstract events. <p> Only then is it guaranteed that the second abstract event cannot start before the first one is completed. This leads to the following definition of a precedence relation on abstract events, first defined by Lamport in <ref> [24] </ref>. Definition 4.2. (Strong precedence relation on abstract events) For any abstract events A and B, A OE B , (8 a : a 2 A : (8 b : b 2 B : a OE b)): Property 4.3. <p> Seen in the light of our earlier observation that abstract events are no longer atomic, this second definition of causality among abstract events should not come as a surprise. In the words of Lamport <ref> [24] </ref>: "Nonatomicity introduces the possibility that an operation execution A can influence an operation execution B without preceding it; it is necessary only that some action of A precede some action of B. <p> The conclusion that weak and strong precedence are meaningful indeed is supported by the fact that (variants of) both weak and strong precedence appear in many places in the literature. As already mentioned, the definitions given above are taken from the work of Lamport <ref> [24, 25] </ref>, in which an extensive motivation for both relations is given. A variant of the weak precedence relation, applied in the context of debugging distributed programs, appears in [20]. As already mentioned in Section 2, we also believe that weak precedence plays an important role in this area. <p> As for primitive events, causality among abstract events can be expressed by means of precedence relations. Following Lamport <ref> [24] </ref>, in Section 4, we introduced two precedence relations on abstract events, namely strong precedence and weak precedence. An abstract event strongly precedes another abstract event if and only if all its constituents precede all constituents of the other event. <p> It also allows for a natural definition of concurrency. Unfortunately, the weak precedence relation is not a partial order. The combination of strong and weak precedence seems to be a proper characterization of causality among abstract events (see also <ref> [24] </ref>). In Section 5, we explained the main goal of this paper, namely finding characterizations of strong and weak precedence in terms of vector time. The characterization must make it possible to determine causal relationships between two abstract events efficiently in a hierarchy of abstract descriptions of program behavior.
Reference: 25. <author> L. Lamport. </author> <title> On interprocess communication, part II: Algorithms. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 86-101, </pages> <year> 1986. </year>
Reference-contexts: The conclusion that weak and strong precedence are meaningful indeed is supported by the fact that (variants of) both weak and strong precedence appear in many places in the literature. As already mentioned, the definitions given above are taken from the work of Lamport <ref> [24, 25] </ref>, in which an extensive motivation for both relations is given. A variant of the weak precedence relation, applied in the context of debugging distributed programs, appears in [20]. As already mentioned in Section 2, we also believe that weak precedence plays an important role in this area.
Reference: 26. <author> K. </author> <title> Marzullo and L.S. Sabel. Efficient detection of a class of stable properities. </title> <journal> Distributed Computing, </journal> <volume> 8 </volume> <pages> 81-91, </pages> <year> 1994. </year>
Reference-contexts: In [23], Lamport argues that causality among primitive events is a partial order. To determine causal relationships between events, logical-timestamp schemes have been proposed [16, 23, 27]. Logical time has been used for many different purposes: implementing causal broadcasts [9], measuring concurrency [10], detecting global predicates <ref> [14, 26] </ref>, implementing distributed breakpoints [4, 19], computing consistent global snapshots [27], and visualizing program ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. 1 behavior [32].
Reference: 27. <author> F. Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In M. Cosnard et al., editor, </editor> <booktitle> Parallel and Distributed Algorithms, International Workshop, Proceedings, </booktitle> <pages> pages 215-226, </pages> <address> Gers, France, October 1988. </address> <publisher> Elsevier Science Publishers B.V., Amsterdam, North-Holland, </publisher> <address> The Netherlands, </address> <year> 1989. </year>
Reference-contexts: Neither event precedes the other and they are said to be concurrent. In [23], Lamport argues that causality among primitive events is a partial order. To determine causal relationships between events, logical-timestamp schemes have been proposed <ref> [16, 23, 27] </ref>. <p> To determine causal relationships between events, logical-timestamp schemes have been proposed [16, 23, 27]. Logical time has been used for many different purposes: implementing causal broadcasts [9], measuring concurrency [10], detecting global predicates [14, 26], implementing distributed breakpoints [4, 19], computing consistent global snapshots <ref> [27] </ref>, and visualizing program ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. 1 behavior [32]. A good starting point for an introduction to several of these issues that play an important role in distributed computing is [3]. <p> The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern <ref> [27, 28] </ref>, Charron-Bost [10, 11, 12], and Fidge [16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [23]. <p> Using the definitions above, it is possible to formalize the notion of cuts. A cut is the event-based equivalent of a global state. Formalizing the notion of cuts is useful to better understand the causality structure of a distributed computation. The following definitions and theorems are due to Mattern <ref> [27] </ref>. Definition 3.1. (Cut) A set C E is called a cut of E if and only if for all events e 0 2 C and e 1 2 E, e 1 OE l e 0 ) e 1 2 C. <p> Since the precedence relation is a partial order, it is not possible to use physical time or any other totally ordered set as a characterization. For this reason, Mattern <ref> [27] </ref> and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [23]. In this subsection, we summarize some definitions and results given by Mattern [27, 28] and Schwarz and Mattern [30]. (Note that [28] is a revised version of [27]. <p> For this reason, Mattern [27] and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [23]. In this subsection, we summarize some definitions and results given by Mattern <ref> [27, 28] </ref> and Schwarz and Mattern [30]. (Note that [28] is a revised version of [27]. <p> Mattern <ref> [27] </ref> and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [23]. In this subsection, we summarize some definitions and results given by Mattern [27, 28] and Schwarz and Mattern [30]. (Note that [28] is a revised version of [27]. The reason for mentioning it here is its clear presentation; it also contains some results which are not present in [27].) The definitions and results given in this subsection form the theoretical framework which is needed to prove the correctness of the timestamp schemes and accompanying precedence tests for abstract <p> In this subsection, we summarize some definitions and results given by Mattern [27, 28] and Schwarz and Mattern [30]. (Note that [28] is a revised version of <ref> [27] </ref>. The reason for mentioning it here is its clear presentation; it also contains some results which are not present in [27].) The definitions and results given in this subsection form the theoretical framework which is needed to prove the correctness of the timestamp schemes and accompanying precedence tests for abstract events given in Sections 6 through 8. <p> Theorem 3.14. (Precedence test <ref> [27, 28, 30] </ref>) For any events e 0 ; e 1 2 E, e 0 e 1 , T:e 0 T:e 1 and e 0 OE e 1 , T:e 0 &lt; T:e 1 . This precedence test formalizes the visualization of precedence given in Figure 3. <p> It provides an efficient way to determine precedence among primitive events; at most N integer comparisons are necessary. Precedence can be determined even more efficiently if it is known in which process an event occurs. Theorem 3.15. (Precedence test <ref> [27, 30] </ref>) For any i 2 P and events e 0 2 E i and e 1 2 E, e 0 e 1 , T:e 0 :i T:e 1 :i. <p> This yields the following theorems. Theorem 3.22. (Structure of time vectors [28]) The set of time vectors, T OE l , with the ordering defined by , forms a complete lattice. It is isomorphic to the lattice (C OE l ; ). Theorem 3.23. (Structure of consistent time vectors <ref> [27] </ref>) The set of consistent time vectors T OE = fT :C j C 2 C OE g, with the ordering , forms a complete lattice. It is isomorphic to (C OE ; ).
Reference: 28. <author> F. Mattern. </author> <title> On the relativistic structure of logical time in distributed systems. </title> <journal> Bigre, </journal> <volume> 78 </volume> <pages> 3-20, </pages> <month> March </month> <year> 1992. </year> <booktitle> Proceedings of the workshop: </booktitle> <institution> Datation et Controle des Executions Reparties, </institution> <month> December </month> <year> 1991, </year> <institution> Rennes, France. </institution> <note> This paper is also available at URL: http://www.informatik.th-darmstadt.de/VS/Publikationen/. </note>
Reference-contexts: The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern <ref> [27, 28] </ref>, Charron-Bost [10, 11, 12], and Fidge [16]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [23]. <p> For this reason, Mattern [27] and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [23]. In this subsection, we summarize some definitions and results given by Mattern <ref> [27, 28] </ref> and Schwarz and Mattern [30]. (Note that [28] is a revised version of [27]. <p> For this reason, Mattern [27] and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [23]. In this subsection, we summarize some definitions and results given by Mattern [27, 28] and Schwarz and Mattern [30]. (Note that <ref> [28] </ref> is a revised version of [27]. <p> Event e 0 precedes event e 1 since all the predecessors of e 0 are also predecessors of e 1 . e 0 T:e 0 e 1 Definition 3.5. (Causal past <ref> [10, 28, 30] </ref>) The function p: : E ! 2 E defines the causal past of an event as follows. For any e 2 E, pe = fe 0 2 E j e 0 eg. Note that pe is a consistent cut. <p> A vector timestamp of size N is assigned to every event such that component i 2 P of the timestamp is equal to the number of predecessors of the event in process i. 7 Definition 3.13. (Timestamp function <ref> [11, 28] </ref>) The function T : E ! IN N defines a timestamp for every event as follows. For any event e 2 E and process i 2 P, T:e:i = jp i ej. The vector representation of timestamps is possible only because the number of processes is known. <p> Theorem 3.14. (Precedence test <ref> [27, 28, 30] </ref>) For any events e 0 ; e 1 2 E, e 0 e 1 , T:e 0 T:e 1 and e 0 OE e 1 , T:e 0 &lt; T:e 1 . This precedence test formalizes the visualization of precedence given in Figure 3. <p> In the remainder of this subsection, the notion of global time is formalized. Global-time vectors have a structure that is isomorphic to the structure of cuts. Definition 3.19. (Global time of a cut <ref> [28] </ref>) Function T : C OE l ! IN N defines the global time of a cut. For any cut C, component i, with 0 i &lt; N , of the time vector is defined as T :C:i = jC " E i j. <p> The following corollaries follow immediately from the definitions given so far. Corollary 3.20 states that the timestamp of an event reflects its causal past (see Figure 3). Corollary 3.20. <ref> [28] </ref> For any event e 2 E, T :pe = T:e. Corollary 3.21. For any event e 2 E, T :p -e = T -:e. <p> This yields the following theorems. Theorem 3.22. (Structure of time vectors <ref> [28] </ref>) The set of time vectors, T OE l , with the ordering defined by , forms a complete lattice. It is isomorphic to the lattice (C OE l ; ). <p> The notion of the causal future of an event was already mentioned in <ref> [28] </ref>. However, the idea to use it as the basis for a timestamp is new. A drawback of reversed vector 22 time is that it is only suitable for post-mortem analysis of distributed computations. The whole set of primitive events is needed to calculate reversed timestamps.
Reference: 29. <author> S. Pilarski and T. Kameda. </author> <title> Checkpointing for distributed databases: Starting from the basics. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(5) </volume> <pages> 602-610, </pages> <year> 1992. </year>
Reference-contexts: As already mentioned in Section 2, we also believe that weak precedence plays an important role in this area. Another variant of the weak precedence relation appears in the area of distributed databases <ref> [29] </ref>, where abstract events correspond to transactions. Restricted versions of both weak and strong precedence formulated in terms of states instead of events appear in [15, 17, 18].
Reference: 30. <author> R. Schwarz and F. Mattern. </author> <title> Detecting causal relationships in distributed computations: In search of the holy grail. </title> <journal> Distributed Computing, </journal> <volume> 7(3) </volume> <pages> 149-174, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Primitive events are grouped together into high-level abstract events, hiding their internal structure and creating an abstract view of the computation. Given a hierarchy of abstract views of program behavior, a distributed application can be analyzed at different levels of abstraction. As Schwarz and Mattern have observed <ref> [30] </ref>, to date, there has been no sound treatment in the literature of causality and logical time for arbitrary abstract events. Therefore, in this paper, we study vector time, which is one particular type of logical time, and causality among abstract events. <p> For this reason, Mattern [27] and Fidge [16] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [23]. In this subsection, we summarize some definitions and results given by Mattern [27, 28] and Schwarz and Mattern <ref> [30] </ref>. (Note that [28] is a revised version of [27]. <p> Event e 0 precedes event e 1 since all the predecessors of e 0 are also predecessors of e 1 . e 0 T:e 0 e 1 Definition 3.5. (Causal past <ref> [10, 28, 30] </ref>) The function p: : E ! 2 E defines the causal past of an event as follows. For any e 2 E, pe = fe 0 2 E j e 0 eg. Note that pe is a consistent cut. <p> Theorem 3.14. (Precedence test <ref> [27, 28, 30] </ref>) For any events e 0 ; e 1 2 E, e 0 e 1 , T:e 0 T:e 1 and e 0 OE e 1 , T:e 0 &lt; T:e 1 . This precedence test formalizes the visualization of precedence given in Figure 3. <p> It provides an efficient way to determine precedence among primitive events; at most N integer comparisons are necessary. Precedence can be determined even more efficiently if it is known in which process an event occurs. Theorem 3.15. (Precedence test <ref> [27, 30] </ref>) For any i 2 P and events e 0 2 E i and e 1 2 E, e 0 e 1 , T:e 0 :i T:e 1 :i. <p> However, such a test is not of any practical use.) For implementation purposes, it is important to know that vector timestamps can be calculated algorithmically during or after the execution of a distributed program. There exists a well-known, straightforward algorithm based on counters. In <ref> [30] </ref>, Schwarz and Mattern present this algorithm and they discuss techniques to implement vector timestamps efficiently. In the remainder of this subsection, the notion of global time is formalized. Global-time vectors have a structure that is isomorphic to the structure of cuts. <p> However, as mentioned, this work lacks a good analysis of causality among abstract events. The causality relation among abstract events is defined implicitly by their timestamps. As shown by Schwarz and Mattern in <ref> [30] </ref>, this leads in some cases to counterintuitive and undesirable precedences among abstract events. They believe that the reason for these counterintuitive precedences is the fact that abstract events are assigned only a single timestamp, which denies their non-atomic nature. <p> Since the two characterizations share one timestamp, three timestamps are sufficient to characterize the combination of weak and strong precedence among arbitrary abstract events. Hence, Sections 6 and 7 present a solution|or 12 at least a partial one|to one of the open problems stated in <ref> [30] </ref>, namely that of assigning meaningful timestamps to arbitrary abstract events. <p> For a more detailed discussion of specifying, detecting, and timestamping abstract events, as well as an overview of some related work, see <ref> [30] </ref>. Before explaining our criteria for timestamps and precedence tests in more detail and substantiating our claim that a single timestamp is not sufficient to characterize causality among arbitrary abstract events, we make one assumption about precedence tests and a few assumptions about times-tamps for abstract events. <p> The characterization must make it possible to determine causal relationships between two abstract events efficiently in a hierarchy of abstract descriptions of program behavior. We have argued that, for both weak and strong precedence, a single timestamp cannot be sufficient (see also <ref> [30] </ref>, where this conjecture is made as well). 29 In Sections 6 and 7, we have studied characterizations of strong and weak precedence among abstract events. Both precedence tests using location information of events and tests not using such information have been given. <p> Summarizing, the results presented in this paper are a step towards the solution of one of the 30 open problems stated in <ref> [30] </ref>, namely that of assigning meaningful timestamps to arbitrary abstract events. Some questions have been answered; some others have been raised. Acknowledgments. We are grateful to the anonymous referees of an earlier version of this paper, whose comments improved our insight in the matter of causality among abstract events.
Reference: 31. <author> R.E. Strom, D.F. Bacon, A.P. Goldberg, A. Lowry, B. Silvermann, D. Yellin, J. Russell, and S. Yemini. </author> <title> Hermes: Unix user's guide, version 0.8alpha. </title> <type> Technical report, </type> <institution> IBM T.J.Watson Research Center, </institution> <address> Yorktown Heights, NY, </address> <month> March </month> <year> 1992. </year> <month> 32 </month>
Reference-contexts: First, however, we show the abstract visualization of a small distributed computation to motivate the use of event abstraction and to show an actual implementation of the results presented in this paper. The computation visualized here is an execution of the boundedbuffer application described in the Hermes tutorial <ref> [31] </ref>. It implements a simple bounded buffer for text strings and conceptually consists of two processes. Process boundedbuffer implements the bounded buffer, and process bbintf provides a line-oriented user interface to the bounded buffer.
Reference: 32. <author> D.J. Taylor. </author> <title> A prototype debugger for Hermes. </title> <booktitle> In Proceedings of the 1992 CAS Conference, </booktitle> <volume> Volume I, </volume> <pages> pages 29-42, </pages> <address> Toronto, Ontario, Canada, </address> <month> November </month> <year> 1992. </year> <institution> IBM Canada Ltd. Laboratory, Centre for Advanced Studies. </institution>
Reference-contexts: been used for many different purposes: implementing causal broadcasts [9], measuring concurrency [10], detecting global predicates [14, 26], implementing distributed breakpoints [4, 19], computing consistent global snapshots [27], and visualizing program ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. 1 behavior <ref> [32] </ref>. A good starting point for an introduction to several of these issues that play an important role in distributed computing is [3]. Experience shows that even for simple distributed applications, the amount of behavioral information is very large, and the causality structure is very complex. <p> Second, vector timestamps for the collected events are calculated separately. Finally, the causal relationships between events in the computation can be visualized and analyzed. This approach guarantees that the program behavior is influenced as little as possible by the monitoring and analysis process. In the actual debugger <ref> [32] </ref>, steps are not as clearly separated as described above. Only timestamps needed for visualizing the part of the computation under consideration are calculated. A checkpoint mechanism is used to allow a fast reconstruction of timestamps for other parts of the computation when needed. <p> During the execution, four additional processes are created and a number of processes within the Hermes runtime system are used. The execution creates an event file containing 1874 primitive events from a total of 126 processes. (The first 120 processes form the standard Hermes runtime system.) Hermes debugger <ref> [32] </ref>. The display is similar to a standard process-time diagram with slightly more 3 information about an execution, such as event types (indicated by the symbol used to draw a primitive event) and an approximation of the process states (indicated by the line style).
Reference: 33. <author> D. Zernik, M. Snir, and D. Malki. </author> <title> Using visualization tools to understand concurrency. </title> <journal> IEEE Software, </journal> <volume> 9(3) </volume> <pages> 87-92, </pages> <month> May </month> <year> 1992. </year> <month> 33 </month>
Reference-contexts: So far, we have only mentioned work that explicitly addresses the question of causality among (relatively) general abstract events. Some papers describing event abstraction simply ignore the issue of causality [6, 7, 19]. Others limit their attention to abstract events with specific structural properties <ref> [8, 33] </ref>. While this allows them to prove certain desirable properties for their abstract events, it severely limits the modeling power. 5 Timestamping Abstract Events 5.1 Timestamps and Precedence Tests for Abstract Events This subsection discusses some basic issues with respect to timestamps and precedence tests for abstract events.
References-found: 33

