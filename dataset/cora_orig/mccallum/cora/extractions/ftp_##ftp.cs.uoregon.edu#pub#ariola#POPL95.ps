URL: ftp://ftp.cs.uoregon.edu/pub/ariola/POPL95.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: A Call-By-Need Lambda Calculus  
Author: Zena M. Ariola Matthias Felleisen John Maraist and Martin Odersky Philip Wadler 
Address: Houston, Texas  Karlsruhe, Germany  Glasgow, Scotland  
Affiliation: Computer Information Science Department University of Oregon Eugene, Oregon  Department of Computer Science Rice University  Institut fur Programmstrukturen Universitat Karlsruhe  Department of Computing Science University of Glasgow  
Abstract: The mismatch between the operational semantics of the lambda calculus and the actual behavior of implementations is a major obstacle for compiler writers. They cannot explain the behavior of their evaluator in terms of source level syntax, and they cannot easily compare distinct implementations of different lazy strategies. In this paper we derive an equational characterization of call-by-need and prove it correct with respect to the original lambda calculus. The theory is a strictly smaller theory than the lambda calculus. Immediate applications of the theory concern the correctness proofs of a number of implementation strategies, e.g., the call-by-need continuation passing transformation and the realization of sharing via assignments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1), </volume> <year> 1991. </year>
Reference-contexts: with respect to sharing in the evaluators 2 . 1 In this paper we write "call-by-need" rather than "lazy" to avoid a name clash with the work of Abramsky [2], which describes call-by-name reduction to values. 2 Ironically, this problem immediately showed up in the dif A number of researchers <ref> [1, 13, 20, 31, 28] </ref> have stud-ied reductions that preserve sharing in calculi with explicit substitutions, especially in relation to optimal reduction strategies. Having different aims, the resulting calculi are considerably more complex than those presented here. <p> The let-I axiom models the creation of such a let binding by 4 The idea of keeping pairs of procedures and their arguments in the syntax of the language is due to work on explicit substitutions <ref> [1] </ref>, on graph rewriting [3, 5], and on adding state to the -calculus [10, 12, 21, 22].
Reference: [2] <author> S. Abramsky. </author> <title> The lazy lambda calculus. </title> <editor> In D. Turner, editor, </editor> <booktitle> Declarative Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: given slightly different specifications based on "natural" or similar semantic frameworks, it is difficult, if not impossible, to compare the intentions with respect to sharing in the evaluators 2 . 1 In this paper we write "call-by-need" rather than "lazy" to avoid a name clash with the work of Abramsky <ref> [2] </ref>, which describes call-by-name reduction to values. 2 Ironically, this problem immediately showed up in the dif A number of researchers [1, 13, 20, 31, 28] have stud-ied reductions that preserve sharing in calculi with explicit substitutions, especially in relation to optimal reduction strategies. <p> In this section we consider two such extensions, for constructors and for recursion. 7 For instance, Abramsky and Ong's model of the lazy lambda calculus <ref> [2] </ref> is adequate for ` . 7.1 Constructors and Primitive Operators value: k n V 1 ::: V n where the components V 1 through V n must be values | otherwise sharing would be lost when copying the compound value [14].
Reference: [3] <author> Z. M. Ariola and Arvind. </author> <title> Properties of a first-order functional language with sharing. </title> <booktitle> Theoretical Computer Science, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: The let-I axiom models the creation of such a let binding by 4 The idea of keeping pairs of procedures and their arguments in the syntax of the language is due to work on explicit substitutions [1], on graph rewriting <ref> [3, 5] </ref>, and on adding state to the -calculus [10, 12, 21, 22]. <p> Intuitively, M N if M can be obtained by unwinding N , that is, N contains more sharing than M <ref> [3] </ref>. In other words, the ordering relation expresses whether the terms have homomorphic graphs. For example, the tree of M (x:x)(x:x) can be homomor-phically embedded into the graph of N let y = x:x in yy, which shows that M N .
Reference: [4] <author> Z. M. Ariola and M. Felleisen. </author> <title> The call-by-need lambda calculus. </title> <type> Technical Report CIS-TR-94-23, </type> <institution> Department of computer science, University of Oregon, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: While many of our results are indeed quite similar, there are interesting and significant differences in overall perspectives, in specific definitions of calculi and in proof techniques. We do not describe these differences here, and instead refer the interested reader to the full technical reports of Ariola and Felleisen <ref> [4] </ref> and of Maraist, Odersky and Wadler [19] for details. and transitive closure of fi interpreted as an asymmetric relation: fi = f (x:M )N; M [x := N ] j M; M 2 flg: The compatible closure of fi is written as ! name ; the reflexive and transitive closure
Reference: [5] <author> Z. M. Ariola and J. W. Klop. </author> <title> Cyclic lambda graph rewriting. </title> <booktitle> In Proc. of the Eighth IEEE Symposium on Logic in Computer Science, </booktitle> <address> Paris, </address> <year> 1994. </year>
Reference-contexts: The let-I axiom models the creation of such a let binding by 4 The idea of keeping pairs of procedures and their arguments in the syntax of the language is due to work on explicit substitutions [1], on graph rewriting <ref> [3, 5] </ref>, and on adding state to the -calculus [10, 12, 21, 22]. <p> Unlike the calculus let of Section 3, we now have a restricted notion of substitution. In other words, substitutions only occur when a variable appears in the hole of an evaluation context. Otherwise, an unrestricted notion of substitution in the presence of cycles would cause interesting non-confluence phenomena <ref> [5] </ref>. hi M + hi V Abs App h; x 0 7! M i [x 0 =x]N + hi V This extended call-by-need calculus corresponds to Ariola and Klop's call-by-name calculus with cycles [5], in the same way that our call-by-need calculus corresponds to the call-by-name calculus. <p> Otherwise, an unrestricted notion of substitution in the presence of cycles would cause interesting non-confluence phenomena <ref> [5] </ref>. hi M + hi V Abs App h; x 0 7! M i [x 0 =x]N + hi V This extended call-by-need calculus corresponds to Ariola and Klop's call-by-name calculus with cycles [5], in the same way that our call-by-need calculus corresponds to the call-by-name calculus.
Reference: [6] <author> Z. M. Ariola and J. W. Klop. </author> <title> Equational term graph rewriting. </title> <journal> Acta Informatica, </journal> <year> 1994. </year>
Reference-contexts: We solve this problem by enriching dags with boxes and labeled edges <ref> [6] </ref>. Dag 2 (M ) is the decorated dag associated with an expression M . A box can be thought of as a refined version of a node; the label associated with an edge is just a sequence of let-bound variable names.
Reference: [7] <author> Arvind, V. Kathail, and K. Pingali. </author> <title> Sharing of computation in functional language implementations. </title> <booktitle> In Proc. International Workshop on High-Level Computer Architecture, </booktitle> <year> 1984. </year>
Reference-contexts: A simple observation justifies call-by-need: the result of reducing an expression, if any, is indistinguishable from the expression itself in all possible contexts. Some implementations attempt to exploit this observation for sharing even more computations than just those of arguments. Arvind et. al. <ref> [7] </ref> provide an overview of such implementations, particularly the so-called "fully lazy" or "graph-based" techniques. Unfortunately, the mismatch between the operational semantics of the lambda calculus and the actual behavior of the implementation is a major obstacle for compiler writers and users. <p> Put differently, our calculus captures neither full laziness as described by Wadsworth [30], nor the sharing required by optimal -calculus interpreters [13, 15, 16, 17, 20]. However, as observed by Arvind, Kathail and Pingali <ref> [7] </ref>, full laziness can always be obtained by extracting the maximal free expressions of a function at compile-time [25]. 6 Although we rejected the liberalized let-V rule which produced this particular expression, it is perfectly reasonable to expect similar terms to appear.
Reference: [8] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: sections briefly discuss extensions of the language (with constants and recursive declarations), the relation of our work with natural semantics-based approaches, and applications of the calculus. 2 The Call-by-Name calculus In this section we briefly review the call-by-name calculus; we assume a basic familiarity of the reader with this material <ref> [8] </ref>. of lambda terms, called fl, is generated over an infinite set of variables. The expression M [x := N ] denotes the capture-free substitution of N for each free occurrence of x in M . <p> Theorem 4.1 let is confluent: M 9N @ @R let R R Proof: The system consisting of just let-I is triv-ially confluent; then by marked and weighted redexes as in Barendregt <ref> [8] </ref> the remaining reductions let-V, let-C and let-A are both weakly Church-Rosser and strongly normalizing, and thus Church-Rosser as well. <p> Since both subsystems commute, the theorem follows from the Lemma of Hindley and Rosen <ref> [8, Proposition 3.3.5] </ref>. 2 This result does not imply that all reduction sequences lead to an answer in let . We therefore introduce the notion of standard reduction, which always reaches an answer if there is one. Figure 3 details our notion of standard reduction. <p> The proof is somewhat reminiscent of Barendregt's standardization proof for the call-by-name calculus, but without the convenience of a finiteness of developments theorem for all redex types <ref> [8, Lemma 11.4.3] </ref>. 2 5 Completeness of the Call-by-Need calcu lus Replacing the call-by-name interpreter with the call-by-need interpreter requires an equivalence proof for the two evaluators: eval need = eval name : In this section, we will show the completeness direction, that is, each result obtained with the call-by-name interpreter <p> By the induction hypothesis, 9N 1 2 fl let ; M 00 2 fl, N 7! need ! (n1) N 1 ; M 0 ! name !M 00 and M 00 N 1 : From the Strip Lemma <ref> [8] </ref> 9M 2 , M 00 7! name 0=1 M 2 and M 1 ! name !M 2 : If M 2 M 00 then we have: N 7! need ! (n1) N 1 and M 0 ! name !M 00 where M 00 N 1 .
Reference: [9] <author> E. Crank. </author> <title> Parameter-passing and the lambda calculus. </title> <type> Master's thesis, </type> <institution> Rice University, </institution> <year> 1990. </year>
Reference-contexts: Their primary purpose is as a reasoning tool for the implementation of lazy languages. We sketch three ideas. Call-by-need and assignment Call-by-need can be implemented using assignments. Crank <ref> [9, 10] </ref> briefly discusses a rewriting semantics of call-by-need based on Felleisen and Hieb's -calculus with assignments [12]. We believe that a call-by-need calculus is the correct basis for proving this implementation technique correct with a simple simulation theorem for the respective standard reductions.
Reference: [10] <author> E. Crank and M. Felleisen. </author> <title> Parameter-passing and the lambda calculus. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: The let-I axiom models the creation of such a let binding by 4 The idea of keeping pairs of procedures and their arguments in the syntax of the language is due to work on explicit substitutions [1], on graph rewriting [3, 5], and on adding state to the -calculus <ref> [10, 12, 21, 22] </ref>. Only the latter two though exploited the idea of modeling the sharing relation of the program heap inside of the source language. representing the reference with a let-bound name, e.g., (x:xx)(II) = let x = II where I z:z. <p> Their primary purpose is as a reasoning tool for the implementation of lazy languages. We sketch three ideas. Call-by-need and assignment Call-by-need can be implemented using assignments. Crank <ref> [9, 10] </ref> briefly discusses a rewriting semantics of call-by-need based on Felleisen and Hieb's -calculus with assignments [12]. We believe that a call-by-need calculus is the correct basis for proving this implementation technique correct with a simple simulation theorem for the respective standard reductions. <p> Garbage collection Modeling the sharing relationship of an evaluator's memory in the source syntax suggests that the calcu lus can also model garbage collection. Indeed, garbage collection can be easily expressed in our call-by-need calculus by adapting the garbage collection rule for reference cells of Felleisen and Hieb <ref> [10, 12] </ref>: let x = M in N = N if x 6 2 F V (N ) We expect that the work on garbage collection in functional languages by Morrisett et. al. [23] will apply to call-by-need languages.
Reference: [11] <author> M. Felleisen and D. P. Friedman. </author> <title> Control operators, the SECD-machine, and the lambda-calculus. </title> <booktitle> In 3rd Working Conference on the Formal Description of Programming Concepts, </booktitle> <address> Ebberup, Den-mark, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: Put differently, a correct implementation of the evaluator can simply reduce the standard or leftmost-outermost redex of a program until the program becomes a value. Evaluation contexts are a convenient way of formulating the evaluation relation <ref> [11] </ref>. A program M standard reduces to N , written as M 7! name N , iff M E n [(x:P )Q] and N E n [P [x := Q]]. <p> As usual, we will omit the tags from the arrows when the meaning is clear from the context. Verifying that the standard relation, 7!, is indeed a function from programs to programs relies on the usual Unique Evaluation Context Lemma <ref> [11] </ref>. This lemma states that there is a unique partitioning of a non-answer into an evaluation context and a redex, which implies that there is precisely one way to make progress in the evaluation.
Reference: [12] <author> M. Felleisen and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 102, </volume> <year> 1992. </year>
Reference-contexts: The let-I axiom models the creation of such a let binding by 4 The idea of keeping pairs of procedures and their arguments in the syntax of the language is due to work on explicit substitutions [1], on graph rewriting [3, 5], and on adding state to the -calculus <ref> [10, 12, 21, 22] </ref>. Only the latter two though exploited the idea of modeling the sharing relation of the program heap inside of the source language. representing the reference with a let-bound name, e.g., (x:xx)(II) = let x = II where I z:z. <p> Their primary purpose is as a reasoning tool for the implementation of lazy languages. We sketch three ideas. Call-by-need and assignment Call-by-need can be implemented using assignments. Crank [9, 10] briefly discusses a rewriting semantics of call-by-need based on Felleisen and Hieb's -calculus with assignments <ref> [12] </ref>. We believe that a call-by-need calculus is the correct basis for proving this implementation technique correct with a simple simulation theorem for the respective standard reductions. Call-by-need and cps conversion Okasaki et. al. [24] recently suggested a continuation-passing transformation for call-by-need languages. <p> Garbage collection Modeling the sharing relationship of an evaluator's memory in the source syntax suggests that the calcu lus can also model garbage collection. Indeed, garbage collection can be easily expressed in our call-by-need calculus by adapting the garbage collection rule for reference cells of Felleisen and Hieb <ref> [10, 12] </ref>: let x = M in N = N if x 6 2 F V (N ) We expect that the work on garbage collection in functional languages by Morrisett et. al. [23] will apply to call-by-need languages.
Reference: [13] <author> J. </author> <title> Field. On laziness and optimality in lambda interpreters: Tools for specification and analysis. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <year> 1990. </year>
Reference-contexts: with respect to sharing in the evaluators 2 . 1 In this paper we write "call-by-need" rather than "lazy" to avoid a name clash with the work of Abramsky [2], which describes call-by-name reduction to values. 2 Ironically, this problem immediately showed up in the dif A number of researchers <ref> [1, 13, 20, 31, 28] </ref> have stud-ied reductions that preserve sharing in calculi with explicit substitutions, especially in relation to optimal reduction strategies. Having different aims, the resulting calculi are considerably more complex than those presented here. <p> In the program (f:fI (f I))(w:(II)w) ; the redex II in the argument will be reduced twice. Put differently, our calculus captures neither full laziness as described by Wadsworth [30], nor the sharing required by optimal -calculus interpreters <ref> [13, 15, 16, 17, 20] </ref>.
Reference: [14] <author> D. P. Friedman and D. S. Wise. </author> <title> Cons should not evaluate its arguments. </title> <booktitle> In Proc. International Conference on Automata, Languages and Programming, </booktitle> <year> 1976. </year>
Reference-contexts: Abramsky and Ong's model of the lazy lambda calculus [2] is adequate for ` . 7.1 Constructors and Primitive Operators value: k n V 1 ::: V n where the components V 1 through V n must be values | otherwise sharing would be lost when copying the compound value <ref> [14] </ref>. For instance, inl (1 + 1) is not a legal value, since copying it would also copy the unevaluated term (1 + 1). Instead, one writes let x = 1 + 1 in inl x : There are two new reduction rules.
Reference: [15] <author> G. Gonthier, M. Abadi, and J.-J Levy. </author> <title> The geometry of optimal lambda reduction. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: In the program (f:fI (f I))(w:(II)w) ; the redex II in the argument will be reduced twice. Put differently, our calculus captures neither full laziness as described by Wadsworth [30], nor the sharing required by optimal -calculus interpreters <ref> [13, 15, 16, 17, 20] </ref>.
Reference: [16] <author> V. K. Kathail. </author> <title> Optimal Interpreters for Lambda-calculus Based Funtional Languages. </title> <type> PhD thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, </institution> <year> 1990. </year>
Reference-contexts: In the program (f:fI (f I))(w:(II)w) ; the redex II in the argument will be reduced twice. Put differently, our calculus captures neither full laziness as described by Wadsworth [30], nor the sharing required by optimal -calculus interpreters <ref> [13, 15, 16, 17, 20] </ref>.
Reference: [17] <author> J. Lamping. </author> <title> An algorithm for optimal lambda calculus reduction. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Fran-cisco, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: In the program (f:fI (f I))(w:(II)w) ; the redex II in the argument will be reduced twice. Put differently, our calculus captures neither full laziness as described by Wadsworth [30], nor the sharing required by optimal -calculus interpreters <ref> [13, 15, 16, 17, 20] </ref>.
Reference: [18] <author> J. Launchbury. </author> <title> A natural semantics for lazy evaluation. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Specifically, they cannot use the calculus to reason about sharing in the evaluation of a program. Purushothaman and Seaman [27, 29] and Launch-bury <ref> [18] </ref> recently recognized this problem and developed two slightly different "natural" semantics of the call-by-need parameter passing mechanism. Roughly speaking, the semantics use store-passing to describe call-by-need in terms of (the semantics of) assignment statements. <p> of the calculus with recursion can be obtained by showing its soundness and completeness with respect to a calculus of infinitary graphs. 8 Relation to Natural Semantics This section presents an operational semantics for call-by-need in the natural semantics style of Plotkin and Kahn, similar to one given by Launchbury <ref> [18] </ref>. We state a proposition that relates the natural semantics to standard reduction. A heap abstracts the state of the store at a point in the computation. <p> Then a simple induction on +-derivations yields the following result. Proposition 8.2 hi M + hi V iff ` ` let in M 7! need ! let in V : The semantics given here is similar to that presented by Launchbury <ref> [18] </ref>. An advantage of our semantics over Launchbury's is that the form of terms is standard, and care is taken to preserve ordering in the heap.
Reference: [19] <author> J. Maraist, M. Odersky, and P. Wadler. </author> <title> The call-by-need lambda calculus (unabridged). </title> <type> Technical Report 28/94, </type> <institution> Universitat Karlsruhe, Fakultat fur Informatik, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: We do not describe these differences here, and instead refer the interested reader to the full technical reports of Ariola and Felleisen [4] and of Maraist, Odersky and Wadler <ref> [19] </ref> for details. and transitive closure of fi interpreted as an asymmetric relation: fi = f (x:M )N; M [x := N ] j M; M 2 flg: The compatible closure of fi is written as ! name ; the reflexive and transitive closure of ! name , as ! name
Reference: [20] <author> L. Maranget. </author> <title> Optimal derivations in weak lambda-calculi and in orthogonal term rewriting systems. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: with respect to sharing in the evaluators 2 . 1 In this paper we write "call-by-need" rather than "lazy" to avoid a name clash with the work of Abramsky [2], which describes call-by-name reduction to values. 2 Ironically, this problem immediately showed up in the dif A number of researchers <ref> [1, 13, 20, 31, 28] </ref> have stud-ied reductions that preserve sharing in calculi with explicit substitutions, especially in relation to optimal reduction strategies. Having different aims, the resulting calculi are considerably more complex than those presented here. <p> In the program (f:fI (f I))(w:(II)w) ; the redex II in the argument will be reduced twice. Put differently, our calculus captures neither full laziness as described by Wadsworth [30], nor the sharing required by optimal -calculus interpreters <ref> [13, 15, 16, 17, 20] </ref>.
Reference: [21] <author> I. A. Mason and C. Talcott. </author> <title> Reasoning about programs with effects. </title> <booktitle> In Proc. of Programming Language Implementation and Logic Programming, </booktitle> <publisher> Springer-Verlag LNCS 456, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: The let-I axiom models the creation of such a let binding by 4 The idea of keeping pairs of procedures and their arguments in the syntax of the language is due to work on explicit substitutions [1], on graph rewriting [3, 5], and on adding state to the -calculus <ref> [10, 12, 21, 22] </ref>. Only the latter two though exploited the idea of modeling the sharing relation of the program heap inside of the source language. representing the reference with a let-bound name, e.g., (x:xx)(II) = let x = II where I z:z.
Reference: [22] <author> I. A. Mason and C. L. Talcott. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(2), </volume> <year> 1991. </year>
Reference-contexts: The let-I axiom models the creation of such a let binding by 4 The idea of keeping pairs of procedures and their arguments in the syntax of the language is due to work on explicit substitutions [1], on graph rewriting [3, 5], and on adding state to the -calculus <ref> [10, 12, 21, 22] </ref>. Only the latter two though exploited the idea of modeling the sharing relation of the program heap inside of the source language. representing the reference with a let-bound name, e.g., (x:xx)(II) = let x = II where I z:z.
Reference: [23] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Modeling memory management. </title> <type> Technical report, </type> <institution> De-partement of computer science, Carnegie Mellon University, </institution> <month> forthcoming </month> <year> 1994. </year>
Reference-contexts: in our call-by-need calculus by adapting the garbage collection rule for reference cells of Felleisen and Hieb [10, 12]: let x = M in N = N if x 6 2 F V (N ) We expect that the work on garbage collection in functional languages by Morrisett et. al. <ref> [23] </ref> will apply to call-by-need languages.
Reference: [24] <author> C. Okasaki, P. Lee, and T. Tarditi. </author> <title> Call-by-need and continuation-passing style. </title> <booktitle> In Lisp and Symbolic Computation, </booktitle> <year> 1994. </year>
Reference-contexts: We believe that a call-by-need calculus is the correct basis for proving this implementation technique correct with a simple simulation theorem for the respective standard reductions. Call-by-need and cps conversion Okasaki et. al. <ref> [24] </ref> recently suggested a continuation-passing transformation for call-by-need languages. In principle, this transformation should satisfy the same theorems as the continuation-passing transformation for call-by-name and call-by-value calculi [26]. Plotkin's proof techniques should immediately apply.
Reference: [25] <author> S. L. Peyton Jones. </author> <title> A fully-lazy lambda lifter in haskell. </title> <journal> Software Practice and Experience, </journal> <volume> 21, </volume> <year> 1991. </year>
Reference-contexts: However, as observed by Arvind, Kathail and Pingali [7], full laziness can always be obtained by extracting the maximal free expressions of a function at compile-time <ref> [25] </ref>. 6 Although we rejected the liberalized let-V rule which produced this particular expression, it is perfectly reasonable to expect similar terms to appear. In fact, any left-nesting of two applications (LM)N could produce such a term! this manipulation is generalized by the let-C axiom.
Reference: [26] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1, </volume> <year> 1975. </year>
Reference-contexts: The fi-axiom gives rise to an equational theory, the -calculus, which implementors can use to reason about the outcome of programs <ref> [26] </ref>. Taken literally, the fi-axiom suggests that a procedure must evaluate the argument of a specific call for each occurrence of the corresponding formal parameter. Realistic implementations of lazy functional languages avoid such computational overhead by memoizing the argument's value when it is first evaluated. <p> It is a seminal result due to Plotkin that the evaluation function of a typical implementation is also determined by the standard reduction relation <ref> [26] </ref>. Put differently, a correct implementation of the evaluator can simply reduce the standard or leftmost-outermost redex of a program until the program becomes a value. Evaluation contexts are a convenient way of formulating the evaluation relation [11]. <p> The following characterization of the call-by-name evaluator is a consequence of the confluence property and the standardization theorem of . Proposition 2.1 For a program M , eval name (M ) = closure iff M 7!! x:N : This result is due to Plotkin <ref> [26] </ref>. <p> Call-by-need and cps conversion Okasaki et. al. [24] recently suggested a continuation-passing transformation for call-by-need languages. In principle, this transformation should satisfy the same theorems as the continuation-passing transformation for call-by-name and call-by-value calculi <ref> [26] </ref>. Plotkin's proof techniques should immediately apply. Since this transformation appears to be used in several implementations of lazy languages, it is important to explore its properties with standard tools.
Reference: [27] <author> Purushothaman and J. Seaman. </author> <title> An adequate operational semantics of sharing in lazy evaluation. </title> <booktitle> In Proc. 4th European Symposium on Programming, </booktitle> <publisher> Springer Verlag LNCS 582, </publisher> <year> 1992. </year>
Reference-contexts: Unfortunately, the mismatch between the operational semantics of the lambda calculus and the actual behavior of the implementation is a major obstacle for compiler writers and users. Specifically, they cannot use the calculus to reason about sharing in the evaluation of a program. Purushothaman and Seaman <ref> [27, 29] </ref> and Launch-bury [18] recently recognized this problem and developed two slightly different "natural" semantics of the call-by-need parameter passing mechanism. Roughly speaking, the semantics use store-passing to describe call-by-need in terms of (the semantics of) assignment statements.
Reference: [28] <author> K. H. Rose. </author> <title> Explicit cyclic substitutions. </title> <booktitle> In 3rd International Workshop on Conditional Term Rewriting Systems, </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: with respect to sharing in the evaluators 2 . 1 In this paper we write "call-by-need" rather than "lazy" to avoid a name clash with the work of Abramsky [2], which describes call-by-name reduction to values. 2 Ironically, this problem immediately showed up in the dif A number of researchers <ref> [1, 13, 20, 31, 28] </ref> have stud-ied reductions that preserve sharing in calculi with explicit substitutions, especially in relation to optimal reduction strategies. Having different aims, the resulting calculi are considerably more complex than those presented here.
Reference: [29] <author> J. M. Seaman. </author> <title> An Operational Semantics of Lazy Evaluation for Analysis. </title> <type> PhD thesis, </type> <institution> The Pennsyl-vania State University, </institution> <year> 1993. </year>
Reference-contexts: Unfortunately, the mismatch between the operational semantics of the lambda calculus and the actual behavior of the implementation is a major obstacle for compiler writers and users. Specifically, they cannot use the calculus to reason about sharing in the evaluation of a program. Purushothaman and Seaman <ref> [27, 29] </ref> and Launch-bury [18] recently recognized this problem and developed two slightly different "natural" semantics of the call-by-need parameter passing mechanism. Roughly speaking, the semantics use store-passing to describe call-by-need in terms of (the semantics of) assignment statements.
Reference: [30] <author> C. Wadsworth. </author> <title> Semantics And Pragmatics Of The Lambda-Calculus. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <month> September </month> <year> 1971. </year>
Reference-contexts: As Wadsworth pointed out, one way to avoid duplicating reductions is by replacing the abstracted variables in function bodies with references to arguments, rather than with the arguments themselves <ref> [30] </ref>. <p> In the program (f:fI (f I))(w:(II)w) ; the redex II in the argument will be reduced twice. Put differently, our calculus captures neither full laziness as described by Wadsworth <ref> [30] </ref>, nor the sharing required by optimal -calculus interpreters [13, 15, 16, 17, 20].
Reference: [31] <author> N. Yoshida. </author> <title> Optimal reduction in weak--calculus with shared environments. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copenhagen, </address> <year> 1993. </year>
Reference-contexts: with respect to sharing in the evaluators 2 . 1 In this paper we write "call-by-need" rather than "lazy" to avoid a name clash with the work of Abramsky [2], which describes call-by-name reduction to values. 2 Ironically, this problem immediately showed up in the dif A number of researchers <ref> [1, 13, 20, 31, 28] </ref> have stud-ied reductions that preserve sharing in calculi with explicit substitutions, especially in relation to optimal reduction strategies. Having different aims, the resulting calculi are considerably more complex than those presented here. <p> Having different aims, the resulting calculi are considerably more complex than those presented here. Closest to our treatment is Yoshida's weak lambda calculus <ref> [31] </ref> which introduces explicit environments similar to let constructs. Her calculus subsumes several of our reduction rules as structural equivalences, even though, due to a different notion of observation, reduction in this calculus is not equivalent to reduction to a value.
References-found: 31

