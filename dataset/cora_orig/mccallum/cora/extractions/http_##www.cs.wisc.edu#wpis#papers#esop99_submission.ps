URL: http://www.cs.wisc.edu/wpis/papers/esop99_submission.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: http://www.cs.wisc.edu
Title: A Decidable Logic for Describing Linked Data Structures  
Author: Michael Benedikt Thomas Reps Mooly Sagiv 
Keyword: General Terms: Algorithms, Languages, Theory Additional Key Words: Alias information, decidable logic, destructive updating, path matrix, pointer aliasing, program invariant, shape descriptor, static shape graph  
Abstract: This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs), as well as the intermediate states that arise when such structures are destructively updated. The paper defines a new logic that is suitable for these purposes (called L r , for "logic of reachability expressions"). We show that L r is decidable, and explain how L r relates to two previously defined structure-description formalisms ("path matrices" and "static shape graphs") by showing how an arbitrary shape descriptor from each of these formalisms can be translated into an L r formula. Categories and Subject Descriptors: D.3.3 [Programming Languages]: Language Constructs and Features|data types and structures; dynamic storage management; E.1 [Data]: Data Structures| graphs; lists; trees; E.2 [Data]: Data Storage Representations|composite structures; linked representations; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs|assertions; invariants; pre- and post-conditions; specification languages; F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs|type structure; F.4.1 [Mathematical Logic and Formal Languages]: Formal Languages|decision problems 
Abstract-found: 1
Intro-found: 1
Reference: [AW93] <author> U. Assmann and M. Weinhardt. </author> <title> Interprocedural heap analysis for parallelizing imperative programs. </title> <editor> In W. K. Giloi, S. Jahnichen, and B. D. Shriver, editors, </editor> <booktitle> Programming Models For Massively Parallel Computers, </booktitle> <pages> pages 74-82, </pages> <address> Washington, DC, </address> <month> September </month> <year> 1993. </year> <note> IEEE Press. </note>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97].
Reference: [BGG96] <author> E. Boerger, E. Graedel, and Y. Gurevich. </author> <title> The Classical Decision Problem. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This technique is one of the most common in logical decision procedures <ref> [BGG96] </ref>. <p> We then make use of classical decidability results on reachability expressions on finite trees ([TW68], summarized also in <ref> [BGG96] </ref>) to shrink each of these trees to smaller trees that satisfy the same properties as the union of trees produced in stage one.
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <address> New York, NY, 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97]. <p> more cdr fields never leads to a cell that is "heap shared". (A cell c is "heap shared" if two or more cells have fields that point to c, or if there is a cell c 0 such that c 0 :car and c 0 :cdr both point to c <ref> [JM82, CWZ90, SRW98b, SRW98a] </ref>.) Thus, a loop invariant for program elem reverse can be written as follows: ((al (y:cdr) _ al (z)) =) y:cdr = z) ^ acyclic list (x) ^ acyclic list (y) ^ :xhcdr fl iy ^ :xhcdr fl iz ^ :yhcdr fl ix ^ :zhcdr fl ix (1)
Reference: [Deu92] <author> A. Deutsch. </author> <title> A storeless model for aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In IEEE International Conference on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <address> Washington, DC, 1992. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: = yhR 2 i: We believe that L r can be generalized to handle this. (A limited form of such connectivity properties, restricted to be in the form xh (carjcdr) fl i = yh (carjcdr) fl i; was proposed in [GH95, GH98].) L r is incomparable to Deutsch's symbolic aliases <ref> [Deu92, Deu94] </ref>: * Symbolic aliases allow the use of full-blown arithmetic, which cannot be used in a decidable logic. * On the other hand, symbolic-alias expressions are not closed under negation. For instance, there is no way to express must-alias relationships using symbolic aliases.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <address> New York, NY, 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: = yhR 2 i: We believe that L r can be generalized to handle this. (A limited form of such connectivity properties, restricted to be in the form xh (carjcdr) fl i = yh (carjcdr) fl i; was proposed in [GH95, GH98].) L r is incomparable to Deutsch's symbolic aliases <ref> [Deu92, Deu94] </ref>: * Symbolic aliases allow the use of full-blown arithmetic, which cannot be used in a decidable logic. * On the other hand, symbolic-alias expressions are not closed under negation. For instance, there is no way to express must-alias relationships using symbolic aliases.
Reference: [FM97] <author> Pascal Fradet and Daniel Le Metayer. </author> <title> Shape types. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> New York, NY, 1997. </address> <publisher> ACM Press. </publisher>
Reference-contexts: a variety of different formalisms have been developed | including "static shape graphs" [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a], "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars <ref> [FM97] </ref> and monadic second-order logic [JJNS97]. For lack of a better term, we will use the phrase structure-description formalisms to refer to such formalisms in a generic sense. <p> For instance, there is no way to express must-alias relationships using symbolic aliases. Thus, the loop invariant used in 2.3 cannot be expressed with symbolic aliases. In <ref> [FM97] </ref>, Fradet and Le Metayer use graph grammars to express interesting properties of the data structures of a C-like language. Graph grammars can be a more natural formalism than logic for describing certain topological properties of stores. <p> Graph grammars can be a more natural formalism than logic for describing certain topological properties of stores. However, graph grammars are not closed under intersection and negation, and problems such as the inclusion problem are not decidable. In terms of expressive power, the structure-description formalism of <ref> [FM97] </ref> is incomparable to the one proposed in the present paper. The logic L r is built on ideas from modal and temporal logic, and from automata-theoretic formalisms that are closely related to these (e.g., tree grammars).
Reference: [GH95] <author> R. Ghiya and L.J. Hendren. </author> <title> Connection analysis: A practical interprocedural heap analysis for C. </title> <booktitle> In Proc. of the 8th Intl. Work. on Languages and Compilers for Parallel Computing, number 1033 in Lecture Notes in Computer Science, </booktitle> <pages> pages 515-534, </pages> <address> Columbus, Ohio, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: allow stating connectivity properties of the form xhR 1 i = yhR 2 i: We believe that L r can be generalized to handle this. (A limited form of such connectivity properties, restricted to be in the form xh (carjcdr) fl i = yh (carjcdr) fl i; was proposed in <ref> [GH95, GH98] </ref>.) L r is incomparable to Deutsch's symbolic aliases [Deu92, Deu94]: * Symbolic aliases allow the use of full-blown arithmetic, which cannot be used in a decidable logic. * On the other hand, symbolic-alias expressions are not closed under negation.
Reference: [GH98] <author> R. Ghiya and L. Hendren. </author> <title> Putting pointer analysis to work. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> New York, NY, 1998. </address> <publisher> ACM Press. </publisher>
Reference-contexts: allow stating connectivity properties of the form xhR 1 i = yhR 2 i: We believe that L r can be generalized to handle this. (A limited form of such connectivity properties, restricted to be in the form xh (carjcdr) fl i = yh (carjcdr) fl i; was proposed in <ref> [GH95, GH98] </ref>.) L r is incomparable to Deutsch's symbolic aliases [Deu92, Deu94]: * Symbolic aliases allow the use of full-blown arithmetic, which cannot be used in a decidable logic. * On the other hand, symbolic-alias expressions are not closed under negation.
Reference: [Hen90] <author> L. Hendren. </author> <title> Parallelizing Programs with Recursive Data Structures. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <address> Ithaca, N.Y., </address> <month> Jan </month> <year> 1990. </year>
Reference-contexts: In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a], "path matrices" <ref> [Hen90, HN90] </ref>, "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97]. <p> We show that L r is decidable. We also show in detail how L r relates to two of the previously defined structure-description formalisms: In Section 3, we show how a generalization of Hendren's path-matrix descriptors <ref> [Hen90, HN90] </ref> can be represented by L r formulae; in Section 4, we show how the variant of static shape graphs defined in [SRW98b] can be represented by L r formulae. In this way, L r provides insight into the expressive power of path matrices and static shape graphs. <p> The remainder of the paper is organized into six sections: Section 2 presents the logic we use for describing properties of linked data structures. Section 3 shows how a generalization of Hendren's path-matrix descriptors <ref> [Hen90, HN90] </ref> can be represented by L r formulae. Section 4 shows how a variant of static shape graphs can be represented by L r formulae. Section 5 discusses the issue of using L r formulae to extract information from the results of program analyses. <p> S is true [[ 1 =) 2 ]] S = [[: 1 ]] S is true or [[ 2 ]] S is true 2 3 Representing Path Matrices via Formulae In this section, we study the relationship between the logic L r and a variant of the path-matrix structure-description formalism <ref> [Hen90, HN90] </ref>. A path matrix records information about the (possibly empty) set of paths that exist between pairs of pointer variables in a program. The version of path matrices described below is a generalization of the original version described in [Hen90, HN90]. <p> L r and a variant of the path-matrix structure-description formalism <ref> [Hen90, HN90] </ref>. A path matrix records information about the (possibly empty) set of paths that exist between pairs of pointer variables in a program. The version of path matrices described below is a generalization of the original version described in [Hen90, HN90]. We show that every path matrix (of the extended version of the formalism) can be represented by a formula in logic L r . Definition 3.1 A path matrix pm contains an entry pm [x; y] for every pair of pointer-valued program variables, x and y. <p> Qi, where R is a regular expression over , and Q is either "P " (standing for "possible path") or "D" (standing for "definite" path). 2 The notions of "possible paths" and "definite paths" are somewhat subtle (and the names "possible paths" and "definite paths", which we have adopted from <ref> [Hen90, HN90] </ref>, are somewhat misleading). <p> The routing expressions that we allow in path matrices are more general than the ones allowed in <ref> [Hen90, HN90] </ref> in the following way: * We allow arbitrary alternations and not just carjcdr. * We follow [JJNS97] in allowing pointer-variable interrogations (e.g., prev, :prev) in routing expressions. <p> This comes in handy in cases where several paths depend on each other (cf. the pm [c; elem] entry in path matrix (7)). 7 r - r - r -x - r - Of course these limitations of <ref> [Hen90, HN90] </ref> are motivated by the need to be able to compute efficiently a safe approximation to the path matrix at every program point. 2 Since path matrices are an intuitive notation, we will not spend the space in directly formalizing the meaning of path matrices in terms of sets of <p> Hendren et al. propose to handle this limitation of ADDS by extending it with the ability to use a certain limited class of reachability properties between variables (of the kind used in the path matrices defined in <ref> [Hen90] </ref>). L r goes beyond ADDS in the following ways: * L r permits stating properties of cyclic data structures. * The routing expressions used in L r formulae are general regular expressions (with pointer-variable interrogations). * L r is closed under both conjunction and negation.
Reference: [HHN92] <author> L. Hendren, J. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and the transformation of imperative programs. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <address> New York, NY, June 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a], "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism <ref> [HHN92] </ref> | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97]. For lack of a better term, we will use the phrase structure-description formalisms to refer to such formalisms in a generic sense. <p> Our work has two advantages: The logic L r is quite expressive (e.g., strictly more expressive than the formalism used by Hendren et al. <ref> [HHN92] </ref>). The added expressibility is important for describing the intermediate states that arise when linked data structures are destructively updated. The logic L r is decidable, which means that there is an algorithm that determines, for every formula in the logic, if the formula is satisfiable. <p> pieces of code. (However, the latter property is a significant advantage for the intended application | a programming language supporting controlled destructive updating of graph data structures.) The ADDS formalism of Hendren et al. is an annotation language for expressing loop invariants and pre- and post-conditions of statements and procedures <ref> [HHN92] </ref>.
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year> <month> 16 </month>
Reference-contexts: In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a], "path matrices" <ref> [Hen90, HN90] </ref>, "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97]. <p> We show that L r is decidable. We also show in detail how L r relates to two of the previously defined structure-description formalisms: In Section 3, we show how a generalization of Hendren's path-matrix descriptors <ref> [Hen90, HN90] </ref> can be represented by L r formulae; in Section 4, we show how the variant of static shape graphs defined in [SRW98b] can be represented by L r formulae. In this way, L r provides insight into the expressive power of path matrices and static shape graphs. <p> The remainder of the paper is organized into six sections: Section 2 presents the logic we use for describing properties of linked data structures. Section 3 shows how a generalization of Hendren's path-matrix descriptors <ref> [Hen90, HN90] </ref> can be represented by L r formulae. Section 4 shows how a variant of static shape graphs can be represented by L r formulae. Section 5 discusses the issue of using L r formulae to extract information from the results of program analyses. <p> S is true [[ 1 =) 2 ]] S = [[: 1 ]] S is true or [[ 2 ]] S is true 2 3 Representing Path Matrices via Formulae In this section, we study the relationship between the logic L r and a variant of the path-matrix structure-description formalism <ref> [Hen90, HN90] </ref>. A path matrix records information about the (possibly empty) set of paths that exist between pairs of pointer variables in a program. The version of path matrices described below is a generalization of the original version described in [Hen90, HN90]. <p> L r and a variant of the path-matrix structure-description formalism <ref> [Hen90, HN90] </ref>. A path matrix records information about the (possibly empty) set of paths that exist between pairs of pointer variables in a program. The version of path matrices described below is a generalization of the original version described in [Hen90, HN90]. We show that every path matrix (of the extended version of the formalism) can be represented by a formula in logic L r . Definition 3.1 A path matrix pm contains an entry pm [x; y] for every pair of pointer-valued program variables, x and y. <p> Qi, where R is a regular expression over , and Q is either "P " (standing for "possible path") or "D" (standing for "definite" path). 2 The notions of "possible paths" and "definite paths" are somewhat subtle (and the names "possible paths" and "definite paths", which we have adopted from <ref> [Hen90, HN90] </ref>, are somewhat misleading). <p> The routing expressions that we allow in path matrices are more general than the ones allowed in <ref> [Hen90, HN90] </ref> in the following way: * We allow arbitrary alternations and not just carjcdr. * We follow [JJNS97] in allowing pointer-variable interrogations (e.g., prev, :prev) in routing expressions. <p> This comes in handy in cases where several paths depend on each other (cf. the pm [c; elem] entry in path matrix (7)). 7 r - r - r -x - r - Of course these limitations of <ref> [Hen90, HN90] </ref> are motivated by the need to be able to compute efficiently a safe approximation to the path matrix at every program point. 2 Since path matrices are an intuitive notation, we will not spend the space in directly formalizing the meaning of path matrices in terms of sets of
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <address> New York, NY, 1989. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97].
Reference: [JJNS97] <author> J.L. Jensen, M.E. Joergensen, N.Klarlund, and M.I. Schwartzbach. </author> <title> Automatic verification of pointer programs using monadic second-order logic. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1997. </year>
Reference-contexts: have been developed | including "static shape graphs" [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a], "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic <ref> [JJNS97] </ref>. For lack of a better term, we will use the phrase structure-description formalisms to refer to such formalisms in a generic sense. <p> The routing expressions that we allow in path matrices are more general than the ones allowed in [Hen90, HN90] in the following way: * We allow arbitrary alternations and not just carjcdr. * We follow <ref> [JJNS97] </ref> in allowing pointer-variable interrogations (e.g., prev, :prev) in routing expressions. <p> In the final stage, the tree-like model is glued together to form a traditional store that satisfies . 7 Related Work Jensen et al. have also defined a decidable logic for describing properties of linked data structures <ref> [JJNS97] </ref>. It is interesting to compare the two approaches: * The logic of Jensen et al. allows quantifications on pointer expressions, which is forbidden in L r . Instead, L r allows stating both sharing constraints and allocation constraints. <p> From a programmer's point of view, an advantage of a logic like L r over ADDS is that L r is strong enough to allow stating properties of the kind that arise at intermediate points of a procedure, when a data structure is in the process of being traversed 1 <ref> [JJNS97] </ref> sketches an extension of their technique to trees, which involves multiple selectors, but they do not handle general directed graphs. 14 or destructively updated. For example, ADDS cannot be used to state the loop invariant of Example 2.2 because the relationship between x and y cannot be expressed.
Reference: [JM81] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97].
Reference: [JM82] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <address> New York, NY, 1982. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97]. <p> more cdr fields never leads to a cell that is "heap shared". (A cell c is "heap shared" if two or more cells have fields that point to c, or if there is a cell c 0 such that c 0 :car and c 0 :cdr both point to c <ref> [JM82, CWZ90, SRW98b, SRW98a] </ref>.) Thus, a loop invariant for program elem reverse can be written as follows: ((al (y:cdr) _ al (z)) =) y:cdr = z) ^ acyclic list (x) ^ acyclic list (y) ^ :xhcdr fl iy ^ :xhcdr fl iz ^ :yhcdr fl ix ^ :zhcdr fl ix (1)
Reference: [KS93] <author> N. Klarlund and M. Schwartzbach. </author> <title> Graph types. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> New York, NY, </address> <month> January </month> <year> 1993. </year> <note> ACM Press. </note>
Reference-contexts: In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a], "path matrices" [Hen90, HN90], "graph types" <ref> [KS93] </ref>, and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97]. For lack of a better term, we will use the phrase structure-description formalisms to refer to such formalisms in a generic sense. <p> Klarlund and Schwartzbach defined a language for defining graph types, which are tree data structures with non-tree links defined by auxiliary tree-path expressions <ref> [KS93] </ref>. In the application they envision, a programmer would be able to declare variables of a given graph type, and write code to mutate the "tree backbone" of these structures.
Reference: [LH88] <author> J.R. Larus and P.N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <address> New York, NY, 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97].
Reference: [LM96] <author> C.-K. Luk and T.C. Mowry. </author> <title> Compiler-based prefetching for recursive data structures. </title> <booktitle> In Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 222-233, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: This information can be used by an optimizing compiler to determine whether it is profitable to generate a pre-fetch for the next element <ref> [LM96] </ref>. * It is possible to express in L r that two pointer-access paths point to different memory cells (i.e., they are not may-aliases), which is important both for optimization and in tools for aiding software understanding. * The reachability and sharing predicates can also be useful, for example, to improve
Reference: [PCK93] <author> J. Plevyak, A.A. Chien, and V. Karamcheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, volume 768 of Lecture Notes in Computer Science, </booktitle> <pages> pages 37-57, </pages> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97].
Reference: [SRW98a] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Parametric shape analysis via 3-valued logic. </title> <type> Technical Report TR-1383, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> July </month> <year> 1998. </year> <note> Available at "http://www.cs.wisc.edu/wpis/papers/parametric.ps". </note>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97]. <p> For instance, with the three-valued logic used for shape analysis in <ref> [SRW98a] </ref>, a formula that queries for a specific piece of information sometimes evaluates to "unknown", even when, in all of the stores that the static shape graph represents, the formula evaluates to a definite true or false value. <p> more cdr fields never leads to a cell that is "heap shared". (A cell c is "heap shared" if two or more cells have fields that point to c, or if there is a cell c 0 such that c 0 :car and c 0 :cdr both point to c <ref> [JM82, CWZ90, SRW98b, SRW98a] </ref>.) Thus, a loop invariant for program elem reverse can be written as follows: ((al (y:cdr) _ al (z)) =) y:cdr = z) ^ acyclic list (x) ^ acyclic list (y) ^ :xhcdr fl iy ^ :xhcdr fl iz ^ :yhcdr fl ix ^ :zhcdr fl ix (1)
Reference: [SRW98b] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 20(1) </volume> <pages> 1-50, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97]. <p> show in detail how L r relates to two of the previously defined structure-description formalisms: In Section 3, we show how a generalization of Hendren's path-matrix descriptors [Hen90, HN90] can be represented by L r formulae; in Section 4, we show how the variant of static shape graphs defined in <ref> [SRW98b] </ref> can be represented by L r formulae. In this way, L r provides insight into the expressive power of path matrices and static shape graphs. The benefits of our work include the following: fl Address: Bell Laboratories; Lucent Technologies; 1000 E. Warrenville Road; P.O. <p> more cdr fields never leads to a cell that is "heap shared". (A cell c is "heap shared" if two or more cells have fields that point to c, or if there is a cell c 0 such that c 0 :car and c 0 :cdr both point to c <ref> [JM82, CWZ90, SRW98b, SRW98a] </ref>.) Thus, a loop invariant for program elem reverse can be written as follows: ((al (y:cdr) _ al (z)) =) y:cdr = z) ^ acyclic list (x) ^ acyclic list (y) ^ :xhcdr fl iy ^ :xhcdr fl iz ^ :yhcdr fl ix ^ :zhcdr fl ix (1) <p> There are many ways to define static shape graphs. For simplicity, we only consider the variant of static shape graphs defined in <ref> [SRW98b] </ref>. The remainder of this section is organized as follows. In Section 4.1, we give a formal definition of static shape graphs. <p> multiple selectors, which enables L r formulae to describe properties of general directed graphs as opposed to just lists. 1 The reachability constraints in L r formulae allow one to test simultaneous pointer inequities, which is crucial for capturing the strength of the variant of static shape graphs defined in <ref> [SRW98b] </ref>. In summary, the formulae of Jensen et al. are more expressive than L r formulae, but they can only state properties of lists and trees, whereas L r can state properties of arbitrary graph data structures.
Reference: [Str92] <author> J. Stransky. </author> <title> A lattice for abstract interpretation of dynamic (Lisp-like) structures. </title> <journal> Information and Computation, </journal> <volume> 101(1) </volume> <pages> 70-102, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97].
Reference: [Tar81a] <author> R.E. Tarjan. </author> <title> Fast algorithms for solving path problems. </title> <journal> J. ACM, </journal> <volume> 28(3) </volume> <pages> 594-614, </pages> <year> 1981. </year>
Reference-contexts: For any two nodes n X ; n Y 2 shapeNodes , let r n X :in!n Y :out be the regular path expression over that describes paths in d SG from n X :in into n Y :out (which can be computed by well-known methods, e.g., <ref> [Tar81b, Tar81a] </ref>).
Reference: [Tar81b] <author> R.E. Tarjan. </author> <title> A unified approach to path problems. </title> <journal> J. ACM, </journal> <volume> 28(3) </volume> <pages> 577-593, </pages> <year> 1981. </year>
Reference-contexts: For any two nodes n X ; n Y 2 shapeNodes , let r n X :in!n Y :out be the regular path expression over that describes paths in d SG from n X :in into n Y :out (which can be computed by well-known methods, e.g., <ref> [Tar81b, Tar81a] </ref>).
Reference: [TW68] <author> J.W. Thatcher and J.B. Wright. </author> <title> Generalized finite automata with an application to a decision problem of second order logic. </title> <journal> Math. Syst. Theory, </journal> <volume> 2 </volume> <pages> 57-82, </pages> <year> 1968. </year>
Reference: [Var97] <author> M. Vardi. </author> <title> Why is modal logic so robustly decidable? In N. </title> <editor> Immerman and P. Kolaitis, editors, </editor> <title> Descriptive Complexity and Finite Models. </title> <publisher> AMS, </publisher> <year> 1997. </year>
Reference-contexts: Finally, these logics do not allow one to state constraints about sharing or the reachability/unreachability of shared nodes. In fact, modal logic is well-known to possess the tree model property: every satisfiable sentence has a (possibly infinite) tree as a model (see, for example, the summary in <ref> [Var97] </ref>). This property fundamentally prevents modal logics as they stand from capturing interesting topological properties of graphs.
Reference: [Wan94] <author> E. Y.-B. Wang. </author> <title> Analysis of Recursive Types in an Imperative Language. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <address> CA, </address> <year> 1994. </year> <month> 17 </month>
Reference-contexts: 1 Introduction This paper aims to provide a better formalism for describing properties of linked data structures (e.g., lists, trees, graphs). In past work with the same motivation, a variety of different formalisms have been developed | including "static shape graphs" <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98b, SRW98a] </ref>, "path matrices" [Hen90, HN90], "graph types" [KS93], and the ADDS annotation formalism [HHN92] | and several previously known formalisms have been exploited | including graph grammars [FM97] and monadic second-order logic [JJNS97].
References-found: 27

