URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1994/UM-CS-1994-071.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/94-071.html
Root-URL: 
Title: Type Evolution Support for Complex Type Changes  
Date: 31, 1994  
Note: October  
Abstract: Barbara Staudt Lerner Computer Science Department University of Massachusetts, Amherst CMPSCI Technical Report 94-71 Abstract Type evolution is a serious problem for programs that use persistent data. Type changes are required during software maintenance, but can make persistent data inaccessible. Existing systems that support type evolution severely restrict the ways in which a type can be changed, thereby limiting what can be accomplished during maintenance. Tess is a system to automate type evolution for a collection of more complex type changes while providing a more natural editing environment for the programmer. Tess uses a comparative approach to identify type changes rather than a specialized editing process. Experimental results on real data indicate that Tess can accurately identify more complex type changes than those supported by existing systems relying on specialized editing. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 83] <author> M.P. Atkinson, P.J. Bailey, K.J. Chisholm, W.P. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4), </volume> <year> 1983. </year> <note> Also published in Readings in Object-Oriented Database Systems, </note> <editor> Stanley B. Zdonik and David Maier, eds., </editor> <publisher> Morgan Kaufman, </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: However, with persistent programming languages the problem is more pervasive since one goal of persistent programming languages is to reduce or eliminate the distinction between transient and persistent types. In particular, some persistent programming languages, such as PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [WWFT88, TC93, DCBM89, ABC + 83] </ref>, treat persistence orthogonally to type definitions. With these languages, an instance of any type can be made persistent dynamically.
Reference: [Bar91] <author> G. Barbedette. </author> <title> Schema modifications in the LISPO 2 persistent object-oriented language. </title> <editor> In P. America, editor, </editor> <booktitle> Proceedings of ECOOP '91, the Fifth European Conference on Object-Oriented Programming, number 512 in Lecture Notes in Computer Science, </booktitle> <address> Geneva, Switzer-land, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Several researchers have investigated type evolution in object-oriented databases. Orion [BKKK87, KK88], GemStone [PS87], and O 2 <ref> [Bar91] </ref> are object-oriented database systems that provide some evolution support. In these systems, evolution is defined in terms of primitive structural changes isolated to individual type definitions, such as adding instance variables to a class, removing instance variables from a class, and renaming instance variables.
Reference: [BKKK87] <author> Jay Banerjee, Won Kim, Hyoung-Joo Kim, and Henry F. Korth. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIGMOD 1987 Annual Conference, </booktitle> <pages> pages 311-322, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Several researchers have investigated type evolution in object-oriented databases. Orion <ref> [BKKK87, KK88] </ref>, GemStone [PS87], and O 2 [Bar91] are object-oriented database systems that provide some evolution support.
Reference: [Bra92] <author> S.E. Bratsberg. </author> <title> Unified class evolution by object-oriented views. </title> <booktitle> In Proceedings of the 11th International Conference on the Entity-Relationship Approach, </booktitle> <pages> pages 423-439, </pages> <address> Karlsruhe, Germany, </address> <month> October </month> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 645, Springer-Verlag. </note>
Reference-contexts: Another approach to evolution of object-oriented databases relies on the simultaneous maintenance of multiple versions of classes and objects. This approach has been used by Skarra and Zdonik [SZ86], Clamen [Cla93], and Bratsberg <ref> [Bra92] </ref>. With these approaches, multiple versions of the same class exist within a single database. The advantage is that existing and new code can operate on existing and new objects without requiring either to be changed.
Reference: [Cla93] <author> Stewart M. Clamen. </author> <title> Schema evolution and integration. Distributed and Parallel Databases: </title> <journal> An International Journal, </journal> <volume> 1(4), </volume> <month> Dec </month> <year> 1993. </year>
Reference-contexts: Another approach to evolution of object-oriented databases relies on the simultaneous maintenance of multiple versions of classes and objects. This approach has been used by Skarra and Zdonik [SZ86], Clamen <ref> [Cla93] </ref>, and Bratsberg [Bra92]. With these approaches, multiple versions of the same class exist within a single database. The advantage is that existing and new code can operate on existing and new objects without requiring either to be changed.
Reference: [DCBM89] <author> Alan Dearle, Richard Connor, Fred Brown, and Ron Morrison. </author> <booktitle> Napier88a database programming language? In Proceedings of the Second International Workshop on Database Programming Languages, </booktitle> <pages> pages 179-195. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1989. </year>
Reference-contexts: However, with persistent programming languages the problem is more pervasive since one goal of persistent programming languages is to reduce or eliminate the distinction between transient and persistent types. In particular, some persistent programming languages, such as PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [WWFT88, TC93, DCBM89, ABC + 83] </ref>, treat persistence orthogonally to type definitions. With these languages, an instance of any type can be made persistent dynamically.
Reference: [GKL94] <author> David Garlan, Charles W. Krueger, and Barbara Staudt Lerner. TransformGen: </author> <title> Automating the maintenance of structure-oriented environments. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 727-774, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: While there is no hard data to support this claim, personal experience and anecdotal evidence exist <ref> [GKL94, Sj93b] </ref>. <p> This allows the description of type changes that simultaneously affect multiple types, but results in a complicated type system that would be difficult to maintain as the number of versions increases. TransformGen <ref> [GKL94] </ref> is a system to support evolution of abstract syntax grammars used by Gan-dalf programming environments [HN86, HGN91]. The abstract syntax grammars are analogous to type definitions; they define the format of the abstract syntax trees stored in databases maintained by Gandalf environments.
Reference: [HGN91] <author> Nico Habermann, David Garlan, and David Notkin. </author> <title> Generation of integrated task-specific software environments. </title> <editor> In Richard F. Rashid, editor, </editor> <booktitle> CMU Computer Science: A 25th Anniversary Commemorative, Anthology Series, chapter 4, </booktitle> <pages> pages 69-97. </pages> <publisher> ACM Press, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: This allows the description of type changes that simultaneously affect multiple types, but results in a complicated type system that would be difficult to maintain as the number of versions increases. TransformGen [GKL94] is a system to support evolution of abstract syntax grammars used by Gan-dalf programming environments <ref> [HN86, HGN91] </ref>. The abstract syntax grammars are analogous to type definitions; they define the format of the abstract syntax trees stored in databases maintained by Gandalf environments. The abstract syntax changes for which TransformGen automatically generates transformation routines are analogous to the type changes supported by Orion and GemStone.
Reference: [HN86] <author> A. Nico Habermann and David Notkin. </author> <title> Gandalf: Software development environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(12):1117-1127, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: This allows the description of type changes that simultaneously affect multiple types, but results in a complicated type system that would be difficult to maintain as the number of versions increases. TransformGen [GKL94] is a system to support evolution of abstract syntax grammars used by Gan-dalf programming environments <ref> [HN86, HGN91] </ref>. The abstract syntax grammars are analogous to type definitions; they define the format of the abstract syntax trees stored in databases maintained by Gandalf environments. The abstract syntax changes for which TransformGen automatically generates transformation routines are analogous to the type changes supported by Orion and GemStone.
Reference: [KK88] <author> Hyoung-Joo Kim and Henry F. Korth. </author> <title> Schema versions and DAG rearrangement views in object-oriented databases. </title> <type> Technical Report TR-88-05, </type> <institution> University of Texas at Austin, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Several researchers have investigated type evolution in object-oriented databases. Orion <ref> [BKKK87, KK88] </ref>, GemStone [PS87], and O 2 [Bar91] are object-oriented database systems that provide some evolution support.
Reference: [LH90] <author> Barbara Staudt Lerner and A. Nico Habermann. </author> <title> Beyond schema evolution to database reorganization. </title> <booktitle> In Proceedings of the Joint ACM OOPSLA/ECOOP '90 Conference on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pages 67-76, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: However, while the programmer can extend the transformer, there is little guidance in identifying the limits of the generation process and the situations that require extension. OTGen <ref> [LH90] </ref> is a system designed using the concepts developed in TransformGen to support flexible transformation of object-oriented databases.
Reference: [Nav80] <author> Shamkant B. Navathe. </author> <title> Schema analysis for database restructuring. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 5(2) </volume> <pages> 157-184, </pages> <month> June </month> <year> 1980. </year>
Reference-contexts: While many database systems support a few simple changes automatically, such as adding or deleting record fields, only a few systems <ref> [SHL75, Nav80, ST82] </ref> support more general transformations. In these cases, the programmer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language, but there is little tool support to assist in this process.
Reference: [Odb94] <author> Erik Odberg. MultiPerspectives: </author> <title> The classification dimension of schema modification management for object-oriented databases. </title> <booktitle> In Proceedings of TOOLS-USA '94, </booktitle> <address> Santa Barbara, California, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: This approach admits more general type changes, but it still limits type changes to be isolated to individual types. It also results in significant overhead (in both space and time) for maintaining and accessing multiple class and object versions. Odberg <ref> [Odb94] </ref> extends the versioning approach to the entire class hierarchy, which is versioned when a type is modified. This allows the description of type changes that simultaneously affect multiple types, but results in a complicated type system that would be difficult to maintain as the number of versions increases.
Reference: [PS87] <author> D. Jason Penney and Jacob Stein. </author> <title> Class modification in the GemStone object-oriented DBMS. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 111-117, </pages> <address> Orlando, Florida, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: Several researchers have investigated type evolution in object-oriented databases. Orion [BKKK87, KK88], GemStone <ref> [PS87] </ref>, and O 2 [Bar91] are object-oriented database systems that provide some evolution support. In these systems, evolution is defined in terms of primitive structural changes isolated to individual type definitions, such as adding instance variables to a class, removing instance variables from a class, and renaming instance variables.
Reference: [Ric93] <author> Debra J. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proceedings of the International Symposium on Software Testing and Analysis (ISSTA) '94. </booktitle> <publisher> ACM Press, </publisher> <month> June 28-30 </month> <year> 1993. </year>
Reference-contexts: To demonstrate the complexity of compound changes handled by Tess, Figures 4 and 5 show consecutive versions of a collection of interrelated types extracted from TAOS, a software testing tool developed at the University of California at Irvine by Debra Richardson and her students <ref> [Ric93] </ref>. (TAOS is written in Pleiades, an extension of Ada that supports persistence. To understand this example, it is sufficient to consider relationship types to be record types and group types to be union types.) In this example, we see three modified types and four new types.
Reference: [SHL75] <author> Nan C. Shu, Barron C. Housel, and Vincent Y. Lum. </author> <title> CONVERT: A high level translation definition language for data conversion. </title> <journal> Communications of the ACM, </journal> <volume> 18(10) </volume> <pages> 557-567, </pages> <month> October </month> <year> 1975. </year>
Reference-contexts: While many database systems support a few simple changes automatically, such as adding or deleting record fields, only a few systems <ref> [SHL75, Nav80, ST82] </ref> support more general transformations. In these cases, the programmer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language, but there is little tool support to assist in this process.
Reference: [Sj93a] <author> D. Sjberg. </author> <title> Quantifying schema evolution. </title> <journal> Information and Software Technology, </journal> <volume> 35(1) </volume> <pages> 35-44, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: It is therefore difficult to know with certainty what evolution support is most beneficial. Sjtberg has published the change history of a relational database management system that includes interesting compound changes like new relations created by joining or partitioning existing relations <ref> [Sj93a] </ref>. Additionally, we have access to the maintenance histories of several research systems, which we are using to understand the general nature of evolution, to experiment with Tess, and to guide future development.
Reference: [Sj93b] <author> D. I. K. Sjberg. </author> <title> Thesaurus-Based Methodologies and Tools for Maintaining Persistent Application Systems. </title> <type> PhD thesis, </type> <institution> University of Glasgow, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: While there is no hard data to support this claim, personal experience and anecdotal evidence exist <ref> [GKL94, Sj93b] </ref>.
Reference: [ST82] <author> Ben Shneiderman and Glenn Thomas. </author> <title> An architecture for automatic relational database system conversion. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2) </volume> <pages> 235-257, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: While many database systems support a few simple changes automatically, such as adding or deleting record fields, only a few systems <ref> [SHL75, Nav80, ST82] </ref> support more general transformations. In these cases, the programmer is responsible for explicitly describing how to convert the data from its old format to its new format using a special-purpose data translation language, but there is little tool support to assist in this process.
Reference: [SZ86] <author> Andrea H. Skarra and Stanley B. Zdonik. </author> <title> The management of changing types in an object-oriented database. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 483-495, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Another approach to evolution of object-oriented databases relies on the simultaneous maintenance of multiple versions of classes and objects. This approach has been used by Skarra and Zdonik <ref> [SZ86] </ref>, Clamen [Cla93], and Bratsberg [Bra92]. With these approaches, multiple versions of the same class exist within a single database. The advantage is that existing and new code can operate on existing and new objects without requiring either to be changed.
Reference: [TC93] <author> Peri Tarr and Lori A. Clarke. Pleiades: </author> <title> An object management system for software engineering environments. </title> <booktitle> In Proceedings of ACM SIGSOFT '93: Symposium on the Foundations of Software Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: However, with persistent programming languages the problem is more pervasive since one goal of persistent programming languages is to reduce or eliminate the distinction between transient and persistent types. In particular, some persistent programming languages, such as PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [WWFT88, TC93, DCBM89, ABC + 83] </ref>, treat persistence orthogonally to type definitions. With these languages, an instance of any type can be made persistent dynamically.
Reference: [WWFT88] <author> Jack C. Wileden, Alexander L. Wolf, Charles D. Fisher, and Peri L. Tarr. PGRAPHITE: </author> <title> An experiment in persistent typed object management. </title> <booktitle> In Proceedings 3rd Software Development Environments Conference, </booktitle> <pages> pages 130-142, </pages> <month> December </month> <year> 1988. </year> <month> 18 </month>
Reference-contexts: However, with persistent programming languages the problem is more pervasive since one goal of persistent programming languages is to reduce or eliminate the distinction between transient and persistent types. In particular, some persistent programming languages, such as PGraphite, Pleiades, Napier-88, and PS-Algol <ref> [WWFT88, TC93, DCBM89, ABC + 83] </ref>, treat persistence orthogonally to type definitions. With these languages, an instance of any type can be made persistent dynamically.
References-found: 22

