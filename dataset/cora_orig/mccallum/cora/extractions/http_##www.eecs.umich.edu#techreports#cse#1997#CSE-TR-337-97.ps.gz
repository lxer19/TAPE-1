URL: http://www.eecs.umich.edu/techreports/cse/1997/CSE-TR-337-97.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse97.html
Root-URL: http://www.eecs.umich.edu
Title: Classification-Directed Branch Predictor Design  
Author: by Po-Yung Chang Professor Edward S. Davidson Professor Ronald J. Lomax Professor Trevor N. Mudge Tse-Yu Yeh, CPU Micro-Architect and Senior 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Science and Engineering) in The  Doctoral Committee: Professor Yale N. Patt, Chair  
Note: Design Engineer, Intel  
Date: 1997  
Affiliation: University of Michigan  
Abstract-found: 0
Intro-found: 1
Reference: <institution> 105 BIBLIOGRAPHY </institution>
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman, </author> <booktitle> Compilers Principles, Techniques, and Tools, </booktitle> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: With additional hint bits in the branch opcodes, PowerPC 604 [10] allows the compiler to pass prediction information to the hardware. The program-based branch predictor [3] bases its prediction on the program structure; this predictor classifies branches into loop branches and non-loop branches using natural loop analysis <ref> [1] </ref> of the control flow graph. Loops are predicted to iterate rather than exit. Non-loop branches are predicted using a number of heuristics - opcode, loop, call, return, guard, store, and pointer comparisons.
Reference: [2] <author> J. R. Allen, K. Kennedy, C. Porterfield, and J. Warren, </author> <title> "Conversion of control dependence to data dependence," </title> <booktitle> in 10th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 177-189, </pages> <year> 1983. </year>
Reference-contexts: The branches can be eliminated by replacing their control-dependent instructions with flow-dependent predicated instructions <ref> [2] </ref>. A predicated instruction contains an extra source operand known as the predicate operand. The predicated instruction is conditionally executed based on the value of this operand. If the predicate evaluates to true, the predicated instruction is executed like a normal instruction.
Reference: [3] <author> T. Ball and J. R. Larus, </author> <title> "Branch prediction for free," </title> <type> Technical Report 1137, </type> <institution> Computer Sciences Department, University of Wisconsin - Madison, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Predicting all branches to be taken achieves about 66% accuracy whereas predicting not-taken achieves about 34% for the SPEC95 integer benchmarks. With additional hint bits in the branch opcodes, PowerPC 604 [10] allows the compiler to pass prediction information to the hardware. The program-based branch predictor <ref> [3] </ref> bases its prediction on the program structure; this predictor classifies branches into loop branches and non-loop branches using natural loop analysis [1] of the control flow graph. Loops are predicted to iterate rather than exit.
Reference: [4] <author> M. G. Butler, </author> <title> Aggressive Execution Engines for Surpassing Single Basic Block Execution, </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1993. </year>
Reference-contexts: Figure 3.1 shows the trace-driven simulation methodology. A Motorola MC88110 instruction level simulator (Archsim) reads in the object code and input data; it then simulates execution and produces an instruction trace. The instruction traces are then processed by either the restricted data flow (RDF) simulator <ref> [4] </ref> or the instruction fetch mechanism (IFM) simulator [37]. The RDF simulator simulates the execution of instructions on a given machine model, which is described in a configuration file read by the RDF simulator. The IFM simulator only simulates the actions involved in predicting instruction fetch address. <p> good coverage of its hard-to-predict branches. 8.2 Predication Model Our predication model assumes that each predicated instruction has three or four source operands: one or two source operands used for calculating the value generated by the instruction, one predicate operand, and one implicit source operand specified by the destination register <ref> [4, 28] </ref>. The predicate operand is an ordinary register. The predicated instruction can interpret its value by its least significant bit or by the complement of its least significant bit. Although predicate registers are usually set by compare instructions, they can be set by any instruction.
Reference: [5] <author> B. Calder and D. Grunwald, </author> <title> "Reducing indirect function call overhead in c++ programs," </title> <booktitle> in Proceedings of the 6th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <year> 1994. </year>
Reference-contexts: To address the problem of target prediction for indirect jumps in C++ programs, Calder and Grunwald proposed a new strategy, the 2-bit strategy, for updating BTB target addresses <ref> [5] </ref>. The typical strategy is to update the BTB on every indirect jump misprediction, Calder and Grunwald's 2-bit strategy does not update a BTB entry's target address until two consecutive predictions with that target address are incorrect.
Reference: [6] <author> P. Chang and U. Banerjee, </author> <title> "Profile-guided multi-heuristic branch prediction," </title> <booktitle> in Proceedings of the International Conference on Parallel Processing, </booktitle> <year> 1995. </year>
Reference-contexts: Using 13 branch history bits, the gshare predictor achieves a 92% prediction accuracy whereas the gshare predictor with no PHT interference achieves a 95% prediction accuracy, leaving significant room for improvement. 10 2.3 Hybrid Branch Predictors To further improve prediction accuracy, hybrid branch predictors have been proposed <ref> [20, 6] </ref>. A hybrid branch predictor is composed of two or more single-scheme predictors and a mechanism to select among these predictors. <p> Prediction pc Predictor 1 Predictor 2 Update to Counter Correct Prediction Correct Prediction No Change Correct Prediction Incorrect Prediction Increment Incorrect Prediction Correct Prediction Decrement Incorrect Prediction Incorrect Prediction No Change Table 2.1: Counter update rules Chang and Banerjee <ref> [6] </ref> proposed the AVG predictor which can accurately predict loop branches. The AVG predictor keeps track of the average number of iterations executed for each loop. <p> new hybrid branch predictor achieved a prediction accuracy of 96.91% on gcc, a branch intensive benchmark, as compared to 96.47% for the best previously known predictor, reducing the miss rate by 12.5%. 30 CHAPTER 5 Hybrid Branch Predictors To improve prediction accuracy, several hybrid branch predictors have recently been proposed <ref> [20, 7, 6] </ref>. They combine multiple prediction schemes into a single predictor and use a selection mechanism to decide for each branch, which single-scheme predictor to use (see Figure 5.1).
Reference: [7] <author> P.-Y. Chang, E. Hao, T.-Y. Yeh, and Y. N. Patt, </author> <title> "Branch classification: A new mechanism for improving branch predictor performance," </title> <journal> International Journal of Parallel Programming, </journal> <volume> vol. 24, no. 2, </volume> <pages> pp. 133-158, </pages> <year> 1996. </year> <note> Previous version published in Proceedings of the 27th ACM/IEEE International Symposium on Microarchitecture, </note> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: In addition, this dissertation proposes branch classification as a means for improving the performance of each individual branch handling mechanism. Various branch handling mechanisms are considered for improvement. * Hybrid branch predictors have been proposed as a way to achieve higher prediction accuracies <ref> [20, 7] </ref>. They combine multiple prediction schemes into a single predictor. A selection mechanism is used to decide, for each branch, which single-scheme predictor to use. <p> In the past, branch prediction research has focused on accurately predicting direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>; a direct branch has a statically specified target which points to a single location in the program. To predict such branches, the prediction mechanism predicts the branch direction and then generates the target associated with that direction. <p> To maximize the prediction accuracy obtained from a given hardware budget, we could use a simple and low-cost predictor for 28 predictable branches and dedicate more resources to handle branches that are more difficult to predict. Since static predictors can accurately predict the mostly-one-direction branches <ref> [7] </ref>, we use static predictors for these mostly-one-direction branches and dedicate our hardware for predicting the mixed-direction branches. For the mixed-direction branches, we use an aggressive hybrid branch predictor, PAs/gshare [20]. <p> new hybrid branch predictor achieved a prediction accuracy of 96.91% on gcc, a branch intensive benchmark, as compared to 96.47% for the best previously known predictor, reducing the miss rate by 12.5%. 30 CHAPTER 5 Hybrid Branch Predictors To improve prediction accuracy, several hybrid branch predictors have recently been proposed <ref> [20, 7, 6] </ref>. They combine multiple prediction schemes into a single predictor and use a selection mechanism to decide for each branch, which single-scheme predictor to use (see Figure 5.1). <p> We therefore reduce the number of mispredictions by 30% to 38% for the gshare predictor. For gshare/pshare, the number of mispredictions was reduced by 23% to 29%. CHAPTER 7 Indirect Branches 7.1 Characteristics In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used. <p> Branches whose misprediction counts exceeded a given threshold were considered hard to predict and marked for elimination. The branch predictor simulated by the profiler in our experiments was the Gshare/PAg predictor <ref> [20, 7] </ref>. This hybrid branch predictor combines the gshare (13) and PAs (11,2) predictors. Compiled simulations as described in Section 3.1.1 are used to report the performance of the branch predictor for each static branch in each of the six SPECint92 benchmarks.
Reference: [8] <author> P. Chow and M. Horowitz, </author> <title> "Architecture tradeoffs in the design of mips-x," </title> <booktitle> in Proceedings of the 14th Annual International Symposium on Computer Architecture, </booktitle> <year> 1987. </year>
Reference-contexts: These prediction schemes can be divided into two groups, static and dynamic predictors. Static branch prediction schemes use information gathered before program execution, such as branch opcodes or profiles, to predict branch direction. The simplest of these predicts that all conditional branches are always taken as in Stanford MIPS-X <ref> [8] </ref>, or always not-taken as in Motorola MC88000 [22]. Predicting all branches to be taken achieves about 66% accuracy whereas predicting not-taken achieves about 34% for the SPEC95 integer benchmarks.
Reference: [9] <author> J. C. Dehnert, P. Y. T. Hsu, and J. P. Bratt, </author> <title> "Overlapped loop support in the Cydra 5," </title> <booktitle> in Proceedings of the 3th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 26-38, </pages> <year> 1989. </year>
Reference-contexts: In this case, the full branch execution penalty is suffered. Thus, an excellent branch predictor is vital to deliver the potential performance of a wide-issue deeply-pipelined microarchitecture. This dissertation proposes several mechanisms for increasing the accuracy of branch predictors. Predicated execution <ref> [14, 29, 9, 19, 28, 36, 18, 12] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program.
Reference: [10] <editor> E. C. M. et al, editor, </editor> <title> The PowerPC Architecture: A Specification for a New Family of RISC Processors, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1994. </year> <month> 106 </month>
Reference-contexts: Predicting all branches to be taken achieves about 66% accuracy whereas predicting not-taken achieves about 34% for the SPEC95 integer benchmarks. With additional hint bits in the branch opcodes, PowerPC 604 <ref> [10] </ref> allows the compiler to pass prediction information to the hardware. The program-based branch predictor [3] bases its prediction on the program structure; this predictor classifies branches into loop branches and non-loop branches using natural loop analysis [1] of the control flow graph.
Reference: [11] <author> J. A. Fisher and S. M. Freudenberger, </author> <title> "Predicting conditional branch direc-tions from previous runs of a program," </title> <booktitle> in Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 85-95, </pages> <year> 1992. </year>
Reference-contexts: The profile-guided branch predictor bases its prediction on the direction the branch most frequently takes, which is determined by profiling the program on a training input data set <ref> [11] </ref>. The profile-guided branch predictor achieves the highest prediction accuracy among the static predictors, correctly predicting about 87% of the branches. Dynamic branch prediction algorithms use information gathered at run-time to predict branch directions. <p> The single-scheme predictors examined were divided into four classes: 32 1. static the profile-guided branch predictor <ref> [11] </ref>. 2. 2bC (n) the two bit counter predictor [32]. It consists of an array of n two bit counters. 3.
Reference: [12] <author> M. L. Golden, </author> <title> Reducing the Penalty of Branch and Load Hazards in Pipelined Microprocessors, </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1995. </year>
Reference-contexts: In this case, the full branch execution penalty is suffered. Thus, an excellent branch predictor is vital to deliver the potential performance of a wide-issue deeply-pipelined microarchitecture. This dissertation proposes several mechanisms for increasing the accuracy of branch predictors. Predicated execution <ref> [14, 29, 9, 19, 28, 36, 18, 12] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program.
Reference: [13] <author> T. Granlund and R. Kenner, </author> <title> "Eliminating branches using a superoptimizer and the GNU C compiler," </title> <booktitle> in Proceedings of the ACM SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 341-352, </pages> <year> 1992. </year>
Reference-contexts: Three different variations for each benchmark were simulated: * np baseline version of the benchmark in which none of the branches were eliminated. * sp software-based predication version in which branches were eliminated by the GCC compiler through the use of logical and bit-manipulation operations <ref> [13] </ref>. Table 8.5 shows an example of software-based predication. * hp - ISA-based predication version in which branches were eliminated by pred icated instructions.
Reference: [14] <author> P. Hsu and E. Davidson, </author> <title> "Highly concurrent scalar processing," </title> <booktitle> in Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <year> 1986. </year>
Reference-contexts: In this case, the full branch execution penalty is suffered. Thus, an excellent branch predictor is vital to deliver the potential performance of a wide-issue deeply-pipelined microarchitecture. This dissertation proposes several mechanisms for increasing the accuracy of branch predictors. Predicated execution <ref> [14, 29, 9, 19, 28, 36, 18, 12] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> Many current commercial computer architectures (e.g. the Intel Pentium Pro, the DEC Alpha, the SPARC V9, and the HP PA-RISC) include some form of predicated execution. Hsu and Davidson <ref> [14] </ref> studied the use of predicated instructions to better schedule decision trees on scalar processors. Instructions on the critical path of a decision tree are scheduled as early as possible to minimize the execution time through the decision tree.
Reference: [15] <author> W. W. Hwu and Y. N. Patt, </author> <title> "Checkpoint repair for out-of-order execution machines," </title> <booktitle> in Proceedings of the 14th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 18-26, </pages> <year> 1987. </year>
Reference-contexts: Each cycle, the oldest firable node of each node table is scheduled, i.e., it is shipped to a pipelined functional unit for execution. Each cycle, functional units complete execution of nodes and distribute the results to nodes waiting for these results, which then may become firable. Checkpointing <ref> [15] </ref> is used to maintain precise exceptions. Checkpoints are established for each branch; thus, once a branch misprediction is determined, instructions from the correct path are fetched in the next cycle.
Reference: [16] <author> D. R. Kaeli and P. G. Emma, </author> <title> "Improving the accuracy of history-based branch prediction," </title> <note> Submitted to IEEE Transactions on Computers, </note> <year> 1994. </year>
Reference-contexts: This strategy was shown to achieve a higher target prediction accuracy than that achieved by the typical strategy. Kaeli et al. proposed a hardware mechanism, the case block table (CBT), to speed up the execution of SWITCH/CASE statements <ref> [16] </ref>.
Reference: [17] <author> J. K. F. Lee and A. J. Smith, </author> <title> "Branch prediction strategies and branch target buffer design," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 6-22, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: The gshare scheme tries to better identify the machine execution states by using both the branch address and the branch history. A gshare using 13 history bits achieves a predication accuracy of approximately 92%. Lee and Smith <ref> [17] </ref> proposed a scheme where the value of each Pattern History Table entry is determined statically, using profile information; this scheme is referred to as the PSg scheme by Yeh and Patt [40]. Sechrest et al. [31] introduced another method, PSg (algo), of statically determining the values in the PHT.
Reference: [18] <author> S. A. Mahlke, R. E. Hank, R. A. Bringmann, J. C. Gyllenhaal, D. M. Gallagher, and W. W. Hwu, </author> <title> "Characterizing the impact of predicated execution on branch prediction," </title> <booktitle> in Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 217-227, </pages> <year> 1994. </year>
Reference-contexts: In this case, the full branch execution penalty is suffered. Thus, an excellent branch predictor is vital to deliver the potential performance of a wide-issue deeply-pipelined microarchitecture. This dissertation proposes several mechanisms for increasing the accuracy of branch predictors. Predicated execution <ref> [14, 29, 9, 19, 28, 36, 18, 12] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> However, not all short forward branches can be predicated. For example, a loop exit branch can not be eliminated. The performance benefit of predicating all short forward branches depends on the predictability of the short forward branches that can be eliminated. Mahlke et al. <ref> [19, 18] </ref> used predicated execution to eliminate the branches that were difficult to predict for a static branch predictor and reported the effect on branch mispredictions and the performance of a statically scheduled machine.
Reference: [19] <author> S. A. Mahlke, D. C. Lin, W. Y. Chen, R. E. Hank, and R. A. Bringmann, </author> <title> "Effective compiler support for predicated execution using the hyperblock," </title> <booktitle> in Proceedings of the 25th Annual ACM/IEEE International Symposium on Mi-croarchitecture, </booktitle> <pages> pp. 45-54, </pages> <year> 1992. </year>
Reference-contexts: In this case, the full branch execution penalty is suffered. Thus, an excellent branch predictor is vital to deliver the potential performance of a wide-issue deeply-pipelined microarchitecture. This dissertation proposes several mechanisms for increasing the accuracy of branch predictors. Predicated execution <ref> [14, 29, 9, 19, 28, 36, 18, 12] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> However, not all short forward branches can be predicated. For example, a loop exit branch can not be eliminated. The performance benefit of predicating all short forward branches depends on the predictability of the short forward branches that can be eliminated. Mahlke et al. <ref> [19, 18] </ref> used predicated execution to eliminate the branches that were difficult to predict for a static branch predictor and reported the effect on branch mispredictions and the performance of a statically scheduled machine.
Reference: [20] <author> S. McFarling, </author> <title> "Combining branch predictors," </title> <type> Technical Report TN-36, </type> <institution> Digital Western Research Laboratory, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: In addition, this dissertation proposes branch classification as a means for improving the performance of each individual branch handling mechanism. Various branch handling mechanisms are considered for improvement. * Hybrid branch predictors have been proposed as a way to achieve higher prediction accuracies <ref> [20, 7] </ref>. They combine multiple prediction schemes into a single predictor. A selection mechanism is used to decide, for each branch, which single-scheme predictor to use. <p> Using 15 global history bits, the two-level branch predictor achieves a prediction accuracy of 93.3%. Several variations of the two-level branch predictor have been proposed [39]. Mc-Farling <ref> [20] </ref> introduced gshare, a variation of the global-history two-level branch predictor which XORs the global branch history with the branch address to index into the PHT. <p> Using 13 branch history bits, the gshare predictor achieves a 92% prediction accuracy whereas the gshare predictor with no PHT interference achieves a 95% prediction accuracy, leaving significant room for improvement. 10 2.3 Hybrid Branch Predictors To further improve prediction accuracy, hybrid branch predictors have been proposed <ref> [20, 6] </ref>. A hybrid branch predictor is composed of two or more single-scheme predictors and a mechanism to select among these predictors. <p> A hybrid branch predictor can exploit the different strengths of its single-scheme component predictors, enabling it to achieve a prediction accuracy greater than that achieved by any of its components alone. McFarling <ref> [20] </ref> proposed a selection mechanism that combines two branch predictors using an array of 2-bit up-down counters to keep track of which predictor is currently more accurate for each branch; each branch is mapped to a counter via its address (see Figure 2.2). <p> In the past, branch prediction research has focused on accurately predicting direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>; a direct branch has a statically specified target which points to a single location in the program. To predict such branches, the prediction mechanism predicts the branch direction and then generates the target associated with that direction. <p> Since static predictors can accurately predict the mostly-one-direction branches [7], we use static predictors for these mostly-one-direction branches and dedicate our hardware for predicting the mixed-direction branches. For the mixed-direction branches, we use an aggressive hybrid branch predictor, PAs/gshare <ref> [20] </ref>. The resulting predictor, PG+PAs/gshare, uses the profile-guided predictor for the mostly-one-direction branches and the PAs/gshare scheme for the mixed-direction branches 2 . Figure 4.5 shows the structure of the PG+PAs/gshare predictor. 2 we use the "+" to indicate static predictor selection and "/" for dynamic predictor selection. <p> For the SPEC92 benchmark gcc, which contains many branches, PG+PAs/gshare achieves prediction accuracy of 96.91%, as compared to 96.47% for the best previously known predictor (PAs/gshare) <ref> [20] </ref>. PG+PAs/gshare outperforming PAs/gshare indicates that branch classification can be helpful in designing more accurate branch predictors. 4.2 Summary Branches in a program can be categorized into different classes. Since branches in the different classes can have different behaviors, the most suitable mechanism to handle each branch can be different. <p> new hybrid branch predictor achieved a prediction accuracy of 96.91% on gcc, a branch intensive benchmark, as compared to 96.47% for the best previously known predictor, reducing the miss rate by 12.5%. 30 CHAPTER 5 Hybrid Branch Predictors To improve prediction accuracy, several hybrid branch predictors have recently been proposed <ref> [20, 7, 6] </ref>. They combine multiple prediction schemes into a single predictor and use a selection mechanism to decide for each branch, which single-scheme predictor to use (see Figure 5.1). <p> It consists of an array of n two bit counters. 3. PAs (k,s) the per-address variation of the Two-Level Adaptive Branch Predictor [39] consisting of 1K k-bit branch history registers and s pattern history tables. 4. gshare (k) a modified version of the the two-level branch predictor <ref> [20] </ref> consist ing of a single k-bit global branch history and a single pattern history table. The static predictor was considered because it is a compile-time predictor which has no hardware cost. <p> The 2bC predictor was considered because it is still used by many of the current generation of commercial microprocessors. The PAs and gshare predictors were considered because they are variations of the highest performing single-scheme predictor, the two-level branch predictor <ref> [38, 25, 39, 40, 20] </ref>. For each predictor type, a range of predictor sizes was considered allowing us to vary the amount of hardware devoted to each scheme. The 2bC array size was varied from 2 10 to 2 20 entries. <p> We therefore reduce the number of mispredictions by 30% to 38% for the gshare predictor. For gshare/pshare, the number of mispredictions was reduced by 23% to 29%. CHAPTER 7 Indirect Branches 7.1 Characteristics In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used. <p> Branches whose misprediction counts exceeded a given threshold were considered hard to predict and marked for elimination. The branch predictor simulated by the profiler in our experiments was the Gshare/PAg predictor <ref> [20, 7] </ref>. This hybrid branch predictor combines the gshare (13) and PAs (11,2) predictors. Compiled simulations as described in Section 3.1.1 are used to report the performance of the branch predictor for each static branch in each of the six SPECint92 benchmarks.
Reference: [21] <author> S. McFarling and J. Hennessy, </author> <title> "Reducing the cost of branches," </title> <booktitle> in Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 396-403, </pages> <year> 1986. </year>
Reference-contexts: In the past, branch prediction research has focused on accurately predicting direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>; a direct branch has a statically specified target which points to a single location in the program. To predict such branches, the prediction mechanism predicts the branch direction and then generates the target associated with that direction. <p> We therefore reduce the number of mispredictions by 30% to 38% for the gshare predictor. For gshare/pshare, the number of mispredictions was reduced by 23% to 29%. CHAPTER 7 Indirect Branches 7.1 Characteristics In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used.
Reference: [22] <author> C. Melear, </author> <title> "The design of the 88000 risc family," </title> <booktitle> in IEEE Micro, </booktitle> <pages> pp. 26-38, </pages> <year> 1989. </year>
Reference-contexts: Static branch prediction schemes use information gathered before program execution, such as branch opcodes or profiles, to predict branch direction. The simplest of these predicts that all conditional branches are always taken as in Stanford MIPS-X [8], or always not-taken as in Motorola MC88000 <ref> [22] </ref>. Predicting all branches to be taken achieves about 66% accuracy whereas predicting not-taken achieves about 34% for the SPEC95 integer benchmarks. With additional hint bits in the branch opcodes, PowerPC 604 [10] allows the compiler to pass prediction information to the hardware.
Reference: [23] <author> S. Melvin and Y. N. Patt, </author> <title> "Exploiting fine-grained parallelism through a combination of hardware and software techniques," </title> <booktitle> in Proceedings of the 18th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 287-297, </pages> <year> 1991. </year> <month> 107 </month>
Reference-contexts: Speculative execution <ref> [27, 23] </ref> is a microarchitectural mechanism that solves the branch problem by guessing the target of a branch. After making a prediction for a branch in the dynamic instruction stream, the processor speculatively executes the instructions from the predicted target.
Reference: [24] <author> R. Nair, </author> <title> "Dynamic path-based branch correlation," </title> <booktitle> in Proceedings of the 28th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 15-23, </pages> <year> 1995. </year>
Reference-contexts: In the past, branch prediction research has focused on accurately predicting direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>; a direct branch has a statically specified target which points to a single location in the program. To predict such branches, the prediction mechanism predicts the branch direction and then generates the target associated with that direction. <p> We therefore reduce the number of mispredictions by 30% to 38% for the gshare predictor. For gshare/pshare, the number of mispredictions was reduced by 23% to 29%. CHAPTER 7 Indirect Branches 7.1 Characteristics In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used. <p> No extra hardware is required to maintain the branch history for the target cache if the branch prediction mechanism already contains this information. The target cache can use the branch predictor's BHR. * Path History Previous research <ref> [42, 24] </ref> has shown that path history can also provide useful correlation information to improve branch prediction accuracy. Path history consists of the target addresses of branches that lead to the current branch. This information is also useful in predicting indirect branch targets.
Reference: [25] <author> S.-T. Pan, K. So, and J. T. Rahmeh, </author> <title> "Improving the accuracy of dynamic branch prediction using branch correlation," </title> <booktitle> in Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 76-84, </pages> <year> 1992. </year>
Reference-contexts: The 2bC predictor was considered because it is still used by many of the current generation of commercial microprocessors. The PAs and gshare predictors were considered because they are variations of the highest performing single-scheme predictor, the two-level branch predictor <ref> [38, 25, 39, 40, 20] </ref>. For each predictor type, a range of predictor sizes was considered allowing us to vary the amount of hardware devoted to each scheme. The 2bC array size was varied from 2 10 to 2 20 entries.
Reference: [26] <author> Y. Patt, W. Hwu, and M. Shebanow, "HPS, </author> <title> a new microarchitecture: Rationale and introduction," </title> <booktitle> in Proceedings of the 18th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 103-107, </pages> <year> 1985. </year>
Reference-contexts: Thus, branch handling mechanisms must effectively handle these conditional branches in order for the processor to achieve its potential performance. 3.3 Machine Model The machine model simulated is the HPS microarchitecture <ref> [26] </ref> [27]. Figure 3.9 shows the block diagram of the HPS architecture. <p> If the predicate evaluates to false, the predicated instruction writes the old value of the destination register (the implicit operand) back into the destination register. This is done instead of suppressing the execution of the instruction because the machine simulated uses dynamic register renaming <ref> [35, 26] </ref>. For register renaming to function correctly, every issued instruction must eventually produce a value. This requirement has the drawback that it forces every predicated instruction to be part of a dependency 79 chain regardless of the value of its predicate.
Reference: [27] <author> Y. N. Patt, S. W. Melvin, W. Hwu, and M. C. Shebanow, </author> <title> "Critical issues regarding HPS, a high performance microarchitecture," </title> <booktitle> in Proceedings of the 18th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 109-116, </pages> <year> 1985. </year>
Reference-contexts: Speculative execution <ref> [27, 23] </ref> is a microarchitectural mechanism that solves the branch problem by guessing the target of a branch. After making a prediction for a branch in the dynamic instruction stream, the processor speculatively executes the instructions from the predicted target. <p> Thus, branch handling mechanisms must effectively handle these conditional branches in order for the processor to achieve its potential performance. 3.3 Machine Model The machine model simulated is the HPS microarchitecture [26] <ref> [27] </ref>. Figure 3.9 shows the block diagram of the HPS architecture.
Reference: [28] <author> D. N. Pnevmatikatos and G. S. Sohi, </author> <title> "Guarded execution and dynamic branch prediction in dynamic ILP processors," </title> <booktitle> in Proceedings of the 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 120-129, </pages> <year> 1994. </year>
Reference-contexts: In this case, the full branch execution penalty is suffered. Thus, an excellent branch predictor is vital to deliver the potential performance of a wide-issue deeply-pipelined microarchitecture. This dissertation proposes several mechanisms for increasing the accuracy of branch predictors. Predicated execution <ref> [14, 29, 9, 19, 28, 36, 18, 12] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> However, instead of decision trees, directed acyclic graphs are commonly used to represent the control structure of a program. Speculative and predicated execution have advantages, as well as disadvantages. Recent researchers have studied the effectiveness of combining speculative and predicated execution. Pnevmatikatos and Sohi <ref> [28] </ref> studied the performance benefit of using predicated execution in conjunction with the two-level branch predictor. They eliminated as many branches as possible through predicated execution. They proposed two models of predication, full guarding and restricted guarding. In the full 13 guarding model, all instructions can be predicated. <p> good coverage of its hard-to-predict branches. 8.2 Predication Model Our predication model assumes that each predicated instruction has three or four source operands: one or two source operands used for calculating the value generated by the instruction, one predicate operand, and one implicit source operand specified by the destination register <ref> [4, 28] </ref>. The predicate operand is an ordinary register. The predicated instruction can interpret its value by its least significant bit or by the complement of its least significant bit. Although predicate registers are usually set by compare instructions, they can be set by any instruction.
Reference: [29] <author> B. R. Rau, D. W. L. Yen, W. Yen, and R. A. Towle, </author> <title> "The Cydra 5 departmental supercomputer," </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 12-35, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: In this case, the full branch execution penalty is suffered. Thus, an excellent branch predictor is vital to deliver the potential performance of a wide-issue deeply-pipelined microarchitecture. This dissertation proposes several mechanisms for increasing the accuracy of branch predictors. Predicated execution <ref> [14, 29, 9, 19, 28, 36, 18, 12] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program.
Reference: [30] <author> R. M. Russell, </author> <title> "The CRAY-1 computer system," </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 1, </volume> <pages> pp. 63-72, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: As a result, the CBT cannot redirect the instruction stream to the appropriate case until that value is computed. 2.5 Predicated Execution Predicated execution was first proposed in the form of vector masks for vector machines such as the CRAY <ref> [30] </ref>. Many current commercial computer architectures (e.g. the Intel Pentium Pro, the DEC Alpha, the SPARC V9, and the HP PA-RISC) include some form of predicated execution. Hsu and Davidson [14] studied the use of predicated instructions to better schedule decision trees on scalar processors.
Reference: [31] <author> S. Sechrest, C.-C. Lee, and T. Mudge, </author> <title> "The role of adaptivity in two-level adaptive branch prediction," </title> <booktitle> in Proceedings of the 28th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <year> 1995. </year>
Reference-contexts: Lee and Smith [17] proposed a scheme where the value of each Pattern History Table entry is determined statically, using profile information; this scheme is referred to as the PSg scheme by Yeh and Patt [40]. Sechrest et al. <ref> [31] </ref> introduced another method, PSg (algo), of statically determining the values in the PHT. The PSg (algo) works on the premise that for branches with a recurring pattern, the next outcome of the branch is likely an extension of this pattern. <p> Thus, to achieve higher performance, the disadvantage of having less accurate predictions for these branches must not outweigh the benefits of reducing the PHT interference. For branches that have a recurring pattern, the next outcome of the branch is an extension of this pattern. Since the PSg (algo) <ref> [31] </ref> works on this premise, we expect it to perform well for branches with repeating patterns and apply it to these branches. 1 2 3 4 5 6 7 8 Pattern Length 0.0 0.2 Misprediction Rate PSg gshare (2KB) gshare (32KB) patterns 45 short repeating patterns were accurately predicted with PSg
Reference: [32] <author> J. E. Smith, </author> <title> "A study of branch prediction strategies," </title> <booktitle> in Proceedings of the 8th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 135-148, </pages> <year> 1981. </year>
Reference-contexts: The profile-guided branch predictor achieves the highest prediction accuracy among the static predictors, correctly predicting about 87% of the branches. Dynamic branch prediction algorithms use information gathered at run-time to predict branch directions. Smith <ref> [32] </ref> proposed a branch prediction scheme which uses a table of 2-bit saturating up-down counters to keep track of the direction a branch is more likely to take. Each branch is mapped via its address to a counter. <p> In the past, branch prediction research has focused on accurately predicting direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>; a direct branch has a statically specified target which points to a single location in the program. To predict such branches, the prediction mechanism predicts the branch direction and then generates the target associated with that direction. <p> The single-scheme predictors examined were divided into four classes: 32 1. static the profile-guided branch predictor [11]. 2. 2bC (n) the two bit counter predictor <ref> [32] </ref>. It consists of an array of n two bit counters. 3. <p> We therefore reduce the number of mispredictions by 30% to 38% for the gshare predictor. For gshare/pshare, the number of mispredictions was reduced by 23% to 29%. CHAPTER 7 Indirect Branches 7.1 Characteristics In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used.
Reference: [33] <author> E. Sprangle and Y. Patt, </author> <title> "Facilitating superscalar processing via a combined static/dynamic register renaming scheme," </title> <booktitle> in Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 143-147, </pages> <year> 1994. </year>
Reference-contexts: Before After if (a == 2) cc = (a != 2); a = 0; cc = sign-extend the least significant bit of cc; a = a & cc; Table 8.5: Example of software-based predication 1 Sprangle and Patt <ref> [33] </ref> have proposed a static register tagging scheme that avoids this drawback by eliminating the need to execute predicated instructions when their predicates are false.
Reference: [34] <author> A. R. Talcott, M. Nemirovsky, and R. C. Wood, </author> <title> "The influence of branch prediction table interference on branch prediction scheme performance," </title> <booktitle> in International Conference on Parallel Architectures and Compilation Techniques, </booktitle> <year> 1995. </year>
Reference-contexts: Recent studies <ref> [34, 41] </ref> have shown that a number of these mispredictions are due to interference in the pattern history tables. <p> PAs using 13 history bits achieves a prediction accuracy of 92.5%. 2.2 Interference in Two-level Branch Predictors The two-level branch predictors have been shown to achieve high prediction accuracy, yet they still suffer a significant number of mispredictions. Recent studies <ref> [34, 41] </ref> have shown that a number of these mispredictions are due to interference in the pattern history tables. Pattern history table interference occurs when a conditional branch references a PHT entry that was last referenced by another conditional branch. <p> Recent studies [34, 41] have shown that a number of these mispredictions are due to interference in the pattern history tables. Pattern history table interference occurs when a conditional branch references a PHT entry that was last referenced by another conditional branch. Talcott et al. <ref> [34] </ref> classified the interference as positive if the counter in the PHT entry correctly predicts the branch outcome. Otherwise, they classified the interference as negative. They showed that destructive interference causes branch prediction schemes to operate much below their potential performance level. <p> Gcc's results differed from the other benchmarks because it contains a large number of static branches in its working set. This large set can cause interference in the pattern history tables of the gshare and PAs predictors, reducing their ability to make accurate predictions <ref> [41, 34] </ref>. In addition, the large number of branches can incur a significant training cost. Both the gshare and PAs predictors must train themselves on the first few instances of the branch before they can begin to accurately predict it. <p> The BPST is a 1K-entry table of two bit counters. The misprediction rate in the graph indicates the rate at which the chosen predictor makes incorrect prediction. With the exception of gcc, all four hashing schemes have similar performance. Young et al. [41] and Talcott et al. <ref> [34] </ref> have shown how branch prediction table interference can affect the performance of branch prediction schemes. Similarly, interference in the BPS table can affect the performance of the branch predictor selection mechanism. One advantage of using the branch history is that it reduces BPST interference.
Reference: [35] <author> R. M. Tomasulo, </author> <title> "An efficient algorithm for exploiting multiple arithmetic units," </title> <journal> IBM Journal of Research and Development, </journal> <volume> vol. 11, </volume> <pages> pp. 25-33, </pages> <month> January </month> <year> 1967. </year>
Reference-contexts: Execution in HPS flows as follows: Each cycle, multiple instructions are issued, and using the information in the register files, the instructions are merged into node tables, much like the Tomasulo algorithm merges operations into the reservation stations of the IBM 360/91 <ref> [35] </ref>. Associated with each instruction (node) are the source operands for that instruction (or identifiers for obtaining the operands), and destination information. <p> If the predicate evaluates to false, the predicated instruction writes the old value of the destination register (the implicit operand) back into the destination register. This is done instead of suppressing the execution of the instruction because the machine simulated uses dynamic register renaming <ref> [35, 26] </ref>. For register renaming to function correctly, every issued instruction must eventually produce a value. This requirement has the drawback that it forces every predicated instruction to be part of a dependency 79 chain regardless of the value of its predicate.
Reference: [36] <author> G. S. Tyson, </author> <title> "The effects of predication on branch prediction," </title> <booktitle> in Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 196-206, </pages> <year> 1994. </year>
Reference-contexts: In this case, the full branch execution penalty is suffered. Thus, an excellent branch predictor is vital to deliver the potential performance of a wide-issue deeply-pipelined microarchitecture. This dissertation proposes several mechanisms for increasing the accuracy of branch predictors. Predicated execution <ref> [14, 29, 9, 19, 28, 36, 18, 12] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> However, the restricted guarding model is less effective than the full guarding model in increasing the effective block sizes and the dynamic window sizes. Instead of predicating as many branches as possible, the compiler needs to carefully select the branches to eliminate. Tyson <ref> [36] </ref> studied the performance benefit of predicating all short forward branches. This aggressive approach of predicating branches of distance less than or equal to 12 reduced the number of instruction slots lost due to branches by as much as 50% for the SPEC92 benchmarks.
Reference: [37] <author> T.-Y. Yeh, </author> <title> Two-level adaptive branch prediction and instruction fetch mechanisms for high performance superscalar processors, </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1993. </year>
Reference-contexts: A Motorola MC88110 instruction level simulator (Archsim) reads in the object code and input data; it then simulates execution and produces an instruction trace. The instruction traces are then processed by either the restricted data flow (RDF) simulator [4] or the instruction fetch mechanism (IFM) simulator <ref> [37] </ref>. The RDF simulator simulates the execution of instructions on a given machine model, which is described in a configuration file read by the RDF simulator. The IFM simulator only simulates the actions involved in predicting instruction fetch address.
Reference: [38] <author> T.-Y. Yeh and Y. N. Patt, </author> <title> "Two-level adaptive branch prediction," </title> <booktitle> in Proceedings of the 24th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 51-61, </pages> <year> 1991. </year>
Reference-contexts: An 8KByte 2-bit counter scheme achieves a prediction accuracy of of 87%. By keeping more history information, a higher level of branch prediction accuracy can be attained <ref> [38] </ref>. Yeh and Patt proposed the two-level branch predictor which uses two levels of history to make branch predictions (see Figure 2.1). <p> The 2bC predictor was considered because it is still used by many of the current generation of commercial microprocessors. The PAs and gshare predictors were considered because they are variations of the highest performing single-scheme predictor, the two-level branch predictor <ref> [38, 25, 39, 40, 20] </ref>. For each predictor type, a range of predictor sizes was considered allowing us to vary the amount of hardware devoted to each scheme. The 2bC array size was varied from 2 10 to 2 20 entries. <p> We propose a new technique, the 2-level branch predictor selection mechanism, which uses more run-time information to improve the performance of the predictor selection mechanism. 5.2.1 2-level Branch Predictor Selection Algorithm It is now well-known that the two-level branch predictor improves prediction accuracy over previously known single-level branch predictors <ref> [38] </ref>. The concepts embodied in the two-level branch predictor can also be applied to the hybrid branch predictor selection mechanism. Figure 5.3 shows the structure of the 2-level branch predictor selection mechanism. <p> Two types of branch history information are used to decide which target of the indirect jump will be predicted pattern history and path history. * Branch History It is now well known that the two-level branch predictor improves prediction accuracy over previous single-level branch predictors <ref> [38] </ref>. The two-level predictors attain high prediction accuracies by using pattern history to distinguish different dynamic occurrences of a conditional branch. To predict indirect jumps, the target cache is indexed using branch address and global pattern history.
Reference: [39] <author> T.-Y. Yeh and Y. N. Patt, </author> <title> "Alternative implementations of two-level adaptive branch prediction," </title> <booktitle> in Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 124-134, </pages> <year> 1992. </year>
Reference-contexts: Using more history bits, higher prediction accuracy can be achieved; however, the implementation cost of the predictor also increases with more history bits. Using 15 global history bits, the two-level branch predictor achieves a prediction accuracy of 93.3%. Several variations of the two-level branch predictor have been proposed <ref> [39] </ref>. Mc-Farling [20] introduced gshare, a variation of the global-history two-level branch predictor which XORs the global branch history with the branch address to index into the PHT. <p> The single-scheme predictors examined were divided into four classes: 32 1. static the profile-guided branch predictor [11]. 2. 2bC (n) the two bit counter predictor [32]. It consists of an array of n two bit counters. 3. PAs (k,s) the per-address variation of the Two-Level Adaptive Branch Predictor <ref> [39] </ref> consisting of 1K k-bit branch history registers and s pattern history tables. 4. gshare (k) a modified version of the the two-level branch predictor [20] consist ing of a single k-bit global branch history and a single pattern history table. <p> The 2bC predictor was considered because it is still used by many of the current generation of commercial microprocessors. The PAs and gshare predictors were considered because they are variations of the highest performing single-scheme predictor, the two-level branch predictor <ref> [38, 25, 39, 40, 20] </ref>. For each predictor type, a range of predictor sizes was considered allowing us to vary the amount of hardware devoted to each scheme. The 2bC array size was varied from 2 10 to 2 20 entries.
Reference: [40] <author> T.-Y. Yeh and Y. N. Patt, </author> <title> "A comparison of dynamic branch predictors that use two levels of branch history," </title> <booktitle> in Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 257-266, </pages> <year> 1993. </year>
Reference-contexts: A gshare using 13 history bits achieves a predication accuracy of approximately 92%. Lee and Smith [17] proposed a scheme where the value of each Pattern History Table entry is determined statically, using profile information; this scheme is referred to as the PSg scheme by Yeh and Patt <ref> [40] </ref>. Sechrest et al. [31] introduced another method, PSg (algo), of statically determining the values in the PHT. The PSg (algo) works on the premise that for branches with a recurring pattern, the next outcome of the branch is likely an extension of this pattern. <p> In the past, branch prediction research has focused on accurately predicting direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>; a direct branch has a statically specified target which points to a single location in the program. To predict such branches, the prediction mechanism predicts the branch direction and then generates the target associated with that direction. <p> m88k perlvortex 0% 40% 80% Percentage SC1: 0 &lt;= pr (br) <= 5% SC3: 10 &lt; pr (br) <= 50% SC5: 90 &lt; pr (br) <= 95% SPECint92 SPECint95 Analysis of the Mostly One-direction Branches (SC1,SC2,SC5,SC6) The hardware costs of two-level branch predictors 1 are estimated using the following equations <ref> [40] </ref>: GAs (k; p) = k + (p fi 2 k fi 2) (bits) PAs (k; p) = (b fi k) + (p fi 2 k fi 2) (bits) gshare (k; p) = k + (p fi 2 k fi 2) (bits) where k is the history register length, p is <p> The 2bC predictor was considered because it is still used by many of the current generation of commercial microprocessors. The PAs and gshare predictors were considered because they are variations of the highest performing single-scheme predictor, the two-level branch predictor <ref> [38, 25, 39, 40, 20] </ref>. For each predictor type, a range of predictor sizes was considered allowing us to vary the amount of hardware devoted to each scheme. The 2bC array size was varied from 2 10 to 2 20 entries. <p> We therefore reduce the number of mispredictions by 30% to 38% for the gshare predictor. For gshare/pshare, the number of mispredictions was reduced by 23% to 29%. CHAPTER 7 Indirect Branches 7.1 Characteristics In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [32, 21, 40, 20, 7, 24] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used.
Reference: [41] <author> C. Young, N. Gloy, and M. D. Smith, </author> <title> "A comparative analysis of schemes for correlated branch prediction," </title> <booktitle> in Proceedings of the 22st Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 276-286, </pages> <year> 1995. </year>
Reference-contexts: Recent studies <ref> [34, 41] </ref> have shown that a number of these mispredictions are due to interference in the pattern history tables. <p> PAs using 13 history bits achieves a prediction accuracy of 92.5%. 2.2 Interference in Two-level Branch Predictors The two-level branch predictors have been shown to achieve high prediction accuracy, yet they still suffer a significant number of mispredictions. Recent studies <ref> [34, 41] </ref> have shown that a number of these mispredictions are due to interference in the pattern history tables. Pattern history table interference occurs when a conditional branch references a PHT entry that was last referenced by another conditional branch. <p> Talcott et al. [34] classified the interference as positive if the counter in the PHT entry correctly predicts the branch outcome. Otherwise, they classified the interference as negative. They showed that destructive interference causes branch prediction schemes to operate much below their potential performance level. Young et al. <ref> [41] </ref> classified interference by comparing the outcome of the PHT counter's prediction to the outcome of the prediction made by a predictor that have not PHT interference. <p> Gcc's results differed from the other benchmarks because it contains a large number of static branches in its working set. This large set can cause interference in the pattern history tables of the gshare and PAs predictors, reducing their ability to make accurate predictions <ref> [41, 34] </ref>. In addition, the large number of branches can incur a significant training cost. Both the gshare and PAs predictors must train themselves on the first few instances of the branch before they can begin to accurately predict it. <p> The BPST is a 1K-entry table of two bit counters. The misprediction rate in the graph indicates the rate at which the chosen predictor makes incorrect prediction. With the exception of gcc, all four hashing schemes have similar performance. Young et al. <ref> [41] </ref> and Talcott et al. [34] have shown how branch prediction table interference can affect the performance of branch prediction schemes. Similarly, interference in the BPS table can affect the performance of the branch predictor selection mechanism. One advantage of using the branch history is that it reduces BPST interference.
Reference: [42] <author> C. Young and M. D. Smith, </author> <title> "Improving the accuracy of static branch prediction using branch correlation," </title> <booktitle> in Proceedings of the 6th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 232-241, </pages> <year> 1994. </year>
Reference-contexts: No extra hardware is required to maintain the branch history for the target cache if the branch prediction mechanism already contains this information. The target cache can use the branch predictor's BHR. * Path History Previous research <ref> [42, 24] </ref> has shown that path history can also provide useful correlation information to improve branch prediction accuracy. Path history consists of the target addresses of branches that lead to the current branch. This information is also useful in predicting indirect branch targets.
References-found: 43

