URL: http://www.cs.uoregon.edu/paracomp/proj/papers/conpar94.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/tau/papers.html
Root-URL: http://www.cs.uoregon.edu
Email: fmohr, darrylb, malonyg@cs.uoregon.edu  
Title: TAU: A Portable Parallel Program Analysis Environment for pC  
Author: Bernd Mohr, Darryl Brown, Allen Malony 
Address: 97403, USA  
Affiliation: Department of Computer and Information Science University of Oregon, Eugene, Oregon  
Abstract: The realization of parallel language systems that offer high-level programming paradigms to reduce the complexity of application development, scalable runtime mechanisms to support variable size problem sets, and portable compiler platforms to provide access to multiple parallel architectures, places additional demands on the tools for program development and analysis. The need for integration of these tools into a comprehensive programming environment is even more pronounced and will require more sophisticated use of the language system technology (i.e., compiler and runtime system). Furthermore, the environment requirements of high-level support for the programmer, large-scale applications, and portable access to diverse machines also apply to the program analysis tools. In this paper, we discuss t (TAU, Tuning and Analysis Utilities), a first prototype for an integrated and portable program analysis environment for pC ++ , a parallel object-oriented language system. t is integrated with the pC ++ system in that it relies heavily on compiler and transformation tools (specifically, the Sage ++ toolkit) for its implementation. This paper describes the design and functionality of t and shows its application in practice.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> F. Bodin, P. Beckman, D. Gannon, J. Gotwals, S. Narayana, S. Srinivas, B. Win-nicka, Sage++: </author> <title> An Object Oriented Toolkit and Class Library for Building Fortran and C++ Restructuring Tools, </title> <booktitle> Proc. </booktitle> <address> Oonski '94, Oregon, </address> <year> 1994. </year>
Reference-contexts: The most difficult challenge to the development of t is in determining what low-level performance (or debugging) instrumentation must be specified for capturing high-level execution abstractions, then translating performance data back to the application/language level. (R3) Integration with compilers and runtime systems. t uses the Sage ++ toolkit <ref> [1] </ref> as an interface to the pC ++ compiler for instrumentation and accessing properties of program objects. t is also integrated with the run time system of pC ++ for profiling and tracing support. (R4) Portability, extensibility, and retargetability.
Reference: 2. <author> V. Herrarte, E. Lusk, </author> <title> Studying Parallel Program Behavior with Upshot, </title> <type> Technical Report ANL-91/15, </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Fig. 1. t Tools Architecture The program and performance analysis environment is shown on the right side. They include the TAU tools, profiling and tracing support, and interfaces to performance analysis tools developed by other groups <ref> [2, 5, 10] </ref>. In the following, the t static and dynamic tools are described in more detail. 4 Static Analysis Tools One of the basic motivations behind using C ++ as the base for a new parallel language is its proven support for developing and maintaining complex and large applications. <p> Trace Conversion: The utility tool se convert converts traces to the SDDF format used with the Pablo performance analysis environment [10] or to the ALOG format used in the Upshot event display tool <ref> [2] </ref>. It also can produce a simple user-readable ASCII dump of the binary trace. Trace Analysis and Visualization: The trace files can also be processed directly with the SIMPLE event trace analysis and visualization environment or other tools based on the TDL/POET event trace interface [5].
Reference: 3. <author> A. Chien and W. Dally. </author> <title> Concurrent Aggregates (CA), </title> <booktitle> Proc. 2nd ACM Sigplan Symposium on Principles & Practice of Parallel Programming, </booktitle> <address> Seattle, Washington, </address> <month> March, </month> <year> 1990. </year>
Reference-contexts: The basic concept behind pC ++ is the notion of a distributed collection, which is a type of concurrent aggregate "container class" <ref> [3] </ref>. More specifically, a collection is a structured set of objects which are distributed across the processing elements of the computer in a manner designed to be completely consistent with HPF Fortran [4].
Reference: 4. <author> High Performance Fortran Forum, </author> <title> High Performance Fortran Language Specification, </title> <note> 1993. Available from titan.cs.rice.edu by anonymous ftp. </note>
Reference-contexts: Consequently, tool users are given little support for "translating" program-level semantics to and from low-level execution measurements and runtime data. (R2) Support for high-level, parallel programming languages. The development of advanced parallel languages (e.g., HPF <ref> [4] </ref> and pC++ [8]) further separates ? This research is supported by ARPA under Rome Labs contract AF 30602-92-C-0135 the user from execution-time reality because of complex transformations and optimizations that take place between the layers of language abstraction, runtime paradigm, and execution environment. (R3) Integration with compilers and runtime systems. <p> More specifically, a collection is a structured set of objects which are distributed across the processing elements of the computer in a manner designed to be completely consistent with HPF Fortran <ref> [4] </ref>. To accomplish this, pC ++ provides a very simple mechanism to build "collections of objects" from a base element class. Member functions from this element class can be applied to the entire collection (or a subset) in parallel.
Reference: 5. <author> B. Mohr, </author> <title> Standardization of Event Traces Considered Harmful or Is an Implementation of Object-Independent Event Trace Monitoring and Analysis Systems Possible?, </title> <booktitle> Proc. CNRS-NSF Workshop on Environments and Tools For Parallel Scientific Computing, </booktitle> <address> St. Hilaire du Touvet, France, Elsevier, </address> <booktitle> Advances in Parallel Computing, </booktitle> <volume> Vol. 6, </volume> <pages> pp. 103-124, </pages> <year> 1993. </year>
Reference-contexts: Fig. 1. t Tools Architecture The program and performance analysis environment is shown on the right side. They include the TAU tools, profiling and tracing support, and interfaces to performance analysis tools developed by other groups <ref> [2, 5, 10] </ref>. In the following, the t static and dynamic tools are described in more detail. 4 Static Analysis Tools One of the basic motivations behind using C ++ as the base for a new parallel language is its proven support for developing and maintaining complex and large applications. <p> It also can produce a simple user-readable ASCII dump of the binary trace. Trace Analysis and Visualization: The trace files can also be processed directly with the SIMPLE event trace analysis and visualization environment or other tools based on the TDL/POET event trace interface <ref> [5] </ref>. These tools use the Trace Description Language (TDL) output of the Instrumentor to access the trace files. 5.4 Easy Easy (Event And State displaY) is an Upshot-like event and state display tool based on the ALOG event trace format.
Reference: 6. <author> J. K. Ousterhout, </author> <title> Tcl: An Embeddable Command Language, </title> <booktitle> Proc. 1990 Winter USENIX Conference. </booktitle>
Reference-contexts: Because pC ++ is intended to be portable, the tools have to be portable as well. We are using C ++ and C to ensure an efficient, portable, and reusable implementation. The same reason led us to choose Tcl/Tk <ref> [6, 7] </ref> for the graphical interface. The t tools are implemented as graphical hypertools. While they are distinct tools, they act in concert as if they were a single application. Each tool implements some defined tasks.
Reference: 7. <author> J. K. Ousterhout, </author> <title> An X11 Toolkit Based on the Tcl Language, </title> <booktitle> Proc. 1991 Winter USENIX Conference. </booktitle>
Reference-contexts: Because pC ++ is intended to be portable, the tools have to be portable as well. We are using C ++ and C to ensure an efficient, portable, and reusable implementation. The same reason led us to choose Tcl/Tk <ref> [6, 7] </ref> for the graphical interface. The t tools are implemented as graphical hypertools. While they are distinct tools, they act in concert as if they were a single application. Each tool implements some defined tasks.
Reference: 8. <author> F. Bodin, P. Beckman, D. Gannon, S. Yang, S. Kesavan, A. Malony, B. Mohr, </author> <title> Implementing a Parallel C++ Runtime System for Scalable Parallel Systems, </title> <booktitle> Proc. 1993 Supercomputing Conference, Portland, Oregon, </booktitle> <pages> pp. 588-597, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Consequently, tool users are given little support for "translating" program-level semantics to and from low-level execution measurements and runtime data. (R2) Support for high-level, parallel programming languages. The development of advanced parallel languages (e.g., HPF [4] and pC++ <ref> [8] </ref>) further separates ? This research is supported by ARPA under Rome Labs contract AF 30602-92-C-0135 the user from execution-time reality because of complex transformations and optimizations that take place between the layers of language abstraction, runtime paradigm, and execution environment. (R3) Integration with compilers and runtime systems. <p> The ports include the Intel Paragon, TMC CM-5, IBM SP-1, Kendall Square Research KSR-1, Sequent Symmetry, BBN TC2000, and workstations clusters using PVM; ports to the Cray T3D and Meiko CS-2 are in progress. More details about the pC ++ language and runtime system can be found in <ref> [8, 9] </ref>. 2.1 An Observability and Analysis Model for pC ++ Collection definition and use are the key aspects for program analysis in the pC ++ system.
Reference: 9. <author> A. Malony, B. Mohr, P. Beckman, D. Gannon, S. Yang, F. Bodin, </author> <title> Performance Analysis of pC++: A Portable Data-Parallel Programming System for Scalable Parallel Computers, </title> <booktitle> Proc. 8th Int. Parallel Processing Symb. (IPPS), </booktitle> <address> Cancun, Mexico, </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 75-85, </pages> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: The ports include the Intel Paragon, TMC CM-5, IBM SP-1, Kendall Square Research KSR-1, Sequent Symmetry, BBN TC2000, and workstations clusters using PVM; ports to the Cray T3D and Meiko CS-2 are in progress. More details about the pC ++ language and runtime system can be found in <ref> [8, 9] </ref>. 2.1 An Observability and Analysis Model for pC ++ Collection definition and use are the key aspects for program analysis in the pC ++ system. <p> Before presenting the t dynamic analysis tools racy and easy, we briefly describe the approach used to implement profiling and tracing in pC ++ (see <ref> [9] </ref> for more details). 5.1 Portable Profiling for C ++ and Languages Based on C ++ A very valuable tool for program tuning is function profiling. <p> With this support, we have been able to validate performance scalability claims of the language and characterize important performance factors of the runtime system ports during pC ++ system development <ref> [9] </ref>. As a consequence, the first version of the compiler is being introduced with an extensive set of performance experiments already documented. The t environment demonstrates the advantages of language-specific program analysis tools. Its design and integration with the pC++ language system allows important programming productivity issues to be addressed.
Reference: 10. <author> D. A. Reed, R. D. Olson, R. A. Aydt, T. M. Madhyasta, T. Birkett, D. W. Jensen, B. A. A. Nazief, B. K. Totty, </author> <title> Scalable Performance Environments for Parallel Systems. </title> <booktitle> Proc. 6th Distributed Memory Computing Conference, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 562-569, </pages> <year> 1991. </year>
Reference-contexts: Fig. 1. t Tools Architecture The program and performance analysis environment is shown on the right side. They include the TAU tools, profiling and tracing support, and interfaces to performance analysis tools developed by other groups <ref> [2, 5, 10] </ref>. In the following, the t static and dynamic tools are described in more detail. 4 Static Analysis Tools One of the basic motivations behind using C ++ as the base for a new parallel language is its proven support for developing and maintaining complex and large applications. <p> Trace Conversion: The utility tool se convert converts traces to the SDDF format used with the Pablo performance analysis environment <ref> [10] </ref> or to the ALOG format used in the Upshot event display tool [2]. It also can produce a simple user-readable ASCII dump of the binary trace.
Reference: 11. <author> V. S. Sunderam, </author> <title> PVM: A Framework for Parallel Distributed Computing, </title> <journal> Concur-rency: Practice & Experience, </journal> <volume> Vol. 2, No. 4, </volume> <pages> pp. 315-339, </pages> <month> December </month> <year> 1990. </year>
References-found: 11

