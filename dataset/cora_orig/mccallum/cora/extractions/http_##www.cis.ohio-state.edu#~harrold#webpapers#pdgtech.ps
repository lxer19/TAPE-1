URL: http://www.cis.ohio-state.edu/~harrold/webpapers/pdgtech.ps
Refering-URL: http://www.cis.ohio-state.edu/~harrold/788.12p/readings.html
Root-URL: 
Email: fharrold,grotherg@cis.ohio-state.edu  
Title: Syntax-Directed Construction of Program Dependence Graphs  
Author: Mary Jean Harrold and Gregg Rothermel 
Keyword: control dependence, control flow, data flow, program dependence graphs, software testing.  
Address: Columbus, OH 43210-1277  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: We present an algorithm that constructs program dependence graphs as a program is parsed. For programs that contain only structured transfers of control, our algorithm does not require explicit control flow or postdominator information to compute exact control dependencies. For programs that contain explicit transfers of control, our algorithm can determine whether these transfers of control are used in a structured way, and if so, compute control dependencies without explicit control flow or postdominator information. When transfers of control are ill-behaved, our algorithm adjusts the control dependence information computed during the parse, to obtain exact control dependencies. For many programs, our algorithm provides savings in time and memory, because it does not require prior computation of control flow or postdominator information. However, our algorithm also calculates control flow information during the parse, and incorporates this information into the program dependence graphs that it constructs; the resulting graphs have a wider range of applicability than graphs that do not contain this information. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal and J. Horgan, </author> <title> "Dynamic program slicing," </title> <booktitle> Proceedings of ACM SIGPLAN '90 Symposium on Programming Language Design and Implementation, </booktitle> <pages> pp. 246-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Additionally, techniques that integrate different versions of programs [28] require control and data dependence information. Finally, both static and dynamic slicing techniques require control and data dependence information <ref> [1, 2, 40] </ref>. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information.
Reference: [2] <author> H. Agrawal, R. DeMillo and E. Spafford, </author> <title> "Dynamic slicing in the presence of unconstrained pointers," </title> <booktitle> Proceedings of the Symposium on Testing, Analysis and Verification, </booktitle> <pages> pp. 60-73, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Additionally, techniques that integrate different versions of programs [28] require control and data dependence information. Finally, both static and dynamic slicing techniques require control and data dependence information <ref> [1, 2, 40] </ref>. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information.
Reference: [3] <author> H. Agrawal, J. Horgan, E. Krauser and S. </author> <title> London, "Incremental regression testing," </title> <booktitle> Proceedings of the Conference on Software Maintenance '92, </booktitle> <pages> pp. 348-357, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Some techniques use control or data dependence information to select test data and determine test set adequacy [31], to extend data flow testing techniques [12], or to generate reduced test sets for programs [15]. Several techniques for regression testing <ref> [3, 7, 8, 16, 37, 38] </ref> use control or data dependence information to determine the retesting required after changes are made to a program. Additionally, techniques that integrate different versions of programs [28] require control and data dependence information.
Reference: [4] <author> A. Aho, R. Sethi and J. Ullman, </author> <booktitle> Compilers, Principles, Techniques and Tools, </booktitle> <publisher> Additon-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: Additionally, techniques that integrate different versions of programs [28] require control and data dependence information. Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis <ref> [4] </ref>, data flow testing [14, 33, 34, 36], test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information. <p> Output-dependence edges connect particular definitions of the same variable. Traditional data flow analysis algorithms fall into two major categories: iterative algorithms and elimination algorithms <ref> [4] </ref>. Either of these techniques can be applied to our CDS to compute data flow information. We first discuss our adaptation of iterative algorithms to work on our CDS, and then discuss the adaptation of elimination algorithms to use our CDS. <p> Further experimentation with the two prototypes revealed that the bottleneck in the FOW prototype is the computation of postdominator information. To compute postdominator information for a function, the FOW prototype uses a straightforward algorithm that runs in time quadratic in the size of the function <ref> [4] </ref>. To illustrate the impact of postdominator computation on CDS construction time, column 4 of Table 4 records the time that the FOW prototype required to construct the CDS for each program excluding the cost of postdominator computation.
Reference: [5] <author> T. Ball and J. Larus, </author> <title> "Optimally profiling and tracing programs," </title> <booktitle> Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling <ref> [5] </ref> require control flow information. A program dependence graph (PDG) [13], in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information.
Reference: [6] <author> R. Ballance and B. Maccabe, </author> <title> "Program dependence graphs for the rest of us," </title> <type> Technical Report, </type> <institution> University of New Mexico, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Because our algorithm provides syntax directed construction of PDGs without first computing control flow or postdominance information, it requires less time and space than traditional approaches for constructing PDGs. Ballance and Maccabe also presented a syntax directed technique for computing control dependence <ref> [6] </ref>. Unlike their technique, our algorithm computes control dependencies correctly for control structures that contain exit statements or multiple transfers of control. <p> When P2 is true, control flows back to S1. However, when P2 is false, statements after the if-else (S4 in the figure) are executed. Thus, statements after the if-else statement are control dependent on P2. Ballance and Maccabe <ref> [6] </ref> present the concept of follow regions to account for such control dependencies. A follow region summarizes the control dependencies for statements that appear after a compound statement. <p> For Fragment B, a summary region R is created and made control dependent on P2-false and P3-false, and S6 is inserted into the graph as a child of R. It is not clear from the discussion in Reference <ref> [6] </ref> how Ballance and Maccabe's algorithm creates these summary regions. ConstructCDS uses the concept of follow regions to construct CDSs for procedures that contains structured control transfer statements. <p> Therefore, S 1 is control dependent on P with label :L. 2 8 Our definition of predicate path is similar to that of Reference <ref> [6] </ref>. 9 Ballance and Maccabe [6] also define control dependence negation. However, their definition is inadequate in certain cases; our definition corrects theirs. 10 Lemma 1 is restated from Reference [6] with modifications. <p> Therefore, S 1 is control dependent on P with label :L. 2 8 Our definition of predicate path is similar to that of Reference <ref> [6] </ref>. 9 Ballance and Maccabe [6] also define control dependence negation. However, their definition is inadequate in certain cases; our definition corrects theirs. 10 Lemma 1 is restated from Reference [6] with modifications. <p> control dependent on P with label :L. 2 8 Our definition of predicate path is similar to that of Reference <ref> [6] </ref>. 9 Ballance and Maccabe [6] also define control dependence negation. However, their definition is inadequate in certain cases; our definition corrects theirs. 10 Lemma 1 is restated from Reference [6] with modifications. We use control dependence instead of immediate control dependence in keeping with the traditional definition of control dependence [13], i.e., a node cannot postdominate itself. <p> Thus, S 1 is control dependent on :(P n+1 ). Case 2: P n+1 is a predicate that controls a while statement. Clearly, S 1 is reached if :P n+1 . 11 Theorem 1 is also restated from Reference <ref> [6] </ref>. However, our definition of differs. 15 Consider the case when S is entered. Every path through S that avoids T reaches the while header where it again enters S, and could reach T . <p> Because we wanted to illustrate the construction of summary regions, we illustrated the CDS in Figure 11 before regions R7 and R8 were combined. 3.1.3 Handling Goto Statements Many goto statements in a program are used as multilevel continues or breaks <ref> [6] </ref>. In these cases, ConstructCDS constructs the CDS from the AST without requiring control flow information. To do this, the algorithm uses 22 techniques that are similar to those used to handle continue and break statements. <p> When programs are structured, elimination algorithms based on interval analysis [39, 43] can be adapted to use the CDS instead of the control flow graph <ref> [6] </ref>. In these cases, the control flow graph is not required in the analysis. However, if the program is highly unstructured or irreducible, these elimination algorithms may produce incorrect data flow information, and thus, these algorithms may require the use of iterative algorithms for some parts of the program. <p> In this case, control flow information is required. An advantage of our CDS construction algorithm over that of Ballance and Maccabe <ref> [6] </ref> is that our algorithm computes control flow information as a program is parsed.
Reference: [7] <author> S. Bates and S. Horwitz, </author> <title> "Incremental testing using program dependence graphs," </title> <booktitle> Proceedings of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 384-396, </pages> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: Some techniques use control or data dependence information to select test data and determine test set adequacy [31], to extend data flow testing techniques [12], or to generate reduced test sets for programs [15]. Several techniques for regression testing <ref> [3, 7, 8, 16, 37, 38] </ref> use control or data dependence information to determine the retesting required after changes are made to a program. Additionally, techniques that integrate different versions of programs [28] require control and data dependence information.
Reference: [8] <author> D. Binkley, </author> <title> "Using semantic differencing to reduce the cost of regression testing," </title> <booktitle> Proceedings of the Conference on Software Maintenance '92, </booktitle> <pages> pp. 41-50, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Some techniques use control or data dependence information to select test data and determine test set adequacy [31], to extend data flow testing techniques [12], or to generate reduced test sets for programs [15]. Several techniques for regression testing <ref> [3, 7, 8, 16, 37, 38] </ref> use control or data dependence information to determine the retesting required after changes are made to a program. Additionally, techniques that integrate different versions of programs [28] require control and data dependence information.
Reference: [9] <author> R. Cytron, J. Ferrante and V. Sarkar, </author> <title> "Compact representations for control dependence," </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> vol. 25, no. 6, </volume> <pages> pp. 337-351, </pages> <month> June </month> <year> 1990. </year>
Reference: [10] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman and F. Zadeck, </author> <title> "Efficiently computing static single assignment form and the control dependence graph," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 13, no. 4, </volume> <pages> pp. 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: A program dependence graph (PDG) [13], in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information. Most existing techniques for PDG construction <ref> [10, 13] </ref> rely on explicit control flow and postdominance information to identify control dependencies and compute data dependence information. In most cases when programs contain goto statements, explicit control flow and postdominance information are prerequisites for identifying control dependencies. <p> In the case of unstructured transfers of control, the running time of ConstructCDS is dominated by the time required to adjust the CDS to represent exact control dependencies, which can take quadratic time in the worst case <ref> [10] </ref>. Thus, the running time of ConstructCDS for unstructured transfers of control is also quadratic in the number of statements in the program. 3.1.6 Improvements to ConstructCDS As we mentioned above, to facilitate presentation, we have presented our algorithm as if it were traversing the AST.
Reference: [11] <author> R. DeMillo, D. Guindi, K. King, W. M. McCracken, and A. J. Offutt, </author> <title> "An extended overview of the Mothra software testing environment," </title> <booktitle> Proceedings of the Second Workshop on Software Testing, Verification, and Analysis, </booktitle> <pages> pp. 142-151, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: A preliminary presentation of this work appeared as "Efficient construction of program dependence graphs," in ACM International Symposium on Software Testing and Analysis '93. 1 GNU C compiler gcc 2 [41], UNIX 3 utilities, SPEC benchmarks, 4 and Mothra software testing system <ref> [11] </ref>, we found that over 95 percent of the functions contain no goto statements. Our research shows that for these programs, we can construct PDGs without the use of explicit control flow or postdominance information. Moreover, the resulting PDGs represent control flow in addition to control and data dependence information. <p> Study 2 Our second study investigated 3066 C functions from the GNU C compiler gcc 15 [41], UNIX 16 utilities, SPEC benchmarks, 17 and Mothra software testing system <ref> [11] </ref>, to determine how often our algorithm constructs the CDS during the program's parse, without needing to adjust control dependencies.
Reference: [12] <author> E. Duesterwald, R. Gupta and M. L. Soffa, </author> <title> "Rigorous data flow testing through output influences," </title> <booktitle> Proceedings of the 2nd Irvine Software Symposium (ISS'92), </booktitle> <pages> pp. 131-145, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many program testing and analysis techniques rely on control dependence or data dependence information. Some techniques use control or data dependence information to select test data and determine test set adequacy [31], to extend data flow testing techniques <ref> [12] </ref>, or to generate reduced test sets for programs [15]. Several techniques for regression testing [3, 7, 8, 16, 37, 38] use control or data dependence information to determine the retesting required after changes are made to a program.
Reference: [13] <author> J. Ferrante, K. J. Ottenstein and J. D. Warren, </author> <title> "The program dependence graph and its use in optimization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information. A program dependence graph (PDG) <ref> [13] </ref>, in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information. Most existing techniques for PDG construction [10, 13] rely on explicit control flow and postdominance information to identify control dependencies and compute data dependence information. <p> A program dependence graph (PDG) [13], in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information. Most existing techniques for PDG construction <ref> [10, 13] </ref> rely on explicit control flow and postdominance information to identify control dependencies and compute data dependence information. In most cases when programs contain goto statements, explicit control flow and postdominance information are prerequisites for identifying control dependencies. <p> Appendix A gives a detailed version of our algorithm. 2 Background A program dependence graph 5 (PDG) encodes control dependencies in a control dependence subgraph (CDS). Control dependence is defined in terms of control flow graphs and the postdominance relation, as follows <ref> [13] </ref>. <p> S8 is control dependent on P7-false, and S4 and P5 are control dependent on P3-false. The nodes in a CDS represent single statements, or regions of code that have common control dependencies. The CDS for Sums.1, constructed using the Ferrante, Ottenstein, and Warren method <ref> [13] </ref>, is shown in the center of Figure 1. A CDS contains several types of nodes. Statement nodes, shown as ellipses, represent simple statements. Predicate nodes, depicted as squares, correspond to statements from which two edges may originate. <p> In each case, the algorithm adjusts control dependence and control flow edges that involve deleted region nodes. Note that the control dependence subgraph construction algorithm described in Reference <ref> [13] </ref> also performs a post-pass of the CDS to remove region nodes of the second type. Example AST. We now trace the operations of ConstructCDS for this example, omitting reference to actions that involve TransferList and RegionTable because they are not required when processing structured programs. <p> Consider Fragment C of Figure 7, in which the while loop contains an exit statement. In this case, Ballance and Maccabe's algorithm computes the control dependencies for S7 as "P1-false or P2-false". According to the traditional definition of control dependence <ref> [13] </ref>, however, S7 is control dependent only on P1-false: there is no path from P2 to S7 on which every node other than P2 and S7 is postdominated by S7. Ballance and Maccabe's approach also may calculate incorrect control dependencies for statements that follow while loops that contain break statements. <p> Fragment B of Figure 7 also illustrates a fourth insufficiency in Ballance and Maccabe's approach, which occurs when statements have multiple control dependencies. In the fragment, S6 is control dependent on P2-false or P3-false. However, by definition <ref> [13] </ref>, a statement node in a control dependence graph can be a control dependence successor of only one region. If a statement is control dependent on multiple predicates, a summary region, that summarizes these control dependencies, is required. <p> ConstructCDS uses the concept of follow regions to construct CDSs for procedures that contains structured control transfer statements. However, ConstructCDS computes control dependencies that agree with those computed by the traditional algorithm <ref> [13] </ref>, and does not exhibit the inadequacies of Ballance and Maccabe's approach. <p> However, their definition is inadequate in certain cases; our definition corrects theirs. 10 Lemma 1 is restated from Reference [6] with modifications. We use control dependence instead of immediate control dependence in keeping with the traditional definition of control dependence <ref> [13] </ref>, i.e., a node cannot postdominate itself. We also relate the control dependence of the first statement in S.follow to the postdominance relation with respect to the target of the transfer of control. 14 To understand the implications of Lemma 1, consider Figure 8. <p> In the first study, we compared the running time of a prototype implementation of ConstructCDS to the running time of an prototype implementation of a traditional CDS construction algorithm <ref> [13] </ref>. In the second study, we analyzed a number of C programs to determine how often our ConstructCDS algorithm could be used without requiring a call to Adjust (). Study 1 Our ConstructCDS prototype takes a C source file, possibly containing multiple functions, as input. <p> The prototype also collects local data flow information during the parse, and attaches GEN, KILL, DEF, and USE sets to CDS nodes. At present, however, the prototype does not implement the Adjust procedure. We implemented the algorithm described in Reference <ref> [13] </ref> as part of the Aristotle program analysis toolkit [24]; we refer to that implementation as the "FOW prototype". Like our ConstructCDS prototype, the FOW prototype takes a C source file, possibly containing multiple procedures, as input.
Reference: [14] <author> P. Frankl and E. Weyuker, </author> <title> "An applicable family of data flow testing criteria," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 14, no. 10, </volume> <pages> pp. 1483-1498, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing <ref> [14, 33, 34, 36] </ref>, test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information.
Reference: [15] <author> R. Gupta and M. L. Soffa, </author> <title> "Automatic generation of a compact test suite," </title> <booktitle> Proceedings of the Twelfth IFIP World Computer Congress, </booktitle> <month> September </month> <year> 1992. </year> <month> 34 </month>
Reference-contexts: 1 Introduction Many program testing and analysis techniques rely on control dependence or data dependence information. Some techniques use control or data dependence information to select test data and determine test set adequacy [31], to extend data flow testing techniques [12], or to generate reduced test sets for programs <ref> [15] </ref>. Several techniques for regression testing [3, 7, 8, 16, 37, 38] use control or data dependence information to determine the retesting required after changes are made to a program. Additionally, techniques that integrate different versions of programs [28] require control and data dependence information.
Reference: [16] <author> R. Gupta, M. J. Harrold and M. L. Soffa, </author> <title> "An approach to regression testing using slicing", </title> <booktitle> Proceedings of the Conference on Software Maintenance '92, </booktitle> <pages> pp. 299-308, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Some techniques use control or data dependence information to select test data and determine test set adequacy [31], to extend data flow testing techniques [12], or to generate reduced test sets for programs [15]. Several techniques for regression testing <ref> [3, 7, 8, 16, 37, 38] </ref> use control or data dependence information to determine the retesting required after changes are made to a program. Additionally, techniques that integrate different versions of programs [28] require control and data dependence information.
Reference: [17] <author> M. J. Harrold and M. L. Soffa, </author> <title> "An incremental approach to unit testing during maintenance," </title> <booktitle> Proceedings of the Conference on Software Maintenance '88, </booktitle> <pages> pp. 362-367, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing <ref> [17, 25, 35, 42] </ref>, and dynamic execution profiling [5] require control flow information. A program dependence graph (PDG) [13], in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information.
Reference: [18] <author> M. J. Harrold and B. A. Malloy, </author> <title> "Performing data flow analysis on the PDG", </title> <type> Technical Report 92-108, </type> <institution> Clemson University, </institution> <month> March </month> <year> 1992. </year>
Reference: [19] <author> M. J. Harrold and B. A. Malloy, </author> <title> "Data flow testing of parallelized code," </title> <booktitle> Proceedings of the Conference on Software Maintenance '92, </booktitle> <pages> pp. 272-281, </pages> <month> November </month> <year> 1992. </year>
Reference: [20] <author> M. J. Harrold, B. A. Malloy and G. Rothermel, </author> <title> "Efficient construction of program dependence graphs," </title> <type> Technical Report 92-128 Clemson University, </type> <month> December </month> <year> 1992. </year>
Reference: [21] <author> M. J. Harrold and G. Rothermel, </author> <title> "A system for analysis and testing of C programs", </title> <booktitle> Proceedings of Quality Week '93, </booktitle> <month> May </month> <year> 1993. </year>
Reference: [22] <author> M. J. Harrold and B. A. Malloy, </author> <title> "A unified interprocedural program representation for a maintenance environment," </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. 584-593, </pages> <month> June </month> <year> 1993. </year>
Reference: [23] <author> M. J. Harrold, </author> <title> "Performing data flow testing in parallel," </title> <booktitle> Proceedings of the 8th International Parallel Processing Symposium (IPPS), </booktitle> <pages> pp. 200-207, </pages> <month> April </month> <year> 1994. </year>
Reference: [24] <author> M. J. Harrold, L. Larsen, J. Lloyd, D. Nedved, M. Page, G. Rothermel,M. Singh, M. Smith, "Aristotle: </author> <title> A system for development of program analysis based tools," </title> <booktitle> Proceedings of 33rd Southeast Conference, </booktitle> <pages> pp. 110-119, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: The prototype also collects local data flow information during the parse, and attaches GEN, KILL, DEF, and USE sets to CDS nodes. At present, however, the prototype does not implement the Adjust procedure. We implemented the algorithm described in Reference [13] as part of the Aristotle program analysis toolkit <ref> [24] </ref>; we refer to that implementation as the "FOW prototype". Like our ConstructCDS prototype, the FOW prototype takes a C source file, possibly containing multiple procedures, as input. For each function F in the source file, the prototype constructs the control flow graph for F during the parse.
Reference: [25] <author> J. Hartmann and D. Robson, </author> <title> "Techniques for selective revalidation," </title> <journal> IEEE Software, </journal> <pages> pp. 31-36, </pages> <month> Jan-uary </month> <year> 1990. </year>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing <ref> [17, 25, 35, 42] </ref>, and dynamic execution profiling [5] require control flow information. A program dependence graph (PDG) [13], in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information.
Reference: [26] <author> C. A. R. Hoare, </author> <title> "Algorithm 65: FIND," </title> <journal> Communications of the ACM, </journal> <volume> vol. 4, no. 1, </volume> <pages> pp. 321-322, </pages> <month> July </month> <year> 1961. </year>
Reference-contexts: partitions elements of an array so that all elements to the left of an indexed location are less than or equal to the value of the array at that index, and all elements to the right are greater than or equal to the value of the array at that index <ref> [26, 27] </ref> Mid.c finds the middle value of three integers Search.c uses binary search to find the location of an element or a location where new element should be inserted Secant.c computes the square root of a number using the secant method Table 2: Descriptions of our subject programs. 4 Implementation
Reference: [27] <author> C. A. R. Hoare, </author> <title> "Proof of a Program: FIND," </title> <journal> Communications of the ACM, </journal> <volume> vol. 14, no. 1, </volume> <pages> pp. 39-45, </pages> <month> January </month> <year> 1971. </year>
Reference-contexts: partitions elements of an array so that all elements to the left of an indexed location are less than or equal to the value of the array at that index, and all elements to the right are greater than or equal to the value of the array at that index <ref> [26, 27] </ref> Mid.c finds the middle value of three integers Search.c uses binary search to find the location of an element or a location where new element should be inserted Secant.c computes the square root of a number using the secant method Table 2: Descriptions of our subject programs. 4 Implementation
Reference: [28] <author> S. Horwitz, J. Prins and R. Reps, </author> <title> "Integrating non-interfering versions of programs," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 11, no. 3, </volume> <pages> pp. 345-387, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Several techniques for regression testing [3, 7, 8, 16, 37, 38] use control or data dependence information to determine the retesting required after changes are made to a program. Additionally, techniques that integrate different versions of programs <ref> [28] </ref> require control and data dependence information. Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information.
Reference: [29] <author> S. Horwitz, T. Reps and D. Binkley, </author> <title> "Interprocedural slicing using dependence graphs," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 12, no. 1, </volume> <pages> pp. 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference: [30] <author> B. Kernighan and D. Ritchie, </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1978. </year>
Reference-contexts: our CDS can be used to correctly compute data flow information for all types of programs. 29 Program Functionality Bub.c sorts a five integer array using bubble sort Bisect.c finds the square root of a number using interval bisection Calc.c implements a reverse Polish calculator described in Kernighan and Ritchie <ref> [30] </ref> Euclid.c implements Euclid's algorithm to compute the greatest common divisor of two integers Find.c partitions elements of an array so that all elements to the left of an indexed location are less than or equal to the value of the array at that index, and all elements to the right
Reference: [31] <author> B. Korel, </author> <title> "The program dependence graph in static program testing," </title> <journal> Information Processing Letters, </journal> <volume> vol. 24, </volume> <pages> pp. 103-108, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Many program testing and analysis techniques rely on control dependence or data dependence information. Some techniques use control or data dependence information to select test data and determine test set adequacy <ref> [31] </ref>, to extend data flow testing techniques [12], or to generate reduced test sets for programs [15]. Several techniques for regression testing [3, 7, 8, 16, 37, 38] use control or data dependence information to determine the retesting required after changes are made to a program.
Reference: [32] <author> B. Korel, </author> <title> "Automated software test data generation," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 16, no. 8, </volume> <pages> pp. 870-879, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation <ref> [32] </ref>, regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information. A program dependence graph (PDG) [13], in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information.
Reference: [33] <author> J. Laski and B. Korel, </author> <title> "A data flow oriented program testing strategy," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 347-354, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing <ref> [14, 33, 34, 36] </ref>, test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information.
Reference: [34] <author> S. Ntafos, </author> <title> "An evaluation of required element testing strategies," </title> <booktitle> Proceedings of the Seventh International Conference on Software Engineering, </booktitle> <pages> pp. 250-256, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing <ref> [14, 33, 34, 36] </ref>, test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information.
Reference: [35] <author> T. Ostrand and E. Weyuker, </author> <title> "Using data flow analysis for regression testing," </title> <booktitle> Proceedings of Sixth Annual Pacific Northwest Software Quality Conference, </booktitle> <pages> pp. 58-71, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing <ref> [17, 25, 35, 42] </ref>, and dynamic execution profiling [5] require control flow information. A program dependence graph (PDG) [13], in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information.
Reference: [36] <author> S. Rapps and E. Weyuker, </author> <title> "Selecting software test data using data flow information," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 11, no. 4, </volume> <pages> pp. 367-375, </pages> <month> April </month> <year> 1985. </year> <month> 35 </month>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing <ref> [14, 33, 34, 36] </ref>, test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information.
Reference: [37] <author> G. Rothermel and M. J. </author> <title> Harrold "A safe, efficient algorithm for regression test selection," </title> <booktitle> Proceedings of the Conference on Software Maintenance '93, </booktitle> <pages> pp. 358-367, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Some techniques use control or data dependence information to select test data and determine test set adequacy [31], to extend data flow testing techniques [12], or to generate reduced test sets for programs [15]. Several techniques for regression testing <ref> [3, 7, 8, 16, 37, 38] </ref> use control or data dependence information to determine the retesting required after changes are made to a program. Additionally, techniques that integrate different versions of programs [28] require control and data dependence information.
Reference: [38] <author> G. Rothermel and M.J. Harrold, </author> <title> "Selecting tests and identifying test coverage requirements for modified software", </title> <booktitle> Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA 94), </booktitle> <pages> pp. 169-184, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Some techniques use control or data dependence information to select test data and determine test set adequacy [31], to extend data flow testing techniques [12], or to generate reduced test sets for programs [15]. Several techniques for regression testing <ref> [3, 7, 8, 16, 37, 38] </ref> use control or data dependence information to determine the retesting required after changes are made to a program. Additionally, techniques that integrate different versions of programs [28] require control and data dependence information.
Reference: [39] <author> B. G. Ryder and M. C. Paull, </author> <title> "Elimination algorithms for data flow analysis," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 18, no. 3, </volume> <pages> pp. 277-316, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: If N is a statement node, IN [N] is the union of the OUT sets of its control flow predecessors, and OUT [N] is synthesized using IN [N], GEN [N] and KILL [N]. When programs are structured, elimination algorithms based on interval analysis <ref> [39, 43] </ref> can be adapted to use the CDS instead of the control flow graph [6]. In these cases, the control flow graph is not required in the analysis.
Reference: [40] <author> E. Schatz and B. G. Ryder, </author> <title> "Directed tracing to detect race conditions," </title> <institution> LCSR-TR-176, Laboratory for Computer Science Research, Rutgers University, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Additionally, techniques that integrate different versions of programs [28] require control and data dependence information. Finally, both static and dynamic slicing techniques require control and data dependence information <ref> [1, 2, 40] </ref>. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing [17, 25, 35, 42], and dynamic execution profiling [5] require control flow information.
Reference: [41] <author> R. M. Stallman, </author> <title> "Using and porting GNU CC," Free Software Foundation, </title> <publisher> Inc., </publisher> <address> Cambridge MA, </address> <pages> pp. 73-77, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: A preliminary presentation of this work appeared as "Efficient construction of program dependence graphs," in ACM International Symposium on Software Testing and Analysis '93. 1 GNU C compiler gcc 2 <ref> [41] </ref>, UNIX 3 utilities, SPEC benchmarks, 4 and Mothra software testing system [11], we found that over 95 percent of the functions contain no goto statements. Our research shows that for these programs, we can construct PDGs without the use of explicit control flow or postdominance information. <p> Moreover, in practice, even a more efficient postdominance calculation algorithm would still add time to the cost of running the FOW prototype. Study 2 Our second study investigated 3066 C functions from the GNU C compiler gcc 15 <ref> [41] </ref>, UNIX 16 utilities, SPEC benchmarks, 17 and Mothra software testing system [11], to determine how often our algorithm constructs the CDS during the program's parse, without needing to adjust control dependencies.
Reference: [42] <author> A. Taha, S. Thebut and S. Liu, </author> <title> "An approach to software fault localization and revalidation based on incremental data flow analysis," </title> <booktitle> Proceedings of COMPSAC 89, </booktitle> <pages> pp. 527-534, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Finally, both static and dynamic slicing techniques require control and data dependence information [1, 2, 40]. Many testing and analysis techniques also require control flow information. For example, data flow analysis [4], data flow testing [14, 33, 34, 36], test case generation [32], regression testing <ref> [17, 25, 35, 42] </ref>, and dynamic execution profiling [5] require control flow information. A program dependence graph (PDG) [13], in which nodes represent statements or regions of code, and edges represent control or data dependencies, encodes both control and data dependence information.
Reference: [43] <author> R. Tarjan, </author> <title> "Testing flow graph reducibility," </title> <journal> Journal of Computer and System Sciences, </journal> <volume> vol. 9, </volume> <pages> pp. 355-365, </pages> <year> 1974. </year>
Reference-contexts: If N is a statement node, IN [N] is the union of the OUT sets of its control flow predecessors, and OUT [N] is synthesized using IN [N], GEN [N] and KILL [N]. When programs are structured, elimination algorithms based on interval analysis <ref> [39, 43] </ref> can be adapted to use the CDS instead of the control flow graph [6]. In these cases, the control flow graph is not required in the analysis. <p> The timings excluding dominator costs for the FOW prototype give us a lower bound on the time that the prototype would require if it employed a more efficient algorithm for calculating postdominance information <ref> [43] </ref>. However, even using this lower bound, the timings show that ConstructCDS is almost always as efficient as, and in most cases more efficient than, the FOW prototype.
Reference: [44] <author> M. Weiser, </author> <title> "Program slicing," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-10, no. 4, </volume> <pages> pp. 352-357, </pages> <month> July 1884. 36 </month>
References-found: 44

