URL: http://www-lsr.imag.fr/users/Didier.Bert/Papers/tapsoft95.ps.gz
Refering-URL: http://www-lsr.imag.fr/Les.Groupes/scop/f-publi.html
Root-URL: http://www.imag.fr
Email: e-mail: fDidier.Bert,Catherine.Oriatg@imag.fr  
Title: A Model Inference System for Generic Specification with Application to Code Sharing  
Author: Didier Bert, Catherine Oriat 
Date: 741-755, 1995.  
Note: Proceedings of TAPSOFT'95, Sixth International Joint Conference on Theory and Practice of Software Development, Aarhus, Denmark, May 1995. LNCS 915, pages  
Address: BP 53, 38041 Grenoble Cedex 9, France  
Affiliation: LGI IMAG,  
Abstract: This paper presents a model inference system to control in-stantiation of generic modules. Generic parameters are specified by properties which represent classes of modules sharing some common features. Just as type checking consists in verifying that an expression is well typed, model checking allows to detect whether a (possibly generic) in-stantiation of a generic module is valid, i.e. whether the instantiation module is a model of the parameterizing property. Equality of instances can be derived from a canonical representation of modules. At last, we show how the code of generic modules can be shared for all instances of modules. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> Reference Manual of the Programming Language Ada. ANSI/MIL-STD 1815A, </institution> <year> 1983. </year>
Reference-contexts: In particular, there are various ways a module can be a model of a property. Such verifications for modules already exist in some programming languages. For instance in Ada <ref> [1] </ref>, homology rules are used to check the validity of instanti-ations; e.g. with private and limited types. In Ada, these rules apply to one type only. In contrast, M. V. <p> In section 5 we show the representation used for instances of generic modules. This representation allows to share imported modules consistently. Section 6 presents the compilation of modules. In contrast to languages such as Ada <ref> [1] </ref> or C++ [13], generic modules are compiled only once in lpg, all the instantiations sharing the same code.
Reference: 2. <author> M. V. Aponte. </author> <title> Extending record typing to type parametric modules with sharing. </title> <booktitle> In 20 th Symposium on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: For instance in Ada [1], homology rules are used to check the validity of instanti-ations; e.g. with private and limited types. In Ada, these rules apply to one type only. In contrast, M. V. Aponte proposed a type system for checking SML modules <ref> [2] </ref>, based on unification and sharing, and which performs verifications w.r.t. the whole specification of the generic part of a module.
Reference: 3. <author> G. Bernot and M. Bidoit. </author> <title> Proving correctness of algebraically specified software: Modularity and observability issues. </title> <booktitle> In Proceedings of AMAST'91. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: 4. <author> D. Bert and R. Echahed. </author> <title> Design and implementation of a generic, </title> <booktitle> logic and functional programming language. In Proceedings of ESOP'86, number 213 in LNCS, </booktitle> <pages> pages 119-132. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: We describe the model inference system used by the specification language lpg to control instantiation of generic modules. lpg (Langage de Programma-tion Generique, i.e. language for generic programming) is a specification language developed at the IMAG Institute by Didier Bert and Rachid Echahed <ref> [4, 5] </ref>. lpg allows on the one hand to define and combine generic components of specifications, and on the other hand to make prototypes thanks to an evaluation tool. There is also a solver of goals associating functional and logic programming. In lpg, generic modules are parameterized by properties.
Reference: 5. <author> D. Bert et al. </author> <title> Reference manual of the specification language LPG. </title> <type> Technical Report 59, </type> <note> LIFIA, mars 1990. Anonymous ftp at imag.fr, in /pub/SCOP/LPG/NewSun4/man lpg.dvi. </note>
Reference-contexts: We describe the model inference system used by the specification language lpg to control instantiation of generic modules. lpg (Langage de Programma-tion Generique, i.e. language for generic programming) is a specification language developed at the IMAG Institute by Didier Bert and Rachid Echahed <ref> [4, 5] </ref>. lpg allows on the one hand to define and combine generic components of specifications, and on the other hand to make prototypes thanks to an evaluation tool. There is also a solver of goals associating functional and logic programming. In lpg, generic modules are parameterized by properties.
Reference: 6. <author> M. Bidoit. </author> <title> The stratified loose approach: A generalization of initial and loose semantics. </title> <type> Technical Report 402, </type> <institution> Universite d'Orsay, France, </institution> <year> 1988. </year>
Reference-contexts: This problem is semi-decidable if the semantics is purely loose, but is undecidable if we work in an initial semantics [14]. In the second case, one has to check properties on classes of algebras, which is hard to do automatically. Consequently, in almost all specification languages (e.g. PLUSS <ref> [11, 6, 7] </ref>, ACT-TWO [9], OBJ [10, 12], . . . ), such verifications are left to the user. In this paper, we show that such verifications can partly be done automatically.
Reference: 7. <author> C. Choppy. </author> <title> About the "correctness" and "adequacy" of PLUSS specifications. In Recent Trends in Data Type Specifications, </title> <booktitle> number 785 in LNCS, </booktitle> <pages> pages 128-143. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This problem is semi-decidable if the semantics is purely loose, but is undecidable if we work in an initial semantics [14]. In the second case, one has to check properties on classes of algebras, which is hard to do automatically. Consequently, in almost all specification languages (e.g. PLUSS <ref> [11, 6, 7] </ref>, ACT-TWO [9], OBJ [10, 12], . . . ), such verifications are left to the user. In this paper, we show that such verifications can partly be done automatically.
Reference: 8. <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of algebraic specification 1. Equations and initial semantics, </title> <booktitle> volume 6 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: OE M is the only morphism from to M . (Categorically speaking, is the initial object of the category of signatures.) We suppose the reader is familiar with basic concepts of algebraic specification (see e.g. <ref> [8] </ref>). The class of algebras which satisfy a unit U together with homomorphisms is a category noted Alg (U ).
Reference: 9. <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of algebraic specification 2. Module Specifications and Constraints, </title> <booktitle> volume 21 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In the second case, one has to check properties on classes of algebras, which is hard to do automatically. Consequently, in almost all specification languages (e.g. PLUSS [11, 6, 7], ACT-TWO <ref> [9] </ref>, OBJ [10, 12], . . . ), such verifications are left to the user. In this paper, we show that such verifications can partly be done automatically. <p> An lpg module can be instantiated by another one only if the other module is a model of the required property. Properties and modules are related by constraints. These constraints are similar those given by Ehrig and Mahr <ref> [9] </ref> in that they put restrictions on classes of algebras. However, they differ in several points: firstly, Ehrig and Mahr only consider inclusion of specifications, whereas we consider any morphism in lpg.
Reference: 10. <author> K. Futatsugi, J.A. Goguen, J.-P. Jouannaud, and J. Meseguer. </author> <booktitle> Principles of OBJ2. In Proc. Principles of Programming Languages, </booktitle> <pages> pages 52-66, </pages> <year> 1985. </year>
Reference-contexts: In the second case, one has to check properties on classes of algebras, which is hard to do automatically. Consequently, in almost all specification languages (e.g. PLUSS [11, 6, 7], ACT-TWO [9], OBJ <ref> [10, 12] </ref>, . . . ), such verifications are left to the user. In this paper, we show that such verifications can partly be done automatically.
Reference: 11. <author> M.-C. </author> <title> Gaudel. A first introduction to PLUSS. </title> <type> Technical report, </type> <institution> Universite d'Orsay, France, </institution> <year> 1984. </year>
Reference-contexts: This problem is semi-decidable if the semantics is purely loose, but is undecidable if we work in an initial semantics [14]. In the second case, one has to check properties on classes of algebras, which is hard to do automatically. Consequently, in almost all specification languages (e.g. PLUSS <ref> [11, 6, 7] </ref>, ACT-TWO [9], OBJ [10, 12], . . . ), such verifications are left to the user. In this paper, we show that such verifications can partly be done automatically.
Reference: 12. <author> J.A. Goguen, C. Kirchner, H. Kirchner, A. Megrelis, J. Meseguer, and T. Winkler. </author> <title> An introduction to OBJ3. </title> <booktitle> In Proceedings of the 1 st International Workshop on Conditional Term Rewriting Systems, number 308 in LNCS, </booktitle> <pages> pages 258-263. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In the second case, one has to check properties on classes of algebras, which is hard to do automatically. Consequently, in almost all specification languages (e.g. PLUSS [11, 6, 7], ACT-TWO [9], OBJ <ref> [10, 12] </ref>, . . . ), such verifications are left to the user. In this paper, we show that such verifications can partly be done automatically.
Reference: 13. <author> S. B. Lippman. </author> <title> C++ Primer. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: In section 5 we show the representation used for instances of generic modules. This representation allows to share imported modules consistently. Section 6 presents the compilation of modules. In contrast to languages such as Ada [1] or C++ <ref> [13] </ref>, generic modules are compiled only once in lpg, all the instantiations sharing the same code.
Reference: 14. <author> F. Nourani. </author> <title> On induction for programming logic. </title> <journal> EATCS Bulletin, </journal> <volume> 13 </volume> <pages> 51-63, </pages> <year> 1981. </year>
Reference-contexts: In the first case one has to prove that some formulae are theorems in the theory. This problem is semi-decidable if the semantics is purely loose, but is undecidable if we work in an initial semantics <ref> [14] </ref>. In the second case, one has to check properties on classes of algebras, which is hard to do automatically. Consequently, in almost all specification languages (e.g. PLUSS [11, 6, 7], ACT-TWO [9], OBJ [10, 12], . . . ), such verifications are left to the user.
Reference: 15. <author> J.C. Reynaud. Semantique de LPG. </author> <note> Research Report 651 I IMAG, LIFIA, </note> <month> mars </month> <year> 1987. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: We do not define the whole semantics of lpg here, but only present the features which are relevant for this paper. For a complete description of the semantics of lpg, see <ref> [15] </ref>. Definition 1. (semantics of a property) The semantics of a property P is a class of algebras mod (P ), which satisfy the specification P , i.e.: mod (P ) Alg (P ).
References-found: 15

