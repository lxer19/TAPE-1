URL: http://www.cs.rpi.edu/~maniattb/mpi2.ps
Refering-URL: http://www.cs.rpi.edu/~maniattb/MPI.html
Root-URL: http://www.cs.rpi.edu
Title: MPI-2: Extensions to the Message-Passing Interface Message Passing Interface Forum  
Date: November 7, 1996  
Note: DRAFT processed on  This work was supported in part by NSF and ARPA under NSF contract CDA-9115428 and Esprit under project HPC Standards (21111).  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Rajesh Bordawekar, Juan Miguel del Rosario, and Alok Choudhary. </author> <title> Design and evaluation of primitives for parallel I/O. </title> <booktitle> In Proceedings of Supercomputing '93, </booktitle> <pages> pages 452-461, </pages> <year> 1993. </year>
Reference-contexts: MPIRT Generate User Event (event name) IN event name event name (handle) EXAMPLE 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 11.10. EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> EVENT-DRIVEN MPI/RT 289 MPI_Name data_transfer_start, channels_names <ref> [1] </ref>; MPI_Timeobj stop; MPI_Timeobj period=MPI_TIME_IGNORE; int counts [1]; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> period=MPI_TIME_IGNORE; int counts <ref> [1] </ref>; MPI_Datatype types [1]; MPI_QOS qoss [1]; MPI_QOS qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards [1], stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> qos_event = 1.0e3; // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards <ref> [1] </ref>, stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> // Initialize QOS for event delivery to 1 microsecond MPI_GUARD start_guards <ref> [1] </ref>, stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //... <p> for event delivery to 1 microsecond MPI_GUARD start_guards <ref> [1] </ref>, stop_guards [1]; MPI_EVENT_NAME monitor_list [1], generate_list [1] MPI_int bufs [1]; MPI_Request [1]; MPI_Buffer_Strategy system_strategy = MPI_BUFFER_CIRCULAR_NOWAIT, user_strategy_sent = MPI_BUFFER_NEXTAVAIL, user_strategy_receive = MPI_BUFFER_NEWEST; int flags [1]; extern void f (); extern void message_consumer (); void error_fns [1]; MPI_Buffer_Pool bufpool_handles [1]; MPI_Error errors [1]; MPI_Request channel; int index; //...
Reference: [2] <author> Juan Miguel del Rosario, Rajesh Bordawekar, and Alok Choudhary. </author> <title> Improved parallel I/O via a two-phase run-time access strategy. </title> <booktitle> In IPPS '93 Workshop on Input/Output in Parallel Computer Systems, </booktitle> <pages> pages 56-70, </pages> <year> 1993. </year> <note> Also published in Computer Architecture News 21(5), </note> <month> December </month> <year> 1993, </year> <pages> pages 31-38. </pages>
Reference-contexts: Example: Consider a C structure struct -char a <ref> [2] </ref>; float b [2]; double c-; assume that floats are 4 bytes and doubles are 8 bytes, and structures are naturally aligned. The memory layout is [c][c]xx [ffff][ffff]xxxx [dddddddd], and the structure is aligned to an 8 byte boundary. Case 1: The entire structure is communicated. <p> Example: Consider a C structure struct -char a <ref> [2] </ref>; float b [2]; double c-; assume that floats are 4 bytes and doubles are 8 bytes, and structures are naturally aligned. The memory layout is [c][c]xx [ffff][ffff]xxxx [dddddddd], and the structure is aligned to an 8 byte boundary. Case 1: The entire structure is communicated.
Reference: [3] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: This can probably be more elegantly expressed in terms of extents. Example 15.1 The following code declares a structure type and creates a datatype for that structure type. struct record - char name; 323 324 CHAPTER 15. MISCELLANY double position <ref> [3] </ref>; float mass; - MPI_Datatype record_type; MPI_datatype types [3] = -MPI_CHAR, MPI_DOUBLE, MPI_FLOAT-; int lengths [3] = -1, 3, 1-; MPI_Type_simple_struct ( 3, lengths, types, record_type); Rationale. The code above is much simpler and more natural than the current approach, that uses MPI TYPE STRUCT, and requires to compute displacements. <p> This can probably be more elegantly expressed in terms of extents. Example 15.1 The following code declares a structure type and creates a datatype for that structure type. struct record - char name; 323 324 CHAPTER 15. MISCELLANY double position <ref> [3] </ref>; float mass; - MPI_Datatype record_type; MPI_datatype types [3] = -MPI_CHAR, MPI_DOUBLE, MPI_FLOAT-; int lengths [3] = -1, 3, 1-; MPI_Type_simple_struct ( 3, lengths, types, record_type); Rationale. The code above is much simpler and more natural than the current approach, that uses MPI TYPE STRUCT, and requires to compute displacements. <p> Example 15.1 The following code declares a structure type and creates a datatype for that structure type. struct record - char name; 323 324 CHAPTER 15. MISCELLANY double position <ref> [3] </ref>; float mass; - MPI_Datatype record_type; MPI_datatype types [3] = -MPI_CHAR, MPI_DOUBLE, MPI_FLOAT-; int lengths [3] = -1, 3, 1-; MPI_Type_simple_struct ( 3, lengths, types, record_type); Rationale. The code above is much simpler and more natural than the current approach, that uses MPI TYPE STRUCT, and requires to compute displacements.
Reference: [4] <author> D. Ferrari. </author> <title> A new admission control method for real-time communication in an In-ternetwork. </title> <editor> In D. Son, editor, </editor> <booktitle> Advances in Real-Time Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1994. </year> <note> Chapter 5. </note>
Reference-contexts: These channels allow MPI/RT to provide guarantees on the maximum delivery time for messages. Discussion: The term real-time channel historically denoted a connection characterized by an upper bound on packet delays <ref> [4] </ref>. More recently, however, it has been applied to connections offering bounds on some other performance indices, such as bandwidth or loss rate. We use the term here with the latter, extended meaning. In MPI/RT, real-time channels are a bi-directional connection between the source and destination. <p> Real-time Admission Control Admission control is a necessary component of a real-time communication service <ref> [4] </ref>. Without a limitation on the number of real-time channels admitted to simultaneously share the resources of a packet-switched network, the quality of the received message streams cannot be guaranteed in the presence of network contention.
Reference: [5] <author> C++ Forum. </author> <title> Working paper for draft proposed international standard for information systems programming language c++. </title> <type> Technical report, </type> <institution> American National Standards Institute, </institution> <year> 1995. </year>
Reference: [6] <author> Message Passing Interface Forum. </author> <title> Document for a standard message-passing interface. </title> <type> Technical Report Technical Report No. </type> <institution> CS-93-214 (revised), University of Tennessee, </institution> <month> April </month> <year> 1994. </year> <note> Available on netlib. </note>
Reference: [7] <author> Message Passing Interface Forum. </author> <title> MPI: A Message-Passing Interface standard. </title> <journal> The International Journal of Supercomputer Applicatons and High Performance Computing, </journal> <volume> 8, </volume> <year> 1994. </year>
Reference: [8] <author> Message Passing Interface Forum. </author> <title> MPI: A Message-Passing Interface Standard. </title> <institution> Technical Report Computer Science Department Technical Report CS-94-230, University of Tennessee, Knoxville, TN, </institution> <month> May 5 </month> <year> 1994. </year> <booktitle> To appear in the International Journal of Supercomputing Applications, </booktitle> <volume> Volume 8, Number 3/4, </volume> <year> 1994. </year>
Reference: [9] <author> Al Geist, Adam Beguelin, Jack Dongarra, Weicheng Jiang, Bob Manchek, and Vaidy Sunderam. </author> <title> PVM: Parallel Virtual Machine|A User's Guide and Tutorial for Network Parallel Computing. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference: [10] <author> S. Jamin, S. Shenker, L. Zhang, and D. D. Clark. </author> <title> An admission control algorithm for predictive real-time service. </title> <booktitle> In Proc. Third International Workshop on Network and Operating System Support for Digital Audio and Video, </booktitle> <pages> pages 349|356. </pages> <publisher> Springer-Verlag, </publisher> <address> 1992. Heidelberg, Germany. 337 338 BIBLIOGRAPHY </address>
Reference-contexts: Many methods can be used to determine whether a new real-time channel can be added to those already existing in the network <ref> [10, 13] </ref>.
Reference: [11] <author> Charles H. Koelbel, David B. Loveman, Robert S. Schreiber, Guy L. Steele Jr., and Mary E. Zosel. </author> <title> The High Performance Fortran Handbook. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference: [12] <author> David Kotz. </author> <title> Disk-directed I/O for MIMD multiprocessors. </title> <booktitle> In Proceedings of the 1994 Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 61-74, </pages> <month> November </month> <year> 1994. </year> <note> Updated as Dartmouth TR PCS-TR94-226 on November 8, </note> <year> 1994. </year>
Reference: [13] <author> A. A. Lazar and G. Pacifici. </author> <title> Control of resources in broadband networks with quality of service guarantees. </title> <journal> IEEE Communications, </journal> <volume> 29(10):66|73, </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Many methods can be used to determine whether a new real-time channel can be added to those already existing in the network <ref> [10, 13] </ref>.
Reference: [14] <author> Bill Nitzberg. </author> <title> Performance of the iPSC/860 Concurrent File System. </title> <type> Technical Report RND-92-020, </type> <institution> NAS Systems Division, NASA Ames, </institution> <month> December </month> <year> 1992. </year>
Reference: [15] <author> William J. Nitzberg. </author> <title> Collective Parallel I/O. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Oregon, </institution> <month> December </month> <year> 1995. </year>
Reference: [16] <author> Perry Partow and Dennis Cottel. </author> <title> Scalable Programming Environment. </title> <type> Technical Report 1672, </type> <institution> Naval Command Control and Ocean Surveillance Center (NRAD), </institution> <month> Septem-ber </month> <year> 1994. </year>
Reference: [17] <author> David L. Ripps. </author> <title> An Implementation Guide to Real-time Programming. </title> <publisher> Yourdon Press, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1990. </year>
Reference: [18] <author> K. E. Seamons, Y. Chen, P. Jones, J. Jozwiak, and M. Winslett. </author> <title> Server-directed collective I/O in Panda. </title> <booktitle> In Proceedings of Supercomputing '95, </booktitle> <month> December </month> <year> 1995. </year>
Reference: [19] <author> Anthony Skjellum, Nathan E. Doss, and Kishore Viswanathan. </author> <title> Inter-communicator extensions to MPI in the MPIX (MPI eXtension) Library. </title> <type> Technical report, </type> <institution> Mississippi State University | Dept. of Computer Science, </institution> <month> April </month> <year> 1994. </year> <note> Draft version. </note>

References-found: 19

