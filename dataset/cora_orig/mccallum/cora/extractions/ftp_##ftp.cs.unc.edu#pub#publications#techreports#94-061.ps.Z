URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/94-061.ps.Z
Refering-URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/FILE.html
Root-URL: http://www.cs.unc.edu
Email: fponamgi,manocha,ling@cs.unc.edu  
Title: Incremental algorithms for collision detection between solid models  
Author: Madhav K. Ponamgi Dinesh Manocha Ming C. Lin 
Address: Chapel Hill, NC 27599  
Affiliation: Department of Computer Science University of North Carolina  
Abstract: Fast and accurate collision detection between general solid models is a fundamental problem in solid modeling, robotics, animation and computer-simulated environments. Most of the earlier algorithms are either restricted to a class of solid models, say convex polytopes, or are not fast enough for practical applications. We present an incremental algorithm for collision detection between general B-rep solid models in dynamic environments. The algorithm combines a hierarchical representation with incremental frame to frame computation to rapidly detect collisions. It makes use of coherence between successive instances to determine efficiently the number of object features interacting. For each pair of objects, it tracks the closest features between them on their respective convex hulls using the [LC91] algorithm. It detects when these objects penetrate using a new psuedo-internal Voronoi data structure and constructs the penetration region, identifying the regions of contact on the convex hulls. The features associated with these regions are represented in a precomputed hierarchy. The algorithm uses a coherence based approach to quickly traverse the pre-computed hierarchy and check for collisions between the features. The algorithm works well in practice and its complexity is output sensitive. 
Abstract-found: 1
Intro-found: 1
Reference: [AANJ94] <author> A.Garica-Alonso, N.Serrano, and J.Flaquer. </author> <title> Solving the collision detection problem. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 36-43, </pages> <year> 1994. </year>
Reference-contexts: Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. Approximate collision detection schemes using a series bounding boxes, spheres, or voxels can be found in <ref> [AANJ94, HBZ90] </ref>. More recently, Hubbard [Hub93] has formulated an approach where accuracy is traded for speed. The approximation schemes can be used 3 to deal with general non-convex objects. A non-convex object can be broken into these sub-units which are tested for collisions.
Reference: [AP76] <author> A.Appel and P.Will. </author> <title> Determining the three-dimensional convex hull of a polyhedron. </title> <journal> IBM Journal of Research and Development, </journal> <pages> pages 590-600, </pages> <year> 1976. </year>
Reference-contexts: Using our former notation, a cap of object A is denoted as CAP (A): CAP (A) = CH (A) A: There has been some work done on computing 2-dimensional caps (caps for non-convex polygons) [Lou66]. A cap algorithm for simple 3-dimensional objects has been described in <ref> [AP76] </ref>. Fig. 9 shows an example of a cap. The caps are computing the "missing" regions of the object so as to form its convex hull. The convex hull of an object is unique, and every face of the convex hull is a convex polygon.
Reference: [Bar90] <author> D. Baraff. </author> <title> Curved surfaces and coherence for non-penetrating rigid body simulation. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 19-28, </pages> <year> 1990. </year>
Reference-contexts: Coherence combined with incremental computation is a major theme of our work. By exploiting coherence, we are able to incrementally trim down the number of pair 4 (a) (b) wise object and feature tests involved in each iteration. For many applications in robotics and modeling, assuming coherence is reasonable <ref> [Bar90, Lin93] </ref>. Definition: Temporal and geometric coherence is the property that the state of the application does not change significantly between successive time steps or simulation frames. The objects move only slightly from frame to frame.
Reference: [Bar92] <author> D. Baraff. </author> <title> Dynamic simulation of non-penetrating rigid body simulation. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1992. </year>
Reference-contexts: Moreover, the objects move only slightly from frame to frame and the collision detection scheme should take advantage of the information from the previous frame to initialize the computation for the current frame <ref> [Bar92, LC91] </ref>. Several solutions based on this idea of coherence have been proposed in [Lin93]. Approaches that combine collision response with detection can be found in [Bar92, WG93, MW88]. The methods in [WG91, WG93] make use of boundary representation to detect collisions. <p> Several solutions based on this idea of coherence have been proposed in [Lin93]. Approaches that combine collision response with detection can be found in <ref> [Bar92, WG93, MW88] </ref>. The methods in [WG91, WG93] make use of boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments. <p> This can be done in O (N + e x + e y + e z ) time, where e x , e y , and e z are the number of exchanges along the x, y, and z axes while sorting <ref> [Bar92] </ref>. Since the exchanges are done during the sorting stage, the running time has the same expected complexity of O (N ). At the end of this stage, we have a list of pairs of objects whose bounding boxes overlap. The number of pairs correspond to k.
Reference: [BT92] <author> C.L. Bajaj and T.Dey. </author> <title> Convex decomposition of polyhedra and robustness. </title> <journal> SIAM Journal of Computing, </journal> <volume> 21 </volume> <pages> 339-364, </pages> <year> 1992. </year>
Reference-contexts: However, we chose not to use this approach for a number of reasons. The problem of computing an optimal convex decomposition of 3-D objects has been shown to be NP-Hard [Cha84]. Recently algorithms for computing convex decomposition have been described in <ref> [BT92] </ref>. They are fairly non-trivial to implement and in many cases generate too many internal or "fictitious" features (edges and faces). For example, consider a polygonal representation of a torus (Fig. 6). In such a case, any convex decomposition will generate O (n) internal features and decompositions.
Reference: [Bob89] <author> J. E. Bobrow. </author> <title> A direct minimization approach for obtaining the distance between convex polyhedra. </title> <journal> International Journal of Robotics Research, </journal> <volume> 8 </volume> <pages> 65-76, </pages> <year> 1989. </year>
Reference: [Cam91] <author> S. Cameron. </author> <title> Approximation hierarchies and s-bounds. </title> <booktitle> In Proceedings. Symposium on Solid Modeling Foundations and CAD/CAM Applications, </booktitle> <pages> pages 129-137, </pages> <address> Austin, TX, </address> <year> 1991. </year>
Reference-contexts: To achieve interactive rates, the total number of pairwise intersection tests must be reduced before performing exact collision tests on the object pairs, which are in the close vicinity of each other. Several methods dealing with this situation are found in <ref> [Cam91, CLMP95, DZ93] </ref>. Most methods use some type of a hierarchical bounding box scheme. Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. <p> However, to achieve desired accuracy using these approaches in simulation is computationally expensive. Many other techniques have been proposed on spatial partitioning methods for collision detection among multiple object pairs [Tur89]. These include binary space partition trees (BSP's), octrees, and approximation hierarchies <ref> [Cam91, FKN80, NAT90, Nay92] </ref>. However, they do not make use of coherence between successive instances and are relatively slow in practice. Algorithms based on interval arithmetic for collision detection are described in [Duf92, ea93].
Reference: [Can86] <author> J. F. Canny. </author> <title> Collision detection for moving polyhedra. </title> <journal> IEEE Trans. PAMI, </journal> <volume> 8:pp. </volume> <pages> 200-209, </pages> <year> 1986. </year>
Reference-contexts: Most robotics literature deals with collision detection in the context of path planning. Using sophisticated mathematical tools, several algorithms have been developed that plan collision-free paths for a robot in restricted environments <ref> [CC86, Can86] </ref>. This differs from virtual prototyping and simulation-based applications, where motion is subject to dynamic constraints or external forces and cannot be expressed as a closed form function of time. Computational geometry literature typically deals with collision detection of objects in a static environment.
Reference: [CC86] <author> S. Cameron and R. K. Culley. </author> <title> Determining the minimum translational distance between two convex polyhedra. </title> <booktitle> Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages pp. 591-596, </pages> <year> 1986. </year>
Reference-contexts: Most robotics literature deals with collision detection in the context of path planning. Using sophisticated mathematical tools, several algorithms have been developed that plan collision-free paths for a robot in restricted environments <ref> [CC86, Can86] </ref>. This differs from virtual prototyping and simulation-based applications, where motion is subject to dynamic constraints or external forces and cannot be expressed as a closed form function of time. Computational geometry literature typically deals with collision detection of objects in a static environment.
Reference: [CD87] <author> B. Chazelle and D. P. Dobkin. </author> <title> Intersection of convex objects in two and three dimensions. </title> <journal> J. ACM, </journal> <volume> 34 </volume> <pages> 1-27, </pages> <year> 1987. </year>
Reference-contexts: Computational geometry literature typically deals with collision detection of objects in a static environment. Objects are at a fixed location and orientation, and the algorithms determine whether they are intersecting <ref> [CD87, DK85] </ref>. In most modeling and graphics applications, where many objects are in motion, such an approach would be inefficient.
Reference: [Cha84] <author> B. Chazelle. </author> <title> Convex partitions of polyhedra: a lower bound and worst-case op timal algorithm. </title> <journal> SIAM J. Comput., </journal> <volume> 13 </volume> <pages> 488-507, </pages> <year> 1984. </year>
Reference-contexts: The simplest algorithms are based on convex decomposition along with algorithms for convex polytopes and multiple object pairs. However, we chose not to use this approach for a number of reasons. The problem of computing an optimal convex decomposition of 3-D objects has been shown to be NP-Hard <ref> [Cha84] </ref>. Recently algorithms for computing convex decomposition have been described in [BT92]. They are fairly non-trivial to implement and in many cases generate too many internal or "fictitious" features (edges and faces). For example, consider a polygonal representation of a torus (Fig. 6).
Reference: [Cha89] <author> B. Chazelle. </author> <title> An optimal algorithm for intersecting three-dimensional convex polyhedra. </title> <booktitle> In Proc. 30th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 586-591, </pages> <year> 1989. </year> <month> 23 </month>
Reference-contexts: There can be various combinations of these cases. Determining the interpenetration volume of the convex hulls delineates which caps (and the features underneath them) and which hull features from both objects are involved in the collision. A optimal linear time convex polytope penetration algorithm is described in <ref> [Cha89] </ref>. The algorithm pre-computes a hierarchy of simplified representations for each polytope (the Dobkin-Kirkpatrick hierarchy [DK85]) and traces the intersection through this hierarchy. The pre-processing and the algorithm are quite complex, so we present two simpler methods that based on coherence.
Reference: [CLMP95] <author> J. Cohen, M. Lin, D. Manocha, and M. Ponamgi. I-collide: </author> <title> An interactive and exact collision detection system for large-scale environments. </title> <booktitle> In Proc. of ACM Interactive 3D Graphics Conference, </booktitle> <address> Monterey, CA, </address> <year> 1995, </year> <pages> pp. 112-120. </pages>
Reference-contexts: To achieve interactive rates, the total number of pairwise intersection tests must be reduced before performing exact collision tests on the object pairs, which are in the close vicinity of each other. Several methods dealing with this situation are found in <ref> [Cam91, CLMP95, DZ93] </ref>. Most methods use some type of a hierarchical bounding box scheme. Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. <p> For instance, consider Fig. 1 (a) where all object pairs are colliding. A similar situation can occur for all feature pairs between a pair of colliding objects as shown in Fig. 1 (b) with "comb polyhedra". However, evidence suggests that these cases rarely occur in real models <ref> [CLMP95, Lin93] </ref>. <p> It would be pointless and expensive to keep track of all possible interactions between objects at each time step. Sorting the bounding boxes surrounding the objects is the key to our Sweep and Prune approach <ref> [CLMP95] </ref>. It is not intuitively obvious how to sort bounding boxes in 3-space to determine overlaps. We use a dimension reduction approach. If two bounding boxes collide in 3-D, then their orthogonal projections on the x, y, and z axes must overlap. <p> The first is to make the boxes containing the faces large enough to contain the faces at any orientation. Thus, updating the hierarchy amounts translating the box coordinates. We have implemented this method for the bounding boxes containing the convex hulls of the objects with excellent results <ref> [CLMP95] </ref>. Another approach is to pre-compute the hierarchy dimensions at common orientations and interpolate between these. 4.6 Determining Contact Regions between Polytopes When the convex hulls of two polytopes are determined to be colliding based on the penetration algorithm, we enter the third stage of the algorithm.
Reference: [CP90] <author> B. Chazelle and L. Palios. </author> <title> Triangulating a non-convex polytope. </title> <journal> Discrete Comput. Geom., </journal> <volume> 5 </volume> <pages> 505-526, </pages> <year> 1990. </year>
Reference: [DF78] <author> D.Muller and F.Preparata. </author> <title> Finding the intersection of two convex polyhedra. </title> <journal> Theoretical Computer Science, </journal> <volume> 8(2) </volume> <pages> 217-236, </pages> <year> 1978. </year>
Reference-contexts: Vertex points of the convex hull are dualized to face planes. A point q = (q x ; q y ; q z ) originally a distance d = q x + q 2 z under the transformation becomes a plane 1=d from the origin on the other side <ref> [DF78] </ref>. A similar transformation occurs for face planes. Because we have defined a new origin, internal to both convex hulls, the closer faces move further away and the further ones closer with this transformation. <p> To 17 Leaf Boxes with Face Polygons Leaf Boxes with Face Polygons Obj A Obj A Hierarchical Sort Manager find the interpenetrating volume, we simply find the convex hull of the dualized face planes (which are points) and transform them back into face planes on the objects <ref> [DF78] </ref>. With this computation we now know which caps have been penetrated as well as which features of the hull features have penetrated. The hull and concavity features are in a pre-computed hierarchy, so we traverse the two hierarchies to determine the contact status between the two objects.
Reference: [DK85] <author> D. P. Dobkin and D. G. Kirkpatrick. </author> <title> A linear algorithm for determining the separation of convex pol yhedra. </title> <journal> J. Algorithms, </journal> <volume> 6 </volume> <pages> 381-392, </pages> <year> 1985. </year>
Reference-contexts: Computational geometry literature typically deals with collision detection of objects in a static environment. Objects are at a fixed location and orientation, and the algorithms determine whether they are intersecting <ref> [CD87, DK85] </ref>. In most modeling and graphics applications, where many objects are in motion, such an approach would be inefficient. <p> A optimal linear time convex polytope penetration algorithm is described in [Cha89]. The algorithm pre-computes a hierarchy of simplified representations for each polytope (the Dobkin-Kirkpatrick hierarchy <ref> [DK85] </ref>) and traces the intersection through this hierarchy. The pre-processing and the algorithm are quite complex, so we present two simpler methods that based on coherence.
Reference: [Duf92] <author> Tom Duff. </author> <title> Interval arithmetic and recursive subdivision for implicit functions and constructive solid geometry. </title> <journal> ACM Computer Graphics, </journal> <volume> 26(2) </volume> <pages> 131-139, </pages> <year> 1992. </year>
Reference-contexts: These include binary space partition trees (BSP's), octrees, and approximation hierarchies [Cam91, FKN80, NAT90, Nay92]. However, they do not make use of coherence between successive instances and are relatively slow in practice. Algorithms based on interval arithmetic for collision detection are described in <ref> [Duf92, ea93] </ref>. These algorithms expect the motion of the objects to be expressed as a closed form function of time. Moreover, the performance of interval arithmetic based algorithms is too slow for interactive applications.
Reference: [DZ93] <author> P. Dworkin and D. Zeltzer. </author> <title> A new model for efficient dynamics simulation. </title> <booktitle> Proceedings Eurographics workshop on animation and simulation, </booktitle> <pages> pages 175-184, </pages> <year> 1993. </year>
Reference-contexts: To achieve interactive rates, the total number of pairwise intersection tests must be reduced before performing exact collision tests on the object pairs, which are in the close vicinity of each other. Several methods dealing with this situation are found in <ref> [Cam91, CLMP95, DZ93] </ref>. Most methods use some type of a hierarchical bounding box scheme. Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied.
Reference: [ea93] <author> J. Snyder et. al. </author> <title> Interval methods for multi-point collisions between time dependent curved surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 321-334, </pages> <year> 1993. </year>
Reference-contexts: These include binary space partition trees (BSP's), octrees, and approximation hierarchies [Cam91, FKN80, NAT90, Nay92]. However, they do not make use of coherence between successive instances and are relatively slow in practice. Algorithms based on interval arithmetic for collision detection are described in <ref> [Duf92, ea93] </ref>. These algorithms expect the motion of the objects to be expressed as a closed form function of time. Moreover, the performance of interval arithmetic based algorithms is too slow for interactive applications.
Reference: [FKN80] <author> H. Fuchs, Z. Kedem, and B. Naylor. </author> <title> On visible surface generation by a priori tree structures. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <volume> volume 14, </volume> <pages> pages 124-133, </pages> <year> 1980. </year>
Reference-contexts: However, to achieve desired accuracy using these approaches in simulation is computationally expensive. Many other techniques have been proposed on spatial partitioning methods for collision detection among multiple object pairs [Tur89]. These include binary space partition trees (BSP's), octrees, and approximation hierarchies <ref> [Cam91, FKN80, NAT90, Nay92] </ref>. However, they do not make use of coherence between successive instances and are relatively slow in practice. Algorithms based on interval arithmetic for collision detection are described in [Duf92, ea93].
Reference: [GH89] <author> E. G. Gilbert and S. M. Hong. </author> <title> A new algorithm for detecting the collision of moving objects. </title> <booktitle> IEEE Conference on Robotics and Automation, </booktitle> <pages> pages pp. 8-14, </pages> <year> 1989. </year>
Reference: [GJK88] <author> E. G. Gilbert, D. W. Johnson, and S. S. Keerthi. </author> <title> A fast procedure for computing the distance between objects in three-dimensional space. </title> <journal> IEEE J. Robotics and Automation, </journal> <volume> vol RA-4:pp. </volume> <pages> 193-203, </pages> <year> 1988. </year>
Reference: [GO94] <author> E.G. Gilbert and C.J. Ong. </author> <title> New distances for the separation and penetration of objects. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages 579-586, </pages> <year> 1994. </year>
Reference-contexts: To circumvent this problem, we introduce the notion of pseudo internal Voronoi regions for a convex polyhedron. These are used to detect when the convex hulls of a pair of objects penetrate. This is different from computing the amount of penetration between two objects, as shown in <ref> [GO94] </ref>. The modified algorithm with penetration detection has the same complexity as the original algorithm in [LC91]. We classify the features of the overlapping convex hulls into those belonging to the original non-convex objects, and those constructed while computing the convex hull of the non-convex objects.
Reference: [HBZ90] <author> B. V. Herzen, A. H. Barr, and H. R. Zatz. </author> <title> Geometric collisions for time-dependent parametric surfaces. </title> <journal> Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 39-48, </pages> <year> 1990. </year>
Reference-contexts: Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. Approximate collision detection schemes using a series bounding boxes, spheres, or voxels can be found in <ref> [AANJ94, HBZ90] </ref>. More recently, Hubbard [Hub93] has formulated an approach where accuracy is traded for speed. The approximation schemes can be used 3 to deal with general non-convex objects. A non-convex object can be broken into these sub-units which are tested for collisions.
Reference: [HH87] <author> C.M. Hoffmann and J. E. Hopcroft. </author> <title> Simulation of physical systems from geometric models. </title> <journal> IEEE Journal on Robotics and Automation, </journal> <volume> 3(3) </volume> <pages> 194-206, </pages> <year> 1987. </year>
Reference-contexts: Such systems create electronic representations of mechanical parts, tools, and machines, which need to be tested for intercon-nectivity, functionality, and reliability. The goal of these virtual and electronic simulation systems is to save processing time and manufacturing costs by avoiding the production of actual physical prototypes <ref> [Hop88, HH87] </ref>. This is similar to the goal of CAD tools for VLSI.
Reference: [Hop88] <author> J.E. Hopcroft. </author> <title> Electronic prototyping. </title> <journal> IEEE Transactions on Aerospace and Electronic Systems, </journal> <volume> 24(2) </volume> <pages> 663-667, </pages> <year> 1988. </year>
Reference-contexts: Such systems create electronic representations of mechanical parts, tools, and machines, which need to be tested for intercon-nectivity, functionality, and reliability. The goal of these virtual and electronic simulation systems is to save processing time and manufacturing costs by avoiding the production of actual physical prototypes <ref> [Hop88, HH87] </ref>. This is similar to the goal of CAD tools for VLSI.
Reference: [Hub93] <author> P. M. Hubbard. </author> <title> Interactive collision detection. </title> <booktitle> In Proceedings of IEEE Symposium on Research Frontiers in Virtual Reality, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Objects are surrounded by bounding boxes. If the bounding boxes overlap, indicating the objects are near each other, a more precise collision test is applied. Approximate collision detection schemes using a series bounding boxes, spheres, or voxels can be found in [AANJ94, HBZ90]. More recently, Hubbard <ref> [Hub93] </ref> has formulated an approach where accuracy is traded for speed. The approximation schemes can be used 3 to deal with general non-convex objects. A non-convex object can be broken into these sub-units which are tested for collisions.
Reference: [LC91] <author> M.C. Lin and John F. Canny. </author> <title> Efficient algorithms for incremental distance computation. </title> <booktitle> In IEEE Conference on Robotics and Automation, </booktitle> <year> 1991. </year>
Reference-contexts: Moreover, the objects move only slightly from frame to frame and the collision detection scheme should take advantage of the information from the previous frame to initialize the computation for the current frame <ref> [Bar92, LC91] </ref>. Several solutions based on this idea of coherence have been proposed in [Lin93]. Approaches that combine collision response with detection can be found in [Bar92, WG93, MW88]. The methods in [WG91, WG93] make use of boundary representation to detect collisions. <p> Moreover, the performance of interval arithmetic based algorithms is too slow for interactive applications. Coherence based algorithms for curved models are presented in [LM95]. 2.1 Algorithm Overview In this paper, we present a fast algorithm for contact determination between non-convex polyhedra. Initially, we apply the distance computation algorithm of <ref> [LC91] </ref> to the convex hulls of the polyhedra. The algorithm described in [LC91] may go into a cyclic loop when convex hulls interpenetrate. To circumvent this problem, we introduce the notion of pseudo internal Voronoi regions for a convex polyhedron. <p> Coherence based algorithms for curved models are presented in [LM95]. 2.1 Algorithm Overview In this paper, we present a fast algorithm for contact determination between non-convex polyhedra. Initially, we apply the distance computation algorithm of <ref> [LC91] </ref> to the convex hulls of the polyhedra. The algorithm described in [LC91] may go into a cyclic loop when convex hulls interpenetrate. To circumvent this problem, we introduce the notion of pseudo internal Voronoi regions for a convex polyhedron. These are used to detect when the convex hulls of a pair of objects penetrate. <p> These are used to detect when the convex hulls of a pair of objects penetrate. This is different from computing the amount of penetration between two objects, as shown in [GO94]. The modified algorithm with penetration detection has the same complexity as the original algorithm in <ref> [LC91] </ref>. We classify the features of the overlapping convex hulls into those belonging to the original non-convex objects, and those constructed while computing the convex hull of the non-convex objects. <p> The number of pairs correspond to k. We pass this list onto the next stage of the algorithm that determines for each pair if the convex hulls of the objects are overlapping. 3.2 Collision Detection between Convex Polytopes We use the algorithm described in <ref> [LC91, Lin93] </ref> to keep track of closest features for a pair of convex polytopes. The algorithm maintains a pair of closest features for each convex polytope pair and calculates the Euclidean distance between the features to detect collisions.
Reference: [Lin93] <author> M.C. Lin. </author> <title> Efficient Collision Detection for Animation and Robotics. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, University of California, Berkeley, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Moreover, the objects move only slightly from frame to frame and the collision detection scheme should take advantage of the information from the previous frame to initialize the computation for the current frame [Bar92, LC91]. Several solutions based on this idea of coherence have been proposed in <ref> [Lin93] </ref>. Approaches that combine collision response with detection can be found in [Bar92, WG93, MW88]. The methods in [WG91, WG93] make use of boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments. <p> Coherence combined with incremental computation is a major theme of our work. By exploiting coherence, we are able to incrementally trim down the number of pair 4 (a) (b) wise object and feature tests involved in each iteration. For many applications in robotics and modeling, assuming coherence is reasonable <ref> [Bar90, Lin93] </ref>. Definition: Temporal and geometric coherence is the property that the state of the application does not change significantly between successive time steps or simulation frames. The objects move only slightly from frame to frame. <p> For instance, consider Fig. 1 (a) where all object pairs are colliding. A similar situation can occur for all feature pairs between a pair of colliding objects as shown in Fig. 1 (b) with "comb polyhedra". However, evidence suggests that these cases rarely occur in real models <ref> [CLMP95, Lin93] </ref>. <p> The number of pairs correspond to k. We pass this list onto the next stage of the algorithm that determines for each pair if the convex hulls of the objects are overlapping. 3.2 Collision Detection between Convex Polytopes We use the algorithm described in <ref> [LC91, Lin93] </ref> to keep track of closest features for a pair of convex polytopes. The algorithm maintains a pair of closest features for each convex polytope pair and calculates the Euclidean distance between the features to detect collisions. <p> If a point lies on a constraint plane, then it is equi-distant from the two features which share this constraint plane in their Voronoi regions. For more details on this construction and its properties, please refer to <ref> [Lin93] </ref>. 3.2.2 Closest Feature Tests Our method for finding closest feature pairs is based on Voronoi regions. We start with a candidate pair of features, one from each polytope, and check whether the closest points lie on these features.
Reference: [LM95] <author> M.C. Lin and Dinesh Manocha. </author> <title> Efficient contact determination between geometric models. </title> <journal> International Journal of Computational Geometry and Applications, </journal> <note> 1995. To appear. 24 </note>
Reference-contexts: These algorithms expect the motion of the objects to be expressed as a closed form function of time. Moreover, the performance of interval arithmetic based algorithms is too slow for interactive applications. Coherence based algorithms for curved models are presented in <ref> [LM95] </ref>. 2.1 Algorithm Overview In this paper, we present a fast algorithm for contact determination between non-convex polyhedra. Initially, we apply the distance computation algorithm of [LC91] to the convex hulls of the polyhedra. The algorithm described in [LC91] may go into a cyclic loop when convex hulls interpenetrate. <p> The tori simulation consists of seven interlocked tori (a toroidal chain). We polygonize each torus into 400 polygons and check for collision between the polyhedral approximations. After the polyhedral models overlap, a local algebraic solver checks for exact collision <ref> [LM95] </ref>.
Reference: [Lou66] <author> P. Loutrel. </author> <title> Determination of hidden edges in polyhedral figures. </title> <type> Technical Report NYU-3-12-1966, </type> <institution> Department of Computer Science, </institution> <address> New York University, </address> <year> 1966. </year>
Reference-contexts: Using our former notation, a cap of object A is denoted as CAP (A): CAP (A) = CH (A) A: There has been some work done on computing 2-dimensional caps (caps for non-convex polygons) <ref> [Lou66] </ref>. A cap algorithm for simple 3-dimensional objects has been described in [AP76]. Fig. 9 shows an example of a cap. The caps are computing the "missing" regions of the object so as to form its convex hull.
Reference: [Meg83] <author> N. Megiddo. </author> <title> Linear-time algorithms for linear programming in r 3 and related problems. </title> <journal> SIAM J. Computing, </journal> <volume> 12:pp. </volume> <pages> 759-776, </pages> <year> 1983. </year>
Reference: [MW88] <author> M. Moore and J. Wilhelms. </author> <title> Collision detection and response for computer animation. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 289-298, </pages> <year> 1988. </year>
Reference-contexts: Several solutions based on this idea of coherence have been proposed in [Lin93]. Approaches that combine collision response with detection can be found in <ref> [Bar92, WG93, MW88] </ref>. The methods in [WG91, WG93] make use of boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments.
Reference: [NAT90] <author> B. Naylor, J. Amanatides, and W. Thibault. </author> <title> Merging bsp trees yield polyhedral modeling results. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 115-124, </pages> <year> 1990. </year>
Reference-contexts: However, to achieve desired accuracy using these approaches in simulation is computationally expensive. Many other techniques have been proposed on spatial partitioning methods for collision detection among multiple object pairs [Tur89]. These include binary space partition trees (BSP's), octrees, and approximation hierarchies <ref> [Cam91, FKN80, NAT90, Nay92] </ref>. However, they do not make use of coherence between successive instances and are relatively slow in practice. Algorithms based on interval arithmetic for collision detection are described in [Duf92, ea93].
Reference: [Nay92] <author> B. Naylor. </author> <title> Interactive solid geometry via partitioing trees. </title> <booktitle> In Proc. of Graphics Interface, </booktitle> <pages> pages 11-18, </pages> <year> 1992. </year>
Reference-contexts: However, to achieve desired accuracy using these approaches in simulation is computationally expensive. Many other techniques have been proposed on spatial partitioning methods for collision detection among multiple object pairs [Tur89]. These include binary space partition trees (BSP's), octrees, and approximation hierarchies <ref> [Cam91, FKN80, NAT90, Nay92] </ref>. However, they do not make use of coherence between successive instances and are relatively slow in practice. Algorithms based on interval arithmetic for collision detection are described in [Duf92, ea93].
Reference: [NF91] <author> E. Nicolson and R. Fearing. </author> <title> Dynamic simulation of a part-mating problem: Threaded fastener insertion. </title> <booktitle> In Proceedings, IEEE/RSJ International Conference on Intelligent Robots and Systems, </booktitle> <pages> pages 30-37, </pages> <year> 1991. </year>
Reference-contexts: According to an earlier study by Nevins and Whitney [NW80], the insertion and tightening of threaded fasteners is one of the twelve most commonly assembled tasks. More recently, Nicolson and Fearing have presented the first algorithm and system for dynamic simulation of screw insertion <ref> [NF91] </ref>. In this section, we briefly describe the geometric model of the screw based on the formulation in [NF91]. A screw thread is a ridge of a thread profile, wrapped in a helical fashion about a cylinder. The pitch is the spatial period of the thread profile. <p> More recently, Nicolson and Fearing have presented the first algorithm and system for dynamic simulation of screw insertion <ref> [NF91] </ref>. In this section, we briefly describe the geometric model of the screw based on the formulation in [NF91]. A screw thread is a ridge of a thread profile, wrapped in a helical fashion about a cylinder. The pitch is the spatial period of the thread profile. The external screw thread is the thread of the bolt and the internal screw thread is that on a nut. <p> A cross-section of the geometric model is shown in Figure 13. The thread profile is parameterized as a function of position, t, and thread pitch, p. Given r and a, it can be represented as a bivariate piecewise function of t and p <ref> [NF91] </ref>. This thread profile is used to formulate the surface of the screw in space as a parametric function of two variables. Given the geometric description of the thread, the dynamic simulation requires precise determination of contact points between the nut and the bolt. <p> This helps in choosing the appropriate time steps. There are no general purpose analytic and efficient approaches known for computing the contact points between the bolt and the nut. Nicolson and Fearing <ref> [NF91] </ref> used a set of "critical points" on the thread profile at which contact is most likely to occur. This is based on approximating the bolt by a helix, whose radius is same as that at the crest of the bolt thread.
Reference: [Nic94] <author> E. </author> <title> Nicolson. </title> <type> Personal Communication, </type> <year> 1994. </year>
Reference-contexts: Given the set of critical points, their algorithm checks whether these critical points lie on the surface of the nut. In their simulation, collision detection accounted for almost half of the simulation time and misses some contacts at times <ref> [Nic94] </ref>. We have applied our collision detection algorithm to a polygonal approximation of the bolt and nut. The polygonal approximation is specified to an * tolerance of the original model.
Reference: [NW80] <author> J.L. Nevins and D.E. Whitney. </author> <title> Assembly research. </title> <booktitle> In Factory Automation, volume 2, </booktitle> <address> Maidenhead, England, </address> <year> 1980. </year>
Reference-contexts: These last two configurations were used on an interlocked chain of eight tori. 5.1 Application to Threaded Insertion We have applied the contact determination algorithm for dynamic simulation of a threaded insertion. According to an earlier study by Nevins and Whitney <ref> [NW80] </ref>, the insertion and tightening of threaded fasteners is one of the twelve most commonly assembled tasks. More recently, Nicolson and Fearing have presented the first algorithm and system for dynamic simulation of screw insertion [NF91].
Reference: [O'R94] <author> J. O'Rourke. </author> <title> Computational Geometry in C. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: In several parts of the overall algorithm, we compute the convex hull of an object. It is a well-known problem that taking the convex hull of co-planar faces (hence vertices) causes numerical problems <ref> [O'R94] </ref>. * The model may have T-vertices, where one edge intersects another edge somewhere in the middle. We add extra edges to remove the T-vertices. * Problems in constructing of the bounding box hierarchy. While grouping the faces into boxes, we use orthogonal cutting planes which cut the existing faces.
Reference: [PS85] <author> F.P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Each feature is described by its geometric parameters and its neighboring features, i.e. the topological information of incidences and adjacencies. Definition: A Voronoi region associated with a feature is a set of points closer to that feature than any other <ref> [PS85] </ref>. The Voronoi regions form a partition of the space outside the polytope, and form the generalized Voronoi diagram of the polytope. Note that the generalized Voronoi diagram of a convex polytope has linear number of features and consists of polyhedral regions. <p> For internal partitioning, internal Voronoi regions can be used. The internal Voronoi regions can be constructed for any convex polytope by computing all the equi-distant hyperplanes between two or more facets on the polytope. However the general construction of the internal Voronoi regions is a non-trivial computation <ref> [PS85] </ref>. To detect a penetration as opposed to knowing all the closest features it is unnecessary to construct the exact internal Voronoi regions. To simply detect a penetration, it is unnecessary to construct the exact internal Voronoi regions. <p> A cap that uses the same vertices is its cover. The O (n 2 ) complexity of the algorithm comes from convex hull computation. In our implementation we use incremental algorithms of quadratic complexity as opposed to optimal algorithms of complexity O (n log n) <ref> [PS85] </ref>. Moreover, the resulting non-simple polygons are triangulated. The implementation of this algorithm has some numerical robustness problems for long thin faces. An implementation less susceptible to this is a brute force triangulation of the boundary vertex sets. <p> For the octree variant tree (OTV), the cutting planes used to divide the vertices are not uniformly distributed over the bounding box volume. The cutting planes are introduced in a manner similar to k d trees <ref> [PS85] </ref>. For example, a single cut along each of the x, y, and z axes is implemented as follows: * The median of the x-coordinates is found.
Reference: [Qui94] <author> S. Quinlan. </author> <title> Efficient distance computation between non-convex objects. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages 3324-3329, </pages> <year> 1994. </year>
Reference: [Sei90] <author> R. Seidel. </author> <title> Linear programming and convex hulls made easy. </title> <booktitle> In Proc. 6th Ann. ACM Conf. on Computational Geometry, </booktitle> <pages> pages 211-215, </pages> <address> Berkeley, California, </address> <year> 1990. </year>
Reference: [THK91] <author> F. Thomas, J. Hamlin, and R.B. Kelley. </author> <title> Spherical object representation and fast distance computation for robotic applications. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation, </booktitle> <year> 1991. </year>
Reference: [TT94] <author> F. Thomas and C. Torras. </author> <title> Interference detection between non-convex polyhedra revisited with a practical aim. </title> <booktitle> In Proceedings of International Conference on Robotics and Automation, </booktitle> <pages> pages 587-594, </pages> <year> 1994. </year>
Reference: [Tur89] <author> G. Turk. </author> <title> Interactive collision detection for molecular graphics. </title> <type> Master's thesis, </type> <institution> Computer Science Department, University of North Carolina at Chapel Hill, </institution> <year> 1989. </year>
Reference-contexts: A non-convex object can be broken into these sub-units which are tested for collisions. However, to achieve desired accuracy using these approaches in simulation is computationally expensive. Many other techniques have been proposed on spatial partitioning methods for collision detection among multiple object pairs <ref> [Tur89] </ref>. These include binary space partition trees (BSP's), octrees, and approximation hierarchies [Cam91, FKN80, NAT90, Nay92]. However, they do not make use of coherence between successive instances and are relatively slow in practice. Algorithms based on interval arithmetic for collision detection are described in [Duf92, ea93].
Reference: [WG91] <author> W.Bouma and G.Vanecek. </author> <title> Collision detection and analysis in a physically based simulation. </title> <booktitle> Proceedings Eurographics workshop on animation and simulation, </booktitle> <pages> pages 191-203, </pages> <year> 1991. </year>
Reference-contexts: Several solutions based on this idea of coherence have been proposed in [Lin93]. Approaches that combine collision response with detection can be found in [Bar92, WG93, MW88]. The methods in <ref> [WG91, WG93] </ref> make use of boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments.
Reference: [WG93] <author> W.Bouma and G.Vanecek. </author> <title> Modeling contacts in a physically based simulation. </title> <booktitle> Second Symposium on Solid Modeling and Applications, </booktitle> <pages> pages 409-419, </pages> <year> 1993. </year>
Reference-contexts: Several solutions based on this idea of coherence have been proposed in [Lin93]. Approaches that combine collision response with detection can be found in <ref> [Bar92, WG93, MW88] </ref>. The methods in [WG91, WG93] make use of boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments. <p> Several solutions based on this idea of coherence have been proposed in [Lin93]. Approaches that combine collision response with detection can be found in [Bar92, WG93, MW88]. The methods in <ref> [WG91, WG93] </ref> make use of boundary representation to detect collisions. Collision detection for multiple moving objects has recently become a popular research topic with the increased interest in large-scaled virtual prototyping environments.
Reference: [WK93] <author> D.Waco and Y.Kim. </author> <title> Geometric Reasoning for Machining Features Using Convex Decomposition Second Symposium on Solid Modeling and Applications, </title> <address> pages 323-332, </address> <year> 1993. </year>
References-found: 48

