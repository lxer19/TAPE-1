URL: http://cs.nyu.edu/cs/faculty/paige/papers/prod.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/paige/research.html
Root-URL: http://www.cs.nyu.edu
Title: To wards Increased Productivity of Algorithm Implementation  
Author: Jiazhen Cai and Robert Paige 
Date: December 3, 1993  
Address: 251 Mercer St. New York, NY 10012  
Affiliation: Dept. of Computer Science New York University/ Courant Institute  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Bancilhon, F., </author> <title> ``Naive Evaluation of Recursively defined Relations,'' in On Knowledge-Base Management Systems, </title> <editor> ed. Brodie, M and Mylopoulos, </editor> <volume> J, </volume> <pages> pp. 165-178, </pages> <year> 1986. </year>
Reference: 2. <author> Bayer, R., </author> <title> Query evaluation and recursion in deductive database system, 1985. </title> <type> unpublished manuscript </type>
Reference: 3. <author> Beeri, C. and Bernstein, P., </author> <title> ``Computational Problems Related to the Design of Normal Form Relation Schemes,'' </title> <journal> ACM TODS, </journal> <volume> vol. 4, no. 1, </volume> <pages> pp. 30-59, </pages> <year> 1979. </year>
Reference-contexts: Transformational Methodology It is convenient to explain our transformational methodology (and the corresponding three levels of prototyping) by illustrating how it can be used to automatically generate C code implementing Beeri and Bernstein's linear time attribute closure algorithm <ref> [3] </ref> (which can also solve propositional horn clause satisfiability) from a perspicuous mathematical specification. The code fragments shown below form part of a `photo' generated APTS derivation performed by our SQ2+-to-C compiler. This derivation resembles a partially automated derivation of the same algorithm that was sketched previously in [25].
Reference: 4. <author> Borras, P., Clement, D., Despeyroux, T., Incerpi, J., Kahn, G., Lang, B., and Pascual, V., </author> <title> Centaur: the system, </title> <institution> INRIA, 1987. Rapports de Recherche </institution>
Reference-contexts: Implementation All of our experiments have been conducted using the APTS system, whose source code is written in about 15,000 lines of SETL2, a nice manageable size encouraging further development. SETL2 is written in C, which makes APTS portable to more machines than other competing systems such as Centaur <ref> [4] </ref> and Refine [31]. APTS is seamless in the sense of having no foreign tools and uniform data structures throughout. Hence, we are able to consider every aspect of system functioning for algorithmic improvement, which is also the focus of our research.
Reference: 5. <author> Cai, J. and Paige, R., </author> <title> ``Program Derivation by Fixed Point Computation,'' </title> <booktitle> Science of Computer Programming, </booktitle> <volume> vol. 11, </volume> <pages> pp. 197-261, </pages> <year> 1988/89. </year>
Reference-contexts: We used APTS to build two compilers for conducting experiments to test the feasibility of these techniques. One of these compilers translates a major fragment of SETL2 [37] into C [20]. The other translates SQ2+ <ref> [5] </ref> (a strongly typed functional subset of SETL2 augmented with fixed point expressions) into C. <p> The highest level of abstraction is SQ2+, where programs are written succinctly in terms of least and greatest fixed point expressions. Our dominated convergence transformation <ref> [5] </ref> can compute these fixed points in terms of high level SETL2 loops that generate `chaotic' sequences that are less expensive than Tarski sequences [39,40,11]. <p> This information is used to prove that the fixed point in (2) can be computed by the following iterative procedure according to the dominated convergence argument developed in <ref> [5] </ref>: (3) a := x ; ( while exists x1 in - x3 in f [ - y in domain f | # - x2 in y | x2 notin a - = 0 - ] | x3 notin a - ) a with := x1 ; end while ; Program
Reference: 6. <author> Cai, J., Facon, P., Henglein, F., Paige, R., and Schonberg, E., </author> <title> ``Type Transformation and Data Structure Choice,'' in Constructing Programs From Specifications, </title> <editor> ed. B. </editor> <booktitle> Moeller, </booktitle> <pages> pp. 126 - 124, </pages> <publisher> North-Holland, </publisher> <year> 1991. </year>
Reference-contexts: Within program (2) semantic analysis determines the monotonicity of the expression s + f [ - y : y in domain f | y subset s - ] relative to p arameter s, and finds the types of the sub-expressions (as described in <ref> [6] </ref>). <p> Although it would be highly efficient to obtain this subtype information (as we do for type information) by analysis of the brief text (2) and by efficient transformational propagation (as was proposed in <ref> [6] </ref>)), we did not do so for the following reason. Because subtyping relations depend on the way programs are written, they need to be updated when programs are transformed. To recompute these relations from scratch after each such transformation would take too much compute time. <p> Comparative benchmarks indicate that the Ada code generated from SETL ran between two and three times slower than the SETL runtime, a result of simple default data structures for sets and no data structure optimization <ref> [6] </ref>. There are several factors that can explain our benchmarks. Certainly, our SETL2-to-C translator eliminates interpretive overhead that exists in both SETL and SETL2. However, we d o not believe that this is a major factor.
Reference: 7. <author> Cai, J. and Paige, R., </author> <title> ``Binding Performance at Language Design Time,'' </title> <booktitle> in ACM P OPL, </booktitle> <pages> pp. 85 - 97, </pages> <month> Jan, </month> <year> 1987. </year>
Reference: 8. <author> Cai, J. and Paige, R., </author> <title> ``Languages Polynomial in the Input Plus Output,'' in Algebraic Methodology and Software Technology, </title> <editor> ed. M. Nivat, C. Rattray, T. Rus, and G. Scollo, </editor> <booktitle> Workshops in Computing Series, </booktitle> <pages> pp. 287 - 302, </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: 9. <author> Cai, J., Paige, R., and Tarjan, R., </author> <title> ``More Efficient Bottom-Up Multi-Pattern Matching In Trees,'' </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 106, no. 1, </volume> <pages> pp. 21 - 60, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: It then applies transformation T to the program to obtained a new transformed program. Consequently, the PDB must be updated to be consistent with the new program and the RDB. The inference and transformation engines make use of our highly efficient bottom up pattern matching algorithm <ref> [9] </ref>. The inference engine used to calculate RDB relations combines our fast bottom up pattern matching [9] with RETE style pattern matching [16] and seminaive evaluation of Datalog [2,1,41]. Like the RETE algorithm, the APTS inference engine avoids redundant search through the PDB. <p> Consequently, the PDB must be updated to be consistent with the new program and the RDB. The inference and transformation engines make use of our highly efficient bottom up pattern matching algorithm <ref> [9] </ref>. The inference engine used to calculate RDB relations combines our fast bottom up pattern matching [9] with RETE style pattern matching [16] and seminaive evaluation of Datalog [2,1,41]. Like the RETE algorithm, the APTS inference engine avoids redundant search through the PDB. However, its bottom up tree multi-pattern matching algorithm is faster then the RETE algorithm.
Reference: 10. <author> Cai, J., </author> <title> A Language for Semantic Analysis, </title> <institution> New Y ork University, </institution> <year> 1993. </year> <type> Technical Report </type>
Reference-contexts: However, its bottom up tree multi-pattern matching algorithm is faster then the RETE algorithm. Like seminaive evaluation, the APTS inference engine reduces the number of redundant modifications (i.e., actions) to the PDB. However, its differential techniques generate fewer intermediate relations <ref> [10] </ref>. In the attribute grammar approach to semantic analysis [21] (which is used, for example, by the Synthesizer Generator [32]) the program syntax tree is the main data structure on top of which the attributed dag is laid.
Reference: 11. <author> Cousot, P. and Cousot, R., </author> <title> ``Constructive versions of Tarski's fixed point theorems,'' </title> <journal> Pacific J. Math., </journal> <volume> vol. 82, no. 1, </volume> <pages> pp. 43-57, </pages> <year> 1979. </year>
Reference: 12. <author> Dewar, R., Grand, A., Liu S. C., Schwartz, J. T., and Schonberg, E., </author> <title> ``Program by Refinement, as Exemplified by the SETL Representation Sublanguage,'' </title> <journal> TOPLAS, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 27-49, </pages> <month> July, </month> <year> 1979. </year>
Reference: 13. <author> Dijkstra, E. W., </author> <title> ``A note on two p roblems in connexion with graphs,'' </title> <journal> Numer. Math., </journal> <volume> vol. 1, no. 5, </volume> <pages> pp. 269-271, </pages> <year> 1959. </year>
Reference-contexts: are denoted by reach (use an arbitrary search to compute all vertices reachable along paths in a directed graph from a given subset of vertices), maxind (compute a maximal independent set in an undirected graph), dijkstra1 (Dijkstra's single source shortest path algorithm for dense directed graphs with non-negative edge weights <ref> [13] </ref>), cycle (cycle decision procedure for undirected graphs), center (find the center of a free tree), aclose (compute the relational attribute closure), topsort (Knuth's topological sorting algorithm [22]), dijkstra2 (same as dijkstra1, but for nondense graphs using 2-heaps), orbit (compute the orbit of a finite function [24]). <p> The sizes of the SETL2 specifications ranged from 25 lines for a maximal independent set algorithm to 103 lines for an implementation of Dijkstra's single source shortest path algorithm <ref> [13] </ref> with 2-heaps (see dijkstra2 in Fig. 2). The Generated C programs ranged from 133 lines for graph reachability to 766 lines for Dijkstra's algorithm with 2-heaps.
Reference: 14. <author> Doberkat, E. and Gutenbeil, U., </author> <title> ``SETL to Ada - tree transformations applied,'' </title> <journal> Information and Software Technology, </journal> <volume> vol. 29, no. 10, </volume> <pages> pp. 548-557, </pages> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: We believe that much of this could be fixed by a better utilization of reference counts and improved code generation. It is also interesting to note Doberkat's related effort to mechanically translate SETL into Ada <ref> [14] </ref> within the Mentor environment [15]. Comparative benchmarks indicate that the Ada code generated from SETL ran between two and three times slower than the SETL runtime, a result of simple default data structures for sets and no data structure optimization [6].
Reference: 15. <author> Donzeau-Gouge, V., Huet, G., Kahn, G., and Lang, B., </author> <title> ``Programming environments based on structured Editors: the Mentor Experience,'' in Interactive Programming Environments, </title> <editor> ed. D. Barstow, H. S hrobe, and E. Sande-wall, </editor> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference-contexts: We believe that much of this could be fixed by a better utilization of reference counts and improved code generation. It is also interesting to note Doberkat's related effort to mechanically translate SETL into Ada [14] within the Mentor environment <ref> [15] </ref>. Comparative benchmarks indicate that the Ada code generated from SETL ran between two and three times slower than the SETL runtime, a result of simple default data structures for sets and no data structure optimization [6]. There are several factors that can explain our benchmarks.
Reference: 16. <author> Forgy, C., </author> <title> ``RETE, a fast algorithm for the many patterns many objects Match problem,'' </title> <journal> Aritifical Intelligence, </journal> <volume> vol. 19, </volume> <pages> pp. 17-37, </pages> <year> 1982. </year>
Reference-contexts: The inference and transformation engines make use of our highly efficient bottom up pattern matching algorithm [9]. The inference engine used to calculate RDB relations combines our fast bottom up pattern matching [9] with RETE style pattern matching <ref> [16] </ref> and seminaive evaluation of Datalog [2,1,41]. Like the RETE algorithm, the APTS inference engine avoids redundant search through the PDB. However, its bottom up tree multi-pattern matching algorithm is faster then the RETE algorithm.
Reference: 17. <author> Freudenberger, S., Schwartz, J. T., and Sharir, M., </author> <title> ``Experience with the SETL Optimizer,'' </title> <journal> ACM TOPLAS, </journal> <volume> vol. 5, no. 1, </volume> <pages> pp. 26-45, </pages> <year> 1983. </year>
Reference: 18. <author> Hindley, J., </author> <title> ``The principal type-scheme of an object in combinatory logic,'' </title> <journal> Tr ans. AMS, </journal> <volume> no. 146, </volume> <pages> pp. 29 - 60., </pages> <year> 1969. </year>
Reference-contexts: SQ2+ is a high level declaration-free language, where semantic details are isolated in the syntax. In our methodology such details are extracted by Hindley <ref> [18] </ref> and Milner-style [23] inference, and propagated by transformation down to lower levels of abstraction, where these details are used to justify further transformations.
Reference: 19. <author> Iverson, K., </author> <title> A Pro gramming Language, </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1962. </year>
Reference-contexts: Our definition of programming productivity in terms of source code lines produced per unit time of manual labor needs some justification. It is well known that short but obscure programs can be written in APL <ref> [19] </ref> (with its overabundance of overloaded operators) or in languages that make use of higher order functions. Complex abstraction mechanisms can also serve to compress programs, sometimes at the expense of clarity. Certainly programs rampant with pointers or other dictions realizing indirection can be obscure, if they are not brief.
Reference: 20. <author> Kernighan, B. and Ritchie, D., </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: We used APTS to build two compilers for conducting experiments to test the feasibility of these techniques. One of these compilers translates a major fragment of SETL2 [37] into C <ref> [20] </ref>. The other translates SQ2+ [5] (a strongly typed functional subset of SETL2 augmented with fixed point expressions) into C.
Reference: 21. <author> Knuth, D. E., </author> <title> ``Semantics of Context-free Languages,'' </title> <journal> Mathematical Systems Theory, </journal> <volume> vol. 2, no. 2, </volume> <pages> pp. 127-145, </pages> <year> 1968. </year>
Reference-contexts: However, its bottom up tree multi-pattern matching algorithm is faster then the RETE algorithm. Like seminaive evaluation, the APTS inference engine reduces the number of redundant modifications (i.e., actions) to the PDB. However, its differential techniques generate fewer intermediate relations [10]. In the attribute grammar approach to semantic analysis <ref> [21] </ref> (which is used, for example, by the Synthesizer Generator [32]) the program syntax tree is the main data structure on top of which the attributed dag is laid.
Reference: 22. <author> Knuth, D. E., </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol 1: </volume> <booktitle> Fundamental Algorithms, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: a maximal independent set in an undirected graph), dijkstra1 (Dijkstra's single source shortest path algorithm for dense directed graphs with non-negative edge weights [13]), cycle (cycle decision procedure for undirected graphs), center (find the center of a free tree), aclose (compute the relational attribute closure), topsort (Knuth's topological sorting algorithm <ref> [22] </ref>), dijkstra2 (same as dijkstra1, but for nondense graphs using 2-heaps), orbit (compute the orbit of a finite function [24]). For nine of these algorithms benchmarks were made comparing executable low lev el SETL2 specifications with C codes automatically generated from them (see Fig. 1).
Reference: 23. <author> Milner, R., </author> <title> ``A theory of type polymorphism in programming,'' </title> <journal> J. Computer and System Sciences, v ol. </journal> <volume> 17, no. 3, </volume> <pages> pp. 348 - 375, </pages> <year> 1978. </year>
Reference-contexts: SQ2+ is a high level declaration-free language, where semantic details are isolated in the syntax. In our methodology such details are extracted by Hindley [18] and Milner-style <ref> [23] </ref> inference, and propagated by transformation down to lower levels of abstraction, where these details are used to justify further transformations.
Reference: 24. <author> Paige, R., </author> <title> ``Programming With Invariants,'' </title> <journal> IEEE Software, </journal> <volume> vol. 3, no. 1, </volume> <pages> pp. 56-69, </pages> <month> Jan, </month> <year> 1986. </year>
Reference-contexts: An inference engine analyzes the program (being compiled) for properties specified in the RDB, and it outputs the PROGRAM DAT ABASE (PDB) of finite relations storing the program's properties. The TRANSFORMATION DAT A BASE (TDB) contains conditional meaning preserving program transformations of two kinds rewriting or finite differencing <ref> [24] </ref>. A transformation engine selects a transformation T by matching T with a portion of the program and by ensuring that the applicability condition for T, when instantiated with the current PDB, is satisfied. It then applies transformation T to the program to obtained a new transformed program. <p> with non-negative edge weights [13]), cycle (cycle decision procedure for undirected graphs), center (find the center of a free tree), aclose (compute the relational attribute closure), topsort (Knuth's topological sorting algorithm [22]), dijkstra2 (same as dijkstra1, but for nondense graphs using 2-heaps), orbit (compute the orbit of a finite function <ref> [24] </ref>). For nine of these algorithms benchmarks were made comparing executable low lev el SETL2 specifications with C codes automatically generated from them (see Fig. 1).
Reference: 25. <author> Paige, R. and Henglein, F., </author> <title> ``Mechanical Translation of Set Theoretic Problem Specifications Into Efficient RAM Code - A Case Study,'' </title> <journal> Journal of Symbolic Computation, </journal> <volume> vol. 4, no. 2, </volume> <pages> pp. 207-232, </pages> <month> Aug., </month> <year> 1987. </year>
Reference-contexts: The code fragments shown below form part of a `photo' generated APTS derivation performed by our SQ2+-to-C compiler. This derivation resembles a partially automated derivation of the same algorithm that was sketched previously in <ref> [25] </ref>. The attribute closure problem inputs a finite set x of attributes and a finite set f of functional dependencies, and outputs the set of attributes logically implied by f and x.
Reference: 26. <author> Paige, R., </author> <title> ``Real-time Simulation of a Set Machine on a RAM,'' in ICCI '89, </title> <editor> e d. R. Janicki and W. Koczkodaj, </editor> <booktitle> Computing and Information, </booktitle> <volume> Vol II, </volume> <pages> pp. 69-73, </pages> <year> 1989. </year>
Reference: 27. <author> Paige, R. and Henglein, F., </author> <title> ``Mechanical Translation of Set Theoretic Problem Specifications Into Efficient RAM Code - A Case Study,'' in EUROCAL 85, </title> <editor> ed. B. Caviness, </editor> <booktitle> Lecture Notes in Computer Science 204, </booktitle> <pages> pp. 554-567, </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference: 28. <author> Paige, R., </author> <title> ``The High Cost of Reading,'' </title> <note> in Liber Amico-rum Lambert Meertens 1966 - 1991, </note> <editor> ed. Johan Jeuring, pp. </editor> <volume> 55 - 65, </volume> <pages> CWI, </pages> <year> 1991. </year>
Reference-contexts: APTS has a general purpose procedure to convert SETL data into a form that can be accepted by a C input macro and stored within the initial data structures. Because of some encouraging new algorithmic results <ref> [28] </ref> we believe that this transformation can actually be performed efficiently at runtime as part of a generic C procedure to read high level input directly. 4. <p> Iteration over a SETL2 set does not force us to resort to hashing. Our proposal to input data and to form initial data structures is highly efficient without making use of hashing <ref> [28] </ref>. 7. Conclusion Algorithms (like those used in Operations Research) are often complex; their actual performance on different data sets are often unpredictable without extensive testing.
Reference: 29. <author> Paige, R., </author> <title> ``APTS Reference Manual,'' </title> <type> unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: Hence, we are able to consider every aspect of system functioning for algorithmic improvement, which is also the focus of our research. It is a meta-transformational environment with convenient meta-tools for syntax, semantics, conditional rewriting, and built-in finite differencing supporting a single integrated transformational language called RSL <ref> [29] </ref>. This language has been designed to support very complex transformations based on algorithm design principles. The language also supports complex program analysis needed to justify such transformations. Our SQ2+ and SETL2-to-C compilers are written in about 9,000 lines of RSL. RSL compilers make use of the following APTS components.
Reference: 30. <author> Paige, R. and Koenig, S., </author> <title> ``Finite Differencing of Computable Expressions,'' </title> <journal> ACM TOPLAS, </journal> <volume> vol. 4, no. 3, </volume> <pages> pp. 402-454, </pages> <month> July, </month> <year> 1982. </year>
Reference-contexts: The finite differencing transformation <ref> [30] </ref> automatically detects invariants (shown below as named equalities) that should be maintained in order to avoid the costly repeated calculation of the truth set at the top of the while-loop of (3). b-y- = - x2 in y | x2 notin a - c (y) = # b - y
Reference: 31. <editor> Refine User's Guide Version 3.0, </editor> <booktitle> Reasoning Systems, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: SETL2 is written in C, which makes APTS portable to more machines than other competing systems such as Centaur [4] and Refine <ref> [31] </ref>. APTS is seamless in the sense of having no foreign tools and uniform data structures throughout. Hence, we are able to consider every aspect of system functioning for algorithmic improvement, which is also the focus of our research.
Reference: 32. <author> Reps, T. and Teitelbaum, T., </author> <title> The Synthesizer Generator, </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Like seminaive evaluation, the APTS inference engine reduces the number of redundant modifications (i.e., actions) to the PDB. However, its differential techniques generate fewer intermediate relations [10]. In the attribute grammar approach to semantic analysis [21] (which is used, for example, by the Synthesizer Generator <ref> [32] </ref>) the program syntax tree is the main data structure on top of which the attributed dag is laid.
Reference: 33. <author> Schonberg, E., Schwartz, J. T., and Sharir, M., </author> <title> ``An Automatic Technique for Selection of Data Representations in in SETL Programs,'' </title> <journal> ACM TOPLAS, </journal> <volume> vol. 3, no. 2, </volume> <pages> pp. 126-143, </pages> <month> Apr, </month> <year> 1981. </year>
Reference: 34. <author> Schwartz, J.T., </author> <title> ``Automatic Data Structure Choice in a Language of Very High Level,'' </title> <journal> CACM, </journal> <volume> vol. 18, no. 12, </volume> <pages> pp. 722-728, </pages> <month> Dec, </month> <year> 1975. </year>
Reference-contexts: Our final transformation implements all set and map datatypes using array and list data structures. This transformation, which is related to Schwartz <ref> [34] </ref>, rests on the discovery of finite universal sets, called bases, to be used for avoiding data replication and for creating aggregate data structures that implement logical associative access operations using simpler cursor or pointer access.
Reference: 35. <author> Schwartz, J., Dewar, R., Dubinsky, D., and Schonberg, E., </author> <title> Programming with Sets: An introduction to SETL, </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Recall also, that only one out of the 9 modules was translated into C. 6. Previous Results The SETL research program directed by Jack Schwartz from about 1971 until 1989 <ref> [35] </ref> has had the most positive inu-ence on our work. Schwartz effectively demonstrated the conceptual simplicity of the SETL language with its rich repertoire of universal set theoretic dictions, and introduced many important concepts in an attempt to solve the formidable task of implementation and optimization. <p> SETL2 has only run-time type checking. The best implementations of both SETL and SETL2 are interpreted systems. Framed in the context of previous results coming out of the SETL project <ref> [35] </ref>, our results are surprising. The SETL project concentrated on methods to improve the performance of a default implementation that had hashed data structures for sets and maps. An optimizer of over 20,000 lines of SETL was produced, but was never fully operational [33,17,35]. <p> Certainly, our SETL2-to-C translator eliminates interpretive overhead that exists in both SETL and SETL2. However, we d o not believe that this is a major factor. I n Dav e Shields's empiri-cal study [36] the interpretive overhead in the SETL system <ref> [35] </ref> was reported to contribute between 50% and 80% of the runtime performance. Assuming this is also true for SETL2, then a factor of between six and fifteen from the thirty-fold improvement in SETL2-to-C translation over the SETL2 interpreted system results from real-time simulation.
Reference: 36. <author> Shields, R., </author> <title> ``Measuring SETL Performance,'' </title> <type> Ph.D. Dissertation, </type> <institution> Computer Sciences Dept., NYU, </institution> <year> 1983. </year>
Reference-contexts: There are several factors that can explain our benchmarks. Certainly, our SETL2-to-C translator eliminates interpretive overhead that exists in both SETL and SETL2. However, we d o not believe that this is a major factor. I n Dav e Shields's empiri-cal study <ref> [36] </ref> the interpretive overhead in the SETL system [35] was reported to contribute between 50% and 80% of the runtime performance.
Reference: 37. <author> Snyder, K., </author> <title> The SETL2 Programming Language, </title> <type> Technical Report 490, </type> <institution> Courant Institute/ New York University, </institution> <address> New York, NY 10012, </address> <year> 1990. </year>
Reference-contexts: We used APTS to build two compilers for conducting experiments to test the feasibility of these techniques. One of these compilers translates a major fragment of SETL2 <ref> [37] </ref> into C [20]. The other translates SQ2+ [5] (a strongly typed functional subset of SETL2 augmented with fixed point expressions) into C.
Reference: 38. <author> Straub, R., ``Taliere: </author> <title> An Interactive System for Data Structuring SETL Programs,'' </title> <type> Ph.D. Dissertation, </type> <institution> Dept. of Computer Science, </institution> <address> New York University, New York, NY, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: An optimizer of over 20,000 lines of SETL was produced, but was never fully operational [33,17,35]. Tw o dissertations evaluating the SETL optimizer and data elaboration language failed to observe any speedup [36,38]. Straub <ref> [38] </ref> reported that annotating SETL programs to indicate how to implement sets and maps rarely improved performance and often slowed it down considerably. He attributed much of the slow speed to the inefficiency of hashing that could not be eliminated in the optimized SETL data structures.
Reference: 39. <author> Tarski, A., </author> <title> ``A Lattice-Theoretical Fixpoint Theorem and its Application,'' </title> <journal> Pacific J. of Mathematics, </journal> <volume> vol. 5, </volume> <pages> pp. 285-309, </pages> <year> 1955. </year>
Reference: 40. <author> Tenenbaum, A., </author> <title> Type Determination for Very High Level Languages, </title> <institution> New York University, Dept. of Computer Science, </institution> <month> Oct, </month> <year> 1974. </year> <note> appears in Courant Computer Science Report 3 </note>
Reference-contexts: It's optimized data structures combined hashing with bit vectors and plex structures to reduce the amount of replicated data and the expense of hashing [12,33,17]. SETL2 uses tries, and attempts no compile-time optimization. SETL attempted to generate more efficient code using type analysis <ref> [40] </ref> with an accuracy up to three levels of nesting for sets, maps, and tuples (in order to guarantee termination of type inference). SETL2 has only run-time type checking. The best implementations of both SETL and SETL2 are interpreted systems.
Reference: 41. <author> Ullman, J., </author> <title> Principles of Database and Knowledge-Base Systems, I, </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Our SQ2+ and SETL2-to-C compilers are written in about 9,000 lines of RSL. RSL compilers make use of the following APTS components. The RULE DAT ABASE (RDB) contains inference rules specifying program properties, e.g. type or dataow. Inference rules are specified in a language similar to Datalog <ref> [41] </ref> augmented with function symbols and primitive pattern matching predicates. An inference engine analyzes the program (being compiled) for properties specified in the RDB, and it outputs the PROGRAM DAT ABASE (PDB) of finite relations storing the program's properties.
References-found: 41

