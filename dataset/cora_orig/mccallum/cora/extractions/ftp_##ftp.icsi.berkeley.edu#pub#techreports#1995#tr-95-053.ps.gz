URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-053.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1995.html
Root-URL: http://www.icsi.berkeley.edu
Title: Efficient Implementation of Multi-Methods through static analysis  
Author: Volker Turau Weimin Chen 
Note: on leave from: FH Wiesbaden,  
Address: I 1947 Center St. Suite 600 Berkeley, California 94704-1198  Kurt-Schumacher-Ring 3, 65197 Wiesbaden, Germany,  Dolivostr.15 64293 Darmstadt, Germany,  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  Fachbereich Informatik,  ICSI GMD Integrated Publication and Information Systems Institute,  
Pubnum: TR-95-053  
Email: turau@informatik.fh-wiesbaden.de  chen@darmstadt.gmd.de  
Phone: (510) 643-9153 FAX (510) 643-7684  
Date: September 1995  
Abstract: Some of the benefits of object-oriented programming such as extensibility and reusability are fundamentally based on inheritance and late binding. Dynamic dispatching is not only time consuming but it also prevents the usage of some optimization techniques such as inlining or interprocedural analysis. The situation is even more severe for languages supporting multi-methods, where dispatching is not only performed based on the type of the receiver, but also based on the types of the arguments. The most efficient way to perform dynamic dispatching is to avoid it as often as possible, without restricting the use of multi-methods. In this paper it is shown how this goal can be achieved through static analysis. We present a technique which discards all method calls which can be statically bound. Furthermore, even if a method cannot be statically bound, we derive information which will at run time speed up the dispatching process considerably. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Amiel, E., Gruber, O. and Simon E. </author> <title> Optimizing Multi-Method Dispatch Using Compressed Dispatch Tables. </title> <booktitle> Proc. Conf. OOPSLA, </booktitle> <year> 1994. </year>
Reference-contexts: Even so there are techniques available to reduce the complexity of multi-method dispatch, they still have the above mentioned disadvantages <ref> [1, 2] </ref>. It is therefore worth seeking for mechanisms to avoid dynamic dispatching for multi-methods as often as possible without restricting the use of them. <p> Research into the second direction can be classified into dynamic and static techniques. Dynamic techniques are based on caches and their organization [10, 8]. Static techniques 1 usually aim at finding data structures which are both time and space efficient. Compressing dispatch tables is one possibility <ref> [1] </ref>. The above mentioned techniques are available for single and multi dispatched methods, even so things are much more complicated in the second case. In a previous paper we have presented a technique for dispatching based on automata which is suitable for multi-methods [2, 11]. <p> In a previous paper we have presented a technique for dispatching based on automata which is suitable for multi-methods [2, 11]. The used lookup automaton realizes dispatch without needing a lot of time and space resources. The space requirements are in no case larger then those reported in <ref> [1] </ref>. The outline of this paper is as follows. In section 2 we present the overall approach. In section 3 we briefly review the concept of the lookup automaton. <p> In a 2-dimensional array for each type and position the corresponding set number is recorded. This way dispatching consists of a few array accesses. The size of the array is in no case larger then those constructed in <ref> [1] </ref>. 4 Binding methods statically In statically typed languages single dispatching can be performed rather efficiently (for example through virtual function tables in C ++ ). Furthermore in some cases it is possible to eliminate dynamic dispatching by binding methods statically. These cases can be found through static analysis. <p> The algorithms are based on a lookup automaton which we have presented previously. Even in the case of cross product patterns, for which the LUA needs a large amount of space, many methods can be bound statically <ref> [2, 1] </ref>. The next step is to implement the algorithm and to test real examples to measure the effects and to have means to decide in which cases it is better to realize the LUA by type-case expressions. 9
Reference: [2] <author> Chen, W. and Turau V. </author> <title> Multiple Dispatching Based On Automata. </title> <journal> J. </journal> <note> Theory and Practice of Object Systems 1 (1), </note> <year> 1995. </year>
Reference-contexts: Even so there are techniques available to reduce the complexity of multi-method dispatch, they still have the above mentioned disadvantages <ref> [1, 2] </ref>. It is therefore worth seeking for mechanisms to avoid dynamic dispatching for multi-methods as often as possible without restricting the use of them. <p> Compressing dispatch tables is one possibility [1]. The above mentioned techniques are available for single and multi dispatched methods, even so things are much more complicated in the second case. In a previous paper we have presented a technique for dispatching based on automata which is suitable for multi-methods <ref> [2, 11] </ref>. The used lookup automaton realizes dispatch without needing a lot of time and space resources. The space requirements are in no case larger then those reported in [1]. The outline of this paper is as follows. In section 2 we present the overall approach. <p> The first two steps have been covered in <ref> [2] </ref>. The aim of this paper is to present an efficient algorithm for the remaining steps. Especially we demonstrate how steps 3 and 4 can be performed using the LUA. Finally we demonstrate how the last step can be realized. The notation of this paper follows [2]. 2 3 The lookup <p> have been covered in <ref> [2] </ref>. The aim of this paper is to present an efficient algorithm for the remaining steps. Especially we demonstrate how steps 3 and 4 can be performed using the LUA. Finally we demonstrate how the last step can be realized. The notation of this paper follows [2]. 2 3 The lookup automaton LUA Let (T ; ) be a type hierarchy possibly with multiple inheritance, in which the types are ordered either globally or by a local type ordering. Furthermore let M be a set of multi-methods with name m and arity n. <p> Note that the construction guarantees, that the LU B`s are either unique or do not exist. In the latter case a type error has occurred. The LUA can be used for statically and dynamically typed languages. It has several advantages. In <ref> [2] </ref> it is proven, that the number of states of the LUA is minimal under certain conditions. It can be implemented with standard automaton techniques or by a multidimensional array. <p> The algorithms are based on a lookup automaton which we have presented previously. Even in the case of cross product patterns, for which the LUA needs a large amount of space, many methods can be bound statically <ref> [2, 1] </ref>. The next step is to implement the algorithm and to test real examples to measure the effects and to have means to decide in which cases it is better to realize the LUA by type-case expressions. 9
Reference: [3] <author> Chen, W. and Aberer, K. </author> <title> Efficient Multiple Dispatching Using Nested Transition-Arrays. Arbeitspapiere der GMD No. </title> <type> 906, </type> <address> Sankt Augustin, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: There are other alternative definitions which order the applicable methods only partially. When there are several methods applicable an error message ambiguous is signaled [4]. Our approach can also be used for this definition <ref> [3] </ref>. Figure 1 shows an example we will use in this paper. The type hierarchy consists of 8 types which are ordered using a local type ordering. There are three multi-methods m 1 ; m 2 and m 3 .
Reference: [4] <author> Chambers, C. </author> <title> Object-oriented multi-methods in Cecil. </title> <booktitle> Proc. ECOOP 1991. </booktitle>
Reference-contexts: There are other alternative definitions which order the applicable methods only partially. When there are several methods applicable an error message ambiguous is signaled <ref> [4] </ref>. Our approach can also be used for this definition [3]. Figure 1 shows an example we will use in this paper. The type hierarchy consists of 8 types which are ordered using a local type ordering. There are three multi-methods m 1 ; m 2 and m 3 .
Reference: [5] <author> Dean, J., Chambers, C. and Grove, D. </author> <title> Selective Specialization for Object-Oriented Languages. </title> <booktitle> Proc. Conf. PLDI, </booktitle> <year> 1995. </year>
Reference-contexts: This will also be of benefit for languages not supporting multi-methods within the framework of the language, because the technique of specialization used to optimize object-oriented languages in general may lead to the need of multi-methods at an internal level <ref> [5] </ref>. One of the goals of optimization techniques for multi-methods should be the recognition of all cases where methods can be statically bound. In this paper it is shown how this goal can be achieved for statically typed languages.
Reference: [6] <author> Dean, J., Grove, D. and Chambers, C. </author> <title> Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. </title> <booktitle> Proc. ECOOP 1995. </booktitle>
Reference-contexts: In case the receiver's class can be narrowed down to a small set, then the method call can be realized by type-case expressions, where each case results in a static function call <ref> [6] </ref>. Profile-guided receiver class prediction receives its information about classes of receivers by monitoring the execution of a program. This way statistics are gathered and based on these type-case expressions are inserted into the code, given preference to classes which occurred more often. Then the program is recompiled [7, 9]. <p> Generating this code naturally increases the code of an application program, but it also allows other optimization techniques such as interprocedural analysis to be applied. 6 Other related work The only other work on static analysis for multi-methods that we are aware of is the work of Dean et. al. <ref> [6] </ref>. Their approach consists of calculating for each multi-method m the so called applies-to tuples. This set consists of all tuples of types, for which m will be dispatched. For each method invocation, they calculate a set which consists of all tuples of subtypes of the types of the invocation.
Reference: [7] <author> Grove, D., Dean, J., Garrett C. and Chambers, C. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> Proc. Conf. OOPSLA, </booktitle> <year> 1995. </year>
Reference-contexts: Profile-guided receiver class prediction receives its information about classes of receivers by monitoring the execution of a program. This way statistics are gathered and based on these type-case expressions are inserted into the code, given preference to classes which occurred more often. Then the program is recompiled <ref> [7, 9] </ref>. Research into the second direction can be classified into dynamic and static techniques. Dynamic techniques are based on caches and their organization [10, 8]. Static techniques 1 usually aim at finding data structures which are both time and space efficient. Compressing dispatch tables is one possibility [1].
Reference: [8] <author> Holzle, U., Chambers, C. and Ungar, D. </author> <title> Optimizing Dynamically-Typed Object-Oriented Languages with Polymorphic Inline Caches. </title> <booktitle> Proc. ECOOP 1991. </booktitle>
Reference-contexts: Then the program is recompiled [7, 9]. Research into the second direction can be classified into dynamic and static techniques. Dynamic techniques are based on caches and their organization <ref> [10, 8] </ref>. Static techniques 1 usually aim at finding data structures which are both time and space efficient. Compressing dispatch tables is one possibility [1]. The above mentioned techniques are available for single and multi dispatched methods, even so things are much more complicated in the second case.
Reference: [9] <author> Holzle, U. and Ungar, D. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <booktitle> Proc. Conf. PLDI, </booktitle> <year> 1994. </year>
Reference-contexts: Profile-guided receiver class prediction receives its information about classes of receivers by monitoring the execution of a program. This way statistics are gathered and based on these type-case expressions are inserted into the code, given preference to classes which occurred more often. Then the program is recompiled <ref> [7, 9] </ref>. Research into the second direction can be classified into dynamic and static techniques. Dynamic techniques are based on caches and their organization [10, 8]. Static techniques 1 usually aim at finding data structures which are both time and space efficient. Compressing dispatch tables is one possibility [1].
Reference: [10] <author> Kiczales G. and Rodriguez, L. </author> <title> Efficient Method Dispatch in PCL. </title> <booktitle> Proc. Conf. on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: Then the program is recompiled [7, 9]. Research into the second direction can be classified into dynamic and static techniques. Dynamic techniques are based on caches and their organization <ref> [10, 8] </ref>. Static techniques 1 usually aim at finding data structures which are both time and space efficient. Compressing dispatch tables is one possibility [1]. The above mentioned techniques are available for single and multi dispatched methods, even so things are much more complicated in the second case.
Reference: [11] <author> Turau, V. and Chen, W. </author> <title> GLB-Closures in Directed Acyclic Graphs and their Applications. </title> <booktitle> Proc. Workshop on Graph Theoretic Algorithms in Computer Science, </booktitle> <year> 1994. </year> <month> 10 </month>
Reference-contexts: Compressing dispatch tables is one possibility [1]. The above mentioned techniques are available for single and multi dispatched methods, even so things are much more complicated in the second case. In a previous paper we have presented a technique for dispatching based on automata which is suitable for multi-methods <ref> [2, 11] </ref>. The used lookup automaton realizes dispatch without needing a lot of time and space resources. The space requirements are in no case larger then those reported in [1]. The outline of this paper is as follows. In section 2 we present the overall approach.
References-found: 11

