URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1990/UM-CS-1990-118.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/90-118.html
Root-URL: 
Title: Automated Analysis of Concurrent and Real-Time Software  
Author: George S. Avrunin Jack C. Wileden 
Address: Amherst, MA 01003  Amherst, MA 01003  
Affiliation: Department of Mathematics and Statistics University of Massachusetts  Department of Computer and Information Science University of Massachusetts  
Abstract: This paper surveys the current status of our work on automated analysis of the logical and timing properties of concurrent software based on the constrained expression approach. It describes our analysis toolset, reports some extremely encouraging results of using the toolset to analyze logical properties of nontrivial concurrent systems, and discusses the modifications we have made to the toolset to apply it to analyzing timing properties. It then outlines ongoing and planned research directed at further improving these methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Proceedings of the International Workshop on Real-Time Ada Issues, sponsored by Ada UK and ACM SIGAda, </institution> <month> May </month> <year> 1987. </year> <note> Appeared as Ada Letters, 7(6), Fall 1987. </note>
Reference-contexts: Despite Ada's shortcomings as a language for real-time software <ref> [1] </ref>, we have used CEDL and the existing deriver in our initial experiments with analysis of timing properties. The deriver [2] produces constrained expression representations from CEDL system designs.
Reference: [2] <author> S. Avery. </author> <title> A tool for producing constrained expression representations of CEDL designs. </title> <institution> Software Development Laboratory Memo 89-2, Department of Computer and Information Science, University of Massachusetts, </institution> <year> 1989. </year>
Reference-contexts: Despite Ada's shortcomings as a language for real-time software [1], we have used CEDL and the existing deriver in our initial experiments with analysis of timing properties. The deriver <ref> [2] </ref> produces constrained expression representations from CEDL system designs. The system expressions it produces consist of the interleave of regular expressions, called task expressions, representing the behavior of the various components (called tasks in Ada, and hence in CEDL, terminology) of the concurrent system.
Reference: [3] <author> G. S. Avrunin, U. Buy, and J. Corbett. </author> <title> Automatic generation of inequality systems for constrained expression analysis. </title> <type> Technical Report 90-32, </type> <institution> Department of Computer and Information Science, University of Mas-sachusetts, Amherst, </institution> <year> 1990. </year>
Reference-contexts: We have found that, in general, it is best to work from the REDFA representation of tasks. The current implementation of the constraint eliminator, therefore, can replace the eliminated task expression with a regular expression, a DFA, or an REDFA, as specified by the user. The inequality generator <ref> [3] </ref> takes a constrained expression representation as input.
Reference: [4] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <note> Submitted for publication. Available as Technical Report 90-116, </note> <institution> Department of Computer and Information Science, University of Massachusetts, Amherst. </institution>
Reference-contexts: This section contains a brief overview of the constrained expression formalism. Detailed and rigorous presentations of the formalism appear in [12] and in the appendix to [14], while less formal treatments intended to provide a more intuitive understanding of the features of the formalism appear in [7] and <ref> [4] </ref>. The use of constrained expressions with a variety of development notations is illustrated in [7] and [14]. A detailed discussion of the relation between constrained expressions and a variety of other methods for describing and analyzing concurrent software systems can be found in [7] and [17]. <p> While this suggests that behaviors must be viewed as total orders on events, in fact the constrained expression formalism is consistent with 4 viewing concurrent system behaviors either as total orders or as partial orders on events, as discussed in <ref> [4] </ref>. We use interleaving to represent concurrency. Thus, a string representing a possible behavior of a system that consists of several concurrently executing components is obtained by interleaving strings representing the behaviors of the components. The events themselves are assumed to be atomic and indivisible. <p> The reasons for this two-step process, which might not seem as straightforward as generating behaviors directly from a single expression, are discussed in [14], while an equivalent and more uniform interpretation process for constrained expressions is presented in <ref> [4] </ref>. Our main constrained expression analysis techniques require that questions about the behavior of a concurrent system be formulated in terms of whether a particular event symbol, or pattern of event symbols, occurs in a string representing a possible behavior of the system. <p> Over the last several years, we have developed a set of tools automating various aspects of constrained expression analysis and have achieved very good results in using them to analyze logical properties of a range of concurrent system examples <ref> [4] </ref>. We briefly describe the current version of the prototype toolset before discussing the application of the formalism, analysis techniques and toolset to analyzing both concurrent and real-time systems. <p> The organization of the toolset is illustrated in the figure. We give brief descriptions of the tools and their use below. A more detailed discussion of the toolset and its implementation appears in <ref> [4] </ref>. The current toolset is intended for use with designs written in the Ada-based design language CEDL (Constrained Expression Design Language) [13]. CEDL focuses on the expression of communication and synchronization among the tasks in a distributed system, and language features not related to concurrency are kept to a minimum. <p> For these reasons, which are discussed more fully in <ref> [4] </ref>, our systems of inequalities should be regarded as expressing necessary conditions that must be satisfied by any behavior of the concurrent system. <p> We report here the results of analysis of several versions of the dining philosophers problem in order to give some idea of the capabilities and performance of the toolset. Additional results on these problems and others, together with a more detailed and complete discussion, appear in <ref> [4] </ref>. <p> Our experiments have also suggested a number of directions for further improvements to the techniques and the tools that automate them. We outline a few of these here; more detailed discussions appear in <ref> [4] </ref> and [5]. The performance of our constrained expression toolset on a range of concurrent system analysis problems is already quite impressive.
Reference: [5] <author> G. S. Avrunin, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated constrained expression analysis of real-time software. </title> <note> Submitted for publication. Available as Technical Report 90-117, </note> <institution> Department of Computer and Information Science, University of Massachusetts, Amherst. </institution>
Reference-contexts: We now give an outline of this new approach. Details of our method and an example of its application can be found in <ref> [5] </ref>. We note that, although these extensions to the toolset were motivated by our interest in analyzing timing properties, they will also be valuable for analyses of logical properties that involve consideration of partial behaviors, such as detecting violations of mutual exclusion. <p> We now briefly describe a marking algorithm that reduces the problems due to cycles in DFAs and a procedure for generating additional equations to eliminate many solutions with unreachable initial states. Detailed descriptions of these methods are given in <ref> [5] </ref>. If upper bounds for all variables are introduced into the integer linear programming problem, the variables associated with cycles that can occur arbitrarily often will all take the maximum value in a solution to the equations giving an upper bound on durations. <p> The upper bounds found by the modified toolset are generally quite good, and frequently are indeed attained by subsequences of behaviors. Detailed discussion of the methods and an illustration of their application are given in <ref> [5] </ref>. 17 CONCLUSIONS AND FUTURE DIRECTIONS In this paper, we have given a brief, high-level description of the current status of our work on automated analysis of concurrent and real-time software. <p> Our experiments have also suggested a number of directions for further improvements to the techniques and the tools that automate them. We outline a few of these here; more detailed discussions appear in [4] and <ref> [5] </ref>. The performance of our constrained expression toolset on a range of concurrent system analysis problems is already quite impressive. Various changes to the toolset's components could make its performance even better, however, and changes to its user interface could make it much easier and more convenient to use.
Reference: [6] <author> G. S. Avrunin, L. K. Dillon, and J. C. Wileden. </author> <title> Constrained expression analysis of real-time systems. </title> <type> Technical Report 89-50, </type> <institution> Department of Computer and Information Science, University of Massachusetts, Amherst, </institution> <year> 1989. </year>
Reference-contexts: a behavior of the system? Such questions involve subsequences of events that might occur within the full sequences that correspond to complete system behaviors. (Of course, sometimes the subsequence of interest is the full sequence.) Our initial approach to applying the constrained expression toolset to the analysis of timing properties <ref> [6] </ref> was to manually modify the constrained expression generated by the deriver and constraint eliminator so that it represented (approximately) the subsequences of interest. In effect, this transformed questions about partial behaviors of the system into questions about complete behaviors of the system represented by the modified constrained expression.
Reference: [7] <author> G. S. Avrunin, L. K. Dillon, J. C. Wileden, and W. E. Riddle. </author> <title> Constrained expressions: Adding analysis capabilities to design methods for concurrent software systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> SE-12(2):278-292, </volume> <year> 1986. </year>
Reference-contexts: This section contains a brief overview of the constrained expression formalism. Detailed and rigorous presentations of the formalism appear in [12] and in the appendix to [14], while less formal treatments intended to provide a more intuitive understanding of the features of the formalism appear in <ref> [7] </ref> and [4]. The use of constrained expressions with a variety of development notations is illustrated in [7] and [14]. A detailed discussion of the relation between constrained expressions and a variety of other methods for describing and analyzing concurrent software systems can be found in [7] and [17]. <p> rigorous presentations of the formalism appear in [12] and in the appendix to [14], while less formal treatments intended to provide a more intuitive understanding of the features of the formalism appear in <ref> [7] </ref> and [4]. The use of constrained expressions with a variety of development notations is illustrated in [7] and [14]. A detailed discussion of the relation between constrained expressions and a variety of other methods for describing and analyzing concurrent software systems can be found in [7] and [17]. The constrained expression formalism treats the behaviors of a concurrent system as sequences of events. <p> the formalism appear in <ref> [7] </ref> and [4]. The use of constrained expressions with a variety of development notations is illustrated in [7] and [14]. A detailed discussion of the relation between constrained expressions and a variety of other methods for describing and analyzing concurrent software systems can be found in [7] and [17]. The constrained expression formalism treats the behaviors of a concurrent system as sequences of events. These events can be of arbitrary complexity, depending on the system characteristics of interest and the level of system description under consideration.
Reference: [8] <author> U. A. </author> <title> Buy. Solving integer programming problems using the IMINOS prototype. </title> <note> In preparation. 20 </note>
Reference-contexts: The inequality generator also provides an interactive facility allowing the analyst to add additional inequalities representing assumptions or queries about the behavior of the system and a reporting facility for use by a human analyst interpreting output of the integer programming package. The integer programming package, called IMINOS <ref> [8] </ref>, is a branch-and-bound integer linear programming system that we have implemented on top of the MINOS optimization package [15]. When the generated system of inequalities is consistent, the integer programming package produces a solution giving counts for the number of occurrences of the various event symbols.
Reference: [9] <author> J. C. Corbett. </author> <title> On selecting a form for inequality generation in the con-strained expression toolset. </title> <type> Constrained Expression Memorandum 90-1. </type> <institution> Department of Computer and Information Science, University of Mas-sachusetts, Amherst, </institution> <year> 1990. </year>
Reference-contexts: Although very compact systems of inequalities can be generated from regular expressions, the conversion of the DFA resulting from constraint elimination into a regular expression sometimes results in enormous regular expressions. Our student, James Corbett, investigated this problem <ref> [9] </ref>, and determined that, in certain cases, a more compact system of inequalities can be generated from the DFA representation of a task than from the regular expression into which that DFA would be converted. (In addition, this eliminates the cost of converting the DFA into a regular expression.) He also
Reference: [10] <author> J. C. Corbett. </author> <title> A tool for automatic elimination of constraints in constrained expression analysis. </title> <type> Constrained Expression Memorandum 90-2. </type> <institution> Department of Computer and Information Science, University of Mas-sachusetts, Amherst, </institution> <year> 1990. </year>
Reference-contexts: The system expressions it produces consist of the interleave of regular expressions, called task expressions, representing the behavior of the various components (called tasks in Ada, and hence in CEDL, terminology) of the concurrent system. The deriver also generates all required constraints. The constraint eliminator <ref> [10] </ref> takes a subexpression of the system expres 7 sion and certain constraints, and produces a new expression whose language is the set of strings in the language of the subexpression that satisfy the constraints.
Reference: [11] <author> J. C. Corbett and G. A. Polk. </author> <title> A tool for automatic generation of behaviors for constrained expression analysis. </title> <note> In preparation. </note>
Reference-contexts: When the generated system of inequalities is consistent, the integer programming package produces a solution giving counts for the number of occurrences of the various event symbols. The behavior generator <ref> [11] </ref> uses heuristic search techniques to find a string of event symbols having the given counts and corresponding to a system behavior, helping the analyst to understand the solution found by the integer programming package.
Reference: [12] <author> L. K. Dillon. </author> <title> Analysis of Distributed Systems Using Constrained Expressions. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, Amherst, </institution> <year> 1984. </year>
Reference-contexts: Rigorous analysis is based on the constrained expression representations that are mechanically generated from the system descriptions created by software developers. This section contains a brief overview of the constrained expression formalism. Detailed and rigorous presentations of the formalism appear in <ref> [12] </ref> and in the appendix to [14], while less formal treatments intended to provide a more intuitive understanding of the features of the formalism appear in [7] and [4]. The use of constrained expressions with a variety of development notations is illustrated in [7] and [14].
Reference: [13] <author> L. K. Dillon. </author> <title> Overview of the constrained expression design language. </title> <type> Technical Report TRCS86-21, </type> <institution> Department of Computer Science, University of California, Santa Barbara, </institution> <month> October </month> <year> 1986. </year>
Reference-contexts: We give brief descriptions of the tools and their use below. A more detailed discussion of the toolset and its implementation appears in [4]. The current toolset is intended for use with designs written in the Ada-based design language CEDL (Constrained Expression Design Language) <ref> [13] </ref>. CEDL focuses on the expression of communication and synchronization among the tasks in a distributed system, and language features not related to concurrency are kept to a minimum. Thus, for example, data types are limited, but most of 6 the Ada control-flow constructs have correspondents in CEDL.
Reference: [14] <author> L. K. Dillon, G. S. Avrunin, and J. C. Wileden. </author> <title> Constrained expressions: Toward broad applicability of analysis methods for distributed software systems. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 10(3) </volume> <pages> 374-402, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Rigorous analysis is based on the constrained expression representations that are mechanically generated from the system descriptions created by software developers. This section contains a brief overview of the constrained expression formalism. Detailed and rigorous presentations of the formalism appear in [12] and in the appendix to <ref> [14] </ref>, while less formal treatments intended to provide a more intuitive understanding of the features of the formalism appear in [7] and [4]. The use of constrained expressions with a variety of development notations is illustrated in [7] and [14]. <p> of the formalism appear in [12] and in the appendix to <ref> [14] </ref>, while less formal treatments intended to provide a more intuitive understanding of the features of the formalism appear in [7] and [4]. The use of constrained expressions with a variety of development notations is illustrated in [7] and [14]. A detailed discussion of the relation between constrained expressions and a variety of other methods for describing and analyzing concurrent software systems can be found in [7] and [17]. The constrained expression formalism treats the behaviors of a concurrent system as sequences of events. <p> The reasons for this two-step process, which might not seem as straightforward as generating behaviors directly from a single expression, are discussed in <ref> [14] </ref>, while an equivalent and more uniform interpretation process for constrained expressions is presented in [4].
Reference: [15] <author> M. A. Saunders. </author> <title> MINOS system manual. </title> <type> Technical Report SOL 77-31, </type> <institution> Stanford University, Department of Operations Research, </institution> <year> 1977. </year>
Reference-contexts: The integer programming package, called IMINOS [8], is a branch-and-bound integer linear programming system that we have implemented on top of the MINOS optimization package <ref> [15] </ref>. When the generated system of inequalities is consistent, the integer programming package produces a solution giving counts for the number of occurrences of the various event symbols.
Reference: [16] <author> R. N. Taylor, F. C. Belz, L. A. Clarke, L. J. Osterweil, R. W. Selby, J. C. Wileden, A. L. Wolf, and M. Young. </author> <title> Foundations for the Arcadia environment architecture. </title> <booktitle> In Proceedings SIGSOFT '88: Third Symposium on Software Development Environments, </booktitle> <pages> pages 1-13, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: with a design notation based on Ada because Ada is one of the few programming languages in relatively widespread use that explicitly provides for concurrency, and because we expect our work on analysis of designs to contribute to and benefit from the Arcadia Consortium's work on Ada software development environments <ref> [16] </ref>. Despite Ada's shortcomings as a language for real-time software [1], we have used CEDL and the existing deriver in our initial experiments with analysis of timing properties. The deriver [2] produces constrained expression representations from CEDL system designs.
Reference: [17] <author> J. C. Wileden and G. S. Avrunin. </author> <title> Toward automating analysis support for developers of distributed software. </title> <booktitle> In Proceedings of the Eighth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 350-357. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1988. </year> <month> 21 </month>
Reference-contexts: The use of constrained expressions with a variety of development notations is illustrated in [7] and [14]. A detailed discussion of the relation between constrained expressions and a variety of other methods for describing and analyzing concurrent software systems can be found in [7] and <ref> [17] </ref>. The constrained expression formalism treats the behaviors of a concurrent system as sequences of events. These events can be of arbitrary complexity, depending on the system characteristics of interest and the level of system description under consideration.
References-found: 17

