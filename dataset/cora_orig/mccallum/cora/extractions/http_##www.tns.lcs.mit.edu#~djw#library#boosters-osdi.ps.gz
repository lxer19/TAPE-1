URL: http://www.tns.lcs.mit.edu/~djw/library/boosters-osdi.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Email: fale,jdchung,jmsg@cis.upenn.edu  
Title: Operating System Support for Protocol Boosters  
Author: A. Mallet, J. D. Chung and J. M. Smith 
Address: Philadelphia, PA 19104-6389  
Affiliation: Distributed Systems Laboratory University of Pennsylvania,  
Abstract: Protocol Boosters" are modules inserted into protocol graphs. They allow the protocol's behavior to adapt to its environment. Boosters can mask undesirable properties of links or subnets in an internetwork. The method permits use of proprietary protocols and supports end-to-end optimizations. We have implemented Protocol Boosters support in the FreeBSD version of UNIX for Intel architecture machines. Our prototype embeds boosters in the 4.4 BSD-Lite Internet Protocol (IP) stack. We have measured the performance of two prototype boosters: an encryption booster (for passage across insecure subnets) and a compression booster (for passage across bandwidth-impaired subnets). Our measurement data suggests that OS support for this method can be constructed with low performance overhead; execution of the protocol elements dominates any overhead introduced by our implementation. We discuss some lessons learned from the implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bershad, et al.,, </author> <title> "Extensibility, Safety and Performance in the SPIN Operating System," </title> <booktitle> Proc. 15th SOSP, </booktitle> <pages> pp. 267-284, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Booster support requires inserting and removing the booster's function from the execution path followed for a group of packets handled by the protocol. A simplified illustration of one style of booster is shown in Figure 2. While future operating systems <ref> [1, 7] </ref> may ease user-level implementation of protocols with good support for efficient user/kernel boundary crossing and structured user control of devices [6], today's operating systems are ill-suited for such implementation. <p> We allocate an additional 32K chunk of memory used by 6 the boosters in their processing. While slightly constrained, implementing each of our sample boosters became very simple. The current FreeBSD kernel network data structures restrict schemes like protocol boosters, Application-specific Safe Handlers [7] and SPIN <ref> [1] </ref> modules. To exploit ideas from these new systems, the FreeBSD kernel must be made more "extension-friendly". 4.3.2 Kernel-awareness and user-level calls Implementation issues which are of minor consequence in user space can have devastating side-effects if errors are introduced in the kernel protection domain. <p> The "waits-for" dependencies used to schedule coroutines would force multiplexers (and demulti-plexers) to be single-threaded and data-driven, rather than clock or priority driven. Protocol boosters have a strong intellectual relation to the application-specific services approach sug 9 gested by the University of Washington's SPIN <ref> [1] </ref> project for building an extensible microkernel. A different tack is followed by MIT's Exokernel [7]; the Exokernel concentrates on allowing applications to specify almost all elements of their OS substrate, without focusing specifically on network protocols. Application-specific Safe Handlers (ASHs) are most similar to protocol boosters.
Reference: [2] <author> L. Brakmo and L. Peterson, </author> <title> "TCP Vegas: End to End Congestion Avoidance on a Global Internet," </title> <journal> in IEEE Journal on Selected Areas in Communications, </journal> <volume> 13(8), </volume> <month> Oct. </month> <year> 1995, </year> <pages> pp. 1465-1480. </pages>
Reference-contexts: More general protocol graph support in the FreeBSD would allow adding booster modules at any level in the protocol hierarchy as well as at arbitrary points in the processing of the datagram. This would offer finer-grained control of boosting. For example, one could implement TCP Vegas <ref> [2] </ref> using protocol boosters if we inserted booster modules at the TCP layer. A desirable implementation target is x-Kernel-like protocol graph facility, with access to FreeBSD resources, and with smart policy modules.
Reference: [3] <author> K. Claffy, </author> <title> "Internet Traffic Characterization," </title> <type> Ph.D. Thesis, UCSD, </type> <year> 1994. </year>
Reference-contexts: It also complicates inserting and deleting boosters at necessary locations in an IP in-ternetwork. While routes rarely change, as shown by Claffy <ref> [3] </ref> in her studies of Internet traffic, such routing dynamics can be addressed by future protocol boosters. The ability to measure performance in a convincing and reproducible manner was our highest priority.
Reference: [4] <author> David D. Clark, Van Jacobson, John Romkey and Howard Salwen, </author> <title> "An Analysis of TCP Processing Overhead," </title> <journal> in IEEE Communications Magazine, </journal> <volume> 27(6), </volume> <month> June </month> <year> 1989, </year> <pages> pp. 23-29. </pages> <address> 2 ftp.cis.upenn.edu:~ pub/dsl/boosters.d 10 </address>
Reference-contexts: The protocol is then optimized by identifying common cases and implementing fast paths for these cases; TCP/IP is an example <ref> [4] </ref>. The resulting protocol is robust end-to-end and typically provides good performance.
Reference: [5] <author> D. Clark & D. Tennenhouse, </author> <title> "Architectural Considerations For A New Generation Of Protocols," </title> <booktitle> Proceedings of ACM SIGCOMM, </booktitle> <pages> pp. 200-208, </pages> <month> September </month> <year> 1990. </year>
Reference: [6] <author> P. Druschel, L. L. Peterson and B. S. Davie, </author> <title> "Experiences with a High-Speed Network Adaptor: </title>
Reference-contexts: A simplified illustration of one style of booster is shown in Figure 2. While future operating systems [1, 7] may ease user-level implementation of protocols with good support for efficient user/kernel boundary crossing and structured user control of devices <ref> [6] </ref>, today's operating systems are ill-suited for such implementation. Access to system resources needed for high performance, such as address maps and fine-grained scheduling, leads to protocols embedded in operating systems. The canonical example is the IP protocol stack embedded in BSD UNIX.
References-found: 6

