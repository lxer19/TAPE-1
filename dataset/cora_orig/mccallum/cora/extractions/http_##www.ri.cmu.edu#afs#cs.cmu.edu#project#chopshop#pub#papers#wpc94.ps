URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/chopshop/pub/papers/wpc94.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/project/chopshop/pub/www/home.html
Root-URL: 
Keyword: Reverse engineering, program comprehension, pro gram slicing, program dependence graph, dataow diagram, interprocedural analysis, modularity, abstraction.  
Abstract: Big programs tend to have big slices, so reverse engi - neering tools based on slicing must apply additional abstractions to make slices intelligible. W e have built a tool that displays slices as diagrams. By confi ning the slice to the statements of a single procedure, by eliding all primitive statements, and by merging different calls of the same procedure, we eliminate local information that is easily seen in the code without the help of tools. And by labelling edges with the variables responsible for ows between procedure calls, global information about called procedures is represented locally . The re - sulting diagram gives a compact but rich summary of the role of called procedures in the slice. 
Abstract-found: 1
Intro-found: 1
Reference: [BG94] <author> R.W. Bowdidge and W .G. Griswold. </author> <title> A utomated support for encapsulating abstract data types. </title> <booktitle> Proc. ACM Sigsoft 94 Symp. on F oundations of Software Engineering . New Orleans, </booktitle> <address> La., </address> <month> December </month> <year> 1994. </year>
Reference-contexts: The idea of folding different calls of the same procedure comes from the star diagram of <ref> [BG94] </ref>, which uses an analysis a bit like slicing to pre - sent candidate statements for encapsulation in an operation of an abstract type. The next section gives an example of Chopshops output and compares it to a traditional slice.
Reference: [DeM78] <author> Tom DeMarco. </author> <title> Structured Analysis and System Specification. </title> <publisher> Yourdon Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: This diagram is derived from a representation similar to the program dependence graph [FOW87], but its spirit is closer to the data ow diagram used (al - beit with a variety of differing, informal interpreta - tions) in a number of development methods <ref> [DeM78] </ref>. Indeed, our work may be viewed as an attempt to bridge the gap between representations that can be generated easily from code and architectural descriptions that appeal to developers. A number of abstractions are applied in the creation of the diagram. Most vital is the modular treatment of procedures.
Reference: [Ern94] <author> Michael D. Ernst. </author> <title> Practical fi ne-grained static slicing of optimized code. </title> <type> Technical report MSR-TR-94-14, </type> <institution> Microsoft R esearch, R edmond, Wa., </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Presenting slices in this pictorial form appears to be novel. Most slicers, such as Andersens Cobol/SRE [NEK94], are purely textual. A slicer being built at Microsoft Research uses an intermediate representation (the value dependence graph) that would allow similar kinds of abstraction <ref> [Ern94] </ref>, and its developers have considered laying unlabelled arrows over text; so far , though, only text highlighting is used. Many reverse engineering tools generate diagrams, but these tend to be derived from shallow semantic analyses.
Reference: [FOW87] <author> Jeanne F errante, Karl J. Ottenstein and Joe D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. on Programming Languages and Systems , 9(3), </journal> <month> July </month> <year> 1987, </year> <pages> pp. 319349. </pages>
Reference-contexts: The diagram is a directed graph with labelled arcs. The nodes represent program statements and the arcs dataow dependences between them. The labels on the arcs indicate which variables are responsible for the dataow. This diagram is derived from a representation similar to the program dependence graph <ref> [FOW87] </ref>, but its spirit is closer to the data ow diagram used (al - beit with a variety of differing, informal interpreta - tions) in a number of development methods [DeM78]. <p> It arises here because of conditional exits from the loop that bring in many of the global variables that have no dataow links to dlines. 3 The Dependence Model Chopshops underlying model is similar to the program dependence graph (PDG) <ref> [FOW87] </ref> but accommodates interprocedural dependences more naturally. The standard way to extend a graphical program representation (whether of dependences, control ow, etc.) to account for called procedures is to form a single supergraph for the entire program by joining the graphs of the individual procedures at their call sites.
Reference: [HRB90] <author> Susan Horwitz, Thomas Reps and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM T rans. on Programming L anguages and Systems, </journal> <volume> 12(1), </volume> <month> January </month> <year> 1990, </year> <pages> pp. 2660. </pages>
Reference-contexts: A number of abstractions are applied in the creation of the diagram. Most vital is the modular treatment of procedures. Standard interprocedural slicing <ref> [HRB90] </ref> pays no respect to procedure call boundaries; a slice on a variable that appears in some procedure p typically includes statements occurring both in procedures that call p and in procedures called by p. <p> The standard way to extend a graphical program representation (whether of dependences, control ow, etc.) to account for called procedures is to form a single supergraph for the entire program by joining the graphs of the individual procedures at their call sites. Extending the PDG in this way <ref> [HRB90] </ref> introduces a host of complications, not only in the construction process but also in the graph itself. Each call site becomes a complex web of linkage nodes and mock assignments (to model the passing of parameters) that is not conducive to a modular analysis. Our approach is simpler .
Reference: [JR94a] <author> Daniel Jackson and Eugene J. Rollins. </author> <title> Chopping: a generalization of slicing . T echnical report CMU-CS-94-169, </title> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, Pa., </address> <month> July </month> <year> 1994. </year>
Reference-contexts: The details, along with a more substantial justifi cation of the model, may be found in our technical report <ref> [JR94a] </ref> and a paper to appear soon [JR94b]. 4 Constructing Slice Diagrams Rather than giving explicit worklist algorithms for constructing slices, we shall defi ne slices as algebraic ex - pressions in terms of the dependence relations. We find these much easier to understand and manipulate.
Reference: [JR94b] <author> Daniel Jackson and Eugene J. Rollins. </author> <title> A new abstraction of the program dependence graph for reverse engineering. </title> <booktitle> Proc. ACM Sigsoft 94 Symp. on F oundations of Softwar e Engineering . New Orleans, </booktitle> <address> La., </address> <month> December </month> <year> 1994. </year>
Reference-contexts: The details, along with a more substantial justifi cation of the model, may be found in our technical report [JR94a] and a paper to appear soon <ref> [JR94b] </ref>. 4 Constructing Slice Diagrams Rather than giving explicit worklist algorithms for constructing slices, we shall defi ne slices as algebraic ex - pressions in terms of the dependence relations. We find these much easier to understand and manipulate.
Reference: [M+92] <author> H.A. Muller , S.R . T illey, M.A. Orgun, </author> <title> B.D. Corrie, N.H. Madhavji. A reverse engineering environment based on spatial and visual software interconnection models. </title> <booktitle> Proc. 5th ACM SIG - SOFT Symposium on Softwar e Development Environments, </booktitle> <year> 1992. </year>
Reference-contexts: Rigi <ref> [M+92] </ref> lets the user impose structure on a program by applying various syntactic aggregation mechanisms to call-graphs; Chopshop, in contrast, is designed to ex - pose semantic relationships between components cho - sen by the user.
Reference: [M+94] <author> Lawrence Markosian, Philip Newcomb, R ussell Brand, Scott Burson and Ted Kitzmiller. </author> <title> Using an enabling technology to reengineer legacy sys - tems. </title> <journal> Communications of the ACM , 37(5), </journal> <month> May </month> <year> 1994, </year> <pages> pp. 5871. </pages>
Reference-contexts: Many reverse engineering tools generate diagrams, but these tend to be derived from shallow semantic analyses. R efine/Cobols set-use analysis <ref> [M+94] </ref>, for example, can produce a diagram superficially similar to ours, but derived from a traditional cross-reference listing: an arc is shown connecting two procedures if there is a global variable written by one that is read by the other, whether or not a data ow path is present.
Reference: [NEK94] <author> Jim Q. Ning, Andre Engberts and W ojtek Kozaczynski. </author> <title> Automated support for legacy code understanding. </title> <journal> Communications of the ACM , 37(5), </journal> <month> May </month> <year> 1994, </year> <pages> pp. 5057. </pages>
Reference-contexts: All of these abstractions may be turned off by the user. Presenting slices in this pictorial form appears to be novel. Most slicers, such as Andersens Cobol/SRE <ref> [NEK94] </ref>, are purely textual. A slicer being built at Microsoft Research uses an intermediate representation (the value dependence graph) that would allow similar kinds of abstraction [Ern94], and its developers have considered laying unlabelled arrows over text; so far , though, only text highlighting is used.
Reference: [Wei84] <author> Mark W eiser. </author> <title> P rogram slicing. </title> <journal> IEEE Trans. on Software Engineering , SE-10(4), </journal> <month> July </month> <year> 1984, </year> <pages> pp. 352357. </pages>
References-found: 11

