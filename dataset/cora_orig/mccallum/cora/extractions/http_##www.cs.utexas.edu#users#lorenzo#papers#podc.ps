URL: http://www.cs.utexas.edu/users/lorenzo/papers/podc.ps
Refering-URL: http://www.cs.utexas.edu/users/lorenzo/publications.html
Root-URL: 
Title: Trade-Offs in Implementing Causal Message Logging Protocols  
Author: Lorenzo Alvisi Keith Marzullo 
Abstract: Casual message logging protocols [3] have several attractive properties: they introduce no blocking, send no additional messages over those sent by the application, and can never cause orphans to be created by crashes. Causal message logging, however, does require additional data to be piggybacked on application messages. The amount of such piggybacked data can become large. In this paper, we present five different implementations of casual message logging. All of the corresponding protocols are parameterized by f, the maximum number of processes that can fail concurrently. We also explore how the application's communication structure can be exploited to limit the amount of piggybacked data. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Alvisi. </author> <title> Understanding the Message Logging Paradigm for Masking Process Crashes. </title> <type> PhD thesis, </type> <institution> Cornell University Department of Computer Science, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Due to lack of space, we do not present the protocol that is run when a crashed process recovers. All five protocols that we develop in this paper can use the same recovery protocol. A discussion on recovery as well as the actual recovery protocol can be found in <ref> [1] </ref>. 2 System Model We assume a system N of n processes that can communicate only by exchanging messages. The system is asynchronous: there exists no bound on the relative speeds of processes, no bound on message transmission delays, and no global time source. <p> Definition 1 A channel graph is tree-like if, for all pairs of nodes i and j, all paths from i to j have the same length. Log for f = 3. Note that the channel graph of Figure 3 is tree-like. The following theorem, proved in <ref> [1] </ref>, characterizes one set of applications for which Det performs as well as + Log when f = n. Theorem 1 Let f = n. Given a tree-like channel graph, for any run , Protocol Det piggybacks on each message the same determinants as Protocol + Log . <p> Given a tree-like channel graph, for any run , Protocol Det piggybacks on each message the same determinants as Protocol + Log . There exist channel graphs for which Det sends the same determinants as + Log even when f &lt; n. The following theorem (also proved in <ref> [1] </ref>) specifies one such kind of graph. Theorem 2 Let f n. <p> For simplicity, in our calculations we don't consider optimizations achievable by applying compression techniques such as those described in <ref> [4, 1] </ref>. Consider a message m from process p to process q. Suppose that, when p sends m, DS p (q) contains D determinants and p's determinant log contains N determinants. <p> The resulting version of jLogj piggybacks no more than f additional words than Det , an amount which is independent of D. A drawback of this approach, however, is that determinants sorted in this manner are not suitable for some of the compression techniques described in <ref> [4, 1] </ref>, which can dramatically reduce the size of the piggyback. Furthermore, this approach can not be applied to + jLogj , Log or + Log . <p> Because the order of events executed by a processor is in fact a total order, it is also straightforward to construct a dependency matrix that has size n P fin P where n P is the number of processors in the system <ref> [1] </ref>. <p> For all processes q in N , SMat p [i; q] contains the highest receive sequence number of any message m delivered by q for which jLog (m)j p = i. The entries of SMat p are initialized to 0. No tice that SMat p <ref> [1; :] </ref> is equal to W DV p , and that SMat p [f + 1; :] is equal to Stable p . Thus, jLog (m)j p = i when SMat p [i + 1; m.dest] &lt; m.rsn SMat p [i; m.dest]. <p> A process q that receives this stability matrix can use it with the piggybacked determinants, its own stability matrix and its own dependency matrix to compute the new values for its stability matrix and dependency matrix. Full descriptions of protocols + jLogj and + Log can be found in <ref> [1] </ref>. 5 Manetho and FBL Protocols Manetho is an optimal message logging protocol designed for f = n.
Reference: [2] <author> L. Alvisi and K. Marzullo. </author> <title> Deriving optimal check-pointing protocols for distributed shared memory architectures. </title> <booktitle> In Selected Papers, International Workshop in Theory and Practice in Distributed Systems, </booktitle> <pages> pages 111-120. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The only FBL protocol that has been completely implemented is Det [4]. We are currently implementing the complete FBL family in order to understand better under what circumstances the simpler protocols are the more efficient ones. We have also extended the message logging specification to distributed shared memory architectures <ref> [2] </ref> and have designed optimal FBL protocols for the entry consistency memory coherency model [6]. Acknowledgments We would like to thank Bruce Hoppe and Fred Schneider for their help in refining our ideas and Wanda Chiu for her detailed comments on our work.
Reference: [3] <author> L. Alvisi and K. Marzullo. </author> <title> Message logging: Pessimistic, optimistic, and causal. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 229-236. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1995. </year>
Reference-contexts: The two main approaches to message logging are optimistic (for example, [18, 17, 11, 20]) and pessimistic (for example, [7, 15, 10, 19]). We have recently defined a third approach that we call causal <ref> [3] </ref>. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9]. In the same paper we defined a message logging protocol to be optimal if it is causal and does not send any additional messages over those needed to mask transient link failures. <p> Let Log (m) denote the set of processes that maintain a copy of #m in their address space: in particular, process m:dest is a member of Log (m) once it delivers m. In <ref> [3] </ref>, we showed that the following property ensures that no set of f or less crashed processes can lead to the creation of orphans: 8m : 2 (jLog (m)j f ) Depend (m) Log (m)) (1) (2 is the temporal "always" operator) [14]. <p> We call the protocols that implement Property (2) causal message-logging protocols. In <ref> [3] </ref> we define optimal message logging protocols to be those protocols that (1) do not create orphans, (2) introduce no blocking, and (3) do not send any additional messages over those needed to mask transient link failures.
Reference: [4] <author> Lorenzo Alvisi, Bruce Hoppe, and Keith Marzullo. </author> <title> Nonblocking and orphan-free message logging protocols. </title> <booktitle> In Proceedings of the 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 145-154, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The two main approaches to message logging are optimistic (for example, [18, 17, 11, 20]) and pessimistic (for example, [7, 15, 10, 19]). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) <ref> [4] </ref> and Manetho [9]. In the same paper we defined a message logging protocol to be optimal if it is causal and does not send any additional messages over those needed to mask transient link failures. <p> For simplicity, in our calculations we don't consider optimizations achievable by applying compression techniques such as those described in <ref> [4, 1] </ref>. Consider a message m from process p to process q. Suppose that, when p sends m, DS p (q) contains D determinants and p's determinant log contains N determinants. <p> The resulting version of jLogj piggybacks no more than f additional words than Det , an amount which is independent of D. A drawback of this approach, however, is that determinants sorted in this manner are not suitable for some of the compression techniques described in <ref> [4, 1] </ref>, which can dramatically reduce the size of the piggyback. Furthermore, this approach can not be applied to + jLogj , Log or + Log . <p> However, the information carried by Log and + Log can be compressed, while we are not aware of techniques for compressing the determinants carried by Manetho. The effects of compression can be very large <ref> [4] </ref>, and so we expect in practice that Protocols Log and + Log will often piggyback much less information than Manetho. One major difference between Manetho and the FBL protocols is that Manetho assumes f = n. <p> How ever, the FBL protocols are all well-suited for efficient compression of the D determinants <ref> [4] </ref>. We do not know if Manetho is equally well-suited for compression. The only FBL protocol that has been completely implemented is Det [4]. We are currently implementing the complete FBL family in order to understand better under what circumstances the simpler protocols are the more efficient ones. <p> How ever, the FBL protocols are all well-suited for efficient compression of the D determinants <ref> [4] </ref>. We do not know if Manetho is equally well-suited for compression. The only FBL protocol that has been completely implemented is Det [4]. We are currently implementing the complete FBL family in order to understand better under what circumstances the simpler protocols are the more efficient ones.
Reference: [5] <author> O. Babaoglu, L. Alvisi, et al. </author> <title> Paralex: An environment for parallel programming in distributed systems. </title> <booktitle> In Proceedings of the 6th ACM International Conference on Supercomputing, </booktitle> <pages> pages 178-187, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: There are applications, however, for which Det performs as well as Log even for large values of f . For example, Figure 3 shows an application for which Det does as well as + Log when f = n <ref> [5] </ref>. The application is a parallel solution to the Synthetic Aperture Radar problem (SAR) in which radar echoes, collected by aircraft or spacecraft, are used to construct terrain contours.
Reference: [6] <author> B. N. Bershad, M. J. Zekauskas, and W. A. Saw-don. </author> <title> The midway distributed shared memory system. </title> <booktitle> In Proceedings of the 93 COMPCON Conference, </booktitle> <pages> pages 528-537. </pages> <publisher> IEEE, </publisher> <month> February </month> <year> 1993. </year>
Reference-contexts: We have also extended the message logging specification to distributed shared memory architectures [2] and have designed optimal FBL protocols for the entry consistency memory coherency model <ref> [6] </ref>. Acknowledgments We would like to thank Bruce Hoppe and Fred Schneider for their help in refining our ideas and Wanda Chiu for her detailed comments on our work.
Reference: [7] <author> Anita Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault tolerance. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, </booktitle> <pages> pages 90-99. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: Thus, in the terminology of message logging, message logging protocols must guarantee that there are no orphan processes, either through careful logging or through a somewhat complex recovery protocol. The two main approaches to message logging are optimistic (for example, [18, 17, 11, 20]) and pessimistic (for example, <ref> [7, 15, 10, 19] </ref>). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9].
Reference: [8] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: A collection of states, one from each process, is a consistent global state if all pairs of states are mutually consistent <ref> [8] </ref>; otherwise it is inconsistent. We assume that processes are piecewise deterministic [19] in that the only nondeterminism in a process arises from the nondeterministic order in which mes sages are delivered.
Reference: [9] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho <ref> [9] </ref>. In the same paper we defined a message logging protocol to be optimal if it is causal and does not send any additional messages over those needed to mask transient link failures. Optimal message protocols do exact a price, however: they piggyback additional information on the application's messages. <p> In particular, after a failure the antecedence graph of the recovering process must be reconstituted through a non-trivial merging of the antecedence graphs of the surviving processes. In addition, garbage collection is recognized to be complex and expensive <ref> [9] </ref>. We suspect that part of the cost may arise because determinants must be logged in a way that preserves the antecedence graph structure which may not lend itself easily to garbage collection.
Reference: [10] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Digest of Papers: 17 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 14-19. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Thus, in the terminology of message logging, message logging protocols must guarantee that there are no orphan processes, either through careful logging or through a somewhat complex recovery protocol. The two main approaches to message logging are optimistic (for example, [18, 17, 11, 20]) and pessimistic (for example, <ref> [7, 15, 10, 19] </ref>). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9].
Reference: [11] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11 </volume> <pages> 462-491, </pages> <year> 1990. </year>
Reference-contexts: Thus, in the terminology of message logging, message logging protocols must guarantee that there are no orphan processes, either through careful logging or through a somewhat complex recovery protocol. The two main approaches to message logging are optimistic (for example, <ref> [18, 17, 11, 20] </ref>) and pessimistic (for example, [7, 15, 10, 19]). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9].
Reference: [12] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The execution of the system is represented by a run, which is an irreflexive partial ordering of the send events, receive events and local events ordered by potential causality <ref> [12] </ref>. Delivery events are local events that represent the delivery of a received message to the application or applications running in that process. For any message m from process p to process q, q delivers m only if it has received m, and q delivers m no more than once. <p> Formally, Depend (m) def ((j = m.dest) ^ j has delivered m) _ (9 an event e j of non-crashed process j: (deliver i (m) ! e j ))g where ! denotes the happens-before relationship <ref> [12] </ref>. Let Log (m) denote the set of processes that maintain a copy of #m in their address space: in particular, process m:dest is a member of Log (m) once it delivers m.
Reference: [13] <author> Friedmann Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In M. Cosnard et. al., editor, </editor> <booktitle> Parallel and Distributed Algorithms, </booktitle> <pages> pages 215-226. </pages> <publisher> Elsevir Science Publishers B. V., </publisher> <year> 1989. </year>
Reference-contexts: One such technique is based on vector clocks <ref> [13] </ref>. Strom and Yemini [18] were the first to use vector clocks with message logging when they introduced the notion of dependency vector. A dependency vector is a vector clock that is specialized to determine causal dependencies between delivery events occurring at different processes.
Reference: [14] <author> Amir Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the Eighteenth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <month> November </month> <year> 1977. </year>
Reference-contexts: In [3], we showed that the following property ensures that no set of f or less crashed processes can lead to the creation of orphans: 8m : 2 (jLog (m)j f ) Depend (m) Log (m)) (1) (2 is the temporal "always" operator) <ref> [14] </ref>. We say that the determinant of a delivery event deliver m:dest (m) is stable when #m cannot become lost due to process crashes, i.e. when jLog (m)j &gt; f. <p> In order to address this problem, we consider protocols that implement the following strengthening of Property 1: 8m : 2 @ (jLog (m)j f ) ) ^ (Depend (m) Log (m)) ^ 3 (Depend (m) = Log (m)) A (2) (3 is the temporal "eventually" operator) <ref> [14] </ref>. This characterization strongly couples logging with causal de pendency on deliver events.
Reference: [15] <author> M.L. Powell and D.L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, </booktitle> <pages> pages 100-109. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: Thus, in the terminology of message logging, message logging protocols must guarantee that there are no orphan processes, either through careful logging or through a somewhat complex recovery protocol. The two main approaches to message logging are optimistic (for example, [18, 17, 11, 20]) and pessimistic (for example, <ref> [7, 15, 10, 19] </ref>). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9].
Reference: [16] <author> Fred B. Schneider. </author> <title> Byzantine generals in action: Implementing fail-stop processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: The state interval p [0] is defined to be the interval of states of p from its initial state to the state immediately before the delivery of the first message. We further assume that: * Processes fail independently according to the fail stop model <ref> [16] </ref>; * There exists common knowledge on the identity of the fixed set of processes that belong to the system; * Channels are point-to-point, FIFO, and fail by in termittently losing messages. 3 Specification With the assumption that processes are piecewise deterministic, the only non-deterministic choices made during an execution concern
Reference: [17] <author> A.P. Sistla and J.L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the Eighth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238. </pages> <publisher> ACM SIGACT/SIGOPS, </publisher> <month> August </month> <year> 1989. </year>
Reference-contexts: Thus, in the terminology of message logging, message logging protocols must guarantee that there are no orphan processes, either through careful logging or through a somewhat complex recovery protocol. The two main approaches to message logging are optimistic (for example, <ref> [18, 17, 11, 20] </ref>) and pessimistic (for example, [7, 15, 10, 19]). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9].
Reference: [18] <author> R. B. Strom and S. Yemeni. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Thus, in the terminology of message logging, message logging protocols must guarantee that there are no orphan processes, either through careful logging or through a somewhat complex recovery protocol. The two main approaches to message logging are optimistic (for example, <ref> [18, 17, 11, 20] </ref>) and pessimistic (for example, [7, 15, 10, 19]). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9]. <p> For any message m delivered by process p, the receive sequence number of m, denoted m.rsn, represents the order in which m was delivered: m.rsn = ` if m is the ` th message delivered by p <ref> [18] </ref>. The state interval that initiates with the delivery of m is denoted p [`] where `, the index of p [`], is equal to m.rsn. <p> One such technique is based on vector clocks [13]. Strom and Yemini <ref> [18] </ref> were the first to use vector clocks with message logging when they introduced the notion of dependency vector. A dependency vector is a vector clock that is specialized to determine causal dependencies between delivery events occurring at different processes.
Reference: [19] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 44-49, </pages> <year> 1988. </year>
Reference-contexts: Thus, in the terminology of message logging, message logging protocols must guarantee that there are no orphan processes, either through careful logging or through a somewhat complex recovery protocol. The two main approaches to message logging are optimistic (for example, [18, 17, 11, 20]) and pessimistic (for example, <ref> [7, 15, 10, 19] </ref>). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9]. <p> A collection of states, one from each process, is a consistent global state if all pairs of states are mutually consistent [8]; otherwise it is inconsistent. We assume that processes are piecewise deterministic <ref> [19] </ref> in that the only nondeterminism in a process arises from the nondeterministic order in which mes sages are delivered.
Reference: [20] <author> S. Venkatesan and T.Y. Juang. </author> <title> Efficient algorithms for optimistic crash recovery. </title> <journal> Distributed Computing, </journal> <volume> 8(2) </volume> <pages> 105-114, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Thus, in the terminology of message logging, message logging protocols must guarantee that there are no orphan processes, either through careful logging or through a somewhat complex recovery protocol. The two main approaches to message logging are optimistic (for example, <ref> [18, 17, 11, 20] </ref>) and pessimistic (for example, [7, 15, 10, 19]). We have recently defined a third approach that we call causal [3]. There are two published causal message logging protocols: Family Based Logging (FBL) [4] and Manetho [9].
References-found: 20

