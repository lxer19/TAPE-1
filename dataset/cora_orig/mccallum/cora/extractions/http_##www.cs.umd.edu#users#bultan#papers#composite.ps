URL: http://www.cs.umd.edu/users/bultan/papers/composite.ps
Refering-URL: http://www.cs.umd.edu/users/bultan/publications-abstracts.html
Root-URL: 
Title: Composite Model Checking with Type Specific Symbolic Encodings  
Author: Tevfik Bultan Richard Gerber 
Note: This research is supported in part by ONR grant N00014-94-10228 and NSF CCR-9619808.  
Address: College Park, MD 20742, USA  
Affiliation: Department of Computer Science University of Maryland,  
Abstract: We present a new symbolic model checking technique, which analyzes temporal properties in multi-typed transition systems. Specifically, the method uses multiple type-specific data encodings to represent system states, and it carries out fixpoint computations via the corresponding type-specific symbolic operations. In essence, different symbolic encodings are unified into one composite model checker. Any type-specific language can be included in this framework provided that the language is closed under Boolean connectives, propositions can be checked for satisfiability, and relational images can be computed. Our technique relies on conjunctive partitioning of transition relations of atomic events based on variable types involved, which allows independent computation of one-step pre- and post-conditions for each variable type. In this paper we demonstrate the effectiveness of our method on a nontrivial data-transfer protocol, which contains a mixture of integer and Boolean-valued variables. The protocol operates over an unreliable channel that can lose, duplicate or reorder messages. Moreover, the protocol's send and receive window sizes are not specified in advance; rather, they are represented as symbolic constants. The resulting system was automatically verified using our composite model checking approach, in concert with a conservative approximation technique. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. A. Henzinger, P. H. Ho, X. Nicollin, A. Olivero, J. Sifakis, S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138(1) </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: In the future, we would expect to see many of these 1 concepts used together, toward solving more complex problems. In recent years various symbolic encodings have been proposed which are efficient for certain variable types. For example model checkers for hybrid systems encode real variables using affine constraints <ref> [1] </ref>. Affine constraint encoding of real variables is similar to the way we encode integer variables using Presburger formulas. In [13], Kesten et al. use rich assertional languages that can encode infinite-state systems for symbolic model checking. In particular, they use regular sets and tree regular sets as symbolic encodings.
Reference: [2] <author> B. Boigelot, and P. Godefroid. </author> <title> Symbolic verification of communication protocols with infinite state spaces using QDDs. </title> <booktitle> In Proceedings of the 8th International Conference on Computer Aided Verification (CAV '96). </booktitle>
Reference-contexts: In [13], Kesten et al. use rich assertional languages that can encode infinite-state systems for symbolic model checking. In particular, they use regular sets and tree regular sets as symbolic encodings. Queue content Decision Diagrams (QDDs) are proposed to encode sets of queue-configurations <ref> [2] </ref>, where the prime use is to carry out reachability queries on communicating state machines. Queue configurations are modeled via deterministic finite-state automata structures, where the language accepted by the automata is equal to the set of queue-contents. QBDDs extend QDDs, by combining QDD representation with BDD encoding [10].
Reference: [3] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(8) </volume> <pages> 677-691. </pages>
Reference-contexts: 1 Introduction Symbolic model checking has been quite successful in hardware verification [6, 7, 14]. This success is generally due to efficiency of encodings like BDDs, which can represent huge sets of bit-vector states in a highly compact format <ref> [3] </ref>. However, one shortcoming of the BDD representation is its inability to handle unbounded variables (like integers). Alternatively, we recently proposed a model checker for general integer based systems, which uses Pres-burger constraints as its underlying state representation [5].
Reference: [4] <author> T. Bultan, R. Gerber, and C. League. </author> <title> "Verifying Systems with Integer Constraints and Boolean Predicates: A Composite Approach." </title> <booktitle> To appear in Proceedings of the 1998 ACM/SIGSOFT International Symposium on Software Testing and Analysis (ISSTA '98). </booktitle>
Reference-contexts: At the same conference, we described our prototype Presburger-based model-checker [5], and showed how it could be used in concert with a multi-polytope widening operator. Recently, we reported some preliminary progress with exact BDD/Presburger model-checking, where the objective was verifying requirements of a sensor-control system <ref> [4] </ref>. In this paper we extend these results, by (1) presenting a model checker that accepts any adequate language; (2) showing how it works on a TCP-like data-transfer protocol; and (3) integrating conservative approximation techniques with composite model-checking where the goal is to accelerate fixpoint computations over infinite variable domains.
Reference: [5] <author> T. Bultan, R. Gerber, and W. Pugh. </author> <title> Symbolic model checking of infinite state systems using Presburger arithmetic. </title> <booktitle> In Proceedings of the 9th International Conference on Computer Aided Verification (CAV '97), </booktitle> <volume> LNCS 1254, </volume> <pages> pages 400-411. </pages>
Reference-contexts: However, one shortcoming of the BDD representation is its inability to handle unbounded variables (like integers). Alternatively, we recently proposed a model checker for general integer based systems, which uses Pres-burger constraints as its underlying state representation <ref> [5] </ref>. As with BDDs for Boolean arrays, Presburger constraints can compactly represent huge (even unbounded) sets of integer states over multiple dimensions. Specifically, our model checker represents sets of state-valuations using unions of convex polytopes, each of which is formed by affine constraints over the system's variables. <p> Obviously, we rely heavily on the previous work on symbolic model-checking [6, 7, 14]. As for the definition of an adequate language and the requisite operations contained in one the concept was nicely reported by [13] at CAV '97. At the same conference, we described our prototype Presburger-based model-checker <ref> [5] </ref>, and showed how it could be used in concert with a multi-polytope widening operator. Recently, we reported some preliminary progress with exact BDD/Presburger model-checking, where the objective was verifying requirements of a sensor-control system [4]. <p> Hence, we often appeal to conservative techniques, which can help when exact results are unobtainable. 3.1 Approximate fixpoint computations As reported in <ref> [5] </ref>, if we cannot directly compute a property f for a program C, we generate a lower-bound for f , denoted f , such that f f. Then we check if I f ; if so, we conclude that I f . <p> As for handling arbitrary levels of negation, we can easily generalize the abovementioned method for outermost negation operators and determine what type of approximation we need for each subformula <ref> [5] </ref>. Note that each iteration of the exact fixpoint computations (Figure 1) will yield a lower a bound for 93f 1 and 83f 1 . <p> This will accelerate the fixpoint computation by generating a majorizing sequence to the exact fixpoint iterates. We show in <ref> [5] </ref> how this is done for integer domains, over multiple convex regions. We have extended the widening idea to composite models. Assume that we have two composite representations P i=1 n P _ ^ p t n Q _ q i i=1 t2T i such that P Q.
Reference: [6] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proc. of the 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Symbolic model checking has been quite successful in hardware verification <ref> [6, 7, 14] </ref>. This success is generally due to efficiency of encodings like BDDs, which can represent huge sets of bit-vector states in a highly compact format [3]. However, one shortcoming of the BDD representation is its inability to handle unbounded variables (like integers). <p> In [13], such an encoding is called an adequate language. The concepts in this paper rest on a large body of work done by us and others. Obviously, we rely heavily on the previous work on symbolic model-checking <ref> [6, 7, 14] </ref>. As for the definition of an adequate language and the requisite operations contained in one the concept was nicely reported by [13] at CAV '97.
Reference: [7] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> 13(4): </volume> <pages> 401-424. </pages>
Reference-contexts: 1 Introduction Symbolic model checking has been quite successful in hardware verification <ref> [6, 7, 14] </ref>. This success is generally due to efficiency of encodings like BDDs, which can represent huge sets of bit-vector states in a highly compact format [3]. However, one shortcoming of the BDD representation is its inability to handle unbounded variables (like integers). <p> In [13], such an encoding is called an adequate language. The concepts in this paper rest on a large body of work done by us and others. Obviously, we rely heavily on the previous work on symbolic model-checking <ref> [6, 7, 14] </ref>. As for the definition of an adequate language and the requisite operations contained in one the concept was nicely reported by [13] at CAV '97.
Reference: [8] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proc. 4th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: However, if a result obtained is not precise enough to prove the property of interest, it can be cached away and improved later, by running more fixpoint iterations. As for upper bounds, we use a technique similar to widening <ref> [8] </ref>, but over multiple convex regions, and over multiple types. <p> single type t 2 T , and that "5 t " is a type-specific widening operator such that: q t 2 q t 2 1 5 t q t 2 is an upper bound for the union computation. (Note that we do not have the guaranteed convergence requirement given in <ref> [8] </ref>, i.e., our approximate fixpoint computations are not guaranteed to converge.) Obviously there are many choices for operators which majorize binary union.
Reference: [9] <author> E. Clarke, X. Zhao. </author> <title> Word level symbolic model checking: A new approach for verifying arithmetic circuits. </title> <type> Technical Report CMU-CS-95-161, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: QBDDs have limited expressiveness for infinite sets, they are more appropriate for encoding bounded queues. Several symbolic representations have been proposed for modeling functions over Boolean variables with non-Boolean ranges, including Multi-Terminal Binary Decision Diagrams (MTBDDs), Binary Moment Diagrams (BMDs), and their generalization Hybrid Decision Diagrams (HDDs) <ref> [9] </ref>. These are especially useful for datapath circuit verification, since they can encode functions that map Boolean vectors to integers. Each of these representations can provide an efficient encoding for a specific variable type.
Reference: [10] <author> P. Godefroid, and D. </author> <title> Long. Symbolic protocol verification with queue BDDs. </title> <booktitle> In Proceedings of the 11th Symposium on Logic in Computer Science, </booktitle> <pages> 198-206, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Queue configurations are modeled via deterministic finite-state automata structures, where the language accepted by the automata is equal to the set of queue-contents. QBDDs extend QDDs, by combining QDD representation with BDD encoding <ref> [10] </ref>. QBDDs have limited expressiveness for infinite sets, they are more appropriate for encoding bounded queues. Several symbolic representations have been proposed for modeling functions over Boolean variables with non-Boolean ranges, including Multi-Terminal Binary Decision Diagrams (MTBDDs), Binary Moment Diagrams (BMDs), and their generalization Hybrid Decision Diagrams (HDDs) [9].
Reference: [11] <author> R. Kaivola. </author> <title> Using Compositional Preorders in the Verification of Sliding Window Protocol. </title> <booktitle> In Proceedings of the 9th International Conference on Computer Aided Verification (CAV '97), </booktitle> <volume> LNCS 1254, </volume> <pages> pages 48-59. </pages>
Reference-contexts: Hence, it was not amenable to verification by a BDD-checker alone; moreover, its size (and the number of Boolean variables) made pure-Presburger checking infeasible. In this paper, we show how the system was automatically verified using our composite model checking approach, in concert with a conservative approximation technique. In <ref> [11] </ref>, a different version of a sliding-window protocol was verified, using a compositional preorder approach. In certain respects, this previous study was more broad, e.g., it handled liveness properties for arbitrary channel lengths. <p> In certain respects, this previous study was more broad, e.g., it handled liveness properties for arbitrary channel lengths. In other respects, it was more constrained, e.g., it assumed a fixed window size, whereas we verify the problem for any window size. But essentially, while examining a similar problem, <ref> [11] </ref> and this paper illustrate two different (but related) techniques. In [11], verification is carried out in a semi-automated fashion, where some key user-generated abstractions were required. Here, the protocol is verified automatically, via composite model checking. <p> In other respects, it was more constrained, e.g., it assumed a fixed window size, whereas we verify the problem for any window size. But essentially, while examining a similar problem, <ref> [11] </ref> and this paper illustrate two different (but related) techniques. In [11], verification is carried out in a semi-automated fashion, where some key user-generated abstractions were required. Here, the protocol is verified automatically, via composite model checking. In the future, we would expect to see many of these 1 concepts used together, toward solving more complex problems.
Reference: [12] <author> W. Kelly, V. Maslov, W. Pugh, E. Rosser, T. Shpeisman and D. Wonnacott. </author> <title> The Omega Library (version 1.00) interface guide. </title> <note> Available at &lt;http://www.cs.umd.edu/projects/omega&gt;. </note>
Reference-contexts: We use the term "adequate language" to describe any type signature (with a corresponding implementation) which adheres to these three properties. Specifically we have implemented a model checker using two adequate languages - Presburger arithmetic (implemented with the Omega Library <ref> [12] </ref>), and BDDs (implemented in our own class library).
Reference: [13] <author> Y. Kesten, O. Maler, M. Marcus, A. Pnueli, and E. Shahar. </author> <title> Symbolic model checking with rich asser-tional languages. </title> <booktitle> In Proceedings of the 9th International Conference on Computer Aided Verification (CAV '97), </booktitle> <volume> LNCS 1254, </volume> <pages> pages 424-435. </pages>
Reference-contexts: Also, our strategy can easily include other symbolic encodings as well provided that the language is closed under Boolean connectives, propositions can be checked for satisfiability, and relational images can be computed. In <ref> [13] </ref>, such an encoding is called an adequate language. The concepts in this paper rest on a large body of work done by us and others. Obviously, we rely heavily on the previous work on symbolic model-checking [6, 7, 14]. <p> Obviously, we rely heavily on the previous work on symbolic model-checking [6, 7, 14]. As for the definition of an adequate language and the requisite operations contained in one the concept was nicely reported by <ref> [13] </ref> at CAV '97. At the same conference, we described our prototype Presburger-based model-checker [5], and showed how it could be used in concert with a multi-polytope widening operator. Recently, we reported some preliminary progress with exact BDD/Presburger model-checking, where the objective was verifying requirements of a sensor-control system [4]. <p> In recent years various symbolic encodings have been proposed which are efficient for certain variable types. For example model checkers for hybrid systems encode real variables using affine constraints [1]. Affine constraint encoding of real variables is similar to the way we encode integer variables using Presburger formulas. In <ref> [13] </ref>, Kesten et al. use rich assertional languages that can encode infinite-state systems for symbolic model checking. In particular, they use regular sets and tree regular sets as symbolic encodings. <p> This definition was borrowed (with some modifications) from the concept of an adequate language described in <ref> [13] </ref>. We use the term "adequate language" to describe any type signature (with a corresponding implementation) which adheres to these three properties. Specifically we have implemented a model checker using two adequate languages - Presburger arithmetic (implemented with the Omega Library [12]), and BDDs (implemented in our own class library).
Reference: [14] <author> K. L. McMillan. </author> <title> Symbolic model checking. </title> <address> Massachusetts, 1993, </address> <publisher> Kluwer Academic Publishers. </publisher> <pages> 10 </pages>
Reference-contexts: 1 Introduction Symbolic model checking has been quite successful in hardware verification <ref> [6, 7, 14] </ref>. This success is generally due to efficiency of encodings like BDDs, which can represent huge sets of bit-vector states in a highly compact format [3]. However, one shortcoming of the BDD representation is its inability to handle unbounded variables (like integers). <p> In [13], such an encoding is called an adequate language. The concepts in this paper rest on a large body of work done by us and others. Obviously, we rely heavily on the previous work on symbolic model-checking <ref> [6, 7, 14] </ref>. As for the definition of an adequate language and the requisite operations contained in one the concept was nicely reported by [13] at CAV '97.
References-found: 14

