URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects/reznik2.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects.html
Root-URL: http://www.research.digital.com
Title: Domain-Specific Programming Languages (DSLs): a paper survey Mathematicians are like the French: they take whatever
Author: Dan S. Reznik 
Date: Spring 1997  
Pubnum: CS263 Final Project  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. Weiss. </author> <title> Creating domain-specific languages: the FAST process. </title> <booktitle> In First ACM SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year> <month> 13 </month>
Reference-contexts: From a programming standpoint, DSLs are expected to produce programs which are both more concise and readable than the equivalent implementation in a general PL, since DSL's constructs map directly to concepts in a given domain of expertise. According to <ref> [1] </ref>, the basic viability of a DSL is validated by the following questions: does a particular DSL solve the right problems, is it easier to use and at least as efficient as current methods, and finally, is there a significant application? One popular response to the above needs has been object-oriented <p> In most areas of human activity, this formalization is built within the framework of natural language, and for this reason it presents an immediate challenge to computer processing. Yet the need for the systematic transfer of knowledge from an individual's memory to "corporate" memory has obvious positive economic consequences <ref> [1] </ref>. So one of the "meta" goals of DSL research is to formalize this very process, i.e., the conversion of domain expertise into a computer-parseable language. <p> This is in turn compounded to dependencies on CS-expertise in development, documentation, and maintenance. 2.2 Maintainable software A basic trend in the software industry has been to tighten the engineering-customer loop <ref> [1] </ref> in designing applications so they can be maintained directly by the customer after release. <p> another to perform corporate acquisitions, both of which require reasoning in terms of current interest rates, inflation, valuation models (often described as differential equations) the point being that anticipating the existence of a family of solutions maybe crucial in cost of the design lifecycle of a (family) of software applications <ref> [1] </ref>. In fact, one key to DSL design is to find 4 a reduced enough domain model (in terms of language constructs) which is general enough to accommodate for future family growth. From a quantitative viewpoint, [1] points out that 3-fold productivity gains can be expected from a DSL systems designed <p> maybe crucial in cost of the design lifecycle of a (family) of software applications <ref> [1] </ref>. In fact, one key to DSL design is to find 4 a reduced enough domain model (in terms of language constructs) which is general enough to accommodate for future family growth. From a quantitative viewpoint, [1] points out that 3-fold productivity gains can be expected from a DSL systems designed specifically for future growth. <p> Let C a and C b be the costs of producing A, and modifying B, respectively. In <ref> [1] </ref>, a conservative value of C b = 0:1C a is suggested, though it could easily be one order of magnitude lower. Since B is designed "for the future" it will require an initial investment I, typically greater than C a ([1] suggests three times greater). <p> is a little too extreme and that it doesn't address many of the DSL desiderata such as creating an environment which is not entirely procedurally-centered and which allows problems to be modeled with a specific language and be maintained by non-experts at a non-programming level. 3.2 The FAST process Weiss <ref> [1] </ref> outlines an architecture, called "FAST" geared toward the systematic construction of DSLs for a family of same-domain problems. While no practical implementation is presented, this work does provide good insight on the basic requirements for such a system. <p> Such a language would have to accommodate the information appearing at each of the stages of a model for customer-centered software development, illustrated by the sequence <ref> [1] </ref>: customer, system concept, application engineering, validation, customer (iterates back), and finally to product.
Reference: [2] <editor> G. Kiczales et al. </editor> <booktitle> Aspect oriented programming. In First ACM SIG--PLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: DSL design faces an important paradox in that it must sit between the unparseable (though ideal from an expressiveness standpoint) natural language and the available set of language implementation tools (e.g., lex, yacc, custom-tailored libraries, etc.). The principle of two R's <ref> [2] </ref> readability and writeability states that the design must be (i) simple enough so it is usable by non-programming domain experts and (ii) formal and systematized 2 enough so it can be reliably and efficiently parsed and translated to machine executable code. <p> Object orientation has been an elegant generalization of language design and a good point could be made that it is a general answer to domain-specific programming. One critique presented in <ref> [2] </ref> is that objects do not allow internal structure to be divorced from object behavior, and a program will not make explicit object interactions since these are typically encoded 3 procedurally for example, if a set of objects is used to represent devices in a circuit, the fact that certain devices <p> the programmer (a human) they can be done in the form of natural language, which circumvents some of the worries concerning formalization of this type of communication presented in the FAST paper above. 3.4 Aspect-oriented programming Not very different from infocentrism, Aspect-Oriented programming (AOP) as defined by Kiczales et al. <ref> [2] </ref>, represents a similar effort in dissociating domain-specific vocabulary from its implementation. An important issue pointed out is that a single abstraction framework (say C, or Pascal library) only does a good job of capturing one aspect of the program.
Reference: [3] <author> M. Lowry, A. Philpot, and I. Underwood. </author> <title> A formal approach to domain oriented software-design environments. </title> <booktitle> In KBSE'94, </booktitle> <year> 1994. </year>
Reference-contexts: The Amphion project <ref> [3] </ref> at Nasa leverages on these issues by making available to mathematical researchers a library of formally-documented geometrical components (routines/data structures) written in FORTRAN.
Reference: [4] <author> A. van Deursen and P. Klint. </author> <title> Little languages, </title> <booktitle> little maintenance? In First ACM SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: It is simply too costly and unreliable to expect a typical domain expert (say a stock trader or a civil engineer) to be able to maintain either lex/yacc or a complex library of routines tailored to their domain. In <ref> [4] </ref>, maintainability is defined as the ease with which a system can be kept in operation when modifications to the code become necessary. To this end, consider the usual modeling of problems by computer scientists as algorithms, called the algocentric approach [5]. <p> The authors subscribe to the previously-mentioned notion that applications are likely to be more economically viable if their input format is designed and maintained by a domain expert rather than a programming language guru, similar to the new "organization of software labor" proposed in <ref> [4] </ref>. In essence, this coalesces jargon creator, document author, developer, and end user into a single individual. They claim that "a domain expert designing a bad jargon is better than a computer expert designing good lex and yacc (but weak in domain knowledge)".
Reference: [5] <author> L. Nakatani and M. Jones. Jargons and infocentrism. </author> <booktitle> In First ACM SIG-PLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: In [4], maintainability is defined as the ease with which a system can be kept in operation when modifications to the code become necessary. To this end, consider the usual modeling of problems by computer scientists as algorithms, called the algocentric approach <ref> [5] </ref>. It was mentioned in the previous section that procedurally-encoded information is typically very hard to extract, so in many cases the growth and/or redevelopment of a legacy application will involve much time-consuming, unsystematic reverse-engineering. <p> One proposed solution has been to shift the focus of the domain-modeling phase to declaring what is known about a problem, rather than how a problem is to be solved. This is called the infocentric approach after <ref> [5] </ref>. <p> They are probably the first to provide an implementable framework (essentially a data structure 6 'generalizer') which addresses this problem. 3.3 Infocentrism In <ref> [5] </ref>, Nakatani and Jones emphasize that DSL systems should make explicit the separation of declarative data ("information") from algorithms. They call this paradigm infocentrism.
Reference: [6] <author> P. Pfahler and U. Kastens. </author> <title> Language design and implementation by selection. </title> <booktitle> In First ACM SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: They range from very simplistic approaches to frameworks for completely automated language generation. Unfortunately, working implementations tend to materialize more often at the simplistic end of this spectrum. 3.1 Language design 1-2-3 Pfahler and Kastens <ref> [6] </ref> present a rather simplistic solution to the design of a DSL in their view this process should be restricted to a yes/no questionnaire: departing from a general tabula-rasa language, which more or less captures the union of most current imperative languages (C, Fortran, Pascal, 5 etc.), a "designer" goes through
Reference: [7] <author> A. van Deursen. </author> <title> Domain-specific languages versus object-oriented frameworks: A financial engineering case study. In Proceedings Smalltalk and Java in Industry and Academia, </title> <address> Erfurt, Netherlands, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: The language is called Risla (Dutch acronym for Interest Rate Information Language), documented partially in works <ref> [7] </ref> and [8]. Risla is a DSL for the manipulation of interest rate products, which consist of financial instruments such as loans, futures, forward rate agreements, etc. All these instruments possess by nature much common vocabulary and concepts.
Reference: [8] <author> B. Arnold abd A. van Deursen and M. </author> <title> Res. An algebraic specification of a language for describing financial products. </title> <booktitle> In Proceedings of the ICSE-17 Workshop on Formal Methods Applications in Software Engineering Practice, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year> <month> 14 </month>
Reference-contexts: The language is called Risla (Dutch acronym for Interest Rate Information Language), documented partially in works [7] and <ref> [8] </ref>. Risla is a DSL for the manipulation of interest rate products, which consist of financial instruments such as loans, futures, forward rate agreements, etc. All these instruments possess by nature much common vocabulary and concepts.
References-found: 8

