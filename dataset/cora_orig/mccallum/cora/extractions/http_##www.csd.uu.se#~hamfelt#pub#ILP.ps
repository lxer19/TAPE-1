URL: http://www.csd.uu.se/~hamfelt/pub/ILP.ps
Refering-URL: http://www.csd.uu.se/~hamfelt/
Root-URL: 
Title: Inductive Metalogic Programming  
Author: Andreas Hamfelt Jtrgen Fischer Nilsson 
Keyword: Induction of logic programs, metalogic programming, higher order program cliches, predicate invention, mixed bottom-up and top-down in duction.  
Address: Denmark  
Affiliation: Computing Science Department Uppsala University  Department of Computer Science Technical University of  
Abstract: We propose a metalogic programming method for efficient induction of a fairly large class of list-handling logic programs delineated through restrictions on the hypothesis language. These restrictions take the form of predefined program recursion schemes (higher order "cliches") from which the hypotheses programs in the induction process are derived by plugging in either simple, nonrecursive clause programs or invented predicates. Metalogic programming is applied for handling clauses as first class data objects in connection with program schemes, and moreover for obtaining a flexible control scheme during the induction, avoiding a blindfold generate-and-test against the given program examples. A metalogic program induction testbed has been constructed and has successfully been applied to some induction problems discussed in the literature. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci & R. Nasr: </author> <title> Integrating Logic and Functional Programming, </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2, </volume> <pages> pp. 51-89, </pages> <year> 1989. </year>
Reference-contexts: that the relationship R holds for each pair obtained by consecutively coupling the members of lists L 1 and L 2 . 2 map ([]; R; []): One way of coping with this logical specification in ordinary first order clauses is to introduce a predicate, say apply ([16], see also <ref> [1, 13] </ref>), which expresses predication, that is the application of a predicate to its arguments. For the above this gives the logic program proper map ([],R,[]). map ([X|U],R,[Y|V]) :- apply (R,X,Y), map (U,R,V). <p> Base case: unfolding append (U,V,W):-fold (U,cons,V,W) with fold ([],R,Z,Z):-true yields As a matter of fact the map can be formed as an instance of fold. map (U,P,V) :- fold (U,p1 (P),[],V). apply (p1 (P),X,Y,[Z|Y]) :- apply (P,X,Z) This example illustrates a variant use of cliches, appealing to currying, cf. also <ref> [1] </ref>. It turns out, perhaps rather surprisingly, that a comprehensive collection of commonly occurring list predicates falls under this scheme. These draw on a restricted repertoire of argument predicates, supplemented with predicates themselves formed by this scheme.
Reference: [2] <author> D. Barker-Plummer: </author> <title> Cliche Programming in PROLOG, </title> <editor> in M. Bruynooghe (ed.): </editor> <booktitle> Proc. Second Workshop on Meta-programming in Logic, </booktitle> <pages> pp. 247-256, </pages> <institution> Department of Computer Science, Katholieke Universiteit Leuven, </institution> <year> 1990. </year>
Reference-contexts: Nevertheless it is tempting from a programming methodology point of view to admit predicate variables in order to provide program schemes or "cliches" <ref> [2] </ref> from which proper programs result by instantiation of predicate variables with predicate constants. Strictly logically this is a daring move from predicate logic to logical type theory, which is pursued in higher logic programming languages such as -Prolog, calling for the ensuing complex notion of higher order unification.
Reference: [3] <author> R. Bird & Ph. Wadler: </author> <title> Introduction to Functional Programming, </title> <publisher> Prentice Hall (C.A.R. Hoare Series), </publisher> <year> 1988. </year>
Reference-contexts: X 1 ; :::; X n ) :- p (X 1 ; :::; X n ). for each proper predicate constant p in the program. 3 Metalogic programming features the alternative more direct clause representation (as a term) [[map,[],R,[]], Another commonly occurring cliche, a classical from functional programming, cf. e.g. <ref> [3] </ref>, is the filter filter ([],P,[]). filter ([X|L],P,[X|LL]) :- apply (P,X), filter (L,P,LL). filter ([X|L],P,LL) :- not apply (P,X), filter (L,P,LL). As the most general cliche, however, we focus on fold (called iterate in [16]) fold ([],R,Z,Z). fold ([X|L],R,Z,Y) :- fold (L,R,Z,U), apply (R,X,U,Y).
Reference: [4] <author> K. A. Bowen & R. A. Kowalski: </author> <title> Amalgamating Language and Metalanguage in Logic Programming, </title> <editor> in K. L. Clark & S. A. Tarnlund (eds.): </editor> <booktitle> Logic Programming, </booktitle> <pages> pp. 153-172, </pages> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: In the refutation proof the hypothesis goal is negated (the variables hence becoming universally quantified); a successful proof is reached when obtaining the empty clause resolvent. 2 Metalogic Programming In metalogic programming <ref> [4] </ref> a theory in the form of a logic program comprised of clauses is encoded as a term d-e and the provability relation ` is formalised as a predicate demo ( , ).
Reference: [5] <author> K. Eshghi: </author> <title> Meta-language in Logic Programming, </title> <type> Ph.D. Thesis, </type> <institution> Department of Computing, Imperial College, </institution> <address> London, </address> <year> 1987. </year>
Reference-contexts: The ways of encoding a formula into a corresponding term de (cf. Godel encoding) are discussed extensively in the metalogic programming literature, see e.g. <ref> [5] </ref>. Basically there are two options: (1) Ground term representation in which variables of the object language formula become ground (i.e., variable-free) terms in the encoding and (2) Non-ground encoding in which object language variables become variables of the metalanguage.
Reference: [6] <author> P. Flach: </author> <title> Simply Logical, Intelligent Reasoning by Example, </title> <publisher> Wiley, </publisher> <year> 1994. </year>
Reference-contexts: Inductive logic programming thus seeks to turn a partial explicit definition of a predicate into an implicit definition. 3.1 Bottom-up versus Top-down Induction There are two contemporary computational approaches to inductive logic programming <ref> [6, 11, 12] </ref>: Bottom-up induction based on generalization of observations (i.e. input/output examples), and conversely top-down induction based on specialization of an overly general hypothesis program. The bottom-up approach tries to come up with definite clauses from which the observations follow or are plainly instances. <p> This suite constitutes recursively a behaviour suite for the unknown predicate argument for the cliche. 2. Generalization step: Compute the least general generalization, LGG, of the above abduced atoms for the unknown predicate argument, using an anti-unification algorithm, cf. e.g. <ref> [6] </ref>. (In a simplified version this step alternatively may simply refer to a given collection of base predicates.) 3.
Reference: [7] <author> A. Hamfelt: </author> <title> Metalogic Representation of Multilayered Knowledge, </title> <type> Ph.D. Thesis, </type> <institution> Up-psala Theses in Computing Science 15, Uppsala University, Uppsala, </institution> <year> 1992. </year>
Reference-contexts: The explicit availability of the proof (computation) predicate demo through the interpreter clause program demo in metalogic programming renders it possible to "customize", monitor, and control the deduction process. This reflection between object level and metalevel can be iterated, giving rise to the so-called multilayered metalogic programming methodology <ref> [7, 8] </ref>. Multilayered metalogic programs have been taken advantage of in connection with partial evaluation, in which in particular the (term encoded) metainterpreter may be provided as argument to itself (self-applicable partial evaluator).
Reference: [8] <author> A. Hamfelt, A. Hansson: </author> <title> Representation of Fragmentary Multilayered Knowledge, </title> <editor> in A. Pettorossi (ed.): </editor> <booktitle> Meta-Programming in Logic, Lecture Notes in Computer Science 649, </booktitle> <pages> pp. 321-335, </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The explicit availability of the proof (computation) predicate demo through the interpreter clause program demo in metalogic programming renders it possible to "customize", monitor, and control the deduction process. This reflection between object level and metalevel can be iterated, giving rise to the so-called multilayered metalogic programming methodology <ref> [7, 8] </ref>. Multilayered metalogic programs have been taken advantage of in connection with partial evaluation, in which in particular the (term encoded) metainterpreter may be provided as argument to itself (self-applicable partial evaluator).
Reference: [9] <author> J. Kietz and S. Wrobel: </author> <title> Controlling the complexity of learning in logic through syntactic and task-oriented models, </title> <booktitle> in [12]. </booktitle>
Reference-contexts: Here we take a more pragmatical view using the method outlined in [16] for emulating higher order mechanisms in usual clausal logic, akin to the rule models in the induction system MOBAL/RDT <ref> [9] </ref> (see also [11]).
Reference: [10] <author> R. A. Kowalski: </author> <title> Problems and Promises of Computational Logic, </title> <editor> in J. W. Lloyd (ed.) </editor> <booktitle> Computational Logic, </booktitle> <pages> pp. 1-36, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [11] <author> N. Lavrac & S. Dzeroski: </author> <title> Inductive Logic Programming, Techniques and Applications, </title> <publisher> Ellis Horwood, </publisher> <year> 1994. </year>
Reference-contexts: Inductive logic programming thus seeks to turn a partial explicit definition of a predicate into an implicit definition. 3.1 Bottom-up versus Top-down Induction There are two contemporary computational approaches to inductive logic programming <ref> [6, 11, 12] </ref>: Bottom-up induction based on generalization of observations (i.e. input/output examples), and conversely top-down induction based on specialization of an overly general hypothesis program. The bottom-up approach tries to come up with definite clauses from which the observations follow or are plainly instances. <p> Here we take a more pragmatical view using the method outlined in [16] for emulating higher order mechanisms in usual clausal logic, akin to the rule models in the induction system MOBAL/RDT [9] (see also <ref> [11] </ref>).
Reference: [12] <editor> S. Muggleton (ed.): </editor> <booktitle> Inductive Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: Inductive logic programming thus seeks to turn a partial explicit definition of a predicate into an implicit definition. 3.1 Bottom-up versus Top-down Induction There are two contemporary computational approaches to inductive logic programming <ref> [6, 11, 12] </ref>: Bottom-up induction based on generalization of observations (i.e. input/output examples), and conversely top-down induction based on specialization of an overly general hypothesis program. The bottom-up approach tries to come up with definite clauses from which the observations follow or are plainly instances.
Reference: [13] <author> J. Fischer Nilsson: </author> <title> Combinatory Logic Programming, </title> <editor> in M. Bruynooghe (ed.): </editor> <booktitle> Proc. Second Workshop on Meta-programming in Logic, </booktitle> <pages> pp. 187-202, </pages> <institution> Department of Computer Science, Katholieke Universiteit Leuven, </institution> <year> 1990. </year>
Reference-contexts: that the relationship R holds for each pair obtained by consecutively coupling the members of lists L 1 and L 2 . 2 map ([]; R; []): One way of coping with this logical specification in ordinary first order clauses is to introduce a predicate, say apply ([16], see also <ref> [1, 13] </ref>), which expresses predication, that is the application of a predicate to its arguments. For the above this gives the logic program proper map ([],R,[]). map ([X|U],R,[Y|V]) :- apply (R,X,Y), map (U,R,V).
Reference: [14] <author> G. Plotkin: </author> <title> A Note on Inductive Generalization, </title> <editor> in B. Meltzer & D. Michie (eds.): </editor> <booktitle> Machine Intelligence 5, </booktitle> <pages> pp. 153-163, </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: The theoretical basis for a constructive computational logical approach to induction was laid down in <ref> [14] </ref> and followed up by contemporary theoretical research, e.g. [15]. Inductive logic programming in particular aims at computationally synthesizing a logic program which can derive the given input-output data. These data usually take the form of a finite test suite of (ground) atomic goals.
Reference: [15] <author> T. Sato: </author> <title> A Complete Set of Rules for Inductive Inference, </title> <type> report TR-92-44, </type> <institution> Elec-trotechnical Laboratory, Tsukuba, </institution> <address> Japan, </address> <year> 1992. </year>
Reference-contexts: The theoretical basis for a constructive computational logical approach to induction was laid down in [14] and followed up by contemporary theoretical research, e.g. <ref> [15] </ref>. Inductive logic programming in particular aims at computationally synthesizing a logic program which can derive the given input-output data. These data usually take the form of a finite test suite of (ground) atomic goals.
Reference: [16] <author> D. H. D. Warren: </author> <title> Higher Extensions of Prolog are they needed?, </title> <editor> J. E. Hayes, D. Michie & Y-H Pao (eds.), </editor> <booktitle> Machine Intelligence 10, </booktitle> <pages> pp. 441-454, </pages> <publisher> Edinburgh University Press, </publisher> <year> 1982. </year>
Reference-contexts: Strictly logically this is a daring move from predicate logic to logical type theory, which is pursued in higher logic programming languages such as -Prolog, calling for the ensuing complex notion of higher order unification. Here we take a more pragmatical view using the method outlined in <ref> [16] </ref> for emulating higher order mechanisms in usual clausal logic, akin to the rule models in the induction system MOBAL/RDT [9] (see also [11]). <p> As the most general cliche, however, we focus on fold (called iterate in <ref> [16] </ref>) fold ([],R,Z,Z). fold ([X|L],R,Z,Y) :- fold (L,R,Z,U), apply (R,X,U,Y). With this powerful cliche the well-known append predicate simply becomes append (U,V,W) :- fold (U,cons,V,W). appealing to the auxiliary general purpose list constructor predicate defined by the unit clause cons (U,V,[U|V]).
References-found: 16

