URL: http://www.cs.rpi.edu/~zaki/PS/CIKM98.ps.gz
Refering-URL: http://www.cs.rpi.edu/~zaki/papers.html
Root-URL: http://www.cs.rpi.edu
Title: Efficient Enumeration of Frequent Sequences  
Author: Mohammed J. Zaki 
Address: Troy NY 12180  
Affiliation: Computer Science Department, Rensselaer Polytechnic Institute,  
Abstract: In this paper we present SPADE, a new algorithm for fast discovery of Sequential Patterns. The existing solutions to this problem make repeated database scans, and use complex hash structures which have poor locality. SPADE utilizes combinatorial properties to decompose the original problem into smaller sub-problems, that can be independently solved in main-memory using efficient lattice search techniques, and using simple join operations. All sequences are discovered in only three database scans. Experiments show that SPADE outperforms the best previous algorithm by a factor of two, and by an order of magnitude with some pre-processed data. It also has linear scalability with respect to the number of customers, and a number of other database parameters. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal et al. </author> <title> Fast discovery of association rules. </title> <editor> In U. Fayyad, et al (eds.) </editor> <booktitle> Advances in KDD, </booktitle> <publisher> AAAI Press, </publisher> <year> 1996. </year>
Reference-contexts: The MEDD and MSDD algorithms [7] discover patterns in multiple event sequences. However, they only find sequences of length 2 with a given window size and a time-gap. Sequence discovery can essentially be thought of as association discovery <ref> [1] </ref> over a temporal database. While association rules discover only intra-transaction patterns (itemsets), we now also have to discover inter-transaction patterns (sequences). The set of all frequent sequences is a superset of the set of frequent itemsets. <p> The set of all frequent sequences is a superset of the set of frequent itemsets. Due to this similarity sequence mining algorithms like AprioriAll, GSP, etc., utilize some of the ideas initially proposed for the discovery of association rules <ref> [1, 10] </ref>. Our new algorithm is based on the fast association mining techniques presented by us in [13].
Reference: [2] <author> R. Agrawal and R. Srikant. </author> <title> Mining sequential patterns. </title> <booktitle> In 11th ICDE Conf., </booktitle> <year> 1995. </year>
Reference-contexts: 10 15 Transaction-TimeCustomer-Id Items BF-&gt;A D-&gt;B->A ABF 3 2 2 Frequent 3-Sequences B F 4 2 Frequent 1-Sequences AB F-&gt;A D-&gt;B BF 3 2 2 2 Frequent 2-Sequences D-&gt;BF->A 2 Frequent 4-Sequences FREQUENT SEQUENCES A B F103 DATABASE 2.1 Related Work The problem of mining sequential patterns was introduced in <ref> [2] </ref>. They also presented three algorithms for solving this problem. The AprioriAll algorithm was shown to perform equal to or better than the other two approaches. In subsequent work [11], the same authors proposed the GSP algorithm that outperformed AprioriAll by up to 20 times. <p> SPADE (min sup; D): F 1 = f frequent items or 1-sequences g; F 2 = f frequent 2-sequences g; E = f equivalence classes [X] 1 g; for all [X] 2 E do Enumerate-Frequent-Seq ([X]); 4.1 Computing Frequent 1-Sequences and 2-Sequences Most of the current sequence mining algorithms <ref> [2, 11] </ref> assume a horizontal database layout such as the one shown in Figure 1. In the horizontal format the database consists of a set of customers. Each customer has a set of transactions, along with the items contained in the transaction. <p> Like [11] we set N S = 5000, N I = 25000 and N = 10000. The number of data-sequences was set to D = 200; 000. Table 1 shows the datasets with their parameter settings. We refer the reader to <ref> [2] </ref> for additional details on the dataset generation. Plan Dataset: The real-life dataset was obtained from a Natural Language Planning domain. The planner generates plans for routing commodities from one city to another. A customer corresponds to a plan identifier, while a transaction corresponds to an event in a plan.
Reference: [3] <author> B. A. Davey and H. A. Priestley. </author> <title> Introduction to Lattices and Order. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Nevertheless, the sequence search space is much more complex and challenging than the itemset space, and thus warrants specific algorithms. 3 Sequence Enumeration: Lattice-based Approach We assume that the reader is familiar with basic concepts of lattice theory (see <ref> [3] </ref> for a good introduction). Let P be a set.
Reference: [4] <author> K. Hatonen, et al. </author> <title> Knowledge discovery from telecom. network alarm databases. </title> <booktitle> In 12th ICDE Conf., </booktitle> <month> Feb </month> <year> 1996. </year>
Reference-contexts: This kind of information can be used to restructure the web-site, or to dynamically insert relevant links in web pages based on user access patterns. There are many other domains where sequence mining has been applied, which include identifying plan failures [12], finding network alarm patterns <ref> [4] </ref>, and so on. The task of discovering all frequent sequences in large databases is quite challenging. The search space is extremely large. For ex ample, with m attributes there are O (m k ) potentially frequent sequences of length k.
Reference: [5] <author> H. Mannila and H. Toivonen. </author> <title> Discovering generalized episodes using minimal occurences. </title> <booktitle> In 2nd Intl. Conf. Knowledge Discovery and Data Mining, </booktitle> <year> 1996. </year>
Reference-contexts: Our definition of a sequence can be expressed as an episode, however their work is targeted to discover the frequent episodes in a single long event sequence, while we are interested in finding frequent sequences across many different customer-sequences. They further extended their framework in <ref> [5] </ref> to discover generalized episodes, which allows one to express arbitrary unary conditions on individual episode events, or binary conditions on event pairs. The MEDD and MSDD algorithms [7] discover patterns in multiple event sequences.
Reference: [6] <author> H. Mannila, H. Toivonen, and I. Verkamo. </author> <title> Discovering frequent episodes in sequences. </title> <booktitle> In 1st Intl. Conf. KDD, </booktitle> <year> 1995. </year>
Reference-contexts: In subsequent work [11], the same authors proposed the GSP algorithm that outperformed AprioriAll by up to 20 times. They also introduced maximum gap, minimum gap, and sliding window constraints on the discovered sequences. The problem of finding frequent episodes in a sequence of events was presented in <ref> [6] </ref>. An episode consists of a set of events and an associated partial order over the events. <p> The closure under meet leads to the well known observation on sequence frequency: Lemma 1 All subsequences of a frequent sequence are frequent. The above lemma leads very naturally to a bottom-up search procedure for enumerating frequent sequences, which has been leveraged in many sequence mining algorithms <ref> [11, 6, 7] </ref>. However, the lattice formulation makes it apparent that we need not restrict ourselves to a purely bottom-up search.
Reference: [7] <author> T. Oates, et al. </author> <title> Algorithms for finding temporal structure in data. </title> <booktitle> In 6th Intl. Wkshp. AI and Statistics, </booktitle> <month> Mar </month> <year> 1997. </year>
Reference-contexts: They further extended their framework in [5] to discover generalized episodes, which allows one to express arbitrary unary conditions on individual episode events, or binary conditions on event pairs. The MEDD and MSDD algorithms <ref> [7] </ref> discover patterns in multiple event sequences. However, they only find sequences of length 2 with a given window size and a time-gap. Sequence discovery can essentially be thought of as association discovery [1] over a temporal database. <p> The closure under meet leads to the well known observation on sequence frequency: Lemma 1 All subsequences of a frequent sequence are frequent. The above lemma leads very naturally to a bottom-up search procedure for enumerating frequent sequences, which has been leveraged in many sequence mining algorithms <ref> [11, 6, 7] </ref>. However, the lattice formulation makes it apparent that we need not restrict ourselves to a purely bottom-up search.
Reference: [8] <author> S. Parthasarathy, M. J. Zaki, and W. Li. </author> <title> Memory placement techniques for parallel association mining. </title> <booktitle> In 4th Intl. Conf. KDD, </booktitle> <month> Aug </month> <year> 1998. </year> <title> [9] http://www.almaden.ibm.com/cs/quest/syndata.html. Quest Project. </title> <institution> IBM Almaden Research Center, </institution> <address> San Jose, CA 95120. </address>
Reference-contexts: Some of the methods, especially those using some form of sampling, can be sensitive to the data-skew, which can adversely effect performance. Furthermore, most approaches use very complicated internal data structures which have poor locality <ref> [8] </ref>, and add additional space and computation overheads. Our goal is to overcome all of these limitations. In this paper we present SPADE (Sequential PAttern Discovery using Equivalence classes), a new algorithm for discovering the set of all frequent sequences. <p> As the length of the frequent sequences increases, the size of the tid-lists decreases, resulting in very fast joins. 2) No complicated hash-tree structure is used, and no overhead of generating and searching of customer subsequences is incurred. These structures typically have very poor locality <ref> [8] </ref>. On the other hand SPADE has excellent locality, since a join requires only a linear scan of two lists. 3) As the minimum support is lowered, more and larger frequent sequences are found. GSP makes a complete dataset scan for each iteration.
Reference: [10] <author> A. Savasere, et al. </author> <title> An efficient algorithm for mining association rules in large databases. </title> <booktitle> In 21st VLDB Conf., </booktitle> <year> 1995. </year>
Reference-contexts: The set of all frequent sequences is a superset of the set of frequent itemsets. Due to this similarity sequence mining algorithms like AprioriAll, GSP, etc., utilize some of the ideas initially proposed for the discovery of association rules <ref> [1, 10] </ref>. Our new algorithm is based on the fast association mining techniques presented by us in [13].
Reference: [11] <author> R. Srikant and R. Agrawal. </author> <title> Mining sequential patterns: Generalizations and performance improvements. </title> <booktitle> In 5th Intl. Conf. Extending Database Technology, </booktitle> <month> Mar </month> <year> 1996. </year>
Reference-contexts: They also presented three algorithms for solving this problem. The AprioriAll algorithm was shown to perform equal to or better than the other two approaches. In subsequent work <ref> [11] </ref>, the same authors proposed the GSP algorithm that outperformed AprioriAll by up to 20 times. They also introduced maximum gap, minimum gap, and sliding window constraints on the discovered sequences. The problem of finding frequent episodes in a sequence of events was presented in [6]. <p> The closure under meet leads to the well known observation on sequence frequency: Lemma 1 All subsequences of a frequent sequence are frequent. The above lemma leads very naturally to a bottom-up search procedure for enumerating frequent sequences, which has been leveraged in many sequence mining algorithms <ref> [11, 6, 7] </ref>. However, the lattice formulation makes it apparent that we need not restrict ourselves to a purely bottom-up search. <p> SPADE (min sup; D): F 1 = f frequent items or 1-sequences g; F 2 = f frequent 2-sequences g; E = f equivalence classes [X] 1 g; for all [X] 2 E do Enumerate-Frequent-Seq ([X]); 4.1 Computing Frequent 1-Sequences and 2-Sequences Most of the current sequence mining algorithms <ref> [2, 11] </ref> assume a horizontal database layout such as the one shown in Figure 1. In the horizontal format the database consists of a set of customers. Each customer has a set of transactions, along with the items contained in the transaction. <p> = ABDF , then we would first check within its class [A] if ADF is frequent, and since [B] will have been processed if we solve the classes in reverse lexicographic order, we can also check if BDF is frequent. 5 The GSP Algorithm Below we describe the GSP algorithm <ref> [11] </ref> in some more detail, since we use it as a base against which we compare SPADE, and it is one of the best current algorithms. <p> Another pass is made to gather their support. The frequent 2-sequences are used to generate the candidate 3-sequences, and this process is repeated until no more frequent sequences are found. There are two main steps in GSP, shown in Figure 12 (see <ref> [11] </ref> for more details). 1) Candidate Generation: Given the set of frequent (k 1)-sequences, F k1 , the candidates for the next pass are generated by joining F k1 with itself. A pruning phase eliminates any sequence at least one of whose subsequences is not frequent. <p> For each such subsequence a search is made in the hash-tree. If a candidate in the hash-tree matches the subsequence, its count is incremented. 6 Experimental Results In this section we compare the performance of SPADE with the GSP algorithm. The GSP algorithm was implemented as described in <ref> [11] </ref>. For SPADE results are shown only for the BFS search. Experiments were performed on a 100MHz MIPS processor with 256MB main memory running IRIX 6.2, with non-local 2GB disk. Synthetic Datasets: The synthetic datasets are the same as those used in [11], albeit with twice as many customers. <p> The GSP algorithm was implemented as described in <ref> [11] </ref>. For SPADE results are shown only for the BFS search. Experiments were performed on a 100MHz MIPS processor with 256MB main memory running IRIX 6.2, with non-local 2GB disk. Synthetic Datasets: The synthetic datasets are the same as those used in [11], albeit with twice as many customers. We used the publicly available dataset generation code from the IBM Quest data mining project [9]. <p> Next a customer of average C transactions is created, and sequences in N S are assigned to different customer elements, respecting the average transaction size of T . The generation stops when D customers have been generated. Like <ref> [11] </ref> we set N S = 5000, N I = 25000 and N = 10000. The number of data-sequences was set to D = 200; 000. Table 1 shows the datasets with their parameter settings. We refer the reader to [2] for additional details on the dataset generation.
Reference: [12] <author> M. J. Zaki, et al. PLANMINE: </author> <title> Sequence mining for plan failures. </title> <booktitle> In 4th Intl. Conf. KDD, </booktitle> <month> Aug </month> <year> 1998. </year>
Reference-contexts: This kind of information can be used to restructure the web-site, or to dynamically insert relevant links in web pages based on user access patterns. There are many other domains where sequence mining has been applied, which include identifying plan failures <ref> [12] </ref>, finding network alarm patterns [4], and so on. The task of discovering all frequent sequences in large databases is quite challenging. The search space is extremely large. For ex ample, with m attributes there are O (m k ) potentially frequent sequences of length k.
Reference: [13] <author> M. J. Zaki, et al. </author> <title> New algorithms for fast discovery of association rules. </title> <booktitle> In 3rd Intl. Conf. KDD, </booktitle> <month> Aug </month> <year> 1997. </year>
Reference-contexts: Due to this similarity sequence mining algorithms like AprioriAll, GSP, etc., utilize some of the ideas initially proposed for the discovery of association rules [1, 10]. Our new algorithm is based on the fast association mining techniques presented by us in <ref> [13] </ref>. Nevertheless, the sequence search space is much more complex and challenging than the itemset space, and thus warrants specific algorithms. 3 Sequence Enumeration: Lattice-based Approach We assume that the reader is familiar with basic concepts of lattice theory (see [3] for a good introduction). Let P be a set.
References-found: 12

