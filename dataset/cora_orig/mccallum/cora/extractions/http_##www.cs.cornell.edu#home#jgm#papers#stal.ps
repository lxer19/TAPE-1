URL: http://www.cs.cornell.edu/home/jgm/papers/stal.ps
Refering-URL: http://www.cs.cornell.edu/home/jgm/papers.html
Root-URL: 
Title: Stack-Based Typed Assembly Language  
Author: Greg Morrisett Karl Crary Neal Glew David Walker 
Keyword: STAL types.  
Date: December 8, 1997  
Affiliation: Cornell University  
Abstract: In previous work, we presented a low-level typed intermediate language, Typed Assembly Language (TAL), and proved its type system is sound. TAL is sufficiently expressive to support compilation from high-level languages such as ML while preserving source level abstractions. Furthermore, its type system does not impede the use of traditional low-level optimizations. The compiler presented was based on a continuation-passing style transform, which eliminated the need for a control stack by heap allocating stack frames. However, modern architectures and most compilers are based on stack allocation of these frames. This paper presents STAL, an extension of TAL with stack constructs and stack types to support the stack allocation style. We show that STAL is sufficiently expressive to support languages such as Java, Pascal, and ML; constructs such as exceptions and displays; and optimizations such as tail call elimination and callee-saves registers. This paper makes two additional contributions. First, it clarifies the connection between compilation based on a CPS transform and stack-based compilation. The latter is seen as a continuation-passing style where continuation closures are unboxed by the caller and the continuation's environment is placed on the stack. Second, it illustrates how STAL can formally model calling conventions by specifying them as formal translations of source function types to 
Abstract-found: 1
Intro-found: 1
Reference: [AM91] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> Volume 528 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: In particular, "stack frames" were represented by heap-allocated closures as in the SML/NJ compiler <ref> [AM91, App92] </ref>. For example, figure 1 shows the TAL code our heap-based compiler would produce for the recursive factorial computation. Each function, such as fact, takes an additional argument which represents the control stack as a continuation closure. <p> The general framework makes 2 it easy to transfer transformations developed for one style to another. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [AM91, App92, AS92] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a
Reference: [App92] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: In particular, "stack frames" were represented by heap-allocated closures as in the SML/NJ compiler <ref> [AM91, App92] </ref>. For example, figure 1 shows the TAL code our heap-based compiler would produce for the recursive factorial computation. Each function, such as fact, takes an additional argument which represents the control stack as a continuation closure. <p> Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight co-routine threads when continuations are heap allocated <ref> [App92, Ste78, KKR + 86, Wan80] </ref>. Second, Appel and Shao have shown that heap-allocation of closures can have better space properties, primarily because it is easier to share environments [AS93]. <p> The general framework makes 2 it easy to transfer transformations developed for one style to another. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [AM91, App92, AS92] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a
Reference: [AS92] <author> Andrew Appel and Zhong Shao. </author> <title> Callee-saves registers in continuation-passing style. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5 </volume> <pages> 189-219, </pages> <year> 1992. </year>
Reference-contexts: The general framework makes 2 it easy to transfer transformations developed for one style to another. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [AM91, App92, AS92] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a <p> ; r3:ff; sp:; ra:8 []fsp:; r1:int ; r3:ffgg Translating this type back in to a boxed, heap allocated closure, we obtain: 8 [ff]:fr1:hi; r2 : int ; r3:ff; ra:9fi:h8 []fr1:fi; r2:int ; r3:ffg 1 ; fi 1 ig Which is the same as the callee-saves approach of Appel and Shao <ref> [AS92] </ref>. Thus we see how our correspondence enables transformations developed for CPS transform based compilers can be used in traditional compilers and vice versa. The generalization to multiple callee-saves registers and other calling conventions should be clear.
Reference: [AS93] <author> Andrew Appel and Zhong Shao. </author> <title> An empirical and analytic study of stack vs. heap cost for languages with clsoures. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1), </volume> <month> January </month> <year> 1993. </year>
Reference-contexts: Second, Appel and Shao have shown that heap-allocation of closures can have better space properties, primarily because it is easier to share environments <ref> [AS93] </ref>. Third, there is a unified memory management mechanism (namely the garbage collector) for allocating and collecting all kinds of objects, including stack frames. Finally, Appel and Shao have argued that, at least for SML/NJ, the locality lost by heap-allocating stack frames is negligible [AS93]. <p> it is easier to share environments <ref> [AS93] </ref>. Third, there is a unified memory management mechanism (namely the garbage collector) for allocating and collecting all kinds of objects, including stack frames. Finally, Appel and Shao have argued that, at least for SML/NJ, the locality lost by heap-allocating stack frames is negligible [AS93]. However, there are also compelling reasons for providing support for stacks. First, almost all compilers use a stack-based architecture.
Reference: [BD95] <author> Mark Bailey and Jack Davidson. </author> <title> A formal model of procedure calling conventions. </title> <booktitle> In Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 298-310, </pages> <address> San Francisco, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: However, the type system for STAL is considerably simpler than the type system of Tofte et al., as it requires no effect information in types. Bailey and Davidson also describe a specification language for modeling procedure calling conventions and checking that implementations respect these conventions <ref> [BD95] </ref>. They are able to specify features such as a variable number of arguments that our formalism does not address. However, their model is explicitly tied to a stack-based calling convention and does not address features such as exception handlers.
Reference: [BTV96] <author> Lars Birkedal, Mads Tofte, and Magnus Vejlstrup. </author> <title> From region inference to von Neumann machines via region representation inference. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183, </pages> <address> St. Petersburg, </address> <month> January </month> <year> 1996. </year> <month> 14 </month>
Reference-contexts: Consequently, procedure call must be added as a primitive construct. In contrast, our treatment supports polymorphic stack recursion, and hence procedure calls can be encoded with existing assembly-language primitives. Tofte and others <ref> [BTV96, TT94] </ref> have developed an allocation strategy involving regions. Regions are lexically scoped containers that have a LIFO ordering on their lifetimes, much like the values on a stack. As in our approach, polymorphic recursion of abstracted region variables plays a critical role.
Reference: [Cor97] <author> Intel Corporation. </author> <title> Intel Architecture Optimization Manual. </title> <publisher> Intel Corporation, </publisher> <address> P.O. Box 7641, Mt. Prospect, IL, 60056-7641, </address> <year> 1997. </year>
Reference-contexts: Finally, many machine architectures have hardware devices that expect programs to behave in a stack-like fashion. For example, the Pentium Pro processor has an internal stack that is used to predict return addresses for procedures so that instruction pre-fetching will not be stalled <ref> [Cor97] </ref>. The internal stack is guided by the use of call/return primitives which use a control stack. In this paper, we provide a stack typing discipline that is remarkably simple, but powerful enough to compile languages such as Pascal, Java, or ML without adding high-level primitives to the assembly language.
Reference: [Cra96] <author> Karl Crary. </author> <title> KML Reference Manual. </title> <institution> Department of Computer Science, Cornell University, </institution> <year> 1996. </year>
Reference-contexts: However, we claim that the framework presented here is a practical approach to compilation. To substantiate this claim, we are constructing a compiler called TALC that maps the KML programming language <ref> [Cra96] </ref> to a variant of STAL described here, suitably adapted for the Intel x86 family of processors. We have found it straightforward to enrich the target language type system to include support for other type constructors, such as references, higher-order constructors, and recursive types.
Reference: [DTM94] <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory subsystem performance of programs using copying garbage collection. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: However, there are also compelling reasons for providing support for stacks. First, almost all compilers use a stack-based architecture. Second, Tarditi and Diwan have shown that with the wrong kind of cache architecture, heap-allocation of continuations (as in SML/NJ) can have substantial overhead due to a loss of locality <ref> [DTM95, DTM94] </ref>. Third, Appel and Shao do not consider imperative languages, such as Java, where the ability to share environments is greatly reduced nor do they consider languages that do not require garbage collection. Finally, many machine architectures have hardware devices that expect programs to behave in a stack-like fashion.
Reference: [DTM95] <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory system performance of programs with intensive heap allocation. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(3) </volume> <pages> 244-273, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: However, there are also compelling reasons for providing support for stacks. First, almost all compilers use a stack-based architecture. Second, Tarditi and Diwan have shown that with the wrong kind of cache architecture, heap-allocation of continuations (as in SML/NJ) can have substantial overhead due to a loss of locality <ref> [DTM95, DTM94] </ref>. Third, Appel and Shao do not consider imperative languages, such as Java, where the ability to share environments is greatly reduced nor do they consider languages that do not require garbage collection. Finally, many machine architectures have hardware devices that expect programs to behave in a stack-like fashion.
Reference: [HDB90] <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 66-77, </pages> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices, 25(6). </note>
Reference-contexts: Second, threads and advanced mechanisms for implementing first class continuations such as the work by Hieb et al. <ref> [HDB90] </ref> cannot be modeled in this system without adding new primitives. However, we claim that the framework presented here is a practical approach to compilation.
Reference: [KKR + 86] <author> David Kranz, R. Kelsey, J. Rees, P. R. Hudak, J. Philbin, and N. Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight co-routine threads when continuations are heap allocated <ref> [App92, Ste78, KKR + 86, Wan80] </ref>. Second, Appel and Shao have shown that heap-allocation of closures can have better space properties, primarily because it is easier to share environments [AS93].
Reference: [LY96] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: In particular, the typing discipline supports stack allocation of temporary variables and values which do not "escape upwards", stack allocation of procedure activation frames, exception handlers, and displays, as well as optimizations such as callee-saves registers. Unlike the JVM architecture <ref> [LY96] </ref>, our system does not constrain the stack to have the same size at each control-flow point, nor does it require new high-level primitives for procedure call/return. Instead, our assembly language continues to have low-level RISC-like primitives such as loads, stores, and jumps.
Reference: [MMH96] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Petersburg, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: At the TAL level, we represent closures as a pair consisting of a code block label and a pointer to an environment data structure. The type of the environment must be held abstract in order to avoid typing difficulties <ref> [MMH96] </ref>, and thus we pack the type of the environment and the pair to form an existential type.
Reference: [MWCG97] <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <title> From System F to typed assembly language (extended version). </title> <type> Technical Report TR97-1651, </type> <institution> Cornell University, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: 1 Introduction and Motivation In Morrisett et al. <ref> [MWCG98, MWCG97] </ref>, we presented a typed assembly language (TAL) and proved that its type system was sound with respect to its operational semantics. <p> Instructions mostly consist of conventional RISC-style assembly operations, including arithmetic, branches, loads, and stores. The two non-standard instructions include malloc, and unpack which are explained below. Evaluation is specified as a deterministic rewriting system that takes programs to programs (see Morrisett et al. <ref> [MWCG98, MWCG97] </ref> for details). The types for TAL consist of type variables, integers, tuple types, existential types, and polymorphic code types. Tuple types contain initialization flags (either 0 or 1) that determine whether or not components have been initialized.
Reference: [MWCG98] <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <title> From System F to typed assembly language. </title> <booktitle> In Twenty-Fifth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: 1 Introduction and Motivation In Morrisett et al. <ref> [MWCG98, MWCG97] </ref>, we presented a typed assembly language (TAL) and proved that its type system was sound with respect to its operational semantics. <p> Instructions mostly consist of conventional RISC-style assembly operations, including arithmetic, branches, loads, and stores. The two non-standard instructions include malloc, and unpack which are explained below. Evaluation is specified as a deterministic rewriting system that takes programs to programs (see Morrisett et al. <ref> [MWCG98, MWCG97] </ref> for details). The types for TAL consist of type variables, integers, tuple types, existential types, and polymorphic code types. Tuple types contain initialization flags (either 0 or 1) that determine whether or not components have been initialized.
Reference: [Rey95] <author> John Reynolds. </author> <title> Using functor categories to generate intermediate code. </title> <booktitle> In Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 25-36, </pages> <address> San Francisco, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: type, but we have not yet explored the ramifications of this enhancement in detail. 5 Related and Future Work Our work is partially inspired by that of Reynolds, which uses functor categories to "replace continuations by instruction sequences and store shapes by descriptions of the structure of the run-time stack" <ref> [Rey95] </ref>. However, Reynolds was primarily concerned with using functors to express an intermediate language of a semantics-based compiler for Algol, whereas we are primarily concerned with type structure for general-purpose target languages.
Reference: [SA98] <author> Raymie Stata and Martn Abadi. </author> <title> A type system for java bytecode subroutines. </title> <booktitle> In Twenty-Fifth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: However, Reynolds was primarily concerned with using functors to express an intermediate language of a semantics-based compiler for Algol, whereas we are primarily concerned with type structure for general-purpose target languages. Stata and Abadi <ref> [SA98] </ref> formalize the Java bytecode verifier's treatment of subroutines by giving a type system for a subset of the Java Virtual Machine language.
Reference: [Ste78] <author> Guy L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference-contexts: Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight co-routine threads when continuations are heap allocated <ref> [App92, Ste78, KKR + 86, Wan80] </ref>. Second, Appel and Shao have shown that heap-allocation of closures can have better space properties, primarily because it is easier to share environments [AS93].
Reference: [TT94] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementation of the typed call-by-value -calculus using a stack of regions. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Consequently, procedure call must be added as a primitive construct. In contrast, our treatment supports polymorphic stack recursion, and hence procedure calls can be encoded with existing assembly-language primitives. Tofte and others <ref> [BTV96, TT94] </ref> have developed an allocation strategy involving regions. Regions are lexically scoped containers that have a LIFO ordering on their lifetimes, much like the values on a stack. As in our approach, polymorphic recursion of abstracted region variables plays a critical role.
Reference: [Wan80] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Proceedings of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <month> August </month> <year> 1980. </year> <month> 15 </month>
Reference-contexts: Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight co-routine threads when continuations are heap allocated <ref> [App92, Ste78, KKR + 86, Wan80] </ref>. Second, Appel and Shao have shown that heap-allocation of closures can have better space properties, primarily because it is easier to share environments [AS93].
References-found: 21

