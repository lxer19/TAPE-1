URL: ftp://theory.lcs.mit.edu/pub/people/oded/gln.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/complexity.html
Root-URL: 
Email: Email: oded@wisdom.weizmann.ac.il.  Email: lnd@bu-cs.bu.ac.il.  Email: noam@cs.huji.ac.il.  
Title: On Constructing 1-1 One-Way Functions  
Author: Oded Goldreich Leonid A Levin Noam Nisan 
Note: Research was supported in part by grant No. 92-00226 from the United States Israel Binational Science Foundation (BSF), Jerusalem, Israel.  
Address: Rehovot, Israel.  Boston, USA.  Jerusalem, Israel.  
Affiliation: Department of Applied Mathematics and Computer Science, Weizmann Institute of Science,  Computer Science Department, Boston University,  Institute for Computer Science, Hebrew University,  
Date: June 12, 1995  
Abstract: We show how to construct length-preserving 1-1 one-way functions based on popular intractability assumptions (e.g., RSA, DLP). Such 1-1 functions should not be confused with (infinite) families of (finite) one-way permutations. What we want and obtain is a single (infinite) 1-1 one-way function. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Bach, </author> <title> Analytic Methods in the Analysis and Design of Number-Theoretic Algorithms (ACM Distinguished Dissertation 1984), </title> <publisher> MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1985. </year>
Reference-contexts: Preliminaries: selecting prime numbers Prime numbers play a key role in all our constructions and so efficient algorithms for selecting such numbers are of key importance to us. We will use two algorithms due to Bach <ref> [1, 2] </ref>. The first algorithm [2] is merely a very efficient (problem-specific) "deterministic amplification" of the 5 Miller-Rabin primality tester [9, 13]. The second algorithm [1] produces uniformly distributed integers together with their prime factorization. <p> We will use two algorithms due to Bach [1, 2]. The first algorithm [2] is merely a very efficient (problem-specific) "deterministic amplification" of the 5 Miller-Rabin primality tester [9, 13]. The second algorithm <ref> [1] </ref> produces uniformly distributed integers together with their prime factorization. <p> probabilistic polynomial time algorithm that on input P uses jP j random bits so that if P is prime then the algorithm always accepts, and otherwise (i.e., P is composite) the algorithm accepts with probability at most 1 p Theorem 2 (space efficient generation of integers with known prime factorization <ref> [1] </ref>): There exists a probabilistic polynomial time algorithm that uses linear space and on input 1 n uniformly generates a number N in the interval [2 n1 ; 2 n 1] and outputs the prime factorization of N . The above two algorithms are reasonablly efficient. <p> We have postponed the discussion of how to randomly generate primes P with known factorization of (P ). Here, a different algorithm of Bach comes to the rescue. This algorithm, uniformly generates composites with their factorization <ref> [1] </ref>. Having produced a factored composite N , we test N + 1 for primality and are done if the answer is in the affirmative.
Reference: [2] <author> E. Bach, </author> <title> "Realistic Analysis of some Randomized Algorithms", </title> <booktitle> 19th STOC, </booktitle> <year> 1987, </year> <pages> pp. 453-461. </pages>
Reference-contexts: Preliminaries: selecting prime numbers Prime numbers play a key role in all our constructions and so efficient algorithms for selecting such numbers are of key importance to us. We will use two algorithms due to Bach <ref> [1, 2] </ref>. The first algorithm [2] is merely a very efficient (problem-specific) "deterministic amplification" of the 5 Miller-Rabin primality tester [9, 13]. The second algorithm [1] produces uniformly distributed integers together with their prime factorization. <p> Preliminaries: selecting prime numbers Prime numbers play a key role in all our constructions and so efficient algorithms for selecting such numbers are of key importance to us. We will use two algorithms due to Bach [1, 2]. The first algorithm <ref> [2] </ref> is merely a very efficient (problem-specific) "deterministic amplification" of the 5 Miller-Rabin primality tester [9, 13]. The second algorithm [1] produces uniformly distributed integers together with their prime factorization. Theorem 1 (randonmess efficient primality tester [2]): There exists a probabilistic polynomial time algorithm that on input P uses jP j <p> We will use two algorithms due to Bach [1, 2]. The first algorithm <ref> [2] </ref> is merely a very efficient (problem-specific) "deterministic amplification" of the 5 Miller-Rabin primality tester [9, 13]. The second algorithm [1] produces uniformly distributed integers together with their prime factorization. Theorem 1 (randonmess efficient primality tester [2]): There exists a probabilistic polynomial time algorithm that on input P uses jP j random bits so that if P is prime then the algorithm always accepts, and otherwise (i.e., P is composite) the algorithm accepts with probability at most 1 p Theorem 2 (space efficient generation of integers with
Reference: [3] <author> M. Blum and S. Micali, </author> <title> "How to Generate Cryptographically Strong Sequences of PseudoRandom Bits", </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 13, </volume> <year> 1984, </year> <pages> pp. 850-864. </pages>
Reference-contexts: 1 Introduction Given any one-way permutation (i.e., a length preserving 1-1 one-way function), one can easily construct an efficient pseudorandom generator. The construction follows the scheme given by Blum and Micali <ref> [3] </ref>, using the fact that every one-way function has a hard-core bit [5].
Reference: [4] <author> O. Goldreich, R. Impagliazzo, L. Levin, R. Venkatesan and D. Zuckerman, </author> <title> "Security Preserving Amplification of Hardness", </title> <booktitle> 31st FOCS, </booktitle> <year> 1990, </year> <pages> pp. 318-326. </pages>
Reference-contexts: To get a (strongly) one-way function, one may apply the transformation in <ref> [4] </ref> to the function f . (In fact, degenerate versions of the transformation in [4] suffice for this purpose.) The above construction is stated with respect to the simplified definition of a family of one-way permutations. <p> To get a (strongly) one-way function, one may apply the transformation in <ref> [4] </ref> to the function f . (In fact, degenerate versions of the transformation in [4] suffice for this purpose.) The above construction is stated with respect to the simplified definition of a family of one-way permutations. <p> It is particularly desirable to keep q (n) linear in l (n). All the constructions presented below achieve this goal. Consequently, the one-way functions constructed below preserve the security of the intractability assumption on which they are based. We remark that the (weak to strong one-way) transformation of <ref> [4] </ref> (mentioned in the Remark above) preserves security too. Preliminaries: selecting prime numbers Prime numbers play a key role in all our constructions and so efficient algorithms for selecting such numbers are of key importance to us. We will use two algorithms due to Bach [1, 2]. <p> Thus, most of the paper is dedicated to the implementation of Step (1), whereas Step (2) is obtained by Construction 1 and Step (3) is obtained by referring to <ref> [4] </ref>. Regarding Step (3), we remark that applying the general ("weak to strong") transformation of [4] seems an over-kill since in our case the weakly one-way function f has a special structure (e.g., it is hard to invert almost on all points on which it is not the identity transformation). <p> Thus, most of the paper is dedicated to the implementation of Step (1), whereas Step (2) is obtained by Construction 1 and Step (3) is obtained by referring to <ref> [4] </ref>. Regarding Step (3), we remark that applying the general ("weak to strong") transformation of [4] seems an over-kill since in our case the weakly one-way function f has a special structure (e.g., it is hard to invert almost on all points on which it is not the identity transformation). <p> Furthermore, it seems that ad-hoc methods may be applicable to the function f resulting from a specific transformation. However, in our attempts to avoid using <ref> [4] </ref>, we were not able to avoid using random walks on expander graphs (and since expander graphs are the only non-elementary component of [4] we see no point in presenting these alternatives here). <p> Furthermore, it seems that ad-hoc methods may be applicable to the function f resulting from a specific transformation. However, in our attempts to avoid using <ref> [4] </ref>, we were not able to avoid using random walks on expander graphs (and since expander graphs are the only non-elementary component of [4] we see no point in presenting these alternatives here). Certainly, it will be better to the use of expander graphs and perform Step (3) in a more efficient manner. Another obvious open problem is to construct one-way 1-1 functions based on the intractability of factoring.
Reference: [5] <author> O. Goldreich and L. Levin, </author> <title> "A Hard-Core Predicate for any One-way Function", </title> <booktitle> 21st STOC, </booktitle> <year> 1989, </year> <pages> pp. 25-32. </pages>
Reference-contexts: 1 Introduction Given any one-way permutation (i.e., a length preserving 1-1 one-way function), one can easily construct an efficient pseudorandom generator. The construction follows the scheme given by Blum and Micali [3], using the fact that every one-way function has a hard-core bit <ref> [5] </ref>.
Reference: [6] <author> O. Goldreich, H. Krawczyk and M. Luby, </author> <title> "On the Existence of Pseudorandom Generators", </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 22, </volume> <year> 1993, </year> <pages> pp. 1163-1175. </pages>
Reference-contexts: In fact, it is of no practical value. The construction in <ref> [6] </ref>, which uses arbitrary regular one-way functions is more attractive in these respects, yet it is far less attractive than the simple construction outlined above. A similar situation occurs with respect to the construction of digital signature schemes (cf., [10] vs [15]).
Reference: [7] <author> S. Goldwasser and J. Kilian, </author> <title> "Almost all primes can be quickly certified", </title> <booktitle> 18th STOC, </booktitle> <year> 1986, </year> <pages> pp. 316-329. </pages>
Reference-contexts: The above two algorithms are reasonablly efficient. We are reluctant to use the primality certifier of Goldwasser and Kilian which for all but a negligible fraction of the primes finds in probabilistic polynomial-time a certificate of primality <ref> [7] </ref>. Interestingly, this algorithm can be implemented within linear space and so applying the transforamtion of Nisan and Zuckerman [11] we get an implementation which uses linear randomness. <p> Interestingly, this algorithm can be implemented within linear space and so applying the transforamtion of Nisan and Zuckerman [11] we get an implementation which uses linear randomness. Theorem 3 (randonmess efficient primality certifier <ref> [7, 11] </ref>): There exists a probabilistic polynomial time algorithm that on input P uses O (jP j) random bits and for all but a negligible fraction of the primes finds a certificate of primality (i.e., a witness/proof with respect to some NP-relation). 4.1 A construction based on RSA The standard presentation
Reference: [8] <author> J. H-astad, R. Impagliazzo, L. Levin and M. Luby, </author> <title> "Construction of a pseudo-random generator from any one-way function", </title> <type> ICSI Technical Report, </type> <note> No. 91-068, submitted to SICOMP. Combines papers of Impagliazzo, Levin and Luby (21st STOC, 1989, pp. 12-24) and J. H-astad, (22nd STOC, </note> <year> 1990, </year> <pages> pp. 395-404). </pages>
Reference-contexts: Then, the pseudorandom generator G, on input a seed s outputs the sequence b (s); b (f (s)); b (f (f (s))); b (f 3 (s)); ::: Pseudorandom generators can be constructed also based on arbitrary one-way functions <ref> [8] </ref>; yet, the known construction is very complex and inefficient. In fact, it is of no practical value. The construction in [6], which uses arbitrary regular one-way functions is more attractive in these respects, yet it is far less attractive than the simple construction outlined above.
Reference: [9] <author> G.L. Miller, </author> <title> "Riemann's Hypothesis and tests for primality", </title> <journal> JCSS, </journal> <volume> Vol. 13, </volume> <pages> pp. 300-317, </pages> <year> 1976. </year>
Reference-contexts: We will use two algorithms due to Bach [1, 2]. The first algorithm [2] is merely a very efficient (problem-specific) "deterministic amplification" of the 5 Miller-Rabin primality tester <ref> [9, 13] </ref>. The second algorithm [1] produces uniformly distributed integers together with their prime factorization.
Reference: [10] <author> M. Naor and M. Yung, </author> <title> "Universal Hash Functions and their Cryptographic Applications", </title> <booktitle> 21st STOC, </booktitle> <year> 1989, </year> <pages> pp. 33-43. </pages>
Reference-contexts: The construction in [6], which uses arbitrary regular one-way functions is more attractive in these respects, yet it is far less attractive than the simple construction outlined above. A similar situation occurs with respect to the construction of digital signature schemes (cf., <ref> [10] </ref> vs [15]). In general, 1-1 one-way functions currently offer simpler and more practical constructions (of more complex primitives) than offered by general one-way functions. These facts were our initial motivation for trying to construct length-preserving 1-1 one-way functions.
Reference: [11] <author> N. Nisan and D. Zuckerman, </author> <title> "More Deterministic Simulation in LOGSPACE", </title> <booktitle> 25th STOC, </booktitle> <year> 1993, </year> <pages> pp. 235-244. </pages>
Reference-contexts: We are reluctant to use the primality certifier of Goldwasser and Kilian which for all but a negligible fraction of the primes finds in probabilistic polynomial-time a certificate of primality [7]. Interestingly, this algorithm can be implemented within linear space and so applying the transforamtion of Nisan and Zuckerman <ref> [11] </ref> we get an implementation which uses linear randomness. <p> Interestingly, this algorithm can be implemented within linear space and so applying the transforamtion of Nisan and Zuckerman [11] we get an implementation which uses linear randomness. Theorem 3 (randonmess efficient primality certifier <ref> [7, 11] </ref>): There exists a probabilistic polynomial time algorithm that on input P uses O (jP j) random bits and for all but a negligible fraction of the primes finds a certificate of primality (i.e., a witness/proof with respect to some NP-relation). 4.1 A construction based on RSA The standard presentation <p> Yet, it is possible to implement an approximation of the algorithm using only a linear number of coin tosses (i.e., linear in the length of the composite being generated). The details are quite tedious. Instead, we prefer to invoke a general result of Nisan and Zuckerman <ref> [11] </ref> by which any probabilistic polynomial-time algorithm, which uses linear space, can be approximated using a linear number of coin tosses. It is very easy to see that Bach's algorithm falls into this category (and this is stated in Theorem 2 above).
Reference: [12] <author> M.O. Rabin, </author> <title> "Digitalized Signatures and Public Key Functions as Intractable as Factoring", </title> <address> MIT/LCS/TR-212, </address> <year> 1979. </year>
Reference-contexts: To achieve this goal using our method one will need to construct a family of one-way permutations satisfying the additional properties specified in Definition 3. (The standard construction of a family of one-way permutations based on factoring <ref> [12] </ref> does not satisfy the augmented one-wayness condition.) Acknowledgments We would like to thank Eric Bach and Hugo Krawczyk for helpful discussions and comments. 9
Reference: [13] <author> M.O. Rabin, </author> <title> "Probabilistic algorithm for testing primality", </title> <journal> Jour. of Number Theory, </journal> <volume> Vol. 12, </volume> <pages> pp. 128-138, </pages> <year> 1980. </year>
Reference-contexts: We will use two algorithms due to Bach [1, 2]. The first algorithm [2] is merely a very efficient (problem-specific) "deterministic amplification" of the 5 Miller-Rabin primality tester <ref> [9, 13] </ref>. The second algorithm [1] produces uniformly distributed integers together with their prime factorization.
Reference: [14] <author> R. Rivest, A. Shamir, and L. Adleman, </author> <title> "A Method for Obtaining Digital Signatures and Public Key Cryptosystems", </title> <journal> CACM, </journal> <volume> Vol. 21, </volume> <month> Feb. </month> <year> 1978, </year> <pages> pp. 120-126. </pages>
Reference-contexts: exists a probabilistic polynomial time algorithm that on input P uses O (jP j) random bits and for all but a negligible fraction of the primes finds a certificate of primality (i.e., a witness/proof with respect to some NP-relation). 4.1 A construction based on RSA The standard presentation of RSA <ref> [14] </ref> yields a family of permutations which is believed to be one-way, but is certainly not one-way in the augmented sense of Definition 3. (Here we refer to a family in which the indices are pairs (N; e), where N is the product of two primes of equal length and e
Reference: [15] <author> J. Rompel, </author> <title> "One-way Functions are Necessary and Sufficient for Secure Signatures", </title> <booktitle> 22nd STOC, </booktitle> <year> 1990, </year> <pages> pp. 387-394. </pages>
Reference-contexts: The construction in [6], which uses arbitrary regular one-way functions is more attractive in these respects, yet it is far less attractive than the simple construction outlined above. A similar situation occurs with respect to the construction of digital signature schemes (cf., [10] vs <ref> [15] </ref>). In general, 1-1 one-way functions currently offer simpler and more practical constructions (of more complex primitives) than offered by general one-way functions. These facts were our initial motivation for trying to construct length-preserving 1-1 one-way functions.
Reference: [16] <author> R. Solovay and V. Strassen, </author> <title> "A fast Monte-Carlo test for primality", </title> <journal> SIAM Jour. on Computing, </journal> <volume> Vol. 6, </volume> <pages> pp. 84-85, </pages> <year> 1977. </year> <month> 10 </month>
References-found: 16

