URL: ftp://ftp.csd.uu.se/pub/papers/reports/0125.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Multiple metareasoning agents for flexible query-answering systems  
Author: Jonas Barklund, Stefania Costantini Pierangelo Dell'Acqua and Gaetano A. Lanzarone 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Uppsala University Computing Science Department  Dipartimento di Scienze dell'Informazione, Universita degli Studi di Milano  
Abstract: UPMAIL Technical Report No. 125 2 May, 1996 ISSN 1100-0686 Abstract We show through a number of examples how it is possible to express beliefs of agents and communication among agents by employing a first-order logic language with metalogical facilities. We argue that (i) such a language is suitable to characterise rational agents in different application areas, and (ii) the interplay between metalogical reasoning and different modalities of communications allows us to obtain systems with a high degree of flexibility. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Barklund, S. Costantini, P. Dell'Acqua, and G. A. Lanzarone. </author> <title> SLD-resolution with reflection. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Logic Programming | Proc. 1994 Intl. Symp., </booktitle> <pages> pages 554-568, </pages> <address> Cambridge, Mass., 1994. </address> <publisher> MIT Press. </publisher>
Reference-contexts: We can say that the language takes the naming mechanism as a "parameter''. In the following, the name of an expression A is conventionally indicated with 0 A. (For sake of simplicity we use a different notation from <ref> [1, 2] </ref>.) If, for instance, we want to express properties (i.e., metaknowledge) of an expression of the object-language (i.e., knowledge) such as p (a; X), we have to employ a name of that expression, represented here as 0 p ( 0 a; 0 X), where 0 X stands for the name
Reference: [2] <author> J. Barklund, S. Costantini, P. Dell'Acqua, and G. A. Lanzarone. </author> <title> Se-mantical properties of encodings in logic programming. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Logic Programming | Proc. 1995 Intl. Symp., </booktitle> <pages> pages 288-302, </pages> <address> Cambridge, Mass., 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: We can say that the language takes the naming mechanism as a "parameter''. In the following, the name of an expression A is conventionally indicated with 0 A. (For sake of simplicity we use a different notation from <ref> [1, 2] </ref>.) If, for instance, we want to express properties (i.e., metaknowledge) of an expression of the object-language (i.e., knowledge) such as p (a; X), we have to employ a name of that expression, represented here as 0 p ( 0 a; 0 X), where 0 X stands for the name
Reference: [3] <author> Jonas Barklund, Katrin Boberg, and Pierangelo Dell'Acqua. </author> <title> A basis for a multilevel metalogic programming language. </title> <editor> In Laurent Fribourg and Franco Turini, editors, </editor> <title> Logic Program Synthesis and Transformation | Meta-Programming in Logic, </title> <publisher> LNCS 883, </publisher> <pages> pages 262-275, </pages> <address> Berlin, 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: By incorporating metalevel reasoning, we obtain query-answering systems that behave more rationally and flexibly towards users. 2 Logic languages with metalogical extensions The examples in this paper are written in two similar extensions of Horn clause logic. The example of Section 5 is expressed in Alloy <ref> [3, 4] </ref>, a language designed for specifying systems of interrelated theories. The examples of Sections 3 and 4 are written in Reflective Prolog [6, 7].
Reference: [4] <author> Jonas Barklund, Katrin Boberg, Pierangelo Dell'Acqua, and Margus Veanes. </author> <title> Meta-programming with theory systems. </title> <editor> In Krzysztof Apt and Franco Turini, editors, </editor> <booktitle> Meta-logics and Logic Programming, </booktitle> <pages> pages 195-226. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1995. </year>
Reference-contexts: By incorporating metalevel reasoning, we obtain query-answering systems that behave more rationally and flexibly towards users. 2 Logic languages with metalogical extensions The examples in this paper are written in two similar extensions of Horn clause logic. The example of Section 5 is expressed in Alloy <ref> [3, 4] </ref>, a language designed for specifying systems of interrelated theories. The examples of Sections 3 and 4 are written in Reflective Prolog [6, 7]. <p> It means that the variable is not part of the represented formula but rather part of the representation, which is then nonground. It is only meaningful to substitute a name term for such a variable. An inference system (although not the most efficient conceivable) for Alloy is given elsewhere <ref> [4] </ref>. An Alloy program specifies a theory or a collection of theories that typically will be (or can be thought of as) the beliefs of one of more agents.
Reference: [5] <author> Stefania Costantini, Pierangelo Dell'Acqua, and Gaetano A. Lanzarone. </author> <title> Reflective agents in metalogic programming. </title> <editor> In Alberto Pettorossi, editor, </editor> <booktitle> Meta-Programming in Logic, </booktitle> <volume> LNCS 649, </volume> <pages> pages 135-147, </pages> <address> Berlin, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In the context of communication-based reasoning, the interaction among agents is based on communication acts. In particular, every agent can ask other agents questions in order to solve a given problem. Within the logic programming paradigm, an approach to communication-based reasoning has been proposed by Costantini et al. <ref> [5] </ref>. The main idea of that approach is to represent agents and communication acts by means of theories and reflection principles, respectively. Thus, theories formalize knowledge of agents, while reflection principles characterize possible kinds of interaction among agents. <p> These modalities can vary with respect to different agents or different conditions as the following examples show. (More elaborate examples of the use of agents in Reflective Prolog can be found in <ref> [5] </ref>.) * An agent A tells an agent B a thing it can prove and lies to an agent C.
Reference: [6] <author> Stefania Costantini and Gaetano A. Lanzarone. </author> <title> A metalogic programming language. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. 6th Intl. Conf. on Logic Programming, </booktitle> <pages> pages 218-33, </pages> <address> Cambridge, Mass., 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The example of Section 5 is expressed in Alloy [3, 4], a language designed for specifying systems of interrelated theories. The examples of Sections 3 and 4 are written in Reflective Prolog <ref> [6, 7] </ref>. <p> Instead, by using a metaevaluation clause we can formalise our statement as solve (P ( 0 a)) belongs to (P; class) where P is a metavariable ranging over the names of predicate symbols. Last, a form of logic reflection which makes this extensions effective both semantically and procedurally <ref> [6] </ref>. Semantically, this has been achieved by introducing the notion of reflective models. They are models in usual sense but satisfy an additional requirement that an atom A belongs to the model if and only if the atom solve ( 0 A) belongs to the model.
Reference: [7] <author> Stefania Costantini and Gaetano A. Lanzarone. </author> <title> A metalogical programming approach: Language, semantics and applications. </title> <journal> J. Exper. Theor. Artificial Intelligence, </journal> <volume> 6, </volume> <year> 1994. </year> <month> 11 </month>
Reference-contexts: The example of Section 5 is expressed in Alloy [3, 4], a language designed for specifying systems of interrelated theories. The examples of Sections 3 and 4 are written in Reflective Prolog <ref> [6, 7] </ref>.
References-found: 7

