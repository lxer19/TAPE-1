URL: ftp://grandteton.cs.uiuc.edu/pub/augmint/thesis.ps
Refering-URL: http://iacoma.cs.uiuc.edu/iacoma/augmint.html
Root-URL: http://www.cs.uiuc.edu
Title: c  
Author: flCopyright by Arun Sharma 
Date: 1996  
Abstract-found: 0
Intro-found: 1
Reference: [BDCW91] <author> E. A. Brewer, C. N. Dellarocas, A. Colbrook, and W. E. Weihl. PROTEUS: </author> <title> A HIGH-PERFORMANCE PARALLEL-ARCHITECTURE SIMULATOR. </title> <type> Technical Report MIT/LCS/TR-516, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Instructions with memory references are interpreted in software. A more common approach is to augment the code, that is, to insert additional instructions at the memory reference points to drive the simulator. This approach has been used in Proteus <ref> [BDCW91] </ref>, Tangolite [Gol93] and Augmint. 2.2 Binary Vs Assembly language instrumentation Such instrumentation can be done both at the executable level and the assembly level. Each method has its advantages and disadvantages. <p> Currently, a lot of time is spent on updating the simulated clock, which is represented as a double. Such an update is done at the end of each basic block and before entering the simulator thread. A possible optimization, discussed in the Proteus <ref> [BDCW91] </ref> user's guide, is to merge basic blocks together into bigger basic blocks wherever possible. Further, depending on the length of simulation time, the user may choose to use a smaller data type for the clock, to improve the simulation speed.
Reference: [GH92] <author> Stephen R. Goldschmidt and John L. Hennessy. </author> <title> THE ACCURACY OF TRACE-DRIVEN SIMULATIONS OF MULTIPROCESSORS. </title> <type> Technical Report STAN//CSL-TR-92-546, </type> <institution> Stanford University, Computer Systems Laboratory, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: Moreover, a simulator is also expected to be non-interfering, in order to get highly accurate results. By spending a lot of time in simulating the system, in a great level of detail, the timing accuracy of the simulator is compromised. Goldschmidt and Hennessy <ref> [GH92] </ref> deal with these issues at length. Augmint deviates from the past work mainly in shifting the focus to CISC architectures. Most of the increased complexity was in writing the augmenter Doctor which now recognizes the complex and even implicit memory references in the Intel x86 assembly code.
Reference: [Gol93] <author> S. Goldschmidt. </author> <title> Simulation of Multiprocessors: Accuracy and Performance. </title> <type> Ph.D. Thesis, </type> <institution> Stanford University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Instructions with memory references are interpreted in software. A more common approach is to augment the code, that is, to insert additional instructions at the memory reference points to drive the simulator. This approach has been used in Proteus [BDCW91], Tangolite <ref> [Gol93] </ref> and Augmint. 2.2 Binary Vs Assembly language instrumentation Such instrumentation can be done both at the executable level and the assembly level. Each method has its advantages and disadvantages. <p> A more realisitic simulator would model the virtual to physical address translations and the cache interference caused by the operating system. Augmint combines the good features of both MINT [Vee93](good backend interface) and Tangolite <ref> [Gol93] </ref> (flexible and portable front end) and provides a software simulation environment that is fast, flexible and accurate. 1 Solaris is a trademark of Sun Microsystems. 2 Windows NT is a trademark of Microsoft Corporation. 23 Appendix A Command line parameters executable_name [front-end options] [-- simulator options] [-- application options] front-end
Reference: [Lea87] <editor> Lusk and Overbeek et al. </editor> <title> Portable Programs for Parallel Processors. Hild, </title> <publisher> Rinehart and Winston, Inc., </publisher> <year> 1987. </year>
Reference-contexts: gcc -lm -g /home/arsharma/augmint/lib/mintd.o /home/arsharma/augmint/lib/macrosd.o -lm -L/home/arsharma/augmint/lib -L/lib -ldsim fft.o -o fftd The executable fftd (the debug version) when executed, completes the simulation. 11 Chapter 4 The Front End 4.1 Programming model In Augmint, programs for shared memory multiprocessors are written using the m4 macros developed at Argonne Nation Laboratory <ref> [Lea87] </ref>. This macro package provides machine-independent memory allocation, process creation and synchronization primitives.
Reference: [LS95] <author> James R. Larus and Eric Schnarr. Eel: </author> <title> Machine-independent executable editing. </title> <booktitle> In SIGPLAN '95 Conference on Programming Languages Design and Impelementation (PLDI), </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: On the other hand, instrumenting the executable, as has been done in the case of EEL <ref> [LS95] </ref> on the other hand does not suffer from this disadvantage. However, it needs a recomputation of the jump targets and labels. 2.3 Trace driven Vs Execution driven Further, the simulation can be trace driven or event driven.
Reference: [Mas92] <author> Henry Massalin. </author> <title> Synthesis: An efficient implementation of fundamental operating system services. </title> <type> Technical Report CUCS-039-92, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: However, this approach is widely used to validate the architecture at a very low level. However, some simulators like MINT [Vee93] have taken a hybrid approach. MINT synthesizes <ref> [Mas92] </ref> a function out of each block of code without branches or memory references. This function loads the target processor state into the registers, executes the code natively and stores any modified registers back into the memory. Instructions with memory references are interpreted in software.
Reference: [pen] <institution> Pentium processor manual. </institution>
Reference-contexts: These instructions, however, do not occur very frequently in the assembly code. Therefore the simulation is quite accurate. 2 The default values have been taken from the Pentium processor manual <ref> [pen] </ref> 3 Stack references are not augmented. 17 5.5 Improvements There are several possible optimizations to improve the performance of the simulator further. Currently, a lot of time is spent on updating the simulated clock, which is represented as a double.
Reference: [SRH + 93] <author> Steven, K. Reinhardt, Mark D. Hill, James R. Larus, Alvin R. Lebeck, James C. Lewis, and David A. Wood. </author> <title> The wisconsin wind tunnel: Virtual prototyping of parallel computers. </title> <booktitle> In ACM Sigmetrics Conference on Mesurement and Modeling of Computer Systems, </booktitle> <pages> pages 48-60, </pages> <month> March </month> <year> 1993. </year> <month> 30 </month>
Reference-contexts: The main idea here is to gain time by avoiding code instrumentation and interpretation, by executing uninstrumented code. Traps are set on memory locations by making use of error correction codes and the simulator takes control only during the traps. This approach has been used in WWT <ref> [SRH + 93] </ref> and Tapeworm [UNMS94]. The advantage of trap driven simulation is that memory reference events, that do not miss in the simulated memory hierarchy do not have any simulation overheads. As a result, the simulation is faster.
Reference: [UNMS94] <author> Richard Uhlig, David Nagle, Trevor Mudge, and Stuart Sechrest. </author> <title> Trap-driven sim-ulation with Tapeworm II. </title> <booktitle> In ASPLOS-VI, </booktitle> <pages> pages 132-144, </pages> <address> San Jose, California, </address> <year> 1994. </year>
Reference-contexts: Traps are set on memory locations by making use of error correction codes and the simulator takes control only during the traps. This approach has been used in WWT [SRH + 93] and Tapeworm <ref> [UNMS94] </ref>. The advantage of trap driven simulation is that memory reference events, that do not miss in the simulated memory hierarchy do not have any simulation overheads. As a result, the simulation is faster.
Reference: [Vee93] <author> Jack E. Veenstra. </author> <title> Mint tutorial and user manual. </title> <type> Technical Report TR 452, </type> <institution> University of Rochester, Computer Science Department, </institution> <month> May </month> <year> 1993. </year> <month> 31 </month>
Reference-contexts: This approach, in general is very slow, since interpreting one machine instruction takes 10 to 100 times more time than executing it natively. However, this approach is widely used to validate the architecture at a very low level. However, some simulators like MINT <ref> [Vee93] </ref> have taken a hybrid approach. MINT synthesizes [Mas92] a function out of each block of code without branches or memory references. This function loads the target processor state into the registers, executes the code natively and stores any modified registers back into the memory. <p> * Doctor, the augmenter, which takes as input an x86 assembly language file, inserts additional code at basic block beginnings and at memory reference points to drive the simulator and outputs an augmented assembly language file. * The threads package: Large parts of the threads package from its predecessor MINT <ref> [Vee93] </ref> remain unchanged. The most significant changes are due to, changing the run time object code interpretation and code synthesis to compile time assembly language instrumentation. * The user interface: The simulator can be roughly divided into a front end and a back end. <p> The front end simulates the execution of multiple application threads running on multiple processors in parallel and generates certain events of interest. The back end is user-defined and invoked every time a significant event occurs. This interface is exactly the same as that provided by MINT <ref> [Vee93] </ref>. 6 7 3.1 Compilation process There are several steps involved in building the executable, as shown in Figure 3.1. 1. The application source code in which parallel constructs are expressed using the m4 macros is input to a macro processor, along with the macro library c.m4.augmint. 2. <p> In both the cases, a pointer to the new task is passed, so that the user defined fields in the task structure can be filled in. The MINT <ref> [Vee93] </ref> user's guide, deals with these things in more detail. 21 Chapter 8 Performance Without adequate performance, it is impossible to simulate large programs, which is necessary to validate the architecture simulated by the backend, when used in the data movement mode.
References-found: 10

