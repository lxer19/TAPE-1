URL: http://www.cs.columbia.edu/~cdo/cw97.ps
Refering-URL: http://www.cs.columbia.edu/~cdo/papers.html
Root-URL: http://www.cs.columbia.edu
Title: Safe-for-Space Threads in Standard ML  
Author: Edoardo Biagioni Ken Cline Peter Lee Chris Okasaki Chris Stone 
Address: Pittsburgh, Pennsylvania 15213-3891  
Affiliation: Carnegie Mellon University  
Abstract: Threads can easily be implemented using first-class continuations, but the straightforward approaches for doing so lead to space leaks, especially in a language with exceptions like Standard ML. We show how these space leaks arise, and give a new implementation for threads that is safe-for-space.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Appel, A. W., and MacQueen, D. B. </author> <title> A Standard ML compiler. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, Lecture Notes in Computer Science (1987), </booktitle> <volume> vol. 274, </volume> <publisher> Springer-Verlag, </publisher> <pages> pp. 301-324. 3-13 </pages>
Reference-contexts: In this paper, we describe the contortions necessary to implement safe-for-space threads in Standard ML [9], using first-class continuations as provided by the Standard ML of New Jersey system (SML/NJ) <ref> [1] </ref>. We begin by developing a simple threads package, and then point out and fix some bizarre behavior that can be caused by exceptions. Next, we describe the two potential space leaks, and show how they can be avoided with a clever use of callcc. <p> There are also questions about what should happen if the main thread calls exit rather than returning, or even if it should be allowed to do so. We shall return to this matter in Section 4. 3 A First Implementation We use first-class continuations as provided by SML/NJ <ref> [1] </ref>, with the built-in type 'a cont and primitive operators callcc and throw. Following the by-now standard approach, first advocated by Wand [13], we represent a thread as a continuation. type thread = unit cont A sleeping thread is activated by throwing to its continuation.
Reference: [2] <author> Biagioni, E., Harper, R., and Lee, P. </author> <title> Signatures for a protocol stack: A systems application of Standard ML. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Orlando (June 1994), </address> <pages> pp. 55-64. </pages>
Reference-contexts: In this architecture, the dth request is processed in a thread of depth d. Obviously, such a server cannot afford a space leak that grows with each new thread. Exactly this kind of architecture appears in the Fox Project's FoxNet system <ref> [2] </ref>. 6 Safe-for-Space Threads In both implementations so far, problems arise because a child thread hangs on to some of its parent's context. We can avoid these problems by arranging that every thread is executed in a top-level context rather than in its parent's context. <p> Now, a thread's exceptions may be caught by another thread even when we specifically attempt to handle the exception in the current thread. 8 Conclusions This work was motivated by a space leak discovered in the FoxNet HTTP server <ref> [2] </ref>. We have experimentally observed such leaks for many different implementations of threads, but these leaks are difficult to quantify because of the lack of adequate profiling tools.
Reference: [3] <author> Cooper, E. C., and Morrisett, J. G. </author> <title> Adding threads to Standard ML. </title> <type> Tech. Rep. Technical Report CMU-CS-90-186, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: COROUTINE = sig exception NoReadyThread val fork : (unit -&gt; unit) -&gt; unit val yield: unit -&gt; unit val exit : unit -&gt; 'a end As is well-known, threads can be implemented elegantly in a language with first-class continuations, such as Scheme [13, 7] or Standard ML extended with callcc <ref> [3, 11] </ref>. However, naive implementations are likely to suffer from two potential space leaks, one involving continuations and one involving exceptions. The space leak involving continuations can easily be optimized away by a good compiler, but the space leak involving exceptions cannot. <p> Therefore, the current thread is lost. This implementation is essentially similar to Wand's implementation of threads in Scheme [13]. Existing implementations of threads in Standard ML, such as ML-Threads <ref> [3] </ref> and CML [11, 12], differ mainly in their treatment of exceptions, as discussed in the following section. 4 The Problem With Exceptions Although appealingly simple, the above implementation exhibits bizarre behavior in the presence of exceptions. <p> In this leak, a child thread unnecessarily retains its parent's exception handlers. Unfortunately, this second leak is unlikely to be optimized away without 3-8 enormous advances in compiler technology. The fact that these implementations leak storage is surprising, because implementations like these (e.g., ML-Threads <ref> [3] </ref> and CML [11, 12]) have been in use for many years. We can only speculate that the kinds of idioms for which these space leaks prove problematic have not arisen until now, or that these leaks have been hidden by other, more obvious leaks.
Reference: [4] <author> Danvy, O., and Filinski, A. </author> <title> Abstracting control. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming (June 1990), </booktitle> <pages> pp. 151-160. </pages>
Reference-contexts: Next, we describe the two potential space leaks, and show how they can be avoided with a clever use of callcc. We then sketch some of the difficulties in achieving a comparable implementation using other control operators, such as Felleisen's control/prompt [5], Danvy and Filinski's shift/reset <ref> [4] </ref>, or Gunter, Remy, and Riecke's set/cupto [6]. Finally, we draw some conclusions. 2 A Simple Threads Package We begin by considering the simple threads interface shown in Figure 1. Three operations are specified in the signature COROUTINE: fork, yield, and exit. <p> In this section, we briefly summarize some of the difficulties one encounters 3-11 when trying to implement safe-for-space threads using a few of these alter-native control operators. First, we consider Felleisen's control/prompt [5] and Danvy and Fil-inski's shift/reset <ref> [4] </ref>. These seem like natural choices for implementing safe-for-space threads since they essentially allow one to run a thread in a top-level context, much like the threadActivator continuation does.
Reference: [5] <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1988), </year> <pages> pp. 180-190. </pages>
Reference-contexts: Next, we describe the two potential space leaks, and show how they can be avoided with a clever use of callcc. We then sketch some of the difficulties in achieving a comparable implementation using other control operators, such as Felleisen's control/prompt <ref> [5] </ref>, Danvy and Filinski's shift/reset [4], or Gunter, Remy, and Riecke's set/cupto [6]. Finally, we draw some conclusions. 2 A Simple Threads Package We begin by considering the simple threads interface shown in Figure 1. Three operations are specified in the signature COROUTINE: fork, yield, and exit. <p> In this section, we briefly summarize some of the difficulties one encounters 3-11 when trying to implement safe-for-space threads using a few of these alter-native control operators. First, we consider Felleisen's control/prompt <ref> [5] </ref> and Danvy and Fil-inski's shift/reset [4]. These seem like natural choices for implementing safe-for-space threads since they essentially allow one to run a thread in a top-level context, much like the threadActivator continuation does.
Reference: [6] <author> Gunter, C. A., R emy, D., and Riecke, J. G. </author> <title> A generalization of exceptions and control in ML-like languages. </title> <booktitle> In Proceedings of the 1995 Conference on Functional Programming Languages and Computer Architecture (June 1995), </booktitle> <pages> pp. 12-23. </pages>
Reference-contexts: We then sketch some of the difficulties in achieving a comparable implementation using other control operators, such as Felleisen's control/prompt [5], Danvy and Filinski's shift/reset [4], or Gunter, Remy, and Riecke's set/cupto <ref> [6] </ref>. Finally, we draw some conclusions. 2 A Simple Threads Package We begin by considering the simple threads interface shown in Figure 1. Three operations are specified in the signature COROUTINE: fork, yield, and exit. <p> The problem is that a prompt set by the user might mask a prompt set by the threads package, or vice versa. Gunter, Remy, and Riecke's set/cupto <ref> [6] </ref> solve this problem by allowing one to name prompts. Then, we can prevent the user from interfering with our prompt simply by hiding its name. In fact, Gunter, Remy, and Riecke present as an example an implementation of threads similar in spirit to those described in this paper. <p> It is unclear whether this leak is inherent in any implementation of these control operators, or an artifact of the particular implementation of set/cupto presented in <ref> [6] </ref>. Finally, Reppy has proposed variants of callcc and throw, called capture and escape, that do not save and restore the exception handler stack [12, page 136]. On the surface, these operators sound like they might help prevent the retention of unnecessary exception handlers.
Reference: [7] <author> Haynes, C. T., Friedman, D. P., and Wand, M. </author> <title> Obtaining corou-tines with continuations. </title> <booktitle> Computer Languages 11, </booktitle> <month> 3-4 </month> <year> (1986), </year> <pages> 143-153. </pages>
Reference-contexts: Government. 3-1 signature COROUTINE = sig exception NoReadyThread val fork : (unit -&gt; unit) -&gt; unit val yield: unit -&gt; unit val exit : unit -&gt; 'a end As is well-known, threads can be implemented elegantly in a language with first-class continuations, such as Scheme <ref> [13, 7] </ref> or Standard ML extended with callcc [3, 11]. However, naive implementations are likely to suffer from two potential space leaks, one involving continuations and one involving exceptions. The space leak involving continuations can easily be optimized away by a good compiler, but the space leak involving exceptions cannot.
Reference: [8] <author> Lee, P. </author> <title> Implementing threads in Standard ML. </title> <booktitle> In Advanced Functional Programming (Aug. 1996), vol. 1129 of LNCS, </booktitle> <pages> pp. 115-130. </pages>
Reference-contexts: Acknowledgements This paper grew from a tutorial presented at the Second International Summer School on Advanced Functional Programming Techniques in Olympia, Washington <ref> [8] </ref>. We have benefitted greatly from discussions with, and comments from, Olin Shivers, Olivier Danvy, Bob Harper, the participants of the summer school, and the referees of this workshop.
Reference: [9] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The space leak involving continuations can easily be optimized away by a good compiler, but the space leak involving exceptions cannot. In this paper, we describe the contortions necessary to implement safe-for-space threads in Standard ML <ref> [9] </ref>, using first-class continuations as provided by the Standard ML of New Jersey system (SML/NJ) [1]. We begin by developing a simple threads package, and then point out and fix some bizarre behavior that can be caused by exceptions.
Reference: [10] <author> Nelson, G., Ed. </author> <title> Systems programming with MODULA-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Principles for programming with threads can be found in any undergraduate textbook on operating-system design. An excellent source for advice is Nelson's book on Modula-3 <ref> [10] </ref>. This research was sponsored in part by the Advanced Research Projects Agency ITO under the title "The Fox Project: Advanced Languages for Systems Software," DARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050.
Reference: [11] <author> Reppy, J. H. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto (June 1991), </address> <pages> pp. 293-305. </pages>
Reference-contexts: COROUTINE = sig exception NoReadyThread val fork : (unit -&gt; unit) -&gt; unit val yield: unit -&gt; unit val exit : unit -&gt; 'a end As is well-known, threads can be implemented elegantly in a language with first-class continuations, such as Scheme [13, 7] or Standard ML extended with callcc <ref> [3, 11] </ref>. However, naive implementations are likely to suffer from two potential space leaks, one involving continuations and one involving exceptions. The space leak involving continuations can easily be optimized away by a good compiler, but the space leak involving exceptions cannot. <p> Therefore, the current thread is lost. This implementation is essentially similar to Wand's implementation of threads in Scheme [13]. Existing implementations of threads in Standard ML, such as ML-Threads [3] and CML <ref> [11, 12] </ref>, differ mainly in their treatment of exceptions, as discussed in the following section. 4 The Problem With Exceptions Although appealingly simple, the above implementation exhibits bizarre behavior in the presence of exceptions. <p> In this leak, a child thread unnecessarily retains its parent's exception handlers. Unfortunately, this second leak is unlikely to be optimized away without 3-8 enormous advances in compiler technology. The fact that these implementations leak storage is surprising, because implementations like these (e.g., ML-Threads [3] and CML <ref> [11, 12] </ref>) have been in use for many years. We can only speculate that the kinds of idioms for which these space leaks prove problematic have not arisen until now, or that these leaks have been hidden by other, more obvious leaks.
Reference: [12] <author> Reppy, J. H. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Therefore, the current thread is lost. This implementation is essentially similar to Wand's implementation of threads in Scheme [13]. Existing implementations of threads in Standard ML, such as ML-Threads [3] and CML <ref> [11, 12] </ref>, differ mainly in their treatment of exceptions, as discussed in the following section. 4 The Problem With Exceptions Although appealingly simple, the above implementation exhibits bizarre behavior in the presence of exceptions. <p> In this leak, a child thread unnecessarily retains its parent's exception handlers. Unfortunately, this second leak is unlikely to be optimized away without 3-8 enormous advances in compiler technology. The fact that these implementations leak storage is surprising, because implementations like these (e.g., ML-Threads [3] and CML <ref> [11, 12] </ref>) have been in use for many years. We can only speculate that the kinds of idioms for which these space leaks prove problematic have not arisen until now, or that these leaks have been hidden by other, more obvious leaks. <p> Finally, Reppy has proposed variants of callcc and throw, called capture and escape, that do not save and restore the exception handler stack <ref> [12, page 136] </ref>. On the surface, these operators sound like they might help prevent the retention of unnecessary exception handlers. In fact, however, just the opposite is true.
Reference: [13] <author> Wand, M. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Proceedings of the 1980 LISP Conference (Aug. </booktitle> <year> 1980), </year> <pages> pp. 19-28. 3-14 </pages>
Reference-contexts: Government. 3-1 signature COROUTINE = sig exception NoReadyThread val fork : (unit -&gt; unit) -&gt; unit val yield: unit -&gt; unit val exit : unit -&gt; 'a end As is well-known, threads can be implemented elegantly in a language with first-class continuations, such as Scheme <ref> [13, 7] </ref> or Standard ML extended with callcc [3, 11]. However, naive implementations are likely to suffer from two potential space leaks, one involving continuations and one involving exceptions. The space leak involving continuations can easily be optimized away by a good compiler, but the space leak involving exceptions cannot. <p> We shall return to this matter in Section 4. 3 A First Implementation We use first-class continuations as provided by SML/NJ [1], with the built-in type 'a cont and primitive operators callcc and throw. Following the by-now standard approach, first advocated by Wand <ref> [13] </ref>, we represent a thread as a continuation. type thread = unit cont A sleeping thread is activated by throwing to its continuation. The queue of ready processes is then easily implemented as a queue of continuations. <p> Finally, we have exit, which immediately starts the next thread. fun exit () = dispatch () Note that exit does not capture the current continuation before calling dispatch. Therefore, the current thread is lost. This implementation is essentially similar to Wand's implementation of threads in Scheme <ref> [13] </ref>. Existing implementations of threads in Standard ML, such as ML-Threads [3] and CML [11, 12], differ mainly in their treatment of exceptions, as discussed in the following section. 4 The Problem With Exceptions Although appealingly simple, the above implementation exhibits bizarre behavior in the presence of exceptions.
References-found: 13

