URL: http://www-sal.cs.uiuc.edu/~nachum/papers/temporal-final.ps.gz
Refering-URL: http://sal.cs.uiuc.edu/~nachum/papers/
Root-URL: http://www.cs.uiuc.edu
Email: nachum@cs.uiuc.edu  jayasim@cis.ohio-state.edu  
Title: Bounded Fairness  
Author: Nachum Dershowitz D. N. Jayasimha 
Note: 1 Research supported in part by the U. S. National Science Foundation under Grants CCR-90-07195 and CCR-90-24271 and by a Lady Davis fellowship at the  2 Research supported in part by the U. S. National Science Foundation under Grant CCR-89-09189.  
Date: February 1993  
Address: Urbana, IL 61801  Columbus, OH 43210  Jerusalem.  
Affiliation: Department of Computer Science University of Illinois  Department of Computer and Information Science The Ohio State University  Hebrew University of  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Ben-Ari. </author> <booktitle> Principles of Concurrent Programming. Prentice-Hall International, </booktitle> <year> 1982. </year>
Reference-contexts: We have investigated other concurrent algorithms for bounded fairness. Peterson's two process mutual exclusion algorithm [18] is 2-bounded fair since it permits a process executing in its trying region to be overtaken at most once. The solution to the dining philosophers problem utilizing monitors presented in Ben-Ari <ref> [1] </ref> is 1-bounded fair. 12 7 Discussion Most fairness properties involve the temporal concept "eventually." Eventuality, however, is a weak concept with which to specify and prove properties of many real-time concurrent programs. We have introduced a stronger notion of fairness called k-bounded fairness.
Reference: [2] <author> M. Ben-Ari, A. Pnueli, and Z. Manna. </author> <title> The temporal logic of branching time. </title> <journal> Acta Informatica, </journal> <volume> 20 </volume> <pages> 207-226, </pages> <year> 1983. </year>
Reference-contexts: Algorithm REMOVE of Figure 2 checks for satisfiability, using the graph produced by BUILD. It removes nodes that are unsatisfiable from the tableau. Following Ben-Ari, et al. <ref> [2] </ref>, we call a node containing only elementary or marked formulas a state. An eventuality formula is a temporal formula whose tableau decomposition yields two or more subformulas, one of which contains itself as a subformula (rules 9-16 in Table 1).
Reference: [3] <author> J. E. Burns, M. J. Fischer, P. Jackson, N. A. Lynch, and G. L. Peterson. </author> <title> Shared data requirements for implementation of mutual exclusion using a test-and-set primitive. </title> <booktitle> In Proc. of the International Conference on Parallel Processing, </booktitle> <pages> pages 79-87, </pages> <year> 1977. </year>
Reference-contexts: In the last section of the paper, we discuss some possible extensions to this research. 2 Bounded Fairness We work in the context of the concurrent processing of several asynchronous processes. To make our ideas concrete, we define fairness using the state transition model of Burns, et al. <ref> [3] </ref>. It will become obvious to the reader that bounded fairness could be defined for other abstract models of concurrent computation (for example, the model described in [5]). Our process model, then, is a set of states with a transition function.
Reference: [4] <author> E. W. Dijkstra. </author> <title> Cooperating sequential processes. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 43-112. </pages> <publisher> Academic Press, </publisher> <year> 1968. </year>
Reference-contexts: how bounded fairness requirements may be specified for standard concurrent programming situations using the k @ operator in a more natural manner than with either until or atnext [14]. (Five) Dining Philosophers Problem: We assume that the reader is familiar with the dining philosophers problem, as originally formulated by Dijkstra <ref> [4] </ref>. Suppose we do not require a strict precedence in granting forks to a philosopher according to the order of the request made, since such a requirement holds up resources (forks). <p> In this section, we show that Dekker's solution to the two process mutual exclusion problem <ref> [4, 15] </ref> is not k-bounded fair for any fixed value of k.
Reference: [5] <author> E. A. Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 996-1072. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: To make our ideas concrete, we define fairness using the state transition model of Burns, et al. [3]. It will become obvious to the reader that bounded fairness could be defined for other abstract models of concurrent computation (for example, the model described in <ref> [5] </ref>). Our process model, then, is a set of states with a transition function.
Reference: [6] <author> R. Fagin and J. H. Williams. </author> <title> A fair carpool scheduling algorithm. </title> <journal> IBM J. of Research & Development, </journal> <volume> 27(2) </volume> <pages> 133-139, </pages> <year> 1983. </year>
Reference-contexts: Such rate assumptions would make solutions more restrictive and time-dependent. In the literature, bounded fairness has been mentioned in specific contexts or en passant. For example, Fagin and Williams <ref> [6] </ref> define fairness in the context of a carpool scheduling algorithm which is intuitively similar to our idea of bounded fairness. Manna and Pnueli [16] mention "bounded overtaking" which is the same as our idea of fairness.
Reference: [7] <author> N. Francez. </author> <title> Fairness. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <month> 14 </month>
Reference-contexts: The distinguishing feature of a large class of fairness notions is eventuality, that is, fairness is defined as a restriction on some infinite behavior according to the eventual occurrence of some events <ref> [7] </ref>. Temporal logic (with the modal operators, 2 and 3 ) has been used as a tool to specify and analyze such fairness properties [19, 20].
Reference: [8] <author> D. Gabbay, A. Pnueli, S. Shelah, and J. Stavi. </author> <title> On the temporal analysis of fairness. </title> <booktitle> In Proc. Seventh Annual ACM Symp. on Prin. of Prog. Languages, </booktitle> <pages> pages 163-173, </pages> <year> 1980. </year>
Reference-contexts: Temporal logic (with the modal operators, 2 and 3 ) has been used as a tool to specify and analyze such fairness properties [19, 20]. Gabbay, et al. <ref> [8] </ref>, added the U (until ) operator to formalize aspects of responsiveness (for example, the absence of unsolicited response) and fairness (for example, strict fairness). In many applications (including real-time applications) the weak commitment of eventual occurrence may not be sufficient. <p> state the following results without proof. (Their proofs are straightforward using the mappings given in the previous section.) 3 p p 1 @ T @ @ p atnext q q 1 @ Since L ( U ) is more powerful than L ( 3 ) or L ( 2 )) <ref> [8] </ref>, we conclude from Theorem 1 that L ( k @ @ ) is more powerful than L ( 2 ).
Reference: [9] <author> H. Hansson and B. Jonsson. </author> <title> A framework for reasoning about time and reliability. </title> <booktitle> In Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pages 102-111, </pages> <year> 1989. </year>
Reference-contexts: Instead, for some systems, such as flight control and process control systems, it is required that time bounds on their behavior be met. It is then necessary to specify and reason about time explicitly. Many explicit-time logics have been proposed for such applications (see <ref> [21, 9, 17] </ref>). While eventual occurrence is a weak commitment, explicit mention of time is restrictive and undesirable in many situations.
Reference: [10] <author> C. A. R. Hoare. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <year> 1974. </year>
Reference-contexts: A process has to wait on a condition variable, say B; if it finds that it should not be granted access to a particular section of the program. Let L be the label at which a process p waits. The operations defined on B are wait and signal <ref> [10] </ref>. The assertion at x means that the control flow is at the beginning of statement x; after x means that control has just completed execution of x.
Reference: [11] <author> D. N. Jayasimha. </author> <title> Distributed synchronizers. </title> <booktitle> In Proc. 17th Intl. Conf. on Parallel Processing, </booktitle> <pages> pages 23-27., </pages> <year> 1988. </year>
Reference-contexts: Then f is satisfiable if and only if the initial node is in G. This can be proved using the techniques suggested by Smullyan [22] and Wolper [23]. 6 Applications In <ref> [11] </ref>, the second author introduced a new synchronization primitive called the Distributed Synchronizer, which is particularly suited for implementation on large shared memory multiprocessors.
Reference: [12] <author> D. N. Jayasimha and N. Dershowitz. </author> <title> Bounded fairness. CSRD Rpt. </title> <type> 615, Ctr. </type> <institution> for Supercomputing Res. and Dev., Univ. of Illinois, Urbana, IL, </institution> <year> 1986. </year>
Reference-contexts: Corollary 1 L ( k @ @ ) has the same power as L ( U ). There is some similarity between the iterated atnext operator and k @ (The two were proposed independently in [14] and <ref> [12] </ref>, respectively.) Informally, p atnext k q means, "p holds at the kth next state at which q holds" (but may hold earlier, too).
Reference: [13] <author> J. A. W. Kamp. </author> <title> Tense Logic and the Theory of Linear Order. </title> <type> PhD thesis, </type> <institution> University of California, </institution> <address> Los Angeles, CA, </address> <year> 1968. </year>
Reference-contexts: In fact, a possible sequence of computations chosen from the processes, called an admissible computation, forms a one-to-one correspondence with W . The set of all admissible computations is the interleaved model of parallel computation. 4 Expressiveness Kamp <ref> [13] </ref> has shown that L ( U ), the language with U as the only temporal connective, 1 is as expressive as the first order theory of linear order.
Reference: [14] <author> F. Kroger. </author> <title> Temporal Logic of Programs. </title> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The following two examples illustrate how bounded fairness requirements may be specified for standard concurrent programming situations using the k @ operator in a more natural manner than with either until or atnext <ref> [14] </ref>. (Five) Dining Philosophers Problem: We assume that the reader is familiar with the dining philosophers problem, as originally formulated by Dijkstra [4]. <p> Corollary 1 L ( k @ @ ) has the same power as L ( U ). There is some similarity between the iterated atnext operator and k @ (The two were proposed independently in <ref> [14] </ref> and [12], respectively.) Informally, p atnext k q means, "p holds at the kth next state at which q holds" (but may hold earlier, too).
Reference: [15] <author> Z. Manna and A. Pnueli. </author> <title> Verification of concurrent programs: The temporal framework. </title> <editor> In R. S. Boyer and J. S. Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science. </booktitle> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1981. </year>
Reference-contexts: In this section, we show that Dekker's solution to the two process mutual exclusion problem <ref> [4, 15] </ref> is not k-bounded fair for any fixed value of k.
Reference: [16] <author> Z. Manna and A. Pnueli. </author> <title> Proving temporal properties: The temporal way. </title> <booktitle> In Proc. 10th Colloq. on Automata, Languages, and Programming, </booktitle> <pages> pages 491-512, </pages> <year> 1983. </year>
Reference-contexts: In the literature, bounded fairness has been mentioned in specific contexts or en passant. For example, Fagin and Williams [6] define fairness in the context of a carpool scheduling algorithm which is intuitively similar to our idea of bounded fairness. Manna and Pnueli <ref> [16] </ref> mention "bounded overtaking" which is the same as our idea of fairness. In this paper, we provide practical motivation for using this concept, and show how a rigorous 1 temporal logic analysis can be done.
Reference: [17] <author> J. S. Ostroff. </author> <title> Temporal Logic for Real Time Systems. </title> <publisher> Research Studies Press, </publisher> <year> 1989. </year>
Reference-contexts: Instead, for some systems, such as flight control and process control systems, it is required that time bounds on their behavior be met. It is then necessary to specify and reason about time explicitly. Many explicit-time logics have been proposed for such applications (see <ref> [21, 9, 17] </ref>). While eventual occurrence is a weak commitment, explicit mention of time is restrictive and undesirable in many situations.
Reference: [18] <author> G. L. Peterson. </author> <title> Myths about the mutual exclusion problem. </title> <journal> Information Processing Letters, </journal> <volume> 12(3) </volume> <pages> 115-116, </pages> <year> 1981. </year>
Reference-contexts: In the examples that we have chosen, the bound is (2n (1 + log 2 n)) for DSP and DSV, and is unbounded for Dekker's algorithm. We have investigated other concurrent algorithms for bounded fairness. Peterson's two process mutual exclusion algorithm <ref> [18] </ref> is 2-bounded fair since it permits a process executing in its trying region to be overtaken at most once.
Reference: [19] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 19th Annual IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: Temporal logic (with the modal operators, 2 and 3 ) has been used as a tool to specify and analyze such fairness properties <ref> [19, 20] </ref>. Gabbay, et al. [8], added the U (until ) operator to formalize aspects of responsiveness (for example, the absence of unsolicited response) and fairness (for example, strict fairness). In many applications (including real-time applications) the weak commitment of eventual occurrence may not be sufficient. <p> The layout is as follows: In Section 2, we give a semi-formal description of bounded fairness through the process model and show how to specify bounded fairness requirements for standard concurrent programming problems. In Section 3, we extend linear temporal logic <ref> [19] </ref> to include a new binary operator k @ @ , which formally captures our intuitive idea of bounded fairness. The syntax and semantics for this logic, kTL, are given. In Section 4, we give some properties of kTL. <p> The usual fairness requirement expressed in linear temporal logic <ref> [19] </ref>, using the above process model, is p i 2 T i 3 (p i 2 C i ) (1) This assertion states that the process, which is currently in its trying region, eventually enters its critical region.
Reference: [20] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <booktitle> Symp. on the Semantics of Concurrent Computations, </booktitle> <pages> pages 1-20, </pages> <booktitle> 1979. </booktitle> <volume> LNCS Vol. 70, </volume> <publisher> Springer Verlag, </publisher> <address> Berlin. </address> <month> 15 </month>
Reference-contexts: Temporal logic (with the modal operators, 2 and 3 ) has been used as a tool to specify and analyze such fairness properties <ref> [19, 20] </ref>. Gabbay, et al. [8], added the U (until ) operator to formalize aspects of responsiveness (for example, the absence of unsolicited response) and fairness (for example, strict fairness). In many applications (including real-time applications) the weak commitment of eventual occurrence may not be sufficient.
Reference: [21] <author> A. Pnueli and E. Harel. </author> <title> Applications of temporal logic to the specifi-cation of real time systems. </title> <booktitle> In Symp. on Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 84-98, </pages> <booktitle> 1988. </booktitle> <volume> LNCS Vol. 331, </volume> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Instead, for some systems, such as flight control and process control systems, it is required that time bounds on their behavior be met. It is then necessary to specify and reason about time explicitly. Many explicit-time logics have been proposed for such applications (see <ref> [21, 9, 17] </ref>). While eventual occurrence is a weak commitment, explicit mention of time is restrictive and undesirable in many situations.
Reference: [22] <author> R. Smullyan. </author> <title> First Order Logic. </title> <publisher> Springer Verlag, </publisher> <year> 1971. </year>
Reference-contexts: All the same, in this section, we outline a semantic tableau method (closely related to the analytic tableau 8 method of Smullyan <ref> [22] </ref>) to obtain a decision procedure for satisfiability that has some interest in its own right. A kTL formula is elementary if it is a propositional variable, its negation, or a next time formula (one with fl as the main, "outermost" connective). Any other formula is non-elementary. <p> Theorem 3 (Satisfiability) Let G be the graph resulting from applying algorithms BUILD and REMOVE to a formula f . Then f is satisfiable if and only if the initial node is in G. This can be proved using the techniques suggested by Smullyan <ref> [22] </ref> and Wolper [23]. 6 Applications In [11], the second author introduced a new synchronization primitive called the Distributed Synchronizer, which is particularly suited for implementation on large shared memory multiprocessors.
Reference: [23] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> <volume> 56(1-2):72-98, </volume> <year> 1983. </year> <title> 16 Footnotes 1. It is implicitly understood that the language has atomic sentences and the usual non-temporal connectives. </title> <note> All languages mentioned in this paper are interpreted in Kripke structures mentioned in the previous section. 17 </note>
Reference-contexts: Theorem 3 (Satisfiability) Let G be the graph resulting from applying algorithms BUILD and REMOVE to a formula f . Then f is satisfiable if and only if the initial node is in G. This can be proved using the techniques suggested by Smullyan [22] and Wolper <ref> [23] </ref>. 6 Applications In [11], the second author introduced a new synchronization primitive called the Distributed Synchronizer, which is particularly suited for implementation on large shared memory multiprocessors.
References-found: 23

