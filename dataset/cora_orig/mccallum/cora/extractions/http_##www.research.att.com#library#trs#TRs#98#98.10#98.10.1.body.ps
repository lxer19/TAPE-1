URL: http://www.research.att.com/library/trs/TRs/98/98.10/98.10.1.body.ps
Refering-URL: http://www.research.att.com/library/trs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: jf@research.att.com  
Title: Overview of the AT&T Labs Trust-Management Project  
Author: Joan Feigenbaum 
Address: 180 Park Avenue, Room C203 Florham Park, NJ 07932-0971 USA  
Affiliation: AT&T Labs Research  
Abstract-found: 0
Intro-found: 1
Reference: 1. <institution> Information Technology Open Systems Interconnection The Directory:Authentication Framework, Recommendation X.509, </institution> <address> ISO/IEC 9594-8. </address>
Reference-contexts: of a globally known, monolithic hierarchy of "certifying authorities." 2 Discussion We will now discuss each of these decisions briefly and give some of the reasons that they are controversial. 2.1 Authorization not authentication Traditional "public-key certificates" that bind identities to public keys have received a lot of attention (e.g., <ref> [1, 2] </ref>).
Reference: 2. <author> International Telegraph and Telephone Consultative Committee (CCITT). </author> <title> The Directory Authentication Framework, Recommendation X.509 1993 update. </title>
Reference-contexts: of a globally known, monolithic hierarchy of "certifying authorities." 2 Discussion We will now discuss each of these decisions briefly and give some of the reasons that they are controversial. 2.1 Authorization not authentication Traditional "public-key certificates" that bind identities to public keys have received a lot of attention (e.g., <ref> [1, 2] </ref>).
Reference: 3. <author> M. Blaze, J. Feigenbaum, and A. Keromytis, </author> <title> The KeyNote Trust Management System, work in progress. </title> <type> Internet Draft, </type> <month> March </month> <year> 1998, </year> <note> http://www.cis.upenn.edu/~angelos/draft-angelos-spki-keynote.txt.gz. </note>
Reference-contexts: Very recently, we designed KeyNote <ref> [3] </ref> in an attempt to provide precisely enough generality and programmability to serve the trust-management needs of a Public-Key Infrastructure, if not the trust-management needs of a broader class of applications.
Reference: 4. <author> M. Blaze, J. Feigenbaum, and J. Lacy, </author> <title> Decentralized Trust Management, </title> <booktitle> in Proceedings of the Symposium on Security and Privacy, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1996, </year> <pages> pp. 164-173. </pages>
Reference-contexts: Since the Autumn of 1995, a small group at AT&T Labs has conducted a broad research project in Trust Management. Our main focus has been the design, implementation, and use of the PolicyMaker trust-management system <ref> [4, 6] </ref>. This paper presents some of the findings and open questions that our group has produced thus far. <p> same form, with two important components: a source (the keyword POLICY in one case and a string representing a credential-issuer in the other) and a program that specifies the nature of the authority that the source is conferring as well as whom or what it is conferring authority on. (See <ref> [4, 6] </ref> for details.) These can be general programs, written in any language for which a "safe" interpreter can be incorporated into the trust-management environment.
Reference: 5. <author> M. Blaze, J. Feigenbaum, P. Resnick, and M. Strauss, </author> <title> Managing Trust in an Information-Labeling System, </title> <journal> European Transactions on Telecommunications, </journal> <volume> 8 (1997), </volume> <pages> pp. 491-501. </pages> <booktitle> (Special issue of selected papers from the 1996 Amalfi Conference on Secure Communication in Networks.) </booktitle>
Reference-contexts: We have only the most straightforward response to the incomprehensibility argument: While it is certainly possible to write incomprehensible assertions using a gen-eral programming language, it is not inevitable that this will be done, and indeed we offer the examples in <ref> [5, 7, 9, 10] </ref> as evidence that programmability and comprehensibility can co-exist; in fact, we believe that users who need to express complex, real-world policies and credentials in restricted languages will be more likely to produce something incomprehensible than they would have been if given a more expressive language. <p> Other open or partially open questions include: 1. Which programming language (s) should be used for policies and credentials? 2. Application areas in which general-purpose trust-management systems have already been deployed include web-page labeling <ref> [5, 7] </ref>, signed email [10], and copyright management [9].
Reference: 6. <author> M. Blaze, J. Feigenbaum, and M. Strauss, </author> <title> Compliance-Checking in the Policy--Maker Trust Management System, </title> <booktitle> in Proceedings of the 2nd Financial Cryptography Conference, Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1998, </year> <note> to appear. Available in preprint form as AT&T Technical Report 98.3.2, http://www.research.att.com/library/trs/TRs/98/98.3/98.3.2.body.ps. </note>
Reference-contexts: Since the Autumn of 1995, a small group at AT&T Labs has conducted a broad research project in Trust Management. Our main focus has been the design, implementation, and use of the PolicyMaker trust-management system <ref> [4, 6] </ref>. This paper presents some of the findings and open questions that our group has produced thus far. <p> Having made the decision to use a general-purpose compliance checker, we still have to choose and defend a notion of "proof of compliance." A detailed definition and analysis of the proof system currently used in PolicyMaker is given in <ref> [6] </ref>. 2.3 Programmability The two kinds of PolicyMaker assertions are policies and credentials. <p> same form, with two important components: a source (the keyword POLICY in one case and a string representing a credential-issuer in the other) and a program that specifies the nature of the authority that the source is conferring as well as whom or what it is conferring authority on. (See <ref> [4, 6] </ref> for details.) These can be general programs, written in any language for which a "safe" interpreter can be incorporated into the trust-management environment.
Reference: 7. <author> Y.-H. Chu, J. Feigenbaum, B. LaMacchia, P. Resnick, and M. Strauss, REFEREE: </author> <title> Trust Management for Web Applications, World Wide Web Journal, </title> <booktitle> 2 (1997), </booktitle> <pages> pp. 127-139. </pages> <booktitle> (Reprinted from Proceedings of the 6th International World Wide Web Conference, World Wide Web Consortium, </booktitle> <address> Cambridge, </address> <year> 1997, </year> <pages> pp. 227-238.) </pages>
Reference-contexts: We have only the most straightforward response to the incomprehensibility argument: While it is certainly possible to write incomprehensible assertions using a gen-eral programming language, it is not inevitable that this will be done, and indeed we offer the examples in <ref> [5, 7, 9, 10] </ref> as evidence that programmability and comprehensibility can co-exist; in fact, we believe that users who need to express complex, real-world policies and credentials in restricted languages will be more likely to produce something incomprehensible than they would have been if given a more expressive language. <p> Other open or partially open questions include: 1. Which programming language (s) should be used for policies and credentials? 2. Application areas in which general-purpose trust-management systems have already been deployed include web-page labeling <ref> [5, 7] </ref>, signed email [10], and copyright management [9].
Reference: 8. <author> C. Ellison, </author> <title> A Simple Public-Key Infrastructure, </title> <address> http://www.clark.net/pub/cme/html/spki.html. </address>
Reference-contexts: Our response to the claim that full programmability of assertions is not necessary is that repeated attempts to design adequate, partially programmable assertions have failed. For example, the Simple Public Key Infrastructure (SPKI) proposal <ref> [8] </ref>, like PolicyMaker, supports direct authorization of public keys but rejects the notion that such authorizations should be fully programmable; over time, the original set of authorizations that could be conferred by SPKI credentials has been enlarged and changed several times, in response to what we believe are inevitable needs of
Reference: 9. <author> J. Lacy, D. P. Maher, and J. H. Snyder, </author> <title> Music on the Internet and the Intellectual Property Protection Problem, </title> <booktitle> in Proceedings of the International Symposium on Industrial Electronics, </booktitle> <publisher> IEEE Press, </publisher> <address> New York, </address> <year> 1997, </year> <pages> pp. </pages> <month> SS77-83. </month>
Reference-contexts: We have only the most straightforward response to the incomprehensibility argument: While it is certainly possible to write incomprehensible assertions using a gen-eral programming language, it is not inevitable that this will be done, and indeed we offer the examples in <ref> [5, 7, 9, 10] </ref> as evidence that programmability and comprehensibility can co-exist; in fact, we believe that users who need to express complex, real-world policies and credentials in restricted languages will be more likely to produce something incomprehensible than they would have been if given a more expressive language. <p> Other open or partially open questions include: 1. Which programming language (s) should be used for policies and credentials? 2. Application areas in which general-purpose trust-management systems have already been deployed include web-page labeling [5, 7], signed email [10], and copyright management <ref> [9] </ref>. Are these the most effective test beds for the idea of general-purpose trust management? Which other application areas should be explored? What evidence of the success or failure of the idea could the developers, users, and administrators of these applications provide? 3.
Reference: 10. <author> R. Levien, L. McCarthy, and M. </author> <title> Blaze, Transparent Internet E-mail Security, </title> <address> http://www.cs.umass.edu/~lmccarth/crypto/papers/email.ps </address>
Reference-contexts: We have only the most straightforward response to the incomprehensibility argument: While it is certainly possible to write incomprehensible assertions using a gen-eral programming language, it is not inevitable that this will be done, and indeed we offer the examples in <ref> [5, 7, 9, 10] </ref> as evidence that programmability and comprehensibility can co-exist; in fact, we believe that users who need to express complex, real-world policies and credentials in restricted languages will be more likely to produce something incomprehensible than they would have been if given a more expressive language. <p> Other open or partially open questions include: 1. Which programming language (s) should be used for policies and credentials? 2. Application areas in which general-purpose trust-management systems have already been deployed include web-page labeling [5, 7], signed email <ref> [10] </ref>, and copyright management [9]. Are these the most effective test beds for the idea of general-purpose trust management? Which other application areas should be explored? What evidence of the success or failure of the idea could the developers, users, and administrators of these applications provide? 3.
Reference: 11. <author> P. Resnick and J. Miller, PICS: </author> <title> Internet Access Controls Without Censorship, </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1996, </year> <pages> pp. 87-93. </pages>
Reference: 12. <author> R. Rivest and B. Lampson, </author> <title> SDSI: A Simple Distributed Security Infrastructure, </title> <address> http://theory.lcs.mit.edu/~rivest/sdsi11.html. </address>
Reference: 13. <author> P. Zimmermann, </author> <title> PGP User's Guide, </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1994. </year>
Reference-contexts: saying "use PolicyMaker." 2.4 Locality of control The idea that explicit, local policy should form the "trust root" for decisions about all potentially dangerous actions has provoked less controversy than our other design decisions (perhaps because this approach has already been taken in certain special cases, including the popular PGP <ref> [13] </ref>). There may eventually be considerable controversy about how to implement this decision. "Local control" sounds very good in the abstract, but it is most straightforwardly done in a way that requires considerable configuration management by administrators and users.
References-found: 13

