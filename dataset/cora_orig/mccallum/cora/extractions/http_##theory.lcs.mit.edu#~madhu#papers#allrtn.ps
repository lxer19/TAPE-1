URL: http://theory.lcs.mit.edu/~madhu/papers/allrtn.ps
Refering-URL: http://theory.lcs.mit.edu/~madhu/papers.html
Root-URL: 
Email: madhu@lcs.mit.edu  
Phone: 2 [0; 1] 1 2 4 1 2:  
Title: Decoding Reed Solomon Codes beyond the Error-Correction Diameter  k where  
Author: Madhu Sudan r 
Date: 2  
Affiliation: Laboratory for Computer Science, MIT  
Note: Appears in Proc. 35th Annual Allerton Conference on Communication, Control and Computing, 1997. (Some minor errors in the printed version have been fixed here.)  1 1  8  
Abstract: We describe a new algorithm for the decoding of Reed Solomon codes. This algorithm was originally described in [12]. While the algorithm presented in this article is the same, the presentation is somewhat different. In particular we derive more precise bounds on the performance of the algorithm and show the following: For an [n; n; (1)n] q Reed Solomon code, the algorithm in [12] corrects (*()o(1))n errors in polynomial time, where We also present the following two (hopefully) useful lower bounds on *(): 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Ar, R. Lipton, R. Rubinfeld and M. Sudan. </author> <title> Reconstructing algebraic func tions from mixed data. </title> <journal> SIAM Journal on Computing, </journal> <volume> to appear. </volume> <booktitle> Preliminary version in Proceedings of the 33rd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 503-512, </pages> <year> 1992. </year>
Reference-contexts: Our algorithm is motivated by an algorithm of Welch and Berlekamp [14, 3] which corrects b (d 1)=2c + 1 errors. In this article we describe the algorithm of Welch and Berlekamp and use it motivate our decoding algorithm. We also describe a crucial intermediate step from <ref> [1] </ref> which forms the basis of our algorithm. Our main result is summarized below and proven in Lemma 9. <p> This yields the desired conclusion immediately. 3 Decoding with algebraic curves in the plane <ref> [1, 12] </ref> A slightly different interpretation of the Welch-Berlekamp algorithm is that it finds an algebraic curve in the plane which "explains" the "data". <p> While this particular scenario attempts to explain the data by a "linear" polynomial in y there is no need to restrict the analysis to this situation. Ar et al. <ref> [1] </ref> considered such a generalization. They consider the case where the data is "explained" some algebraic curve Q of low degree in y (but not necessarily a linear polynomial in y). <p> The following lemma simplifies some of the expressions above by examining the error-correction rate *() as a function of . Lemma 9 *() = 1 1 + where = 6 6 s 1 2 7 5 : (4) *() can be lower bounded as follows: 8 2 <ref> [0; 1] </ref>; *() 1 2 + 4 1 2 (6) Remark: The bound (4) is described pictorially in Figure 1.
Reference: [2] <author> E. R. Berlekamp. </author> <title> Algebraic Coding Theory. </title> <publisher> McGraw Hill, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: As can be seen easily, this problem captures the bounded distance decoding problem for Reed Solomon codes. There is a rich history of work associated with this problem. The classical work of Berlekamp-Massey (cf. <ref> [2, 9] </ref>), corrects upto b (d 1)=2c errors. Sidelnikov [11] and Dumer [4] have constructed algorithms which correct up to b (d 1)=2c + c log n errors for any constant c [4, 11].
Reference: [3] <author> E. R. Berlekamp. </author> <title> Bounded Distance +1 Soft-Decision Reed-Solomon Decoding. </title> <journal> In IEEE Transactions on Information Theory, pages 704-720, </journal> <volume> vol. 42, no. 3, </volume> <month> May </month> <year> 1996. </year>
Reference-contexts: We give an algorithm that improves over these results when k=n is sufficiently small (i.e., less than 1=3). Our algorithm is motivated by an algorithm of Welch and Berlekamp <ref> [14, 3] </ref> which corrects b (d 1)=2c + 1 errors. In this article we describe the algorithm of Welch and Berlekamp and use it motivate our decoding algorithm. We also describe a crucial intermediate step from [1] which forms the basis of our algorithm. <p> Theorem 1 For every *, The bounded distance decoding problem with parameters n, k = n and e = *()n can be solved in polynomial time provided *() &lt; 1 1 + where = 6 6 s 1 2 7 5 : 2 Decoding with univariate rational functions <ref> [14, 3] </ref> The idea of Welch and Berlekamp [14, 3] can be informally described as follows: They describe how a "rational function" in x can be used to "explain" the "data" f (x i ; y i )g n i=1 . <p> bounded distance decoding problem with parameters n, k = n and e = *()n can be solved in polynomial time provided *() &lt; 1 1 + where = 6 6 s 1 2 7 5 : 2 Decoding with univariate rational functions <ref> [14, 3] </ref> The idea of Welch and Berlekamp [14, 3] can be informally described as follows: They describe how a "rational function" in x can be used to "explain" the "data" f (x i ; y i )g n i=1 . <p> i )g n i=1 s.t. there exists a bivariate polynomial Q satisfying: The (1; k 1) weighted degree of Q is at most D, Q 6 0 and 8i 2 [n]; Q (x i ; y i ) = 0. (1) Then the following hold: 2 Actually Berlekamp and Welch <ref> [14, 3] </ref> give a much more efficient solution for this task, but we will not describe their solution here. 3 1. A polynomial Q satisfying equation (1) can be found in polynomial time. 2.
Reference: [4] <author> I. I. Dumer. </author> <title> Two algorithms for the decoding of linear codes. </title> <journal> Problems of Information Transmission, </journal> <volume> 25(1) </volume> <pages> 24-32, </pages> <year> 1989. </year>
Reference-contexts: As can be seen easily, this problem captures the bounded distance decoding problem for Reed Solomon codes. There is a rich history of work associated with this problem. The classical work of Berlekamp-Massey (cf. [2, 9]), corrects upto b (d 1)=2c errors. Sidelnikov [11] and Dumer <ref> [4] </ref> have constructed algorithms which correct up to b (d 1)=2c + c log n errors for any constant c [4, 11]. We give an algorithm that improves over these results when k=n is sufficiently small (i.e., less than 1=3). <p> There is a rich history of work associated with this problem. The classical work of Berlekamp-Massey (cf. [2, 9]), corrects upto b (d 1)=2c errors. Sidelnikov [11] and Dumer [4] have constructed algorithms which correct up to b (d 1)=2c + c log n errors for any constant c <ref> [4, 11] </ref>. We give an algorithm that improves over these results when k=n is sufficiently small (i.e., less than 1=3). Our algorithm is motivated by an algorithm of Welch and Berlekamp [14, 3] which corrects b (d 1)=2c + 1 errors.
Reference: [5] <author> O. Goldreich, R. Rubinfeld and M. Sudan. </author> <title> Learning polynomials with queries: The highly noisy case. </title> <booktitle> Proceedings of the 36th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 294-303, </pages> <year> 1995. </year>
Reference-contexts: For instance, is there an algorithm that can decode from more errors (than (d 1)=2) when = k=n &gt; 1=3? A nice target would be a decoding algorithm that works for *() 1 p In this case we know (cf. <ref> [5, 10] </ref>) that the number of codewords within a distance of *()n is bounded by a polynomial in n. One does expect that the problem will become harder as *() ! 1 . It would be interesting to see if the problem becomes NP-hard as *() ! 1 .
Reference: [6] <author> D. Grigoriev. </author> <title> Factorization of Polynomials over a Finite Field and the Solution of Systems of Algebraic Equations. </title> <editor> Translated from Zapiski Nauchnykh Seminarov Lenningradskogo Otdeleniya Matematicheskogo Instituta im. V. A. Steklova AN SSSR, </editor> <volume> Vol. 137, </volume> <pages> pp. 20-79, </pages> <year> 1984. </year>
Reference-contexts: We simply factor the polynomial Q obtained in Part 1 above and output all p such that y p (x) divides Q. The polynomial Q can be factored in time polynomial in its degree using the algorithm of Kaltofen [7] or Grigoriev <ref> [6] </ref> (see also Kaltofen [8]).
Reference: [7] <author> E. Kaltofen. </author> <title> A Polynomial-Time Reduction from Bivariate to Univariate Integral Polynomial Factorization. </title> <booktitle> In 23rd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 57-64, </pages> <year> 1982. </year>
Reference-contexts: We simply factor the polynomial Q obtained in Part 1 above and output all p such that y p (x) divides Q. The polynomial Q can be factored in time polynomial in its degree using the algorithm of Kaltofen <ref> [7] </ref> or Grigoriev [6] (see also Kaltofen [8]).
Reference: [8] <author> E. Kaltofen. </author> <title> Polynomial factorization 1987-1991. LATIN '92, </title> <editor> I. Simon (Ed.) </editor> <publisher> Springer LNCS, v. </publisher> <pages> 583 294-313, </pages> <year> 1992. </year>
Reference-contexts: We simply factor the polynomial Q obtained in Part 1 above and output all p such that y p (x) divides Q. The polynomial Q can be factored in time polynomial in its degree using the algorithm of Kaltofen [7] or Grigoriev [6] (see also Kaltofen <ref> [8] </ref>). Proof: For Part 1, we observe as in the proof of Lemma 2 that for any i, the condition Q (x i ; y i ) = jl q jl x j y l = 0 is a linear constraint on the unknowns q jl .
Reference: [9] <author> F. J. MacWilliams and N. J. A. Sloane. </author> <title> The Theory of Error-Correcting Codes. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981. </year>
Reference-contexts: As can be seen easily, this problem captures the bounded distance decoding problem for Reed Solomon codes. There is a rich history of work associated with this problem. The classical work of Berlekamp-Massey (cf. <ref> [2, 9] </ref>), corrects upto b (d 1)=2c errors. Sidelnikov [11] and Dumer [4] have constructed algorithms which correct up to b (d 1)=2c + c log n errors for any constant c [4, 11].
Reference: [10] <author> J. Radhakrishnan. </author> <type> Personal communication, </type> <month> January, </month> <year> 1996. </year>
Reference-contexts: For instance, is there an algorithm that can decode from more errors (than (d 1)=2) when = k=n &gt; 1=3? A nice target would be a decoding algorithm that works for *() 1 p In this case we know (cf. <ref> [5, 10] </ref>) that the number of codewords within a distance of *()n is bounded by a polynomial in n. One does expect that the problem will become harder as *() ! 1 . It would be interesting to see if the problem becomes NP-hard as *() ! 1 .
Reference: [11] <author> V. M. Sidelnikov. </author> <title> Decoding Reed Solomon codes beyond (d 1)=2 and zeros of multivariate polynomials. </title> <journal> Problems of Information Transmission, </journal> <volume> 30(1) </volume> <pages> 44-59, </pages> <year> 1994. </year>
Reference-contexts: As can be seen easily, this problem captures the bounded distance decoding problem for Reed Solomon codes. There is a rich history of work associated with this problem. The classical work of Berlekamp-Massey (cf. [2, 9]), corrects upto b (d 1)=2c errors. Sidelnikov <ref> [11] </ref> and Dumer [4] have constructed algorithms which correct up to b (d 1)=2c + c log n errors for any constant c [4, 11]. We give an algorithm that improves over these results when k=n is sufficiently small (i.e., less than 1=3). <p> There is a rich history of work associated with this problem. The classical work of Berlekamp-Massey (cf. [2, 9]), corrects upto b (d 1)=2c errors. Sidelnikov [11] and Dumer [4] have constructed algorithms which correct up to b (d 1)=2c + c log n errors for any constant c <ref> [4, 11] </ref>. We give an algorithm that improves over these results when k=n is sufficiently small (i.e., less than 1=3). Our algorithm is motivated by an algorithm of Welch and Berlekamp [14, 3] which corrects b (d 1)=2c + 1 errors.
Reference: [12] <author> M. Sudan. </author> <title> Decoding of Reed Solomon codes beyond the error-correction bound. </title> <journal> Jour nal of Complexity, </journal> <volume> 13(1) </volume> <pages> 180-193, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: For any such pair of polynomials (N; D), N D () = p (), provided e 1 2 (n k). Remark: As a consequence p can be found in polynomial time. We just divide the polynomials N and D to obtain p. 1 For our algorithm from <ref> [12] </ref> we can replace this condition with the weaker one that (x i ; y i )'s are distinct. 2 Proof: Let E (x) be an "error-locator" polynomial, i.e., E (x i ) = 0 if (but not necessarily only if) y i 6= p (x i ). <p> This yields the desired conclusion immediately. 3 Decoding with algebraic curves in the plane <ref> [1, 12] </ref> A slightly different interpretation of the Welch-Berlekamp algorithm is that it finds an algebraic curve in the plane which "explains" the "data". <p> It would be interesting to see if the problem becomes NP-hard as *() ! 1 . Acknowledgments I am grateful to Dave Forney, Simon Litsyn, Ronny Roth, and Alex Vardy for their valuable comments on the article <ref> [12] </ref>. Their detailed comments motivated and encouraged the writing 9 of this article. I am grateful to Jorn Justesen for pointing out an error in the earlier version of this paper.
Reference: [13] <author> A. Vardy. </author> <title> Algorithmic complexity in coding theory and the minimum distance prob lem. </title> <booktitle> Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 92-109, </pages> <year> 1997. </year> <month> 10 </month>
Reference: [14] <author> L. R. Welch and E. R. Berlekamp. </author> <title> Error correction of algebraic block codes. </title> <type> US Patent Number 4,633,470, </type> <note> issued December 1986. 11 </note>
Reference-contexts: We give an algorithm that improves over these results when k=n is sufficiently small (i.e., less than 1=3). Our algorithm is motivated by an algorithm of Welch and Berlekamp <ref> [14, 3] </ref> which corrects b (d 1)=2c + 1 errors. In this article we describe the algorithm of Welch and Berlekamp and use it motivate our decoding algorithm. We also describe a crucial intermediate step from [1] which forms the basis of our algorithm. <p> Theorem 1 For every *, The bounded distance decoding problem with parameters n, k = n and e = *()n can be solved in polynomial time provided *() &lt; 1 1 + where = 6 6 s 1 2 7 5 : 2 Decoding with univariate rational functions <ref> [14, 3] </ref> The idea of Welch and Berlekamp [14, 3] can be informally described as follows: They describe how a "rational function" in x can be used to "explain" the "data" f (x i ; y i )g n i=1 . <p> bounded distance decoding problem with parameters n, k = n and e = *()n can be solved in polynomial time provided *() &lt; 1 1 + where = 6 6 s 1 2 7 5 : 2 Decoding with univariate rational functions <ref> [14, 3] </ref> The idea of Welch and Berlekamp [14, 3] can be informally described as follows: They describe how a "rational function" in x can be used to "explain" the "data" f (x i ; y i )g n i=1 . <p> i )g n i=1 s.t. there exists a bivariate polynomial Q satisfying: The (1; k 1) weighted degree of Q is at most D, Q 6 0 and 8i 2 [n]; Q (x i ; y i ) = 0. (1) Then the following hold: 2 Actually Berlekamp and Welch <ref> [14, 3] </ref> give a much more efficient solution for this task, but we will not describe their solution here. 3 1. A polynomial Q satisfying equation (1) can be found in polynomial time. 2.
References-found: 14

