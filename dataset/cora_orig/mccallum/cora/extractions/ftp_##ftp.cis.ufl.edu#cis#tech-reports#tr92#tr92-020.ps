URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-020.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: An Efficient Approximation Algorithm for the File Redistribution Scheduling Problem in Fully Connected Networks  
Author: Ravi Varadarajan Pedro I. Rivera-Vega 
Abstract: We consider the problem of transferring a set of files from their given locations in a fully connected network to their respective destinations in minimum time. The network has two unidirectional links, one in each direction, between every pair of nodes. We assume that it takes unit time to transfer a file across a link and no link is used by more than one file at any time. There is no restriction on storage capacity at the nodes. The objective of the File Redistribution Scheduling problem is to find routes for the files and a schedule for the use of the links along the routes so as to complete the transfer of all the files in minimum time. This problem has been shown to be NP-hard even with the restriction that each file must have at most one hop in its route. In this paper, we present an efficient polynomial time algorithm that finds an approximate solution to the problem. In this approximate solution, each file has at most one hop in its route and all the files can be transferred within twice the time taken by an optimal schedule.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. A. Brualdi, </author> <title> "Transversal Theory and Graphs," Studies in Graph Theory, Vol.11, Part I, </title> <year> 1975, </year> <month> pp.23-88. </month>
Reference-contexts: For example, in a four-node network, when a matching contains edges (1; 3) and (2; 4), we can route two files, one of type <ref> [1; 3] </ref> and another of type [2; 4] to go through an intermediate node (say) 4. This means that [1; 3] file will use the route 1 4 3 and at the same time, the [2; 4] file will 4 use route 2 4 4 meaning that it will use the <p> For example, in a four-node network, when a matching contains edges (1; 3) and (2; 4), we can route two files, one of type <ref> [1; 3] </ref> and another of type [2; 4] to go through an intermediate node (say) 4. This means that [1; 3] file will use the route 1 4 3 and at the same time, the [2; 4] file will 4 use route 2 4 4 meaning that it will use the direct link (2; 4) during the first time unit. <p> Let X 1 be the set of nodes in X with degree equal to p. Then there exists a matching M which matches X 1 to a subset of Y . Proof: See <ref> [1] </ref>, pp.46 Now we are ready to state the theorem that proves correctness of the algorithm. Theorem 4.2 The schedule S produced by the algorithm satisfies the following: (1) S is a valid schedule, and (2) T (S) 2T opt (M ). <p> The makespan is 9 4 time units for this example. Note that the optimal makespan for this example is 3 time units; to see this, let all the files except 2 files of type <ref> [2; 1] </ref> use direct link and let the two files of type [2; 1] follow routes 2 3 1 and 2 4 1 respectively. 7 Conclusions In this paper, we have given an efficient algorithm for determining a schedule for the file redistribution scheduling problem in fully connected networks. <p> The makespan is 9 4 time units for this example. Note that the optimal makespan for this example is 3 time units; to see this, let all the files except 2 files of type <ref> [2; 1] </ref> use direct link and let the two files of type [2; 1] follow routes 2 3 1 and 2 4 1 respectively. 7 Conclusions In this paper, we have given an efficient algorithm for determining a schedule for the file redistribution scheduling problem in fully connected networks. This schedule has a makespan that is within twice the optimal makespan.
Reference: [2] <author> H.-A. Choi and S. L. Hakimi, </author> <title> "Data Transfers in Networks," </title> <journal> Algorithmica, </journal> <volume> No. 3, </volume> <year> 1988, </year> <pages> pp. 223-245. </pages>
Reference-contexts: For example, in a four-node network, when a matching contains edges (1; 3) and (2; 4), we can route two files, one of type [1; 3] and another of type <ref> [2; 4] </ref> to go through an intermediate node (say) 4. This means that [1; 3] file will use the route 1 4 3 and at the same time, the [2; 4] file will 4 use route 2 4 4 meaning that it will use the direct link (2; 4) during the <p> contains edges (1; 3) and (2; 4), we can route two files, one of type [1; 3] and another of type <ref> [2; 4] </ref> to go through an intermediate node (say) 4. This means that [1; 3] file will use the route 1 4 3 and at the same time, the [2; 4] file will 4 use route 2 4 4 meaning that it will use the direct link (2; 4) during the first time unit. <p> The makespan is 9 4 time units for this example. Note that the optimal makespan for this example is 3 time units; to see this, let all the files except 2 files of type <ref> [2; 1] </ref> use direct link and let the two files of type [2; 1] follow routes 2 3 1 and 2 4 1 respectively. 7 Conclusions In this paper, we have given an efficient algorithm for determining a schedule for the file redistribution scheduling problem in fully connected networks. <p> The makespan is 9 4 time units for this example. Note that the optimal makespan for this example is 3 time units; to see this, let all the files except 2 files of type <ref> [2; 1] </ref> use direct link and let the two files of type [2; 1] follow routes 2 3 1 and 2 4 1 respectively. 7 Conclusions In this paper, we have given an efficient algorithm for determining a schedule for the file redistribution scheduling problem in fully connected networks. This schedule has a makespan that is within twice the optimal makespan.
Reference: [3] <author> E. G. Coffman, JR, M. R. Garey, D. S. Johnson and A. S. Lapaugh, </author> <title> "Scheduling File Transfers," </title> <journal> SIAM Journal on Computing , Vol. </journal> <volume> 14, No. 3, </volume> <month> August </month> <year> 1985, </year> <pages> pp. 744-780. </pages>
Reference-contexts: For example, in a four-node network, when a matching contains edges (1; 3) and (2; 4), we can route two files, one of type <ref> [1; 3] </ref> and another of type [2; 4] to go through an intermediate node (say) 4. This means that [1; 3] file will use the route 1 4 3 and at the same time, the [2; 4] file will 4 use route 2 4 4 meaning that it will use the <p> For example, in a four-node network, when a matching contains edges (1; 3) and (2; 4), we can route two files, one of type <ref> [1; 3] </ref> and another of type [2; 4] to go through an intermediate node (say) 4. This means that [1; 3] file will use the route 1 4 3 and at the same time, the [2; 4] file will 4 use route 2 4 4 meaning that it will use the direct link (2; 4) during the first time unit. <p> Note that the first two files in the above routes use direct links 1 2 and 2 1 during the second and first time units respectively. Also the file of type <ref> [4; 3] </ref> is a "dummy" file and hence is not scheduled in steps 11 and 12 of the algorithm.
Reference: [4] <author> J. E. Hopcroft and R. M. Karp, </author> <title> "An n 5=2 algorithm for maximum matchings in bipartite graphs," </title> <journal> SIAM Journal on Computing, </journal> <month> 2 (Dec. </month> <year> 1973),pp. </year> <pages> 225-231. </pages>
Reference-contexts: For example, in a four-node network, when a matching contains edges (1; 3) and (2; 4), we can route two files, one of type [1; 3] and another of type <ref> [2; 4] </ref> to go through an intermediate node (say) 4. This means that [1; 3] file will use the route 1 4 3 and at the same time, the [2; 4] file will 4 use route 2 4 4 meaning that it will use the direct link (2; 4) during the <p> contains edges (1; 3) and (2; 4), we can route two files, one of type [1; 3] and another of type <ref> [2; 4] </ref> to go through an intermediate node (say) 4. This means that [1; 3] file will use the route 1 4 3 and at the same time, the [2; 4] file will 4 use route 2 4 4 meaning that it will use the direct link (2; 4) during the first time unit. <p> In step 5, we invoke the subroutine FindMaxMatch-ing to find a maximum size matching R of the bipartite graph G W . For this, we use the algorithm of <ref> [4] </ref>. In step 1, we invoke the subroutine FindPerfectMatrix to find a non-negative square matrix E and a perfect non-negative square matrix W with the same critical sum as M such that M + E = W . <p> Step 1 invokes FindPerfectMatrix routine that is easily seen to have a time complexity of O (n 2 ). For step 5, we can use the algorithm of <ref> [4] </ref>. For a bipartite graph G = (V; E) it has worst-case running time O ((jV j+jEj) jV j). At the beginning of the i th iteration of the while loop (step 4), the graph G W has jV j = 2n and jE W j = (CS (M )i+1)n. <p> Note that the first two files in the above routes use direct links 1 2 and 2 1 during the second and first time units respectively. Also the file of type <ref> [4; 3] </ref> is a "dummy" file and hence is not scheduled in steps 11 and 12 of the algorithm.
Reference: [5] <author> D. Peleg and E. Upfal, </author> <title> "The Generalized Packet Routing Problem," </title> <journal> Theoretical Computer Science, </journal> <volume> 53, </volume> <year> 1987, </year> <pages> pp. 281-293. </pages>
Reference: [6] <author> D. Peleg and E. Upfal, </author> <title> "The Token Distribution Problem," </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 18, No. 2, </volume> <month> April </month> <year> 1989, </year> <pages> pp. 229-143. 10 </pages>
Reference: [7] <author> P.I. Rivera-Vega, R. Varadarajan and S.B. Navathe, </author> <title> "Scheduling Data Redis--tribution in Distributed Databases", </title> <type> Technical Report, </type> <institution> Database Research and Development Center, University of Florida, </institution> <year> 1989. </year>
Reference-contexts: The problem is of practical importance in distributed and parallel computer systems. For example, in a distributed database system, redistribution of data is periodically required in order to maintain a desired level of performance usually measured by average execution time of transactions <ref> [7] </ref>. In this case, the redistribution should be accomplished as soon as possible since the system cannot be fully operational while it is taking place. In the parallel processing context, this problem is related to the problem of routing packets among the processors of a network ([9, 5, 6]).
Reference: [8] <author> P.I. Rivera-Vega. R. Varadarajan and S.B. Navathe, </author> <title> "Scheduling Data Transfers in Fully Connected Networks," Networks: </title> <note> An International Journal, to appear. </note>
Reference-contexts: Our problem is distinct from the FTP and to avoid confusion, we call our problem the "file redistribution scheduling problem". The file redistribution scheduling problem has been shown to be intractable <ref> [8] </ref> even when the schedules are restricted to two-edge schedules. These are schedules in which every file has at most one hop in its route to its destination. In [8], the authors present a two-phase approach to find two-edge schedules. <p> The file redistribution scheduling problem has been shown to be intractable <ref> [8] </ref> even when the schedules are restricted to two-edge schedules. These are schedules in which every file has at most one hop in its route to its destination. In [8], the authors present a two-phase approach to find two-edge schedules. In the first phase, each file is assigned a two-edge route and in the second phase, a schedule for use of the links along the assigned routes is determined. <p> = P n j=1 m ij denote the number of files having node i as the source, and m 0 P n j=1 m ji the number of files having node i as the destination. 3 The Approximation Algorithm The fact that the problem has been shown to be intractable <ref> [8] </ref> motivates us to seek efficient approximation strategies which guarantee schedules with bounded makespans with respect to optimal values. In this paper, we present one such approximation algorithm. Our algorithm constructs routes with at most one hop between sources and destinations. <p> we are currently investigating include the following: (1) Can we modify the proposed approximation algorithm so that it provides a schedule with makespan closer to optimal (especially when the optimal makespan is closer to L than to 2L) ? and (2) Can we identify other cases, besides those discussed in <ref> [8] </ref>, for which polynomial time algorithms to determine optimal schedules exist ? It is also possible to get improved schedules by first computing only the routes using the algorithm proposed in this paper and then determining the schedules using the scheduling algorithm proposed in [8]. <p> other cases, besides those discussed in <ref> [8] </ref>, for which polynomial time algorithms to determine optimal schedules exist ? It is also possible to get improved schedules by first computing only the routes using the algorithm proposed in this paper and then determining the schedules using the scheduling algorithm proposed in [8]. The investigation of the accuracy of such schedules is also an interesting issue to explore.
Reference: [9] <author> L. G. Valiant, </author> <title> "A Scheme for Fast Parallel Communication," </title> <journal> SIAM Journal on Computing, Vol.11, </journal> <volume> 2, </volume> <month> May </month> <year> 1982, </year> <pages> pp. 350-361. </pages>
Reference: [10] <author> E. A. Varvarigos and D. P. Bertsekas, </author> <title> "Communication Algorithms for Isotropic Tasks in Hypercubes and Wraparound Meshes," Parallel Computing, </title> <note> to appear. </note>
Reference-contexts: To tackle the case when M is an arbitrary n fi n matrix, not necessarily perfect, we make use of the following result proved in <ref> [10] </ref>. Lemma 3.3 Given any nonnegative integer square matrix M , there is a square matrix Z such that M + Z is a perfect matrix and CS (M + Z) = CS (M ). The matrix Z simply indicates the "dummy" files that need to be transferred. <p> In step 1, we invoke the subroutine FindPerfectMatrix to find a non-negative square matrix E and a perfect non-negative square matrix W with the same critical sum as M such that M + E = W . The proof of Lemma 3.3 given in <ref> [10] </ref> gives an implicit procedure to construct these matrices and we give an explicit efficient procedure below. The procedure we use is identical to the North-West-Corner (NWC) rule used in finding a feasible allocation in the transportation problem.
Reference: [11] <author> J. Whitehead, </author> <title> "The Complexity of File Transfer Scheduling with Forwarding," </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 19, No. 2, </volume> <pages> pp. 222-245, </pages> <month> April </month> <year> 1990. </year> <month> 11 </month>
References-found: 11

