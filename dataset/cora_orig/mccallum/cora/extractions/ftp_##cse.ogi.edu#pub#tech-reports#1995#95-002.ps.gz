URL: ftp://cse.ogi.edu/pub/tech-reports/1995/95-002.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: -casas,dclark,konuru,otto,prouty,walpole-@cse.ogi.edu  
Title: MPVM: A Migration Transparent Version of PVM  
Author: Jeremy Casas, Dan Clark, Ravi Konuru, Steve Otto, Robert Prouty, Jonathan Walpole 
Address: PO BOX 91000 Portland, OR 97291-1000, USA  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Date: Feb 15 13:08:42 1995  February 1995  
Note: Wed  
Abstract: Parallel Virtual Machine (PVM) is a widely-used software system that allows a heterogeneous set of parallel and serial UNIX-based computers to be programmed as a single distributed-memory parallel machine. In this paper, an extension to PVM to support dynamic process migration is presented. Support for migration is important in general-purpose workstation environments since it allows parallel computations to co-exist with other applications, using idle-cycles as they become available and off-loading from workstations when they are no longer free. A description and evaluation of the design and implementation of the prototype Migratable PVM system is presented together with some performance results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. L. Beguelin, J. J. Dongarra, A. Geist, and R. J. M. V. S. Sunderam. </author> <title> Heterogeneous network computing. </title> <booktitle> In Sixth SIAM Conference on Parallel Processing. </booktitle> <publisher> SIAM, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction PVM <ref> [1, 2, 3] </ref> is a software system that allows a heterogeneous network of parallel and serial computers to be programmed as a single computational resource. This resource appears to the application programmer as a potentially large distributed-memory virtual computer.
Reference: [2] <author> J. J. Dongarra, A. Geist, R. J. Manchek, and V. S. Sunderam. </author> <title> Integrated PVM framework supports heterogeneous network computing. </title> <booktitle> Computers in Physics, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: 1 Introduction PVM <ref> [1, 2, 3] </ref> is a software system that allows a heterogeneous network of parallel and serial computers to be programmed as a single computational resource. This resource appears to the application programmer as a potentially large distributed-memory virtual computer.
Reference: [3] <author> A. L. Beguelin, J. J. Dongarra, A. Geist, R. J. Manchek, S. W. Otto, and J. Walpole. </author> <title> PVM: Experiences, current status and future direction. </title> <booktitle> In Supercomputing 93 Proceedings, </booktitle> <pages> pages 7656, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction PVM <ref> [1, 2, 3] </ref> is a software system that allows a heterogeneous network of parallel and serial computers to be programmed as a single computational resource. This resource appears to the application programmer as a potentially large distributed-memory virtual computer. <p> section 5, a qualitative discussion of the design and implementation in section 6, and conclusions and future work in section 7. 2 Background MPVM is based on PVM 3.3.4 as released from Oak Ridge National Laboratory and is part of the larger Concurrent Processing Environment, an on going research effort <ref> [3] </ref>.
Reference: [4] <author> M. J. Litzkow, M. Livny, and M. W. </author> <title> Mutka. Condor A hunter of idle workstations. </title> <booktitle> In Proceedings of the 8th IEEE International Conference on Distributed Computing Systems, </booktitle> <pages> pages 104111, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Workstation owners are often willing to allow others to access their workstation when it is idle, but expect dedicated access the rest of the time. Since most workstations are idle most of the time <ref> [4] </ref>, the key to harnessing the full power of such systems lies in gaining access to these idle cycles. <p> Notable examples of such implementation are present in Charlotte [9], V [10], Mosix [11, 12], Sprite [13, 14], and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor <ref> [4, 6, 16] </ref> is an example of such an implementation. MPVM fits into this category. Most of the literature on these systems focus on process migration mechanism efficiency. Efficiency is defined in terms of application freeze time and state transfer cost.
Reference: [5] <author> K. Al-Saqabi, S. W. Otto, and J. Walpole. </author> <title> Gang scheduling in heterogenous distributed systems. </title> <type> Technical report, </type> <institution> Dept. of Computer Science and Engineering, Oregon Graduate Institute of Science & Technology, </institution> <year> 1994. </year>
Reference-contexts: Hence, new versions of PVM such as MPVM should maintain the same semantics. Lastly, in PVM 3.3.4, it is possible to designate a special task as the resource manager. The resource manager, also called the global scheduler (GS) in this paper, embodies decision making policies <ref> [5] </ref> such as task-to-processor allocation for sensibly scheduling multiple parallel applications. Using a GS makes it convenient to experiment with different scheduling policies.
Reference: [6] <author> M. Litzkow and M. Solomon. </author> <title> Supporting checkpointing and process migration outside the Unix kernel. </title> <booktitle> In Usenix Winter Conference Proceedings, </booktitle> <pages> pages 283290, </pages> <address> San Francisco, CA, </address> <year> 1992. </year>
Reference-contexts: For this purpose, a setjmp () is called within the migration signal handler just before the actual state transfer. A similar approach is taken in Condor <ref> [6] </ref>. After calling setjmp (), Mtask creates a TCP socket and using the IP address and the socket port address from the TM_MIGACK CM, establishes a connection with the skeleton process on the destination host. <p> Notable examples of such implementation are present in Charlotte [9], V [10], Mosix [11, 12], Sprite [13, 14], and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor <ref> [4, 6, 16] </ref> is an example of such an implementation. MPVM fits into this category. Most of the literature on these systems focus on process migration mechanism efficiency. Efficiency is defined in terms of application freeze time and state transfer cost.
Reference: [7] <author> PVM version 3.3.0 release-notes, </author> <month> June </month> <year> 1994. </year> <title> Comes with the PVM distribution from Netlib. </title>
Reference-contexts: A drawback of this method, however, is that it doesnt work for Unix domain sockets. PVM 3.3.x uses Unix domain sockets for direct connections between tasks on the same host since it is about 1.5x - 2x faster than TCP sockets <ref> [7] </ref>. Unix domain sockets only work for tasks on the same host. Unfortunately, Unix domain sockets has no support for OOB data. As currently implemented, MPVM uses TCP sockets for direct communication even for tasks on the same host.
Reference: [8] <author> A. Geist, A. Beguelin, J. Dongarra, W. Jiang, R. Manchek, and V. Sunderam. </author> <title> PVM 3 users guide and reference manual. </title> <type> Technical Report ORNL/TM-12187, </type> <institution> Oak Ridge National Laboratory, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: These tids are used to identify the source and destina tion of messages. Tids are formed using an encoding of a host ID and a task number <ref> [8] </ref>. The host ID or hid represents the host where the task is executing while the task number identifies a particular task on a particular host. The combination of the host number and the task number uniquely identifies any task in the entire virtual machine.
Reference: [9] <author> Y. Artsy and R. Finkel. </author> <title> Designing a process migration facility the Charlotte experience. </title> <journal> Computer, </journal> <volume> 22(9):47 56, </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: In system-level supported implementations, the OS kernel is involved in the migration. Notable examples of such implementation are present in Charlotte <ref> [9] </ref>, V [10], Mosix [11, 12], Sprite [13, 14], and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor [4, 6, 16] is an example of such an implementation.
Reference: [10] <author> M. M. Theimer, K. A. Lantz, and D. R. Cheriton. </author> <title> Preemptable remote execution facilities for the V-System. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 212, </pages> <address> Orcas Islands, Washington, </address> <month> December 1-4 </month> <year> 1985. </year>
Reference-contexts: In system-level supported implementations, the OS kernel is involved in the migration. Notable examples of such implementation are present in Charlotte [9], V <ref> [10] </ref>, Mosix [11, 12], Sprite [13, 14], and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor [4, 6, 16] is an example of such an implementation.
Reference: [11] <author> A. Barak and A. Litman. </author> <title> MOS A multicomputer distributed operating system. </title> <journal> Software Practice & Experience, </journal> <volume> 15(8):725737, </volume> <month> August </month> <year> 1985. </year>
Reference-contexts: In system-level supported implementations, the OS kernel is involved in the migration. Notable examples of such implementation are present in Charlotte [9], V [10], Mosix <ref> [11, 12] </ref>, Sprite [13, 14], and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor [4, 6, 16] is an example of such an implementation. MPVM fits into this category.
Reference: [12] <author> A. Barak, S. Guday, and R. G. Wheeler. </author> <title> The MOSIX Distributed Operating System Load Balancing for Unix. </title> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In system-level supported implementations, the OS kernel is involved in the migration. Notable examples of such implementation are present in Charlotte [9], V [10], Mosix <ref> [11, 12] </ref>, Sprite [13, 14], and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor [4, 6, 16] is an example of such an implementation. MPVM fits into this category.
Reference: [13] <author> F. Douglis and J. Ousterhout. </author> <title> Process migration in the Sprite operating system. </title> <booktitle> In Proceedings of the 7th IEEE International Conference on Distributed Computing Systems, </booktitle> <pages> pages 1825, </pages> <address> Berlin, West Germany, </address> <month> September 21-25 </month> <year> 1987. </year>
Reference-contexts: In system-level supported implementations, the OS kernel is involved in the migration. Notable examples of such implementation are present in Charlotte [9], V [10], Mosix [11, 12], Sprite <ref> [13, 14] </ref>, and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor [4, 6, 16] is an example of such an implementation. MPVM fits into this category.
Reference: [14] <author> F. Douglis and J. Ousterhout. </author> <title> Transparent process migration: Design alternatives and the Sprite implementation. </title> <journal> Software Practice & Experience, </journal> <volume> 21(8):757785, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: In system-level supported implementations, the OS kernel is involved in the migration. Notable examples of such implementation are present in Charlotte [9], V [10], Mosix [11, 12], Sprite <ref> [13, 14] </ref>, and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor [4, 6, 16] is an example of such an implementation. MPVM fits into this category.
Reference: [15] <author> D. S. Milojicic, W. Zint, A. Dangel, and P. Giese. </author> <title> Task migration on the top of the Mach microkernel. </title> <booktitle> In MACH III Symposium Proceedings, </booktitle> <pages> pages 273289, </pages> <address> Santa Fe, New Mexico, </address> <month> April 19-21 </month> <year> 1993. </year>
Reference-contexts: In system-level supported implementations, the OS kernel is involved in the migration. Notable examples of such implementation are present in Charlotte [9], V [10], Mosix [11, 12], Sprite [13, 14], and Mach <ref> [15] </ref>. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor [4, 6, 16] is an example of such an implementation. MPVM fits into this category.
Reference: [16] <author> A. Bricker, M. Litzkow, and M. Livny. </author> <title> Condor technical summary. </title> <type> Technical report, </type> <institution> University of Wisconsin at Madison, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Notable examples of such implementation are present in Charlotte [9], V [10], Mosix [11, 12], Sprite [13, 14], and Mach [15]. User-level supported process migration implementations, on the other hand, do not require services other than what the OS ordinarily provides through its system call interface. Condor <ref> [4, 6, 16] </ref> is an example of such an implementation. MPVM fits into this category. Most of the literature on these systems focus on process migration mechanism efficiency. Efficiency is defined in terms of application freeze time and state transfer cost.
Reference: [17] <author> E. R. Zayas. </author> <title> Attacking the process migration bottleneck. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 1324, </pages> <address> Austin, Texas, </address> <month> November 8-11 </month> <year> 1987. </year>
Reference-contexts: Freeze time is the time during which the process is not executing. State transfer cost on the other hand is the cost of transferring the process state. The state transfer cost is often the limiting factor in migration speed <ref> [17] </ref>. This observation is in accordance with the experimental results shown in the previous section. Two other categorizations of these implementations are in terms of transparency and residual dependency. Transparency refers to how much, or how little, the process is affected by the migration. <p> Mach uses the concept of Copy-On-Reference (COR) initially used in Accent <ref> [17] </ref>, the precursor of Mach. COR semantics allows a migrating process or task (in Mach parlance) to be started immediately at the target node.
Reference: [18] <author> J. Pruyne and M. Livny. </author> <title> Providing resource management services to parallel applications. </title> <booktitle> In Proceeding of the 2nd workshop on Environments and Tools for Parallel Scientific Computing, </booktitle> <pages> pages 152161, </pages> <year> 1995. </year>
Reference-contexts: The most notable of user-level process migration implementations is Condor. Condor was initially designed for sequential programs. Recently, however, support for PVM applications was added but only as far as scheduling and process suspension/resumption <ref> [18] </ref>. There is currently no support of migration of PVM applications. The main difference between Condor and MPVM is that Condor uses a checkpoint/roll-back mechanism to achieve migration. This design decision was made to minimize obtrusiveness.
Reference: [19] <author> R. Konuru, J. Casas, S. Otto, R. Prouty, and J. Walpole. </author> <title> A user-level process package for PVM. </title> <booktitle> In 1994 Scalable High-Performance Computing Conference, </booktitle> <pages> pages 4855. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: Aside from the speed factor, disk space consumption is also avoided. It is not uncommon to see core dumps in the megabyte range. Two systems closely related to MPVM are UPVM and DynamicPVM. UPVM <ref> [19] </ref>, another research effort here at OGI, addresses the problem of the course-grained distribution granularity present in MPVM. MPVM migrates tasks at the level of whole processes. UPVM introduces the concept of User Level Processes (ULPs) which are thread-like entities that are independently migratable.
Reference: [20] <author> L. Dikken, F. van der Linden, J. Vesseur, and P. Sloot. </author> <title> Dynamic PVM Dynamic Load Balancing on Parallel Systems, </title> <booktitle> volume II: Networking and Tools of Lecture Notes in Computer Science, </booktitle> <pages> pages 273277. </pages> <publisher> Springer-Verlag, </publisher> <address> Munich, Germany, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Second, since all the ULPs share the address space of a single Unix process, there is a limit on the number of ULPs the application can have depending on the size of the virtual address space of the process and the memory requirements of each ULP. DynamicPVM <ref> [20] </ref> is an extension to PVM to support process migration, very much like MPVM, but relies on Condor-style checkpointing. A more detailed comparison of both systems is unfortunately unavailable at this time.
Reference: [21] <author> M. M. Theimer and B. Hayes. </author> <title> Heterogeneous process migration by recompilation. </title> <type> Technical Report CSL-92-3, </type> <institution> Xerox Palo Alto Research Center - CA, </institution> <year> 1992. </year>
Reference-contexts: Heterogeneity can come in the form of different processors and instruction sets, different OSs, different memory management units, etc. Translation of a process state as captured on one machine to one of a different architecture is not easy, though there is some work being done that addresses this problem <ref> [21] </ref>. 6.5 Scalability Recall that the migration protocol generally only involves the migrating task, the source pvmd, the destination pvmd, and the home pvmd of the migrating task.
Reference: [22] <author> A. W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96107, </pages> <address> Santa Clara, CA, </address> <month> April 8-11 </month> <year> 1991. </year>
Reference-contexts: The solutions presented by systems such as V and Mach rely on virtual memory functions such as trapping page faults, checking for dirty pages, etc. These functions, however, are not generally available at user-level. Though there is work being done to provide user-level virtual memory management <ref> [22, 23, 24] </ref>, until such functionality becomes widely available, portable user-level process migration implementations cannot make use of methods available to system-level implementations 7 Conclusion MPVM is an extension to PVM that provides for transparent process migration.
Reference: [23] <author> K. Harty and D. R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 187197, </pages> <address> Boston, Massachusetts, </address> <month> October 12-15 </month> <year> 1992. </year>
Reference-contexts: The solutions presented by systems such as V and Mach rely on virtual memory functions such as trapping page faults, checking for dirty pages, etc. These functions, however, are not generally available at user-level. Though there is work being done to provide user-level virtual memory management <ref> [22, 23, 24] </ref>, until such functionality becomes widely available, portable user-level process migration implementations cannot make use of methods available to system-level implementations 7 Conclusion MPVM is an extension to PVM that provides for transparent process migration.
Reference: [24] <author> S. Sechrest and Y. Park. </author> <title> User-level physical memory management for Mach. </title> <booktitle> In Mach Symposium Proceedings, </booktitle> <pages> pages 189199, </pages> <address> Monterey, California, </address> <month> November 20-22 </month> <year> 1991. </year> <title> MPVM: A Migration Transparent Version of PVM 27 of 27 </title>
Reference-contexts: The solutions presented by systems such as V and Mach rely on virtual memory functions such as trapping page faults, checking for dirty pages, etc. These functions, however, are not generally available at user-level. Though there is work being done to provide user-level virtual memory management <ref> [22, 23, 24] </ref>, until such functionality becomes widely available, portable user-level process migration implementations cannot make use of methods available to system-level implementations 7 Conclusion MPVM is an extension to PVM that provides for transparent process migration.
Reference: [25] <author> T. Green and J. Snyder. DQS, </author> <title> a distributed queuing system. </title> <type> Technical report, </type> <institution> Supercomputer Computations Research Institute, Florida State University, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Another aspect being considered is the support for fault-tolerance with the use of checkpointing. More long-term goals for MPVM are integration with a global sched-uler that would make it convenient to experiment with various scheduling policies. Integration with existing utilities such as batch schedulers (Condor and DQS <ref> [25] </ref>), tools (Ptools [26]), profilers and debuggers (Xpvm [27]) etc. is 26 of 27 MPVM: A Migration Transparent Version of PVM also be being considered. All this work is targeted for the next generation PVM system.
Reference: [26] <author> W. Gropp and E. Lusk. </author> <title> Scalable Unix tools on parallel processors. </title> <booktitle> In 1994 Scalable High-Performance Computing Conference, </booktitle> <pages> pages 5662. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: More long-term goals for MPVM are integration with a global sched-uler that would make it convenient to experiment with various scheduling policies. Integration with existing utilities such as batch schedulers (Condor and DQS [25]), tools (Ptools <ref> [26] </ref>), profilers and debuggers (Xpvm [27]) etc. is 26 of 27 MPVM: A Migration Transparent Version of PVM also be being considered. All this work is targeted for the next generation PVM system.
Reference: [27] <author> J. A. Kohl and G. A. Geist. XPVM: </author> <title> A graphical console and monitor for PVM. In 2nd PVM Users Group Meeting, </title> <institution> Oak Ridge, TN, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: More long-term goals for MPVM are integration with a global sched-uler that would make it convenient to experiment with various scheduling policies. Integration with existing utilities such as batch schedulers (Condor and DQS [25]), tools (Ptools [26]), profilers and debuggers (Xpvm <ref> [27] </ref>) etc. is 26 of 27 MPVM: A Migration Transparent Version of PVM also be being considered. All this work is targeted for the next generation PVM system.
References-found: 27

