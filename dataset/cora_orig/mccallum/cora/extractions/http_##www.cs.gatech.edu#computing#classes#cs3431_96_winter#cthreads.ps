URL: http://www.cs.gatech.edu/computing/classes/cs3431_96_winter/cthreads.ps
Refering-URL: http://www.cs.gatech.edu/computing/classes/cs3431_96_winter/
Root-URL: 
Email: schwan@cc.gatech.edu harold@cc.gatech.edu bodhi@cc.gatech.edu  
Title: A C Thread Library for Multiprocessors  
Author: Karsten Schwan, Harold Forbes, Ahmed Gheith, Bodhisattwa Mukherjee and Yiannis Samiotakis 
Address: Atlanta, Georgia 30332-0280  
Affiliation: School of Information and Computer Science Georgia Institute of Technology  
Date: 10 January 1991  
Pubnum: GIT-ICS-91/02  
Abstract: This document describes the interface and implementation of a user-level thread library for several computer systems. The purpose of this library is to allow programmers to develop high-performance, concurrent applications that are easily ported to future MACH-based machines. Thus, differences between the `standard' Mach C thread library package and this library have been minimized. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Eric C. Cooper and Richard P. Draves. </author> <title> C threads. Internal research note of the Mach project, </title> <month> April </month> <year> 1987. </year>
Reference-contexts: Comment on the implementation. 3. Describe the monitor implementation. 4. Explain in detail a simple thread program. Appendices address: 1. The CThread Interface (.h) File. 2. Other architectures. 3. Some non-library functions and tools. For a complete description of Mach C Threads see <ref> [1] </ref>. 2 2 Differences from Mach C Threads The differences of this thread library in comparison with MACH's C threads [1] are due to: 1. We introduce error return values for all library calls to aid in the debugging process. <p> Appendices address: 1. The CThread Interface (.h) File. 2. Other architectures. 3. Some non-library functions and tools. For a complete description of Mach C Threads see <ref> [1] </ref>. 2 2 Differences from Mach C Threads The differences of this thread library in comparison with MACH's C threads [1] are due to: 1. We introduce error return values for all library calls to aid in the debugging process. This decision proved indispensable in writing the monitor library (based on threads) shown below. 2.
Reference: [2] <author> Thomas W. Doeppner. </author> <title> A threads tutorial. </title> <type> Technical report, </type> <institution> Department of Computer Science, Brown University, CS-87-06, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: This condition would not occur if threads were preemptable or remotely executable. 7 4 A Monitor Implementation with Threads The following text describes an implementation of monitors as specified by Hoare [3] . Note that the signal and wait instructions offered here differ from those in Brown's `monitor' implementation <ref> [2] </ref> in that Brown's implementation offers a `signalandexit' call, whereas a `signal' call is offered in the package below. typedef int monitor_result ; #define M_SUCCEED 0 #define M_NO_SUCH_CONDITION 1 #define M_NO_MEMORY 2 #define M_BAD_NUM_OF_CONDITIONS 3 The monitor calls are: monitor_result monitor_init (monitor_ptr, no_of_cond, node) monitor_t *monitor_ptr; int no_of_cond; int node; This
Reference: [3] <author> C.A.R. Hoare. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Comm. of the Assoc. Comput. Mach., </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <month> Oct </month> <year> 1974. </year> <month> 14 </month>
Reference-contexts: This condition would not occur if threads were preemptable or remotely executable. 7 4 A Monitor Implementation with Threads The following text describes an implementation of monitors as specified by Hoare <ref> [3] </ref> .
References-found: 3

