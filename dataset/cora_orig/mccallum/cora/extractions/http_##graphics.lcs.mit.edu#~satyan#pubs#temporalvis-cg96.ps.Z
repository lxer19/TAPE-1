URL: http://graphics.lcs.mit.edu/~satyan/pubs/temporalvis-cg96.ps.Z
Refering-URL: http://graphics.lcs.mit.edu/~satyan/pubs.html
Root-URL: 
Email: fsatyan,sethg@graphics.lcs.mit.edu  
Title: Temporally Coherent Conservative Visibility (Extended Abstract)  
Author: Satyan Coorg Seth Teller 
Keyword: Conservative visibility, temporal coherence, hierarchical representations, octrees, visual events, linearized dynamic aspect graphs.  
Address: Cambridge, MA 02139  
Affiliation: Synthetic Imagery Group MIT Laboratory for Computer Science  
Abstract: In this paper, we present a new approach to the visibility problem. The novel aspects of our algorithm are that it is temporally coherent and conservative; for all viewpoints the algorithm overestimates the set of visible polygons. As the synthetic viewpoint moves, the algorithm reuses visibility information computed for previous viewpoints. It does so by computing visual events at which visibility changes occur, and efficiently identifying and discarding these events as the viewpoint changes. In essence, the algorithm implicitly constructs and maintains a linearized portion of an aspect graph, a data structure for representing visual events. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Airey, J. M., Rohlf, J. H., and Brooks, Jr., F. P. </author> <title> Towards Image Realism with Interactive Update Rates in Complex Virtual Building Environments. </title> <booktitle> ACM Sig-graph Special Issue on 1990 Symposium on Interactive 3D Graphics 24, 2 (1990), </booktitle> <pages> 41-50. </pages>
Reference-contexts: The challenge, of course, is to produce a useful tight upper bound on the visible polygons. This idea of conservative visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 23, 10] </ref>. The idea in [23, 10] is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell, eye-to-cell, and eye-to-object visibility can be used to bound exact visibility from above.
Reference: [2] <author> Akeley, K. </author> <title> RealityEngine Graphics. </title> <booktitle> Computer Graphics (Proc. Siggraph '93) (1993), </booktitle> <pages> 109-116. </pages>
Reference-contexts: 1 Introduction In computer graphics, identifying visible polygons or eliminating hidden polygons is an important component of efficient scene rendering algorithms. Despite the availability of the depth-buffer algorithm in hardware <ref> [2] </ref>, the number of polygons in many geometric models is larger than hardware alone can process at interactive frame rates. One way to address this problem is by developing algorithms that resolve visibility at a higher level, and render only the visible portions of the model. <p> Due to the availability of cheap memory, the simple depth-buffer algorithm, typically implemented in hardware <ref> [2] </ref>, is widely used. This algorithm resolves visibility at each pixel. Along with its color, each pixel stores the distance of the represented surface fragment from the viewpoint; all pixel depths are set to some far away distance at the start of each frame.
Reference: [3] <author> Baumgart, B. G. </author> <title> A Polyhedron Representation for Computer Vision. </title> <booktitle> In Proc. AFIPS Natl. Comput. Conf. (1975), </booktitle> <volume> vol. 44, </volume> <pages> pp. 589-596. </pages>
Reference-contexts: When visual events occur due to a change in the viewpoint, the algorithm must update either the visibility or the set of relevant planes or both. Using a winged-edge data structure <ref> [3] </ref>, we can update the visibility using only "local" computation. For example, in Figure 3-a, the edges adjacent to vertex V 6 can be used to identify the edges of B that overlap E, and thus the new set of relevant planes.
Reference: [4] <author> Bentley, J. </author> <title> Multidimensional binary search trees used for associative searching. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 509-517. </pages>
Reference-contexts: We also studied the performance of the algorithm on actual scenes: the fifth floor model of the Berkeley Soda Hall building (Soda), and a city database from Viewpoint Data-Labs (City). Though we described the algorithm in terms of octrees, the actual implementation used kD-trees <ref> [4] </ref>, a similar hierarchical data structure. For these experiments, the objects are just single polygons. The height of the oc-tree containing the polygons and the number of occluders (k) are inputs to the program; these were chosen to achieve interactive frame rates.
Reference: [5] <author> Bern, M., Dobkin, D., Eppstein, D., and Gross-man, R. </author> <title> Visibility with a Moving Point of View. </title> <booktitle> Algo-rithmica 11 (1994), </booktitle> <pages> 360-378. </pages>
Reference-contexts: Conservative visibility has also been used in [14] to design an optimal algorithm for determining visibility in a scene containing only rectangles with sides parallel to the x and y axes. Exact visibility algorithms have also been developed for viewpoints moving along pre-specified paths (e.g., lines <ref> [18, 5] </ref>). The hierarchical z-buffer algorithm [13] makes some use of temporal coherence by maintaining a list of polygons that are visible from the current viewpoint. For the next viewpoint, the algorithm draws polygons from this list first.
Reference: [6] <author> Clarkson, K. L. </author> <title> New Applications of Random Sampling in Computational Geometry. </title> <booktitle> Discrete Computational Geometry 2 (1987), </booktitle> <pages> 195-222. </pages>
Reference-contexts: As noted in Section 2, computing all possible cells is prohibitively expensive. However, it is possible to identify a subset of planes (called relevant planes) which is guaranteed to contain those planes which define the arrangement cell. 1 Even with an efficient data structure such as that in <ref> [6] </ref>, this prospect is impractical due to the space requirement. Also, as we describe, not all of these O (n 2 ) planes are relevant. 3 In this section, we consider the occlusion characteristics of two convex polyhedra.
Reference: [7] <author> Coorg, S., and Teller, S. </author> <title> A Spatially and Temporally Coherent Object Space Visibility Algorithm. </title> <type> Tech. Rep. </type> <institution> TM-546, Laboratory for Computer Science, MIT, </institution> <year> 1996. </year>
Reference-contexts: An alternate approach to this problem, using dynamically chosen sets of connected polygons to perform visibility culling, and caching across viewpoints to exploit temporal coherence is presented in <ref> [7] </ref>. This algorithm tends to have a better response to occasional "jumps" in the movement of the observer, albeit at the expense of performing slightly worse for smooth motion of the observer.
Reference: [8] <author> Crow, F. C. </author> <title> Shadow Algorithms For Computer Graphics. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '77) 11, 2 (1977), </volume> <pages> 242-248. </pages>
Reference-contexts: In other words, the algorithm visits only those nodes T in the octree whose visibility status is different from T 's parent (Figure 6-a). The region of space occluded by the occluder is its shadow volume <ref> [8] </ref>. If the number of octree leaves is m, the worst-case complexity of this algorithm is fi (m), that is, the algorithm might make fi (m) constant-time occlusion tests without reporting any occlusion relations.
Reference: [9] <editor> Edelsbrunner, H., Brauer, E. W., Rozenberg, G., and Salomaa, A. </editor> <booktitle> Algorithms in Combinatorial Geometry. EATCS Monographs on Theoretical Computer Science, </booktitle> <year> 1987. </year>
Reference-contexts: This observation immediately leads to a naive algorithm for tracking visibility changes. First, the algorithm generates planes formed by all pairs of scene vertices and edges. Using these planes, it divides 3-dimensional space into an arrangement of cells (see, e.g., <ref> [9] </ref>). Then, the algorithm associates with each cell the set of polygons visible from the cell, and associates cell boundaries with changes in the visibility set. Such a data structure is a "linearized" version of an aspect graph [12, 19]. <p> The UpdateEye operation would make fi (p) plane checks for each new viewpoint. An alternative would be to construct the arrangement of the planes in the set. Using this data structure, the operation UpdateEye is very efficient, requiring only fi (k) time if k planes are crossed <ref> [9] </ref>. However, the operations Insert and Delete take fi (p 2 ) time. Since these operations occur at least as frequently as the UpdateEye operation, maintaining an arrangement would be impractical in our application. Also, the fi (p 3 ) storage cost quickly becomes prohibitive.
Reference: [10] <author> Funkhouser, T., S equin, C., and Teller, S. </author> <title> Management of Large Amounts of Data in Interactive Building Walkthroughs. </title> <booktitle> In Proc. 1992 Workshop on Interactive 3D Graphics (1992), </booktitle> <pages> pp. 11-20. </pages>
Reference-contexts: The challenge, of course, is to produce a useful tight upper bound on the visible polygons. This idea of conservative visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 23, 10] </ref>. The idea in [23, 10] is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell, eye-to-cell, and eye-to-object visibility can be used to bound exact visibility from above. <p> The challenge, of course, is to produce a useful tight upper bound on the visible polygons. This idea of conservative visibility has been exploited to design fast architectural walkthrough systems [1, 23, 10]. The idea in <ref> [23, 10] </ref> is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell, eye-to-cell, and eye-to-object visibility can be used to bound exact visibility from above.
Reference: [11] <author> Gigus, Z., Canny, J., and Seidel, R. </author> <title> Efficiently Computing and Representing Aspect Graphs of Polyhedral Objects. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence 13, </journal> <volume> 6 (1991), </volume> <pages> 542-551. </pages>
Reference-contexts: The well-known aspect graph encodes a representation of exact visibility for every qualitatively distinct region of viewpoints <ref> [19, 12, 11] </ref>. One drawback of this approach is that the visible portion of the scene may have higher complexity than the input scene itself a scene with n polygons can have a visible portion of size fi (n 2 ).
Reference: [12] <author> Gigus, Z., and Malik, J. </author> <title> Computing the Aspect Graph for Line Drawings of Polyhedral Objects. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence 12, </journal> <volume> 2 (1990), </volume> <pages> 113-122. </pages>
Reference-contexts: The well-known aspect graph encodes a representation of exact visibility for every qualitatively distinct region of viewpoints <ref> [19, 12, 11] </ref>. One drawback of this approach is that the visible portion of the scene may have higher complexity than the input scene itself a scene with n polygons can have a visible portion of size fi (n 2 ). <p> Under Definition 1, there is only one kind of visual event that in which the projection of a vertex of the scene lies in the projection of an edge of the scene (Figure 2). This event is called a vertex-edge or VE event in <ref> [19, 12] </ref>. <p> Then, the algorithm associates with each cell the set of polygons visible from the cell, and associates cell boundaries with changes in the visibility set. Such a data structure is a "linearized" version of an aspect graph <ref> [12, 19] </ref>. Such a data structure could be used in an interactive setting as follows. For some initial viewpoint, the arrangement cell containing the viewpoint is located, and the visible polygons associated with that cell are reported. <p> The naive algorithm can be modified to (implicitly) construct and (explicitly) examine only these cells, greatly reducing its storage and time complexity. Finally, we reiterate that any algorithm that maintains exact visibility must also consider EEE events, in which three scene edges meet at a single image point <ref> [12, 19] </ref>. A data structure analogous to the one above, but incorporating EEE events, would have to consider fi (n 3 ) triples of edges, and an induced arrangement of fi (n 9 ) cells.
Reference: [13] <author> Greene, N., Kass, M., and Miller, G. </author> <title> Hierarchical Z-Buffer Visibility. </title> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, </booktitle> <year> 1993 (1993), </year> <pages> pp. 231-240. </pages>
Reference-contexts: Exact visibility algorithms have also been developed for viewpoints moving along pre-specified paths (e.g., lines [18, 5]). The hierarchical z-buffer algorithm <ref> [13] </ref> makes some use of temporal coherence by maintaining a list of polygons that are visible from the current viewpoint. For the next viewpoint, the algorithm draws polygons from this list first. The contents of the hierarchical z-buffer can then be used to cull invisible polygons.
Reference: [14] <author> Grove, E., Murali, T. M., and Vitter, J. </author> <title> The Object Complexity Model for Hidden-Surface Elimination. </title> <booktitle> In Proc. 7th Canad. Conf. </booktitle> <publisher> Comput. Geom. </publisher> <address> (Quebec City, Canada, </address> <year> 1995), </year> <pages> pp. 273-278. </pages>
Reference-contexts: Though this method eliminates most invisible polygons in architectural models, its generalization to models with less apparent cell structure seems difficult. Conservative visibility has also been used in <ref> [14] </ref> to design an optimal algorithm for determining visibility in a scene containing only rectangles with sides parallel to the x and y axes. Exact visibility algorithms have also been developed for viewpoints moving along pre-specified paths (e.g., lines [18, 5]).
Reference: [15] <author> Hubschman, H., and Zucker, S. W. </author> <title> Frame to Frame Coherence and the Hidden Surface Computation: Constraints for a Convex World. </title> <journal> ACM Trans. on Graphics (USA) 1 (Apr. </journal> <year> 1982), </year> <pages> 129-162. </pages>
Reference-contexts: Such queries are not efficiently supported in most graphics hardware, and simulating the z-buffer in software involves significant overhead. Because it operates in image space, this algorithm is also susceptible to aliasing artifacts. A temporally coherent visibility algorithm for scenes comprised only of convex objects is presented in <ref> [15] </ref>. The algorithm is complex, as it computes exact visibility, and no implementation is described. Our algorithm represents an advance over existing efforts in the following respects. First, our construction of imminent visual events enables us to avoid checking for events that are unlikely to occur in the near future.
Reference: [16] <author> McKenna, M. </author> <title> Worst-case Optimal Hidden Surface Removal. </title> <journal> ACM Transactions on Graphics 6, </journal> <volume> 1 (1987), </volume> <pages> 19-28. </pages>
Reference-contexts: Thus, there is ample spatial and temporal coherence to be exploited in most such applications. 1.1 Visibility Algorithms Given a viewpoint and a polyhedral scene, the problem of computing the exact visibility, i.e., computing an exact description of the visible portions of the scene, has been extensively researched <ref> [22, 16, 17] </ref>. Due to the availability of cheap memory, the simple depth-buffer algorithm, typically implemented in hardware [2], is widely used. This algorithm resolves visibility at each pixel.
Reference: [17] <author> Mulmuley, K. </author> <title> An Efficient Hidden-Surface Removal Algorithm, I. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '89) 23, 3 (1989), </volume> <pages> 379-388. </pages>
Reference-contexts: Thus, there is ample spatial and temporal coherence to be exploited in most such applications. 1.1 Visibility Algorithms Given a viewpoint and a polyhedral scene, the problem of computing the exact visibility, i.e., computing an exact description of the visible portions of the scene, has been extensively researched <ref> [22, 16, 17] </ref>. Due to the availability of cheap memory, the simple depth-buffer algorithm, typically implemented in hardware [2], is widely used. This algorithm resolves visibility at each pixel.
Reference: [18] <author> Mulmuley, K. </author> <title> Hidden Surface Removal with Respect to a Moving View Point. </title> <booktitle> In Proceedings of the Twenty Third Annual ACM Symposium on Theory of Computing (New Orleans, </booktitle> <address> Louisiana, </address> <month> 6-8 May </month> <year> 1991), </year> <pages> pp. 512-522. </pages>
Reference-contexts: Conservative visibility has also been used in [14] to design an optimal algorithm for determining visibility in a scene containing only rectangles with sides parallel to the x and y axes. Exact visibility algorithms have also been developed for viewpoints moving along pre-specified paths (e.g., lines <ref> [18, 5] </ref>). The hierarchical z-buffer algorithm [13] makes some use of temporal coherence by maintaining a list of polygons that are visible from the current viewpoint. For the next viewpoint, the algorithm draws polygons from this list first.
Reference: [19] <author> Plantinga, W., and Dyer, C. </author> <title> Visibility, Occlusion, and the Aspect Graph. </title> <booktitle> Int. J. Computer Vision 5, 2 (1990), </booktitle> <pages> 137-160. </pages>
Reference-contexts: The well-known aspect graph encodes a representation of exact visibility for every qualitatively distinct region of viewpoints <ref> [19, 12, 11] </ref>. One drawback of this approach is that the visible portion of the scene may have higher complexity than the input scene itself a scene with n polygons can have a visible portion of size fi (n 2 ). <p> Under Definition 1, there is only one kind of visual event that in which the projection of a vertex of the scene lies in the projection of an edge of the scene (Figure 2). This event is called a vertex-edge or VE event in <ref> [19, 12] </ref>. <p> Then, the algorithm associates with each cell the set of polygons visible from the cell, and associates cell boundaries with changes in the visibility set. Such a data structure is a "linearized" version of an aspect graph <ref> [12, 19] </ref>. Such a data structure could be used in an interactive setting as follows. For some initial viewpoint, the arrangement cell containing the viewpoint is located, and the visible polygons associated with that cell are reported. <p> The naive algorithm can be modified to (implicitly) construct and (explicitly) examine only these cells, greatly reducing its storage and time complexity. Finally, we reiterate that any algorithm that maintains exact visibility must also consider EEE events, in which three scene edges meet at a single image point <ref> [12, 19] </ref>. A data structure analogous to the one above, but incorporating EEE events, would have to consider fi (n 3 ) triples of edges, and an induced arrangement of fi (n 9 ) cells.
Reference: [20] <author> Preparata, F. P., and Shamos, M. I. </author> <title> Computational Geometry: an Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Separating planes of two convex polyhedra are planes formed by an edge of one polyhedron and a vertex of the other such that the polyhedra lie on opposite sides of the plane <ref> [20] </ref>. Supporting planes are similar, except that both polyhedra lie on the same side of the plane. Consider the occlusion relationship of two polyhedra A and B shown in Figure 3-a. <p> Given two objects and a viewpoint, the set of relevant planes can be computed in fi (n + m) time, by combining an algorithm for identifying supporting and separating planes of two convex polyhedra with an algorithm for computing the intersection of two convex 2-dimensional polygons <ref> [20] </ref>. When visual events occur due to a change in the viewpoint, the algorithm must update either the visibility or the set of relevant planes or both. Using a winged-edge data structure [3], we can update the visibility using only "local" computation.
Reference: [21] <author> Samet, H. </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, and GIS. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: This section describes an efficient hierarchical method for maintaining these relationships. Consider the problem of identifying visible objects in the presence of a single occluder. One efficient way to achieve this is by organizing all objects in an octree data structure <ref> [21] </ref>.
Reference: [22] <author> Sutherland, I. E., Sproull, R. F., and Schu-macker, R. A. </author> <title> A Characterization of Ten Hidden-Surface Algorithms. </title> <journal> Computing Surveys 6, </journal> <volume> 1 (1974), </volume> <pages> 1-55. </pages>
Reference-contexts: Thus, there is ample spatial and temporal coherence to be exploited in most such applications. 1.1 Visibility Algorithms Given a viewpoint and a polyhedral scene, the problem of computing the exact visibility, i.e., computing an exact description of the visible portions of the scene, has been extensively researched <ref> [22, 16, 17] </ref>. Due to the availability of cheap memory, the simple depth-buffer algorithm, typically implemented in hardware [2], is widely used. This algorithm resolves visibility at each pixel.
Reference: [23] <author> Teller, S., and S equin, C. H. </author> <title> Visibility Preprocessing for Interactive Walkthroughs. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '91) 25, 4 (1991), </volume> <pages> 61-69. 10 </pages>
Reference-contexts: The challenge, of course, is to produce a useful tight upper bound on the visible polygons. This idea of conservative visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 23, 10] </ref>. The idea in [23, 10] is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell, eye-to-cell, and eye-to-object visibility can be used to bound exact visibility from above. <p> The challenge, of course, is to produce a useful tight upper bound on the visible polygons. This idea of conservative visibility has been exploited to design fast architectural walkthrough systems [1, 23, 10]. The idea in <ref> [23, 10] </ref> is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell, eye-to-cell, and eye-to-object visibility can be used to bound exact visibility from above. <p> The efficacy of the culling algorithm, as defined by the fraction of truly invisible polygons culled by the algorithm, is shown in Table 6. Note that the algorithm is effective in culling away a significant fraction of the scene, even for models like City, where the cell/portal technique of <ref> [23] </ref> is less effective. 7 Conclusions and Future Work This paper described a visibility algorithm that exploits the temporal coherence in the motion of an observer through a geometric model. Casting the algorithm as one of conservative visibility maintenance greatly simplified its design, and reduced its time and storage complexity.
References-found: 23

