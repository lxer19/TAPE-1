URL: http://www.cs.toronto.edu/~paige/Writing/fmi_facs.ps.gz
Refering-URL: http://www.cs.toronto.edu/~paige/use.html
Root-URL: 
Title: Formal Aspects of  Heterogeneous Notations for Formal Method Integration  
Author: Richard F. Paige 
Keyword: formal method integration; heterogeneous specification; refinement; formal methods  
Address: Toronto, Toronto, Ontario, M5S 3G4, Canada.  
Affiliation: 1 Department of Computer Science, University of  
Note: c  
Pubnum: Computing  
Email: paige@cs.toronto.edu  
Date: (1997) 3: 1-000  1997 BCS  
Abstract: We describe an approach for defining and making use of compositions of partial specifications written in different formal languages. The technique provides a first step towards integrating formal methods that use the notations. We discuss the integration process and consider how refinement can occur in such a setting. We present several examples of formal heterogeneous specifications, and two examples of integrated formal method usage based on such an idea. 
Abstract-found: 1
Intro-found: 1
Reference: [Bac78] <author> R.J.R. </author> <title> Back.: On the correctness of refinement steps in program development, </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, University of Helsinki, </institution> <year> 1978. </year>
Reference-contexts: Its primary aim is to present imperative pro 6 R. F. Paige gram construction as a collection of part-abstract, part-operational program fragments. Each fragment is related to a predecessor program fragment by a mathematical notion of refinement. The refinement calculus was first presented by Back <ref> [Bac78] </ref> and was subsequently reinvented by Morgan [Mor94] and others (we consider only Morgan's version in this paper).
Reference: [BaW89] <author> R.J.R. Back and J. von Wright.: </author> <title> A Lattice-Theoretical Basis for a Specification Language. In Mathematics of Program Construction, </title> <publisher> LNCS 375, Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Definition 8. (<ref> [BaW89] </ref>) An angelic specification is constructed from the angelic update fQ 0 g (for predicates Q 0 ), which satisfies wp (fQ 0 g; R 0 ) b= 9 0 * (Q 0 ^ R 0 ) for all predicates R 0 . [BaW89] contains a discussion on angelicism in general, and shows how any angelic specification can be constructed from the angelic update.
Reference: [BSC94] <author> R. Barden, S. Stepney, and D. Cooper.: </author> <title> Z in Practice, </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: of all words in the text file. wordSeq : seq CHAR ! seq word 8 d : seq CHAR; s : seq word * (wordSeq d = s) , ((d - punctWSpace = a = s) ^ (ran s = lexicon d )) (- is the anti-filter function defined in <ref> [BSC94] </ref>. d - punctWSpace is a sequence containing those characters of d that are not in the set punctWSpace.) We provide a schema that updates the statistics for a given text document.
Reference: [BoH94] <author> J. Bowen and M. </author> <title> Hinchey.: Ten Commandments of Formal Methods, </title> <institution> Oxford University Computing Laboratory Technical Monograph, </institution> <year> 1994. </year>
Reference-contexts: A combination of notations may also be used to write simpler specifications than via the use of one notation [ZaM93]. * Ease of expression: some specification languages are not as useful as others when used to describe particular classes of systems <ref> [BoH94] </ref>. For example, trying to specify a concurrent system in Z might not be as appropriate as using CSP [Hoa85]. The use of CSP might not be appropriate for specifying state-based aspects of a system, whereas Z may be of use.
Reference: [BoS93] <author> J. Bowen and V. Stavridou.: </author> <title> The Industrial Take-up of Formal Methods in Safety-Critical and Other Areas: A Perspective, </title> <booktitle> Proc. FME `93: Industrial-strength Formal Methods, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [BrN92] <author> S.M. Brien and J.E. </author> <title> Nicholls.: Z Base Standard 1.0, </title> <type> Technical Monograph TM-PRG-107, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, Oxford, UK, </institution> <month> November </month> <year> 1992. </year>
Reference: [Bro95] <author> M. Broy.: </author> <title> Mathematics of Software Engineering, Mathematics of Program Construction, </title> <publisher> LNCS 947, Springer-Verlag, </publisher> <year> 1995. </year>
Reference: [Bry89] <author> T. Bryant.: </author> <title> Structured methodologies and formal notations: developing a framework for synthesis and investigation, </title> <booktitle> Proc. ZUM `89: Z Users Meeting, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [CaW95] <author> A. Cavalcanti and J. Woodcock.: </author> <title> A weakest precondition semantics for Z, </title> <type> Technical Report PRG-TR-24-95, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, Oxford, UK, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: The mapping from a Z schema to a refinement calculus specification statement is quite straightforward; it can be carried out if the Z schema represents a system operation <ref> [CaW95] </ref>. The Z schema Op b= [ S ; i? : I ; o! : O j pred ]; can be mapped into a specification statement using ZToSS .
Reference: [COR95] <author> J. Crow, S. Owre, J. Rushby, N. Shankar, and M. Srivas.: </author> <title> A Tutorial Introduction to PVS, </title> <booktitle> Proc. Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <title> Heterogeneous Notations for Formal Method Integration 41 </title>
Reference-contexts: Formality in software development is used for many reasons: for its precision in capturing requirements [DaH94]; for writing system specifications [Spi89]; for safety- or economically-critical systems development ([BoS93], [GCR94]); for reducing costs, e.g., as in the CICS project [HoK92]; or for animation [DiL94] or mechanical checking of properties <ref> [COR95] </ref>. The activities of integrating formality into existing practice, and determining how to best use formality in software development, are topics of continuing research ([WiZ92], [PWM93], [SFD92], [Web93]).
Reference: [DaH94] <author> A.M. Davis and P. Hsia.: </author> <title> Giving Voice to Requirements Engineering, </title> <journal> IEEE Software, </journal> <month> March </month> <year> 1994. </year>
Reference-contexts: 1. Introduction An indication of a maturing discipline is in the increasing use of rigour and formality in its methods and processes ([Bro95], [Hoa94]). Formality in software development is used for many reasons: for its precision in capturing requirements <ref> [DaH94] </ref>; for writing system specifications [Spi89]; for safety- or economically-critical systems development ([BoS93], [GCR94]); for reducing costs, e.g., as in the CICS project [HoK92]; or for animation [DiL94] or mechanical checking of properties [COR95].
Reference: [DeM82] <author> T. DeMarco.: </author> <title> Controlling Software Projects: Management, Measurement, and Estimation, </title> <publisher> Yourdon Press, </publisher> <year> 1982. </year>
Reference-contexts: Your problem is not likely to be a method X problem or a method Y problem. It's much more likely to be a method X problem and a method Y problem and a method W and a method Z problem as well, no doubt. And to quote DeMarco <ref> [DeM82] </ref>: The idea that a single method should govern even two different projects is highly suspect: the differences between projects are much more important than the similarities. * It is a technique that can be used to gradually insinuate new methods into existing practice.
Reference: [DiL94] <author> J. Dick and J. Loubersac.: </author> <title> Integrating Structured and Formal Methods: A Visual Approach to VDM, </title> <booktitle> Proc. FME `94: Industrial-strength Formal Methods, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Formality in software development is used for many reasons: for its precision in capturing requirements [DaH94]; for writing system specifications [Spi89]; for safety- or economically-critical systems development ([BoS93], [GCR94]); for reducing costs, e.g., as in the CICS project [HoK92]; or for animation <ref> [DiL94] </ref> or mechanical checking of properties [COR95]. The activities of integrating formality into existing practice, and determining how to best use formality in software development, are topics of continuing research ([WiZ92], [PWM93], [SFD92], [Web93]).
Reference: [Dij76] <author> E.W. Dijkstra.: </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: Informal text is also included, describing the intended meaning of the specification parts and the whole. 2.2. Weakest preconditions Weakest preconditions (usually abbreviated wp) are predicate transformers; they were introduced in Dijkstra <ref> [Dij76] </ref>. When using wp in programming, the designer begins with a formal specification of what is to be done; this is typically given in the form of a pre- and postcondition.
Reference: [FGH93] <author> A. Finkelstein, D. Gabbay, A. Hunter, J. Kramer, and B. Nuseibeh.: </author> <title> Inconsistency Handling in Multiperspective Specifications, </title> <booktitle> Proc. European Software Engineering Conference `93, </booktitle> <publisher> LNCS 717, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: There are likely other criteria that can be accentuated by using a heterogeneous framework. There are many different frameworks we might present (examples in the literature include [ZaJ93] and <ref> [FGH93] </ref>). We create a framework by translation. For every formal notation of interest, we present a semantic mapping into a second formal notation of interest. By doing so, we present a set of rules which describe how to translate a heterogeneous specification into an equivalent-as-possible homogeneous specification.
Reference: [GCR94] <author> S. Gerhart, D. Craigen, and D. Ralston.: </author> <title> Experience with formal methods in critical systems, </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1994. </year>
Reference-contexts: Formality in software development is used for many reasons: for its precision in capturing requirements [DaH94]; for writing system specifications [Spi89]; for safety- or economically-critical systems development ([BoS93], <ref> [GCR94] </ref>); for reducing costs, e.g., as in the CICS project [HoK92]; or for animation [DiL94] or mechanical checking of properties [COR95]. The activities of integrating formality into existing practice, and determining how to best use formality in software development, are topics of continuing research ([WiZ92], [PWM93], [SFD92], [Web93]).
Reference: [Gri81] <editor> D. Gries.: </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: This specification is then manipulated in an attempt to determine a program that implements it. wp can be used to verify these manipulation steps, and to help in calculating programs from specifications. Weakest preconditions are not particularly well-suited themselves for use as a program design calculus (Gries <ref> [Gri81] </ref> uses them for calculation), but they do form the basis for instances of such calculi, e.g., Morgan's refinement calculus. 2.3. Morgan's refinement calculus The refinement calculus is a formal method for the derivation and development of programs from specifications. Its primary aim is to present imperative pro 6 R.
Reference: [Gri90] <author> D. Gries.: </author> <title> Lectures on data refinement, Programming and Mathematical Method, </title> <booktitle> International Summer School, NATO ASI Series Volume 88, </booktitle> <year> 1990. </year>
Reference-contexts: The formal definition of data refinement is based upon this invariant. Data refinement has been studied extensively in a homogeneous setting; for example, see [Mor88] and <ref> [Gri90] </ref>. Several different definitions have also been provided, but a common one (used in [Mor94]) is based on weakest preconditions: Definition 17. ([Gri90]) Let a be a list of "abstract" variables, c be a list of "concrete" variables, and I the coupling invariant relating the two. <p> ) wp (Sc; (9 a 0 * I 0 ^ R 0 )) Data refinement (in all settings) has the same complication as satisfiability checking (in all settings): it cannot in general be carried out by parts, because the relation of data refinement is not monotonic over all specification combinators <ref> [Gri90] </ref>. This is an artifact of data refinement itself. To perform data refinement in a heterogeneous setting, we have several options. * Translate all specification parts into one notation, and carry out data refine ment in the homogeneous domain. <p> F. Paige * Determine a rule-set that describes when partwise data refinement can occur. A rule-set as mentioned above is briefly described in [Pai97]. It provides rules that show how to data refine specifications in one language by specifications in a second language, and generalizes rules from <ref> [Gri90] </ref> that show how to data refine heterogeneous specifications by parts. Data refinement is demonstrated in Section 7.2. 7. Use of integrated formal methods In this section, we examine how to use integrated formal methods in writing specifications and in developing implementations.
Reference: [GuH91] <author> J.V. Guttag and J.J. Horning.: LCL: </author> <title> A Larch interface language for C, </title> <type> Technical Report 74, </type> <institution> DEC Systems Research Center, </institution> <month> July </month> <year> 1991. </year>
Reference: [GuH93] <author> J.V. Guttag and J.J. Horning.: </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The refinement relation enjoys various properties that allow specifications to be refined by parts, steps, and cases. As well, specifications can be combined using the familiar operators of boolean theory, along with all the usual program combinators. 2.5. Larch Larch <ref> [GuH93] </ref> takes a two-tiered approach to the formal specification of software components. A Larch specification has components in two different languages: * one language designed for a specific programming language (a Larch Be havioural Interface Language); * one language independent of any programming language (the Larch Shared Language). <p> In particular, we add LCL <ref> [GuH93] </ref>, the interface language for C, to the framework; other interface languages can be handled similarly.
Reference: [Hal90] <author> A. Hall.: </author> <title> Seven Myths of Formal Methods, </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1990. </year>
Reference: [Ham94] <author> J. Hammond.: </author> <title> Producing Z Specifications from Object-Oriented Analysis, </title> <booktitle> Proc. Eighth Z User Meeting, </booktitle> <address> Cambridge, </address> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: software engineering context is a problem of growing research interest for several reasons. * It provides a systematic way for engineering or adapting a method to conform to the developers' thinking and abilities [HeO92]. * Method integration has been used in practice, at Rolls-Royce [Hil91], BT [SFD92], Philips [Kro93], Westinghouse <ref> [Ham94] </ref>, and AT&T [ZaJ95]. Many of the integrations used in these organizations are based on ad-hoc techniques.
Reference: [Hay95] <author> I. Hayes.: Specifiability, </author> <booktitle> slides from WG2.3 Meeting, </booktitle> <address> Ithaca, New York, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: That is, particular notations can express specifications for which there is no semantic equivalent in a different language. Heterogeneous Notations for Formal Method Integration 13 Fig. 2. Definitions for ordering on translations Language expressiveness can be compared in terms of translatability (see <ref> [Hay95] </ref> for an alternative approach.) The exact definition that we use is as follows. Definition 9. Let f be a translation from a language W to a language Y , i.e., f : W ! Y .
Reference: [Heh93] <author> E.C.R. Hehner.: </author> <title> A Practical Theory of Programming, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A specification statement S is refined by a specification statement T (written S v T ) if 8 R * wp (S ; R) ) wp (T ; R): 2.4. Predicative programming Predicative programming is due to Hehner <ref> [Heh93] </ref>. It is a program design calculus like the refinement calculus, but treats programs as specifications. With this approach, programs and specifications are predicates on pre- and poststate (final values of variables are annotated with a dash; initial values of variables are undecorated). Refinement is just boolean implication. <p> Predicates and specification statements Let frame w * P be a predicate specification <ref> [Heh93] </ref> not involving time, i.e., there will be no references to the time variables t and t 0 in P . The developer must specify the frame w . We give two mappings for predicates into specification statements. 1. <p> w : [ 8 t * 9 n : nat * 8 w 0 * P ) t 0 t + n; 9 t * 9 t 0 * P ^ t 0 t ]: The precondition in the translation result is the exact precondition for termination due to Norvell <ref> [Heh93] </ref>, while the postcondition is existentially quantified to eliminate time variable references. Before discussing the translations from specification statements to predicates, we make a definition. Informally, an angelic specification aborts only when there is no other choice 1 . Definition 8 states this more precisely. <p> specification statement w : [ pre; post ] is translated using SSToTimedPred : SSToTimedPred (w : [ pre; post ]) b= frame w ; t * (pre ) post ^ t 0 t): After the translation, the developer can add extra time-related specificands as necessary, e.g., as is done in <ref> [Heh93] </ref>. 3.2. Refinement calculus and weakest preconditions The mapping from specification statements to weakest precondition predicate transformers, given as SSToWp, is well-known from Morgan [Mor94]. <p> (emptree,x,emptree)) == true isheap (graft (u,x,v)) == x&lt;=root (u) /" x&lt;=root (v) /" isheap (u) /" isheap (v); insert (emptree,y) == graft (emptree,y,emptree); insert (graft (u,x,v),y) == if y&lt;=x then graft (insert (v,x),y,u) else graft (insert (v,y),x,u); We use the above LSL trait in combination with the predicate notation of <ref> [Heh93] </ref> to write a heterogeneous specification. In particular, we specify, using the predicate notation of [Heh93], the heap operations of initialization, search, and delete. Initialization of a heap t is particularly straightforward. <p> /" isheap (v); insert (emptree,y) == graft (emptree,y,emptree); insert (graft (u,x,v),y) == if y&lt;=x then graft (insert (v,x),y,u) else graft (insert (v,y),x,u); We use the above LSL trait in combination with the predicate notation of <ref> [Heh93] </ref> to write a heterogeneous specification. In particular, we specify, using the predicate notation of [Heh93], the heap operations of initialization, search, and delete. Initialization of a heap t is particularly straightforward. Init b= t 0 = emptree Search through a heap t for an item x is identical to the standard search operation on a partially-ordered tree. <p> We declare ListToHeap : [flint] ! tree ! tree; which transforms a list of integers into a heap of integers. Its definition is as follows. Let t be any tree, L any integer list, and i any integer. (+ is list concatenation from <ref> [Heh93] </ref>.) ListToHeap ([nil ]; t) = t ListToHeap ([i ] + L; t ) = ListToHeap (L; insert (t ; i )) The heap will be balanced in this operation because of the swapping that takes place in insert. <p> Rule 5.16. If (P ^ 9 w 0 * pred ) ) pred , then X ( frame w * P. Proof. By translation of schemas into predicates, Definition 7, and the Law of Portation <ref> [Heh93] </ref>. Rule 5.17. If pre ) (9 w 0 * pred ^ 8 w 0 * post ( pred ) then T v X and T ( X . Rule 5.18. <p> We consider two examples. * A small refinement combining the use of Morgan's refinement calculus and Hehner's predicative programming in refining a specification that uses "inde pendent composition" <ref> [Heh93] </ref>. * A more complicated database example that integrates a Z specification style with predicative programming. Data refinement and procedural refinement are demonstrated in some detail. 7.1. Independent composition example Predicative programming, as described in [Heh93], has features for constructing specifications that can be implemented by executing processes in parallel. <p> refinement calculus and Hehner's predicative programming in refining a specification that uses "inde pendent composition" <ref> [Heh93] </ref>. * A more complicated database example that integrates a Z specification style with predicative programming. Data refinement and procedural refinement are demonstrated in some detail. 7.1. Independent composition example Predicative programming, as described in [Heh93], has features for constructing specifications that can be implemented by executing processes in parallel. These features can be generalized to a heterogeneous setting. We show how a heterogeneous specification using independent composition can be written and refined. <p> The k (independent composition) operator is defined in <ref> [Heh93] </ref>. To verify that the specification is satisfiable, we use Definition 14, since k is a predicate combinator. <p> be refined in the obvious way: i 6= #L ) s 0 = min (s; MIN j : i ; ::#L * Lj ) ( if Li &lt; s then s := Li else ok: i := i + 1 The resulting implementation is heterogeneous (involving the programming language of <ref> [Heh93] </ref> and Dijkstra's guarded command language) and can easily be transliterated to a homogeneous form in either programming language subset. 7.2. Database example We specify and implement (part of) a small chemicals database for a supply house. <p> sort b= 8 i ; j : 0; ::MAX * (i j ) L 0 (i):name L 0 (j ):name) ^ perm L L 0 and perm L L 0 is a predicate that is true when L and L 0 are list permutations (x is the bunch constructor from <ref> [Heh93] </ref>). We check Inv for satisfiability. Inv is satisfiable if: createlist: (9 L 0 * sort): The sort is satisfiable (this is straightforward to verify). <p> if i &gt; N ! r ! := NO NAME [] i N ! amt [i ] := amt [i ] + a?; r ! := SUCCESS [] a? &lt; 0 ! r ! := NEGATIVE fi The Inv predicate can be data refined according to the technique demonstrated in <ref> [Heh93] </ref>. The implementer's variables are chem and amount ; the new variables are cdb and amt . <p> + 1 * cdb (i) = c ^ amt (i ) &gt; 0): 8 i ; j : 0; ::N * (i j ) L 0 (i ):name L 0 (j ):name) ^ perm L L 0 The second part of the dependent composition can be refined as demonstrated in <ref> [Heh93] </ref>; we concentrate on the data-refined createlist specification.
Reference: [Heh95] <author> E.C.R. Hehner.: </author> <title> Abstractions of Time. A Classical Mind: Essays in Honour of C.A.R. Hoare, </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: In the specification statement notation, a precondition on termination is explicitly given, while in the predicate notation termination is a special case of timing <ref> [Heh95] </ref>; we say nothing about time in PredToSS 1 . 2.
Reference: [HeM88] <author> E.C.R. Hehner and A.J. Malton.: </author> <title> Termination Conventions and Comparative Semantics, </title> <journal> Acta Informatica, </journal> <month> 25 </month> <year> (1988). </year>
Reference-contexts: In presenting the translations, we make two assumptions: * we assume that throughout this paper all notations use the unprimed-primed convention of Z to represent initial and final variables, as was done in <ref> [HeM88] </ref>; * we assume the existence of a set of mappings that translate the standard types, type operations and constructors, programming language syntax, and function interfaces from one notation to another. 8 R. F. Paige Fig. 1. <p> SSToWp (w : [ pre; post ]) b= wp (w : [ pre; post ]; R 0 ) = pre ^ (8 w 0 * post ) R 0 ); The reverse transformation, given as function WpToSS , is somewhat more com plex and is derived from <ref> [HeM88] </ref>. WpToSS (wp (S ; R 0 )) b= w : [ wp (S ; true); (:wp (S ; w 0 6= w 0 ))[w 0 =w 0 ] ]; 1 Similarly, a demonic specification is miraculous whenever magic is one of its possible choices. 10 R. F. <p> Predicative programming and weakest preconditions It is possible to translate directly between predicative programming specifications and weakest preconditions; this result is due to Hehner and Malton <ref> [HeM88] </ref> (we reformulate the results in our context). <p> Refinement calculus: * havoc, i.e., terminating but otherwise arbitrary behaviour. havoc cannot be specified in predicates without an extension to include a termination convention <ref> [HeM88] </ref>. It is true in Z. * magic, i.e., terminating and establishing the impossible false. magic cannot be expressed in Z. It is represented by ? in predicates. * angelic specifications: cannot be expressed in predicates or Z.
Reference: [HeO92] <author> M. Heym and H. Osterle.: </author> <title> A Reference Model for Information Systems Development, </title> <booktitle> Proc. IFIP WG 8.2 Working Conference on the Impact of Computer Supported Technologies on Information Systems Development, </booktitle> <year> 1992. </year>
Reference-contexts: Method integration in a software engineering context is a problem of growing research interest for several reasons. * It provides a systematic way for engineering or adapting a method to conform to the developers' thinking and abilities <ref> [HeO92] </ref>. * Method integration has been used in practice, at Rolls-Royce [Hil91], BT [SFD92], Philips [Kro93], Westinghouse [Ham94], and AT&T [ZaJ95]. Many of the integrations used in these organizations are based on ad-hoc techniques.
Reference: [Hil91] <author> J.V. Hill.: </author> <title> Software development methods in practice, </title> <booktitle> Proc. Sixth Annual Conference on Computer Assurance, </booktitle> <year> 1991. </year>
Reference-contexts: Method integration in a software engineering context is a problem of growing research interest for several reasons. * It provides a systematic way for engineering or adapting a method to conform to the developers' thinking and abilities [HeO92]. * Method integration has been used in practice, at Rolls-Royce <ref> [Hil91] </ref>, BT [SFD92], Philips [Kro93], Westinghouse [Ham94], and AT&T [ZaJ95]. Many of the integrations used in these organizations are based on ad-hoc techniques.
Reference: [HiB95] <author> M. Hinchey and J. Bowen.: </author> <title> Applications of Formal Methods, </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference: [Hoa85] <author> C.A.R. Hoare.: </author> <title> Communicating Sequential Processes, </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: For example, trying to specify a concurrent system in Z might not be as appropriate as using CSP <ref> [Hoa85] </ref>. The use of CSP might not be appropriate for specifying state-based aspects of a system, whereas Z may be of use.
Reference: [Hoa94] <author> C.A.R. Hoare.: </author> <title> Unified Theories of Programming, </title> <type> Technical Paper, </type> <institution> Oxford Computing Laboratory, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: 1. Introduction An indication of a maturing discipline is in the increasing use of rigour and formality in its methods and processes ([Bro95], <ref> [Hoa94] </ref>). Formality in software development is used for many reasons: for its precision in capturing requirements [DaH94]; for writing system specifications [Spi89]; for safety- or economically-critical systems development ([BoS93], [GCR94]); for reducing costs, e.g., as in the CICS project [HoK92]; or for animation [DiL94] or mechanical checking of properties [COR95].
Reference: [HoK92] <author> I. Houston and S. King.: </author> <title> CICS Project report: experience and results for the use of Z in IBM, </title> <booktitle> Proc. 6th Annual Z Users Meeting, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Formality in software development is used for many reasons: for its precision in capturing requirements [DaH94]; for writing system specifications [Spi89]; for safety- or economically-critical systems development ([BoS93], [GCR94]); for reducing costs, e.g., as in the CICS project <ref> [HoK92] </ref>; or for animation [DiL94] or mechanical checking of properties [COR95]. The activities of integrating formality into existing practice, and determining how to best use formality in software development, are topics of continuing research ([WiZ92], [PWM93], [SFD92], [Web93]).
Reference: [ILR95] <editor> J. Iivari, K. Lyytinen, and M. Rossi (eds).: </editor> <booktitle> Advanced Information Systems Engineering, Proc. CAiSE `95, </booktitle> <publisher> LNCS 932, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: may force undesirable restrictions on expression, analysis, or the production of a solution [Kro93]. * The complexity of the engineering process|as well as user preferences in terms of both notation and development method|suggests that it is unrealistic to expect to have a standard method that perfectly conveys the process ([Kro93], <ref> [ILR95] </ref>). Our interest in methods and notations has focused on combining two or more methods into a potentially more useful whole; this is method integration [Kro93]. In this paper, we focus on a technique for integrating formal methods.
Reference: [Jac95] <author> M.A. Jackson.: </author> <title> Software Requirements and Specifications, </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: As Jackson <ref> [Jac95] </ref> says: For any realistic problem, you will need more than one method. You will have to see the problem as a complex of several overlapping problems. . . Your problem is not likely to be a method X problem or a method Y problem.
Reference: [Kin90] <author> S. King.: </author> <title> Z and the refinement calculus, VDM `90: VDM and Z Formal Methods in Software Development, </title> <publisher> LNCS 428, Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This assumes that the Z schema represents a system operation. 3.5. Z and the refinement calculus The final set of translations we describe are between Z and the refinement calculus. One direction of the translation has been noted in the past <ref> [Kin90] </ref>; we merely summarize this result here (with appropriate syntactic changes). The mapping from a Z schema to a refinement calculus specification statement is quite straightforward; it can be carried out if the Z schema represents a system operation [CaW95]. <p> The inputs to the operation are denoted by i ?, and the outputs by o!. inv is a state invariant obtained from the schema in the declaration of Op, and w consists of variables in S together with the operation outputs.) See <ref> [Kin90] </ref> for more details. <p> In a heterogeneous setting, there are strategies that we can use to help accomplish such a check. * Translate the heterogeneous specification into a homogeneous specification, and use one of Definitions 14-16. The translation procedure can be mecha nized. * Use translations (e.g., such as those presented in <ref> [Kin90] </ref> and [Pai97]) to map a heterogeneous specification into a form over which satisfiability checking Heterogeneous Notations for Formal Method Integration 29 can be done by parts. <p> This is an artifact of data refinement itself. To perform data refinement in a heterogeneous setting, we have several options. * Translate all specification parts into one notation, and carry out data refine ment in the homogeneous domain. This process is mechanizable. * Apply translations (e.g., as in <ref> [Kin90] </ref> or [Pai97]) and map a specification (part) into a form over which the data refinement relation is monotonic. * Use implicit compositions, assume each specification part represents a distinct system operation, and apply the appropriate notion of data refinement to the appropriate specification part. 30 R. F.
Reference: [Kro93] <author> K. Kronlof, ed.: </author> <title> Method Integration: Concepts and Case Studies, </title> <publisher> Wiley, </publisher> <year> 1993. </year>
Reference-contexts: A kernel of research has focused on the synthesis ([ILR95], Correspondence and offprint requests to: Richard F. Paige, Department of Computer Science, University of Toronto, Toronto, Ontario, M5S 3G4, Canada. 2 R. F. Paige <ref> [Kro93] </ref>, [SFD92]) of methodological and notational concepts. It is on this general theme that we focus in this paper. The point of view that we take is that no single instance of any method or notation is a panacea for software development. <p> To require a developer to use a single method (or notation) for a task may force undesirable restrictions on expression, analysis, or the production of a solution <ref> [Kro93] </ref>. * The complexity of the engineering process|as well as user preferences in terms of both notation and development method|suggests that it is unrealistic to expect to have a standard method that perfectly conveys the process ([Kro93], [ILR95]). <p> in terms of both notation and development method|suggests that it is unrealistic to expect to have a standard method that perfectly conveys the process (<ref> [Kro93] </ref>, [ILR95]). Our interest in methods and notations has focused on combining two or more methods into a potentially more useful whole; this is method integration [Kro93]. In this paper, we focus on a technique for integrating formal methods. We discuss this approach shortly, after describing method integration and its rationales in more detail. 1.1. <p> We discuss this approach shortly, after describing method integration and its rationales in more detail. 1.1. Method Integration Method integration is the activity of resolving existing incompatibilities between methods, so that they can be safely and effectively used together <ref> [Kro93] </ref>. <p> in a software engineering context is a problem of growing research interest for several reasons. * It provides a systematic way for engineering or adapting a method to conform to the developers' thinking and abilities [HeO92]. * Method integration has been used in practice, at Rolls-Royce [Hil91], BT [SFD92], Philips <ref> [Kro93] </ref>, Westinghouse [Ham94], and AT&T [ZaJ95]. Many of the integrations used in these organizations are based on ad-hoc techniques. Systematic and general techniques for method integration are required so as to simplify and formalize the activity of integration, and to avoid the potential for error associated with case-by-case solutions [Kro93]. * <p> Philips <ref> [Kro93] </ref>, Westinghouse [Ham94], and AT&T [ZaJ95]. Many of the integrations used in these organizations are based on ad-hoc techniques. Systematic and general techniques for method integration are required so as to simplify and formalize the activity of integration, and to avoid the potential for error associated with case-by-case solutions [Kro93]. * As the complexity of the problems being dealt with in software development continues to grow, it becomes increasingly more unlikely that one method will suffice for development. As Jackson [Jac95] says: For any realistic problem, you will need more than one method.
Reference: [LKP91] <author> P. Larsen, J. van Katwijk, N. Plat, K. Pronk, and H. Toetenel.: </author> <title> Towards an integrated combination of SA and VDM, </title> <booktitle> Proc. Methods Integration Workshop, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [Mor88] <author> C.C. Morgan.: </author> <title> Data refinement using miracles, </title> <journal> Information Processing Letters, </journal> <volume> 29(6), </volume> <month> December </month> <year> 1988. </year>
Reference-contexts: Larch LCL: cannot express havoc or angelic nondeterminism. 6. Larch LSL: cannot directly express state-based behaviour. The specifications in this catalogue are typically extreme (except for the case of LSL), and are all of questionable use in programming. See Morgan <ref> [Mor88] </ref> and Ward and Hayes [WaH91] for discussions on the utility of magic and angelicism, respectively. 4. Specification examples We give several small examples of formal heterogeneous specifications and consider their semantics. <p> The formal definition of data refinement is based upon this invariant. Data refinement has been studied extensively in a homogeneous setting; for example, see <ref> [Mor88] </ref> and [Gri90]. Several different definitions have also been provided, but a common one (used in [Mor94]) is based on weakest preconditions: Definition 17. ([Gri90]) Let a be a list of "abstract" variables, c be a list of "concrete" variables, and I the coupling invariant relating the two.
Reference: [Mor93] <author> C.C. Morgan.: </author> <title> The Refinement Calculus, and Literate Development, Formal Program Development, </title> <booktitle> IFIP TC2/WG2.1 State of the art report, </booktitle> <publisher> LNCS 755, Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Mor94] <author> C.C. Morgan.: </author> <title> Programming from Specifications, </title> <booktitle> Prentice-Hall, Second Edition, </booktitle> <year> 1994. </year>
Reference-contexts: F. Paige gram construction as a collection of part-abstract, part-operational program fragments. Each fragment is related to a predecessor program fragment by a mathematical notion of refinement. The refinement calculus was first presented by Back [Bac78] and was subsequently reinvented by Morgan <ref> [Mor94] </ref> and others (we consider only Morgan's version in this paper). <p> Refinement calculus and weakest preconditions The mapping from specification statements to weakest precondition predicate transformers, given as SSToWp, is well-known from Morgan <ref> [Mor94] </ref>. SSToWp (w : [ pre; post ]) b= wp (w : [ pre; post ]; R 0 ) = pre ^ (8 w 0 * post ) R 0 ); The reverse transformation, given as function WpToSS , is somewhat more com plex and is derived from [HeM88]. <p> The formal definition of data refinement is based upon this invariant. Data refinement has been studied extensively in a homogeneous setting; for example, see [Mor88] and [Gri90]. Several different definitions have also been provided, but a common one (used in <ref> [Mor94] </ref>) is based on weakest preconditions: Definition 17. ([Gri90]) Let a be a list of "abstract" variables, c be a list of "concrete" variables, and I the coupling invariant relating the two.
Reference: [Pai97] <author> R.F. Paige.: </author> <title> Formal Method Integration via Heterogeneous Notations, </title> <type> PhD dissertation, </type> <note> expected 1997. </note>
Reference-contexts: It generalizes existing notations (what we might term homogeneous languages) by allowing specifications to be constructed from parts written in several different languages. Definition 1. A heterogeneous notation is syntactically and semantically composed from two or more notations. In this paper, we consider only compositions involving formal notations. In <ref> [Pai97] </ref>, we provide a wider perspective and also consider semiformalisms. Specifications written using more than one notation will be called heterogeneous. Definition 2. A specification is heterogeneous if it is a composition of partial specifications written in two or more notations. <p> Compositions between notations are not always possible. A reasonable requirement is that the notations being composed have the same or can be given the same underlying model. We consider only notations that are compatible in this sense herein; compatibility is examined in more detail in <ref> [Pai97] </ref>. 1.3. Heterogeneous Notations for Method Integration Heterogeneous notations are a technique that can be used to combine languages. We are interested in heterogeneous notations as a means to carry out method integration; with notations combined, method integration becomes procedure generalization. <p> * ( var r : type * frame w ; r * (pre ) post [r=result ]) result r ) (In post, we substitute uses of result with uses of the fresh variable r for the sake of clarity.) Two further translations from LCL to predicative programming are given in <ref> [Pai97] </ref>. Translation into Larch from the notations in the framework is also possible. The Z operation schema Op: Op i ? : I pred 12 R. F. Paige can be mapped into an LCL operation. <p> The example we describe is a part of a text analysis system, the full version of which is considered in detail in <ref> [Pai97] </ref> (in the context of a semiformal method integration). <p> Then: Rule 5.13. (S x ^ S y v S z ^ S y ) ( S x v S z ; (There is an implicit translation to predicates in the antecedent of the second expression.) Rules for refinement over sequential composition are given in <ref> [Pai97] </ref>. 5.3. Heterogeneous development rules The final collection of procedural refinement theorems that we present are for heterogeneous development. These results allow us to formally change notations during a development via a refinement relation, thus giving us a kind of transitivity. <p> Restrictability of formal notations and methods becomes even more apparent once semiformalisms are added to the framework. This is discussed in detail in <ref> [Pai97] </ref>. 6.2. Translation Translation is an important concept in our approach. It is used to combine the notations and integrate the methods in the framework. <p> By doing so, we essentially encode several refinement steps in a translation, saving the developer from having to apply these laws in those cases when the pattern can be recognized. Examples of such translation laws are given in <ref> [Pai97] </ref>. 6.3. Satisfiability and Data Refinement We next discuss the issues of satisfiability checking and data refinement in a heterogeneous setting. We discuss general strategies for carrying out these procedures with the use of heterogeneous specifications and integrated formal methods. 6.3.1. <p> The translation procedure can be mecha nized. * Use translations (e.g., such as those presented in [Kin90] and <ref> [Pai97] </ref>) to map a heterogeneous specification into a form over which satisfiability checking Heterogeneous Notations for Formal Method Integration 29 can be done by parts. <p> In other words, there are no unspecified compositions between the implicit parts. There are certain explicit compositions that do allow satisfiability checking by parts, and in these cases we can use the most appropriate satisfiability definition for each part. These are described in <ref> [Pai97] </ref>; examples include predicate disjunction, selection, and Z schema disjunction. Satisfiability checking is hard in a homogeneous case; it is no harder in a heterogeneous setting. In a heterogeneous setting, we have more notations and notation features at our disposal. <p> To perform data refinement in a heterogeneous setting, we have several options. * Translate all specification parts into one notation, and carry out data refine ment in the homogeneous domain. This process is mechanizable. * Apply translations (e.g., as in [Kin90] or <ref> [Pai97] </ref>) and map a specification (part) into a form over which the data refinement relation is monotonic. * Use implicit compositions, assume each specification part represents a distinct system operation, and apply the appropriate notion of data refinement to the appropriate specification part. 30 R. F. <p> F. Paige * Determine a rule-set that describes when partwise data refinement can occur. A rule-set as mentioned above is briefly described in <ref> [Pai97] </ref>. It provides rules that show how to data refine specifications in one language by specifications in a second language, and generalizes rules from [Gri90] that show how to data refine heterogeneous specifications by parts. Data refinement is demonstrated in Section 7.2. 7. <p> F. Paige This can easily be implemented by using a tail recursive refinement, with guard j 6= N + 1. Further examples of using integrated formal methods are described in <ref> [Pai97] </ref>. 8. Conclusions and future work We have described an approach to formal method integration based on heterogeneous notations. We have combined six formal notations, considered the problem of dealing with expressiveness, and produced examples of formal heterogeneous specifications. <p> Integrated formal methods are an instance of method integrations. Since no single method|formal or semiformal|is a panacea, we might expect to find new improvements and utility in combining our formal method integration technique with semiformal methods. This is considered in <ref> [Pai97] </ref>, and is a direction for future research. Acknowledgements Ric Hehner provided much excellent advice and many helpful comments on the paper and the research in general. Fran~cois Pitt advised on presentation and pointed out several sections needing further clarification.
Reference: [PWM93] <author> F. Polack, M. Whiston, and K.C. Mander.: </author> <title> The SAZ Project: Integrating SSADM and Z, </title> <booktitle> Proc. FME `93: Industrial-strength Formal Methods, </booktitle> <publisher> LNCS 670, Springer-Verlag, </publisher> <year> 1993. </year> <note> 42 R. </note> <editor> F. </editor> <publisher> Paige </publisher>
Reference-contexts: The activities of integrating formality into existing practice, and determining how to best use formality in software development, are topics of continuing research ([WiZ92], <ref> [PWM93] </ref>, [SFD92], [Web93]). Recent research on formality in software development has emphasized the creation of different modeling paradigms, novel notations, and new methods for analysis or design. A kernel of research has focused on the synthesis ([ILR95], Correspondence and offprint requests to: Richard F.
Reference: [ScRo77] <author> K. Schoman and D. Ross. </author> <title> Structured Analysis for requirements definition, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 3(1), </volume> <year> 1977. </year>
Reference-contexts: A number of reasons can be given for why heterogeneous notations might be of use. * Expressiveness: one notation may not be able to express all the concepts necessary for a particular problem or style of specification. A standard example of this is data flow diagrams <ref> [ScRo77] </ref>, which are often composed with text-based process specifications. * Simpler specification languages and specifications: with the use of heterogeneous notations, individual specification languages can be made much simpler than what is now considered to be state-of-the-art [ZaJ93].
Reference: [SeA90] <author> L.T. Semmens and P. Allen.: </author> <title> Using Yourdon and Z: an approach to formal specification, </title> <booktitle> Fifth Annual Z Users Meeting, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Both notations will be helpful in specifying a system combining both aspects. * Practice: heterogeneous specifications have seen use in practice, e.g., see [ZaJ95], the combination of Yourdon notations with the VDM specification language at Rolls-Royce discussed in [SFD92], or the use of Z and Yourdon notations in <ref> [SeA90] </ref>. The semantics of a heterogeneous specification is given by formally defining the meaning of all the used notation compositions. Such a semantics is provided by a heterogeneous framework. Definition 3.
Reference: [SFD92] <author> L.T. Semmens, R.B. France, and T.W. Docker.: </author> <title> Integrated Structured Analysis and Formal Specification Techniques, </title> <journal> The Computer Journal 35(6), </journal> <month> June </month> <year> 1992. </year>
Reference-contexts: The activities of integrating formality into existing practice, and determining how to best use formality in software development, are topics of continuing research ([WiZ92], [PWM93], <ref> [SFD92] </ref>, [Web93]). Recent research on formality in software development has emphasized the creation of different modeling paradigms, novel notations, and new methods for analysis or design. A kernel of research has focused on the synthesis ([ILR95], Correspondence and offprint requests to: Richard F. <p> A kernel of research has focused on the synthesis ([ILR95], Correspondence and offprint requests to: Richard F. Paige, Department of Computer Science, University of Toronto, Toronto, Ontario, M5S 3G4, Canada. 2 R. F. Paige [Kro93], <ref> [SFD92] </ref>) of methodological and notational concepts. It is on this general theme that we focus in this paper. The point of view that we take is that no single instance of any method or notation is a panacea for software development. <p> Method integration in a software engineering context is a problem of growing research interest for several reasons. * It provides a systematic way for engineering or adapting a method to conform to the developers' thinking and abilities [HeO92]. * Method integration has been used in practice, at Rolls-Royce [Hil91], BT <ref> [SFD92] </ref>, Philips [Kro93], Westinghouse [Ham94], and AT&T [ZaJ95]. Many of the integrations used in these organizations are based on ad-hoc techniques. <p> Both notations will be helpful in specifying a system combining both aspects. * Practice: heterogeneous specifications have seen use in practice, e.g., see [ZaJ95], the combination of Yourdon notations with the VDM specification language at Rolls-Royce discussed in <ref> [SFD92] </ref>, or the use of Z and Yourdon notations in [SeA90]. The semantics of a heterogeneous specification is given by formally defining the meaning of all the used notation compositions. Such a semantics is provided by a heterogeneous framework. Definition 3.
Reference: [Spi89] <author> J.M. Spivey.: </author> <title> The Z Notation: A Reference Manual, </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1. Introduction An indication of a maturing discipline is in the increasing use of rigour and formality in its methods and processes ([Bro95], [Hoa94]). Formality in software development is used for many reasons: for its precision in capturing requirements [DaH94]; for writing system specifications <ref> [Spi89] </ref>; for safety- or economically-critical systems development ([BoS93], [GCR94]); for reducing costs, e.g., as in the CICS project [HoK92]; or for animation [DiL94] or mechanical checking of properties [COR95]. <p> In this section, we very briefly describe the formal methods and notations that will be utilized in the later parts of the paper. We refer the reader to the references for more technical details. 2.1. Z The formal notation Z is due to Abrial; a standard reference is <ref> [Spi89] </ref>. It is a specification notation based on typed set theory. The fundamental Z construct is the schema, which combines variable declarations with predicate invariants; the invariants are written as relations on pre- and poststates.
Reference: [War93] <author> N. Ward.: </author> <title> Adding specification constructors to the refinement calculus, </title> <booktitle> Proc. FME `93: Industrial-strength Formal Methods, </booktitle> <publisher> LNCS 670, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Composing specification statements with predicate combinators In this section, we add the predicate combinators ^ and _ to the refinement calculus. A similar problem was examined by Ward <ref> [War93] </ref>, who added Z schema conjunction and disjunction operators to the refinement calculus. In Ward's work, Z conjunction and disjunction are not monotonic with respect to the refinement relation v. <p> We now define specification statements on predicate combinators. In the following, let W b= w : [ pre w ; post w ] and X b= x : [ pre x ; post x ]. For reference, we 16 R. F. Paige state the definitions given in <ref> [War93] </ref>. Ward uses f for Z conjunction and g for Z disjunction of specification statements. We retain this usage throughout the paper. Definition 12. ([War93]) W f X b= w ; x : [ pre w ^ pre x ; post w ^ post x ]: Definition 13. ([War93]) Providing that <p> We extend predicate ^ and _ to specification statements, and arrive at the following results (following <ref> [War93] </ref>, we describe the results as theorems). We use translation PredToSS 1 here, though we note that translation PredToSS 2 results in much simpler semantics. Theorem 4.1. <p> Refinement over conjunction and disjunction Conjunction and disjunction are combinators in both predicate programming and Z. Unfortunately, refinement isn't always monotonic over these operators; <ref> [War93] </ref> shows that v is not monotonic over the Z schema combinators g and f. There are cases when we can refine over these combinators, and so to this end we summarize a few theorems here. <p> F. Paige The proof of the second part is similar. As is discussed in <ref> [War93] </ref>, refinement over schema conjunction and disjunction is not monotonic. However, we can combine schemas via predicate operators _ and ^, with the following results: let S x ; S y ; and S z be schemas.
Reference: [WaH91] <author> N. Ward and I. Hayes.: </author> <title> Applications of Angelic Nondeterminism, </title> <booktitle> Proc. 6th Aus-tralian Software Engineering Conference, </booktitle> <address> Sydney, Australia, </address> <year> 1991. </year>
Reference-contexts: Larch LCL: cannot express havoc or angelic nondeterminism. 6. Larch LSL: cannot directly express state-based behaviour. The specifications in this catalogue are typically extreme (except for the case of LSL), and are all of questionable use in programming. See Morgan [Mor88] and Ward and Hayes <ref> [WaH91] </ref> for discussions on the utility of magic and angelicism, respectively. 4. Specification examples We give several small examples of formal heterogeneous specifications and consider their semantics.
Reference: [Web93] <author> D. Weber-Wulff.: </author> <title> Selling Formal Methods to Industry, </title> <booktitle> Proc. FME `93: Industrial-strength Formal Methods, </booktitle> <publisher> LNCS 670, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The activities of integrating formality into existing practice, and determining how to best use formality in software development, are topics of continuing research ([WiZ92], [PWM93], [SFD92], <ref> [Web93] </ref>). Recent research on formality in software development has emphasized the creation of different modeling paradigms, novel notations, and new methods for analysis or design. A kernel of research has focused on the synthesis ([ILR95], Correspondence and offprint requests to: Richard F. <p> The specification restricts the use of each notation (and hence, method); that is, each notation is only used where the specifier and developer desires. <ref> [Web93] </ref> states this as an important requirement of an industrial-strength formal method. 4.4. Larch and Predicates A heap is a partially-ordered tree in which the parent node is no greater than the child nodes (according to some order relation). <p> This approach to formal method integration offers a selection of properties and facilities that may prove helpful in a development. We briefly discuss such issues in this section. 6.1. Restrictability and gradual introduction The concept of notation and method restrictability was discussed in Weber-Wulff <ref> [Web93] </ref>. Therein, a number of propositions for industrial-strength formal methods are listed.
Reference: [WiZ92] <author> J.M. Wing and A.M. Zaremski.: </author> <title> Unintrusive ways to integrate formal specifications in practice, VDM `91: Formal Software Development Methods, </title> <publisher> LNCS 551, Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [ZaJ93] <author> P. Zave and M. Jackson.: </author> <title> Conjunction as Composition, </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 2(4), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: That is, there is no ideal method that will suffice in all development stages and situations. There are technical and philosophical reasons for this. * Each individual method (or notation) offers a different set of expressive capabilities appropriate for specifying clearly and concisely a different set of properties <ref> [ZaJ93] </ref>. <p> A standard example of this is data flow diagrams [ScRo77], which are often composed with text-based process specifications. * Simpler specification languages and specifications: with the use of heterogeneous notations, individual specification languages can be made much simpler than what is now considered to be state-of-the-art <ref> [ZaJ93] </ref>. A combination of notations may also be used to write simpler specifications than via the use of one notation [ZaM93]. * Ease of expression: some specification languages are not as useful as others when used to describe particular classes of systems [BoH94]. <p> There are likely other criteria that can be accentuated by using a heterogeneous framework. There are many different frameworks we might present (examples in the literature include <ref> [ZaJ93] </ref> and [FGH93]). We create a framework by translation. For every formal notation of interest, we present a semantic mapping into a second formal notation of interest. By doing so, we present a set of rules which describe how to translate a heterogeneous specification into an equivalent-as-possible homogeneous specification. <p> We might use this for checking explicit compositions of specification parts, and for checking parts that are implicitly composed by conjunction, e.g., as in <ref> [ZaJ93] </ref>. * Use implicit compositions of specifications and assume that each part is a system operation; satisfiability checking over such combinations can be done by parts.
Reference: [ZaJ95] <author> P. Zave and M. Jackson.: </author> <title> Where do operations come from? An approach to mul-tiparadigm specification, </title> <type> preprint. </type>
Reference-contexts: is a problem of growing research interest for several reasons. * It provides a systematic way for engineering or adapting a method to conform to the developers' thinking and abilities [HeO92]. * Method integration has been used in practice, at Rolls-Royce [Hil91], BT [SFD92], Philips [Kro93], Westinghouse [Ham94], and AT&T <ref> [ZaJ95] </ref>. Many of the integrations used in these organizations are based on ad-hoc techniques. <p> The use of CSP might not be appropriate for specifying state-based aspects of a system, whereas Z may be of use. Both notations will be helpful in specifying a system combining both aspects. * Practice: heterogeneous specifications have seen use in practice, e.g., see <ref> [ZaJ95] </ref>, the combination of Yourdon notations with the VDM specification language at Rolls-Royce discussed in [SFD92], or the use of Z and Yourdon notations in [SeA90]. The semantics of a heterogeneous specification is given by formally defining the meaning of all the used notation compositions.
Reference: [ZaM93] <author> P. Zave and P. Mataga.: </author> <title> A formal specification of some important 5ESS features, Part I: Overview, </title> <institution> AT&T Bell Laboratories Technical Memorandum, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: A combination of notations may also be used to write simpler specifications than via the use of one notation <ref> [ZaM93] </ref>. * Ease of expression: some specification languages are not as useful as others when used to describe particular classes of systems [BoH94]. For example, trying to specify a concurrent system in Z might not be as appropriate as using CSP [Hoa85].
References-found: 53

