URL: ftp://ftp.cs.utexas.edu/pub/predator/tr-93-16.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Email: -singhal,batory-@cs.utexas.edu  
Title: P++: A Language for Software System Generators  
Author: Vivek Singhal and Don Batory 
Keyword: program families, large-scale encapsulation, software system synthesis, GenVoca, software system generators.  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: P++ is a programming language that supports the GenVoca model, a particular style of software design that is intended for building software system generators. P++ is an enhanced version of C++: it offers linguistic extensions for component encapsulation, abstraction, parameterization, and inheritance, where a component is a suite of interrelated classes and functions. This paper describes the motivations for P++, the ideas which underlie its design, the syntax and features of the language, and related areas of research. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar93] <author> John Barnes. </author> <title> Introducing Ada 9X. </title> <type> Technical Report, </type> <institution> Intermetrics Inc., </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: The specific concepts offered by P++ arise from the actual experiences and requirements of software system generators (Genesis, Avoca, Ficus, etc.). Nevertheless, there are many programming languages that offer features similar to P++. Languages like Ada 9X <ref> [Bar93] </ref> and Modula 3 [Car89] provide constructs for defining components. In addition, in most object-oriented languages (e.g., Eiffel [Mey88], Self [Cha91]) it is possible to emulate abstract component interfaces (realms) using virtual classes, albeit with some performance penalties. Realm inheritance can also be emulated using inheritance hierarchies of virtual classes.
Reference: [Bat88] <author> Don Batory. </author> <title> Concepts for a DBMS synthesizer. </title> <booktitle> In Proceedings of ACM Principles of Database Systems Conference, </booktitle> <year> 1988. </year> <note> Also in Rubn Prieto-Daz and Guillermo Arango, </note> <editor> editors, </editor> <title> Domain Analysis and Software Systems Modeling. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The essential themes that Parnas espoused are present in contemporary software generators; generators formalize the design of software families as open architectures, where software system synthesis and evolution can be quick and inexpensive. Genesis is an example of a generator for the domain of database systems <ref> [Bat88] </ref>. Genesis consists of a library of components and a generator which are used to specify and synthesize university-quality database management systems (consisting of up to 70,000 lines of code).
Reference: [Bat92a] <author> Don Batory and Sean OMalley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The GenVoca model captures their common design strategy <ref> [Bat92a] </ref>. GenVoca defines a particular style of designing and organizing components that enables families of software systems to be defined through component composition. An implementation of a GenVoca model is a software system generator for a particular domain.
Reference: [Bat92b] <author> Don Batory and James Barnett, DaTE: </author> <title> the Genesis DBMS software layout editor. </title> <editor> In Pericles Loucopoulos and Roberto Zicari, editors, </editor> <title> Conceptual Modeling, Databases, and CASE: An Integrated View of Information Systems Development. </title> <publisher> Wiley, </publisher> <year> 1992. </year> <month> 13 </month>
Reference-contexts: P2 also performs sophisticated analyses and query optimizations in order to generate efficient code. Genesis offers another example of a domain-specific tool. Genesis has a layout editor (called DaTE) that provides a graphical interface for selecting and combining components <ref> [Bat92b] </ref>. The editor not only provides an easy-to-understand depiction of a target systems organization, but it also guides the programmer in building semantically correct component compositions.
Reference: [Bat92c] <author> Don Batory, Vivek Singhal, and Marty Sirkin. </author> <title> Implementing a domain model for data structures. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 2(3) </volume> <pages> 375-402, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: We believe that P++ will be one member of a suite of tools some of which are domain-specific that comprise a software system generator; P++ provides the substrate for writing and combining components. The following examples illustrate this idea. Predator is a generator for the data structures domain <ref> [Bat92c, Bat93] </ref>. P2 is a domain-specific compiler that implements a superset of ANSI C, providing linguistic extensions for components, component compositions, containers, and cursor constructs.
Reference: [Bat93] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings of the ACM SIGSOFT 93: Symposium on the Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Generators for other domains include Avoca (network protocols) [Hut91, OMa92], Ficus (file systems) [Hei93], Brale (host-at-sea buoy systems) [Wei90], and Predator (data structures) <ref> [Bat93] </ref>. This research was supported in part by Applied Research Laboratories at the University of Texas, Schlumberger, and Digital Equipment Corporation. 2 Although each of the previously mentioned systems was developed independently and targeted for a different problem domain, all were organized in basically the same way. <p> We believe that P++ will be one member of a suite of tools some of which are domain-specific that comprise a software system generator; P++ provides the substrate for writing and combining components. The following examples illustrate this idea. Predator is a generator for the data structures domain <ref> [Bat92c, Bat93] </ref>. P2 is a domain-specific compiler that implements a superset of ANSI C, providing linguistic extensions for components, component compositions, containers, and cursor constructs.
Reference: [Boo91] <author> Grady Booch. </author> <title> Object-Oriented Design with Applications. </title> <address> Benjamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: In terms of expressiveness, both constructs are roughly equivalent. However, the basic difference arises from their intended usage. Nested classes do not arise in popular object-oriented design methodologies (e.g., <ref> [Boo91, Rum91, Teo90] </ref>); their intended use in C++ is to facilitate the implementation of the enclosing class. In contrast, a basic tenet of GenVoca is to identify groups of interrelated classes and encapsulate them within component constructs.
Reference: [Car89] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <type> Modula-3 report (revised). Technical Report 52, </type> <institution> Systems Research Center, Digital Equipment Corporation, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: The specific concepts offered by P++ arise from the actual experiences and requirements of software system generators (Genesis, Avoca, Ficus, etc.). Nevertheless, there are many programming languages that offer features similar to P++. Languages like Ada 9X [Bar93] and Modula 3 <ref> [Car89] </ref> provide constructs for defining components. In addition, in most object-oriented languages (e.g., Eiffel [Mey88], Self [Cha91]) it is possible to emulate abstract component interfaces (realms) using virtual classes, albeit with some performance penalties. Realm inheritance can also be emulated using inheritance hierarchies of virtual classes.
Reference: [Cha91] <author> Craig Chambers and David Ungar. </author> <title> Making pure object-oriented languages practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Nevertheless, there are many programming languages that offer features similar to P++. Languages like Ada 9X [Bar93] and Modula 3 [Car89] provide constructs for defining components. In addition, in most object-oriented languages (e.g., Eiffel [Mey88], Self <ref> [Cha91] </ref>) it is possible to emulate abstract component interfaces (realms) using virtual classes, albeit with some performance penalties. Realm inheritance can also be emulated using inheritance hierarchies of virtual classes.
Reference: [Cog93] <author> L. Coglianese and R. Szymanski. </author> <title> DSSA-ADAGE: an environment for architecture-based avionics development. </title> <note> In Proceedings of AGARD 1993. Also in Technical Report ADAGE IBM-93-04, </note> <institution> IBM Owego, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: A different approach, one that achieves economies of scale, was needed. He argued that since program families are inevitable, designing program families from the beginning was the most cost-effective way to proceed. Recent work on domain-specific software architectures <ref> [Cog93, SEI90] </ref> has shown that software system generators offer a promising means of economically building families of large, complex software systems. These generators are domain-specific; they implement models (called domain models) which show how to construct a family of similar software systems by composing prefabricated components.
Reference: [DOD83] <author> Department of Defense. </author> <title> Reference Manual for the Ada Programming Language. Ada Joint Program Office, </title> <institution> Department of Defense, ANSI/MIL-STD-1815A, </institution> <year> 1983. </year>
Reference-contexts: int eoc (); // beyond end of container? void insert (int); // add item void remove (); // delete item int& get_value (); // get item element *current_pos; // current position container *cont; // container iterated upon -; 5 Contemporary programming languages already offer constant and type parameterization of classes <ref> [Ell90, DOD83] </ref>; P++ extends these parameterization capabilities to components and realms. In addition, P++ components can also be parameterized by realms. Realm parameters are a basic feature of the GenVoca model and a concept borrowed from module interconnection languages [Pri86, Gog86].
Reference: [Ell90] <author> Margaret Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: int eoc (); // beyond end of container? void insert (int); // add item void remove (); // delete item int& get_value (); // get item element *current_pos; // current position container *cont; // container iterated upon -; 5 Contemporary programming languages already offer constant and type parameterization of classes <ref> [Ell90, DOD83] </ref>; P++ extends these parameterization capabilities to components and realms. In addition, P++ components can also be parameterized by realms. Realm parameters are a basic feature of the GenVoca model and a concept borrowed from module interconnection languages [Pri86, Gog86].
Reference: [Gog86] <author> Joseph Goguen. </author> <title> Reusing and interconnecting software components. </title> <journal> IEEE Computer, </journal> <volume> 19(2) </volume> <pages> 16-28, </pages> <month> February </month> <year> 1986. </year> <note> Also in Rubn Prieto-Daz and Guillermo Arango, </note> <editor> editors, </editor> <title> Domain Analysis and Software Systems Modeling. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: In addition, P++ components can also be parameterized by realms. Realm parameters are a basic feature of the GenVoca model and a concept borrowed from module interconnection languages <ref> [Pri86, Gog86] </ref>. In the following sections, we describe these P++ parameterization constructs and their novelty and significance. 2.2.1 Constant and Type Parameters Generic components and generic realms require constant and type parameters. <p> P++ integrates component definition and component combination features in a single language. Other researchers have used module interconnection languages (MILs) to combine components <ref> [Pri86, Gog86] </ref>. However, such languages typically are different from the language in which components are written. 2.2.3 Beyond C++ There are some similarities between P++ parameterized components and C++ templates both allow constant and type parameters. The principle difference is that P++ also allows realm parameters. <p> The output of this preprocessor would be P++ source. P++ would then produce C++ source by composing components. 5 Related Work As mentioned earlier, the conceptual foundations for P++ lie in the notion of program families [Par76] and the construction of families by parameterized programming <ref> [Gog86] </ref>. The specific concepts offered by P++ arise from the actual experiences and requirements of software system generators (Genesis, Avoca, Ficus, etc.). Nevertheless, there are many programming languages that offer features similar to P++. Languages like Ada 9X [Bar93] and Modula 3 [Car89] provide constructs for defining components. <p> The use of virtual domain-specific language preprocessor P++ compiler C++ compiler source program executable & generator 12 classes introduces run-time overhead because each method invocation from an abstract class requires a virtual table lookup. In contrast, P++ performs compile-time simplification of component compositions, which eliminates this cost. LIL <ref> [Gog86] </ref> and FOOPS [Gog93] are examples of languages that are based on Goguens parameterized programming model. This model provides a formal foundation for understanding the two varieties of parameters: horizontal (e.g. type and constants parameters) and vertical (e.g. realm parameters).
Reference: [Gog93] <author> Joseph Goguen and Adolfo Socorro. </author> <title> Module composition and system design for the object paradigm. </title> <type> Technical Report, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: In contrast, P++ performs compile-time simplification of component compositions, which eliminates this cost. LIL [Gog86] and FOOPS <ref> [Gog93] </ref> are examples of languages that are based on Goguens parameterized programming model. This model provides a formal foundation for understanding the two varieties of parameters: horizontal (e.g. type and constants parameters) and vertical (e.g. realm parameters). The functional programming language ML employs a very different approach to parameterization [Mil90].
Reference: [Hei93] <author> John Heidemann and Gerald Popek. </author> <title> File system development with stackable layers. </title> <journal> ACM Transactions on Computer Systems, </journal> <note> to appear. Also in Technical Report CSD-930019, </note> <institution> Department of Computer Science, University of California, </institution> <address> Los Angeles, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Defining a database system as a composition of components and generating that system can be done within a half-hour; an equivalent system built from scratch would take months or years of effort. Generators for other domains include Avoca (network protocols) [Hut91, OMa92], Ficus (file systems) <ref> [Hei93] </ref>, Brale (host-at-sea buoy systems) [Wei90], and Predator (data structures) [Bat93].
Reference: [Hut91] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-kernel: an architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1), </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Defining a database system as a composition of components and generating that system can be done within a half-hour; an equivalent system built from scratch would take months or years of effort. Generators for other domains include Avoca (network protocols) <ref> [Hut91, OMa92] </ref>, Ficus (file systems) [Hei93], Brale (host-at-sea buoy systems) [Wei90], and Predator (data structures) [Bat93].
Reference: [Lis87] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <booktitle> In Addendum to the OOPSLA 87 Conference Proceedings, </booktitle> <pages> pages 17-34, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: C++ does not support templates of templates, which makes C++ somewhat less exible than P++. 2.3 Inheritance Programming languages use inheritance to implement two kinds of hierarchies: implementation hierarchies and type hierarchies <ref> [Lis87] </ref>. Current object-oriented languages usually support implementation hierarchies, where a subclass inherits both the interface and the implementation of its superclass, unless explicitly overridden (overloaded) by the subclass. In this context, the primary purpose of inheritance is to 10 support code reuse, at the cost of potentially violating encapsulation.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Nevertheless, there are many programming languages that offer features similar to P++. Languages like Ada 9X [Bar93] and Modula 3 [Car89] provide constructs for defining components. In addition, in most object-oriented languages (e.g., Eiffel <ref> [Mey88] </ref>, Self [Cha91]) it is possible to emulate abstract component interfaces (realms) using virtual classes, albeit with some performance penalties. Realm inheritance can also be emulated using inheritance hierarchies of virtual classes.
Reference: [Mil90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This model provides a formal foundation for understanding the two varieties of parameters: horizontal (e.g. type and constants parameters) and vertical (e.g. realm parameters). The functional programming language ML employs a very different approach to parameterization <ref> [Mil90] </ref>. ML automatically deduces type restrictions on parameters; consequently, the application of a function is limited only by the usage of its parameters. P++ is distinguished from other languages by its explicit support for the GenVoca model.
Reference: [OMa92] <author> Sean OMalley and Larry Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Defining a database system as a composition of components and generating that system can be done within a half-hour; an equivalent system built from scratch would take months or years of effort. Generators for other domains include Avoca (network protocols) <ref> [Hut91, OMa92] </ref>, Ficus (file systems) [Hei93], Brale (host-at-sea buoy systems) [Wei90], and Predator (data structures) [Bat93].
Reference: [Par76] <author> David Parnas. </author> <title> On the design and development of program families. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(1):1-9, </volume> <month> March </month> <year> 1976. </year>
Reference-contexts: 1 Introduction Almost two decades ago, Parnas observed that software design was incorrectly taught as a technique which sought a unique program/solution, because, over its lifetime, the program inevitably would evolve into a family of similar programs <ref> [Par76] </ref>. When programs are not designed for extensibility, the effort and expense needed to modify them is often out of proportion to the changes themselves. A different approach, one that achieves economies of scale, was needed. <p> The output of this preprocessor would be P++ source. P++ would then produce C++ source by composing components. 5 Related Work As mentioned earlier, the conceptual foundations for P++ lie in the notion of program families <ref> [Par76] </ref> and the construction of families by parameterized programming [Gog86]. The specific concepts offered by P++ arise from the actual experiences and requirements of software system generators (Genesis, Avoca, Ficus, etc.). Nevertheless, there are many programming languages that offer features similar to P++.
Reference: [Pri86] <author> Rubn Prieto-Daz and James M. Neighbors. </author> <title> Module interconnection languages. </title> <journal> Journal of Systems and Software, </journal> <volume> 6(4) </volume> <pages> 307-334, </pages> <month> November </month> <year> 1986. </year> <editor> Also in Peter Freeman, editor. </editor> <booktitle> Software Reusability. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year> <month> 14 </month>
Reference-contexts: In addition, P++ components can also be parameterized by realms. Realm parameters are a basic feature of the GenVoca model and a concept borrowed from module interconnection languages <ref> [Pri86, Gog86] </ref>. In the following sections, we describe these P++ parameterization constructs and their novelty and significance. 2.2.1 Constant and Type Parameters Generic components and generic realms require constant and type parameters. <p> P++ integrates component definition and component combination features in a single language. Other researchers have used module interconnection languages (MILs) to combine components <ref> [Pri86, Gog86] </ref>. However, such languages typically are different from the language in which components are written. 2.2.3 Beyond C++ There are some similarities between P++ parameterized components and C++ templates both allow constant and type parameters. The principle difference is that P++ also allows realm parameters.
Reference: [Pri93] <editor> Rubn Prieto-Daz and William Frakes, editors. </editor> <booktitle> Advances in Software Reuse: Second International Workshop on Software Reuse, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Component parameterization, which permits an easy and controlled form of modification, is widely believed to be the prescription for success ful component customization <ref> [Pri93] </ref>. component int_linked_list - class element - element (int); // constructor int data; // the value of this node element *next, *prev; // adjacent nodes on list -; class container - container (); // constructor element *head; // first node of list -; class cursor - cursor (container *); // constructor
Reference: [Rum91] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design, </title> <publisher> Prentice-Hall, </publisher> <year> 1991 </year>
Reference-contexts: In terms of expressiveness, both constructs are roughly equivalent. However, the basic difference arises from their intended usage. Nested classes do not arise in popular object-oriented design methodologies (e.g., <ref> [Boo91, Rum91, Teo90] </ref>); their intended use in C++ is to facilitate the implementation of the enclosing class. In contrast, a basic tenet of GenVoca is to identify groups of interrelated classes and encapsulate them within component constructs.
Reference: [SEI90] <author> Software Engineering Institute. </author> <booktitle> Proceedings of the Workshop on Domain-Specific Software Architectures, </booktitle> <address> Hidden-Valley, Pennsylvania, </address> <year> 1990. </year>
Reference-contexts: A different approach, one that achieves economies of scale, was needed. He argued that since program families are inevitable, designing program families from the beginning was the most cost-effective way to proceed. Recent work on domain-specific software architectures <ref> [Cog93, SEI90] </ref> has shown that software system generators offer a promising means of economically building families of large, complex software systems. These generators are domain-specific; they implement models (called domain models) which show how to construct a family of similar software systems by composing prefabricated components.
Reference: [Sir93] <author> Marty Sirkin, Don Batory, and Vivek Singhal. </author> <title> Software components in a data structure precompiler. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: of s2 typedef r2&lt;s1&gt; system21;; // r2 is layered on top of s1 typedef r2&lt;s2&gt; system22;; // r2 is layered on top of s2 typedef r3 system33;; // a component with no realm parameter A more complicated example that uses both realm and type parameters arises in data structure generation <ref> [Sir93] </ref>. Data structure components can be understood as transformations, where the linked_list component of Figure 3 transforms a collection of T objects into a collection of element objects that are connected by a linked list (see Figure 5a).
Reference: [Sny86] <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 38-45, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: A subclass could violate the data abstraction presented by its superclass in three ways: the subclass might directly access an instance variable of its superclass, call a private operation of its superclass, or directly refer to one of its superclass superclasses <ref> [Sny86] </ref>. In contrast, when a language implements type hierarchies, inheritance is being used to support data abstraction. In this context, a subtype inherits only the interface of its supertype, but not its implementation. The primary advantage of type hierarchies over implementation hierarchies is interchangeability.
Reference: [Teo90] <author> T. J. Teorey. </author> <title> Database Modeling and Design: The Entity-Relationship Approach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: In terms of expressiveness, both constructs are roughly equivalent. However, the basic difference arises from their intended usage. Nested classes do not arise in popular object-oriented design methodologies (e.g., <ref> [Boo91, Rum91, Teo90] </ref>); their intended use in C++ is to facilitate the implementation of the enclosing class. In contrast, a basic tenet of GenVoca is to identify groups of interrelated classes and encapsulate them within component constructs.
Reference: [Wei90] <author> David M. Weiss. </author> <title> Synthesis Operational Scenarios. </title> <type> Technical Report 90038-N, Version 1.00.01, </type> <institution> Software Productivity Consortium, </institution> <address> Herndon, Virginia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Generators for other domains include Avoca (network protocols) [Hut91, OMa92], Ficus (file systems) [Hei93], Brale (host-at-sea buoy systems) <ref> [Wei90] </ref>, and Predator (data structures) [Bat93].
References-found: 29

