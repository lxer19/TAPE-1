URL: http://www.cs.utexas.edu/users/marco/kluwer.ps
Refering-URL: http://www.cs.utexas.edu/users/marco/
Root-URL: 
Title: 2 SELF-STABILIZING REAL-TIME DECISION SYSTEMS  
Author: Marco Schneider 
Address: Austin Austin, Texas 78712-1188  
Affiliation: Department of Computer Sciences The University of Texas at  
Abstract: We examine the task of constructing self-stabilizing real-time decision systems, which take their input from an external environment, and present a series of results concerning compilers which force the property of self-stabilization onto such systems. We consider compilers that do and do not preserve termination applied to finite state and infinite state programs. 
Abstract-found: 1
Intro-found: 1
Reference: [AV91] <author> Baruch Awerbuch, George Varghese. </author> <title> Distributed Program Checking: a Paradigm for Building Self-stabilizing Distributed Protocols. </title> <booktitle> Proceedings of the 32'nd IEEE Symp. on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1991. </year> <title> Self-Stabilizing Real-Time Decision Systems 43 </title>
Reference-contexts: An attempt is underway to integrate our transformations into the current work of Browne et. al. as part of the "BOCS" project [BOCS]. Additional work in the area of compiling for self-stabilization has been completed by the following sets of authors; [GHR90], [KP90], and <ref> [AV91] </ref>. We summarize this additional work. [GHR90] show that self-stabilization is in principle unstable across architectures. They demonstrate pathological cases for a variety of abstract architectures under which there cannot exist a compiler that preserves or forces self-stabilization. <p> This methodology is suitable for a compilation process requiring both program and predicate specifying safe state as input, and producing a self-stabilizing version of the same program as output. 22 Chapter 2 <ref> [AV91] </ref> provide a compiler from deterministic synchronous protocols into self-stabilizing versions for dynamic (asynchronous) networks. Their compiler is for "non-interactive protocols". They define a non-interactive protocol as a protocol specified by an input-output relation. Their work may be viewed in the context of real-time decision systems.
Reference: [BEGMMR] <author> J. C. Browne, A. Emerson, M. Gouda, D. Miranker, A. Mok, L. Rosier. </author> <title> Bounded-Time Fault-Tolerant Rule-Based Systems. </title> <journal> Telematics and Informatics, </journal> <volume> Vol. 7, Nos. 3/4, </volume> <pages> pp. 441-454, </pages> <year> 1990. </year>
Reference-contexts: Finally we acknowledge those who have helped us in our endeavor. 2 RELATED WORK Our efforts were motivated by the joint work of <ref> [BEGMMR] </ref> and [Che90, Che92], and have a direct relation to it. Their area of application was also real-time decision systems which react to periodic sensor readings (the input), and they use the same nondeterministic rule based programming model (EQL [Che90]) that we base our work on.
Reference: [BOCS] <author> J. C. Browne, A. Emerson, M. Gouda, D. Miranker, A. Mok, S. Chodrow, R.-H Wang, D. Tsou, L. Obermeyer. </author> <title> Correct and Robust Decision Systems for High Complexity Critical Control Systems. </title> <booktitle> Submitted to The Third International Workshop on Responsive Computer Systems. </booktitle>
Reference-contexts: An attempt is underway to integrate our transformations into the current work of Browne et. al. as part of the "BOCS" project <ref> [BOCS] </ref>. Additional work in the area of compiling for self-stabilization has been completed by the following sets of authors; [GHR90], [KP90], and [AV91]. We summarize this additional work. [GHR90] show that self-stabilization is in principle unstable across architectures.
Reference: [BG90] <author> J. Bruck, J. W. Goodman. </author> <title> On the Power of Neural Networks for Solving Hard Problems. </title> <journal> Journal of Complexity, </journal> <volume> Vol. 6, </volume> <pages> pages 129 - 135, </pages> <year> 1990. </year>
Reference-contexts: A neural network (Hopfield Net) is in fact a restricted type of self-stabilizing boolean program. Thus polynomial uniform neural networks can only compute the decision relations in NP " co-NP. A similar result appears in <ref> [BG90] </ref>. We now present some other interesting corollaries. Corollary 6.1 If there exists a polynomial uniform family of self-stabilizing boolean programs that implements a PSPACE-complete decision relation then PSPACE = NP. Corollary 6.2 Let g be an EPC for boolean programs that forces the property of self-stabilization.
Reference: [CM88] <author> K.M. Chandy, J. Misra. </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1988. </year>
Reference-contexts: The semantics of our model is based upon EQL [Che90] a rule-based language designed for the programming of real-time decision systems. This model is also similar to that of UNITY <ref> [CM88] </ref>. Rather than introduce the specific syntax of EQL or some other language we introduce a simple notation that abstracts from the details of rule based languages and allows us to present transformations more concisely. A program consists of an initialization section and a finite set of rules.
Reference: [Che90] <author> A. M. K. Cheng. </author> <title> Analysis and Synthesis of Real-Time Rule-Based Decision Systems. </title> <type> Ph.D. Dissertation, </type> <institution> Dept. of Computer Sciences, University of Texas at Austin, </institution> <year> 1990. </year>
Reference-contexts: Finally we acknowledge those who have helped us in our endeavor. 2 RELATED WORK Our efforts were motivated by the joint work of [BEGMMR] and <ref> [Che90, Che92] </ref>, and have a direct relation to it. Their area of application was also real-time decision systems which react to periodic sensor readings (the input), and they use the same nondeterministic rule based programming model (EQL [Che90]) that we base our work on. <p> Their area of application was also real-time decision systems which react to periodic sensor readings (the input), and they use the same nondeterministic rule based programming model (EQL <ref> [Che90] </ref>) that we base our work on. <p> Examples of the algorithms they consider are leader election and spanning tree. 3 A MODEL OF COMPUTATION In this section we introduce a model of computation upon which we will demonstrate our results. The semantics of our model is based upon EQL <ref> [Che90] </ref> a rule-based language designed for the programming of real-time decision systems. This model is also similar to that of UNITY [CM88].
Reference: [Che92] <author> A. M. K. Cheng. </author> <title> Self-Stabilizing Real-Time Rule-Based Systems. </title> <booktitle> Proc. of the 11th Annual Symposium on Reliable Distributed Systems, </booktitle> <address> Houston, Texas, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Finally we acknowledge those who have helped us in our endeavor. 2 RELATED WORK Our efforts were motivated by the joint work of [BEGMMR] and <ref> [Che90, Che92] </ref>, and have a direct relation to it. Their area of application was also real-time decision systems which react to periodic sensor readings (the input), and they use the same nondeterministic rule based programming model (EQL [Che90]) that we base our work on.
Reference: [Dij73] <author> E. W. Dijkstra. </author> <title> EWD391 Self-stabilization in spite of distributed control. 1973. Reprinted in Selected Writings on Computing: A Personal Perspective, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1982, </year> <pages> pp. 41-46. </pages>
Reference-contexts: This provides a complementary method by which to make systems fault tolerant. The notion of "self-stabilization" was first introduced to computer science by Dijkstra <ref> [Dij73, Dij74] </ref>. For a comprehensive survey of this area we direct the reader to [Sch93]. The motivation for our work in self-stabilization is the study of reactive real-time decision systems which receive their input from an external environment that experiences periodic changes.
Reference: [Dij74] <author> E. W. Dijkstra. </author> <title> Self stabilizing systems in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17 </volume> <pages> 643-644, </pages> <year> 1974. </year>
Reference-contexts: This provides a complementary method by which to make systems fault tolerant. The notion of "self-stabilization" was first introduced to computer science by Dijkstra <ref> [Dij73, Dij74] </ref>. For a comprehensive survey of this area we direct the reader to [Sch93]. The motivation for our work in self-stabilization is the study of reactive real-time decision systems which receive their input from an external environment that experiences periodic changes.
Reference: [Emd90] <author> P. V. Emde Boas. </author> <title> Machine Models and Simulations. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. </volume> <publisher> A, North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990 </year>
Reference-contexts: We will also consider boolean programs that will only require the boolean connectives, the equality predicate and the constants TRUE and FALSE. We note the invariance thesis for complexity theory which states that all standard sequential models of computation are polynomially related under a logarithmic cost function <ref> [Emd90] </ref>. Our model provides the same arithmetic operations as an MRAM. One step of a Turing machine can easily be simulated by one step in our model.
Reference: [GHR90] <author> M. G. Gouda, R. R. Howell, L. E. Rosier. </author> <title> The instability of self-stabilization. </title> <journal> Acta Informatica, </journal> <volume> Vol. 27, </volume> <pages> pp. 697-724, </pages> <year> 1990. </year>
Reference-contexts: An attempt is underway to integrate our transformations into the current work of Browne et. al. as part of the "BOCS" project [BOCS]. Additional work in the area of compiling for self-stabilization has been completed by the following sets of authors; <ref> [GHR90] </ref>, [KP90], and [AV91]. We summarize this additional work. [GHR90] show that self-stabilization is in principle unstable across architectures. They demonstrate pathological cases for a variety of abstract architectures under which there cannot exist a compiler that preserves or forces self-stabilization. <p> Additional work in the area of compiling for self-stabilization has been completed by the following sets of authors; <ref> [GHR90] </ref>, [KP90], and [AV91]. We summarize this additional work. [GHR90] show that self-stabilization is in principle unstable across architectures. They demonstrate pathological cases for a variety of abstract architectures under which there cannot exist a compiler that preserves or forces self-stabilization.
Reference: [Joh90] <author> D. Johnson. </author> <title> A Catalog of Complexity Classes. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. </volume> <publisher> A, North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990 </year>
Reference-contexts: Finding such a divisor is at least of polynomial complexity. There is no known polynomial algorithm to test if a number is composite <ref> [Joh90] </ref>. We now provide an EPC that forces self-stabilization onto programs that take a constant number of steps. In order to do so we must make the following enhancement to our model which does not exist in EQL.
Reference: [KP90] <author> S. Katz, K. J. Perry. </author> <title> Self-stabilizing Extensions for Message Passing Systems. </title> <booktitle> Proc. of the 9th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Quebec City, Canada, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: An attempt is underway to integrate our transformations into the current work of Browne et. al. as part of the "BOCS" project [BOCS]. Additional work in the area of compiling for self-stabilization has been completed by the following sets of authors; [GHR90], <ref> [KP90] </ref>, and [AV91]. We summarize this additional work. [GHR90] show that self-stabilization is in principle unstable across architectures. They demonstrate pathological cases for a variety of abstract architectures under which there cannot exist a compiler that preserves or forces self-stabilization. The difficulties revealed are mainly due to concurrency. [KP90] provide a <p> authors; [GHR90], <ref> [KP90] </ref>, and [AV91]. We summarize this additional work. [GHR90] show that self-stabilization is in principle unstable across architectures. They demonstrate pathological cases for a variety of abstract architectures under which there cannot exist a compiler that preserves or forces self-stabilization. The difficulties revealed are mainly due to concurrency. [KP90] provide a methodology by which self-stabilization may be forced onto asynchronous message passing systems. Their task is accomplished by superposing self-stabilizing snapshot and reset algorithms onto an algorithm for which the set of safe states can be expressed by a decidable predicate.
Reference: [KR90] <author> R. M. Karp, V. Ramachandran. </author> <title> Parallel algorithms for shared-memory machines. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. </volume> <publisher> A, North-Holland, </publisher> <address> Amsterdam, </address> <note> 1990 44 Chapter 2 </note>
Reference: [Sch91] <author> M. Schneider. </author> <title> Self Stabilization A Unified Approach To Fault Tolerance In The Face of Transient Errors. Course Notes in Distributed Computing, Edited by Jayadev Misra and Josyula R. </title> <type> Rao, Technical Report TR-91-18, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: In this section we consider partial fixed points. Some of the transformations we present also appear in <ref> [Sch91] </ref>. We define a partial fixed point with respect to a subvector Y of the output variables of a program.
Reference: [Sch93] <author> M. Schneider. </author> <title> Self-Stabilization. </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 25, No. 1, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: This provides a complementary method by which to make systems fault tolerant. The notion of "self-stabilization" was first introduced to computer science by Dijkstra [Dij73, Dij74]. For a comprehensive survey of this area we direct the reader to <ref> [Sch93] </ref>. The motivation for our work in self-stabilization is the study of reactive real-time decision systems which receive their input from an external environment that experiences periodic changes.
References-found: 16

