URL: http://cs.utep.edu/gelfond/papers/ilps97.ps
Refering-URL: http://cs.utep.edu/gelfond/gelfond.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fmgelfond,alfredog@cs.utep.edu  
Title: From Functional Specifications to Logic Programs  
Author: Michael Gelfond, Alfredo Gabaldon 
Address: El Paso, TX 79968, USA  
Affiliation: Department of Computer Science University of Texas at El Paso  
Abstract: The paper investigates a methodology for representing knowledge in logic programming using functional specifications. The methodology is illustrated by an example formalizing several forms of inheritance reasoning. We also introduce and study a new specification constructor which corresponds to removal of the closed world assumption from input predicates of functional specifications. 
Abstract-found: 1
Intro-found: 1
Reference: [AP96] <author> J.J. Alferes and L.M. Pereira. </author> <title> Reasoning with Logic Programming, </title> <booktitle> Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer. </publisher> <year> 1996. </year>
Reference-contexts: The alternative approach which uses logic programs with well-founded semantics and its extensions can be found in <ref> [AP96] </ref>. <p> The problem of specifying and representing is-nets is commonly used to test strengths and weaknesses of various nonmonotonic formalisms. Logic programming approaches to this problem (which assume completeness of its domain) can be found in <ref> [AP96] </ref> and [Lin91]. Modifications of this example will be used throughout this paper.
Reference: [ABW88] <author> K. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge In Minker, </title> <editor> J., ed., </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <pages> pp. 89-148, </pages> <year> 1988. </year>
Reference-contexts: Proof (Sketch). A program [X can be viewed as a logic program without classical negation in a language which contains new predicate symbols :has. This program is stratified <ref> [ABW88] </ref> and has therefore a unique answer set A [Gel88]. As shown in [Gel90] A is also the unique answer set of [ X iff A doesn't contain contrary literals.
Reference: [BGK93] <author> C. Baral, M. Gelfond, and O. Kosheleva. </author> <title> Approximating general logic programs, </title> <booktitle> Proc. ILPS, </booktitle> <pages> pp. 181-198, </pages> <year> 1993. </year>
Reference-contexts: Informally, the input opening f ffi of f is the result of the removal of this assumption. The notion of input opening is closely related to the notion of interpolation of a logic program from <ref> [BGK93] </ref>. Interpolation can be viewed as a particular case of input opening defined for specifications which assume the CWA for their outputs as well as inputs and whose input relations are independent from each other. <p> F-specification ~ f with the same signatures as f and the domain ~ D is called the interpolation of f if ~ f (X ) = ^ X2c (D;X) This is a slight generalization of the notion of interpolation introduced in <ref> [BGK93] </ref>, where the authors only considered interpolations of functions de fined by general logic programs. Definition 3.4 (Domain Completion) Let D be a collection of complete states over signature .
Reference: [CSW95] <author> W. Chen, T. Swift and D. Warren. </author> <title> Efficient top-down computation of queries under the well-founded semantics, </title> <journal> Journal of Logic Programming, </journal> <volume> 24,3:161-201, </volume> <year> 1995. </year>
Reference-contexts: However, due to the left recursion in the rules 9, 10 ffi cannot be run with the Prolog interpreter. It was however run under a simple meta-interpreter based on the SLG inference engine <ref> [CSW95] </ref> which is sound w.r.t. our semantics.
Reference: [Cla78] <author> K. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, eds., </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pp. 293-322. </pages> <publisher> Plenum Press, </publisher> <address> NY, </address> <year> 1978. </year>
Reference-contexts: logic program over signature () we mean a collection of rules of the form (r) l 0 l 1 ; : : : ; l m ; not l m+1 ; : : : ; not l n where l's are literals over () and not is negation as failure <ref> [Cla78, Rei78] </ref>. head (r) = fl 0 g, pos (r) = fl 1 ; : : : ; l m g, neg (r) = fl m+1 ; : : : ; l n g. head () is the union of head (r) for all rules from .
Reference: [Dev90] <author> Y. Deville. </author> <title> Logic Programming: systematic program development, </title> <editor> Clark, K., series editor, </editor> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1990. </year>
Reference-contexts: In this sense our approach is complementary to the work on pro-gram development in Prolog (see for instance <ref> [Dev90] </ref>) which concentrates on properties of a particular inference engine.
Reference: [Gel88] <author> M. Gelfond. </author> <month> 17 </month>
Reference-contexts: Proof (Sketch). A program [X can be viewed as a logic program without classical negation in a language which contains new predicate symbols :has. This program is stratified [ABW88] and has therefore a unique answer set A <ref> [Gel88] </ref>. As shown in [Gel90] A is also the unique answer set of [ X iff A doesn't contain contrary literals.
Reference: [Gel90] <author> M. </author> <note> Gelfond. </note>
Reference-contexts: Proof (Sketch). A program [X can be viewed as a logic program without classical negation in a language which contains new predicate symbols :has. This program is stratified [ABW88] and has therefore a unique answer set A [Gel88]. As shown in <ref> [Gel90] </ref> A is also the unique answer set of [ X iff A doesn't contain contrary literals.
Reference: [GG97] <author> M. Gelfond and A. Gabaldon. </author> <title> From functional specifications to logic programs. </title> <type> Technical report. </type> <note> Available from: http://cs.utep.edu/gelfond/gelfond.html </note>
Reference-contexts: Somewhat surprisingly, the resulting class of programs formalizes inheritance reasoning with incomplete information which was not previously formalized. Unfortunately, the size limitations do not allow us to include proofs. They can be found in <ref> [GG97] </ref>. Acknowledgments We would like to thank the referees for valuable comments. The first author acknowledges the support of NASA under grant NCCW-0089.
Reference: [GL91] <author> M. Gelfond and V. Lifschitz. </author> <title> Classical Negation in Logic Programs and Disjunctive Databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference: [GP96] <author> M. Gelfond and H. Przymusinska. </author> <title> Towards a theory of elaboration tolerance: logic programming approach. </title> <journal> Int'l Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 6(1) </volume> <pages> 89-112, </pages> <year> 1996. </year>
Reference-contexts: The restriction to functional problems allows us to start the programming process with formalizing a natural language description of a problem in terms of functional specifications (f-specifications) <ref> [GP96] </ref> functions which map collections of facts about known relations from the domain into collections of facts about new, defined relations. <p> After the construction of an f-specification f the designer of the system is confronted with the task of representing f in a logical language with a precisely described entailment relation. <ref> [GP96] </ref> advocates the use of a language L of logic programs with two types of negations and the answer set semantics. <p> Programs of this sort are called lp-functions. In <ref> [GP96] </ref> the authors suggest that the construction of f from f can be substantially facilitated by so called realization theorems which relate specification constructors to some operations on logic programs. They can provide an implementor with a useful heuristic guidance and the means to establish the correctness of his programs. <p> Examples of such reductions can be found in <ref> [GP96] </ref>. The previous discussion shows that the success of our approach depends to a large extent on our ability to discover a collection of specification constructors which can serve as building blocks for the construction of f-specifications. This paper is a continuation of a search for such constructors. <p> D-consistent states of into their maximally informative supersets. 10 Specifications f and g s.t. o (f ) = i (g) and lit ( i (g)) " lit ( o (g)) = ; can be combined into a new f-specification g ffi f by a specification constructor ffi called incremental extension <ref> [GP96] </ref>. <p> Follows immediately from the fact that constraints for N can be reduced to binary constraints by using complete available information about relation subclass and Proposition 3.1. 2 Finally, using Propositions 3.2, 3.3 and the realization theorem for incremental extension from <ref> [GP96] </ref> we can prove: Proposition 3.4 ffi represents f ffi Proof. By Proposition 3.1, f ffi = ~ f ffi ~ f D . Since ~ D has the unique answer set we can use realization theorem for incremental extension from [GP96] according to which representation ffi of f ffi can <p> 3.3 and the realization theorem for incremental extension from <ref> [GP96] </ref> we can prove: Proposition 3.4 ffi represents f ffi Proof. By Proposition 3.1, f ffi = ~ f ffi ~ f D . Since ~ D has the unique answer set we can use realization theorem for incremental extension from [GP96] according to which representation ffi of f ffi can be obtained simply by combining ~ and ~ D 4 2 Proposition 3.4 shows the correctness of ffi w.r.t. our specification. However, due to the left recursion in the rules 9, 10 ffi cannot be run with the Prolog interpreter. <p> We show that this generalization can be easily incorporated into the design. To do that we use another specification constructor from <ref> [GP96] </ref>. We will recall the following definitions from [GP96]. Definition 3.5 Let f be a functional specification with disjoint sets of input and output predicates. <p> We show that this generalization can be easily incorporated into the design. To do that we use another specification constructor from <ref> [GP96] </ref>. We will recall the following definitions from [GP96]. Definition 3.5 Let f be a functional specification with disjoint sets of input and output predicates. <p> o (f ) is called input extension of f if 1. f fl is defined on elements of dom (f ) possibly expanded by consistent sets of literals from o (f ), 2. for every X 2 dom (f ), f fl (X) = f (X), 4 As shown in <ref> [GP96] </ref> this simple construction does not always work. 15 3. for any Y 2 dom (f fl ) and any l 2 lit ( o (f )), (i) if l 2 Y then l 2 f fl (Y ) (ii) if l 62 Y and l 62 Y then l 2
Reference: [Kun89] <author> K. Kunen. </author> <title> Signed data dependencies in logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 7(3) </volume> <pages> 231-245, </pages> <year> 1989. </year>
Reference: [Lif93] <author> V. Lifschitz. </author> <title> Restricted Monotonicity. </title> <booktitle> In Proc. of AAAI-93, </booktitle> <pages> pp. 432-437, </pages> <year> 1993. </year>
Reference-contexts: We call such problems functional KR problems. They frequently occur in the development of databases when new relations (views) are defined in terms of basic relations stored in the database tables. They are also typical in artificial intelligence (see <ref> [Lif93] </ref>), e.g., in formalizing knowledge about action and change when we need to define the state of the world at a given moment in terms of its initial (known) state.
Reference: [LT94] <author> V. Lifschitz and H. Turner. </author> <title> Splitting a Logic Program. </title> <editor> In P. Van Hentenryck, editor, </editor> <booktitle> Proc. 11th ICLP, </booktitle> <pages> pp. 23-38, </pages> <year> 1994. </year>
Reference: [Lin91] <author> F. Lin. </author> <title> A study of nonmonotonic reasoning, </title> <type> Ph.D. Thesis, </type> <institution> Stan-ford U., </institution> <year> 1991. </year> <month> [Mar89] </month>
Reference-contexts: The problem of specifying and representing is-nets is commonly used to test strengths and weaknesses of various nonmonotonic formalisms. Logic programming approaches to this problem (which assume completeness of its domain) can be found in [AP96] and <ref> [Lin91] </ref>. Modifications of this example will be used throughout this paper. An is-net N can be viewed as a combination of graphs N s and N d where N s describes the subclass relation between classes and N d consists of positive and negative links connecting classes with properties.
Reference: [Mor90] <author> C. Morgan. </author> <title> In C.A.R. Hoare, series ed., Programming from specifications, </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: We are primarily interested in what is entailed by our program and not in specific algorithms used to compute this 1 Our use of the term "specification" follows <ref> [Mor90] </ref> which eliminates the distinction between programs and specifications. 1 entailment. In this sense our approach is complementary to the work on pro-gram development in Prolog (see for instance [Dev90]) which concentrates on properties of a particular inference engine.
Reference: [Rei78] <author> R. Reiter. </author> <title> On closed world data bases. </title> <editor> In H. Gallaire and J. Minker, eds., </editor> <booktitle> Logic and Data Bases, </booktitle> <publisher> Plenum Press, NY, </publisher> <pages> pp. 119-140, </pages> <year> 1978. </year>
Reference-contexts: This paper is a continuation of a search for such constructors. We introduce and study a new specification constructor, called input opening, which is defined on f-specifications of KR problems which assume the closed world assumption (CWA) <ref> [Rei78] </ref> on its input predicates. Informally, the input opening f ffi of f is the result of the removal of this assumption. The notion of input opening is closely related to the notion of interpolation of a logic program from [BGK93]. <p> logic program over signature () we mean a collection of rules of the form (r) l 0 l 1 ; : : : ; l m ; not l m+1 ; : : : ; not l n where l's are literals over () and not is negation as failure <ref> [Cla78, Rei78] </ref>. head (r) = fl 0 g, pos (r) = fl 1 ; : : : ; l m g, neg (r) = fl m+1 ; : : : ; l n g. head () is the union of head (r) for all rules from .
Reference: [Tur93] <author> H. Turner. </author> <title> A monotonicity theorem for extended logic programs. </title> <editor> In D. S. Warren, ed., </editor> <booktitle> Proc. 10th ICLP, </booktitle> <pages> pp. 567-585, </pages> <year> 1993. </year>
Reference: [Tur94] <author> H. Turner. </author> <title> Signed Logic Programs. </title> <editor> In Bruynooghe, M., ed., </editor> <booktitle> Proc. ILPS, </booktitle> <pages> pp. 61-75, </pages> <year> 1994. </year> <month> 18 </month>
References-found: 19

