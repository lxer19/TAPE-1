URL: http://www.cs.washington.edu/research/projects/lis/www/papers/postscript/chou-tvlsi.ps
Refering-URL: http://www.cs.washington.edu/research/projects/lis/www/papers/
Root-URL: 
Title: The Chinook Hardware/Software Co-Synthesis System  
Author: Pai H. Chou, Ross B. Ortega, Gaetano Borriello 
Date: November 15, 1995  
Address: Box 352350 Seattle, WA 98195-2350  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Designers of embedded systems are facing ever tighter constraints on design time. Unfortunately, tools today do not provide the right kind of help in the partitioning and mapping of a design onto hardware and software components. The Chinook co-synthesis system is an attempt to provide such a tool for control-dominated embedded system designs. It addresses the automation of the most time-consuming and error-prone tasks in embedded controller design, namely: the synthesis of interface hardware and software needed to integrate system components; the migration of functions between processors or custom logic; and the co-simulation of the design before and after synthesis. This paper describes the prin cipal elements of Chinook and discusses its application to a variety of embedded designs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Boussinot and R. De Simone. </author> <booktitle> The Esterel language. Proceedings of the IEEE, </booktitle> <volume> 79(9), </volume> <month> September </month> <year> 1991. </year>
Reference: [2] <author> CADENCE Design Systems, Inc. </author> <title> Programming Language Interface Reference Manual. CADENCE Design Systems, </title> <publisher> Inc., </publisher> <year> 1992. </year>
Reference-contexts: As abstract communications and operations become refined into more concrete signals and components, outputs from intermediate design steps and the final implementation can also be simulated with cycle-level accuracy. The simulator uses the Verilog-XL Programming Language Interface <ref> [2] </ref> to communicate with peripheral device models. The device models are written in C and make X-window calls to visually represent the simulated device. Each device model exports the same application program interface (API) for simulation and synthesis.
Reference: [3] <author> M. Chiodo et al. </author> <title> Hardware-software codesign of embedded systems. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 26-36, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: This is for the most part done informally using a mixture of natural language documents, pseudo-code, and block diagrams. This approach has made design maintenance, upgrading, and retargeting very time consuming and difficult. Several formal specification methods have been proposed including finite state machines <ref> [3] </ref>, Petri nets [24], and CSP [17]. Today's tools lie somewhere in the middle, using a high-level programming or a simulatable hard The Chinook Hardware/Software Co-Synthesis System 2 ware description language, because it enables some early validation of the design.
Reference: [4] <author> P. Chou and G. Borriello. </author> <title> Software scheduling in the co-synthesis of reactive real-time systems. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: We do not use critical regions to achieve atomic execution because they disable interleaving, which is necessary when servicing devices with long separation between sequential events. Instead, Chinook allows the user to define safe points in the handlers, where potential mode transitions can safely occur <ref> [4] </ref>. All parallel handlers must reach their safe points before a mode transition is allowed to take effect. 7 Simulation The design can be simulated at different levels of detail. The initial specification is compatible with behavioral Verilog and is simulated without exact timing or detailed I/O.
Reference: [5] <author> P. Chou and G. Borriello. </author> <title> Interval scheduling: Fine-grained software scheduling for embedded systems. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: These waveforms must meet intricate min/max timing constraints on the order of instruction cycles. Chinook meets these constraints by construction using a technique called interval scheduling <ref> [5] </ref> to statically schedule these instructions. The execution times of the operations are often variable, rather than exact values. This uncertainty comes from pipelining, interrupts, and caching effects at the instruction level, as well as data dependency and control flow at the program level.
Reference: [6] <author> P. Chou, R. Ortega, and G. Borriello. </author> <booktitle> Synthesis of the hardware/software interface in microcontroller-based systems. In Proceedings of the International Conference on Computer Aided Design, </booktitle> <pages> pages 488-495, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: The MMIO algorithm introduces minimal address matching logic by efficiently assigning the address bits to the devices. The MMIO algorithm has several steps (Fig. 6). First, it ensures that every device port except the guards can share the memory bus by applying forced sharing <ref> [6] </ref> if necessary. Second, all guarded device ports are assigned bits in the processor's data port or the remaining bits in the address port. Third, it allocates address bits to uniquely identify each device, and generates the address matching logic.
Reference: [7] <author> P. Chou, R. B. Ortega, and G. Borriello. </author> <title> Interface co-synthesis techniques for embedded systems. </title> <booktitle> In Proceedings of the International Conference on Computer Aided Design, </booktitle> <pages> pages 280-287, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: These ports can be accessed from software-like registers thus providing a low-cost and straightforward interfacing mechanism. Chinook provides a port allocation scheme that also outputs customized access routines to reflect the pin assignments <ref> [7] </ref>. The key idea is that an I/O port may be able to service multiple devices without glue logic and without performance penalties.
Reference: [8] <author> P. Chou, E. A. Walkup, and G. Borriello. </author> <title> Scheduling for reactive real-time systems. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 37-47, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: The SEQs can be viewed as a textual representation of the waveforms the processor will generate. SEQs are derived from the timing diagrams for the device's interfaces and are customized to the capabilities of the processor in question <ref> [8] </ref>. SEQs are basic-block primitives. All control constructs such as loops and conditionals are expressed in higher-level device drivers. Another difference between SEQs and drivers is that only SEQs may directly access device ports whereas drivers must access them via calls to SEQs. <p> In statically scheduling the software, Chinook first converts handlers within a mode into a single handler containing their bodies, possibly using unrolling, and then schedules this single partially-ordered handler by interleaving <ref> [8] </ref>. Note that a mode transition may be triggered by one of the handlers before other handlers run to completion, and the scheduler must maintain the integrity of all handler states.
Reference: [9] <author> T. Cormen, C. Leiserson, and R. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This technique frees (n dlog ne) bits from one-hot encoding by using a single dlog ne input decoder to implement n address comparators. If the two approaches above fail, then the algorithm attempts Huffman encoding <ref> [9] </ref> of the device-select field. Huffman encoding uniquely identifies each device with a variable number of address bits. It exploits situations where the devices require different numbers of bits in the device-control field. A device requiring more device-control bits is addressed by a shorter device-select pattern, and vice versa.
Reference: [10] <author> M. Cornero, F. Thoen, G. Goossens, and F. Curatelli. </author> <title> Software synthesis for real-time information processing systems. Code Generation for Embedded Processors, </title> <address> pages 260-296, </address> <year> 1995. </year>
Reference-contexts: This often leads designers to over-design their systems with faster processors or larger capacity logic devices than really needed, thereby increasing the cost. Other aspects of the embedded system design cycle include scheduling and retargetable code-generation <ref> [10, 22] </ref>, for different off-the-shelf processors as well as custom ones.
Reference: [11] <author> R. Ernst, J. Henkel, and T. Benner. </author> <title> Hardware-software cosynthesis for microcontrollers. </title> <journal> IEEE Design and Test of Computers, </journal> <volume> 10(4) </volume> <pages> 64-75, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Partitioning is the process of determining the components on which to implement portions of system functionality. Partitioning may be a split between a processor and auxiliary logic or among a set of processors. Attempts at automating partitioning have included simulated annealing algorithms <ref> [11] </ref> and hardware to software migration [14], but have for the most part ignored the problems of interfacing and communication between the parts. Interfacing is the process of connecting the components together.
Reference: [12] <author> D. D. Gajski and F. Vahid. </author> <title> Specification and design of embedded hardware-software systems. </title> <journal> IEEE Design and Test of Computers, </journal> <volume> 12(1) </volume> <pages> 53-67, </pages> <month> Spring </month> <year> 1995. </year>
Reference: [13] <author> B. Gladstone. </author> <title> Specification of timing in a digital system. </title> <booktitle> ASIC and EDA, </booktitle> <pages> pages 46-52, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: The first are requirements imposed on the user of the interface, while the last two are timing promises made by the device. When new devices are added to the device library, these constraints and their corresponding timing diagrams are entered via an interactive editor <ref> [13] </ref>. Chinook parses these files and synthesizes the device driver code by choosing a linear schedule of controller events, and inserting additional interface glue logic where necessary [29].
Reference: [14] <author> R. Gupta and G. De Micheli. </author> <title> Hardware-software cosynthesis for digital systems. </title> <journal> Computers and Electrical Engineering, </journal> <volume> 10(3) </volume> <pages> 29-41, </pages> <month> September </month> <year> 1993. </year> <note> The Chinook Hardware/Software Co-Synthesis System 23 </note>
Reference-contexts: Partitioning is the process of determining the components on which to implement portions of system functionality. Partitioning may be a split between a processor and auxiliary logic or among a set of processors. Attempts at automating partitioning have included simulated annealing algorithms [11] and hardware to software migration <ref> [14] </ref>, but have for the most part ignored the problems of interfacing and communication between the parts. Interfacing is the process of connecting the components together.
Reference: [15] <author> R. K. Gupta and G. De Micheli. </author> <title> Constrained software generation for hardware-software systems. </title> <booktitle> In Proceedings of the Third International Workshop on Hardware/Software Codesign, </booktitle> <pages> pages 56-63, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Experimental results show that the best heuristic uses the min-separation as the primary cost function, with the amount of uncertainty in the execution delay as the secondary heuristic. It consistently outperforms one that solves the same problem inexactly <ref> [15] </ref>. E a run B EA B D C 0 2 4 6 8 10 12 14 min-run row is the max-run. The third row is another run with execution delays randomly chosen from the ranges. The idle spacing is the same in all runs.
Reference: [16] <author> D. Harel. StateCharts: </author> <title> a visual formalism for complex systems. </title> <journal> Science of Programming, </journal> <volume> 8, </volume> <year> 1987. </year>
Reference: [17] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: This approach has made design maintenance, upgrading, and retargeting very time consuming and difficult. Several formal specification methods have been proposed including finite state machines [3], Petri nets [24], and CSP <ref> [17] </ref>. Today's tools lie somewhere in the middle, using a high-level programming or a simulatable hard The Chinook Hardware/Software Co-Synthesis System 2 ware description language, because it enables some early validation of the design. However, there is still no accepted formalization of the timing and performance constraints.
Reference: [18] <author> D. C. Ku and G. De Micheli. </author> <title> Relative scheduling under timing constraints: algorithms for high-level synthesis of digital circuits. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 11(6), </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: A min-run is one where all operations take their lower-bound execution delays; similarly, a max run is the longest possible execution of the schedule. To solve this problem, we use a graph formulation similar to relative scheduling <ref> [18] </ref>. A backtracking algorithm performs a topological traversal on the graph and computes a valid schedule for the min-run. An important theorem is that if the max-run of this schedule also meets all timing constraints, then all runs of the schedule can meet all timing constraints.
Reference: [19] <author> J. Kuskin et al. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In 21st Annual Internation Symposium on Computer Architecture, </booktitle> <pages> pages 302-313, </pages> <year> 1994. </year>
Reference-contexts: r i v r net driver m m r i v r proc driver I / O a d r proc handler net handler M A G I C the MAGIC system. 8.3 MAGIC The MAGIC (Memory and General Interconnect Controller) is a custom node controller for the FLASH architecture <ref> [19] </ref>. It communicates with a processor, network, I/O devices and DRAM (see Figure 17b). We modeled this architecture with three handlers, one for the processor requests, one for the network requests and one for the I/O requests.
Reference: [20] <author> E. A. Lee and S. Ha. </author> <title> Scheduling strategies for multiprocessor real-time DSP. </title> <booktitle> In Proceedings of GLOBECOM, </booktitle> <volume> volume 2, </volume> <pages> pages 1279-1283, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: An interval schedule is valid if for all combinations of actual delay values, all timing constraints are satisfied. This may be classified as self-timed scheduling according to <ref> [20] </ref> in the sense that resource assignment and ordering are statically determined, but the actual timing is not known until run-time. The Chinook Hardware/Software Co-Synthesis System 18 - A B C -ffi u run 1 t (A) t (B) t (C) computed based on the worst-case delays.
Reference: [21] <author> S. Malik, W. Wolf, A. Wolfe, Y.-T. S. Li, and T.-Y. Yen. </author> <title> Performance analysis of embedded systems. </title> <editor> In M. Sami and G. DeMicheli, editors, Hardware/Software Co-Design. </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1996. </year>
Reference-contexts: Other aspects of the embedded system design cycle include scheduling and retargetable code-generation [10, 22], for different off-the-shelf processors as well as custom ones. In order to meet timing constraints with confidence, analysis tools such as [26] <ref> [21] </ref> are needed to predict execution times and possibly the size of code fragments, Finally, simulators, debuggers, and profilers are needed to evaluate the final design at a detailed level.
Reference: [22] <author> P. Marwedel and G. Goossens, </author> <title> editors. Code Generation for Embedded Processors. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: This often leads designers to over-design their systems with faster processors or larger capacity logic devices than really needed, thereby increasing the cost. Other aspects of the embedded system design cycle include scheduling and retargetable code-generation <ref> [10, 22] </ref>, for different off-the-shelf processors as well as custom ones.
Reference: [23] <author> A. K. Mok. </author> <title> The design of real-time programming systems based on process models. </title> <booktitle> In Real Time Systems Symposium, </booktitle> <pages> pages 5-17, </pages> <year> 1984. </year>
Reference-contexts: Their interaction with the devices and the environment must respect not only low-level signaling constraints but also performance requirements such as rate and response time constraints. To satisfy these high-level constraints, designers have used process-based scheduling techniques based on operating systems concepts <ref> [23] </ref>. These techniques are coarse-grained, priority-driven, and dynamically preemptive. They assume that the processor does not perform I/O directly and the processes are independent of each other. Since all timing constraints are coarse-grained, overhead incurred by the executive during preemption can be dismissed.
Reference: [24] <author> T. Murata. </author> <title> Petri nets: Properties, analysis, </title> <booktitle> and applications. Proceedings of the IEEE, </booktitle> <volume> 77(4) </volume> <pages> 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: This is for the most part done informally using a mixture of natural language documents, pseudo-code, and block diagrams. This approach has made design maintenance, upgrading, and retargeting very time consuming and difficult. Several formal specification methods have been proposed including finite state machines [3], Petri nets <ref> [24] </ref>, and CSP [17]. Today's tools lie somewhere in the middle, using a high-level programming or a simulatable hard The Chinook Hardware/Software Co-Synthesis System 2 ware description language, because it enables some early validation of the design. However, there is still no accepted formalization of the timing and performance constraints.
Reference: [25] <author> J. Ousterhout. </author> <title> TCL and the TK Toolkit. </title> <publisher> Addison-Wesley Publishing Company, Inc, </publisher> <year> 1994. </year>
Reference-contexts: The processor library contains a cycle-accurate simulation model for structural validation. This model interprets the binary code produced by the code generator. A TCL (Tool Command Language) <ref> [25] </ref> interface to the processor simulator, allows designers to customize debugging information presented on the screen during a simulation run. Because the behavioral simulator is processor-independent, only a structural processor simulation model is required.
Reference: [26] <author> C. Y. Park. </author> <title> Predicting Deterministic Execution Times of Real-Time Programs. </title> <type> PhD thesis, </type> <institution> University of Wash-ington, </institution> <year> 1992. </year> <type> Technical Report 92-08-02, </type> <institution> Department of Computer Science & Engineering. </institution>
Reference-contexts: Other aspects of the embedded system design cycle include scheduling and retargetable code-generation [10, 22], for different off-the-shelf processors as well as custom ones. In order to meet timing constraints with confidence, analysis tools such as <ref> [26] </ref> [21] are needed to predict execution times and possibly the size of code fragments, Finally, simulators, debuggers, and profilers are needed to evaluate the final design at a detailed level.
Reference: [27] <author> M. Srivastava, B.C.Richards, and R.W.Brodersen. </author> <title> System level hardware module generation. </title> <journal> IEEE Transactions on VLSI Systems, </journal> <volume> 3(1), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: Designers spend a large fraction of the time in interfacing system components to each other and the operating environment (including user interfaces) because it is where the bulk of errors lie. However, interfacing remains one of the least addressed areas in co-synthesis tools. Interface generation has been described in <ref> [27] </ref>, though the synthesis of interface software is not addressed. In practice, the process of design space exploration is so time-consuming that many designers fix the target architecture and system components well before a complete evaluation of the final system can be done and perform only a single mapping.
Reference: [28] <author> D. Thomas and P. Moorby. </author> <title> The Verilog hardware description language. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: To do this, Chinook needs knowledge about the interface information, which is captured in the component library. 3.1 System Description The designer supplies a high-level description of the system. Currently Chinook supports the Verilog hard ware description language <ref> [28] </ref>. The description contains both structural and behavioral constructs. 3.1.1 Structural Description The structural description in the Verilog file instantiates the principal components of the system, including processors, peripheral devices, and communication interfaces.
Reference: [29] <author> E. A. Walkup and G. Borriello. </author> <title> Interface timing verification with application to synthesis. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: When new devices are added to the device library, these constraints and their corresponding timing diagrams are entered via an interactive editor [13]. Chinook parses these files and synthesizes the device driver code by choosing a linear schedule of controller events, and inserting additional interface glue logic where necessary <ref> [29] </ref>. This hardware consists of simple finite-state machines that generate or capture signal events during communication with the peripheral device. 4.3 I/O Port Allocation Many processors used in embedded systems include I/O ports that can be used to directly sense and manipulate the processor's environment.
Reference: [30] <author> M. Weiser. </author> <title> Some computer science issues in ubiquitous computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(7) </volume> <pages> 74-84, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The processor model faithfully reproduces, within cycle-level accuracy, the appropriate waveforms on the processor's pins. 8 Examples Several embedded systems have been designed using the Chinook tools. The following examples show the type of complexity that the current version supports. They are an infrared local-area network <ref> [30] </ref>, portable electronic phonebook, a node controller for a distributed system, and a mobile defibrillator. The Chinook Hardware/Software Co-Synthesis System 20 8.1 Infrared Local-Area Network We applied Chinook to the class of devices that can be used with an infrared local-area network [30]. <p> They are an infrared local-area network <ref> [30] </ref>, portable electronic phonebook, a node controller for a distributed system, and a mobile defibrillator. The Chinook Hardware/Software Co-Synthesis System 20 8.1 Infrared Local-Area Network We applied Chinook to the class of devices that can be used with an infrared local-area network [30]. The types of possible devices range from transceivers connected to a workstation or a laptop all the way to simple identification tags for tracking people and objects. Each device must implement the same communication protocol but within very different cost constraints.
References-found: 30

