URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-92-27.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Smart Pointers: They're Smart, but They're Not Pointers  
Author: Daniel R. Edelson 
Address: Santa Cruz, CA 95064 USA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Date: 10 June 1992  
Pubnum: UCSC-CRL-92-27  
Abstract: fl This research was performed while the author was a visiting researcher at INRIA Project SOR, BP 105 Rocquencourt, 78153 Le Chesnay CEDEX, FRANCE. This work was supported in part by Esprit project 5279 Harness. This paper first appeared in Proc. 1992 Usenix C++ Conference, Usenix Association, 1992, pp 1-19. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [ANS91] <institution> ANSI X3J16/ISO WG21 working document X3J16/91-0115, </institution> <month> May </month> <year> 1991. </year> <title> Draft ANSI/ISO standard for the C++ programming language. </title>
Reference-contexts: T [] Tfl array ) pointer to first element 13. T (args) T (fl)(args) except following & or before () 14. Tfl voidfl provided T is not const or volatile 15. T (fl)(args) voidfl provided sufficient bits are available <ref> [ANS91, x4.6, line 6] </ref> Class 2: User-defined Conversions 16. conversion by constructor 17. conversion by conversion operator 3 2. Smart Pointers Smart pointers are class objects that behave like raw pointers [Str87, Str91]. <p> If this operator could be overloaded such that it altered the value of the pointer, then the error could be avoided. Note, the current language definition does not explicitly forbid overloading this operator, nor does it explicitly permit it <ref> [ANS91] </ref>, however, it seems inevitable that overloading this operator will eventually be prohibited. 2.2.3 Another Error with Pointer Hierarchies There is one other error that the schemes presented in the last two subsections both share: they both permit an incorrect, implicit type conversion.
Reference: [Cop92] <author> James Coplien. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of <ref> [Cop92] </ref>) or garbage collection [Ken91, Ede92]. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. The smart pointer overloads the indirection operators in order to be usable with normal pointer syntax. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting <ref> [Ken91, Mae92, MIKC92, Cop92] </ref>, * convenient access to persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others.
Reference: [DMS92] <author> Peter Dickman, Messac Makpangou, and Marc Shapiro. </author> <title> Contrasting fragmented objects with uniform transparent object references for distributed programming. </title> <booktitle> In SIGOPS 1992 European Workshop on Models and Paradigms for Distributed Systems Structuring, </booktitle> <year> 1992. </year>
Reference-contexts: Accessors 3. Accessors Kennedy describes accessors in OATH [Ken91] as an alternative to smart pointers. The central difference between accessors and smart pointers is that accessors don't overload the indirection operators; instead, like stubs <ref> [DMS92] </ref>, they duplicate all the public member functions of the referent object and forward those calls through a pointer to the object.
Reference: [Ede92] <author> Daniel R. Edelson. </author> <title> Precompiling C++ for garbage collection. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <year> 1992. </year> <note> To appear in the Spring-Verlag Lecture Notes in Computer Science. </note>
Reference-contexts: For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection <ref> [Ken91, Ede92] </ref>. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. The smart pointer overloads the indirection operators in order to be usable with normal pointer syntax. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection <ref> [Ede92] </ref>, * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others. <p> In other cases, it is not critical that the application be prevented from obtaining raw pointers. For example, mark-and-sweep garbage collectors can normally tolerate the existence of raw pointers, provided the raw pointers point at objects that are also referenced by smart pointers <ref> [Ede92] </ref>. Smart pointers leak raw pointers because of the definition in C ++ of the overloaded indirect member access operator, -&gt;. When the compiler sees an expression of the form X-&gt;Y, where X is an expression of class type, the compiler evaluates X.operator-&gt;().
Reference: [Gau92] <author> Philippe Gautron. </author> <title> Don't convert smart pointers to voidfl, 1992. </title> <type> Private communication. </type>
Reference-contexts: Smart pointers may supply a conversion to voidfl in order to be usable directly used in control statements, e.g. if (ptr) and while (ptr). The conversion to voidfl may also be seen as undesirable <ref> [Gau92] </ref>, in which case all testing is explicit using overloaded comparison operators. Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some.
Reference: [Gro92] <author> Ed Grossman. </author> <title> Using smart pointers for transparent access to objects on disk or across a network, 1992. </title> <type> Private communication. </type>
Reference-contexts: For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, * instrumenting (measuring) the code, * or others. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. Achieving the ideal, i.e. making the smart pointer semantics a superset of raw pointer semantics, is impossible (as we will show).
Reference: [HM90] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Towards compile-time optimizations for persistence. </title> <booktitle> In 4 th Inter. Workshop on Persistent Object Systems, </booktitle> <pages> pages 17-27. </pages> <publisher> Morgan Kaufman (1991), </publisher> <year> 1990. </year>
Reference-contexts: Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [Ken91] <author> Brian Kennedy. </author> <title> The features of the object-oriented abstract type hierarchy (OATH). </title> <booktitle> In Proc. Usenix C++ Conference, </booktitle> <pages> pages 41-50. </pages> <publisher> Usenix Association, </publisher> <month> April </month> <year> 1991. </year>
Reference-contexts: For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection <ref> [Ken91, Ede92] </ref>. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. The smart pointer overloads the indirection operators in order to be usable with normal pointer syntax. <p> Given this, we conclude that the C ++ programming language does not support seamless smart pointers: smart pointers cannot transparently replace raw pointers in all ways except declaration syntax. We show that this conclusion also applies to accessors <ref> [Ken91] </ref>. The organization of this paper is as follows: Section 1 very briefly summarizes the behavior of raw pointers that smart pointers try to emulate, particularly in terms of the standard type conversions. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting <ref> [Ken91, Mae92, MIKC92, Cop92] </ref>, * convenient access to persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others. <p> This problem is less severe than the problem identified in x2.1.2; this is a more viable implementation. 2.2 Inheritance Hierarchy In the previous section, we discussed emulating the standard pointer conversions with user-defined conversions. It is also possible to emulate them using the standard reference conversions <ref> [Ken91] </ref>. We arrange the smart pointer classes in a class hierarchy that parallels the object hierarchy. Figure 2.2 illustrates this. Since class Pc derives from Pb, any instance of Pc can be converted to an instance of Pb through the standard Derived& to Base& conversion. <p> For example, if smart pointers are used to implement copying garbage collection, then after a garbage collection, all dynamically allocated objects have been moved and any raw pointer no longer has the correct value. 2.5. Other Weaknesses 15 As another example, <ref> [Ken91] </ref> discusses why the problem of raw pointer leakage makes smart pointers unsafe for reference counting. The basic idea is that the application can obtain reference counted pointer as a temporary expression, perhaps as the return value from a function. <p> This is the main problem that accessors solve. 1 These operators may be chained together, but must eventually return a raw pointer. 16 3. Accessors 3. Accessors Kennedy describes accessors in OATH <ref> [Ken91] </ref> as an alternative to smart pointers. The central difference between accessors and smart pointers is that accessors don't overload the indirection operators; instead, like stubs [DMS92], they duplicate all the public member functions of the referent object and forward those calls through a pointer to the object. <p> Accessors are somewhere in between smart pointers and smart references, because they implement pointer semantics, but use `.' rather than `-&gt;' to access the underlying object. to reproduce all the functionality described in <ref> [Ken91] </ref>, instead, it just shows the relation between the application class and the accessor class. Accessors are clearly superior to smart pointers because they prevent raw pointer leakage. However, they are difficult to declare because every member function of the application class must also be declared in the accessor class.
Reference: [Mae92] <author> Roman E. Maeder. </author> <title> A provably correct reference count scheme for a symbolic computation system. In unpublished form, </title> <year> 1992. </year>
Reference-contexts: Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting <ref> [Ken91, Mae92, MIKC92, Cop92] </ref>, * convenient access to persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others.
Reference: [MIKC92] <author> Peter W. Madany, Nayeem Islam, Panos Kougiouris, and Roy H. Campbell. </author> <title> Reification and reflection in C++: An operating systems perspective. </title> <type> Technical Report UIUCDCS-R-92-1736, </type> <institution> Dept. of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: 1. Introduction The ability to substitute user-defined code for pointers is a very powerful programming mechanism. It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems <ref> [MIKC92, SGH + 89, Str91, pg. 244] </ref>, to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken91, Ede92]. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. <p> It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g. the ObjectStars of <ref> [MIKC92] </ref> or the counted pointers idiom of [Cop92]) or garbage collection [Ken91, Ede92]. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. The smart pointer overloads the indirection operators in order to be usable with normal pointer syntax. <p> Smart pointers may optionally supply a conversion to the corresponding raw pointer types. Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting <ref> [Ken91, Mae92, MIKC92, Cop92] </ref>, * convenient access to persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others. <p> Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [Sal92] <author> Hayssam Saleh. </author> <title> Conception et realisation d'un systeme pour la programmation d'applications objets concurrentes et reparties sur machines paralleles. </title> <type> PhD thesis, </type> <institution> Universite Pierre et Marie Curie|Paris VI, </institution> <year> 1992. </year>
Reference-contexts: However, the conversion from Derivedflfl to Baseflfl is prohibited because it introduces a gaping hole in the otherwise (mostly) safe type system. Specifically, given two objects whose classes are different but have a common base, this conversion allows you to incorrectly compare or assign pointers to these objects <ref> [Sal92] </ref>. Figure 2.4 provides a example of how this conversion allows assignment between two incompatible pointer types. With a class hierarchy of smart pointers, this conversion is not just between Derivedflfl and Baseflfl; it is also between Derivedfl and Basefl because the smart pointer classes are related through inheritance.
Reference: [SDP92] <author> Marc Shapiro, Peter Dickman, and David Plainfosse. </author> <title> Robust, distributed references and acyclic garbage collection. </title> <booktitle> In Symp. on Principles of Distributed Computing, </booktitle> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: 1. Introduction The ability to substitute user-defined code for pointers is a very powerful programming mechanism. It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems <ref> [SDP92, SMC92] </ref>, persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken91, Ede92]. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. <p> For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, * instrumenting (measuring) the code, * or others. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. Achieving the ideal, i.e. making the smart pointer semantics a superset of raw pointer semantics, is impossible (as we will show).
Reference: [SGH + 89] <author> Marc Shapiro, Yvon Gourhant, Sabine Habert, Laurence Mosseri, Michel Ruffin, and Celine Valot. </author> <title> SOS: An object-oriented operating system|assessment and perspectives. </title> <journal> Comput. Syst., </journal> <volume> 2(4) </volume> <pages> 287-338, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: 1. Introduction The ability to substitute user-defined code for pointers is a very powerful programming mechanism. It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems <ref> [MIKC92, SGH + 89, Str91, pg. 244] </ref>, to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken91, Ede92]. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. <p> Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [SGM89] <author> Marc Shapiro, Philippe Gautron, and Laurence Mosseri. </author> <title> Persistence and migration for C++ objects. </title> <editor> In Stephen Cook, editor, ECOOP'89, </editor> <booktitle> Proc. of the Third European Conf. on Object-Oriented Programming, British Computer Society Workshop Series, </booktitle> <pages> pages 191-204, </pages> <address> Nottingham (GB), </address> <month> July </month> <year> 1989. </year> <institution> The British Computer Society, Cambridge University Society. </institution> <address> References 21 </address>
Reference-contexts: Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
Reference: [SMC92] <author> Marc Shapiro, Julien Maisonneuve, and Pierre Collet. </author> <title> Implementing references as chains of links. </title> <booktitle> In Workshop on Object Orientation in Operating Systems, </booktitle> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: 1. Introduction The ability to substitute user-defined code for pointers is a very powerful programming mechanism. It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems <ref> [SDP92, SMC92] </ref>, persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken91, Ede92]. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. <p> For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects [SGH + 89, Str91, HM90, SGM89, MIKC92], * uniform access to distributed objects <ref> [SDP92, Gro92, SMC92] </ref>, * instrumenting (measuring) the code, * or others. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers. Achieving the ideal, i.e. making the smart pointer semantics a superset of raw pointer semantics, is impossible (as we will show).
Reference: [Str87] <author> Bjarne Stroustrup. </author> <title> The evolution of C++ 1985 to 1987. </title> <booktitle> In Proc. Usenix C++ Workshop, </booktitle> <pages> pages 1-22. </pages> <publisher> Usenix Association, </publisher> <month> November </month> <year> 1987. </year>
Reference-contexts: 1. Introduction The ability to substitute user-defined code for pointers is a very powerful programming mechanism. It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers <ref> [Str87] </ref> or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems [MIKC92, SGH + 89, Str91, pg. 244], to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken91, Ede92]. <p> Tfl voidfl provided T is not const or volatile 15. T (fl)(args) voidfl provided sufficient bits are available [ANS91, x4.6, line 6] Class 2: User-defined Conversions 16. conversion by constructor 17. conversion by conversion operator 3 2. Smart Pointers Smart pointers are class objects that behave like raw pointers <ref> [Str87, Str91] </ref>. The smart pointers overload the indirection operators (fl and -&gt;) in order to be usable with normal pointer syntax. They have constructors that permit them to be initialized with raw pointers such as new returns.
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> 2 nd edition, </address> <year> 1991. </year>
Reference-contexts: 1. Introduction The ability to substitute user-defined code for pointers is a very powerful programming mechanism. It facilitates using C ++ in domains for which the language is not specialized. For example, smart pointers [Str87] or variations thereof can be used to support distributed systems [SDP92, SMC92], persistent object systems <ref> [MIKC92, SGH + 89, Str91, pg. 244] </ref>, to provide reference counting (e.g. the ObjectStars of [MIKC92] or the counted pointers idiom of [Cop92]) or garbage collection [Ken91, Ede92]. In this paradigm, a smart pointer encapsulates some kind of raw pointer or complex handle. <p> Tfl voidfl provided T is not const or volatile 15. T (fl)(args) voidfl provided sufficient bits are available [ANS91, x4.6, line 6] Class 2: User-defined Conversions 16. conversion by constructor 17. conversion by conversion operator 3 2. Smart Pointers Smart pointers are class objects that behave like raw pointers <ref> [Str87, Str91] </ref>. The smart pointers overload the indirection operators (fl and -&gt;) in order to be usable with normal pointer syntax. They have constructors that permit them to be initialized with raw pointers such as new returns. <p> Our goal in manipulating smart pointers is to have all the functionality of regular pointers and then some. For example, the `and then some' might be: * tracing garbage collection [Ede92], * reference counting [Ken91, Mae92, MIKC92, Cop92], * convenient access to persistent objects <ref> [SGH + 89, Str91, HM90, SGM89, MIKC92] </ref>, * uniform access to distributed objects [SDP92, Gro92, SMC92], * instrumenting (measuring) the code, * or others. To accomplish this, the smart pointers should look and feel, to the greatest extent possible, like raw pointers.
References-found: 18

