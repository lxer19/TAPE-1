URL: http://www.cs.berkeley.edu/~fredwong/research/PAPER/dsvm.ps
Refering-URL: http://www.cs.berkeley.edu/~fredwong/research/research.htm
Root-URL: 
Email: -tzuyi,fredwong-@cs.berkeley.edu  
Title: On the Usability of User-Level, All-Software Distributed Shared Memory  
Author: Tzu-Yi Chen and Frederick Wong 
Abstract: All-software, user-level distributed shared memory (DSM) systems claim to be efficient, portable, and simple-to-use --- and hence claim to be a reasonable alternative to message-passing standards such as MPI. This paper presents the performance of two recent user-level all-software DSM systems on both data and task parallel applications on a network of workstations. We find the claims of DSM systems to be exaggerated, and identify barriers to the efficiency and usability of all-software, user-level DSM systems. Finally, we propose ways to improve such DSM systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. L. Johnson, M. F. Kaashoek, and D. A. Wallach. </author> <title> CRL: High-Performance All-Software Distributed SHared Memory. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating Systems Principles, </booktitle> <month> Dec </month> <year> 1995. </year>
Reference-contexts: Traditionally these applications have been coded using a message passing paradigm. However, it is speculated that this is primarily due to the inability of alternatives to provide reasonable performance. <ref> [1] </ref> Message passing requires the programmer to explicitly control the communication in programs. Because the programmer, familiar with her application, can therefore control both what data is communicated as well as when data is communicated, applications written using message passing can be very efficient. <p> The first system we studied requires only mechanisms for sending and receiving messages. In addition, the second requires also the existence of a few common system calls for interacting with the paging mechanisms. CRL The C Region Library (CRL) <ref> [1] </ref> is a region based all-software, user-level DSM system. To use CRL, a programmer defines regions and controls access to them all through annotations provided by the library, and then links to the library when compiling.
Reference: [2] <author> C. Amza, A. L. Cox, S. Dwarkadas, P. Keleher, H. Lu, R. Rajamony, W. Yu, and W. Zwaenepoel. TreadMarks: </author> <title> Shared Memory Computing on Networks of Workstations. </title> <journal> IEEEC, </journal> <volume> 29(2) </volume> <pages> 18-28, </pages> <month> Feb </month> <year> 1996. </year>
Reference: [3] <author> P. Keleher, S. Dwarkadas, A. L. Cox, and W. Zwaenepoel. TreadMarks: </author> <title> Distributed Shared Memory on Standard Workstations and Operating Systems. </title> <booktitle> In Proceedings of the Winter 1994 USENIX Conference, </booktitle> <pages> pages 115-131, </pages> <month> Jan </month> <year> 1994. </year>
Reference: [4] <author> H. Lu. </author> <title> Message Passing Versus Distributed Shared Memory on Networks of Workstations. </title> <type> Masters thesis, </type> <institution> Rice University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Unfortunately, this leads to complicated protocols (such as their multiple-writer protocol) and a complicated implementation 1 . A comparison of TreadMarks to PVM, a message passing system, is done in <ref> [4] </ref>, and is similar to the analysis we did here. <p> Obviously if the data were better distributed at first, the time represented by the green line could be largely eliminated. code, both with and without the first iteration (the lowermost line and the second line from the top, respectively), with the TreadMarks speedups from <ref> [4] </ref> (the uppermost line) and also the speedups of a non-optimal MPI version of the code that was our first try at implementing the code in MPI (the second line from the bottom) 1 .
Reference: [5] <author> B. N. Bershad, M. J. Zekauskas, and W. A. Saw-don. </author> <title> THe Midway Distributed Shared Memory System. </title> <booktitle> In COMPCON93, </booktitle> <pages> pages 528-537, </pages> <month> Feb </month> <year> 1993. </year>
Reference: [6] <author> M. J. Zekauskas, W. A. Sawdon, and B. N. Ber-shad. </author> <title> Software Write Detection for a Distributed Shared Memory. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <year> 1994. </year>
Reference: [7] <author> T-C. Chiueh and M. Verma. </author> <title> A Compiler-Directed Distributed Shared Memory System. </title> <booktitle> In Proceedings of the 1995 Intl Conference on Supercomputing, </booktitle> <pages> pages 77-86, </pages> <month> Jul </month> <year> 1995. </year>
Reference-contexts: Examples are Midway [5,6], which includes a set of keywords and function calls for annotating programs, and a compiler for generating code to maintain reference information regarding shared data; Locust <ref> [7] </ref>, which requires compiler support to that the Locust runtime system can exploit data dependency information gathered at compile time to handle coordination between processes; and Munin [8], which uses language extensions to define shared objects and to specify reference patterns for them.
Reference: [8] <author> J. B. Carter, J. K. Bennett, and W. Zwaenepoel. </author> <title> Implementation and Performance of Munin. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles (SOSP91), </booktitle> <pages> pages 152-164, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: set of keywords and function calls for annotating programs, and a compiler for generating code to maintain reference information regarding shared data; Locust [7], which requires compiler support to that the Locust runtime system can exploit data dependency information gathered at compile time to handle coordination between processes; and Munin <ref> [8] </ref>, which uses language extensions to define shared objects and to specify reference patterns for them. Still other software based DSM systems check whether references require off-processor communication by checking the VM protection bits using a technique described in [9].
Reference: [9] <author> A. W. Appel and K. Li. </author> <title> Virtual Memory Primitives for User Programs. </title> <type> Technical Report CS-TR-276-90, </type> <institution> Princeton University, </institution> <year> 1990. </year>
Reference-contexts: Still other software based DSM systems check whether references require off-processor communication by checking the VM protection bits using a technique described in <ref> [9] </ref>. Ivy [10] is an example of such a system. 2.3 Other DSM Systems DSM mechanisms can be implemented all in software, all in hardware, or in some combination of the two. Implementations that require hardware support tend to be faster, at the cost of portability.
Reference: [10] <author> K. Li. IVY: </author> <title> A Shared Virtual Memory System for Parallel Computing. </title> <booktitle> In 1988 International Conference on Parallel Processing, </booktitle> <volume> volume 2, </volume> <pages> pages 94-101, </pages> <year> 1988. </year>
Reference-contexts: Still other software based DSM systems check whether references require off-processor communication by checking the VM protection bits using a technique described in [9]. Ivy <ref> [10] </ref> is an example of such a system. 2.3 Other DSM Systems DSM mechanisms can be implemented all in software, all in hardware, or in some combination of the two. Implementations that require hardware support tend to be faster, at the cost of portability.
Reference: [11] <author> L. Iftode, C. Dubnicki, E. W. Felten, and K. Li. </author> <title> Improving Release-Consistent Shared Virtual Memory using Atomic Update. </title> <booktitle> In Proceedings of the 2nd Intl Symposium on High Performance Computer Architecture., </booktitle> <month> Feb </month> <year> 1996. </year>
Reference-contexts: Implementations that require hardware support tend to be faster, at the cost of portability. DSM systems requiring special hardware support include Shrimp <ref> [11] </ref> and the DASH and FLASH [12] projects. 2.4 General Reference A web site with pointers to many distributed shared memory projects (both hardware and software) is located at [13]. Most articles describing new DSM systems have sections on related work.
Reference: [12] <author> J. Kuskin, D. Ofelt, M. Heinrich, J. Heinlein, R. Simoni, K. Gharachorloo, J. Chapin, D. Naka-hira, J. Baxter, M. Horowitz, A. Gupta, M. Rosenblum, and J. Hennessey. </author> <title> The Stanford FLASH Multiprocessor. </title> <booktitle> In Proceedings of the 21st Intl Symposium on Computer Architecture, </booktitle> <pages> pages 302-313, </pages> <address> Chicago, IL, </address> <month> Apr </month> <year> 1994. </year>
Reference-contexts: Implementations that require hardware support tend to be faster, at the cost of portability. DSM systems requiring special hardware support include Shrimp [11] and the DASH and FLASH <ref> [12] </ref> projects. 2.4 General Reference A web site with pointers to many distributed shared memory projects (both hardware and software) is located at [13]. Most articles describing new DSM systems have sections on related work.
Reference: [13] <institution> Web page on Distributed Shared Memory. </institution> <note> url: http://www.cs.umd.edu/users/keleher/dsm.html </note>
Reference-contexts: DSM systems requiring special hardware support include Shrimp [11] and the DASH and FLASH [12] projects. 2.4 General Reference A web site with pointers to many distributed shared memory projects (both hardware and software) is located at <ref> [13] </ref>. Most articles describing new DSM systems have sections on related work. In addition, past articles that compared various DSM systems include [14]. 3 Results This section describes how we collected our data, then presents and analyzes our results. 3.1 Preliminaries We chose two applications that exhibited very different characteristics.
Reference: [14] <author> B. Nitzberg and V. Lo. </author> <title> Distributed Shared Memory.: A Survey of Issues and Algorithms. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 52-60, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Most articles describing new DSM systems have sections on related work. In addition, past articles that compared various DSM systems include <ref> [14] </ref>. 3 Results This section describes how we collected our data, then presents and analyzes our results. 3.1 Preliminaries We chose two applications that exhibited very different characteristics. The first is the solving of the heat equation on a 2D grid using the red-black Gauss Seidel algorithm.
Reference: [15] <author> T. Eicken, D. Culler, S. Goldstein, and K. Schauser, </author> <title> Active Messages: a Mechanism for Integrated Communication and Computation, </title> <booktitle> In Proceedings of the 19th International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1992., </year> <title> Gold Coast, Qld., </title> <booktitle> Australia, </booktitle> <pages> pp. 256-266. </pages>
Reference-contexts: We discuss the efficiency of dynamic load-balancing in the context of CRL by examining the communication cost versus the degree of parallelism. Performance results are obtained on two implementations of CRL - - CRL on TCP/IP, and CRL on Active Messages (AM) <ref> [15] </ref>.
Reference: [16] <author> D. Culler, K. Keeton, C. Krumbein, L. Liu, A. Mainwaring, R. Martin, S. Rodrigues, K. Wright, and C. Yoshikawa, </author> <title> Generic Active Message Interface Specification, </title> <month> February </month> <year> 1995. </year>
Reference-contexts: If the region is invalid, the routine finds the owner of the region and fetches the most update version of the region from the owner. All invalidations and data transfers are done in a request-reply-like model. Generic Active Messages (GAM) <ref> [16] </ref> is an interface specification for Active Messages (AM). Since the TCP/IP version of CRL is based on a version coded for the CM-5 version of AM, the communication interface closely resembles that of GAM. However, a few important issues should be noted for the GAM implementation.
Reference: [17] <author> B. Bershad, S. Savage, P. Pardyak, E. G. Sirer M. E. Fiuczynski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In the Proceedings of the Fifteenth Symposium on Operating Systems Principles. </booktitle> <year> 1995. </year>
Reference-contexts: Furthermore, non-blocking synchronization can be introduced into the application programming interface of CRL to improve the performance by application level prefetching of shared data. These extension to the existing DSM systems also requires specialized operating system supports. RISC OS, like Spin <ref> [17] </ref>, can helps to improve the responsiveness of polling thread in CRL-GAM implementation by exporting thread scheduling services to application level.
References-found: 17

