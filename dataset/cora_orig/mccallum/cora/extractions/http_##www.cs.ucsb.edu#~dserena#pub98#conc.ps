URL: http://www.cs.ucsb.edu/~dserena/pub98/conc.ps
Refering-URL: http://www.cs.ucsb.edu/~dserena/
Root-URL: http://www.cs.ucsb.edu
Title: Improved Concurrency Control Techniques for Multi-dimensional Index Structures  
Author: K. V. Ravi Kanth, David Serena, Ambuj K. Singh 
Address: Santa Barbara, CA 93117.  
Affiliation: Department of Computer Science, University of California,  
Abstract: Multi-dimensional index structures such as R-trees enable fast searching in high-dimensional spaces. They differ from uni-dimensional structures in the following aspects: (1) index regions in the tree may be modified during ordinary insert and delete operations, and (2) node splits during inserts are quite expensive. Both these characteristics may lead to reduced concurrency of update and query operations. In this paper, we examine how to achieve high concurrency for multi-dimensional structures. First, we develop a new technique for efficiently handling index region modifications. Then, we extend it to reduce/eliminate query blocking overheads during node-splits. We examine two variants of this extended scheme one that reduces the blocking overhead for queries, and another that completely eliminates it. Experiments on image data on a shared-memory multiprocessor show that these schemes achieve up to 2 times higher throughput than existing techniques, and scale well with the number of processors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. H. Anderson and M. Moir. </author> <title> Universal constructions for large objects. </title> <booktitle> In WDAG '95, volume 972 of LNCS, </booktitle> <pages> pages 168182, </pages> <year> 1995. </year>
Reference-contexts: In contrast to existing constructions for wait-free objects [14], we choose to make only the queries wait-free. Otherwise, the cost of achieving wait-freedom for all operations can become quite high due to excessive copying and wasted parallelism <ref> [1] </ref>. Our technique for ensuring wait-free queries in multi-dimensional structures is similar to the scheme proposed for binary search trees by Valois [14]. 3 Top-Down Index Region Modification (TDIM) In this section, we describe a new approach for index region modification, called top-down index region modification (TDIM).
Reference: [2] <author> N. Beckmann, H. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R* tree: An efficient and robust access method for points and rectangles. </title> <booktitle> Proc. of the ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 322331, </pages> <month> May 23-25 </month> <year> 1990. </year>
Reference-contexts: In image databases such as QBIC [11], these index structures enable content-based retrieval of image data. Similarly, they enable content-based retrieval in text, audio and sequence databases. Several multi-dimensional index structures such as R-trees <ref> [2, 3, 4] </ref> and SS-trees [15] have been developed in the database literature. These structures extend uni fl Work supported by research grants NSF/ARPA/NASA IRI-9411330 and NSF Grant CDA96-01954. dimensional disk-resident structures such as B-trees to multi-dimensional data. However, they differ from B-trees in the following two aspects.
Reference: [3] <author> S. Berchtold, D. A. Keim, and H. P. Kreigel. </author> <title> The X-tree: An index structure for high dimensional data. </title> <booktitle> Proceedings of the Int. Conf. on Very Large Data Bases, </booktitle> <year> 1996. </year>
Reference-contexts: In image databases such as QBIC [11], these index structures enable content-based retrieval of image data. Similarly, they enable content-based retrieval in text, audio and sequence databases. Several multi-dimensional index structures such as R-trees <ref> [2, 3, 4] </ref> and SS-trees [15] have been developed in the database literature. These structures extend uni fl Work supported by research grants NSF/ARPA/NASA IRI-9411330 and NSF Grant CDA96-01954. dimensional disk-resident structures such as B-trees to multi-dimensional data. However, they differ from B-trees in the following two aspects.
Reference: [4] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 4757, </pages> <year> 1984. </year>
Reference-contexts: In image databases such as QBIC [11], these index structures enable content-based retrieval of image data. Similarly, they enable content-based retrieval in text, audio and sequence databases. Several multi-dimensional index structures such as R-trees <ref> [2, 3, 4] </ref> and SS-trees [15] have been developed in the database literature. These structures extend uni fl Work supported by research grants NSF/ARPA/NASA IRI-9411330 and NSF Grant CDA96-01954. dimensional disk-resident structures such as B-trees to multi-dimensional data. However, they differ from B-trees in the following two aspects. <p> This ensures that inserts can be performed without excessive locking and without affecting query behavior. The total ordering of data items is implicitly used for ensuring such correct query behavior. Unfortunately, such an ordering does not exist in multiple dimensions. Therefore, for multi-dimensional structures such as R-trees <ref> [4] </ref>, Kornacker and Banks [7] associate sequence numbers with child entries in an index node and use the total ordering on these numbers to ensure correct query behavior. The extra space for these sequence numbers reduces the capacity of tree nodes, which may lead to a degradation in query performance.
Reference: [5] <author> T. Johnson and D. Shasha. </author> <title> The performance of concurrent B-tree algorithms. </title> <journal> Proc. ACM Symp. on Transactions of Database Systems, </journal> <volume> 18(1), </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: Related work is described in Section 2, TDIM in Section 3, CCU in Section 4, CCU NQ in Section 5, and experimental comparisons of the proposed schemes in Section 6. 2 Related Work Extensive research has been done on concurrency control techniques for in 1-dimensional index structures such as B-trees <ref> [5, 13] </ref>. In B-trees, index regions are not modified except in the case of splits (and merges). Therefore, most techniques try to minimize the locking overheads due to a node-split (or a node-merge) using the link technique of Lehman and Yao [9].
Reference: [6] <author> K. V. Ravi Kanth, David F. Serena, and Ambuj K. Singh. </author> <title> Improved concurrency control techniques for multi-dimensional index structures. </title> <type> Technical report, </type> <institution> Univ. of California at Santa Barbara, </institution> <month> December </month> <year> 1997. </year> <note> http://www.cs.ucsb.edu/~kravi/conc.ps. </note>
Reference-contexts: Release the lock on the node n. end Node splits propagate in a bottom-up fashion using exclusive locks. The split algorithm is nearly identical to that of CGiST. However, our algorithm avoids two minor errors in the split algorithm of CGiST. These errors are described in <ref> [6] </ref>. We also note that the performance of CGiST can be enhanced by a simple split-optimization: the splitting of a node into two is done before locking its parent as opposed to after locking the parent in CGiST. <p> Of the two copy-based variants, the non-blocking version achieves the maximum throughput because it achieves wait-freedom for queries. Similar results are also obtained for scalabil ity comparisons when the index structures are partially resident on disk. These results are described in detail in <ref> [6] </ref>. varying number of processors: (a) 5%- insert and (b) 25%-insert workloads In summary, the above results indicate that copy-based concurrency control schemes achieve up to 50% improvements in query and update response times over existing techniques for realistic database workloads (5% inserts).
Reference: [7] <author> M. Kornacker and D. </author> <title> Banks. High concurrency locking for R-trees. </title> <booktitle> Proceedings of the Int. Conf. on Very Large Data Bases, </booktitle> <pages> pages 134145, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: The total ordering of data items is implicitly used for ensuring such correct query behavior. Unfortunately, such an ordering does not exist in multiple dimensions. Therefore, for multi-dimensional structures such as R-trees [4], Kornacker and Banks <ref> [7] </ref> associate sequence numbers with child entries in an index node and use the total ordering on these numbers to ensure correct query behavior. The extra space for these sequence numbers reduces the capacity of tree nodes, which may lead to a degradation in query performance.
Reference: [8] <author> M. Kornacker, C. Mohan, and J. Hellerstein. </author> <title> Concur-rency control and recovery in GiST. </title> <booktitle> Proc. ACM SIG-MOD Int. Conf. on Management of Data, </booktitle> <year> 1997. </year>
Reference-contexts: The extra space for these sequence numbers reduces the capacity of tree nodes, which may lead to a degradation in query performance. Consequently, Kornacker et al. <ref> [8] </ref> propose a new technique that reduces this extra information from one for every child entry in a node to one for the entire node. This extension for concurrency control is proposed in the context of GiST structures. We refer to it as the Concurrent GiST (CGiST) technique. <p> When combined with predicate locking mechanism of <ref> [8] </ref>, CCU ensures serializability of concurrent transactions. In this paper, we only focus on index performance without going into the serializability issues. CCU NQ, a variant of CCU, completely eliminates the blocking overhead for a query due to other concurrent updates. <p> In addition to this basic structure, we also maintain a node sequence number (nsn) with each node and a global sequence number (global nsn) with the entire structure. Together, these sequence numbers can be used to detect node splits due to concurrent insertions as in <ref> [8] </ref>. Next, we describe how to combine index region modification with a top-down traversal of the tree during an insert operation. An insert operation starts at the root of the tree and identifies a child subtree S in which the new data item fits best. <p> In that case, the insert operation is restarted at the root. This procedure is repeated until the insert reaches a leaf node wherein the corresponding data item is inserted. Unlike the technique of <ref> [8] </ref>, our strategy combines index region modification with tree traversal and avoids locking of nodes from multiple levels of the tree at the same time. Since the modification of index regions is done in a piecemeal fashion without excluding query access, queries are not blocked except during node-splits. <p> We use this optimization for CGIST when we compare it with our algorithms. The query algorithm in TDIM is same as that of <ref> [8] </ref> and is omitted for brevity. procedure Split (NodeType n) begin 1. Determine the parent p of n. 2. Create an index entry [n 0 ; N 0 ] into n 0 where N 0 is the index region for node n 0 . 3. <p> Garbage collection can be performed using the drain technique of [10] and is not addressed in this paper. In the next section, we present some performance results. 6 Experiments In this section, we compare the performance of our proposed concurrency control techniques with existing ones such as CGiST <ref> [8] </ref>. We first describe the experimental setup. 6.1 Setup We experimented with a database of 26K 48-dimensional texture feature vectors obtained from the Corel Image Collection. These feature vectors are indexed using an R fl -tree, which was implemented in C under IRIX 6.2. <p> As in [13], we mainly worked with two principal configurations for an index: an in-memory index configuration (disk-access ratio=0) and a partial-disk-resident configuration with disk access ratio set to 25%. In what follows, we evaluate the performance of the proposed concurrency control techniques and compare them with CGiST <ref> [8] </ref> (incorporating the split-optimization described in Section 3). We first describe the experimental results for an inserts-only workload. For this workload, the three schemes that are proposed in this paper TDIM, CCU and CCU NQ are identical.
Reference: [9] <author> P. L. Lehman and S. B. Yao. </author> <title> Efficient locking for concurrent operations on b-trees. </title> <booktitle> Proc. ACM Symp. on Transactions of Database Systems, </booktitle> <address> 6(4):650670, </address> <month> December </month> <year> 1981. </year>
Reference-contexts: In B-trees, index regions are not modified except in the case of splits (and merges). Therefore, most techniques try to minimize the locking overheads due to a node-split (or a node-merge) using the link technique of Lehman and Yao <ref> [9] </ref>. Whenever a node is split into two, a link is maintained between the two resulting nodes. Queries that reach the split node before the split propagates to the parent follow the link if necessary. This ensures that inserts can be performed without excessive locking and without affecting query behavior.
Reference: [10] <author> C. Mohan. ARIES/KVL: </author> <title> A key-value locking method for concurrency control of multi-action transactions operating on B-tree indexes. </title> <booktitle> Proceedings of the Int. Conf. on Very Large Data Bases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: The above scheme achieves wait-freedom for queries by eliminating blocking of queries due to node-splits. However, a node split that propagates up to k levels in the tree may create k+1 garbage nodes. Garbage collection can be performed using the drain technique of <ref> [10] </ref> and is not addressed in this paper. In the next section, we present some performance results. 6 Experiments In this section, we compare the performance of our proposed concurrency control techniques with existing ones such as CGiST [8].
Reference: [11] <author> W. Niblack, R. Barber, W. Equitz, M. Flickner, E. Glas-man, D. Petkovic, and P. Yanker. </author> <title> The QBIC project: Querying images by content using color, texture and shape. </title> <booktitle> In Proc. of the SPIE Conf. 1908 on Storage and Retrieval for Image and Video Databases, volume 1908, </booktitle> <pages> pages 173187, </pages> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Multi-dimensional indexing has applications in spatial, image, text and sequence databases. In spatial database systems such as the Alexandria [12], multidimensional index structures provide fast access to spatial/geographical data. In image databases such as QBIC <ref> [11] </ref>, these index structures enable content-based retrieval of image data. Similarly, they enable content-based retrieval in text, audio and sequence databases. Several multi-dimensional index structures such as R-trees [2, 3, 4] and SS-trees [15] have been developed in the database literature.
Reference: [12] <author> T. R. Smith and J. Frew. </author> <title> Alexandria Digital Library. </title> <journal> Communications of the ACM, </journal> <volume> 38(4):6162, </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Multi-dimensional indexing has applications in spatial, image, text and sequence databases. In spatial database systems such as the Alexandria <ref> [12] </ref>, multidimensional index structures provide fast access to spatial/geographical data. In image databases such as QBIC [11], these index structures enable content-based retrieval of image data. Similarly, they enable content-based retrieval in text, audio and sequence databases.
Reference: [13] <author> V. Srinivasan and M. Carey. </author> <title> Performance of b-tree con-currency control algorithms. </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 416425, </pages> <year> 1991. </year>
Reference-contexts: Related work is described in Section 2, TDIM in Section 3, CCU in Section 4, CCU NQ in Section 5, and experimental comparisons of the proposed schemes in Section 6. 2 Related Work Extensive research has been done on concurrency control techniques for in 1-dimensional index structures such as B-trees <ref> [5, 13] </ref>. In B-trees, index regions are not modified except in the case of splits (and merges). Therefore, most techniques try to minimize the locking overheads due to a node-split (or a node-merge) using the link technique of Lehman and Yao [9]. <p> The logical addresses in CCU NQ are kept in memory due to their low storage requirements. Note that these logical addresses always keep track of the physical addresses of the nodes be it on the disk, or in memory. As in <ref> [13] </ref>, we mainly worked with two principal configurations for an index: an in-memory index configuration (disk-access ratio=0) and a partial-disk-resident configuration with disk access ratio set to 25%.
Reference: [14] <author> J. D. Valois. </author> <title> Lock-Free Data Structures. </title> <type> PhD thesis, </type> <institution> Rensselaer Polytechnic Institute, Department of Computer Science, </institution> <year> 1995. </year>
Reference-contexts: In this paper, we only focus on index performance without going into the serializability issues. CCU NQ, a variant of CCU, completely eliminates the blocking overhead for a query due to other concurrent updates. In contrast to existing constructions for wait-free objects <ref> [14] </ref>, we choose to make only the queries wait-free. Otherwise, the cost of achieving wait-freedom for all operations can become quite high due to excessive copying and wasted parallelism [1]. <p> Otherwise, the cost of achieving wait-freedom for all operations can become quite high due to excessive copying and wasted parallelism [1]. Our technique for ensuring wait-free queries in multi-dimensional structures is similar to the scheme proposed for binary search trees by Valois <ref> [14] </ref>. 3 Top-Down Index Region Modification (TDIM) In this section, we describe a new approach for index region modification, called top-down index region modification (TDIM). This scheme performs index region modifications by operating on at most one node along the insertion path for most insertions. <p> These schemes also scale well with the number of processors. The difference in performance of the two variants of the copy-based concurrent update scheme is small. Due to garbage collection issues and the cost of indirection <ref> [14] </ref>, we recommend the use of the blocking variant of the copy-based concurrency control (CCU) for achieving high concurrency in multi-dimensional index structures. 7 Conclusions In this paper, we examined concurrency control in multi-dimensional index structures. We proposed new techniques to reduce locking overheads of both query and update operations.
Reference: [15] <author> D. White and R. Jain. </author> <title> Similarity indexing with the SS-tree. </title> <booktitle> Proc. Int. Conf. on Data Engineering, </booktitle> <pages> pages 516 523, </pages> <year> 1996. </year>
Reference-contexts: In image databases such as QBIC [11], these index structures enable content-based retrieval of image data. Similarly, they enable content-based retrieval in text, audio and sequence databases. Several multi-dimensional index structures such as R-trees [2, 3, 4] and SS-trees <ref> [15] </ref> have been developed in the database literature. These structures extend uni fl Work supported by research grants NSF/ARPA/NASA IRI-9411330 and NSF Grant CDA96-01954. dimensional disk-resident structures such as B-trees to multi-dimensional data. However, they differ from B-trees in the following two aspects.
References-found: 15

