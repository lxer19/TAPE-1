URL: http://www.cs.umr.edu/techreports/94-29.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Email: sumeit@cs.umr.edu  minsall@cs.umr.edu  ff@cs.umr.edu  
Title: A RUN-TIME DECISION PROCEDURE FOR RESPONSIVE COMPUTING SYSTEMS  
Author: GRACE TSAI MATT INSALL BRUCE McMILLIN 
Date: January 13, 1994  
Address: Rolla, MO 65401 USA  Rolla, MO 65401 USA  Rolla, MO 65401 USA  
Affiliation: Department of Computer Science University of Missouri-Rolla  Department of Mathematics and Statistics University of Missouri-Rolla  Department of Computer Science University of Missouri-Rolla  
Abstract: A responsive computing system is a hybrid of real-time, distributed and fault-tolerant systems. In such a system, severe consequences will occur if the logical and physical specifications of the system are not met. In this paper, we present a logic, Interval Temporal Logic (ITL), to specify responsive computing systems and give a decision procedure to verify properties of the systems at run-time as follows. First, we specify properties of the system using ITL formulas. Next, we collect, at run-time, events and maintain equivalent event histories to represent system execution. Finally, we apply a decision procedure to determine satisfaction of the formulas. The proposed decision procedure is essentially a run-time procedure which makes use of event histories computed during execution to verify properties of the system in the actual operational environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Malek, </author> <title> "Responsive systems: A challenge for the nineties," </title> <booktitle> in Proc. EUROMICRO'90, 16th Symposium Microprocessing and Microprogramming, (Amersterdam, The Nether-lands), </booktitle> <pages> pp. 9-16, </pages> <year> 1990. </year> <title> Keynote Address. </title>
Reference-contexts: 1 INTRODUCTION A responsive computing system <ref> [1] </ref> is one which responds to internal programs or external inputs in a timely, dependable and predictable manner. <p> Thus, processes P train and P gate have the 8 following state information in their histories, V h t and V h g . V h t = &lt; (P train ; x = traveling; <ref> [1; 0] </ref>); (P train ; x = approaching; [2; 0]) &gt; V h g = &lt; (P gate ; y = up; [0; 1]) &gt; The tuple (P train ; x = traveling; [1; 0]) shows that at (vector) time [1; 0] the train is traveling, and (P train ; x <p> V h t = &lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]) &gt; V h g = &lt; (P gate ; y = up; <ref> [0; 1] </ref>) &gt; The tuple (P train ; x = traveling; [1; 0]) shows that at (vector) time [1; 0] the train is traveling, and (P train ; x = approaching; [2; 0]) denotes that at time [2; 0] the train is approaching. <p> V h t = &lt; (P train ; x = traveling; <ref> [1; 0] </ref>); (P train ; x = approaching; [2; 0]) &gt; V h g = &lt; (P gate ; y = up; [0; 1]) &gt; The tuple (P train ; x = traveling; [1; 0]) shows that at (vector) time [1; 0] the train is traveling, and (P train ; x = approaching; [2; 0]) denotes that at time [2; 0] the train is approaching. <p> h t = &lt; (P train ; x = traveling; <ref> [1; 0] </ref>); (P train ; x = approaching; [2; 0]) &gt; V h g = &lt; (P gate ; y = up; [0; 1]) &gt; The tuple (P train ; x = traveling; [1; 0]) shows that at (vector) time [1; 0] the train is traveling, and (P train ; x = approaching; [2; 0]) denotes that at time [2; 0] the train is approaching. Likewise, the tuple (P gate ; y = up; [0; 1]) states that the gate is up at time [0; 1]. <p> Likewise, the tuple (P gate ; y = up; <ref> [0; 1] </ref>) states that the gate is up at time [0; 1]. When communication m 1 occurs, processes P train and P gate exchange their respective histories V h t and V h g , and incorporate received histories into their own histories. <p> Likewise, the tuple (P gate ; y = up; <ref> [0; 1] </ref>) states that the gate is up at time [0; 1]. When communication m 1 occurs, processes P train and P gate exchange their respective histories V h t and V h g , and incorporate received histories into their own histories. Recall that the incorporation of histories is based on the causality on events. <p> Recall that the incorporation of histories is based on the causality on events. The histories of processes P train and P gate after the incorporation are as follows. V h t =&lt; (P train ; x = traveling; <ref> [1; 0] </ref>); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; <p> The histories of processes P train and P gate after the incorporation are as follows. V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; <ref> [0; 1] </ref>); (P train ; P gate ; receive; [2; 1]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The <p> V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; <p> V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; <ref> [0; 1] </ref>); (P train ; P gate ; receive; [2; 1]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message <p> ; x = traveling; <ref> [1; 0] </ref>); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message from P train . <p> y = up; [0; 1]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message from P train . After communications m 2 and m 3 , the histories V h t and V h g are as follows. <p> <ref> [2; 1] </ref>) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message from P train . After communications m 2 and m 3 , the histories V h t and V h g are as follows. <p> =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message from P train . After communications m 2 and m 3 , the histories V h t and V h g are as follows. <p> After communications m 2 and m 3 , the histories V h t and V h g are as follows. V h t =&lt; (P train ; x = traveling; <ref> [1; 0] </ref>); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = <p> After communications m 2 and m 3 , the histories V h t and V h g are as follows. V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; <ref> [0; 1] </ref>); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate <p> V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; <p> = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; <ref> [0; 1] </ref>); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = <p> train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; <ref> [1; 0] </ref>); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = <p> x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the
Reference: [2] <author> G. Tsai, M. Insall, and B. McMillin, </author> <title> "Ensuring the satisfaction of a temporal specification at run-time," </title> <institution> UMR Department of Computer Science Technical Report Number CSC 93-020, </institution> <year> 1993. </year>
Reference-contexts: Since the history V h is built at run-time, the procedure is a run-time procedure which checks satisfaction of formulas in the operational environment. In our previous work, we used a decision procedure to check satisfaction of liveness assertions in the operational environment <ref> [2] </ref>. A liveness assertion ( ! EF ) denotes that when a program starts from a state satisfying assertion , eventually it will get to a state satisfying assertion . <p> The examples of constructing event histories and the proof of correctness of a history, V h i , built according to the Computing History of Figure 2 are shown in <ref> [2] </ref>. 3.3 Computing Histories in a Faulty Environment This subsection presents the construction of an event history of process P i in a faulty environment. In such an environment, faulty processes may fool non-faulty ones by sending incorrect values. <p> Figure 3 shows Computing History for a faulty environment. Also, the proof of correctness of the history V h i , built according to the Computing History of Figure 3, is shown in <ref> [2] </ref>. An event history V h i of process P i is computed as follows. During a communication, processes P i and P j exchange their respective histories V h i and V h j . <p> Thus, the externally observable events (send or receive events) are the actions that change the states of a process, and they can be regarded as intermediate states of a program. <ref> [2] </ref> shows the correspondence between states and externally observable events in a history. After establishing the correspondence between states and events in a history, we define satisfaction of a formula by a state in terms of satisfaction by an event. <p> Otherwise, (V h i ; ) returns FALSE. The above interval formulas and responsiveness assertions involve behavior of one process, so the procedure examines only events of the process in history V h i . Due to the page limit, the reader may refer to <ref> [2] </ref> for the decision procedure dealing with formulas specifying behavior of more than one process. 4 Railroad Crossing Example In this section, we present a railroad crossing example to illustrate determination of satisfaction of ITL formulas at run-time. For simplicity, we assume a non-faulty environment. <p> Thus, processes P train and P gate have the 8 following state information in their histories, V h t and V h g . V h t = &lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; <ref> [2; 0] </ref>) &gt; V h g = &lt; (P gate ; y = up; [0; 1]) &gt; The tuple (P train ; x = traveling; [1; 0]) shows that at (vector) time [1; 0] the train is traveling, and (P train ; x = approaching; [2; 0]) denotes that at time <p> train ; x = approaching; <ref> [2; 0] </ref>) &gt; V h g = &lt; (P gate ; y = up; [0; 1]) &gt; The tuple (P train ; x = traveling; [1; 0]) shows that at (vector) time [1; 0] the train is traveling, and (P train ; x = approaching; [2; 0]) denotes that at time [2; 0] the train is approaching. Likewise, the tuple (P gate ; y = up; [0; 1]) states that the gate is up at time [0; 1]. <p> 0]) &gt; V h g = &lt; (P gate ; y = up; [0; 1]) &gt; The tuple (P train ; x = traveling; [1; 0]) shows that at (vector) time [1; 0] the train is traveling, and (P train ; x = approaching; <ref> [2; 0] </ref>) denotes that at time [2; 0] the train is approaching. Likewise, the tuple (P gate ; y = up; [0; 1]) states that the gate is up at time [0; 1]. <p> Recall that the incorporation of histories is based on the causality on events. The histories of processes P train and P gate after the incorporation are as follows. V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; <ref> [2; 0] </ref>); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; <p> V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; <p> ; x = approaching; <ref> [2; 0] </ref>); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message from P train . <p> y = up; [0; 1]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message from P train . After communications m 2 and m 3 , the histories V h t and V h g are as follows. <p> <ref> [2; 1] </ref>) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message from P train . After communications m 2 and m 3 , the histories V h t and V h g are as follows. <p> =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; The tuple (P train ; P gate ; receive; [2; 1]) shows that at time [2; 1] process P gate receives a message from P train . After communications m 2 and m 3 , the histories V h t and V h g are as follows. <p> After communications m 2 and m 3 , the histories V h t and V h g are as follows. V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; <ref> [2; 0] </ref>); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = <p> V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; <p> V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; <ref> [2; 3] </ref>); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P <p> ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; <ref> [2; 0] </ref>); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate <p> x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; <ref> [2; 1] </ref>) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the <p> gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; <ref> [2; 3] </ref>); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the decision procedure to check validity of the formula = <p> For the events in histories V h t , the tuple (P train ; x = ingate; [4; 3]) denotes that the train is ingate, and the tuple (P gate ; y = down; <ref> [2; 3] </ref>) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time. <p> For the events in histories V h t , the tuple (P train ; x = ingate; [4; 3]) denotes that the train is ingate, and the tuple (P gate ; y = down; <ref> [2; 3] </ref>) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time. <p> tuple (P train ; x = ingate; [4; 3]) denotes that the train is ingate, and the tuple (P gate ; y = down; <ref> [2; 3] </ref>) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time.
Reference: [3] <author> C. Jard and T. Jeron, </author> <title> "On-line model-checking for finite linear temporal logic specifications," in Automatic Verification Methods for Finite State Systems, </title> <booktitle> Lecture Notes in Computer Science 407, </booktitle> <pages> pp. 189-196, </pages> <year> 1989. </year>
Reference-contexts: Thus, this paper focuses on constructing a decision procedure to check, at run-time, satisfaction of responsiveness assertions and interval formulas which can assert properties of the systems within bounded intervals of time. For the determination of satisfaction of formulas, <ref> [3] </ref> translates temporal logic formulas into finite automata. In contrast, we establish a correspondence between states and events in the event history and examine the history for the determination of satisfaction of formulas. The work of [4] embeds system constraints into programs and examines them at run-time. <p> V h t =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; <ref> [2; 3] </ref>); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P <p> =&lt; (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; <ref> [3; 3] </ref>) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train <p> (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; <ref> [4; 3] </ref>); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; <p> (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; <ref> [5; 3] </ref>); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P <p> gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; <ref> [2; 3] </ref>); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the decision procedure to check validity of the formula = <p> =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; <ref> [3; 3] </ref>) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the decision procedure to check validity of the formula = [x = ingate]y = down. <p> (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; <ref> [4; 3] </ref>); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the decision procedure to check validity of the formula = [x = ingate]y = down. <p> (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; <ref> [5; 3] </ref>); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the decision procedure to check validity of the formula = [x = ingate]y = down. <p> For the events in histories V h t , the tuple (P train ; x = ingate; <ref> [4; 3] </ref>) denotes that the train is ingate, and the tuple (P gate ; y = down; [2; 3]) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x <p> For the events in histories V h t , the tuple (P train ; x = ingate; [4; 3]) denotes that the train is ingate, and the tuple (P gate ; y = down; <ref> [2; 3] </ref>) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time. <p> For the events in histories V h t , the tuple (P train ; x = ingate; [4; 3]) denotes that the train is ingate, and the tuple (P gate ; y = down; <ref> [2; 3] </ref>) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time. <p> events in histories V h t , the tuple (P train ; x = ingate; <ref> [4; 3] </ref>) denotes that the train is ingate, and the tuple (P gate ; y = down; [2; 3]) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time. <p> tuple (P train ; x = ingate; [4; 3]) denotes that the train is ingate, and the tuple (P gate ; y = down; <ref> [2; 3] </ref>) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time. <p> Also, by comparison of (vector) timestamps of [2; 3] and <ref> [4; 3] </ref>, (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time.
Reference: [4] <author> S. E. Chodrow, F. Jahanian, and M. Donner, </author> <title> "Run-time monitoring of real-time systems," </title> <booktitle> in IEEE Symposium on Real-Time Systems, </booktitle> <pages> pp. 74-83, </pages> <year> 1991. </year>
Reference-contexts: For the determination of satisfaction of formulas, [3] translates temporal logic formulas into finite automata. In contrast, we establish a correspondence between states and events in the event history and examine the history for the determination of satisfaction of formulas. The work of <ref> [4] </ref> embeds system constraints into programs and examines them at run-time. However, they use a centralized monitor to obtain an execution history, while our method does not require monitors to compute histories. The organization of this paper is as follows. In Section 2, we introduce the logic ITL. <p> (P train ; x = approaching; [2; 0]); (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; <ref> [4; 3] </ref>); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; <p> train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; <ref> [5; 4] </ref>) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate <p> (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; <ref> [4; 3] </ref>); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the decision procedure to check validity of the formula = [x = ingate]y = down. <p> train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; <ref> [5; 4] </ref>) &gt; Now, we apply the decision procedure to check validity of the formula = [x = ingate]y = down. <p> For the events in histories V h t , the tuple (P train ; x = ingate; <ref> [4; 3] </ref>) denotes that the train is ingate, and the tuple (P gate ; y = down; [2; 3]) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x <p> events in histories V h t , the tuple (P train ; x = ingate; <ref> [4; 3] </ref>) denotes that the train is ingate, and the tuple (P gate ; y = down; [2; 3]) denotes that the gate is down. Also, by comparison of (vector) timestamps of [2; 3] and [4; 3], (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time. <p> Also, by comparison of (vector) timestamps of [2; 3] and <ref> [4; 3] </ref>, (P gate ; y = down; [2; 3]) happens before (P train ; x = ingate; [4; 3]). Therefore, history V h t satisfies the formula at run-time.
Reference: [5] <author> D. Peled and A. Pnueli, </author> <title> "Proving partial order liveness properties," </title> <booktitle> 17th Colloquium on Automata, Language and Programming, </booktitle> <pages> pp. 553-571, </pages> <year> 1990. </year>
Reference-contexts: The logic ITL is an extension of Interleaving Set Temporal Logic <ref> [5] </ref>. It adopts a partial order semantics which considers a distributed computation as a set of partially ordered events. Hence, this logic ITL can capture temporal and distributed aspects of the responsive systems that we are modeling. <p> (P gate ; y = up; [0; 1]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; <ref> [5; 3] </ref>); (P train ; P gate ; receive; [5; 4]) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P <p> train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; <ref> [5; 4] </ref>) &gt; V h g =&lt; (P gate ; y = up; [0; 1]); (P train ; x = traveling; [1; 0]); (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate <p> (P train ; x = approaching; [2; 0]); (P train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; <ref> [5; 3] </ref>); (P train ; P gate ; receive; [5; 4]) &gt; Now, we apply the decision procedure to check validity of the formula = [x = ingate]y = down. <p> train ; P gate ; receive; [2; 1]) &gt; (P gate ; y = down; [2; 3]); (P gate ; P train ; receive; [3; 3]) &gt; (P train ; x = ingate; [4; 3]); (P train ; x = departure; [5; 3]); (P train ; P gate ; receive; <ref> [5; 4] </ref>) &gt; Now, we apply the decision procedure to check validity of the formula = [x = ingate]y = down.
Reference: [6] <author> G. Tsai, M. Insall, and B. McMillin, </author> <title> "Constructing an interval temporal logic for real-time systems," </title> <institution> UMR Department of Computer Science Technical Report Number CSC 93-025, </institution> <year> 1993. </year>
Reference-contexts: Note that the soundness and relative completeness of the logic system was shown in <ref> [6] </ref>. 4 3 THE DECISION PROCEDURE In this section, we present a technique to build execution histories, and provide the decision procedure to determine satisfaction of ITL formulas at run-time.
Reference: [7] <author> L. Lamport, </author> <title> "Time, clocks and the ordering of events in a distributed system," </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 7, </volume> <pages> pp. 558-565, </pages> <year> 1978. </year>
Reference-contexts: This collection of events can be ordered according to a causal relation !, which is defined as follows. Definition 3.1 Event e precedes event f in an execution, i.e., e ! f , iff any one of the following conditions holds <ref> [7] </ref>: 1. e and f are events of the same process, and e occurs before f , 2. e is a send event, and f is the corresponding receive event, or 3. there exists an event g, such that e ! g, and g ! f .
Reference: [8] <author> J. Fidge, </author> <title> "Timestamps in message passing systems that preserve the partial ordering," </title> <booktitle> in Proceeding of the Tenth International Conference of Software Engineering, </booktitle> <pages> pp. 182-187, </pages> <year> 1992. </year>
Reference: [9] <author> F. Mattern, </author> <title> "Virtual time and global states of distributed systems," </title> <booktitle> in Parallel and Distributed Algorithms: Proceedings of the International Workshops on Parallel and Distributed Algorithms (M. </booktitle> <editor> Cosnard et al., </editor> <booktitle> eds.), </booktitle> <pages> pp. 215-226, </pages> <year> 1989. </year> <month> 10 </month>
Reference-contexts: According to the casual relation !, processes can partially order events in their own histories. These histories are equivalent in the sense that they only differ in the order of independent (not causally related) events. The relation ! can be implemented by the existing vector clock scheme ([8], <ref> [9] </ref>) for the determination of causality between any two events. 2 Without loss of generality, we do not consider the concurrency between events on a process, intra-process concurrency.
References-found: 9

