URL: http://www.daimi.aau.dk/~bromille/Papers/tss.ps
Refering-URL: http://www.cs.toronto.edu/~fich/
Root-URL: 
Title: Tables should be sorted (on random access machines)  
Author: Faith Fich and Peter Bro Miltersen 
Address: Toronto.  
Affiliation: Department of Computer Science, University of  
Abstract: We consider the problem of storing an n element subset S of a universe of size m, so that membership queries (is x 2 S?) can be answered efficiently. The model of computation is a random access machine with the standard instruction set (direct and indirect adressing, conditional branching, addition, subtraction, and multiplication). We show that if s memory registers are used to store S, where n s m=n * , then query time (log n) is necessary in the worst case. That is, under these conditions, the solution consisting of storing S as a sorted table and doing binary search is optimal. The condition s m=n * is essentially optimal; we show that if n + m=n o(1) registers may be used, query time o(log n) is possible.
Abstract-found: 1
Intro-found: 1
Reference: [AHU74] <author> A. Aho, J. Hopcroft, and J. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: The instruction set is described in Table 1. Here, as in [PS82, BG91, Maa88], we assume that addition, subtraction, and multiplication can be performed. In other papers, the RAM instruction set does not include multiplication [CR73] or restricts multiplication to reasonably small operands <ref> [AHU74] </ref>.
Reference: [BG91] <author> A.M. Ben-Amram and Z. Galil, </author> <title> Lower bounds for data structure problems on RAMs. </title> <booktitle> In Proc. 32th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> pages 622-631. </pages>
Reference-contexts: Our proof is the first application of this kind of technique taking advantage of a restricted instruction set, while allowing memory registers to contain arbitrary integers. Another lower bound proof technique has previously been transferred from the cell probe model to the random access machine model: Ben-Amram and Galil <ref> [BG91] </ref> modified Fredman and Saks' time stamp technique for the cell probe model [FS89] to obtain the same lower bounds for the random access machine model, with registers that can contain arbitrarily large integers. <p> For ease of presentation, we include in our version of the RAM model two additional registers, the accumulator and the pointer. The accumulator is where arithmetic operations are performed. The pointer is used for indirect addressing. The instruction set is described in Table 1. Here, as in <ref> [PS82, BG91, Maa88] </ref>, we assume that addition, subtraction, and multiplication can be performed. In other papers, the RAM instruction set does not include multiplication [CR73] or restricts multiplication to reasonably small operands [AHU74].
Reference: [Ben86] <author> J.L. Bentley, </author> <title> Programming Pearls. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: smaller powers of 2. (See [Knu73, vol. 3 pages 413-414].) Alternatively, the full binary search tree containing the values in S can be represented implicitly with the left and right children of the node in location l at locations 2l and 2l + 1, respectively (as in a heap). (See <ref> [Ben86, pages 136,183-184] </ref> and [Knu73, vol. 1 page 401, vol. 3 pages 422,670].) Then the equivalent of binary search can be carried out using no extra registers. Constant query time is possible with a bit vector representation, using m registers.
Reference: [BM94] <author> A. Brodnik and J. Ian Munro, </author> <title> Membership in constant time and minimum space. </title> <booktitle> In Proc. 2nd European Symposium on Algorithms 1994, </booktitle> <pages> pages 72-81. </pages>
Reference-contexts: However, there are still some questions that remain unanswered. One concerns the exact amount of extra memory needed to get constant query time. The upper bound in [FKS84] has been improved by [FNSS92] and <ref> [BM94] </ref>. It is still an open problem when exactly n memory cells are sufficient. In particular, Yao's lower bound does not apply if the implicitness restriction on is removed.
Reference: [CR73] <author> S.A. Cook and R.A. Reckhow, </author> <title> Time bounded random access machines. </title> <journal> JCSS, </journal> <volume> vol. 7, </volume> <year> 1973, </year> <pages> pages 354-375. </pages>
Reference-contexts: get larger lower bounds in the random access machine model than in the cell probe model (where the complexity of membership is constant). 2 The Random Access Machine Model The random access machine (RAM) is an important and well studied model of sequential computation, first formalized by Cook and Reckow <ref> [CR73] </ref>. It has an infinite sequence of registers, indexed by the integers. Each register can contain an arbitrarily large integer. For ease of presentation, we include in our version of the RAM model two additional registers, the accumulator and the pointer. The accumulator is where arithmetic operations are performed. <p> The pointer is used for indirect addressing. The instruction set is described in Table 1. Here, as in [PS82, BG91, Maa88], we assume that addition, subtraction, and multiplication can be performed. In other papers, the RAM instruction set does not include multiplication <ref> [CR73] </ref> or restricts multiplication to reasonably small operands [AHU74]. <p> Denote this encoding by t (A). Cook and Rechow <ref> [CR73] </ref> show that there exists a universal RAM interpreter with the property that if the interpreter is executed with inputs z 2 Z fl and t (A) (stored in an interleaved fashion), the result is the same as if A was executed on input z.
Reference: [FN93] <author> A. Fiat and M. Naor, </author> <title> Implicit O(1) probe search. </title> <journal> SIAM J. Computing vol. </journal> <volume> 22, </volume> <year> 1993, </year> <pages> pages 1-10. </pages>
Reference-contexts: The upper bound in [FKS84] has been improved by [FNSS92] and [BM94]. It is still an open problem when exactly n memory cells are sufficient. In particular, Yao's lower bound does not apply if the implicitness restriction on is removed. Fiat, Naor, Schmidt, and Siegel [FNSS92], <ref> [FN93] </ref> consider bounds on the size of the universe m as a function of n for which there is an implicit data structure with constant query time. However, there is still a wide gap between their upper and lower bounds.
Reference: [FNSS92] <author> A. Fiat, M. Naor, J.P. Schmidt, and A. Seigel, </author> <title> Nonoblivious hashing. </title> <journal> J. ACM vol. </journal> <volume> 39, </volume> <year> 1992, </year> <pages> pages 764-782. </pages>
Reference-contexts: For most practical purposes, this answers the question of whether tables should be sorted: they should not. However, there are still some questions that remain unanswered. One concerns the exact amount of extra memory needed to get constant query time. The upper bound in [FKS84] has been improved by <ref> [FNSS92] </ref> and [BM94]. It is still an open problem when exactly n memory cells are sufficient. In particular, Yao's lower bound does not apply if the implicitness restriction on is removed. Fiat, Naor, Schmidt, and Siegel [FNSS92], [FN93] consider bounds on the size of the universe m as a function of <p> The upper bound in [FKS84] has been improved by <ref> [FNSS92] </ref> and [BM94]. It is still an open problem when exactly n memory cells are sufficient. In particular, Yao's lower bound does not apply if the implicitness restriction on is removed. Fiat, Naor, Schmidt, and Siegel [FNSS92], [FN93] consider bounds on the size of the universe m as a function of n for which there is an implicit data structure with constant query time. However, there is still a wide gap between their upper and lower bounds.
Reference: [FKS84] <author> M.L. Fredman, J. Komlos, and E. Szemeredi, </author> <title> Storing a sparse table with O(1) worst case access time. </title> <journal> J. ACM, </journal> <volume> vol. 31, </volume> <year> 1984, </year> <pages> pages 538-544. </pages>
Reference-contexts: This result was improved by Tarjan and Yao [TY79] and Fredman, Komlos and Szemeredi <ref> [FKS84] </ref>. The latter paper shows that, for all values of m and n, there is a storage scheme using n + o (n) memory cells, so that queries can be answered in constant time. <p> For most practical purposes, this answers the question of whether tables should be sorted: they should not. However, there are still some questions that remain unanswered. One concerns the exact amount of extra memory needed to get constant query time. The upper bound in <ref> [FKS84] </ref> has been improved by [FNSS92] and [BM94]. It is still an open problem when exactly n memory cells are sufficient. In particular, Yao's lower bound does not apply if the implicitness restriction on is removed. <p> However, there is still a wide gap between their upper and lower bounds. Instead of putting a restriction on the data structure, we can put a restriction on the query algorithm. The technique of <ref> [FKS84] </ref> is based on the family of hash functions h k (x) = (kx mod p) mod s, i.e. integer division is used. However, the only arithmetic operations usually included in the instruction set of random access machines are addition, subtraction and multiplication.
Reference: [FS89] <author> M.L. Fredman and M.E. Saks, </author> <title> The cell probe complexity of dynamic data structures. </title> <booktitle> In Proc. 21st Ann. ACM Symp. on Theory of Computing, </booktitle> <year> 1989, </year> <pages> pages 345-354. </pages>
Reference-contexts: Another lower bound proof technique has previously been transferred from the cell probe model to the random access machine model: Ben-Amram and Galil [BG91] modified Fredman and Saks' time stamp technique for the cell probe model <ref> [FS89] </ref> to obtain the same lower bounds for the random access machine model, with registers that can contain arbitrarily large integers.
Reference: [Knu73] <author> D.E. Knuth, </author> <booktitle> The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: The idea is to precompute the first blog 2 nc powers of 2. The initial comparison is performed at location 2 blog 2 nc and the locations of subsequent comparisons are obtained by either adding or subtracting successively smaller powers of 2. (See <ref> [Knu73, vol. 3 pages 413-414] </ref>.) Alternatively, the full binary search tree containing the values in S can be represented implicitly with the left and right children of the node in location l at locations 2l and 2l + 1, respectively (as in a heap). (See [Ben86, pages 136,183-184] and [Knu73, vol. <p> (See [Knu73, vol. 3 pages 413-414].) Alternatively, the full binary search tree containing the values in S can be represented implicitly with the left and right children of the node in location l at locations 2l and 2l + 1, respectively (as in a heap). (See [Ben86, pages 136,183-184] and <ref> [Knu73, vol. 1 page 401, vol. 3 pages 422,670] </ref>.) Then the equivalent of binary search can be carried out using no extra registers. Constant query time is possible with a bit vector representation, using m registers.
Reference: [Maa88] <author> W. Maass, </author> <title> On the use of inaccessible numbers and order indiscernibles in lower bound arguments for random access machines. </title> <journal> J. Symbolic Logic, </journal> <volume> vol. 53, </volume> <year> 1988, </year> <pages> pages 1098-1109. </pages>
Reference-contexts: For ease of presentation, we include in our version of the RAM model two additional registers, the accumulator and the pointer. The accumulator is where arithmetic operations are performed. The pointer is used for indirect addressing. The instruction set is described in Table 1. Here, as in <ref> [PS82, BG91, Maa88] </ref>, we assume that addition, subtraction, and multiplication can be performed. In other papers, the RAM instruction set does not include multiplication [CR73] or restricts multiplication to reasonably small operands [AHU74].
Reference: [MNSW95] <author> P.B. Miltersen, N. Nisan, S. Safra, and A. Wigderson, </author> <title> On data structures and asymmetric communication complexity. </title> <booktitle> In Proc. 27th ACM Symposium on Theory of Computing, </booktitle> <year> 1995, </year> <note> to appear. </note>
Reference-contexts: Thus, the space upper bound s 2 m=n (1) in our theorem is essentially optimal. Our proof technique has a strong communication complexity flavor and can, in fact, be viewed as a modification of the richness technique used for showing lower bounds on the communication complexity of membership in <ref> [MNSW95] </ref>. Communication complexity has previously been used for showing lower bounds for data structure problems in the cell probe model [MNSW95]. Our proof is the first application of this kind of technique taking advantage of a restricted instruction set, while allowing memory registers to contain arbitrary integers. <p> a strong communication complexity flavor and can, in fact, be viewed as a modification of the richness technique used for showing lower bounds on the communication complexity of membership in <ref> [MNSW95] </ref>. Communication complexity has previously been used for showing lower bounds for data structure problems in the cell probe model [MNSW95]. Our proof is the first application of this kind of technique taking advantage of a restricted instruction set, while allowing memory registers to contain arbitrary integers.
Reference: [PS82] <author> W. Paul and J. Simon, </author> <title> Decision trees and random access machines. In Logic and Algorithmic, monograph no. </title> <institution> 30 de l'enseignement mathematique, Univeriste de Geneve, </institution> <year> 1982. </year>
Reference-contexts: For ease of presentation, we include in our version of the RAM model two additional registers, the accumulator and the pointer. The accumulator is where arithmetic operations are performed. The pointer is used for indirect addressing. The instruction set is described in Table 1. Here, as in <ref> [PS82, BG91, Maa88] </ref>, we assume that addition, subtraction, and multiplication can be performed. In other papers, the RAM instruction set does not include multiplication [CR73] or restricts multiplication to reasonably small operands [AHU74].
Reference: [ST85] <author> D.D. Sleator and R.E. Tarjan, </author> <title> Self-Adjusting Binary Search Trees. </title> <journal> J. ACM, </journal> <volume> vol. 32, </volume> <year> 1985, </year> <pages> pages 652-686. </pages>
Reference: [TY79] <author> R.E. Tarjan and A.C. Yao, </author> <title> Storing a sparse table. </title> <journal> C. ACM, </journal> <volume> vol. 22, </volume> <year> 1979, </year> <pages> pages 606-611. </pages>
Reference-contexts: This result was improved by Tarjan and Yao <ref> [TY79] </ref> and Fredman, Komlos and Szemeredi [FKS84]. The latter paper shows that, for all values of m and n, there is a storage scheme using n + o (n) memory cells, so that queries can be answered in constant time.
Reference: [Yao81] <author> A.C. Yao, </author> <title> Should tables be sorted? J. </title> <journal> ACM, </journal> <volume> vol. 28, </volume> <year> 1981, </year> <month> pages 615-628. </month> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction In Yao's influential paper "Should tables be sorted?" <ref> [Yao81] </ref>, the following basic data structure problem was considered: Given a subset S of size n of the universe U = f0; : : :; m1g, store it as a data structure (S) in the memory of a unit cost random access machine, using few memory registers, each containing an element
References-found: 16

