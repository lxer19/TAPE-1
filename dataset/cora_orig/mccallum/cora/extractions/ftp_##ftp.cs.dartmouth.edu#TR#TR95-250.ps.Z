URL: ftp://ftp.cs.dartmouth.edu/TR/TR95-250.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/reports/abstracts/TR95-250/
Root-URL: http://www.cs.dartmouth.edu
Email: thc@cs.dartmouth.edu.  
Title: DartCVL: The Dartmouth C Vector Library  
Author: Thomas H. Cormen, Sumit Chawla, Preston Crow, Melissa Hirschl, Roberto Hoyle, Keith D. Kotay, Rolf H. Nelson, Nils Nieuwejaar, Scott M. Silver, Michael B. Taylor, Rajiv Wickremesinghe Tom Cormen, 
Address: Sudikoff Laboratory, Hanover, NH  
Note: Authors' address (unless otherwise stated): 6211  03755. Send electronic mail inquiries to  
Affiliation: Dartmouth College Computer Science  Dartmouth College Department of Computer Science  
Pubnum: Technical Report PCS-TR95-250  
Abstract: As a class project, we implemented a version of CVL, the C Vector Library, on a DECmpp 12000/Sx 2000, which is equivalent to the MasPar MP-2 massively parallel computer. We compare our implementation, DartCVL, to the University of North Carolina implementation, UnCvl. DartCVL was designed for the MP-2 architecture and UnCvl was designed for the MP-1. Because the MasPar MP-1 and MP-2 are functionally equivalent, both DartCVL and UnCvl will run on either. Differences in the designs of the two machines, however, may lead to different software design decisions. DartCVL differs from UnCvl in two key ways. First, DartCVL uses hierarchical virtualization, whereas UnCvl uses cut-and-stack. Second, DartCVL runs as much serial code as possible on the console, whereas UnCvl runs all serial code on the Array Control Unit (ACU). The console (a DECstation 5000/240 at Dartmouth) has a significantly faster serial processor than the ACU. DartCVL is optimized for the MP-2, and our timing results indicate that it usually runs faster than UnCvl on the 2048-processor machine at Dartmouth. 
Abstract-found: 1
Intro-found: 1
Reference: [BCH + 93] <author> Guy E. Blelloch, Siddharta Chatterjee, Jonathan C. Hardwick, Margaret Reid-Miller, Jay Sipelstein, and Marco Zagha. Cvl: </author> <title> A C Vector Library Manual, </title> <type> Version 2. Technical Report CMU-CS-93-114, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: 1 Introduction As a class project, the authors implemented CVL, the C Vector Library, on a DECmpp 12000/Sx 2000. CVL is an interface defined by Blelloch et al. <ref> [BCH + 93] </ref> to a group of simple functions for managing and operating on vectors. Our implementation, DartCVL, embodies the many functions defined in [BCH + 93]. The target machine is equivalent to the MasPar MP-2, a massively parallel SIMD computer. We had two goals in this project. <p> CVL is an interface defined by Blelloch et al. <ref> [BCH + 93] </ref> to a group of simple functions for managing and operating on vectors. Our implementation, DartCVL, embodies the many functions defined in [BCH + 93]. The target machine is equivalent to the MasPar MP-2, a massively parallel SIMD computer. We had two goals in this project. <p> Consequently, some of the fundamental design decisions we made for DartCVL differ from those made for UnCvl. DartCVL benefitted from these differences in most, but not all, cases. CVL The best pocket description of CVL comes from its manual <ref> [BCH + 93] </ref>: CVL is a library of low-level vector routines callable from C. This library presents an abstract model of a vector machine suitable either for stand-alone use or as the backend of a high-level language system.
Reference: [Ble92] <author> Guy E. Blelloch. Nesl: </author> <title> A nested data-parallel language. </title> <type> Technical Report CMU-CS-92-103, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: *s2 = S2, *d = D; for (i = 0; i &lt; steps; i++, d++, s1++, s2++) *d = *s1 + *s2; if (iproc &lt; leftover) *d = *s1 + *s2; Segment descriptors Many CVL operations use segmented vectors, and they are a key part of the implementation of Nesl <ref> [Ble92] </ref>, a nested data-parallel language. In a Nesl implementation of Quicksort, for example, a single vector is repeatedly segmented into smaller segments, each of which represents a partition of the data. Segmented operations treat each segment as though it were a separate vector.
Reference: [Dig92] <institution> Digital Equipment Corporation, Maynard, Massachusetts. </institution> <note> DECmpp Programming Language (ANSI) User's Guide, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: Section 3 discusses some other design decisions. Section 4 presents and analyzes timing results of DartCVL and UnCvl functions. Finally, Section 5 presents some concluding remarks. 2 Machine architecture In this section, we describe the DECmpp 12000/Sx 2000 <ref> [Dig92] </ref>, which is identical to the Mas-Par MP-2. For concrete examples, we will use the 2048-processor machine (named "cascade") installed at Dartmouth. The DECmpp 12000/Sx 2000 is a massively parallel processing system, made up of a console system and a data parallel unit (DPU).
Reference: [FHS93] <author> Rickard E. Faith, Doug L. Hoffman, and David G. Stahl. UnCvL: </author> <title> The University of North Carolina C Vector Library. </title> <type> Technical Report TR93-063, </type> <institution> Department of Computer Science, University of North Carolina at Chapel Hill, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: The engineering goal was to produce a fast implementation of CVL. This paper focuses on the engineering goal. We were aware of the UnCvl project <ref> [FHS93] </ref>, which is an implementation of CVL for the MasPar MP-1. Although the MP-1 and MP-2 are code-compatible, their architectures are sufficiently different that design decisions that work well on one machine may not perform as well on the other.
Reference: [Pri93] <author> Jan Prins. </author> <title> Private communication, </title> <month> June </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: To describe vector organization, most of the DartCVL functions that run on the DPU take as an input a structure with three pieces of information: * the vector's VPR, 2 Prins <ref> [Pri93] </ref> reports that a sophisticated pipelined algorithm improves the scan performance with cut-and-stack virtualization. 5 * the number of the pivot PE, which is the one PE with between 0 and VPR elements, and * the number of elements in the pivot PE, which we (inaccurately) call the "last VPR." Our
References-found: 5

