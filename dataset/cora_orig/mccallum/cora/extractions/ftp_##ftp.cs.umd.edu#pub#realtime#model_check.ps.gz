URL: ftp://ftp.cs.umd.edu/pub/realtime/model_check.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Email: jeff@rational.com  rich@cs.umd.edu  
Title: Compositional Model Checking of Ada Tasking Programs  
Author: Jeffrey Fischer Richard Gerber 
Address: 205 Van Buren Street Herndon, VA 22070  College Park, MD 20742  
Affiliation: Rational Software Corporation  Department of Computer Science University of Maryland  
Note: In Proc. of 9th IEEE Conference on Computer Assurance (IEEE Compass), June 1994. Also UMD CS-TR-3225, UMIACS-TR-94-19.  
Abstract: Model checking [7] has proven to be an effective analysis tool for domains such as hardware circuits and communication protocols. However, it has not yet been widely applied to more general concurrent systems, such as those realized by Ada multitasking programs. A major impediment to the use of model checking in such systems is the exponential growth of the state space, which results from the parallel composition of component tasks. Various compositional approaches have been proposed to address this problem, in which the parts of a system are analyzed separately, and then the results are combined into inferences about the whole. One of the more promising of these techniques is called compositional minimization [6], which eliminates each component's "uninteresting" states as the model checking proceeds; this in turn can lead to a significant reduction in the composite state-space. In this paper we evaluate the application of this approach to Ada multi-tasking programs, particularly highlighting the design choices made to accommodate Ada's semantics. We also discuss the types of systems (and properties) for which this method produces significant time/space savings, as well as those for which the savings are less pronounced. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, and D. L. Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> 414-425, </pages> <year> 1990. </year>
Reference-contexts: Since the seminal paper describing the CTL model checking approach [7], there have been numerous enhancements; e.g., compositional model checking [8], symbolic model checking [4], real-time model checking <ref> [1] </ref> and abstract model checking [9, 2]. For the most part these enhancements have been added to address two fundamental challenges: the state space explosion problem and the application of the technique to nonfinite state systems.
Reference: [2] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property preserving simulations. </title> <booktitle> Proceedings CAV92, </booktitle> <volume> LNCS 663, </volume> <pages> 260-273, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Since the seminal paper describing the CTL model checking approach [7], there have been numerous enhancements; e.g., compositional model checking [8], symbolic model checking [4], real-time model checking [1] and abstract model checking <ref> [9, 2] </ref>. For the most part these enhancements have been added to address two fundamental challenges: the state space explosion problem and the application of the technique to nonfinite state systems.
Reference: [3] <author> A. Bouajjani, J. Fernandez, N. Halbwachs, and C. Ratel. </author> <title> Minimal state graph generation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 18 </volume> <pages> 247-269, </pages> <year> 1992. </year>
Reference-contexts: Concise notations such as binary decision diagrams (BDD's) can often be used to compactly encode the states and their transitions. It is also frequently the case that a composition will contain many states that are in some (formally definable) sense equivalent. Algorithms such as that presented in <ref> [3] </ref> can be used to minimize the state space by collecting states into their equivalence classes. Another alternative is the compositional approach, in which the parts of a system are analyzed separately, and then the results are combined into infer ences about the whole.
Reference: [4] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> 428-439, </pages> <year> 1990. </year> <month> 12 </month>
Reference-contexts: Since the seminal paper describing the CTL model checking approach [7], there have been numerous enhancements; e.g., compositional model checking [8], symbolic model checking <ref> [4] </ref>, real-time model checking [1] and abstract model checking [9, 2]. For the most part these enhancements have been added to address two fundamental challenges: the state space explosion problem and the application of the technique to nonfinite state systems.
Reference: [5] <author> M. Chiodo, T. R. Shiple, A. Sangiovanni--Vincentelli, and R. K.Brayton. </author> <title> Automatic reduction in CTL compositional model checking. </title> <note> Memorandum No. </note> <institution> UCB/ERL M92/55, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <year> 1992. </year>
Reference-contexts: The interface (hopefully) yields a simple representation of behaviors to be presented by the environment. In practice such interfaces are quite hard to derive; indeed, they may be as complex as the system itself. These two techniques have recently been synthesized into a third approach called compositional minimization <ref> [5, 6] </ref>. This method differs from other compositional approaches, in that no interface abstractions need to be generated; thus it can easily be automated. It also differs from other minimization techniques, in that it is applied to the individual tasks before composition, potentially resulting in a reduced aggregate state space. <p> system's states will indeed be labeled with F 1;1 , and we interpret this result to mean that the assertion is true in our model. 8 4 Compositional Minimization of Ada Tasking Programs Now we present the minimization/verification technique for our Ada task model, motivated by the BDD-circuit verification in <ref> [5, 6] </ref>. As we have stated, the method does not place limits on the expressiveness of either the logical specification or the system being analyzed. Therefore one would expect that the time/space savings will vary greatly from property to property, and from system to system. <p> 0 x 0 with reduced (9 (f R g); T ) def Finally, 9 fl (f) is the simplest case; a transition is included only if the destination state satisfies f: reduced (9 fl (f); T ) def We note that our approach is an improvement over that offered in <ref> [5, 6] </ref>, since we use input information in our minimization, whereas their algorithm only reduces with respect to local state. Using the information afforded from the inputs often leads to a greater reduction in the number of transitions.
Reference: [6] <author> M. Chiodo, T. R. Shiple, A. Sangiovanni-Vincentelli, and R. K.Brayton. </author> <title> Automatic reduction in CTL compositional model checking. </title> <booktitle> Proceedings CAV'92, </booktitle> <volume> LNCS 663, </volume> <pages> 234-247, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The interface (hopefully) yields a simple representation of behaviors to be presented by the environment. In practice such interfaces are quite hard to derive; indeed, they may be as complex as the system itself. These two techniques have recently been synthesized into a third approach called compositional minimization <ref> [5, 6] </ref>. This method differs from other compositional approaches, in that no interface abstractions need to be generated; thus it can easily be automated. It also differs from other minimization techniques, in that it is applied to the individual tasks before composition, potentially resulting in a reduced aggregate state space. <p> system's states will indeed be labeled with F 1;1 , and we interpret this result to mean that the assertion is true in our model. 8 4 Compositional Minimization of Ada Tasking Programs Now we present the minimization/verification technique for our Ada task model, motivated by the BDD-circuit verification in <ref> [5, 6] </ref>. As we have stated, the method does not place limits on the expressiveness of either the logical specification or the system being analyzed. Therefore one would expect that the time/space savings will vary greatly from property to property, and from system to system. <p> 0 x 0 with reduced (9 (f R g); T ) def Finally, 9 fl (f) is the simplest case; a transition is included only if the destination state satisfies f: reduced (9 fl (f); T ) def We note that our approach is an improvement over that offered in <ref> [5, 6] </ref>, since we use input information in our minimization, whereas their algorithm only reduces with respect to local state. Using the information afforded from the inputs often leads to a greater reduction in the number of transitions.
Reference: [7] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A third technique is that of model checking <ref> [7] </ref>. As with reachability analysis, a graph abstraction of the state space is used, but much more general properties of the system can be analyzed. As in the proof-system methods, the properties are specified as logical formulae. <p> While each abstract view must be consistent with the semantics of the Ada source code, there are many possibilities, with each offering trade-offs between the accuracy and efficiency of the analysis. Since the seminal paper describing the CTL model checking approach <ref> [7] </ref>, there have been numerous enhancements; e.g., compositional model checking [8], symbolic model checking [4], real-time model checking [1] and abstract model checking [9, 2]. <p> F 5 : :(G ! 9 fl (AC ^ Bw ^ 9 fl (F 3 ^ H))) The original model checking procedure <ref> [7] </ref> is capable of verifying these assertions, but only after expanding the entire state-space. Assume that we are interested in verifying a formula F against the transition system T .
Reference: [8] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> 464-475, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Since the seminal paper describing the CTL model checking approach [7], there have been numerous enhancements; e.g., compositional model checking <ref> [8] </ref>, symbolic model checking [4], real-time model checking [1] and abstract model checking [9, 2]. For the most part these enhancements have been added to address two fundamental challenges: the state space explosion problem and the application of the technique to nonfinite state systems. <p> Another alternative is the compositional approach, in which the parts of a system are analyzed separately, and then the results are combined into infer ences about the whole. The approach described in <ref> [8] </ref> is representative: components are composed with "interfaces," and the product is fed into the model checker. The interface (hopefully) yields a simple representation of behaviors to be presented by the environment.
Reference: [9] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> Proceedings of the Nineteenth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> 343-354, </pages> <year> 1992. </year>
Reference-contexts: Since the seminal paper describing the CTL model checking approach [7], there have been numerous enhancements; e.g., compositional model checking [8], symbolic model checking [4], real-time model checking [1] and abstract model checking <ref> [9, 2] </ref>. For the most part these enhancements have been added to address two fundamental challenges: the state space explosion problem and the application of the technique to nonfinite state systems.
Reference: [10] <author> L. K. Dillon. </author> <title> Using symbolic execution for verification of Ada tasking programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 643-669, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: In such cases, some form of static analysis can often help a designer verify that the program will behave as expected. Many static analysis techniques are available, with varying levels of abstraction and computational complexity. Methods based on proof systems (e.g., <ref> [14, 10] </ref>) provide the basic machinery to show that a specification is consistent with a set of Ada tasks. This approach is by far the most general, and as a consequence, it usually does not lead to fully automated verification techniques.
Reference: [11] <author> R. Gerber and I. Lee. </author> <title> A Layered Approach to Automating the Verification of Real-Time Systems. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <year> 1992. </year>
Reference-contexts: Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes a finite-state abstraction of the program, and then checks the states to determine whether they conform to the property at hand (e.g., see <ref> [16, 17, 13, 15, 11] </ref>). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A third technique is that of model checking [7].
Reference: [12] <author> E. A. Emerson and J. Y. Halpern. </author> <title> 'Sometimes' and 'not never' revisited: on branching versus linear time temporal logic. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: All model checking algorithms require two inputs: (1) the property, specified as a formula in a temporal logic such as CTL (see <ref> [12] </ref>); and (2) the abstract model of the system, given by its transition system. Akin to reachability analysis, the system can be represented in various degrees of abstraction.
Reference: [13] <author> D. L. Long and L. A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> 44-52, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes a finite-state abstraction of the program, and then checks the states to determine whether they conform to the property at hand (e.g., see <ref> [16, 17, 13, 15, 11] </ref>). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A third technique is that of model checking [7].
Reference: [14] <author> D. C. Luckham and F. W. von Henke. </author> <title> An overview of Anna, a specification language for Ada. </title> <journal> IEEE Software, </journal> <month> March </month> <year> 1985. </year>
Reference-contexts: In such cases, some form of static analysis can often help a designer verify that the program will behave as expected. Many static analysis techniques are available, with varying levels of abstraction and computational complexity. Methods based on proof systems (e.g., <ref> [14, 10] </ref>) provide the basic machinery to show that a specification is consistent with a set of Ada tasks. This approach is by far the most general, and as a consequence, it usually does not lead to fully automated verification techniques.
Reference: [15] <author> S. P. Masticola and B. G. Ryder. </author> <title> A model for Ada programs for static deadlock detection in polynomial time. </title> <booktitle> Proceedings of ACM Sig-plan Programming Languages Design and Implementation, ACM Sigplan Notices, </booktitle> <volume> 26(12) </volume> <pages> 97-107, </pages> <year> 1991. </year>
Reference-contexts: Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes a finite-state abstraction of the program, and then checks the states to determine whether they conform to the property at hand (e.g., see <ref> [16, 17, 13, 15, 11] </ref>). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A third technique is that of model checking [7].
Reference: [16] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes a finite-state abstraction of the program, and then checks the states to determine whether they conform to the property at hand (e.g., see <ref> [16, 17, 13, 15, 11] </ref>). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A third technique is that of model checking [7].
Reference: [17] <author> M. Young and W. J. Yeh. </author> <title> Compositional reach-ability analysis of Ada programs using process algebra. Proc. of Testing, Analysis and Verification. </title> <month> August </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes a finite-state abstraction of the program, and then checks the states to determine whether they conform to the property at hand (e.g., see <ref> [16, 17, 13, 15, 11] </ref>). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A third technique is that of model checking [7].
References-found: 17

