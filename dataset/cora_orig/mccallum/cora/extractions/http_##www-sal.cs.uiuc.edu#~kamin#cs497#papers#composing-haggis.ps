URL: http://www-sal.cs.uiuc.edu/~kamin/cs497/papers/composing-haggis.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/cs497/papers.html
Root-URL: http://www.cs.uiuc.edu
Email: E-mail: fsof,simonpjg@dcs.glasgow.ac.uk  
Title: Composing Haggis key ingredients that Haggis relies on to provide its compositional style are concurrency
Author: Sigbjrn Finne and Simon Peyton Jones 
Note: Two  
Address: Glasgow G12 8QQ, United Kingdom.  
Affiliation: Department of Computing Science, University of Glasgow,  
Abstract: Haggis is a purely-functional, multi-threaded user interface framework for composing interactive applications. It provides a compositional view of the world of user interface applications, applying to all aspects of the interface the principle of building a component from parts. Interactive components are viewed as virtual I/O devices that are composed together to make up complete applications. To fully support this style of programming, Haggis makes good use of the integral features of Haskell, a lazy, purely-functional language. The resulting system offers an extensible, modular and simple programming model for writing user interface applications at a high level of abstraction. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Adobe Systems Inc. </institution> <note> PostScript language referencemanual. Addison Wesley, second edition, </note> <year> 1990. </year>
Reference-contexts: a -&gt; Widget a mkPopup :: Widget a -&gt; Widget (a, Popup) printerW :: Widget a -&gt; Widget (a, Printer) The combinator printerW encapsulates an arbitrary component for printing, so that when the action printW printer "dump.ps" printW :: Printer -&gt; String -&gt; IO () is executed, a PostScript 5 <ref> [1] </ref> representation of the current graphical output for the encapsulated component is generated.
Reference: [2] <author> Paul R. Calder and Mark A. Linton. Glyphs: </author> <title> Flyweight objects for user interfaces. </title> <booktitle> In ACM Symposium on User Interface Software and Technology, </booktitle> <pages> pages 92-101, </pages> <year> 1990. </year>
Reference-contexts: The windowing model is similar to Fresco's [11], and heavy use is made of lightweight display objects based on glyphs <ref> [2] </ref>, which, in X terms, do not have a window associated with them. A consequence of having such a `windowless' windowing model is that updates cannot be done by issuing drawing requests to X asynchronously, since a widget could be obscured by others.
Reference: [3] <author> Magnus Carlsson and Thomas Hallgren. </author> <title> FUDGETS a graphical user interface in a lazy functional language. </title> <booktitle> In Proceedings of the 6th ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 321 - 330. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The use of concurrency to structure both the underlying implementation and application is common for both systems, but the current implementation of Haggis has a less fine-grained use of processes. 6 Available by anonymous ftp from ftp://ftp.dcs.glasgow.ac.uk/pub/haskell/ Other functional approaches (notably Fudgets <ref> [3] </ref>) have been evaluated well else-where [15]; Haggis differs from these in its use of concurrency and monads to structure interaction with the outside world.
Reference: [4] <author> Sigbjorn Finne and Simon Peyton Jones. </author> <title> Pictures: A simple structured graphics model. </title> <booktitle> In Glasgow Functional Programming Workshop, </booktitle> <address> Ullapool, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: This is made possible by the device-independent 2D graphics model used to describe graphical output <ref> [4] </ref>, where pictures are described by composing parts, similar to that of [7, 20]. 5 PostScript is trademark of Adobe Systems Incorporated. 5 Implementation Haggis is operational and currently only available for internal use at Glasgow.
Reference: [5] <author> Emden W. Gansner and John H. Reppy. eXene. </author> <booktitle> In Proceedings of the 1991 CMU Workshop on SML, </booktitle> <month> October 31 </month> <year> 1991. </year>
Reference-contexts: The resulting system has a simple, uniform application interface to the windowing capabilities, making its presence almost transparent to the programmer. Haggis is most closely related to eXene <ref> [5] </ref>, a multi-threaded framework written in Concurrent ML (CML) [19].
Reference: [6] <author> H. R. Hartson, A. Siochi, and D. Hix. </author> <title> The UAN: A user-oriented representation for direct manipulation interface designs. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(3) </volume> <pages> 181-203, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Different approaches to specifying interactive behaviour can be accommodated, such as the generic interactors used by [8, 13], where default behaviour can be overridden and adapted to fit context of use, or higher level notations such as the UAN <ref> [6] </ref>. Haggis does not dictate the manner in which the controllers should be expressed, but we are currently experimenting with an approach similar to that of Interactors [13], where the different types of interactions possible using mouse and keyboard are enumerated.
Reference: [7] <author> Peter Henderson. </author> <title> Functional geometry. </title> <booktitle> In ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 179-187, </pages> <year> 1982. </year>
Reference-contexts: This is made possible by the device-independent 2D graphics model used to describe graphical output [4], where pictures are described by composing parts, similar to that of <ref> [7, 20] </ref>. 5 PostScript is trademark of Adobe Systems Incorporated. 5 Implementation Haggis is operational and currently only available for internal use at Glasgow.
Reference: [8] <author> Tyson R. Henry, Scott E. Hudson, and Gary L. Newell. </author> <title> Integrating gesture and snapping into a user interface toolkit. </title> <booktitle> In Proceedings of UIST'90, </booktitle> <pages> pages 112-121, </pages> <year> 1990. </year>
Reference-contexts: The basic encapsulation or delegation mechanism does not specify how to express the controller itself. Different approaches to specifying interactive behaviour can be accommodated, such as the generic interactors used by <ref> [8, 13] </ref>, where default behaviour can be overridden and adapted to fit context of use, or higher level notations such as the UAN [6].
Reference: [9] <editor> Paul Hudak et al. </editor> <title> Report on the programming language haskell version 1.2. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Its salient features are: * It is based on a functional language. The framework is implemented in Haskell <ref> [9] </ref>, a lazy, purely-functional language. <p> Interactive objects are the medium by which application and user interact. Haggis extends the metaphor of devices and device handles to such objects, treating interactive components as virtual I/O devices where the user and application can exchange information (Section 2.3) 2 Overview Haskell <ref> [9] </ref> is the standard non-strict, purely-functional programming language, and several high quality, freely available compilers already exist for it. <p> Requires support for concurrency. One area of further work is to look into ways of defining relationships between different types of interactive devices and operations over them. Haskell's type classes <ref> [9] </ref> are not expressive enough for defining these relationships, and we are currently investigating how the more powerful type system of constructor classes [10] can be put to use. Alas, it is out of the scope of this paper to go into detail here.
Reference: [10] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <booktitle> In Proceedings of the 6th ACM Conference on Functional Programming and Computer Architecture, </booktitle> <address> Copenhagen, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: One area of further work is to look into ways of defining relationships between different types of interactive devices and operations over them. Haskell's type classes [9] are not expressive enough for defining these relationships, and we are currently investigating how the more powerful type system of constructor classes <ref> [10] </ref> can be put to use. Alas, it is out of the scope of this paper to go into detail here. Haggis is operational and one near term goal is to release the system for others to try and evaluate.
Reference: [11] <author> Mark Linton and Chuck Price. </author> <title> Building distributed user interfaces with fresco. </title> <booktitle> In Proceedings of the Seventh X Technical Conference, </booktitle> <pages> pages 77-87, </pages> <address> Boston, MA, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: The central idea in Haggis is to view the construction of a user interface as a composition from parts. This compositional approach is similar to the object-oriented approaches of Interviews [12], and more recently Fresco <ref> [11] </ref>, but differs in that Haggis provides a unified programming model for writing both applications and new first-class interactive components. The compositional mechanisms are described in detail in Section 3, and a discussion of the relationship to other systems can be found in Section 6. * It is extensible. <p> Internally, concurrency is used to structure tasks such as the delivery of events, redisplay and the provision of servers to manage resources such as fonts and colours to provide a more convenient and declarative interface to the underlying window system. The windowing model is similar to Fresco's <ref> [11] </ref>, and heavy use is made of lightweight display objects based on glyphs [2], which, in X terms, do not have a window associated with them. <p> Rather than having a global redisplay thread which takes care of damage repair, Haggis distributes clipping regions to each component, so that asynchronous redisplay becomes possible. 6 Related Work Haggis' use of composition as the main programming glue is to some degree used by Fresco <ref> [11] </ref>. Built on top of class-based, object oriented languages, Fresco provides a set of common user interface abstractions together with a fixed collection of operators for combining them.
Reference: [12] <author> Mark A. Linton, J.M. Vlissides, and P.R. Calder. </author> <title> Composing user interfaces with InterViews. </title> <journal> IEEE Computer, </journal> <volume> 22(2) </volume> <pages> 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The central idea in Haggis is to view the construction of a user interface as a composition from parts. This compositional approach is similar to the object-oriented approaches of Interviews <ref> [12] </ref>, and more recently Fresco [11], but differs in that Haggis provides a unified programming model for writing both applications and new first-class interactive components.
Reference: [13] <author> Brad A. Myers. </author> <title> A new model for handling input. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(2) </volume> <pages> 289-320, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The basic encapsulation or delegation mechanism does not specify how to express the controller itself. Different approaches to specifying interactive behaviour can be accommodated, such as the generic interactors used by <ref> [8, 13] </ref>, where default behaviour can be overridden and adapted to fit context of use, or higher level notations such as the UAN [6]. <p> Haggis does not dictate the manner in which the controllers should be expressed, but we are currently experimenting with an approach similar to that of Interactors <ref> [13] </ref>, where the different types of interactions possible using mouse and keyboard are enumerated.
Reference: [14] <author> Brad A. Myers. </author> <title> Why are human-computer interfaces difficult to design and implement? Technical Report CMU-CS-93-183, </title> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Writing and maintaining user interface software can be a trying experience. Established software engineering habits such as the modularization of code into different parts and the composition of these to make up a complete system, do not currently carry over to the user interface domain <ref> [14] </ref>. The servitude that the non-user interface parts has to endure under the tyranny of the event-loop is well known, but the frameworks provided for programming the user interface are also lacking.
Reference: [15] <author> Rob Noble and Colin Runciman. </author> <title> Functional languages and graphical user interfaces - a review and a case study. </title> <type> Technical Report 94-223, </type> <institution> Department of Computer Science, University of York, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: The use of concurrency to structure both the underlying implementation and application is common for both systems, but the current implementation of Haggis has a less fine-grained use of processes. 6 Available by anonymous ftp from ftp://ftp.dcs.glasgow.ac.uk/pub/haskell/ Other functional approaches (notably Fudgets [3]) have been evaluated well else-where <ref> [15] </ref>; Haggis differs from these in its use of concurrency and monads to structure interaction with the outside world.
Reference: [16] <author> Simon Peyton Jones, Andrew Gordon, and Sigbjorn Finne. </author> <title> Concurrent Haskell. </title> <booktitle> In ACM Symposium on the Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: To be able to treat user interface components as black boxes that can be composed together, Haggis relies on the use of concurrency. It is implemented in Concurrent Haskell <ref> [16] </ref>, an extension of standard Haskell with support for the dynamic creation of lightweight threads and, at the lowest level, shared memory synchronization primitives. <p> It can be thought of as given the state of the Real World, which it then proceeds to side-effect by executing a sequence of actions on it. * In Concurrent Haskell <ref> [16] </ref>, processes can be created dynamically using the forkIO construct (forkIO :: IO () -&gt; IO ().) It eagerly starts to evaluate the action it is passed, concurrently with the context that executed the forkIO action. <p> The user normally interleaves interaction between different parts of an interface. If the application has to repeatedly check which device was last interacted with and then execute some appropriate action in response, event-loops at the level of devices have effectively been introduced. In Haggis, Concurrent Haskell's <ref> [16] </ref> lightweight processes are used to dynamically create processes to handle interaction with parts of the user interface.
Reference: [17] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In ACM Conference on the Principles of Programming Languages, </booktitle> <pages> pages 71 - 84. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: The key point of the IO monad is that the combinators thenIO and seqIO serialize I/O operations. The evaluation order of the (side-effecting) actions becomes thus fixed, admitting not only an efficient implementation <ref> [17] </ref>, but allows I/O performing, purely-functional programs to be expressed without sacrificing vital underlying language properties.
Reference: [18] <author> Rob Pike. Acme: </author> <title> A user interface for programmers. </title> <booktitle> In Proceedings of the Winter 1994 USENIX Conference, </booktitle> <pages> pages 223-234, </pages> <address> San Fransisco, </address> <year> 1994. </year>
Reference-contexts: A useful advance introduced by UNIX was to present an interface to the program that hid whether the input came from a file, another program or the keyboard. Haggis extends this device abstraction to include user interface components. This is not new and unique to Haggis <ref> [18] </ref>, but this perspective differs distinctly from an event-driven system. Changing the input of the character counting program in an event-driven system to use a `virtual keyboard' displayed on the screen would require the program structure to be turned inside out. The interface drives the application. <p> Although the two systems explore largely different issues, Haggis extends the use of hierarchical composition beyond the interface, providing semantic operations such as combineButtons. The extension of the device abstraction to incorporate interactive components is also used by Acme <ref> [18] </ref>, a concurrent window system that provide access to its windows via a file system interface. The resulting system has a simple, uniform application interface to the windowing capabilities, making its presence almost transparent to the programmer.
Reference: [19] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> Proceedings of the ACM SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <year> 1991. </year>
Reference-contexts: The resulting system has a simple, uniform application interface to the windowing capabilities, making its presence almost transparent to the programmer. Haggis is most closely related to eXene [5], a multi-threaded framework written in Concurrent ML (CML) <ref> [19] </ref>.
Reference: [20] <author> Roger Took. </author> <title> Surface interaction: A paradigm and model for separating application and interface. </title> <booktitle> In Proceedings of the CHI'90, </booktitle> <pages> pages 35-42, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: This is made possible by the device-independent 2D graphics model used to describe graphical output [4], where pictures are described by composing parts, similar to that of <ref> [7, 20] </ref>. 5 PostScript is trademark of Adobe Systems Incorporated. 5 Implementation Haggis is operational and currently only available for internal use at Glasgow.
Reference: [21] <author> Michael Travers. </author> <title> Recursive interfaces for reactive objects. </title> <booktitle> In Proceedings of CHI'94, </booktitle> <pages> pages 379-385, </pages> <address> Boston, MA, </address> <month> April 24-28 </month> <year> 1994. </year>
Reference-contexts: Haggis differs in that it tries to provide a uniform programming model where the construction of a user interface is inseparable from the construction of new components. This uniform representation of the world is similar to LiveWorld <ref> [21] </ref>, a prototype-based graphical programming system for experimenting with active objects. It has a uniform object model based on recursive containment, so the hierarchies constructed are similar to what Haggis creates.
Reference: [22] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Proceedings of the ACM SIG-PLAN 19th Annual Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year> <type> Invited talk. </type>
Reference-contexts: The discovery of the applicability of monads to functional programming <ref> [22] </ref> has, amongst other things, provided a frame-work for writing interactive programs in a non-strict, purely-functional language. For the purposes of this paper, a monad provides a functional framework for expressing computations that side-effect without compromising features such as equational reasoning.
References-found: 22

