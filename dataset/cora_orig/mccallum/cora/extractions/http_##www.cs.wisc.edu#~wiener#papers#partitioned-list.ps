URL: http://www.cs.wisc.edu/~wiener/papers/partitioned-list.ps
Refering-URL: http://www.cs.wisc.edu/shore/shore.papers.html
Root-URL: 
Email: fwiener,naughtong@cs.wisc.edu  
Title: OODB Bulk Loading Revisited: The Partitioned-List Approach  
Author: Janet L. Wiener Jeffrey F. Naughton 
Address: 1210 W. Dayton St., Madison, WI 53706  
Affiliation: Department of Computer Sciences University of Wisconsin-Madison  
Abstract: Object-oriented and object-relational databases (OODB) need to be able to load the vast quantities of data that OODB users bring to them. Loading OODB data is significantly more complicated than loading relational data due to the presence of relationships, or references, in the data; the presence of these relationships means that naive loading algorithms are slow to the point of being unusable. In our previous work, we presented the late-invsort algorithm, which performed significantly better than naive algorithms on all the data sets we tested. Unfortunately, further experimentation with the late-invsort algorithm revealed that for large data sets (ones in which a critical data structure of the load algorithm does not fit in memory), the performance of late-invsort rapidly degrades to where it, too, is unusable. In this paper we propose a new algorithm, the partitioned-list algorithm, whose performance almost matches that of late-invsort for smaller data sets but does not degrade for large data sets. We present a performance study of an implementation within the Shore persistent object repository showing that the partitioned-list algorithm is at least an order of magnitude better than previous algorithms on large data sets. In addition, because loading gigabytes and terabytes of data can take hours, we describe how to checkpoint the partitioned-list algorithm and resume a long-running load after a system crash or other interruption.
Abstract-found: 1
Intro-found: 1
Reference: [Cam95] <author> John Campbell, </author> <month> Jan. </month> <year> 1995. </year> <type> Personal communication. </type>
Reference-contexts: We give two examples of such data sets from the scientific community. In both cases, the scientists involved are using or planning to use an OODB to store their data. * The Human Genome Database <ref> [Cam95, CPea93] </ref> is currently just over 1 gigabyte of 50-200 byte objects, containing 3-15 bidirectional relationships each.
Reference: [Cat93] <author> R. G. G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan-Kaufman, Inc., </publisher> <year> 1993. </year>
Reference-contexts: Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard <ref> [Cat93] </ref>. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships [Ont94, Obj92, LLOW91, Ver93]. In addition to dealing with relationships, a good load utility must be able to load data sets of widely varying sizes. <p> In this schema, each Experiment object has a many-to-one relationship with an Input object and a one-to-one relationship with an Output object. Figure 1 defines the schema in the Object Definition Language proposed by ODMG <ref> [Cat93] </ref>. interface Experiment f attribute char scientist [16]; relationship Ref&lt;Input&gt; input inverse Input::expts; relationship Ref&lt;Output&gt; output inverse Output::expt; g; interface Input f attribute double temperature; attribute long humidity; relationship Set&lt;Experiment&gt; expts inverse Experiment::input; g; interface Output f attribute double plant growth; relationship Ref&lt;Experiment&gt; expt inverse Experiment::output; g; 2.2 Example data file
Reference: [CDF + 94] <author> M. Carey, et al.. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> Proc. SIGMOD, p. </booktitle> <pages> 383-394, </pages> <year> 1994. </year> <month> 23 </month>
Reference-contexts: We believe that any OODB that provides logical OIDs can also provide pre-assignment of OIDs; we know it is possible at the buffer manager level in GemStone [Mai94] and in Ontos, as well as in Shore <ref> [CDF + 94] </ref>. Using logical OIDs does require the database to store an extra index that maps logical to physical OIDs. However, we found previously that the advantages of using logical OIDs (such as having smaller OIDs) outweigh the costs of maintaining and using this index [WN94]. <p> There is very little random I/O being performed on behalf of the algorithm, because there is no longer 13 random access to any load data structure. 4 Implementation We implemented all of the algorithms in C++. The database was stored under the Shore storage manager <ref> [CDF + 94] </ref>. We used the Shore persistent object manager, even though it is still under development, for two reasons. First, Shore provides the notion of a "value-added server" (VAS), which allowed us to place the load utility directly in the server.
Reference: [CMR92] <author> J. B. Cushing, D. Maier, and M. Rao. </author> <title> Computational Proxies: Modeling Scientific Applications in Object Databases. </title> <type> Tech. Report 92-020, </type> <institution> Oregon Graduate Institute, </institution> <month> Dec. </month> <year> 1992. </year> <note> Revised May, </note> <year> 1993. </year>
Reference-contexts: These methods, i.e., insert statements in a data manipulation language, or new statements in a database programming language, are more appropriate for loading tens and hundreds of objects than for loading millions of objects. Loading large amounts of data is currently a bottleneck in many OODB applications <ref> [CMR92, CMR + 94] </ref>. Relational database systems provide a load utility to bypass the individual language statements. The load utility takes an ascii description of all of the data to be loaded and returns when it has loaded it.
Reference: [CMR + 94] <author> J. B. Cushing, D. Maier, M. Rao, D. Abel, D. Feller, and D. M. DeVaney. </author> <title> Computational Proxies: Modeling Scientific Applications in Object Databases. </title> <booktitle> Proc. Scientific and Statistical Database Management, </booktitle> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: These methods, i.e., insert statements in a data manipulation language, or new statements in a database programming language, are more appropriate for loading tens and hundreds of objects than for loading millions of objects. Loading large amounts of data is currently a bottleneck in many OODB applications <ref> [CMR92, CMR + 94] </ref>. Relational database systems provide a load utility to bypass the individual language statements. The load utility takes an ascii description of all of the data to be loaded and returns when it has loaded it.
Reference: [CPea93] <author> M.A. Chipperfield, C.J. Porter, et al. </author> <title> Growth of Data in the Genome Data Base since CCM92 and Methods for Access. Human Genome Mapping, </title> <booktitle> p. </booktitle> <pages> 3-5, </pages> <year> 1993. </year>
Reference-contexts: We give two examples of such data sets from the scientific community. In both cases, the scientists involved are using or planning to use an OODB to store their data. * The Human Genome Database <ref> [Cam95, CPea93] </ref> is currently just over 1 gigabyte of 50-200 byte objects, containing 3-15 bidirectional relationships each.
Reference: [Deu90] <author> O. </author> <title> Deux. The Story of O2. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: The load utility can therefore dramatically reduce the amount of client-server interaction, and hence both the layers of software traversed and the communication overhead to create each new object. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 <ref> [Deu90] </ref>, Objectivity [Obj92], ObjectStore [LLOW91], Versant [Ver93], and Gemstone [MS90].
Reference: [DLP + 93] <author> R. Drach, et al. </author> <title> Optimizing Mass Storage Organization and Access for Multi-Dimensional Scientific Data. </title> <booktitle> Proc. IEEE Symposium on Mass Storage Systems, </booktitle> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: In the range of 40 gigabytes to 3 terabytes of data is produced in a single simulation history <ref> [DLP + 93] </ref>! An id map for a single data set requires upwards of 200 megabytes. We note that the physical memory available for a load is not necessarily the total physical memory of the machine, but rather the memory not being used by other concurrent queries or utilities.
Reference: [Kea83] <author> M. Kitsuregawa and et al. </author> <title> Application of Hash to Data Base Machine and its Architecture. </title> <journal> New Generation Computing, </journal> <volume> 1 </volume> <pages> 62-74, </pages> <year> 1983. </year>
Reference-contexts: This performance gap could be narrowed by using a hybrid hash join [Sha86] 16 in the partitioned-list algorithm instead of the standard Grace hash join <ref> [Kea83] </ref> to join the id map, todo list, and inverse todo lists.
Reference: [Kim94] <author> W. Kim. </author> <title> UniSQL/X Unified Relational and Object-Oriented Database System. </title> <booktitle> Proc. SIGMOD, </booktitle> <address> p. 481, </address> <year> 1994. </year>
Reference-contexts: which happens whether or not the page must first be (expensively) fetched from disk. (a) (b) (c) 5.2.3 Comparing large data set algorithms when there are no inverse relationships Although all of the major commercial OODB vendors support inverse relationships, many object-relational DBs do not (e.g., Illustra [Ube94] and UniSQL <ref> [Kim94] </ref>) and/or users may choose not to use them. As a final comparison of the algorithms for handling large data sets, we altered the data file to explicitly list all ten relationships from each object and removed the inverse relationships from the schema. <p> Without locality of reference in the data set, partitioned-list completed 16 times faster than btree on a 60 Mb data set! Even when there are no inverse relationships in the schema, e.g., in object-relational databases such as Illustra [Ube94] and UniSQL <ref> [Kim94] </ref>, partitioned-list is an order of magnitude faster. By eliminating all random accesses to data structures, and by writing and reading each data item exactly once, we achieve linear I/O costs for partitioned-list in the size of the data set.
Reference: [LLOW91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> CACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: The load utility can therefore dramatically reduce the amount of client-server interaction, and hence both the layers of software traversed and the communication overhead to create each new object. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 [Deu90], Objectivity [Obj92], ObjectStore <ref> [LLOW91] </ref>, Versant [Ver93], and Gemstone [MS90]. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships <ref> [Ont94, Obj92, LLOW91, Ver93] </ref>. In addition to dealing with relationships, a good load utility must be able to load data sets of widely varying sizes. As the size of the data set increases, an increasing degree of care and cleverness is required to load the data quickly.
Reference: [Mai94] <author> David Maier, </author> <month> Jan. </month> <year> 1994. </year> <type> Personal communication. </type>
Reference-contexts: If the database only provides physical OIDs, the algorithm may be modified to create the object in order to get its OID. We believe that any OODB that provides logical OIDs can also provide pre-assignment of OIDs; we know it is possible at the buffer manager level in GemStone <ref> [Mai94] </ref> and in Ontos, as well as in Shore [CDF + 94]. Using logical OIDs does require the database to store an extra index that maps logical to physical OIDs.
Reference: [MN92] <author> C. Mohan and I. Narang. </author> <title> Algorithms for Creating Indexes for Very Large Tables Without Quiescing Updates. </title> <booktitle> Proc. SIGMOD, p. </booktitle> <pages> 361-370, </pages> <year> 1992. </year>
Reference-contexts: Teradata provides a resumable load for their relational database [WCK93] as does DB2 [RZ89]. Mohan and Narang provide an algorithm for what to checkpoint for a resumable sort <ref> [MN92] </ref>, which was the original inspiration for what to checkpoint during a load to make it resumable. 1.2 Structure of the paper The remainder of the paper is structured as follows: In Section 2 we present an example database schema and data file.
Reference: [MN93] <author> C. Mohan and I. Narang. </author> <title> An Efficient and Flexible Method for Archiving a Data Base. </title> <booktitle> Proc. SIGMOD, p. </booktitle> <pages> 139-146, </pages> <year> 1993. </year>
Reference-contexts: One additional step is necessary before pronouncing the load complete. If an archive copy of the database is maintained in case of media failure, a full archive copy of the newly loaded data must be made before the data is read or written <ref> [MN93] </ref>. Otherwise, the data might be lost due to media failure, since there is no log record of the loaded data.
Reference: [Moh93a] <author> C. Mohan. </author> <title> A Survey of DBMS Research Issues in Supporting Very Large Tables. </title> <booktitle> Proc. Foundations of Data Organization and Algorithms, p. </booktitle> <pages> 279-300, </pages> <year> 1993. </year>
Reference-contexts: The database volume was a 2 gigabyte Seagate ST-12400N disk controlled exclusively by Shore. The data file resided on a separate disk and thus did not interfere with the database I/O. For these tests, we turned logging off, as would be expected in a load utility <ref> [Moh93a] </ref>. 5 Performance tests We ran a series of performance tests to show how quickly (or slowly!) each algorithm could load different size data sets. In this section, we will use the names in Table 1 to refer to each algorithm.
Reference: [Moh93b] <author> C. Mohan. </author> <title> IBM's Relational DBMS Products: Features and Technologies. </title> <booktitle> Proc. SIGMOD, p. </booktitle> <pages> 445-448, </pages> <year> 1993. </year>
Reference-contexts: This paper will appear in the Proceedings of the 21st International Conference on Very Large Data Bases, Zurich, Switzer land, September, 1995. z Author's current address: wiener@db.stanford.edu or Dept. of Computer Science, Stanford University, Stanford, CA 94305. 1 small number of objects, because it is based in the database server <ref> [Moh93b] </ref>. The load utility can therefore dramatically reduce the amount of client-server interaction, and hence both the layers of software traversed and the communication overhead to create each new object.
Reference: [MS90] <author> D. Maier and J. Stein. </author> <title> Development and Implementation of an Object-Oriented DBMS. </title> <editor> In S. B. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, p. </booktitle> <pages> 167-185. </pages> <address> Morgan-Kaufman, </address> <publisher> Inc., </publisher> <year> 1990. </year>
Reference-contexts: There are many commercial object-oriented database products today, including Ontos [Ont94], O2 [Deu90], Objectivity [Obj92], ObjectStore [LLOW91], Versant [Ver93], and Gemstone <ref> [MS90] </ref>.
Reference: [Nel91] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: That is, they assume that all of the data can fit in memory and are unsuitable when it can not. Both Snodgrass's Interface Description Language [Sno89] and Pkl for Modula 3 <ref> [Nel91] </ref> fall in this category. Our previous work focused on loading data sets in the second class of sizes [WN94]. We presented alternative strategies for handling forward references in the data file and for handling updates due to inverse relationships.
Reference: [Obj92] <institution> Objectivity, Inc. Objectivity/DB Documentation, </institution> <address> 2.0 edition, </address> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: The load utility can therefore dramatically reduce the amount of client-server interaction, and hence both the layers of software traversed and the communication overhead to create each new object. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 [Deu90], Objectivity <ref> [Obj92] </ref>, ObjectStore [LLOW91], Versant [Ver93], and Gemstone [MS90]. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships <ref> [Ont94, Obj92, LLOW91, Ver93] </ref>. In addition to dealing with relationships, a good load utility must be able to load data sets of widely varying sizes. As the size of the data set increases, an increasing degree of care and cleverness is required to load the data quickly. <p> However, a good load algorithm can achieve a 20-30% performance gain [WN94]. Also, as we mentioned above, a load utility can decrease client-server interaction to speed up 1 Objectivity has something it calls a load utility, however, it can only load data that already contains system-specific object identifiers (OIDs) <ref> [Obj92] </ref>. Similarly, Ontos's bulk load facility is really just an option to turn off logging while running user code that creates large amounts of data [Ont94]. 2 loading, which individual new and insert statements can not. 2.
Reference: [Ont94] <author> Ontos, Inc. </author> <title> Ontos DB Reference Manual, release 3.0 beta edition, </title> <year> 1994. </year>
Reference-contexts: The load utility can therefore dramatically reduce the amount of client-server interaction, and hence both the layers of software traversed and the communication overhead to create each new object. There are many commercial object-oriented database products today, including Ontos <ref> [Ont94] </ref>, O2 [Deu90], Objectivity [Obj92], ObjectStore [LLOW91], Versant [Ver93], and Gemstone [MS90]. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships <ref> [Ont94, Obj92, LLOW91, Ver93] </ref>. In addition to dealing with relationships, a good load utility must be able to load data sets of widely varying sizes. As the size of the data set increases, an increasing degree of care and cleverness is required to load the data quickly. <p> Similarly, Ontos's bulk load facility is really just an option to turn off logging while running user code that creates large amounts of data <ref> [Ont94] </ref>. 2 loading, which individual new and insert statements can not. 2.
Reference: [PG88] <author> N. W. Paton and P. M. D. Gray. </author> <title> Identification of Database Objects by Key. </title> <booktitle> Proc. 2nd Workshop on Object-Oriented Database Systems, p. </booktitle> <pages> 280-285, </pages> <year> 1988. </year>
Reference-contexts: In this example, the surrogates are integers, and they are unique in the data file. In general, however, the surrogates may be strings or numbers; if the class has a key they may be part of the object's data <ref> [PG88] </ref>. Wherever one object references another object, the data file entry for the referencing object contains the surrogate for the referenced object. The process of loading includes translating each surrogates into the OID assigned to the corresponding object. To facilitate this translation, we use an id map.
Reference: [RZ89] <author> R. Reinsch and M. Zimowski. </author> <title> Method for Restarting a Long-Running, Fault-Tolerant Operation in a Transaction-Oriented Data Base System Without Burdening the System Log. </title> <type> U.S. Patent 4,868,744, </type> <institution> IBM, </institution> <year> 1989. </year>
Reference-contexts: There has been no work, however, on loading very large data sets, i.e., data sets so large that they fall in the third class of sizes and the id map does not fit in physical memory. Teradata provides a resumable load for their relational database [WCK93] as does DB2 <ref> [RZ89] </ref>.
Reference: [Sha86] <author> L.D. Shapiro. </author> <title> Join Processing in Database Systems with Large Main Memories. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 11(3), </volume> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: In-mem is better than partitioned-list when the id map does fit in memory because it writes neither the id map nor a todo list to disk. This performance gap could be narrowed by using a hybrid hash join <ref> [Sha86] </ref> 16 in the partitioned-list algorithm instead of the standard Grace hash join [Kea83] to join the id map, todo list, and inverse todo lists.
Reference: [Sno89] <author> R. Snodgrass. </author> <title> The Interface Description Language: Definition and Use. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: That is, they assume that all of the data can fit in memory and are unsuitable when it can not. Both Snodgrass's Interface Description Language <ref> [Sno89] </ref> and Pkl for Modula 3 [Nel91] fall in this category. Our previous work focused on loading data sets in the second class of sizes [WN94]. We presented alternative strategies for handling forward references in the data file and for handling updates due to inverse relationships.
Reference: [Ube94] <author> M. Ubell. </author> <title> The Montage Extensible DataBlade Architecture. </title> <booktitle> Proc. SIGMOD, </booktitle> <address> p. 482, </address> <year> 1994. </year>
Reference-contexts: the buffer pool, which happens whether or not the page must first be (expensively) fetched from disk. (a) (b) (c) 5.2.3 Comparing large data set algorithms when there are no inverse relationships Although all of the major commercial OODB vendors support inverse relationships, many object-relational DBs do not (e.g., Illustra <ref> [Ube94] </ref> and UniSQL [Kim94]) and/or users may choose not to use them. As a final comparison of the algorithms for handling large data sets, we altered the data file to explicitly list all ten relationships from each object and removed the inverse relationships from the schema. <p> Without locality of reference in the data set, partitioned-list completed 16 times faster than btree on a 60 Mb data set! Even when there are no inverse relationships in the schema, e.g., in object-relational databases such as Illustra <ref> [Ube94] </ref> and UniSQL [Kim94], partitioned-list is an order of magnitude faster. By eliminating all random accesses to data structures, and by writing and reading each data item exactly once, we achieve linear I/O costs for partitioned-list in the size of the data set.
Reference: [Ver93] <author> Versant Object Technology. </author> <title> Versant Object Database Management System C++Versant Manual, </title> <note> release 2 edition, </note> <month> July </month> <year> 1993. </year>
Reference-contexts: The load utility can therefore dramatically reduce the amount of client-server interaction, and hence both the layers of software traversed and the communication overhead to create each new object. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 [Deu90], Objectivity [Obj92], ObjectStore [LLOW91], Versant <ref> [Ver93] </ref>, and Gemstone [MS90]. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships <ref> [Ont94, Obj92, LLOW91, Ver93] </ref>. In addition to dealing with relationships, a good load utility must be able to load data sets of widely varying sizes. As the size of the data set increases, an increasing degree of care and cleverness is required to load the data quickly.
Reference: [WCK93] <author> A. Witkowski, F. Cari~no, and P. Kostamaa. </author> <title> NCR 3700 | The Next-Generation Industrial Database Computer. </title> <booktitle> Proc. VLDB, p. </booktitle> <pages> 230-243, </pages> <year> 1993. </year>
Reference-contexts: There has been no work, however, on loading very large data sets, i.e., data sets so large that they fall in the third class of sizes and the id map does not fit in physical memory. Teradata provides a resumable load for their relational database <ref> [WCK93] </ref> as does DB2 [RZ89]. <p> Flushing the buffer pool ensures that the state of the load as of the checkpoint can be recovered from disk after a crash. Teradata also flushes all loaded data to disk when taking a resumable load checkpoint <ref> [WCK93] </ref>. For each step of our partitioned-list load algorithm, we now summarize the action of the step, describe when a checkpoint is permitted, what to write in the checkpoint record, and how to use the checkpoint record information to resume the load. 1.
Reference: [WN94] <author> J. L. Wiener and J. F. Naughton. </author> <title> Bulk Loading into an OODB: A Performance Study. </title> <booktitle> Proc. VLDB, p. </booktitle> <pages> 120-131, </pages> <year> 1994. </year>
Reference-contexts: All of the data to be loaded fits in physical memory. Naive algorithms suffice to load this class. However, a good load algorithm can achieve a 20-30% performance gain <ref> [WN94] </ref>. Also, as we mentioned above, a load utility can decrease client-server interaction to speed up 1 Objectivity has something it calls a load utility, however, it can only load data that already contains system-specific object identifiers (OIDs) [Obj92]. <p> The data itself is too large for memory, but the id map does fit. (The size of the id map is a function of the number of objects regardless of their size.) For this class of load sizes, our previously proposed algorithms <ref> [WN94] </ref> work well, improving performance by one to two orders of magnitude over naive algorithms. 3. Neither the data nor the id map fits in memory. As a followup to [WN94], we ran experiments with loads in this range and found that our previously proposed algorithms exhibited terrible performance due to <p> function of the number of objects regardless of their size.) For this class of load sizes, our previously proposed algorithms <ref> [WN94] </ref> work well, improving performance by one to two orders of magnitude over naive algorithms. 3. Neither the data nor the id map fits in memory. As a followup to [WN94], we ran experiments with loads in this range and found that our previously proposed algorithms exhibited terrible performance due to thrashing (excessive paging of the id map) on id map lookups. Unfortunately, it is for these large loads that a fast load algorithm is most needed. <p> Both Snodgrass's Interface Description Language [Sno89] and Pkl for Modula 3 [Nel91] fall in this category. Our previous work focused on loading data sets in the second class of sizes <ref> [WN94] </ref>. We presented alternative strategies for handling forward references in the data file and for handling updates due to inverse relationships. We recommended one clearly superior algorithm to use for a load utility, and we will revisit its performance for loading data sets of all sizes in this paper. <p> Using logical OIDs does require the database to store an extra index that maps logical to physical OIDs. However, we found previously that the advantages of using logical OIDs (such as having smaller OIDs) outweigh the costs of maintaining and using this index <ref> [WN94] </ref>. The algorithm has 3 steps. 1. Read the data file.
References-found: 28

