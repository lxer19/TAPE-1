URL: http://www.research.digital.com/SRC/personal/monika/papers/monika-esa93.ps.gz
Refering-URL: http://www.research.digital.com/SRC/personal/monika/papers.html
Root-URL: http://www.research.digital.com
Title: Fully Dynamic Planarity Testing in Planar Embedded Graphs  
Author: Giuseppe F. Italiano Johannes A. La Poutre Monika H. Rauch 
Address: Ithaca, NY 14853.  
Note: On leave from  
Affiliation: Dipartimento di Informatica e Sistemistica, Universita di Roma "La Sapienza", Roma, Italy.  IBM T.J. Watson Research Center. Department of Computer Science, Cornell University,  
Abstract: We present the first data structure to maintain an embedded planar graph under arbitrary edge insertions, arbitrary edge deletions and queries that test whether the insertion of a new edge would violate the planarity of the embedding. Our data structure supports online updates and queries on an n-vertex embedded planar graph in O(log 2 n) worst-case time, it can be built in O(n) time and requires O(n) fl This work was supported in part by ESPRIT BRA ALCOM II under contract no. 7141 and by the Italian MURST Project "Algoritmi, Modelli di Calcolo e Strutture Informative". A preliminary version of this paper was presented at the 1st European Symposium on Algorithms, Bad Honnef, Bonn, Germany [10]. z Department of Computer Science, Princeton University, Princeton, NJ 08544, USA. The research of this author was supported by a NATO Science Fellowship awarded by NWO (the Netherlands Organization for Scientific Research), and partially supported by DIMACS (Center for Discrete Mathematics and Theoretical Computer Science - NSF-STC88-09648). Current address: Department of Computer Science, Utrecht University, Utrecht, The Netherlands. space.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, J. D. Ullman, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: During this process, edge bundle lists are subject to splits and merges, and therefore we represent them as balanced binary trees <ref> [1] </ref>. Recall that each edge bundle has its edge count: we store at each internal node of the balanced tree the sum of the edge counts of the leaves in its subtree.
Reference: [2] <author> D. Eppstein, G. F. Italiano, R. Tamassia, R. E. Tarjan, J. Westbrook, M. Yung, </author> <title> "Maintenance of a Minimum Spanning Forest in a Dynamic Planar Graph" J.Algorithms, </title> <booktitle> 13 (1992), </booktitle> <pages> 33-54. </pages>
Reference-contexts: In recent years, there has been a considerable amount of work on dynamic algorithms for plane graphs. Tamassia and Preparata [14] gave dynamic algorithms for transitive closure on st-plane graphs. Eppstein et al. <ref> [2] </ref> showed how to maintain information about the minimum spanning forest and the connected components of a plane graph in O (log n) time per operation. Hershberger et al. [9] gave an algorithm that maintains the 2-edge-connected components of a plane graph in O (log 2 n) time per operation.
Reference: [3] <author> D. Eppstein, Z. Galil, G. F. Italiano, and T. Spencer. </author> <title> "Separator Based Sparsification for Dynamic Planar Graph Algorithms". </title> <booktitle> Proc. 25th Annual Symp. on Theory of Computing, </booktitle> <year> 1993, </year> <pages> 208-217. </pages>
Reference-contexts: If the graph is allowed to change its planar embedding during edge insertions, this problem becomes substantially harder, and the best bound known up to date is O ( p by Eppstein et al. <ref> [3] </ref>. Is the gap between O (log 2 n) and O ( p n ) really required for this problem, if we switch from plane to planar graphs?
Reference: [4] <author> S. Even, R. E. Tarjan, </author> <booktitle> "Computing an st-numbering" Theoretical Computer Science, 2 (1976), </booktitle> <pages> 339-344. </pages>
Reference-contexts: Namely, the algorithm is committed to a precomputed st-numbering <ref> [4] </ref> of the plane graph, and is not able to support all the deletions that are incompatible with this st-numbering. As mentioned in [11], this is closer to an undo operation (which undoes the effect of the last insertion not yet undone) rather than to a general edge deletion.
Reference: [5] <author> G. N. Frederickson, </author> <title> "Data Structures for On-line Updating of Minimum Spanning Trees" SIAM J. </title> <journal> Comput. </journal> <volume> 14 (1985), </volume> <pages> 781-798. </pages>
Reference-contexts: Our data structure is a novel application of the topology trees <ref> [5, 6, 9] </ref>, augmented with some additional information to maintain efficiently dynamic information about the embedding of an arbitrary plane graph. For the ease of description, we only present here our data structure for connected graphs. <p> Throughout the sequence of updates, we maintain a spanning tree T of b G containing all of the dashed edges of b G. We use different data structures for tree edges and non-tree edges. To store tree edges, we use topology trees <ref> [5, 6, 9] </ref>, which represent a tree in a hierarchical way by partitioning the set of vertices into subsets, called clusters. Similar to [9], we group non-tree neighboring edges that are incident to the same clusters into edge bundles. <p> Finally, in Section 7 we list some open problems and concluding remarks. 2 Topology Trees Let b G be a graph whose vertices have degree at most 3, and let T be a spanning tree of b G. In this section we review the topology trees of Frederickson <ref> [5, 6, 9] </ref>, which represent a recursive decomposition of b G based upon T . We need few definitions first. A vertex cluster with respect to T is a set of vertices that induces a connected subgraph on T .
Reference: [6] <author> G. N. Frederickson, </author> <title> "Ambivalent Data Structures for Dynamic 2-Edge-Connectivity and k Smallest Spanning Trees" Proc. </title> <booktitle> 32nd Annual Symp. on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> 632-641. </pages>
Reference-contexts: Our data structure is a novel application of the topology trees <ref> [5, 6, 9] </ref>, augmented with some additional information to maintain efficiently dynamic information about the embedding of an arbitrary plane graph. For the ease of description, we only present here our data structure for connected graphs. <p> Throughout the sequence of updates, we maintain a spanning tree T of b G containing all of the dashed edges of b G. We use different data structures for tree edges and non-tree edges. To store tree edges, we use topology trees <ref> [5, 6, 9] </ref>, which represent a tree in a hierarchical way by partitioning the set of vertices into subsets, called clusters. Similar to [9], we group non-tree neighboring edges that are incident to the same clusters into edge bundles. <p> Finally, in Section 7 we list some open problems and concluding remarks. 2 Topology Trees Let b G be a graph whose vertices have degree at most 3, and let T be a spanning tree of b G. In this section we review the topology trees of Frederickson <ref> [5, 6, 9] </ref>, which represent a recursive decomposition of b G based upon T . We need few definitions first. A vertex cluster with respect to T is a set of vertices that induces a connected subgraph on T . <p> For each cluster formed after the split, we check whether it must be combined with an adjacent cluster. The details of this process can be found in <ref> [6] </ref>. For our purposes, it suffices to state that each insertion/deletion of an edge causes at most a constant number of changes in the legal partition. <p> This implies that at any level a cluster of tree degree 3 consists always of a single vertex. The legal multi-level partition has the nice property of having only logarithmic depth, as implied by the following lemma of Frederickson <ref> [6] </ref>. Lemma 2 ([6]).
Reference: [7] <author> F. Harary, </author> <title> Graph Theory, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference-contexts: We describe algorithms that operate on bounded-degree graphs. This is powerful enough for our goals, since any graph G = (V; E) can be transformed into a graph b G with maximum degree 3, and this transformation can be easily maintained dynamically. The transformation is as follows <ref> [7] </ref>: Suppose a vertex v 2 V has degree d &gt; 3, and the adjacency list of v consists of vertices u 1 ; u 2 ; : : : ; u d (i.e., v is adjacent to u 1 ; u 2 ; : : : ; u d in
Reference: [8] <author> D. Harel, R. E. Tarjan, </author> <title> "Fast Algorithms for Finding Nearest Common Ancestors" SIAM J. </title> <institution> Comput. </institution> <year> (1984). </year>
Reference-contexts: Then we compute the lca of all the edge bundles in the cluster graph based on the new topology tree. This takes time O (log n log log log n) on a pointer machine <ref> [8] </ref>. Adjacent edge bundles with the same target are merged together. This requires removing O (log n) old edge bundles from the edge bundle list and inserting O (log n) new bundles.
Reference: [9] <author> J. Hershberger, M. Rauch, S. Suri. </author> <title> "Fully Dynamic 2-Edge-Connectivity in Planar Graphs" Proc. </title> <booktitle> 3rd Scandinavian Workshop on Algorithm Theory, Lecture Notes in 24 Computer Science vol. </booktitle> <volume> 621, </volume> <publisher> Springer-Verlag, </publisher> <year> 1992, </year> <pages> 233-244. </pages> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: Tamassia and Preparata [14] gave dynamic algorithms for transitive closure on st-plane graphs. Eppstein et al. [2] showed how to maintain information about the minimum spanning forest and the connected components of a plane graph in O (log n) time per operation. Hershberger et al. <ref> [9] </ref> gave an algorithm that maintains the 2-edge-connected components of a plane graph in O (log 2 n) time per operation. Rauch [12] gave an algorithm that maintains information about 2-vertex connectivity in plane graphs in O (log 2 n) time. <p> Our data structure is a novel application of the topology trees <ref> [5, 6, 9] </ref>, augmented with some additional information to maintain efficiently dynamic information about the embedding of an arbitrary plane graph. For the ease of description, we only present here our data structure for connected graphs. <p> Throughout the sequence of updates, we maintain a spanning tree T of b G containing all of the dashed edges of b G. We use different data structures for tree edges and non-tree edges. To store tree edges, we use topology trees <ref> [5, 6, 9] </ref>, which represent a tree in a hierarchical way by partitioning the set of vertices into subsets, called clusters. Similar to [9], we group non-tree neighboring edges that are incident to the same clusters into edge bundles. <p> We use different data structures for tree edges and non-tree edges. To store tree edges, we use topology trees [5, 6, 9], which represent a tree in a hierarchical way by partitioning the set of vertices into subsets, called clusters. Similar to <ref> [9] </ref>, we group non-tree neighboring edges that are incident to the same clusters into edge bundles. Additionally, we keep bits, called coverage bits, at each face that tell us which edges can be embedded inside the face, and show how to maintain these bits dynamically. <p> Finally, in Section 7 we list some open problems and concluding remarks. 2 Topology Trees Let b G be a graph whose vertices have degree at most 3, and let T be a spanning tree of b G. In this section we review the topology trees of Frederickson <ref> [5, 6, 9] </ref>, which represent a recursive decomposition of b G based upon T . We need few definitions first. A vertex cluster with respect to T is a set of vertices that induces a connected subgraph on T . <p> The topology tree of an n-vertex spanning tree has height fi (log n). We now sketch how to update a topology tree. In this description, we follow the general approach of Hershberger et al. <ref> [9] </ref>. If there are updates in b G, its spanning tree T and consequently the legal multi-level partition may be required to change. <p> A similar procedure expands the topology tree at any constant number of vertices in O (log n) time. This yields a tree of clusters linked by edges of T , called the expansion tree, and having O (1) clusters per level. The following lemma by Hershberger et al. <ref> [9] </ref> shows that this tree is well structured. Lemma 3 ([9]). If the topology tree is expanded at a constant number of vertices, the sum of the level differences between neighboring clusters in the expansion tree is O (log n). <p> We first describe a data structure, called an edge bundle, for storing non-tree edges, and then describe the other two data structures for storing faces: coverage lists and face lists. 3.1 Edge Bundles Our definition of edge bundles is a variation of the data structure defined in <ref> [9] </ref>. Let C be a cluster, and let e = (u; v) be a non-tree edge incident to C, with u being the vertex in C. <p> Thus the total time for expanding the topology tree is O (log 2 n). 2 After the expansion of the topology tree at a constant number of vertices, all edge bundles are precisely retargeted and the cluster graph is built. Hershberger et al. <ref> [9] </ref> show that the retargeting takes time O (log n) plus the time for splitting O (log n) edge bundles.
Reference: [10] <author> G. F. Italiano, J. A. La Poutre, M. H. Rauch, </author> <title> "Fully Dynamic Planarity Testing in Planar Embedded Graphs", </title> <booktitle> Proc. 1st Annual European Symposium on Algorithms, </booktitle> <address> Bad Honnef, Bonn, Germany, </address> <month> 30 September - 2 October </month> <year> 1993, </year> <booktitle> Lecture Notes in Computer Science vol. </booktitle> <volume> 726, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993, </year> <pages> 212-223. </pages>
Reference: [11] <author> J. A. La Poutre, J. Westbrook, </author> <title> "Dynamic Two-Connectivity with Backtracking." </title> <booktitle> Proc. 5th ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1994, </year> <pages> 204-212. </pages>
Reference-contexts: Namely, the algorithm is committed to a precomputed st-numbering [4] of the plane graph, and is not able to support all the deletions that are incompatible with this st-numbering. As mentioned in <ref> [11] </ref>, this is closer to an undo operation (which undoes the effect of the last insertion not yet undone) rather than to a general edge deletion.
Reference: [12] <author> M. H. </author> <title> Rauch "Improved Data Structures for Fully Dynamic Biconnectivity." </title> <booktitle> Proc. 26th Symp. on Theory of Computing, </booktitle> <year> 1994. </year>
Reference-contexts: Hershberger et al. [9] gave an algorithm that maintains the 2-edge-connected components of a plane graph in O (log 2 n) time per operation. Rauch <ref> [12] </ref> gave an algorithm that maintains information about 2-vertex connectivity in plane graphs in O (log 2 n) time. In all of these algorithms, insertions expect to be told in which face the edge is to be inserted. <p> Our data structure supports queries and updates in O (log 2 n) worst-case time each. Recently, Rauch proved a lower bound of (log n= log log n) for this problem <ref> [12] </ref>, which holds in the cell probe model of computation [15]. Our algorithm is a factor of log n log log n away from this lower bound, leaving open the question of whether our bounds can be improved.
Reference: [13] <author> R. Tamassia, </author> <title> "A Dynamic Data Structure for Planar Graph Embedding", </title> <booktitle> Proc. 15th ICALP , LNCS 317, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988, </year> <pages> 576-590. </pages>
Reference-contexts: However, none of these algorithms can test whether this condition is fulfilled within the given time bounds. Indeed, although there is an O (log n) algorithm by Tamassia <ref> [13] </ref> to maintain information about the embedding of a plane graph, this algorithm is not able to carry out the full repertoire of updates, since it supports only special cases of deletions.
Reference: [14] <author> R. Tamassia, F. P. Preparata, </author> <title> "Dynamic Maintenance of Planar Digraphs, with Applications", </title> <journal> Algorithmica, </journal> <volume> 5 (1990), </volume> <pages> 509-527. </pages>
Reference-contexts: If the graph is plane, we assume that we are given the adjacency lists corresponding to the committed embedding. In recent years, there has been a considerable amount of work on dynamic algorithms for plane graphs. Tamassia and Preparata <ref> [14] </ref> gave dynamic algorithms for transitive closure on st-plane graphs. Eppstein et al. [2] showed how to maintain information about the minimum spanning forest and the connected components of a plane graph in O (log n) time per operation.
Reference: [15] <author> A. Yao, </author> <title> "Should Tables Be Sorted", </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 28(3), </volume> <year> 1981, </year> <pages> 615-628. 25 </pages>
Reference-contexts: Our data structure supports queries and updates in O (log 2 n) worst-case time each. Recently, Rauch proved a lower bound of (log n= log log n) for this problem [12], which holds in the cell probe model of computation <ref> [15] </ref>. Our algorithm is a factor of log n log log n away from this lower bound, leaving open the question of whether our bounds can be improved.
References-found: 15

