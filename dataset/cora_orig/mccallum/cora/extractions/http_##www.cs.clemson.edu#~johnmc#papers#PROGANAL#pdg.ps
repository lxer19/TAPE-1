URL: http://www.cs.clemson.edu/~johnmc/papers/PROGANAL/pdg.ps
Refering-URL: http://www.cs.clemson.edu/~johnmc/prog_anal_papers.html
Root-URL: http://www.cs.clemson.edu
Title: An Extensible Program Representation for Object-Oriented Software 1  
Author: Brian A. Malloy John D. McGregor Anand Krishnaswamy 
Address: Clemson, SC 29634-1906  
Affiliation: Dept. of Computer Science Clemson University  
Abstract: An extensible representation for object-oriented programs is presented. It is based on the concept of a program dependency graph and elaborated to include both control flow and data flow information. The representation takes advantage of the basic incremental philosophy of the object-oriented approach to develop a more compact representation that is useful with practical programs. The basic approach reported here provides a static view of an object-oriented program. The approach can be expanded to provide dynamic information for tools such as interactive debuggers and other runtime tools. The outline of this extension is also presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> The common object request broker: </editor> <title> Architecture and specification. </title> <type> Technical report, </type> <institution> Object Management Group and Open, </institution> <note> 1992. </note> <author> [2] iralal Agrawal and Joseph R. </author> <title> organ. Dynamic program slicing. </title> <booktitle> In roceedings o the I ' ymposium on rogramming anguage esign and Implementation, </booktitle> <pages> pages 246-256, </pages> <year> 1990. </year>
Reference: [3] <author> Korel B. </author> <title> The program dependence graph in static program testing. </title> <booktitle> In ormation rocessing etters, </booktitle> <volume> 24(2) </volume> <pages> 103-108, </pages> <month> Jan </month> <year> 1987. </year>
Reference-contexts: Control and data dependence information are used to select test data and determine test set adequacy <ref> [3] </ref>, and to extend data flow testing techniques [10]. Control and data dependence information are also used to generate reduced test sets for programs [11]. Several techniques for regression testing [5][15][22] use control and data dependence information to determine the retesting required after changes are made to a program.
Reference: [4] <author> Ryder B.G. </author> <title> Constructing the call graph of a program. </title> <journal> I ransactions on o tware ngineering, </journal> <volume> 5(3) </volume> <pages> 216-225, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: A call graph is an interprocedural program representation where nodes represent individual procedures and edges represent call sites. Each edge is labeled with the actual parameters associated with that call site. A program's call graph can be constructed e ciently <ref> [4] </ref> and used for many applications such as program maintenance and interprocedural data flow analysis. owever, the call graph is a flow-insensitive structure since it does not incorporate control flow information.
Reference: [5] <author> D. Binkley. </author> <title> Using semantic differencing to reduce the cost of regression testing. </title> <booktitle> In roceedings o the on erence on o tware aintenance ' , pages 41-50, </booktitle> <year> 1992. </year>
Reference: [6] <author> Callahan D. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In roceedings o I ' on . rogramming anguage esign and Implementation, </booktitle> <pages> pages 47-56, </pages> <note> 1988. </note> <author> [7] iralal Agrawal; Richard A. DeMillo and Eugene . Spafford. </author> <title> Dynamic slicing in the presence of unconstrained pointers. </title> <booktitle> In roceedings o the ourth ymposium on esting, nalysis and eri cation . I - , pages 60-73, </booktitle> <year> 1991. </year>
Reference-contexts: The OPDG is designed to handle interprocedural analysis and at the same time, represent the concepts of the object-oriented paradigm in a clear subtle way. The Unified Interprocedural Graph (UIG) [12] extracts the important information incorporated into previous representations: the call graph, SDG, the Program Summary Graph <ref> [6] </ref>, and the Interprocedural Flow Graph (IFG) [14]. Algorithms developed for the previous representations are adapted to develop the UIG.
Reference: [8] <author> David Duke and Roger Duke. </author> <title> Towards a semantics for object-z. </title> <booktitle> In ' : and , 1990. </booktitle>
Reference-contexts: There are several efforts underway to provide more specific representations for object-oriented programs. These efforts include the Interface Definition anguage (ID )[1] defined by the Object Management Group (OMG) and Object <ref> [8] </ref>. Object is an extension of the formal specification language that adds basic object-oriented concepts to the existing language. It can be used to develop program descriptions written in a mathematically manipulable format.
Reference: [9] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> he nnotated e erence anual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference: [10] <author> E. Duesterwald; R. Gupta and M. . Soffa. </author> <title> Rigorous data flow testing through output influences. </title> <booktitle> In roceedings o the nd Irvine o tware ymposium I ' , pages 131-145, </booktitle> <year> 1992. </year>
Reference-contexts: Control and data dependence information are used to select test data and determine test set adequacy [3], and to extend data flow testing techniques <ref> [10] </ref>. Control and data dependence information are also used to generate reduced test sets for programs [11]. Several techniques for regression testing [5][15][22] use control and data dependence information to determine the retesting required after changes are made to a program. The PDG has also proven useful for debugging purposes.
Reference: [11] <author> Rajiv Gupta and Mary ou Soffa. </author> <title> Automatic generation of a compact test suite. In roceedings o the wel th I I orld omputer ongress, </title> <year> 1992. </year>
Reference-contexts: Control and data dependence information are used to select test data and determine test set adequacy [3], and to extend data flow testing techniques [10]. Control and data dependence information are also used to generate reduced test sets for programs <ref> [11] </ref>. Several techniques for regression testing [5][15][22] use control and data dependence information to determine the retesting required after changes are made to a program. The PDG has also proven useful for debugging purposes. Both static [7][2] and dynamic [24] slicing techniques require control and data dependence information.
Reference: [12] <author> Mary Jean arrold and Brian Malloy. </author> <title> A unified interprocedural program representation for a maintenance environment. </title> <journal> I ransactions on o tware ngineering, </journal> <volume> 19(6) </volume> <pages> 584-593, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The SDG does not directly incorporate the important object-oriented concepts including inheritance, polymorphism and dynamic binding. The OPDG is designed to handle interprocedural analysis and at the same time, represent the concepts of the object-oriented paradigm in a clear subtle way. The Unified Interprocedural Graph (UIG) <ref> [12] </ref> extracts the important information incorporated into previous representations: the call graph, SDG, the Program Summary Graph [6], and the Interprocedural Flow Graph (IFG) [14]. Algorithms developed for the previous representations are adapted to develop the UIG.
Reference: [13] <author> Mary Jean arrold and John D. McGregor. </author> <title> ierarchical incremental testing. </title> <type> Technical Report TR91-111, </type> <institution> Department of Computer Science, Clemson University, </institution> <year> 1991. </year>
Reference-contexts: This is not a complete static representation since the implementations of the methods are not included; however, certain algorithms such as the ierarchical Incremental Testing ( IT) <ref> [13] </ref> procedure can provide useful information given this level of representation. * The second layer is the Control Dependence Subgraph (CDS), where a CDS for each method is included in this representation. Since this is a static representation, some information cannot be completely resolved.
Reference: [14] <author> Mary Jean arrold and Mary ou Soffa. </author> <title> Computation of interprocedural definition and use dependencies. </title> <booktitle> In roceedings o I omputer ociety 1 Int. on . on omput. anguages, ew rleans, </booktitle> , <pages> pages 297-306, </pages> <year> 1990. </year>
Reference-contexts: The Unified Interprocedural Graph (UIG) [12] extracts the important information incorporated into previous representations: the call graph, SDG, the Program Summary Graph [6], and the Interprocedural Flow Graph (IFG) <ref> [14] </ref>. Algorithms developed for the previous representations are adapted to develop the UIG.
Reference: [15] <author> Rajiv Gupta; Mary Jean arrold and Mary ou Soffa. </author> <title> An approach to regression testing using slicing. </title> <booktitle> In roceedings o the on erence on o tware aintenance ' , pages 299-308, </booktitle> <year> 1992. </year>
Reference: [16] <author> Ferrante J; Ottenstein K and Warren J.D. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ransactions on rogramming anguages and ystems, </journal> <volume> 9(3) </volume> <pages> 319-331, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: This dynamic binding of messages to methods supports the development of systems that are highly interactive, but the runtime binding does not allow static, compile time, resolution of messages between objects. 2.2 Program Dependency Graphs A program dependency graph (PDG) <ref> [16] </ref> is a graphical representation of a program that encodes both control dependencies and data dependencies into a single structure. The graph contains nodes that represent statements or regions of code, and edges that represent either control dependence or data dependence information. <p> Furthermore, the call graph does not express important object-oriented concepts such as inheritance, polymorphism and dynamic binding. The OPDG incorporates these important concepts into the PDG using the edges and vertices described in Figure 2 and discussed in section 3.3. The Program Dependence Graph (PDG) <ref> [16] </ref> has proven to be a valuable tool for program analysis since it encodes both control and data dependence information into a single representation. The PDG has been used for program optimization, parallelization, testing, static and dynamic slicing, debugging and browsing.
Reference: [17] <author> Tim Korson and John McGregor. </author> <title> Object-oriented software design: A tutorial. </title> <booktitle> ommunications o the , 33(9):40 | 60, </booktitle> <year> 1990. </year>
Reference-contexts: introduction here. Korson and McGregor <ref> [17] </ref> provide a survey of basic terms and concepts. We will briefly discuss the special characteristics of object technology that influenced our development of the representation. Classes and objects are central to the development of object-oriented software. <p> Consider the declarations: C is a c ass in a hierarch c1 and c are instance variab es C *c1; Both c1 and c have a static type of class . owever, c1 can have a different dynamic type <ref> [17] </ref>, if there are subclasses inheriting from , since c1 can be made to point to an instance of C or any of its subclasses. Whenever a message is sent to an object whose static type is the class , the all edge terminates at the lass header for .
Reference: [18] <author> Anand Krishnaswamy. </author> <title> Program slicing: An application of object-oriented program dependency graphs. </title> <type> Technical Report TR 94-108, </type> <institution> Clemson University, </institution> <year> 1994. </year>
Reference-contexts: Thus, OPDGs for class libraries can be created during the compilation stages for the library, saved and retrieved when required. Class reuse leads to reuse of the OPDG for that class too. An application of the OPDG, namely slicing object-oriented programs, is discussed in <ref> [18] </ref>. Related ork .1 ntra and nter Proced ral Program epresentations A sizable amount of work has been accomplished in the area of representing programs with single and multiple procedure bodies. A complete examination of the latter requires both inter and intraprocedural analyses.
Reference: [19] <author> Brian Malloy; John D. McGregor; Anand Krishnaswamy and Murali Medikonda. </author> <title> An extensible program representation for object-oriented software. </title> <type> Technical Report TR 94-109, </type> <institution> Clemson University, </institution> <year> 1994. </year>
Reference-contexts: Data flow and control flow are depicted between the statements in the methods. arious Instantiation and olymorphic all edges, if any, are recognized and represented. In the OPDG for the example system <ref> [19] </ref>, as shown in figure 9, the different all edges to methods (Simple, Polymorphic or Instantiation) are directed to the lass headers.
Reference: [20] <author> Panos E. ivadas and Stephen Croll. </author> <title> Program slicing. </title> <type> Technical Report SERC-TR-61-F, </type> <institution> University of Florida, Gainesville, </institution> <year> 1992. </year>
Reference-contexts: The main concern in performing interprocedural analysis, is that of handling parameters and preserving the calling context. Parameters are handled with additional edges and vertices in the SDG and in the UIG. orwitz et al present an algorithm in [26] using linkage grammars. ivadas and Scroll <ref> [20] </ref> present an alternate method to calculate the calling context, based on the call order in the program. The OPDG builds on the work presented in [20] and incorporates information into the lass header to save the calling context of the calls. <p> edges and vertices in the SDG and in the UIG. orwitz et al present an algorithm in [26] using linkage grammars. ivadas and Scroll <ref> [20] </ref> present an alternate method to calculate the calling context, based on the call order in the program. The OPDG builds on the work presented in [20] and incorporates information into the lass header to save the calling context of the calls. Parameters are handled by redefining the all edge to engulf the control and data flow between the call site and the called method procedure.
Reference: [21] <author> Mary Jean arrold; Brian Malloy and Gregg Rothermel. </author> <title> E cient construction of program dependence graphs. </title> <booktitle> International ymposium on o tware esting and nalysis, </booktitle> <volume> 18(3) </volume> <pages> 160-70, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The part of the PDG that represents control dependence information is the control dependence subgraph (CDS) and the part that represents data dependence information is the data dependence subgraph (DDS). For the purpose of this work, we use the extended version of the PDG <ref> [21] </ref>, that incorporates control flow information, as well as control dependence (CDS) and data dependence (DDS). <p> S8: P5,C5: div++; if (flag) cout &lt;< n; n++; P9,C9: S11: 1R S3 S4 P9 C5 P5 C9 R6 S11 R8 T T S7 1R S3 S4 P9 C5 P5 C9 R6 S11 R8 CDS accepts an abstract syntax tree for a procedure P and outputs the CDS for P <ref> [21] </ref>. Figure 1 depicts a program segment and the corresponding CDS and DDS for this program segment. A CDS contains several types of nodes. In figure 1, nodes such as S1, S3 and S4, represent statements in the program. <p> Information regarding the data members of the class are also available in the lass header. - ethod Procedure A ethod or a rocedure header indicates the entry vertex for the corresponding method or procedure. Its representation is similar to the entry vertex of a procedure as given in <ref> [21] </ref> or [26]. The ethod header adds additional meaning to the representation by encapsulating information such as the class to which it belongs, data attributes of the class and 3 Although some object-oriented languages allow public data members, good object-oriented design does not proliferate public data members in a class. <p> A brief description for each type of edge is given below. * ontrol dges low dges These are uni-directional edges that depict the explicit flow of control in the program. Implicit flow is denoted using the left-to-right notation of <ref> [21] </ref>. In figure 4, for the example code segment given, implicit flow of control is represented between the statements , 1 and using the left-to-right notation. A few instances of explicit control flow are return to the beginning o a while-loop, an exit or a brea statement and an exception. <p> The PDG has been used for program optimization, parallelization, testing, static and dynamic slicing, debugging and browsing. The PDG has been extended to incorporate control flow information <ref> [21] </ref>, expanding the viable applications of the PDG. owever, even with this extension, the PDG does not permit interprocedural analysis and therefore does not permit analysis across procedure boundaries. Furthermore, the PDG does not possess the expressiveness to represent such important object-oriented concepts as inheritance, polymorphism and dynamic binding.
Reference: [22] <author> Gregg Rothermel and Mary Jean arrold. </author> <title> A safe, e cient algorithm for regression test selection. </title> <booktitle> In roceedings o the on erence on o tware aintenance ' , pages 358-367, </booktitle> <year> 1993. </year>
Reference: [23] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William orensen. b ect-riented odeling and esign. </author> <title> Prentice- all, </title> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The resulting representation of an object-oriented program is more compact and easier to understand. .2 Other epresentations or Object-Oriented o t are Object-oriented analysis and design methods use a number of models with accompanying graphical notations. For example, Rumbaugh et al <ref> [23] </ref> uses three different models, each with its own notation, to represent the software system. These models are at a higher level than the code and do not have su cient detail to support our goals for this representation.
Reference: [24] <author> E. Schatz and B.G. Ryder. </author> <title> Directed tracing to detect race conditions. </title> <type> Technical Report CSR-TR-176, </type> <institution> aboratory for Computer Science Research, Rutgers University, </institution> <year> 1992. </year>
Reference-contexts: Several techniques for regression testing [5][15][22] use control and data dependence information to determine the retesting required after changes are made to a program. The PDG has also proven useful for debugging purposes. Both static [7][2] and dynamic <ref> [24] </ref> slicing techniques require control and data dependence information. Since the region nodes in a PDG summarize control dependence information for all of those statements in the region, the PDG is useful for parallelization of a program.

References-found: 22

