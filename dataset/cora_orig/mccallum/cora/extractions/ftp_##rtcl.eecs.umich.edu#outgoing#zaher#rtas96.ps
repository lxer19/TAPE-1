URL: ftp://rtcl.eecs.umich.edu/outgoing/zaher/rtas96.ps
Refering-URL: http://www.eecs.umich.edu/~zaher/publications.html
Root-URL: http://www.cs.umich.edu
Email: fzaher, ashaikh, farnam, kgshing@eecs.umich.edu  
Title: RTCAST: Lightweight Multicast for Real-Time Process Groups  
Author: Tarek Abdelzaher, Anees Shaikh, Farnam Jahanian, and Kang Shin 
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Real-time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: We propose a lightweight fault-tolerant multicast and membership service for real-time process groups which may exchange periodic and aperiodic messages. The service supports bounded-time message transport, atomicity, and order for multicasts within a group of communicating processes in the presence of processor crashes and communication failures. It guarantees agreement on membership among the communicating processors, and ensures that membership changes (e.g., resulting from processor joins or departures) are atomic and ordered with respect to multicast messages. We provide the flexibility of an event-triggered approach with the fast message delivery time of time-triggered protocols, such as TTP [14], where messages are delivered to the application immediately upon reception. This is achieved without compromising agreement, order and atom-icity properties. In addition to the design and details of the algorithm, we describe our implementation of the protocol using the x-Kernel protocol architecture running on RT Mach 3.0. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Abdelzaher, A. Shaikh, F. Jahanian, and K. Shin. RT-CAST: </author> <title> Lightweight multicast for real-time process groups. </title> <type> Technical Report CSE-TR-291-96, </type> <institution> Dept. of Elec. Engineering and Comp. Science, University of Michigan, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Membership changes are communicated exclusively by membership change messages using our multicast mechanism. Since message multicast is atomic and ordered, so are the membership changes. This guarantees agreement on membership view. Order, atomicity and agreement are proven more formally in <ref> [1] </ref>. Section 4.1 presents the steady state operation of the algorithm (with no receive omissions, processor crashes or membership changes). Section 4.2 then describes how receive omissions are detected and handled. Section 4.3 describes processor crashes and member elimination. <p> The proof of the theorem is detailed in <ref> [1] </ref>. Theorem 1 A set of messages G presented by node N j is schedulable if P C i T j , where n i = b (d i 4)/P c. <p> It was verified that all messages guaranteed by ACSA made it to all destinations by their respective deadlines, unless the destination crashed. The messages themselves, in all experiments, were generated synthetically. More details regarding performance evaluation are reported in <ref> [1] </ref>. 7. Conclusions In this paper we presented RTCast, a new multicast and membership protocol to support fault-tolerant real-time applications. Our approach follows the process group paradigm in which a group of cooperating processes performs application tasks.
Reference: [2] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In Proc. 6th International Workshop on Distributed Algorithms, number 647 in Lecture Notes in Computer Science, </booktitle> <pages> pages 292-312, </pages> <address> Haifa, Israel, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Examples of this approach are found in the Strong Group Mem bership protocol [13] and the MGS protocol for processor group membership [21]. Additional work on group membership protocols appears in <ref> [2, 10, 20] </ref>. Common to the above mentioned protocols whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real-time applications. Thus these techniques are not suitable for the applications in which we are interested.
Reference: [3] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A communication sub-system for high availability. </title> <type> Technical Report TR CS91-13, </type> <institution> Dept. of Computer Science, Hebrew University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [6, 3, 24, 17] </ref> and synchronous [14, 4, 11] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [17], Transis <ref> [3] </ref>, and Horus [24]. A number of systems choose to separate the group membership service from the fault-tolerant multicast service. As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available.
Reference: [4] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agarwal, and P. Cia-rfella. </author> <title> The Totem single-ring ordering and membership protocol. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(4) </volume> <pages> 311-342, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [6, 3, 24, 17] and synchronous <ref> [14, 4, 11] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> Thus these techniques are not suitable for the applications in which we are interested. There are, however, several protocols that integrate reliable multicast and group membership and also target real-time applications. Totem <ref> [4, 18] </ref> is an example of a protocol that provides probabilistic real-time guarantees. It is based on a token ring, and guarantees atomic ordered delivery of messages within two token rounds (in the absence of message loss). RTCast, on the other hand, achieves atomicity and order within a single round.
Reference: [5] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Failure of the token site will delay message reception even if both the source and destination are operational. In contrast, RTCast does not acknowledge each message, and need not involve an intermediate node on the path of each message. ISIS <ref> [5, 6] </ref> introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure.
Reference: [6] <author> K. P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12) </volume> <pages> 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [6, 3, 24, 17] </ref> and synchronous [14, 4, 11] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> Failure of the token site will delay message reception even if both the source and destination are operational. In contrast, RTCast does not acknowledge each message, and need not involve an intermediate node on the path of each message. ISIS <ref> [5, 6] </ref> introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure.
Reference: [7] <author> J.-M. Chang and N. Maxemchuk. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Section 7 concludes the paper by discussing the limitations of this work and future research directions. 2. Related work Several fault-tolerant, atomic ordered multicast and membership protocols have been proposed for use in asynchronous distributed systems. In some of the earliest work, Chang and Maxemchuk <ref> [7] </ref> proposed a token based algorithm for a process group where each member sends its messages to a token site which orders the messages and broadcasts acknowledgments. Destinations use the acknowledgments to order messages as specified by the token site.
Reference: [8] <author> B. Chen, S. Kamat, and W. Zhao. </author> <title> Fault-tolerant real-time communication in fddi-based networks. </title> <booktitle> In Proc. 16th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 141-150, </pages> <address> Pisa, Italy, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Finally, a research effort complementary to ours is re ported in <ref> [8] </ref>. While we consider fault tolerance with respect to processor failure, we do not suggest a mechanism for implementing fault-tolerant message communication. For example, we do not specify whether or not redundancy is used to tolerate link failures. <p> Permanent link failures (resulting in network partitions) are not considered. We believe that the proper way to handle permanent link failures in fault-tolerant real-time systems is to employ hardware redundancy, for example, as in TTP [14] or suggested in <ref> [8] </ref>. 4. Multicast and membership service Our primary purpose is to provide a fault-tolerant atomic ordered multicast service for distributed real-time systems that achieves agreement on replicated state. In a token ring, sent messages have a natural order defined by token rotation.
Reference: [9] <author> F. Cristian. </author> <title> Probabilistic clock synchronization. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 146-158, </pages> <year> 1989. </year>
Reference-contexts: We presently circumvent this problem by preventing simultaneous joins. membership service described in Section 4. The Retransmission layer is responsible for handling retransmissions as described in Section 4.6. ClockSync provides a synchronization service using the probabilistic algorithm developed by Cristian <ref> [9] </ref>. It uses the underlying unreliable messaging service provided in the x-Kernel environment. In soft real-time systems, non real-time systems, or systems where hard real-time communication has been prescheduled and guaranteed a priori, we may wish to omit the ACSA layer, in which case the application interfaces directly to RTCast.
Reference: [10] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: Examples of this approach are found in the Strong Group Mem bership protocol [13] and the MGS protocol for processor group membership [21]. Additional work on group membership protocols appears in <ref> [2, 10, 20] </ref>. Common to the above mentioned protocols whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real-time applications. Thus these techniques are not suitable for the applications in which we are interested.
Reference: [11] <author> F. Cristian, B. Dancy, and J. Dehn. </author> <title> Fault-tolerance in the advanced automation system. </title> <booktitle> In Proc. of Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 6-17, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [6, 3, 24, 17] and synchronous <ref> [14, 4, 11] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application.
Reference: [12] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan-uary </month> <year> 1991. </year>
Reference-contexts: Each machine on the private LAN runs the CMU Real-Time Mach 3.0 operating system and all machines are members of a single logical ring. Figure 6 illustrates the testbed. 6.1. Protocol stack layers We implement the communication service as a protocol developed in the x-Kernel 3.2 protocol implementation environment <ref> [12] </ref>. The protocol stack is shown in Figure 7. Each box represents a separate protocol layer. The primary advantage of using x-Kernel is the ability to easily reconfigure the protocol stack according to application needs by adding or removing corresponding protocols.
Reference: [13] <author> F. Jahanian, S. Fakhouri, and R. Rajkumar. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design, and implementation. In Proc. 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <year> 1993. </year>
Reference-contexts: As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available. Examples of this approach are found in the Strong Group Mem bership protocol <ref> [13] </ref> and the MGS protocol for processor group membership [21]. Additional work on group membership protocols appears in [2, 10, 20]. Common to the above mentioned protocols whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real-time applications.
Reference: [14] <author> H. Kopetz and G. Grunsteidl. </author> <title> TTP a protocol for fault-tolerant real-time systems. </title> <journal> IEEE Computer, </journal> <volume> 27(1) </volume> <pages> 14-23, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [6, 3, 24, 17] and synchronous <ref> [14, 4, 11] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> The abstraction hides a portable, analyzable, scalable and efficient mechanism for group communication. It does not, however, attempt to guarantee atomicity and order in the presence of failures, which may compromise consistency. TTP <ref> [14] </ref> is similar to RTCast in many respects. It uses a time-triggered scheme to provide predictable immediate message delivery, membership service, and redundancy management in fault-tolerant real-time systems. <p> Permanent link failures (resulting in network partitions) are not considered. We believe that the proper way to handle permanent link failures in fault-tolerant real-time systems is to employ hardware redundancy, for example, as in TTP <ref> [14] </ref> or suggested in [8]. 4. Multicast and membership service Our primary purpose is to provide a fault-tolerant atomic ordered multicast service for distributed real-time systems that achieves agreement on replicated state. In a token ring, sent messages have a natural order defined by token rotation.
Reference: [15] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: ISIS [5, 6] introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure. ISIS implements an atomic ordered multicast on top of a vector clock-based <ref> [15] </ref> causal multicast service, using an idea similar to that of Chang and Maxemchuk. We integrate membership and multicast services, but implement ordered atomic multicast directly without constructing a partial order first. The ordering task, however, is simplified by assuming a ring network. <p> A possible decision then is to assume that all of them have crashed and eliminate them from group membership (by multicasting a corresponding membership change 4 This is different from using vector clocks <ref> [15] </ref>; here, messages carry only their sequence number and sender id. 5 We know who the sender is because we know from whom a message is missing message).
Reference: [16] <author> N. Malcolm, S. Kamat, and W. Zhao. </author> <title> Real-time communication in FDDI networks. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 10(1) </volume> <pages> 75-107, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: For example, instead of the schedulability condition stated in Theorem 1, one may use the generalized rate monotonic analysis [22], FDDI synchronous bandwidth allocation analysis <ref> [16] </ref>, or delay analysis for Controller Area Networks [23], depending on the application at hand. 6. Implementation The protocol presented in Section 4 is implemented on a network of Intel Pentium R fl -based PCs connected over a private Ethernet.
Reference: [17] <author> S. Mishra, L. Peterson, and R. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed Systems Engineering Journal, </journal> <volume> 1(2) </volume> <pages> 87-103, </pages> <month> De-cember </month> <year> 1993. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [6, 3, 24, 17] </ref> and synchronous [14, 4, 11] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul <ref> [17] </ref>, Transis [3], and Horus [24]. A number of systems choose to separate the group membership service from the fault-tolerant multicast service. As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available.
Reference: [18] <author> L. Moser and P. Melliar-Smith. </author> <title> Probabalistic bounds on message delivery for the totem single-ring protocol. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 238-248, </pages> <year> 1994. </year>
Reference-contexts: Thus these techniques are not suitable for the applications in which we are interested. There are, however, several protocols that integrate reliable multicast and group membership and also target real-time applications. Totem <ref> [4, 18] </ref> is an example of a protocol that provides probabilistic real-time guarantees. It is based on a token ring, and guarantees atomic ordered delivery of messages within two token rounds (in the absence of message loss). RTCast, on the other hand, achieves atomicity and order within a single round.
Reference: [19] <author> R. Rajkumar, M. Gagliardi, and L. Sha. </author> <title> The real-time publisher/subscriber inter-process communication model for distributed real-time systems: </title> <booktitle> Design and implementation. In Proc. Real Time Technology and Applications Symposium, </booktitle> <pages> pages 66-75, </pages> <address> Chicago, IL, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The intuitive reason why immediate delivery does not interfere with atomicity in RTCast is that processors failing to receive a message take themselves out of the group. Rajkumar et. al. <ref> [19] </ref> present an elegant publisher/subscriber model for distributed real-time systems. It provides a simple user interface for publishing messages on a logical channel, and for subscribing to selected channels as needed by each application.
Reference: [20] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Process membership in asynchronous environments. </title> <type> Technical Report TR93-1328, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Examples of this approach are found in the Strong Group Mem bership protocol [13] and the MGS protocol for processor group membership [21]. Additional work on group membership protocols appears in <ref> [2, 10, 20] </ref>. Common to the above mentioned protocols whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real-time applications. Thus these techniques are not suitable for the applications in which we are interested.
Reference: [21] <author> L. Rodrigues, P. Ver issimo, and J. Rufino. </author> <title> A low-level processor group membership protocol for LANs. </title> <booktitle> In Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <pages> pages 541-550, </pages> <year> 1993. </year>
Reference-contexts: As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available. Examples of this approach are found in the Strong Group Mem bership protocol [13] and the MGS protocol for processor group membership <ref> [21] </ref>. Additional work on group membership protocols appears in [2, 10, 20]. Common to the above mentioned protocols whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real-time applications.
Reference: [22] <author> L. Sha, R. Rajkumar, and S. S. Sathaye. </author> <title> Generalized rate monotonic scheduling theory: A framework for developing real-time systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 82(1) </volume> <pages> 68-82, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The goal of this separation is to allow use of a number of admission control policies to ensure timeliness while leaving consistency to the multicast algorithm. For example, instead of the schedulability condition stated in Theorem 1, one may use the generalized rate monotonic analysis <ref> [22] </ref>, FDDI synchronous bandwidth allocation analysis [16], or delay analysis for Controller Area Networks [23], depending on the application at hand. 6. Implementation The protocol presented in Section 4 is implemented on a network of Intel Pentium R fl -based PCs connected over a private Ethernet.
Reference: [23] <author> K. Tindell, A. Burns, and A. J. Wellings. </author> <title> Calculating controller area network (CAN) message response times. </title> <journal> Control Engineering Practice, </journal> <volume> 3(8) </volume> <pages> 1163-1169, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: For example, instead of the schedulability condition stated in Theorem 1, one may use the generalized rate monotonic analysis [22], FDDI synchronous bandwidth allocation analysis [16], or delay analysis for Controller Area Networks <ref> [23] </ref>, depending on the application at hand. 6. Implementation The protocol presented in Section 4 is implemented on a network of Intel Pentium R fl -based PCs connected over a private Ethernet.
Reference: [24] <author> R. van Renesse, T. Hickey, and K. Birman. </author> <title> Design and performance of Horus: A lightweight group communications system. </title> <type> Technical Report TR94-1442, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: 1. Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous <ref> [6, 3, 24, 17] </ref> and synchronous [14, 4, 11] environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. <p> The ordering task, however, is simplified by assuming a ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [17], Transis [3], and Horus <ref> [24] </ref>. A number of systems choose to separate the group membership service from the fault-tolerant multicast service. As a result, the group membership service maintains consistency regarding the membership view and may assume that separate reliable atomic multicast support is available.
References-found: 24

