URL: http://www.cs.nmsu.edu/~epontell/ilps97/1.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/ilps97/programme.html
Root-URL: http://www.cs.nmsu.edu
Email: kish@cs.man.ac.uk  
Title: A New Implementation Scheme for Combining And/Or Parallelism  
Author: Kish Shen 
Address: Manchester M13 9PL U.K.  
Affiliation: Department of Computer Science University of Manchester  
Abstract: This paper presents the Fire model, an implementation scheme of the or-under-and, no reusage execution scheme for and/or parallelism in Prolog. Unlike previous schemes, the Fire model does not contain any private storage for the alternative bindings. Instead, the bindings are stored in data-structures associated with the search-space, and is accessible by all. The advantage is that task-switching and scheduling, one of the major area of complexities with previous schemes, becomes simple and constant time. Another property of the Fire model is that when either and- or or-parallelism alone is exploited, there are little extra overheads when compared to schemes which exploits only one of these forms of parallelism. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. A. M. Ali and R. Karlsson. </author> <title> Full Prolog and Scheduling Or-Parallelism in Muse. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 19(6) </volume> <pages> 445-475, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Although many of the early proposals exploited both forms of parallelism (e.g.[9, 20, 36, 11, 15]), many of the more recent schemes, especially those that have been successfully implemented, have tended to concentrate on either and- or or- parallelism (e.g. <ref> [21, 1, 18, 5, 28] </ref>), probably because of the complexities and difficulties in efficiently implementing both forms of parallelism together.
Reference: [2] <author> K. A. M. Ali and R. Karlsson. </author> <title> The Muse Approach to Or-Parallel Prolog. </title> <type> Technical Report SICS/R-90/R9009, </type> <institution> Swedish Institute of Computer Science, </institution> <year> 1990. </year>
Reference-contexts: Andorra-I [25], PBA [16], SBA [24]), or on the Muse model <ref> [2] </ref> (e.g. ACE [12]).
Reference: [3] <author> U. C. Baron, J. Chassin de Kergommeaux, M. Hailperin, M. Ratcliffe, P. Robert, J.-C. Syre, and H. Westphal. </author> <title> The Parallel ECRC Prolog System PEPSys: An Overview and Evaluation Results. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1988, </booktitle> <volume> Volume 3, </volume> <pages> pages 841-850, </pages> <year> 1988. </year>
Reference-contexts: This is expensive and requires rather complex synchronisations. In addition, if the system provides the option of selective or-parallelism, then solution combining becomes even more difficult, as in PEPSys <ref> [3] </ref>. <p> As mentioned, a scheme to handle IAP via reusage of and-goals was proposed for PEPSys <ref> [3] </ref>. Because this implementation scheme is based on reusage, it is fundamentally different from the Fire model. The various or-parallel solutions to and-goals are combined to give the cross-product via data-structures called join-cells. These join-cells are also used to connect the binding areas. <p> join-cells can only handle two and-goals, and no description was given on how a CGE containing more than two and-goals would be handled (presumably via some form of multiple join-cells); also no description of how the ages (OBL) are to be handled across the different BAs (hash-windows) were given in <ref> [3] </ref>.
Reference: [4] <author> A. J. Beaumont and D. H. D. Warren. </author> <title> Scheduling Speculative Work on Or-parallel Prolog Systems. </title> <booktitle> In Logic Programming: Proceedings of the Tenth International Conference, </booktitle> <pages> pages 135-149. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: separate issues from the fundamental scheduling problem (and may indeed require more than the selection of the right work to deal with them, as for example the most effective means of dealing with or-speculativeness to date in or-parallelism is to suspend speculative work and moving to less a speculative one <ref> [4] </ref>). These issues are generally best dealt with later when there is an implementation to experiment with.
Reference: [5] <author> J. Bevemyr, T. Lindgren, and H. Millroth. </author> <title> Reform Prolog: the Language and its Implementation. </title> <booktitle> In Logic Programming: Proceedings of the Tenth International Conference. </booktitle> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Although many of the early proposals exploited both forms of parallelism (e.g.[9, 20, 36, 11, 15]), many of the more recent schemes, especially those that have been successfully implemented, have tended to concentrate on either and- or or- parallelism (e.g. <ref> [21, 1, 18, 5, 28] </ref>), probably because of the complexities and difficulties in efficiently implementing both forms of parallelism together.
Reference: [6] <author> R. Butler, E. L. Lusk, R. Olson, and R. A. Overbeek. ANLWAM: </author> <title> A Parallel Implementation of the Warren Abstract Machine. </title> <type> Internal report, </type> <institution> Argonne National Laboratory, U.S.A, </institution> <year> 1986. </year>
Reference-contexts: Another approach to dealing with the or-parallel binding problem is to associate the alternative bindings with the search-tree. In fact, some of the earliest proposals to deal with or-parallel bindings use this approach (e.g. <ref> [6, 8] </ref>).
Reference: [7] <author> J. Chassin de Kergommeaux. </author> <title> Measures of the PEPSys Implementation on the MX500. </title> <type> Technical Report CA-44, </type> <institution> European Computer-Industry Research Centre, </institution> <address> Arabellaastr. 17, D-8000 Munchen 81, Germany, </address> <year> 1989. </year>
Reference-contexts: In fact, a simulation study [31] showed that even for a favourable program like N-queens, where there is extremely high potential parallelism and large granularity, the overhead for task switching can be very significant and have an impact on the speedup. Performance data obtained from PEPSys <ref> [7] </ref> and Aurora [33] shows that Aurora gives somewhat better performances, but the margin is not sufficient to conclusively show that the SRI model is inherently better than the PEPSys' binding scheme. <p> The cost for being able to task-switch in constant time is that access to some variable bindings may be non-constant time. Measurements with PEPSys suggested that there are relatively few of these bindings, and that the lookup usually do not involve accessing many BAs <ref> [7] </ref>. 6 Or more precisely, the CMOS or-parallel binding model developed independently by the author, but which was not published because it proved to be very similar to the published PEPSys model. 7 For example, it might be implemented as a sparse array, using similar techniques to SBA (Sparce Binding Array)
Reference: [8] <author> J. Chassin de Kergommeaux, P. Robert, and H. Westphal. </author> <title> An Abstract Machine for the Implementation of the PEPSys Model. </title> <type> Technical Report CA-26, </type> <institution> European Computer-Industry Research Centre, </institution> <year> 1987. </year>
Reference-contexts: Another approach to dealing with the or-parallel binding problem is to associate the alternative bindings with the search-tree. In fact, some of the earliest proposals to deal with or-parallel bindings use this approach (e.g. <ref> [6, 8] </ref>). <p> for handling or-parallelism in the Fire model because it appears to be the most efficient scheme which stores alternative bindings into the search-tree. 3.1 The PEPSys or-parallel binding model For completeness, a very brief description of the PEPSys or-parallel binding model will be given here; the reader is referred to <ref> [8] </ref> for more details. Note that only the or-parallel binding scheme of PEPSys is used for the Fire model.
Reference: [9] <author> J. S. Conery. </author> <title> The AND/OR Process Model for Parallel Interpretation of Logic Programs. </title> <type> PhD thesis, </type> <institution> University of California at Irvine, </institution> <year> 1983. </year> <note> Available as technical report 204. </note>
Reference-contexts: One way round this problem is to exploit both forms of parallelism, but place restrictions on where a particular form of parallelism could be exploited; examples of this approach include Con-ery's AND/OR process model <ref> [9] </ref>, Fagin's PPP model [11], the no or-under-and scheme studied in my simulation 1 The high-level execution scheme can be readily extended to cover DAP, but depending on the actual implementation scheme, extending the scheme to efficiently implement DAP can be more difficult. 1 study [29], and Andorra-I [25]. <p> Proposals which exploit only one form of parallelism, in which not everything is available simultaneously, have naturally followed sequential Prolog and did not reuse independent goals, and indeed even some of the early proposals to combine the two forms of parallelism (e.g. <ref> [9, 11] </ref>) did not have reusage, due to the severe restrictions on how and- and or-parallelism can be combined (and thus what would be available simultaneously).
Reference: [10] <author> I. Dutra. </author> <title> Strategies for Scheduling And and Or Work in Parallel Logic Programming Systems. </title> <booktitle> In Logic Programming: Proceedings of 1994 Internation Symposium. </booktitle> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: This may limit the amount of parallelism exploited, especially if workers are fixed within a particular team, as is the case in many of the initial implementations of these models. An extra scheduler which partially overcomes this restriction by moving workers around teams was developed for Andorra-I <ref> [10] </ref>, but this imposes extra overheads (especially in terms of memory usage 4 ), and does not totally overcome the problem, because this is an extra layer of scheduling (which in itself adds further complications), and will only kick in when it is somehow decided (probably via some heuristics) that a
Reference: [11] <author> B. S. Fagin. </author> <title> A Parallel Execution Model for Prolog. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: One way round this problem is to exploit both forms of parallelism, but place restrictions on where a particular form of parallelism could be exploited; examples of this approach include Con-ery's AND/OR process model [9], Fagin's PPP model <ref> [11] </ref>, the no or-under-and scheme studied in my simulation 1 The high-level execution scheme can be readily extended to cover DAP, but depending on the actual implementation scheme, extending the scheme to efficiently implement DAP can be more difficult. 1 study [29], and Andorra-I [25]. <p> Proposals which exploit only one form of parallelism, in which not everything is available simultaneously, have naturally followed sequential Prolog and did not reuse independent goals, and indeed even some of the early proposals to combine the two forms of parallelism (e.g. <ref> [9, 11] </ref>) did not have reusage, due to the severe restrictions on how and- and or-parallelism can be combined (and thus what would be available simultaneously).
Reference: [12] <author> G. Gupta and M. V. Hermenegildo. </author> <title> ACE: And/Or-parallel Copying-based Execution of Logic Programs. </title> <booktitle> In Proceedings of ICLP'91 Workshop on Parallel Execution, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Andorra-I [25], PBA [16], SBA [24]), or on the Muse model [2] (e.g. ACE <ref> [12] </ref>).
Reference: [13] <author> G. Gupta and M. V. Hermenegildo. </author> <title> Recomputation based Implementation of And-Or Parallel Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <volume> Volume 2, </volume> <pages> pages 770-782. </pages> <institution> Institute for New Generation Computing, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: ACE and PBA are the first two proposed implementation schemes of the or-under-and, no goal reusage approach <ref> [13] </ref>. <p> Its advantage is that it clearly relates both and- and or-parallelism to where they occur in the search-tree, making it obvious what needs to be computed and at what point. An alternative representation to the ANT is the C-tree proposed by Gupta <ref> [13] </ref>; it is not used here because it is less easy to relate it to the search-tree, and it is less obvious to determine when recomputation should take place by looking at the tree, although it does have the advantage of being able to represent and-parallelism in a clearer way that
Reference: [14] <author> G. Gupta, M. V. Hermenegildo, E. Pontelli, and V. Santos Costa. </author> <title> ACE: And/Or-parallel Copying-based Execution of Logic Programs. </title> <booktitle> In Logic Programming: Proceedings of the Eleventh Conference, </booktitle> <pages> pages 93-110. </pages> <publisher> The MIT Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: As such, the actual execution model is very similar to previous proposed implementation schemes of the same execution model, such as ACE <ref> [14] </ref> and PBA [16], except for whatever scheduling restrictions that are imposed in one implementation scheme or the other due to implementation considerations.
Reference: [15] <author> G. Gupta and B. Jayaraman. </author> <title> Combined And-Or Parallelism on Shared Memory Multiprocessors. </title> <editor> In E. L. Lusk and R. A. Overbeek, editors, </editor> <booktitle> Logic Programming: Proceedings of the North American Conference, 1989, </booktitle> <volume> Volume 1, </volume> <pages> pages 332-349. </pages> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: However, for all early schemes which did have sufficient freedom, reusage seemed so attractive that it was always included (e.g. <ref> [36, 20, 35, 15] </ref>). 3 As part of a study of IAP and or- parallelism [29], I studied goal reusage by comparing it with an alternative scheme which did not implement reusage.
Reference: [16] <author> G. Gupta, V. Santos Costa, and E. Pontelli. </author> <title> Shared Paged Binding Arrays: A Universal Data Structure for Parallel Logic Programming. </title> <booktitle> In Proceedings of the NSF/ICOT Workshop on Parallel Logic Programming and its Environments. </booktitle> <institution> University of Oregon, </institution> <year> 1994. </year>
Reference-contexts: Sibling and-nodes are and-nodes which occur in the same (complete or failing) and-thread. 3 The Fire Model In several previous work to combine and- and or-parallelism, the or-parallel part of the system was based either on the SRI-model [34] (e.g. Andorra-I [25], PBA <ref> [16] </ref>, SBA [24]), or on the Muse model [2] (e.g. ACE [12]). <p> As such, the actual execution model is very similar to previous proposed implementation schemes of the same execution model, such as ACE [14] and PBA <ref> [16] </ref>, except for whatever scheduling restrictions that are imposed in one implementation scheme or the other due to implementation considerations.
Reference: [17] <author> M. V. Hermenegildo. </author> <title> An Abstract Machine Based Execution Model for Computer Architecture Design and Efficient Implementation of Logic Programs in Parallel. </title> <type> PhD thesis, </type> <institution> The University of Texas At Austin, </institution> <year> 1986. </year>
Reference-contexts: The search will not terminate early because the BAs following it (B to G) all have greater starting ages. 3.4 Arrangement of Markers We shall assume that the Fire model will be using a marker-based distributed stack scheme <ref> [17, 30] </ref> for management of the stacks. With the introduction of or-parallelism, the parcall marker, at least as used in DASWAM, is not sufficient to manage the and-thread. In DASWAM, the parcall marker is used to co-ordinate the execution of goals in a CGE. <p> As for scheduling itself, the same mechanism as used in RAP-WAM <ref> [17] </ref> can be used here: work (both or-work and and-work) can be pushed onto work stacks associated with the workers (if desired, each worker can have separate and- and or- work stacks, to allow for more sophisticated scheduling). Other workers can then steal work from these stacks.
Reference: [18] <author> M. V. Hermenegildo and K. J. Green. </author> <title> &-Prolog and its Performance: Exploiting Independent And-Parallelism. </title> <editor> In D. H. D. Warren and P. Szeredi, editors, </editor> <booktitle> Logic Programming: Proceedings of the Seventh International Conference, </booktitle> <pages> pages 253-268. </pages> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Although many of the early proposals exploited both forms of parallelism (e.g.[9, 20, 36, 11, 15]), many of the more recent schemes, especially those that have been successfully implemented, have tended to concentrate on either and- or or- parallelism (e.g. <ref> [21, 1, 18, 5, 28] </ref>), probably because of the complexities and difficulties in efficiently implementing both forms of parallelism together. <p> And-fork This indicates the start of a new source of and-parallelism, which corresponds to the start of a CGE in execution models such as &-Prolog <ref> [18] </ref> and DDAS [27]. And-node This indicates the start of an actual and-task, i.e. an individual and-goal in a CGE in &-Prolog and DDAS. And-join This indicates the end of a source of and-parallelism, which corresponds to the end of a CGE.
Reference: [19] <author> S. Janson and S. Haridi. </author> <title> Programming Paradigms of the Andorra Kernel Language. </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Logic Programming: Proceedings of 1991 International Symposium, </booktitle> <pages> pages 167-183. </pages> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Another alternative to exploiting both and/or- parallelism together is to abandon Prolog, and do it in a different language from Prolog, and parallelism has to be programmed explicitly. Such an approach is taken with AKL <ref> [19] </ref>. While abandoning Prolog may have merits, especially if the aim is to design a language for concurrent programming, this is somewhat different from the aim of this research, which is to exploit parallelism in Prolog programs implicitly.
Reference: [20] <author> L. V. Kale. </author> <title> Parallel Architectures for Problem Solving. </title> <type> PhD thesis, </type> <institution> State University of New York at Stony Brook, </institution> <year> 1985. </year>
Reference-contexts: However, for all early schemes which did have sufficient freedom, reusage seemed so attractive that it was always included (e.g. <ref> [36, 20, 35, 15] </ref>). 3 As part of a study of IAP and or- parallelism [29], I studied goal reusage by comparing it with an alternative scheme which did not implement reusage.
Reference: [21] <author> E. L. Lusk, R. Butler, T. Disz, R. Olson, R. A. Overbeek, R. Stevens, D. H. D. Warren, A. Calderwood, P. Sz-eredi, S. Haridi, P. Brand, M. Carlsson, A. Ciepielewski, and B. Hausman. </author> <title> The Aurora Or-Parallel Prolog System. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1988, </booktitle> <volume> Vol. 3, </volume> <pages> pages 819-830. </pages> <institution> Institute for New Generation Computer Technology, </institution> <year> 1988. </year>
Reference-contexts: Although many of the early proposals exploited both forms of parallelism (e.g.[9, 20, 36, 11, 15]), many of the more recent schemes, especially those that have been successfully implemented, have tended to concentrate on either and- or or- parallelism (e.g. <ref> [21, 1, 18, 5, 28] </ref>), probably because of the complexities and difficulties in efficiently implementing both forms of parallelism together.
Reference: [22] <author> D. Michie. </author> <title> Memo Functions and Machine Learning. </title> <journal> Nature, </journal> <volume> 218 </volume> <pages> 19-22, </pages> <month> Apr. </month> <year> 1968. </year>
Reference-contexts: This idea of reusing the results of the same computation in different places in a program has its origins in the memo function <ref> [22] </ref>. The reusage of independent and-goals can be considered as a form of implicit memo function.
Reference: [23] <author> J. Montelius. </author> <title> Exploiting Fine-grain Parallelism in Concurrent Constraint Languages. </title> <type> PhD thesis, </type> <institution> Uppsala University, </institution> <year> 1997. </year>
Reference-contexts: While abandoning Prolog may have merits, especially if the aim is to design a language for concurrent programming, this is somewhat different from the aim of this research, which is to exploit parallelism in Prolog programs implicitly. In AKL, or-parallelism is achieved by copying, and in implementations of AKL <ref> [23] </ref>, this has been shown to cause or-parallel programs to run significantly slower. 5 Conclusion This paper outlined the Fire implementation model for combining and- and or-parallelism, which may have some advantages over existing models, because it simplifies task- switching, which is at the heart of much of the complexities associated
Reference: [24] <author> V. Santos Costa, M. E. Correia, and F. Silva. </author> <title> Performance of Sparse Binding Arrays for Or-Parallelism. </title> <booktitle> In Proceedings of the VIII SBAC-PAD, </booktitle> <year> 1996. </year>
Reference-contexts: However, the actual development of these schemes have uncovered some difficulties and complications, which have to some extent delayed the development of actual prototype systems; 2 in fact, PBA is no longer being developed, instead, an alternative to the PBA the SBA <ref> [24] </ref>, which should simplify some of the complexities associated with PBA, is now being developed. Probably because of the implementation difficulties, neither schemes appear to have reached a state of development where an efficient implementation is available. <p> Sibling and-nodes are and-nodes which occur in the same (complete or failing) and-thread. 3 The Fire Model In several previous work to combine and- and or-parallelism, the or-parallel part of the system was based either on the SRI-model [34] (e.g. Andorra-I [25], PBA [16], SBA <ref> [24] </ref>), or on the Muse model [2] (e.g. ACE [12]). <p> 6 Or more precisely, the CMOS or-parallel binding model developed independently by the author, but which was not published because it proved to be very similar to the published PEPSys model. 7 For example, it might be implemented as a sparse array, using similar techniques to SBA (Sparce Binding Array) <ref> [24] </ref>. 6 3.2 Extending PEPSys for and-parallelism in or-under-and scheme In the Fire model, the PEPSys or-parallel binding model is extended to cover and- parallelism.
Reference: [25] <author> V. Santos Costa, D. H. D. Warren, and R. Yang. </author> <title> The Andorra-I Engine: A Parallel Implementation of the Basic Andorra Model. </title> <booktitle> In Logic Programming: Proceedings of the Eighth International Conference, </booktitle> <pages> pages 825-839, </pages> <year> 1991. </year>
Reference-contexts: One system that has been relatively successful in exploiting both forms of parallelism is Andorra-I <ref> [25] </ref>, but the and-parallelism is limited to determinate goals only, with or- and and-parallelism exploited in distinct phases. <p> process model [9], Fagin's PPP model [11], the no or-under-and scheme studied in my simulation 1 The high-level execution scheme can be readily extended to cover DAP, but depending on the actual implementation scheme, extending the scheme to efficiently implement DAP can be more difficult. 1 study [29], and Andorra-I <ref> [25] </ref>. <p> Sibling and-nodes are and-nodes which occur in the same (complete or failing) and-thread. 3 The Fire Model In several previous work to combine and- and or-parallelism, the or-parallel part of the system was based either on the SRI-model [34] (e.g. Andorra-I <ref> [25] </ref>, PBA [16], SBA [24]), or on the Muse model [2] (e.g. ACE [12]).
Reference: [26] <author> K. Shen. </author> <title> An Overview of DASWAM An Implementation of DDAS. </title> <type> Technical Report CSTR-92-08, </type> <institution> Computer Science Department, University of Bristol, </institution> <year> 1992. </year>
Reference-contexts: Comparatively recently, various implementation schemes that exploits both forms of parallelism have been proposed ([13, 14, 16, 24]), which to a greater or lesser extent implements the high-level execution scheme or-under-and, no goal reusage used in a simulation study of and- and or-parallelism <ref> [26, 29, 31] </ref>. This scheme combined independent and-parallelism (IAP) with or-parallelism such that the and-goals are recomputed (or more accurately, separately computed); the scheme can be readily extended to cover dependent and-parallelism (DAP) 1 as proposed in the Prometheus scheme [26]. <p> This scheme combined independent and-parallelism (IAP) with or-parallelism such that the and-goals are recomputed (or more accurately, separately computed); the scheme can be readily extended to cover dependent and-parallelism (DAP) 1 as proposed in the Prometheus scheme <ref> [26] </ref>. The or-under-and scheme provides a more flexible framework for combining and- and or-parallelism than the Basic Andorra Model, because the two forms of parallelism need not be exploited in different phases. <p> Such schemes are able to simplify some of the implementation complexities asso-ciated with combining and- and or- parallelism, but the restrictions imposed can exclude significant sources of one or the other form of parallelism: for example, Andorra-I cannot exploit non-deterministic and-parallelism; <ref> [26] </ref> showed that no or-under-and can significantly restrict the exploitation of or-parallelism in some programs, and the restrictions imposed on the PPP scheme can also constrain the exploitation of parallelism when compared to the or-under-and. <p> In the rare cases where it might be useful, predicates such as bagof, setof, or some special new predicates (for efficiency) can be used to provide the functionality (see for example <ref> [26] </ref> for details). * An extra stage is needed to combine the reused goals to produce all the solutions. This is expensive and requires rather complex synchronisations. In addition, if the system provides the option of selective or-parallelism, then solution combining becomes even more difficult, as in PEPSys [3]. <p> An ANT also gives some indication of where parallelism may be exploited in this search-space. It is basically a Prolog search-tree with extra annotations to represent and indicate the parallelism. It was the basis for the data-structure used in the and/or parallel simulator <ref> [26] </ref>. Its advantage is that it clearly relates both and- and or-parallelism to where they occur in the search-tree, making it obvious what needs to be computed and at what point. <p> This is to ensure that any access to variables bound inside the and-thread would have a greater age than the binding. To observe the needed relationship, the following scheme for the ages, adapted from the handling of dependent variables' age in DASWAM <ref> [26] </ref> is used: the age is incremented each time an or-parallel node is created as in the or-parallel case and, in addition, each time an and-thread is started or completed - i.e. the age in a branch is incremented each time it encounters an and-fork.
Reference: [27] <author> K. Shen. </author> <title> Studies of And/Or Parallelism in Prolog. </title> <type> PhD thesis, </type> <institution> Computer Laboratory, University of Cam-bridge, </institution> <year> 1992. </year>
Reference-contexts: And-fork This indicates the start of a new source of and-parallelism, which corresponds to the start of a CGE in execution models such as &-Prolog [18] and DDAS <ref> [27] </ref>. And-node This indicates the start of an actual and-task, i.e. an individual and-goal in a CGE in &-Prolog and DDAS. And-join This indicates the end of a source of and-parallelism, which corresponds to the end of a CGE.
Reference: [28] <author> K. Shen. </author> <title> Initial Results from the Parallel Implementation of DASWAM. </title> <editor> In M. Maher, editor, </editor> <booktitle> Proceedings of the 1996 Joint International Conference and Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Although many of the early proposals exploited both forms of parallelism (e.g.[9, 20, 36, 11, 15]), many of the more recent schemes, especially those that have been successfully implemented, have tended to concentrate on either and- or or- parallelism (e.g. <ref> [21, 1, 18, 5, 28] </ref>), probably because of the complexities and difficulties in efficiently implementing both forms of parallelism together.
Reference: [29] <author> K. Shen and M. V. Hermenegildo. </author> <title> A Simulation Study of Or- and Independent And-parallelism. </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Logic Programming: Proceedings of 1991 International Symposium, </booktitle> <pages> pages 135-151. </pages> <publisher> The MIT Press, </publisher> <year> 1991. </year> <month> 16 </month>
Reference-contexts: Comparatively recently, various implementation schemes that exploits both forms of parallelism have been proposed ([13, 14, 16, 24]), which to a greater or lesser extent implements the high-level execution scheme or-under-and, no goal reusage used in a simulation study of and- and or-parallelism <ref> [26, 29, 31] </ref>. This scheme combined independent and-parallelism (IAP) with or-parallelism such that the and-goals are recomputed (or more accurately, separately computed); the scheme can be readily extended to cover dependent and-parallelism (DAP) 1 as proposed in the Prometheus scheme [26]. <p> include Con-ery's AND/OR process model [9], Fagin's PPP model [11], the no or-under-and scheme studied in my simulation 1 The high-level execution scheme can be readily extended to cover DAP, but depending on the actual implementation scheme, extending the scheme to efficiently implement DAP can be more difficult. 1 study <ref> [29] </ref>, and Andorra-I [25]. <p> However, for all early schemes which did have sufficient freedom, reusage seemed so attractive that it was always included (e.g. [36, 20, 35, 15]). 3 As part of a study of IAP and or- parallelism <ref> [29] </ref>, I studied goal reusage by comparing it with an alternative scheme which did not implement reusage. This involved the development of an execution scheme that allowed great freedom in how and- and or-parallelism can be combined, but which did not have reusage. <p> In fact, although fi can be started as soon as OPC1 is allocated, it seems useful in many situations to actually not execute fi until the remainder of the second and-arc, fl is finished. This was the execution model used in the simulator <ref> [29] </ref>, and the data from it indicated that this avoided much speculative work. <p> A study of the behaviour of and- and or-parallelism in Prolog programs <ref> [29, 31] </ref> suggests that there are many programs contain many or-branches inside CGEs of which only one lead to success, while the other branches are relatively short and fails.
Reference: [30] <author> K. Shen and M. V. Hermenegildo. </author> <title> Divided We Stand: Parallel Distributed Stack Memory Management. </title> <editor> In E. Tick and G. Succi, editors, </editor> <booktitle> Implementations of Logic Programming System, </booktitle> <pages> pages 185-201. </pages> <publisher> Kluwer, </publisher> <year> 1994. </year>
Reference-contexts: The search will not terminate early because the BAs following it (B to G) all have greater starting ages. 3.4 Arrangement of Markers We shall assume that the Fire model will be using a marker-based distributed stack scheme <ref> [17, 30] </ref> for management of the stacks. With the introduction of or-parallelism, the parcall marker, at least as used in DASWAM, is not sufficient to manage the and-thread. In DASWAM, the parcall marker is used to co-ordinate the execution of goals in a CGE.
Reference: [31] <author> K. Shen and M. V. Hermenegildo. </author> <title> High-level Characteristics of Or- and Independent And-parallelism in Prolog. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 24(5) </volume> <pages> 433-478, </pages> <year> 1996. </year>
Reference-contexts: Comparatively recently, various implementation schemes that exploits both forms of parallelism have been proposed ([13, 14, 16, 24]), which to a greater or lesser extent implements the high-level execution scheme or-under-and, no goal reusage used in a simulation study of and- and or-parallelism <ref> [26, 29, 31] </ref>. This scheme combined independent and-parallelism (IAP) with or-parallelism such that the and-goals are recomputed (or more accurately, separately computed); the scheme can be readily extended to cover dependent and-parallelism (DAP) 1 as proposed in the Prometheus scheme [26]. <p> In fact, a simulation study <ref> [31] </ref> showed that even for a favourable program like N-queens, where there is extremely high potential parallelism and large granularity, the overhead for task switching can be very significant and have an impact on the speedup. <p> A study of the behaviour of and- and or-parallelism in Prolog programs <ref> [29, 31] </ref> suggests that there are many programs contain many or-branches inside CGEs of which only one lead to success, while the other branches are relatively short and fails.
Reference: [32] <author> K. Shen and D. H. D. Warren. </author> <title> A Simulation Study of the Argonne Model for Or-Parallel Execution of Prolog. </title> <booktitle> In Proceedings of the Fourth Symposium on Logic Programming. </booktitle> <publisher> Computer Society Press of the IEEE, </publisher> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: The motivations for the various (non-speculative) schedulers for 11 Aurora and Muse was to allow the selection of good work because task-switching is non-constant time. With a constant time task switching, there is no longer any strong reason to prefer one or-goal over another, and the simulation study of <ref> [32] </ref> support this in that the selection strategy made only small differences to the speedups, even in the presence of constant-time overheads.
Reference: [33] <author> P. </author> <title> Szeredi. Performance Analysis of the Aurora Or-Parallel System. </title> <editor> In E. L. Lusk and R. A. Overbeek, editors, </editor> <booktitle> Logic Programming: Proceedings of the North American Conference, 1989, </booktitle> <volume> Volume 2, </volume> <pages> pages 713-732. </pages> <publisher> The MIT Press, </publisher> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: For example, in Aurora, significant overhead in task-switching is incurred, not because the number of bindings that need to be installed/disinstall which was originally expected to be the main cost of task-switching are great <ref> [33] </ref>, but probably because in order to allow a worker to install and disinstall bindings from the binding arrays, and in particular if extra information (such as locations of individual workers in the search-tree) are retained to allow a worker to move to a good location, a lot of extra overhead <p> In fact, a simulation study [31] showed that even for a favourable program like N-queens, where there is extremely high potential parallelism and large granularity, the overhead for task switching can be very significant and have an impact on the speedup. Performance data obtained from PEPSys [7] and Aurora <ref> [33] </ref> shows that Aurora gives somewhat better performances, but the margin is not sufficient to conclusively show that the SRI model is inherently better than the PEPSys' binding scheme.
Reference: [34] <author> D. H. D. Warren. </author> <title> The SRI Model for Or-Parallel Execution of Prolog Abstract Design and Implementation Issues. </title> <booktitle> In Proceedings 1987 Symposium on Logic Programming, </booktitle> <pages> pages 92-102. </pages> <publisher> Computer Society Press of the IEEE, </publisher> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Sibling and-nodes are and-nodes which occur in the same (complete or failing) and-thread. 3 The Fire Model In several previous work to combine and- and or-parallelism, the or-parallel part of the system was based either on the SRI-model <ref> [34] </ref> (e.g. Andorra-I [25], PBA [16], SBA [24]), or on the Muse model [2] (e.g. ACE [12]).
Reference: [35] <author> H. Westphal, P. Robert, J. Chassin de Kergommeaux, and J.-C. </author> <title> Syre. The PEPSys Model: Combining Backtracking AND- and OR-parallelism. </title> <booktitle> In Proceedings 1987 Symposium on Logic Programming, </booktitle> <pages> pages 436-448. </pages> <publisher> Computer Society Press of the IEEE, </publisher> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: However, for all early schemes which did have sufficient freedom, reusage seemed so attractive that it was always included (e.g. <ref> [36, 20, 35, 15] </ref>). 3 As part of a study of IAP and or- parallelism [29], I studied goal reusage by comparing it with an alternative scheme which did not implement reusage.
Reference: [36] <author> M. J. Wise. </author> <title> Prolog Multiprocessors. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year> <month> 17 </month>
Reference-contexts: However, for all early schemes which did have sufficient freedom, reusage seemed so attractive that it was always included (e.g. <ref> [36, 20, 35, 15] </ref>). 3 As part of a study of IAP and or- parallelism [29], I studied goal reusage by comparing it with an alternative scheme which did not implement reusage.
References-found: 36

