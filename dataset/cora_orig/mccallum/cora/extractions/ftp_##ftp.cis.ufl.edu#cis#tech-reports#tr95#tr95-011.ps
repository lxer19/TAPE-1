URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr95/tr95-011.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr95-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: An Optimal Algorithm for the Construction of the System Dependence Graph  
Author: Panos E. Livadas Theodore Johnson 
Address: Gainesville, FL 32611  
Affiliation: Computer and Information Sciences Department University of Florida  
Abstract: Program slicing can be used to aid in a variety of software maintenance activities including code understanding, code testing, debugging, and program reengineering. Program slicing (as well as other program analysis functions including forward slicing) can be efficiently performed on an internal program representation called a system dependence graph (SDG). The construction of the SDG depends primarily on the calculation of the transitive dependences which in turn depends in the calculation of the data dependences. In this paper we demonstrate the correctness and the optimality of our method of calculating the transitive data dependences. Furthermore, this method requires neither the (explicit) calculation of the GMOD and GREF sets nor the construction of a linkage grammar and the corresponding subordinate characteristic graphs of the linkage grammar's nonterminals. Additionally, a beneficial side effect of this method is that it provides us with a new method for performing interprocedural, flow-sensitive data flow analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho74] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> ``The Design and Analysis of Computer Algorithms'', </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference: [Aho86] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> ``Compilers: Principles, Techniques and Tools'', </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: We would like to note here that our method for determining control dependences is based on a syntax-directed method (hence we do not handle such constructs such as gotos). If another, more precise method was used (such as the one described in <ref> [Aho86] </ref>, there would be no need to include return-control edges in the SDG. The return-control edge indicates the dependence between the return statement of a procedure and other statements following the return statement which will not be executed when the program exits on a return statement.
Reference: [Bad88] <author> L. Badger and M. Weiser. </author> <title> ``Minimizing Communications for Synchronizing Parallel Dataflow Programs'', </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <publisher> Penn State University Press, </publisher> <address> PA. </address>
Reference-contexts: Dicing, a method based on static slicing, can be used to aid in debugging by allowing certain program bugs to be automatically located [Lyl87]. Horwitz [Hor88] has used the concepts of slicing in integrating program variants and Badger <ref> [Bad88] </ref> has demonstrated how slicing can be used for automatic paralleliza-tion. Furthermore, slicing also aids in code reusability.
Reference: [Ban79] <author> Banning, J.P. </author> <title> ``An Efficient Way to Find the Side Effects of Procedure Calls and the Aliases of Variables''. </title> <booktitle> In Conference Record of the Sixth ACM Symposium on Principles of Programming Languages (San Antonio, Tex., </booktitle> <address> Jan. 29-31,1979). </address> <publisher> ACM, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: In this case, the presence of its actual-out node could adversely affect the precision of an interprocedural slice. A method is described in [Hor90] to detect such a phenomena that is based on the calculation of the GMOD and GREF sets 14 (via the method proposed in <ref> [Ban79] </ref>) for each procedure F k .
Reference: [Boe75] <author> B.W. Boehm. </author> <title> ``The High Cost of Software, Practical Strategies for Developing Large Software Systems'', </title> <editor> E. Horowitz (ed.). </editor> <address> Reading, Mass: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: 1. Introduction Software maintenance is an expensive, demanding, and ongoing process. Lientz and Swanson [Lie80] have reported that large organizations devoted 50% of their total programming effort to the maintenance of existing systems. Boehm <ref> [Boe75] </ref> has estimated that one US Air Force system cost $30 per instruction to develop and $4,000 per instruction to maintain over its lifetime.
Reference: [Cal88] <author> D. Callahan. </author> <title> ``The Program Summary Graph and Flow-Sensitive Interprocedural Data Flow Analysis'', </title> <booktitle> In Proceedings of the SIGPLAN 1988 Conference on Programming Language Design and Implementation, </booktitle> <address> Atlanta Georgia, </address> <month> June 22-24, </month> <year> 1988. </year>
Reference: [Fer87] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> ``The Program Dependence Graph and its Use in Optimization'', </title> <journal> ACM TOPLAS, </journal> <month> July </month> <year> 1987. </year>
Reference-contexts: Methods for more precise interprocedural slicing have been developed by Horwitz [Hor88] where parameters are passed by value-result. This is an extension of the program dependence graph presented in <ref> [Fer87] </ref>. However, this models a simple language that supports scalar variables, assignment statements, conditional statements, and while loops. The dependence graph developed by Horwitz differentiates between loop-independent and loop-carried flow dependency edges.
Reference: [Har89] <author> M. J. Harrold and M. L. Soffa. </author> <title> ``Selecting Data for Integration Testing </title>
Reference-contexts: Recursion is handled by a method of iteration over the recursive procedure (s). The called procedure always returns to the correct address in the calling procedure. This completely eliminates the use of linkage grammar and construction of subordinate characteristic graphs which makes our algorithm more efficient. Harrold, et. al., <ref> [Har89] </ref> calculate interprocedural data dependences in the context of inter-procedural data flow testing. Their algorithm requires an invocation ordering of the procedures. Additionally, when recursive procedures are present, processing may visit each node p times where p is the number of procedures in the program.
Reference: [Hor88] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> ``Integrating Non-interfering Versions of Programs'', </title> <booktitle> in Proceedings of the 15th ACM Symposium of Programming Languages, </booktitle> <publisher> ACM Press, </publisher> <address> N. York. </address>
Reference-contexts: Dicing, a method based on static slicing, can be used to aid in debugging by allowing certain program bugs to be automatically located [Lyl87]. Horwitz <ref> [Hor88] </ref> has used the concepts of slicing in integrating program variants and Badger [Bad88] has demonstrated how slicing can be used for automatic paralleliza-tion. Furthermore, slicing also aids in code reusability. <p> In addition, Weiser's method does not produce an optimum slice across procedure calls because it cannot keep track of the calling context of a called procedure. Methods for more precise interprocedural slicing have been developed by Horwitz <ref> [Hor88] </ref> where parameters are passed by value-result. This is an extension of the program dependence graph presented in [Fer87]. However, this models a simple language that supports scalar variables, assignment statements, conditional statements, and while loops. The dependence graph developed by Horwitz differentiates between loop-independent and loop-carried flow dependency edges.
Reference: [Hor89] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> ``Integrating Non-interfering Versions of Programs'', </title> <journal> ACM TOPLAS, </journal> <month> July </month> <year> 1989. </year>
Reference: [Hor90] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> ``Interprocedural Slicing Using Dependence Graphs'', </title> <journal> ACM TOPLAS, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: This definition is less general than the one given in [Wei84]; but, it is sufficient <ref> [Hor90] </ref>. Program slices could be used in a variety of ways to aid in several software engineering activities. Weiser [Wei82] has shown that programmers use slices when debugging. <p> Otten-stein et al [Ott84], showed that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program which they referred to as the program dependence graph (PDG). Horwitz et al <ref> [Hor90] </ref>, have introduced algorithms to construct interpro-cedural slices by extending the program dependence graph to a supergraph of the PDG which is referred to as the system dependence graph (SDG). <p> The following sections describe these conversions. 2.3.1. Global Variables The handling of global variables is based on the method suggested by <ref> [Hor90] </ref>. Specifically, glo-bals are solved by introducing them as additional pass-by-reference parameters to the procedures that use or define them. All procedures that call a procedure directly or a procedure which indirectly uses or defines global variables are modified to include the global variables as pass-by-reference parameters. <p> We note here that the possible number of alias configurations for a procedure with n passed-by-reference parameters is 2 n - n. 3. The Interprocedural Slicing Algorithm The interprocedural slicing algorithm is based on the algorithm suggested in <ref> [Hor90] </ref>. Modifications are necessary given the additional constructs introduced in the grammar. The algorithm finds the slice relative to a node s 0 of a program G P in two phases. <p> We should note that when a call to a procedure F yields aliasing and a slice at a statement s 0 that is internal to the body of procedure F, special care must be taken. As described in <ref> [Hor90] </ref>, assuming that the total number of aliasing patterns is m &gt; 0, let s 0 m represent the instance of s 0 in each procedure dependence graph associated with F. Then the slice is given by i = 1 m slice at s 0 m 4. <p> Enhancing Slicing Accuracy There are a number of instances in which an actual-out node should not exist as when a passed-by-reference parameter is not modified. In this case, the presence of its actual-out node could adversely affect the precision of an interprocedural slice. A method is described in <ref> [Hor90] </ref> to detect such a phenomena that is based on the calculation of the GMOD and GREF sets 14 (via the method proposed in [Ban79]) for each procedure F k . <p> The set GREF (P) is defined as the set of variables that might be referenced by P itself or by a procedure (transitively) called from P <ref> [Hor90] </ref>. - 10 - contained in the procedure's dependence graph. Furthermore, as we will show in the next section, we will derive this information during construction of the SDG. In particular, we will consider four cases of a formal-out node that corresponds to a pass-by-reference parameter. <p> We will say that the procedure has been summarized, if and only if, all summary dependences have been calculated. On the other hand, determination of the summary information of F k requires that the procedure be solved. The method that is proposed in <ref> [Hor90] </ref> for the calculation of the transitive dependences distinguishes between grammars that do not support recursion and those that do. In the former case, the solution proposed is via the use of a separate copy of a procedure dependence graph for each call-site. <p> Whereas a slice relative to a particular variable in a particular statement is the set of all statements that may affect the value of the variable, a forward slice will capture the potential effect of changing a variable at a selected statement <ref> [Hor90] </ref>. Like slicing, forward slicing is accomplished in two phases. The first phase consists of a traversal of a particular set of edges starting at a selected node. In the second phase, traversal of a different set of edges is applied to each node visited during the first phase. <p> Our method treats these as a single type of edge -- the data flow edge -- which simplifies construction of the program dependence graph. Our method of calculating interprocedural dependences does not use linkage grammar as used in Horwitz's algorithm <ref> [Hor90] </ref>. Our algorithm is conceptually much simpler. The linkage grammar utilized by Horwitz includes one nonterminal and one production for each procedure in the system. The attributes in the linkage grammar correspond to the input and output parameters of the procedures.
Reference: [Hwa88] <author> J.C. Hwang, M.W. Du, C.R. Chou. </author> <title> ``Finding Program Slices for Recursive Procedures'', </title> <booktitle> In Proceedings of the IEEE COMPSAC 88, IEEE Computer Society, </booktitle> <year> 1988. </year>
Reference-contexts: As above, we do not need to calculate an invocation ordering. Also, we need to iterate over only the recursive procedures, not the entire program. A technique for handling slices for recursive procedures has been suggested by Hwang <ref> [Hwa88] </ref> which constructs a sequence of slices of the system - where each slice of the sequence essentially permits only one additional level of recursion - until a fixed point is reached.
Reference: [Kas80] <author> Kastens, U. </author> <title> ``Ordered Attribute Grammars''. </title> <journal> Acta Inf. </journal> <volume> 13,3, </volume> <year> 1980. </year>
Reference: [Ker88] <author> B.W. Kernigham and D. M. Ritchie. </author> <title> ``The C Programming (ANSI C) Language'', </title> <booktitle> 2nd. </booktitle> <address> Edition, </address> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey. </address>
Reference: [Leu87] <author> H.K.N. Leung and H.K. Reghbati. </author> <title> ``Comments on Program Slicing'', </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. Se-13 No. 12, </volume> <month> December </month> <year> 1987. </year>
Reference: [Liv94] <author> Panos E. Livadas, Stephen Croll. </author> <title> ``A New Algorithm for the Calculation of Transitive Dependences'', </title> <journal> Journal of Software Maintenance, </journal> <volume> Vol 6, </volume> <pages> 1994; pp. 100-127. </pages>
Reference-contexts: We have also implemented a number of tools such as a static slicer, a dicer, a forward slicer among others that can utilize this SDG <ref> [Liv94] </ref>. We should also note that the prototype incorporates the methods and algorithms discussed in this paper. <p> We should note that the terminology and notation used in the sequel is the same as that in <ref> [Liv94] </ref> unless otherwise noted. 2.1. Program Dependence Graph The program dependence graph (PDG) for a program P, with no procedures, denoted by G P , is a labeled, directed, multigraph. <p> In actuality, the SDG is ``resolved'' at the token level. Using a parse tree representation as the basis for our SDG allows more precise slices to be calculated <ref> [Liv94] </ref>. In the sequel, by the term SDG we will denote a parse-tree-based SDG unless otherwise noted. For the purposes of simplicity, the figures in this paper are shown to be resolved at the statement level. <p> Finally, to repeat, the algorithm operates on a parse-tree-based SDG that yields smaller slices. ________________ 15 Notwithstanding the fact that in the case of aliasing phenomena each aliasing pattern gives rise to a distinct procedure dependence graph. - 11 - The Algorithm In <ref> [Liv94] </ref>, we presented and algorithm that in the absence of recursion correctly recursion computes the transitive dependences in a terminal procedure, and use it to compute both data dependences and transitive dependences of a SDG in a single pass. <p> The SDG for program Prog is computed by calling solve_program. This procedure initializes the ECSG and the procedure solutions and then calls solve_procedure on the main procedure. In solve_procedure, each line of the the procedure P is solved, using the algorithm described in <ref> [Liv94] </ref>. Whenever an unsummarized procedure call Q is encountered, the partial solution of P is saved and solve_procedure is executed on Q. <p> It is also easy to see, by an inductive argument, that only those edges that exist in the program are added to the SDG. - 17 - In the base case, the calculation of dependences within a single procedure is correct <ref> [Liv94] </ref>, so only those edges e such that r (e) = 1 are added in the first iteration.
Reference: [Lyl86] <author> J.R. Lyle and M. Weiser. </author> <title> ``Experiments in Slicing-based Debugging Aids'', In Elliot Soloway and Sitharama Iyengar, editors, Empirical Studies of Programmers, </title> <publisher> Ablex Publishing - 23 - Corporation, </publisher> <address> Norwood, New Jersey, </address> <year> 1986. </year>
Reference: [Lyl87] <author> J.R. Lyle and M. Weiser. </author> <title> ``Automatic Program Bug Location by Program Slicing'', </title> <booktitle> In Proccedings of the 2nd International Conference on Computers and Applications, </booktitle> <month> June </month> <year> 1987. </year>
Reference-contexts: Dicing, a method based on static slicing, can be used to aid in debugging by allowing certain program bugs to be automatically located <ref> [Lyl87] </ref>. Horwitz [Hor88] has used the concepts of slicing in integrating program variants and Badger [Bad88] has demonstrated how slicing can be used for automatic paralleliza-tion. Furthermore, slicing also aids in code reusability.
Reference: [Ott84] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> ``The Program Dependence Graph in a Software Development Environment'', </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Pittsburgh, </booktitle> <address> Pa., </address> <month> April 23-25, </month> <year> 1984). </year> <journal> ACM SIGPLAN Notices 19,5, </journal> <month> May </month> <year> 1984. </year>
Reference-contexts: Furthermore, slicing also aids in code reusability. Furthermore, a number of metrics based on program slicing have been proposed [Wei82] which include coverage, component overlap, functional clustering, parallelism, and tightness. - 2 - Weiser's slicer was based on a flow-graph representation of Simple_D programs. Otten-stein et al <ref> [Ott84] </ref>, showed that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program which they referred to as the program dependence graph (PDG).
Reference: [Par86] <editor> G. Parikh. </editor> <booktitle> ``Handbook of Software Maintenance'', </booktitle> <publisher> Wiley-Interscience, </publisher> <address> New York, New York 1986. </address>
Reference: [Reps88] <author> T. Reps and W. Yang. </author> <title> ``The Semantics of Program Slicing'', </title> <institution> TR-777, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> June </month> <year> 1988. </year>
Reference: [Reps89] <author> T. Reps and T. Bricker. </author> <title> ``Illustrating Interference in Interfering Versions of Programs'', </title> <institution> TR-827, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> March </month> <year> 1989. </year>
Reference: [Wei81] <author> M. Weiser. </author> <title> ``Program Slicing'', </title> <booktitle> In Proceedings of the Fifth International Conference on Software Engineering, </booktitle> <address> San Diego, CA, </address> <month> March </month> <year> 1981. </year>
Reference: [Wei82] <author> M. Weiser. </author> <title> ``Programmers Use Slices When Debugging'', </title> <note> CACM July 1982. </note>
Reference-contexts: This definition is less general than the one given in [Wei84]; but, it is sufficient [Hor90]. Program slices could be used in a variety of ways to aid in several software engineering activities. Weiser <ref> [Wei82] </ref> has shown that programmers use slices when debugging. Program slicing provides a meaningful way to decompose a large program into smaller components and can therefore aid in program understanding; and, can also be used in code reusability. <p> Horwitz [Hor88] has used the concepts of slicing in integrating program variants and Badger [Bad88] has demonstrated how slicing can be used for automatic paralleliza-tion. Furthermore, slicing also aids in code reusability. Furthermore, a number of metrics based on program slicing have been proposed <ref> [Wei82] </ref> which include coverage, component overlap, functional clustering, parallelism, and tightness. - 2 - Weiser's slicer was based on a flow-graph representation of Simple_D programs.
Reference: [Wei84] <author> M. Weiser. </author> <title> ``Program Slicing, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> July </month> <year> 1984. </year>
Reference-contexts: This definition is less general than the one given in <ref> [Wei84] </ref>; but, it is sufficient [Hor90]. Program slices could be used in a variety of ways to aid in several software engineering activities. Weiser [Wei82] has shown that programmers use slices when debugging. <p> The only difference is that the action of the slicing algorithm is reversed. Instead of marking nodes as being contained in the slice, the encountered nodes are marked as not being in the slice. 9. Related Work Weiser <ref> [Wei84] </ref> has built slicers for FORTRAN and an abstract data language called Simple-D. His slices were based on flow-graph representation of programs. As far as we know, no operational slicers for C have been built.
Reference: [Yang89] <author> W. Yang, S. Horwitz, and T. Reps. </author> <title> ``Detecting Program Components With Equivalent Behaviors'', </title> <institution> TR-840, Computer Sciences Dept., University of Wisconsin, Madison, </institution> <month> June </month> <year> 1989. </year>
References-found: 26

