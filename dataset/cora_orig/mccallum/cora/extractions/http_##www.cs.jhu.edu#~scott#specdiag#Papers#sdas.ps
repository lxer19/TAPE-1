URL: http://www.cs.jhu.edu/~scott/specdiag/Papers/sdas.ps
Refering-URL: http://www.cs.jhu.edu/~scott/specdiag/
Root-URL: http://www.cs.jhu.edu
Email: scott@cs.jhu.edu  
Title: Specification Diagrams for Actor Systems  
Author: Scott F. Smith 
Date: May 15, 1998  
Affiliation: The Johns Hopkins University  
Abstract-found: 0
Intro-found: 1
Reference: [Agh86] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: In this particular presentation the underlying communication assumptions we use are those taken from the actor model: object- and not channel-based naming, and asynchronous fair message passing. 1.1 Actor Concepts We provide here a very brief overview of actor concepts; see <ref> [Agh86, AMST97, Tal97] </ref> for more complete descriptions. 1 Actors are distributed, object-based message passing entities. Since actors are object-based, they each have a unique name, and actors may dynamically create other actors. Individual actors independently compute in parallel, and actors only communicate by message passing.
Reference: [AMST97] <author> G. Agha, I. A. Mason, S. F. Smith, and C. L. Talcott. </author> <title> A foundation for actor computation. </title> <journal> Journal of Functional Programming, </journal> <volume> 7:172, </volume> <year> 1997. </year>
Reference-contexts: In this particular presentation the underlying communication assumptions we use are those taken from the actor model: object- and not channel-based naming, and asynchronous fair message passing. 1.1 Actor Concepts We provide here a very brief overview of actor concepts; see <ref> [Agh86, AMST97, Tal97] </ref> for more complete descriptions. 1 Actors are distributed, object-based message passing entities. Since actors are object-based, they each have a unique name, and actors may dynamically create other actors. Individual actors independently compute in parallel, and actors only communicate by message passing. <p> Additionally, individual actor computations must never starve. These two guarantees of progress are the fairness assumptions of actor computation. There is no programming language for actors; one possible language is defined in [MT97] but others are possible. A fixed semantic framework for actors has been developed <ref> [AMST97, Tal97] </ref>. We will use this framework as the basis for the developments here. Actor systems are intended to model open distributed computation. This means that the whole system will not be present, and the framework must assume some external actors are interacting with the local system. <p> In this sense it is a standard presentation of operational semantics of actors <ref> [AMST97, Tal97] </ref>. The main difference with these previous works is more post-processing is required to remove paths that are not admissible.
Reference: [BB87] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. Computer Networks and ISDN Systems, </title> <address> 14:2559, </address> <year> 1987. </year>
Reference-contexts: A number of full specification languages based on process algebra have been developed; examples include LOTOS <ref> [BB87] </ref>, which is based on CSP; it is now an an ISO standard. Esterel [BG92] is a process algebra based specification language with a synchronous execution semantics. Temporal Logic Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [JM86, MP92, Lam94].
Reference: [BG92] <author> G. Berry and G. Gonthier. </author> <title> The ESTEREL synchronous programming language: design, semantics, </title> <booktitle> implementation. Science of Computer Programming, </booktitle> <address> 19(2):87152, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: A number of full specification languages based on process algebra have been developed; examples include LOTOS [BB87], which is based on CSP; it is now an an ISO standard. Esterel <ref> [BG92] </ref> is a process algebra based specification language with a synchronous execution semantics. Temporal Logic Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems [JM86, MP92, Lam94].
Reference: [Cli81] <author> W. D. Clinger. </author> <title> Foundations of Actor Semantics. </title> <type> PhD thesis, </type> <institution> MIT, 1981. MIT Artificial Intelligence Laboratory AI-TR-633. </institution>
Reference-contexts: The language is also designed to be useful throughout the development lifecycle, from an initial sketch of the overall architecture to detailed specifications of final components that may serve as documentation of critical aspects of their behavior. Its design was inspired by concepts from actor event diagrams <ref> [Cli81] </ref>, process algebra [Mil80, Hoa85], and UML Sequence Diagrams [RJB98]. <p> Specfication diagrams can be viewed as a major extension of UML sequence diagram notation. In the actor model, event diagrams [Gre75, Hew77] model actor computation in terms of message-passing between actors. Clinger <ref> [Cli81] </ref> formalizes event diagrams as mathematical structures and defines a formal semantics mapping actor system descriptions to sets event diagrams. More generally sets of event diagrams can be thought of as abstract specifications. These have rich mathematical structure but, are in general highly undecidable.
Reference: [et al91] <author> J. Rumbaugh et al. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: A message-passing diagram has a time-line showing the message-passing behavior between different components. Unlike the other approaches described above, message passing specifications are usually object-based and can be asynchronous. The UML Sequence Diagram [RJB98] (derived in turn from the event trace diagram of <ref> [et al91] </ref>) is a simple form of message passing diagram for rpc-style communication. Specfication diagrams can be viewed as a major extension of UML sequence diagram notation. In the actor model, event diagrams [Gre75, Hew77] model actor computation in terms of message-passing between actors.
Reference: [Gre75] <author> I. Greif. </author> <title> Semantics of communicating parallel processes. </title> <type> Technical Report 154, </type> <institution> MIT, Project MAC, </institution> <year> 1975. </year>
Reference-contexts: The UML Sequence Diagram [RJB98] (derived in turn from the event trace diagram of [et al91]) is a simple form of message passing diagram for rpc-style communication. Specfication diagrams can be viewed as a major extension of UML sequence diagram notation. In the actor model, event diagrams <ref> [Gre75, Hew77] </ref> model actor computation in terms of message-passing between actors. Clinger [Cli81] formalizes event diagrams as mathematical structures and defines a formal semantics mapping actor system descriptions to sets event diagrams. More generally sets of event diagrams can be thought of as abstract specifications.
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 8(3):231274, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Specification diagrams are graphical structures. Many specification languages that have achieved widespread usage have a graphical foundation: engineers can understand and communicate more effectively by graphical means. Popular graphical specification languages include Universal Modelling Language (UML) and its predecessors [RJB98], and StateCharts <ref> [Har87] </ref>. UML is the now-standard set of object-oriented design notations; it includes several different forms of graphical specification notation. Our aim here is a language with similar intuitive advantage but significantly greater expressivity and formal underpinnings. <p> Automata-Based Formalisms Finite automata are useful for specifying systems which have a strong state-based behavior. They lack expressivity, but make up 23 for this lack by their amenability to automatic verification by state-space search techniques. The StateCharts formalism <ref> [Har87] </ref> has become particularly popular in industry. States of the automaton represent states of the system (where certain invariant properties hold), and state transitions represent actions. The StateCharts formalism has features beyond simple finite automata, including the ability to nest and compose automata.
Reference: [Hew77] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3):323364, </volume> <year> 1977. </year>
Reference-contexts: The UML Sequence Diagram [RJB98] (derived in turn from the event trace diagram of [et al91]) is a simple form of message passing diagram for rpc-style communication. Specfication diagrams can be viewed as a major extension of UML sequence diagram notation. In the actor model, event diagrams <ref> [Gre75, Hew77] </ref> model actor computation in terms of message-passing between actors. Clinger [Cli81] formalizes event diagrams as mathematical structures and defines a formal semantics mapping actor system descriptions to sets event diagrams. More generally sets of event diagrams can be thought of as abstract specifications.
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Its design was inspired by concepts from actor event diagrams [Cli81], process algebra <ref> [Mil80, Hoa85] </ref>, and UML Sequence Diagrams [RJB98]. <p> Name-passing and dynamic name creation are important to distributed systems and are treated in specification diagrams as well as the p calculus. The trace-based semantic framework is a concept shared with CSP <ref> [Hoa85] </ref>. There are differences as well, and the most important ones are found beneath the surface in the semantics of operators and not their syntax. The object-based behavior of specification diagrams is enforced by the interfaces; for this there is no analogue in process algebra since it is not object-based.
Reference: [HPPSS87] <author> D. Harel, A. Pnueli, J. Pruzan-Schmidt, and R. Sherman. </author> <title> On the formal semantics of statecharts. </title> <booktitle> In Proceedings 2 nd Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, New York, </address> <pages> pages 5464, </pages> <year> 1987. </year>
Reference-contexts: Their primary weakness is that a complex software system may not have a meaningful global state, and properties of such systems are more naturally expressed in terms of events and relations on events. UML notation includes a StateCharts-based style of diagram. A formal semantics of StateCharts has been defined <ref> [HPPSS87] </ref>, but the tools are not sound with respect to a formal semantics and so the effort is not completely satisfactory. Message-Passing Diagrams Message-passing diagrams are a common form of informal graphical specification. A message-passing diagram has a time-line showing the message-passing behavior between different components.
Reference: [HT91] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <editor> In Pierre America, editor, </editor> <booktitle> Proceedings of the Euro-pean Conference on Object-Oriented Programming (ECOOP), volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 133147. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, Tokyo, </address> <year> 1991. </year> <month> 25 </month>
Reference-contexts: Process algebra and specification diagrams in fact share some significant similarities. Parallel composition is of a similar sort in both; choice in specification diagrams could be viewed as a generalization of CCS' external choice operator. message send and receive is analogous to the related concepts in the p-calculus <ref> [MPW92, HT91] </ref>, although the p-calculus restricts data passed to be a channel name, and is in the classical presentation, synchronous as opposed to asynchronous. Name-passing and dynamic name creation are important to distributed systems and are treated in specification diagrams as well as the p calculus.
Reference: [JM86] <author> Farnam Jahanian and Aloysius Mok. </author> <title> Safety analysis of timing proper-ties in real-time systems. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 12(9):890904, </volume> <year> 1986. </year>
Reference-contexts: Esterel [BG92] is a process algebra based specification language with a synchronous execution semantics. Temporal Logic Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems <ref> [JM86, MP92, Lam94] </ref>. While logics may express an extremely broad collection of properties, a significant disadvantage is the need for large, complex formulae to specify nontrivial systems: readability of specifications becomes a serious issue even for small specifications, and users thus require more advanced training.
Reference: [Lam94] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM TOPLAS, </journal> <volume> 16(3):872 923, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: Esterel [BG92] is a process algebra based specification language with a synchronous execution semantics. Temporal Logic Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems <ref> [JM86, MP92, Lam94] </ref>. While logics may express an extremely broad collection of properties, a significant disadvantage is the need for large, complex formulae to specify nontrivial systems: readability of specifications becomes a serious issue even for small specifications, and users thus require more advanced training.
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Its design was inspired by concepts from actor event diagrams [Cli81], process algebra <ref> [Mil80, Hoa85] </ref>, and UML Sequence Diagrams [RJB98]. <p> We briefly review some of the current schools by way of background. Process Algebras Process algebra notation may be used to formally specify the communication actions of concurrent systems, and this was in fact one of the original goals of CCS <ref> [Mil80] </ref>. Process algebra and specification diagrams in fact share some significant similarities.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Esterel [BG92] is a process algebra based specification language with a synchronous execution semantics. Temporal Logic Temporal logic formulae have been extensively used as a means for logical specification of concurrent and distributed systems <ref> [JM86, MP92, Lam94] </ref>. While logics may express an extremely broad collection of properties, a significant disadvantage is the need for large, complex formulae to specify nontrivial systems: readability of specifications becomes a serious issue even for small specifications, and users thus require more advanced training.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). Information and Computation, </title> <address> 100:177, </address> <year> 1992. </year>
Reference-contexts: Process algebra and specification diagrams in fact share some significant similarities. Parallel composition is of a similar sort in both; choice in specification diagrams could be viewed as a generalization of CCS' external choice operator. message send and receive is analogous to the related concepts in the p-calculus <ref> [MPW92, HT91] </ref>, although the p-calculus restricts data passed to be a channel name, and is in the classical presentation, synchronous as opposed to asynchronous. Name-passing and dynamic name creation are important to distributed systems and are treated in specification diagrams as well as the p calculus.
Reference: [MT97] <author> I. A. Mason and C. L. Talcott. </author> <title> A semantically sound actor translation, </title> <note> 1997. submitted. </note>
Reference-contexts: At this point they may be queued if the destination actor is busy. Additionally, individual actor computations must never starve. These two guarantees of progress are the fairness assumptions of actor computation. There is no programming language for actors; one possible language is defined in <ref> [MT97] </ref> but others are possible. A fixed semantic framework for actors has been developed [AMST97, Tal97]. We will use this framework as the basis for the developments here. Actor systems are intended to model open distributed computation.
Reference: [RJB98] <author> Jim Rumbaugh, Ivar Jacobson, and Grady Booch. </author> <title> Unified Modeling Language Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1998. </year>
Reference-contexts: Specification diagrams are graphical structures. Many specification languages that have achieved widespread usage have a graphical foundation: engineers can understand and communicate more effectively by graphical means. Popular graphical specification languages include Universal Modelling Language (UML) and its predecessors <ref> [RJB98] </ref>, and StateCharts [Har87]. UML is the now-standard set of object-oriented design notations; it includes several different forms of graphical specification notation. Our aim here is a language with similar intuitive advantage but significantly greater expressivity and formal underpinnings. <p> Its design was inspired by concepts from actor event diagrams [Cli81], process algebra [Mil80, Hoa85], and UML Sequence Diagrams <ref> [RJB98] </ref>. <p> Message-Passing Diagrams Message-passing diagrams are a common form of informal graphical specification. A message-passing diagram has a time-line showing the message-passing behavior between different components. Unlike the other approaches described above, message passing specifications are usually object-based and can be asynchronous. The UML Sequence Diagram <ref> [RJB98] </ref> (derived in turn from the event trace diagram of [et al91]) is a simple form of message passing diagram for rpc-style communication. Specfication diagrams can be viewed as a major extension of UML sequence diagram notation.
Reference: [Tal97] <author> C. L. Talcott. </author> <title> Composable semantic models for actor theories. </title> <editor> In T. Ito M. Abadi, editor, </editor> <booktitle> Theoretical Aspects of Computer Science, number 1281 in Lecture Notes in Computer Science, </booktitle> <pages> pages 321364. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <month> 26 </month>
Reference-contexts: In this particular presentation the underlying communication assumptions we use are those taken from the actor model: object- and not channel-based naming, and asynchronous fair message passing. 1.1 Actor Concepts We provide here a very brief overview of actor concepts; see <ref> [Agh86, AMST97, Tal97] </ref> for more complete descriptions. 1 Actors are distributed, object-based message passing entities. Since actors are object-based, they each have a unique name, and actors may dynamically create other actors. Individual actors independently compute in parallel, and actors only communicate by message passing. <p> Additionally, individual actor computations must never starve. These two guarantees of progress are the fairness assumptions of actor computation. There is no programming language for actors; one possible language is defined in [MT97] but others are possible. A fixed semantic framework for actors has been developed <ref> [AMST97, Tal97] </ref>. We will use this framework as the basis for the developments here. Actor systems are intended to model open distributed computation. This means that the whole system will not be present, and the framework must assume some external actors are interacting with the local system. <p> See <ref> [Tal97] </ref> for details; here we provide a terse and simplified presentation. We use a path-based (trace-based) semantics: an open, nondeterministic system is interpreted as a set of interaction paths. Each path is a possibly infinite list of input and output actions. <p> All of the interaction paths constructed in this paper are constrained to obey the EPLaw of <ref> [Tal97] </ref>. EPLaw (p) requires inputs of p to be to receptionists or names sent in a previous output, and outputs to be to external actors or actors whose name was received in a previous input. <p> In this sense it is a standard presentation of operational semantics of actors <ref> [AMST97, Tal97] </ref>. The main difference with these previous works is more post-processing is required to remove paths that are not admissible. <p> See <ref> [Tal97] </ref> for full definition of the algebra of interaction path sets; basic definitions 20 were given previously in section 3. The algebra on diagrams is directly lifted from the algebra on Ip sets vie the semantic meaning function for diagrams, [[D r c ]].
References-found: 20

