URL: http://www.cs.utexas.edu/users/cpg/RTS/papers/seke.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/cpg/RTS/abs.html
Root-URL: 
Email: -dastuart,mok-@cs.utexas.edu  farnam@eecs.umich.edu  
Title: A Methodology and Support Tools for Analysis of Real-Time Specifications  
Author: Douglas A. Stuart Aloysius K. Mok Farnam Jahanian 
Keyword: real-time systems, specification, timing constraints, Modechart, RTL, requirements analysis, verification  
Note: Supported in part by a research grant from the Office of Naval Research under ONR contract number N0014-94-1-0582  
Address: Austin, Texas 78712  Ann Arbor, MI 48109-2122  
Affiliation: Department of Computer Sciences University of Texas at Austin  Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas A. Alspaugh, Stuart R. Faulk, Kathryn Heninger Britton, R. Alan Parker, David L. Parnas, and John E. Shore. </author> <title> Software requirements for the A7-E aircraft. </title> <type> Technical Report NRL/FR/5530-92-9194, </type> <institution> Naval Research Laboratory, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: Modechart can be viewed as a language for constructing modes, which are control information that impose structure on the operation of a system. The concept of modes was first introduced by Parnas et al. to simplify describing the requirements specification of the A-7E aircraft <ref> [14, 1] </ref>. The semantics of Modechart is given in Real Time Logic (RTL), a first-order logic for the specification and analysis of such systems [19]. Modechart is extended from Statechart [13] with appropriate constructs for expressing timing constraints.
Reference: [2] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> In Prodeedings of the 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Each of these two types of language has augmented existing models of untimed systems with temporal constructs to capture the timing behavior of systems. Some representative examples of automata-theoretic languages for real-time systems are those of <ref> [20, 25, 2, 3, 24, 19, 10] </ref>. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers.
Reference: [3] <author> R. Alur and D. Dill. </author> <title> The theory of timed automata. </title> <booktitle> In Proceedings of REX Workshop "Real-Time: Theory in Practice", </booktitle> <pages> pages 45-73, </pages> <address> Mook, The Netherlands, </address> <month> June </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> volume 600 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: Each of these two types of language has augmented existing models of untimed systems with temporal constructs to capture the timing behavior of systems. Some representative examples of automata-theoretic languages for real-time systems are those of <ref> [20, 25, 2, 3, 24, 19, 10] </ref>. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers. <p> Since real-time systems typically have infinitely many states, clever ways of aggregating state information are needed to enable exploration of all possible execution paths. Extension of model checking methods to real-time systems have been proposed in <ref> [3, 33] </ref> and an earlier version of this paper [18]. The advantage of model checking methods, such as the one described in this paper, is that they are amenable to mechanical procedures. Proof methods based on process algebras rely on descriptions of systems and requirements in a process algebraic language.
Reference: [4] <author> B. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: Other studies have demonstrated that errors in the specification are the most frequent types of software errors and the most expensive to correct <ref> [4, 28] </ref>. It has also been observed that safety-critical failures can often be traced to requirements specification or design errors very early in the software development process [22]. In spite of the complexity of real-time systems, they are being used to control and monitor important, even safety-critical, applications.
Reference: [5] <author> D. Clarke, I. Lee, and H. Xie. Versa: </author> <title> A tool for the specification and analysis of resource-bound real-time systems. </title> <type> Technical Report MS-CIS-93-77, </type> <institution> University of Pennsylvania, Department of Computer and Information Science, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: The proof method relies heavily on algebraic identities to prove equivalence between algebraic expressions, combined with some mapping proofs. Development of mechanical proof methods for for process algebras is still preliminary. To evaluate the effectiveness of these reasoning techniques, prototype tools have been developed, such as those in <ref> [6, 5] </ref>. Although the approach proposed in this paper is similar to reachability analysis of timed-petri nets, e.g., [30, 35, 29, 26], there are several major differences.
Reference: [6] <author> R. Cleaveland, J. Parrow, and B Steffen. </author> <title> The concurrency workbench: A semantics-based tool for the verification of concurrent systems. </title> <journal> TOPLAS, </journal> <volume> 15 </volume> <pages> 36-72, </pages> <year> 1993. </year>
Reference-contexts: The proof method relies heavily on algebraic identities to prove equivalence between algebraic expressions, combined with some mapping proofs. Development of mechanical proof methods for for process algebras is still preliminary. To evaluate the effectiveness of these reasoning techniques, prototype tools have been developed, such as those in <ref> [6, 5] </ref>. Although the approach proposed in this paper is similar to reachability analysis of timed-petri nets, e.g., [30, 35, 29, 26], there are several major differences.
Reference: [7] <author> P. C. Clements, C. L. Heitmeyer, B. G. Labaw, and A. T. Rose. </author> <title> MT: A toolset for specifying and analyzing real-time systems. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: The Modechart Toolset (MT), developed at the Naval Research Laboratory in collaboration with researchers at the University of Texas, is a collection of integrated tools for specifying and analyzing real-time systems <ref> [7, 32] </ref>. MT supports the formal specification of real-time behavior in a language called Modechart and formal analysis via formal verification, static completeness and consistency checking, and specification simulation. <p> A recent report presented an overview of the Modechart Toolset and its application to an actual Navy real-time system, namely, the HARM Low-Cost Seeker Missile (HLCS) software <ref> [7] </ref>. The graphical interface to the toolset developed for the UNIX and X-windows environment, as shown in Figure 1, is described in the MT User's Guide from NRL [32]. This paper focuses on the mechanical verifier of the Modechart Toolset.
Reference: [8] <author> D. Craigen, S. Gerhart, and T. Ralston. </author> <title> An international survey of industrial applications of formal methods, volume 1 study methodology. </title> <type> Technical Report PB93-178556/AS, Tech. Report 5546-93-9581, </type> <institution> US Naval Research Laboratory, Washington, DC; Tech. Report Info-0474-1, Atomic Energy Control Board of Canada, Ontario, National Technical Information Service, Springfield, VA, </institution> <year> 1993. </year>
Reference-contexts: A recent independent study of 12 cases in which formal methods were applied to the construction of industrial systems concluded that, while still immature in certain respects, [formal methods] are beginning to be used seriously and successfully by industry to design and develop computer or computerized systems <ref> [8, 9] </ref>. The same study also pointed out the lack of robust tools for formal methods, and in particular, support for specification and analysis of timing requirements.
Reference: [9] <author> D. Craigen, S. Gerhart, and T. Ralston. </author> <title> An international survey of industrial applications of formal methods, volume 2 case studies. </title> <type> Technical Report PB93-178564/AS, Tech. Report 5546-93-9582, </type> <institution> US Naval Research Laboratory, Washington, DC; Tech. Report Info-0474-2, Atomic Energy Control Board of Canada, Ontario, National Technical Information Service, Springfield, VA, </institution> <year> 1993. </year>
Reference-contexts: A recent independent study of 12 cases in which formal methods were applied to the construction of industrial systems concluded that, while still immature in certain respects, [formal methods] are beginning to be used seriously and successfully by industry to design and develop computer or computerized systems <ref> [8, 9] </ref>. The same study also pointed out the lack of robust tools for formal methods, and in particular, support for specification and analysis of timing requirements.
Reference: [10] <author> E. Emerson, A. Mok, A. Sistla, and J. Srinivasan. </author> <title> Quantitative temporal reasoning. In Workshop on Automatic Verification of Finite-state Systems, </title> <address> Grenoble, </address> <year> 1989. </year>
Reference-contexts: Each of these two types of language has augmented existing models of untimed systems with temporal constructs to capture the timing behavior of systems. Some representative examples of automata-theoretic languages for real-time systems are those of <ref> [20, 25, 2, 3, 24, 19, 10] </ref>. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers.
Reference: [11] <author> D.A. Gabel. </author> <title> Technology 1994: </title> <journal> Software engineering. IEEE Spectrum, </journal> <volume> 31(1) </volume> <pages> 38-41, </pages> <month> january </month> <year> 1994. </year>
Reference-contexts: Ensuring that an embedded real-time system meets its prescribed specification is a growing challenge that confronts software engineers and system designers. Several studies have demonstrated that the cost of detecting and removing software errors increases significantly as the development process moves from requirements specification toward implementation and system integration <ref> [11] </ref>. It has been estimated that the cost of removing an error from a system specification is an order of magnitude smaller than the cost of removing it from a system during integration testing.
Reference: [12] <author> R. Gerber and I. Lee. </author> <title> A resource-based prioritized bisimulation for real-time systems. </title> <type> Technical Report MS-CIS-90-69, </type> <institution> University of Pennsylvania, Department of Computer and Information Science, </institution> <month> September </month> <year> 1990. </year> <month> 24 </month>
Reference-contexts: Some representative examples of automata-theoretic languages for real-time systems are those of [20, 25, 2, 3, 24, 19, 10]. Some representative examples of process-algebraic languages for real-time systems are those of <ref> [12, 21, 31] </ref>. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers. Specifications written in the front-end language are translated to another language (usually state-machine-based) that is more amenable to formal analysis.
Reference: [13] <author> D. Harel et al. Statemate: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE-16(4), </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: Although similar in some ways to Harel's Statecharts <ref> [13] </ref>, Modechart is specifically tailored to representing time-critical systems. Modechart can be viewed as a language for constructing modes, which are control information that impose structure on the operation of a system. <p> The semantics of Modechart is given in Real Time Logic (RTL), a first-order logic for the specification and analysis of such systems [19]. Modechart is extended from Statechart <ref> [13] </ref> with appropriate constructs for expressing timing constraints. Its visual hierarchical structure together with a small set of well-defined constructs positions it as an attractive programming language for event-driven real-time control systems. Fundamental constructs of a Modechart specification are modes, mode transitions, events, and timing constraints.
Reference: [14] <author> K. L. Heninger. </author> <title> Specifying software requirements for complex systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE-6(1):2-13, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Modechart can be viewed as a language for constructing modes, which are control information that impose structure on the operation of a system. The concept of modes was first introduced by Parnas et al. to simplify describing the requirements specification of the A-7E aircraft <ref> [14, 1] </ref>. The semantics of Modechart is given in Real Time Logic (RTL), a first-order logic for the specification and analysis of such systems [19]. Modechart is extended from Statechart [13] with appropriate constructs for expressing timing constraints.
Reference: [15] <author> F. Jahanian. </author> <title> Verifying properties of systems with variable timing constraints. </title> <booktitle> In Proceedings of the Tenth Real-Time Systems Symposium, </booktitle> <address> Santa Monica, California, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: Unfortunately, it was shown in <ref> [15] </ref> that the problem of determining whether a modechart satisfies an arbitrary RTL formula is undecidable. However, while this is the case for arbitrary formulas, it is possible to construct subsets of RTL for which the problem is decidable.
Reference: [16] <author> F. Jahanian, R.S. Lee, and A.K. Mok. </author> <title> Semantics of modechart in real time logic. </title> <booktitle> In Proc. of 21st Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1988. </year>
Reference-contexts: specification, then a decision procedure for a class of properties for the computation graph is also a decision procedure for the Modechart specification. 3 Specification of Real-Time Systems 3.1 Specifying Systems: Modechart Modechart is a graphical specification language developed to provide a compact and structured way to represent real-time systems <ref> [16, 17] </ref>. Although similar in some ways to Harel's Statecharts [13], Modechart is specifically tailored to representing time-critical systems. Modechart can be viewed as a language for constructing modes, which are control information that impose structure on the operation of a system. <p> Taking the transition causes modes M5, M4, M7, and M2 to be exited, and M3, M8, and M9 to be entered. The formal definition of Modechart is beyond the scope of this presentation. More formal treatment of the syntax and semantics of Modechart appear in <ref> [16, 17] </ref>. 5 3.2 Specifying Properties: Real Time Logic Real Time Logic views a real-time system as a class of event types.
Reference: [17] <author> F. Jahanian and A. K. Mok. Modechart: </author> <title> A specification language for real-time systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <month> 20(10), </month> <year> 1994. </year>
Reference-contexts: specification, then a decision procedure for a class of properties for the computation graph is also a decision procedure for the Modechart specification. 3 Specification of Real-Time Systems 3.1 Specifying Systems: Modechart Modechart is a graphical specification language developed to provide a compact and structured way to represent real-time systems <ref> [16, 17] </ref>. Although similar in some ways to Harel's Statecharts [13], Modechart is specifically tailored to representing time-critical systems. Modechart can be viewed as a language for constructing modes, which are control information that impose structure on the operation of a system. <p> Taking the transition causes modes M5, M4, M7, and M2 to be exited, and M3, M8, and M9 to be entered. The formal definition of Modechart is beyond the scope of this presentation. More formal treatment of the syntax and semantics of Modechart appear in <ref> [16, 17] </ref>. 5 3.2 Specifying Properties: Real Time Logic Real Time Logic views a real-time system as a class of event types.
Reference: [18] <author> F. Jahanian and D. A. Stuart. </author> <title> A method for verifying properties of modechart specifications. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 12-21, </pages> <address> Huntsville, AL, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: This example is selected because its specification is concise and it is a suitable representative of the types of properties that we wish to specify 6 in a real-time system. The example describes a monitoring and control system for a railroad crossing, mentioned in [23] and <ref> [18] </ref>: The gate at a guarded railroad crossing is to be software controlled, and since the gate cannot control the train, a real-time monitor is used to detect a train that is approaching. <p> Some representative examples of automata-theoretic languages for real-time systems are those of [20, 25, 2, 3, 24, 19, 10]. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers <ref> [18, 27] </ref>, have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers. Specifications written in the front-end language are translated to another language (usually state-machine-based) that is more amenable to formal analysis. <p> Since real-time systems typically have infinitely many states, clever ways of aggregating state information are needed to enable exploration of all possible execution paths. Extension of model checking methods to real-time systems have been proposed in [3, 33] and an earlier version of this paper <ref> [18] </ref>. The advantage of model checking methods, such as the one described in this paper, is that they are amenable to mechanical procedures. Proof methods based on process algebras rely on descriptions of systems and requirements in a process algebraic language.
Reference: [19] <author> Farnam Jahanian and Aloysius Ka-Lau Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: The concept of modes was first introduced by Parnas et al. to simplify describing the requirements specification of the A-7E aircraft [14, 1]. The semantics of Modechart is given in Real Time Logic (RTL), a first-order logic for the specification and analysis of such systems <ref> [19] </ref>. Modechart is extended from Statechart [13] with appropriate constructs for expressing timing constraints. Its visual hierarchical structure together with a small set of well-defined constructs positions it as an attractive programming language for event-driven real-time control systems. <p> Each of these two types of language has augmented existing models of untimed systems with temporal constructs to capture the timing behavior of systems. Some representative examples of automata-theoretic languages for real-time systems are those of <ref> [20, 25, 2, 3, 24, 19, 10] </ref>. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers.
Reference: [20] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Technical Report 79, </type> <institution> Digital Systems Research Center, </institution> <month> December 25 </month> <year> 1991. </year>
Reference-contexts: Each of these two types of language has augmented existing models of untimed systems with temporal constructs to capture the timing behavior of systems. Some representative examples of automata-theoretic languages for real-time systems are those of <ref> [20, 25, 2, 3, 24, 19, 10] </ref>. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers.
Reference: [21] <author> I. Lee, P. Bremond-Gregoire, and R. Gerber. </author> <title> A process algebraic approach to the specification and analysis of resource-bound real-time systems. </title> <type> Technical Report MS-CIS-93-08, </type> <month> January </month> <year> 1993. </year> <note> To appear in Proc. of IEEE, </note> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Some representative examples of automata-theoretic languages for real-time systems are those of [20, 25, 2, 3, 24, 19, 10]. Some representative examples of process-algebraic languages for real-time systems are those of <ref> [12, 21, 31] </ref>. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers. Specifications written in the front-end language are translated to another language (usually state-machine-based) that is more amenable to formal analysis.
Reference: [22] <author> N. G. Leveson. </author> <title> Software safety. In Invited Talk, </title> <booktitle> 11th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <address> Seattle, WA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: It has also been observed that safety-critical failures can often be traced to requirements specification or design errors very early in the software development process <ref> [22] </ref>. In spite of the complexity of real-time systems, they are being used to control and monitor important, even safety-critical, applications. During the last decade, software researchers have devoted much attention to formal methods for representing and reasoning about behavioral requirements of real-time systems.
Reference: [23] <author> N. G. Leveson and J. L. Stolzy. </author> <title> Analyzing safety and fault tolerance using time petri nets. </title> <booktitle> In TAPSOFT: Joint Conference on Theory and Practice of Software Development, </booktitle> <year> 1985. </year>
Reference-contexts: This example is selected because its specification is concise and it is a suitable representative of the types of properties that we wish to specify 6 in a real-time system. The example describes a monitoring and control system for a railroad crossing, mentioned in <ref> [23] </ref> and [18]: The gate at a guarded railroad crossing is to be software controlled, and since the gate cannot control the train, a real-time monitor is used to detect a train that is approaching.
Reference: [24] <author> N. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. Distrib. </title> <journal> Computing, </journal> <volume> 6(2) </volume> <pages> 121-139, </pages> <year> 1992. </year>
Reference-contexts: Each of these two types of language has augmented existing models of untimed systems with temporal constructs to capture the timing behavior of systems. Some representative examples of automata-theoretic languages for real-time systems are those of <ref> [20, 25, 2, 3, 24, 19, 10] </ref>. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers.
Reference: [25] <author> Z. Manna, O. Maler, and A. Pnueli. </author> <title> The theory of timed automata. </title> <booktitle> In Proceedings of REX Workshop "Real-Time: Theory in Practice", volume 600 of Lecture Notes in Computer Science, </booktitle> <pages> pages 447-482, </pages> <address> Mook, The Netherlands, June 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Each of these two types of language has augmented existing models of untimed systems with temporal constructs to capture the timing behavior of systems. Some representative examples of automata-theoretic languages for real-time systems are those of <ref> [20, 25, 2, 3, 24, 19, 10] </ref>. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers.
Reference: [26] <author> P.M. Merlin and D.J. Farbar. </author> <title> Recoverability of communication protocols-implications of a theoretical study. </title> <journal> IEEE Trans. on Communications, </journal> <pages> pages 1036-43, </pages> <month> Sept. </month> <year> 1976. </year>
Reference-contexts: Development of mechanical proof methods for for process algebras is still preliminary. To evaluate the effectiveness of these reasoning techniques, prototype tools have been developed, such as those in [6, 5]. Although the approach proposed in this paper is similar to reachability analysis of timed-petri nets, e.g., <ref> [30, 35, 29, 26] </ref>, there are several major differences. The various Petri net approaches all have mechanical proof techniques but lack a specification language, so do not provide the possibility of general techniques such as the one described here.
Reference: [27] <author> J. Ostroff. </author> <title> Temporal Logic for Real-Time Systems. </title> <publisher> John Wiley and Sons Inc., </publisher> <year> 1989. </year>
Reference-contexts: Some representative examples of automata-theoretic languages for real-time systems are those of [20, 25, 2, 3, 24, 19, 10]. Some representative examples of process-algebraic languages for real-time systems are those of [12, 21, 31]. Also, several researchers <ref> [18, 27] </ref>, have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers. Specifications written in the front-end language are translated to another language (usually state-machine-based) that is more amenable to formal analysis.
Reference: [28] <author> R. Pressman. </author> <title> Software Engineering A practitioner's Approach. </title> <publisher> McGraw Hill, </publisher> <address> New York, </address> <note> 3rd edition edition, </note> <year> 1992. </year>
Reference-contexts: Other studies have demonstrated that errors in the specification are the most frequent types of software errors and the most expensive to correct <ref> [4, 28] </ref>. It has also been observed that safety-critical failures can often be traced to requirements specification or design errors very early in the software development process [22]. In spite of the complexity of real-time systems, they are being used to control and monitor important, even safety-critical, applications.
Reference: [29] <author> C. Ramchandani. </author> <title> Analysis of asynchronous concurrent systems by timed petri nets. </title> <type> Technical Report TR 120, </type> <institution> Project MAC, MIT, </institution> <month> Feb. </month> <year> 1974. </year>
Reference-contexts: Development of mechanical proof methods for for process algebras is still preliminary. To evaluate the effectiveness of these reasoning techniques, prototype tools have been developed, such as those in [6, 5]. Although the approach proposed in this paper is similar to reachability analysis of timed-petri nets, e.g., <ref> [30, 35, 29, 26] </ref>, there are several major differences. The various Petri net approaches all have mechanical proof techniques but lack a specification language, so do not provide the possibility of general techniques such as the one described here.
Reference: [30] <author> R.R. Razouk and C.V. Phelps. </author> <title> Performance analysis of timed petri nets. </title> <booktitle> In Proc. of 4th International Workshop on Protocol Spec, Verf and Testing, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: Development of mechanical proof methods for for process algebras is still preliminary. To evaluate the effectiveness of these reasoning techniques, prototype tools have been developed, such as those in [6, 5]. Although the approach proposed in this paper is similar to reachability analysis of timed-petri nets, e.g., <ref> [30, 35, 29, 26] </ref>, there are several major differences. The various Petri net approaches all have mechanical proof techniques but lack a specification language, so do not provide the possibility of general techniques such as the one described here. <p> The restrictions imposed on the types of nets (such as decision free nets, free choice nets and nets with conflict sets) and the restrictions on the timing constraints limit the systems that can be described. Also, the reachability algorithms, for example the one presented in <ref> [30] </ref>, rely on the presence of counters in the nodes of the reachability graph to measure elapsed times. The approach in this paper allows nodes with different timer values to be merged into a single node, resulting in a potentially smaller graph.
Reference: [31] <author> G. M. Reed and A. W. Roscoe. </author> <title> A timed model for communicating sequential processes. </title> <journal> Theor. Comp. Sci., </journal> <pages> pages 249-261, </pages> <year> 1988. </year>
Reference-contexts: Some representative examples of automata-theoretic languages for real-time systems are those of [20, 25, 2, 3, 24, 19, 10]. Some representative examples of process-algebraic languages for real-time systems are those of <ref> [12, 21, 31] </ref>. Also, several researchers [18, 27], have devised dual language approaches. Such an approach provides a front-end language, sometimes graphical, that is intuitive and easily understood by developers. Specifications written in the front-end language are translated to another language (usually state-machine-based) that is more amenable to formal analysis.
Reference: [32] <author> A. Rose, M. Perez, and P. Clements. </author> <title> Modechart toolset user's guide. </title> <type> Technical Report NRL/MRL/5540-94-7427, </type> <institution> Center for Computer High Assurance Systems, Naval Research Lab, </institution> <address> Washington, D.C., </address> <month> February </month> <year> 1994. </year> <month> 25 </month>
Reference-contexts: The Modechart Toolset (MT), developed at the Naval Research Laboratory in collaboration with researchers at the University of Texas, is a collection of integrated tools for specifying and analyzing real-time systems <ref> [7, 32] </ref>. MT supports the formal specification of real-time behavior in a language called Modechart and formal analysis via formal verification, static completeness and consistency checking, and specification simulation. <p> The graphical interface to the toolset developed for the UNIX and X-windows environment, as shown in Figure 1, is described in the MT User's Guide from NRL <ref> [32] </ref>. This paper focuses on the mechanical verifier of the Modechart Toolset. The purpose of the verifier is to determine whether the specification of a system in Modechart satisfies a desired safety assertion. The paper describes the formal 1 technique underlying the mechanical verifier. <p> In this case, rather than even express the query as a formula, the query is directly expressed in terms of an intuitive notion of mode activation duration. Further information about the tool can be found in <ref> [32] </ref>. 5 Concluding Remarks The verification technique proposed in this paper is based on model checking. It requires the construction of a computation graph for a given Modechart specification.
Reference: [33] <author> D. A. Stuart. </author> <title> Implementing a verifier for real-time systems. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 62-71, </pages> <address> Orlando, FL, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: Since real-time systems typically have infinitely many states, clever ways of aggregating state information are needed to enable exploration of all possible execution paths. Extension of model checking methods to real-time systems have been proposed in <ref> [3, 33] </ref> and an earlier version of this paper [18]. The advantage of model checking methods, such as the one described in this paper, is that they are amenable to mechanical procedures. Proof methods based on process algebras rely on descriptions of systems and requirements in a process algebraic language.
Reference: [34] <author> D.A. Stuart, A.K. Mok, and F. Jahanian. </author> <title> A formal method for verifying real-time properties of modechart specifications. </title> <type> Technical report, Technical Report, </type> <institution> University of Michigan, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: The details of the theorems and algorithms presented in this section can be found in <ref> [34] </ref>. 4.1 Computations Since a system often has infinite traces, and as indicated our goal is to construct a finite computation graph that represents the computations of the system, it will be necessary to replace a potentially infinite set of potentially infinite objects with a single finite object, or at least <p> The distance between two points can be evaluated in a number of ways. One approach is to solve the set of inequalities making up the constraints on the trace. Another approach, covered in detail in <ref> [34] </ref>, represents these constraints as a graph, and the distance between points is then the weight of a path in the graph. We can now state the following theorem which allows us to effectively determine the actual successors of a point.
Reference: [35] <author> W.M. Zuberek. </author> <title> Timed petri net and preliminary performance evaluation. </title> <booktitle> In 7th Annual Symposium on Computer Architecture, </booktitle> <pages> pages 88-96, </pages> <year> 1980. </year> <month> 26 </month>
Reference-contexts: Development of mechanical proof methods for for process algebras is still preliminary. To evaluate the effectiveness of these reasoning techniques, prototype tools have been developed, such as those in [6, 5]. Although the approach proposed in this paper is similar to reachability analysis of timed-petri nets, e.g., <ref> [30, 35, 29, 26] </ref>, there are several major differences. The various Petri net approaches all have mechanical proof techniques but lack a specification language, so do not provide the possibility of general techniques such as the one described here.
References-found: 35

