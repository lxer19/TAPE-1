URL: http://www.cs.vt.edu/~chitra/docs/93jpdcA/93jpdcA.ps
Refering-URL: http://www.cs.vt.edu/~chitra/PublicationList.html
Root-URL: http://www.cs.vt.edu
Email: abrams@vt.edu  
Title: Geometric Performance Analysis of Periodic Behavior  
Author: Marc Abrams 
Note: This work was supported in part by National Science Foundation grant NCR-9211342.  
Date: September 7, 1995  
Address: VA 24061-0106  
Affiliation: Computer Science Department, Virginia Tech, Blacksburg,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abrams. </author> <title> An example of deriving performance properties from a visual represen-tion of program execution. </title> <type> Technical Report TR 95-09, </type> <institution> Computer Sci. Dept., Virginia 32 Tech, Blacksburg, </institution> <address> VA 24061-0106, </address> <month> June </month> <year> 1995. </year> <note> Available from World Wide Web location http://www.cs.vt.edu/reports. </note>
Reference-contexts: The assumptions give sufficient (but not necessary) conditions for a program to always reaches a LCES if it does not deadlock, excluding nondeterministic behavior. The assumptions are sufficient but not necessary conditions because they can be relaxed. For example, <ref> [1, Fig. 1] </ref> shows a program that uses message passing with one buffer for inter-process communication (violating A2.3 and A3) that reaches a LCES. The assumptions are, however, necessary and sufficient to use the analytic solution of this paper. We argue next that the assumptions are not unreasonable. <p> Because we develop our solution method by starting with a program as a transition system, we lay the foundation for relaxing the remaining assumptions to study 4 other parallel program classes, such as those in <ref> [1] </ref>, with geometry. Timed Progress Graphs: We propose a novel way to analyze program performance: using timed progress graphs (TPG). <p> Presented in algorithm A0 below is a solution to (2); (1) is addressed in part in <ref> [1] </ref>. The algorithm requires some notation. <p> We use here a predominately analytic method (only the formula for C L (f (X)) is obtained from a computational geometric algorithm). A purely computational geometric method is given in <ref> [1] </ref>. Finding g (G) is equivalent to the following integer programming problem: minimize the length of a slope one diagonal ray rooted at G subject to the constraint that the final ray point lies on some constraint line generated by an element of fl.
Reference: [2] <author> M. Abrams. </author> <title> Geometric performance analysis of periodic behavior in detail. </title> <type> Technical Report TR 95-15, </type> <institution> Computer Sci. Dept., Virginia Tech, Blacksburg, </institution> <address> VA 24061-0106, </address> <month> July </month> <year> 1995. </year> <note> Available from World Wide Web location http://www.cs.vt.edu/reports. </note>
Reference-contexts: If G G 0 ^ h6 9 ^ G : ^ G 2 fl _ ^ G 2 fl 0 :: C N ( ^ G)i then fl fl 0 . Proof: See <ref> [2, Appendix B] </ref>. 2 4.3 Transient and Limit Cycle Execution Trajectories In general, a TET consists of a transient portion followed by an infinite number of repetitions of a limit cycle execution trajectory. Either portion may be empty. <p> Theorem 1 A TET fl in a timed progress graph consists of a transient trajectory followed by an infinite number of congruent LCETs iff jjfGjG 2 fl ^ C N (G)gjj &lt; 1 ^ h6 9G : G 2 fl :: C D (G)i. Proof outline: (See <ref> [2, Appendix C] </ref> for a formal proof.) If part: Let G be the largest non deterministic point in fl; delete the initial subtrajectory of fl that has G as its final point. The remaining trajectory, denoted ^fl, contains only deterministic points. <p> In either case (a) or (b), ^fl 17 passes through a congruent point an infinite number of times, and, by Lemma 1, fl must contain an infinite number of congruent LCETs. The formal proof in <ref> [2] </ref> uses induction on the length of ^fl to make this argument rigorous. Only if part: fl ends in an infinite repetition of a LCET, thus transition function f applied to any point in fl cannot yield the empty set. By definition fl contains no dead points. <p> In contrast, the explicit form of a non-blocking LCET, representing only running states and hence no blocking, reveals little information. The number of congruence classes of non-blocking limit cycles is at most infinite; and by the Corollary to Lemma 5 in <ref> [2] </ref>, the number of blocking LCETs is at most twice the number of semaphores. <p> Hence one trajectory is output, congruent to those in Example 5: point X = (4; 1) and vector sequence (3; 3), (2; 0). 2 The correctness of A0 is established in <ref> [2, Appendix A] </ref> by proving that A0 terminates if each evaluation of function f terminates; that there are at most jjfljj congruence classes of blocking LCETs in a TPGS; that none of the trajectories output by algorithm A0 are congruent; and that for each trajectory output by A0, either that trajectory <p> Algorithm A1 is refined to exploit this fact in <ref> [2, x8] </ref>, and requires at worst time O (N 2 D) and space (N ), where D is the maximum number of integers that occur in any interval I (X k ; W k 0 ; X k 0 all k; k 0 2 f0; 1; : : : ; N
Reference: [3] <author> V. S. Adve and M. K. Vernon. </author> <title> The influence of random delays on parallel execution times. </title> <booktitle> In Proc. SIGMETRICS, </booktitle> <pages> pages 61-73, </pages> <address> Santa Clara, CA, </address> <month> June </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: Chandy and Misra [7] view all computations as non-terminating transition systems that reach a fixed point. Regarding A2.5, Adve and Vernon <ref> [3] </ref> conclude based on seven parallel applications that "it appears reasonable to ignore the variability in execution times when estimating synchronization delays." Furthermore, they conclude, an exponential task time assumption could actually lead to more severe errors than a constant-time assumption.
Reference: [4] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: Uses of logic include Henzinger, Manna, and Pnueli's [14] proof system for real time systems using bounds on transition times, Shaw's [27] extension of Hoare logic to reason about time; and Ramshaw's [23] generation of recurrence equations about timings using Hoare style axioms. Analytic methods include complexity analysis (e.g., <ref> [4] </ref>), micro-analysis using difference equations (e.g., [15]), Petri nets (e.g., [20]), stochastic processes (e.g., [10]), stochastic automata [22], queueing networks (e.g., [13]), and analysis of graphs whose nodes represent code segments (e.g., [11, 25]).
Reference: [5] <author> J. L. Bentley and T. A. Ottman. </author> <title> Algorithms for reporting and counting geometric intersections. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-28(9):643-647, </volume> <month> Sept. </month> <year> 1978. </year>
Reference-contexts: Applying the definition of C N and simplifying yields the expression for C L in the theorem. 2 Known computational geometric algorithms for reporting intersections of line segments (e.g., <ref> [5] </ref>) can compute fG 0 j 8L; 8L 0 : L 2 fl ^ L 0 2 fl ^ L 6= L 0 :: G 0 2 L " L 0 g, required in Theorem 2. 7.2 Analytic Solution of C R (G), g (G), and g (f (G)) The solution
Reference: [6] <author> S. D. Carson and J. P. F. Reynolds. </author> <title> The geometry of semaphore programs. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 25-53, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: A TPG adds timing information to an untimed progress graph (UPG), which Carson and Reynolds define as "a multidimensional, Cartesian graph in which the progress of each of a set of concurrent processes is measured along an independent time axis" <ref> [6] </ref>. To our knowledge, TPGs were first used in operations research to find schedules that minimize the last job completion time in a job shop with two jobs and an arbitrary number of machines [26, pp. 262-263]. <p> UPGs were later used by Dijkstra [8] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood [18, 21, 28, 29] to detect deadlocks in lock-based transaction systems; and Carson and Reynolds <ref> [6] </ref> to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. TPGs differ from UPGs in two ways: First, TPGs represent the time required for transitions, which permits performance analysis. UPGs represent timed transition diagram sets in which all times are equal. <p> One final distinction is that we do not use a computational geometric algorithm to analyze progress graphs, as do most past solutions, but rather derive an analytic solution based on number theory. Combining Carson and Reynold's <ref> [6] </ref> work with this paper shows that one model can be used to verify both liveness and analyze performance of semaphore programs. Results: The use of TPGs is informally illustrated in x2. x3 formalizes timed transition diagrams. x4 formally defines TPGs. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [6, 18, 21, 28, 29] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [14]. Time is represented by nonnegative real numbers. <p> To illustrate, consider the three database transactions used by Lipski and Papadimitriou (Fig. 11 in [18]) and later by Carson and Reynolds (Appendix in <ref> [6] </ref>). A TET in three dimensions can be constructed by drawing one TPG for every pair of processes, as shown in Fig. 12. (See [18] for a true three dimensional sketch.) Each axis in each graph is labeled by one of three transaction numbers (T1, T2, or T3).
Reference: [7] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: As for A2.2, certain programs can be considered non-terminating for the purpose of analysis: long running programs that execute the same code repeatedly, such as simulations, and reactive programs, such as operating system algorithms, that react to external stimuli. Chandy and Misra <ref> [7] </ref> view all computations as non-terminating transition systems that reach a fixed point.
Reference: [8] <author> E. G. Coffman, M. J. Elphick, and A. Shoshani. </author> <title> System deadlocks. </title> <journal> ACM Comp. Surv., </journal> <volume> 3(2) </volume> <pages> 70-71, </pages> <month> June </month> <year> 1971. </year>
Reference-contexts: To our knowledge, TPGs were first used in operations research to find schedules that minimize the last job completion time in a job shop with two jobs and an arbitrary number of machines [26, pp. 262-263]. UPGs were later used by Dijkstra <ref> [8] </ref> to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood [18, 21, 28, 29] to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [6] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4.
Reference: [9] <author> E. W. Dijkstra. </author> <title> Cooperating sequential processes. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 67-68. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: A2: Each process meets the following assumptions: (A2.1) A process executes on a dedicated processor. (A2.2) A process executes a nonterminating loop. (A2.3) A process synchronizes with other processes through binary semaphores <ref> [9] </ref>. (A2.4) Binary semaphore operations are executed unconditionally. (A2.5) The execution time of each code segment within each 3 process that either (1) starts at the initial statement of the loop body and continues to and includes the first semaphore operation, or (2) follows each semaphore operation and continues to and <p> and whose edges are derived by an analytic method (x7) that expresses the timing of processes between synchronization points as a set of Diophantine equations. x8 discusses extension to more than two processes. 2 Illustration of Solution Method We illustrate our approach using Dijkstra's dining philosophers problem with two philosophers <ref> [9] </ref>. Two philosophers eating a meal share two chopsticks. A philosopher must wait upon attempting to acquire the chopsticks while the other is eating. Figure 1 shows a program solution in which P and V operations on a semaphore correspond to acquiring and releasing chopsticks, respectively.
Reference: [10] <author> E. Gelenbe, A. Lichnewsky, and A. Staphylopatis. </author> <title> Experience with the parallel solution of partial differential equations on a distributed computing system. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-31(12):1157-1164, </volume> <month> Dec. </month> <year> 1982. </year> <month> 33 </month>
Reference-contexts: Analytic methods include complexity analysis (e.g., [4]), micro-analysis using difference equations (e.g., [15]), Petri nets (e.g., [20]), stochastic processes (e.g., <ref> [10] </ref>), stochastic automata [22], queueing networks (e.g., [13]), and analysis of graphs whose nodes represent code segments (e.g., [11, 25]).
Reference: [11] <author> R. Govindarajan and G. R. Gao. </author> <title> A novel framework for multi-rate scheduling in dsp appli-cations. </title> <booktitle> In Proc. Inter. Conf. on Application-Specific Array Processors, </booktitle> <pages> pages 77-88, </pages> <address> Venice, Italy, Oct. 1993. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: Analytic methods include complexity analysis (e.g., [4]), micro-analysis using difference equations (e.g., [15]), Petri nets (e.g., [20]), stochastic processes (e.g., [10]), stochastic automata [22], queueing networks (e.g., [13]), and analysis of graphs whose nodes represent code segments (e.g., <ref> [11, 25] </ref>).
Reference: [12] <editor> G. Haring and G. Kotsis, editors. </editor> <booktitle> Performance Measurement and Visualization of Parallel Systems, volume 7 of Advances in Parallel Computing. </booktitle> <publisher> North-Holland, </publisher> <address> Moravany, Czechoslo-vakia, </address> <year> 1993. </year> <booktitle> Proc. of the Workshop on Performance Measurement and Visualization, </booktitle> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: In fact, the idea of analyzing execution sequences is quite popular, as witnessed by recent work on software performance visualization systems (e.g., <ref> [12] </ref>) that includes the ability to display program event traces.
Reference: [13] <author> P. Heidelberger and K. S. Trivedi. </author> <title> Analytic queueing models for programs with internal concurrency. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-32(1):73-82, </volume> <month> Jan. </month> <year> 1983. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [4]), micro-analysis using difference equations (e.g., [15]), Petri nets (e.g., [20]), stochastic processes (e.g., [10]), stochastic automata [22], queueing networks (e.g., <ref> [13] </ref>), and analysis of graphs whose nodes represent code segments (e.g., [11, 25]).
Reference: [14] <author> T. A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> Temporal proof methodologies for timed transition systems. </title> <type> Technical Report TR 93-1330, </type> <institution> Dept. of Comp. Sci., Cornell Univ., </institution> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: Uses of logic include Henzinger, Manna, and Pnueli's <ref> [14] </ref> proof system for real time systems using bounds on transition times, Shaw's [27] extension of Hoare logic to reason about time; and Ramshaw's [23] generation of recurrence equations about timings using Hoare style axioms. <p> Because UPGs have been used extensively for analysis of deadlocks [6, 18, 21, 28, 29], deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams <ref> [14] </ref>. Time is represented by nonnegative real numbers. Let R, R + , and Z denote, respectively, the set of nonnegative reals, positive reals, and nonnegative integers. We assume that h8n : n 2 Z :: n 1i to simplify our notation.
Reference: [15] <author> T. J. Hickey, J. Cohen, H. Hotta, and T. Petitjean. </author> <title> Computer-assisted microanalysis of parallel programs. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 14(1) </volume> <pages> 54-106, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [4]), micro-analysis using difference equations (e.g., <ref> [15] </ref>), Petri nets (e.g., [20]), stochastic processes (e.g., [10]), stochastic automata [22], queueing networks (e.g., [13]), and analysis of graphs whose nodes represent code segments (e.g., [11, 25]).
Reference: [16] <author> M. A. Holliday and M. K. Vernon. </author> <title> A generalized timed Petri net model for performance analysis. </title> <booktitle> In Proc. Int. Workshop on Timed Petri Nets, </booktitle> <month> July </month> <year> 1985. </year>
Reference-contexts: Also proved are complexity results for systems of processes with communication by buffers. Finally, Holliday and Vernon <ref> [16] </ref> use Petri nets with frequency expressions (i.e., probabilities) to resolve deterministically which transition fires when a token enables two or more transitions simultaneously, and analyzes a dining philosophers program. 1.2 Problem Statement Let the state of a program be the control point of each process.
Reference: [17] <author> B. W. Jones. </author> <title> The Theory of Numbers. </title> <publisher> Rinehart, </publisher> <address> New York, </address> <year> 1955. </year>
Reference-contexts: Therefore equation (6) is a Diophantine equation. A necessary and sufficient condition for a solution to equation (6) to exist is that the 27 greatest common divisor of 1 and 0 divides s 0 , by Jones' Theorem 3.3 <ref> [17] </ref>. Therefore a solution exists iff interval I (G; W; X) contains an integer. Applying equation (1) establishes the following. <p> The rewritting is done by expressing unknown i 1 in terms of unknown s 0 and an integer parameter ff by applying the solution technique for three variable Diophantine equations in <ref> [17] </ref>, pp. 67-68. There are an infinite number of solutions, which parameter ff expresses. The solution to (6) is i 1 = us 0 + 0 ff; (9) where u is an integer satisfying 1 u 1 (mod 0 ).
Reference: [18] <author> W. Lipski and C. H. Papadimitriou. </author> <title> A fast algorithm for testing for safety and detecting deadlocks in locked transaction systems. </title> <journal> J. Alg., </journal> <volume> 2(3) </volume> <pages> 211-226, </pages> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: UPGs were later used by Dijkstra [8] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [18, 21, 28, 29] </ref> to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [6] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [6, 18, 21, 28, 29] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [14]. Time is represented by nonnegative real numbers. <p> To illustrate, consider the three database transactions used by Lipski and Papadimitriou (Fig. 11 in <ref> [18] </ref>) and later by Carson and Reynolds (Appendix in [6]). A TET in three dimensions can be constructed by drawing one TPG for every pair of processes, as shown in Fig. 12. (See [18] for a true three dimensional sketch.) Each axis in each graph is labeled by one of three <p> To illustrate, consider the three database transactions used by Lipski and Papadimitriou (Fig. 11 in <ref> [18] </ref>) and later by Carson and Reynolds (Appendix in [6]). A TET in three dimensions can be constructed by drawing one TPG for every pair of processes, as shown in Fig. 12. (See [18] for a true three dimensional sketch.) Each axis in each graph is labeled by one of three transaction numbers (T1, T2, or T3). We denote the graphs as 1 fi 2 (for the graph with axes T1 and T2), 1 fi 3, and 3 fi 2.
Reference: [19] <author> J. Magott. </author> <title> Performance evaluation of systems of cyclic processes with mutual exclusion using Petri nets. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 229-232, </pages> <month> Nov. </month> <year> 1985. </year> <month> 34 </month>
Reference-contexts: The class analyzed is also a Deterministic System of Synchronizing Processes (DSSP) restricted to two linear processes but generalized to omit the private-buffer assumption (i.e., Definition 2.7 (ii) in [24]). Magott <ref> [19] </ref> gives an O (N ) algorithm to compute minimum cycle time (MCT), or the minimum time required for a consistent Petri net to return to its initial marking, given deterministic firing times for nets consisting of a set of N cyclic processes that mutually exclusively share a single resource, and
Reference: [20] <author> T. Murata. </author> <title> Petri nets: Properties, analysis and applications. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(4) </volume> <pages> 541-580, </pages> <month> Apr. </month> <year> 1989. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [4]), micro-analysis using difference equations (e.g., [15]), Petri nets (e.g., <ref> [20] </ref>), stochastic processes (e.g., [10]), stochastic automata [22], queueing networks (e.g., [13]), and analysis of graphs whose nodes represent code segments (e.g., [11, 25]). <p> choice) nets subsumes the program class analyzed here. (In a simple net, all arc weights are one and if two places share an output 1 transition then the set of output transitions of one place is either equal to or a subset of the output transitions of the other place <ref> [20, p. 554] </ref>). The class analyzed is also a Deterministic System of Synchronizing Processes (DSSP) restricted to two linear processes but generalized to omit the private-buffer assumption (i.e., Definition 2.7 (ii) in [24]).
Reference: [21] <author> C. H. Papadimitriou. </author> <title> Concurrency control by locking. </title> <journal> SIAM J. on Computing, </journal> <volume> 12(2) </volume> <pages> 215-226, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: UPGs were later used by Dijkstra [8] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [18, 21, 28, 29] </ref> to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [6] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [6, 18, 21, 28, 29] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [14]. Time is represented by nonnegative real numbers.
Reference: [22] <author> B. Plateau and K. Atif. </author> <title> Stochastic automata network for modeling parallel systems. </title> <journal> IEEE Trans. on Software Engineering, </journal> 1991(10) 1093-1109, Oct. 1991. 
Reference-contexts: Analytic methods include complexity analysis (e.g., [4]), micro-analysis using difference equations (e.g., [15]), Petri nets (e.g., [20]), stochastic processes (e.g., [10]), stochastic automata <ref> [22] </ref>, queueing networks (e.g., [13]), and analysis of graphs whose nodes represent code segments (e.g., [11, 25]).
Reference: [23] <author> L. H. Ramshaw. </author> <title> Formalizing the Analysis of Algorithms. </title> <type> PhD thesis, </type> <institution> Computer Sci. Dept., Stanford Univ., </institution> <month> June </month> <year> 1979. </year> <month> STAN-CS-79-741. </month>
Reference-contexts: Uses of logic include Henzinger, Manna, and Pnueli's [14] proof system for real time systems using bounds on transition times, Shaw's [27] extension of Hoare logic to reason about time; and Ramshaw's <ref> [23] </ref> generation of recurrence equations about timings using Hoare style axioms.
Reference: [24] <author> W. Reisig. </author> <title> Deterministic buffer synchronization of sequential systems. </title> <journal> Acta Informatica, </journal> <volume> 18 </volume> <pages> 117-134, </pages> <year> 1982. </year>
Reference-contexts: The class analyzed is also a Deterministic System of Synchronizing Processes (DSSP) restricted to two linear processes but generalized to omit the private-buffer assumption (i.e., Definition 2.7 (ii) in <ref> [24] </ref>).
Reference: [25] <author> R. Reiter. </author> <title> Scheduling parallel computations. </title> <journal> JACM, </journal> <volume> 15(4) </volume> <pages> 590-599, </pages> <month> Oct. </month> <year> 1968. </year>
Reference-contexts: Analytic methods include complexity analysis (e.g., [4]), micro-analysis using difference equations (e.g., [15]), Petri nets (e.g., [20]), stochastic processes (e.g., [10]), stochastic automata [22], queueing networks (e.g., [13]), and analysis of graphs whose nodes represent code segments (e.g., <ref> [11, 25] </ref>).
Reference: [26] <author> M. Sasieni, A. Yaspan, and L. Friedman. </author> <title> Operations Research Methods and Problems. </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1959. </year>
Reference-contexts: To our knowledge, TPGs were first used in operations research to find schedules that minimize the last job completion time in a job shop with two jobs and an arbitrary number of machines <ref> [26, pp. 262-263] </ref>.
Reference: [27] <author> A. J. Shaw. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Uses of logic include Henzinger, Manna, and Pnueli's [14] proof system for real time systems using bounds on transition times, Shaw's <ref> [27] </ref> extension of Hoare logic to reason about time; and Ramshaw's [23] generation of recurrence equations about timings using Hoare style axioms.
Reference: [28] <author> E. Soisalon-Soininen and D. Wood. </author> <title> An optimal algorithm for testing for safety and detecting deadlocks in locked transaction system. </title> <booktitle> In Symp. on Principles of Database Systems, </booktitle> <pages> pages 108-116, </pages> <address> Los Angeles, </address> <month> Mar. </month> <year> 1982. </year> <note> ACM. </note>
Reference-contexts: UPGs were later used by Dijkstra [8] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [18, 21, 28, 29] </ref> to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [6] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [6, 18, 21, 28, 29] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [14]. Time is represented by nonnegative real numbers.
Reference: [29] <author> M. Yannakakis, C. H. Papadimitriou, and H. T. Kung. </author> <title> Locking policies: Safety and freedom from deadlock. </title> <booktitle> In 20th ACM Symp. on the Foundations of Computer Sci., </booktitle> <pages> pages 283-287, </pages> <year> 1979. </year> <booktitle> Author Biography MARC ABRAMS received the Ph.D. </booktitle> <institution> degree from the University of Maryland at College Park in 1986 and is an Associate Professor of Computer Science at Virginia Polytechnic Institute and State University. His research interests include performance analysis of software, communication networks, and computer systems. </institution>
Reference-contexts: UPGs were later used by Dijkstra [8] to illustrate multiprogramming deadlock; Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [18, 21, 28, 29] </ref> to detect deadlocks in lock-based transaction systems; and Carson and Reynolds [6] to prove liveness properties in programs with an arbitrary number of processes under assumptions A2.3 and 2.4. <p> In addition, the points on line segments ((3; 3); (4; 3)) and (3; 3); (3; 4) do not lie on any TET, and hence are unreachable. Because UPGs have been used extensively for analysis of deadlocks <ref> [6, 18, 21, 28, 29] </ref>, deadlocks are not considered further. 2 3 Timed Transition Diagrams Our model of a program is based on Henzinger, Manna, and Pnueli's timed transition diagrams [14]. Time is represented by nonnegative real numbers.
References-found: 29

