URL: ftp://ftp.eecs.umich.edu/groups/gasm/bagof.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: boerger@di.unipi.it  dean@math.hr  
Phone: 2  
Title: The Mathematics of Set Predicates in Prolog  
Author: Egon B orger Dean Rosenzweig 
Address: Pisa  Zagreb  
Affiliation: 1 Dip. di Informatica, Universita di  FSB, University of  
Abstract: We provide a logical specification of set predicates findall and bagof of Prolog. The specification is given in proof theoretic terms, and pertains to any SLD-resolution based language. The order dependent aspects, relevant for languages embodying a sequential proof search strategy (possibly with side effects), can be added in an orthogonal way. The specification also allows us to prove that bagof cannot be defined by SLD-resolution alone. We show the correctness, wrt to our specification, of Demoen's definition of bagof for Prolog in Prolog. The specification of bagof allows us to throw some light on the logical problems with setof .
Abstract-found: 1
Intro-found: 1
Reference: [Apt 90] <author> K.R.Apt, </author> <title> Logic Programming, </title> <editor> in: J. van Leeuwen (ed.), </editor> <title> Formal Models and Semantics. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <address> Vol.B, </address> <publisher> Elsevier 1990, </publisher> <pages> pp. 493-574 </pages>
Reference-contexts: We use _ to denote multiset union, thus h 1; 2; 1 i _ h 2; 2 i = h 1; 1; 2; 2; 2 i. We shall otherwise rely on standard notation and terminology of logic programming, cf. <ref> [Apt 90] </ref>. 1 Semantics of findall The predicate findall (T, G, L) has been introduced into Prolog in order to automate the process of finding (through repeated backtracking) and collecting into 2 a list, all values of the term T with which the goal G succeeds, unifying subse-quently this list with <p> There seems to be (almost) a consensus in the Prolog community about where to look|to model theory. From model theoretic point of view, computed parameter values are different if they have different sets of (ground) instances. It is known <ref> [Apt 90] </ref> to be equivalent to the following criterion: computed parameter 6 values Y i ; Y j are alternative if they are not variants. The decision, to group into one alternative solution (bag) those proofs which yield variant parameter values, is then expressed by Definition 1. <p> Statement (a) follows from answer substitutions being idempotent|cf. <ref> [Apt 90] </ref>. Statement (b) follows from (a), observing that sequences . . . t (. . . Y . . .) . . . Y . . . and . . . t (. . . Z . . .) . . . <p> Propositions 3 and 4 might help explain some of the usual difficulties in understanding bagof . It namely violates the lifting property of SLD-resolution <ref> [Apt 90] </ref>: a solution of an instance of a goal is an instance of a solution of that goal.
Reference: [Barendregt 84] <author> H.P.Barendregt, </author> <title> The Lambda Calculus, </title> <publisher> Elsevier 1984 </publisher>
Reference-contexts: For instance, R 1 R 1 0 y 2 dy is not a theorem of the integral calculus|the two sides are simply the same expression. For systematic discussion in the context of -calculus, cf. <ref> [Barendregt 84] </ref>. To define duplicates by == =2 amounts to collecting sets of names.
Reference: [BoeRos 91] <author> E.Borger, D.Rosenzweig, </author> <title> A Formal Specification of Prolog by Tree Algebras, </title> <editor> in: V. Ceric et.al. (eds.), </editor> <booktitle> Proceedings of The Third International Conference on Information Technology Interfaces, SRCE, Zagreb 1991, </booktitle> <pages> pp. 513-518 </pages>
Reference-contexts: For the reader who finds this proof to be handwaving, and requires a `more formal' argument, we would have to substitute `the usual operational understanding' of Prolog (i.e. of the way it searches the SLD-tree) with a mathematical model. Our tree model <ref> [BoeRos 91, BoeRos 92] </ref> adheres so closely to this `usual operational understanding' that a transfer of the preceding proof to the mathematical model is nothing but an excercise, which we may leave to the interested reader.
Reference: [BoeRos 92] <author> E.Borger, D.Rosenzweig, </author> <title> The WAM|Definition and Compiler Correctness, </title> <type> Technical report TR-14/92, </type> <institution> Dipartimento di Informatica, Universita di Pisa 1992 12 </institution>
Reference-contexts: For the reader who finds this proof to be handwaving, and requires a `more formal' argument, we would have to substitute `the usual operational understanding' of Prolog (i.e. of the way it searches the SLD-tree) with a mathematical model. Our tree model <ref> [BoeRos 91, BoeRos 92] </ref> adheres so closely to this `usual operational understanding' that a transfer of the preceding proof to the mathematical model is nothing but an excercise, which we may leave to the interested reader.
Reference: [Demoen 91] <author> B.Demoen, </author> <title> Code and Comments Regarding bagof/3 , in: PROLOG. </title> <booktitle> Paris papers 2, ISO/IEC JTC1 SC22 WG17 N.80, </booktitle> <pages> pp. 85-86 </pages>
Reference-contexts: Introduction The solution collecting predicates findall, bagof, setof of Prolog have been quite extensively discussed in the literature| [PerPor 81], [Warren 82], [Ueda 86], [Ueda 87], [O'Keefe 90], <ref> [Demoen 91] </ref>, [Dodd 91], [WG17 92] and can be found, in different versions, in most Prolog systems (DEC-10, C, Quintus, BIM, Sic-stus, IBM, LPA,. . . ). Discussion has however mainly been about whether and why they should be used, and whether and how they are eliminable. <p> We also prove that the algorithm, probably intended by the ISO Prolog standardization committee [WG17 92], and ? in: Computational Logic and Proof Theory, G.Gottlob, A.Leitsch, D.Mundici Eds., Springer LNCS 713, 1993, pp.1-13. expressed by an elegant piece of Prolog code by <ref> [Demoen 91] </ref>, is correct with respect to our specification. The mathematical crux of the paper is section 2 which provides the logical semantics of bagof/3. Section 1 prepares the ground with a logical (order-independent) semantics for findall/3, giving also the methodological paradigm. <p> be understood in a very narrow sense (say only in terms of simple fixpoint constructions like classical T P ) 4 3 Correctness of Demoen's specification of bagof In case of Prolog, several descriptions of bagof have been put forward in the context of the standardization effort in ISO WG17 <ref> [Demoen 91, Dodd 91, WG17 92] </ref>. <p> The only specification which, to us, seems to be clear and precise enough to be related to our specification by a proof, is due to Bart Demoen, and comes in the form of the following elegant piece of Prolog code <ref> [Demoen 91] </ref>. bagof (Term; Goal; Bag) : free variables (Goal; Term; Vars); findall (Vars Term; Goal; Answerlist); produce (Answerlist; Answer; Vars); Bag = Answer: 4 Proposition 5. applies, strictly speaking, to findall as well, but, as shown by the above example, `less strikingly so'. 9 produce ([ Params Term j Rest
Reference: [Dodd 91] <author> A.Dodd, </author> <title> The Predicates bagof/3 and setof/3 , a Proposal, </title> <booktitle> in: PRO-LOG. Paris papers 2, ISO/IEC JTC1 SC22 WG17 N.80, </booktitle> <pages> pp. 75-84 </pages>
Reference-contexts: Introduction The solution collecting predicates findall, bagof, setof of Prolog have been quite extensively discussed in the literature| [PerPor 81], [Warren 82], [Ueda 86], [Ueda 87], [O'Keefe 90], [Demoen 91], <ref> [Dodd 91] </ref>, [WG17 92] and can be found, in different versions, in most Prolog systems (DEC-10, C, Quintus, BIM, Sic-stus, IBM, LPA,. . . ). Discussion has however mainly been about whether and why they should be used, and whether and how they are eliminable. <p> be understood in a very narrow sense (say only in terms of simple fixpoint constructions like classical T P ) 4 3 Correctness of Demoen's specification of bagof In case of Prolog, several descriptions of bagof have been put forward in the context of the standardization effort in ISO WG17 <ref> [Demoen 91, Dodd 91, WG17 92] </ref>.
Reference: [O'Keefe 90] <author> R.A.O'Keefe, </author> <title> The Craft of Prolog, </title> <publisher> MIT Press 1990 </publisher>
Reference-contexts: Introduction The solution collecting predicates findall, bagof, setof of Prolog have been quite extensively discussed in the literature| [PerPor 81], [Warren 82], [Ueda 86], [Ueda 87], <ref> [O'Keefe 90] </ref>, [Demoen 91], [Dodd 91], [WG17 92] and can be found, in different versions, in most Prolog systems (DEC-10, C, Quintus, BIM, Sic-stus, IBM, LPA,. . . ). Discussion has however mainly been about whether and why they should be used, and whether and how they are eliminable. <p> We cannot do much better with model theory alone, since findall inherently involves proof-theoretic notions. . . . although Prolog reports solutions, it is looking for proofs, and findall/3 is defined to return an instance of the t for every proof of g. <ref> [O'Keefe 90] </ref> For the following proof theoretical analysis we have the assumption that the SLD-tree of g is finite (since otherwise the computation of findall will not terminate). <p> However obvious this choice may seem, in case of not fully instantiated terms it is impossible to justify logically, as sensed also by O'Keefe: (setof is) . . . only sound when the free variables and template variables are bound to sufficiently instantiated terms . . . <ref> [O'Keefe 90] </ref> Consider a database with facts p: p: q (Z; Z): q (Z; Z): The calls setof (1; p; L 1 ); setof (X; p; L 2 ); setof (X; q (X; Y ); L 3 ) provide, under this semantics, the solutions L 1 = [ 1 ]; L
Reference: [PerPor 81] <author> L.M.Pereira, A.Porto, </author> <title> All Solutions, </title> <booktitle> in: Logic Programming Newsletter 2, </booktitle> <year> 1981, </year> <pages> pp. 9-10 </pages>
Reference-contexts: Introduction The solution collecting predicates findall, bagof, setof of Prolog have been quite extensively discussed in the literature| <ref> [PerPor 81] </ref>, [Warren 82], [Ueda 86], [Ueda 87], [O'Keefe 90], [Demoen 91], [Dodd 91], [WG17 92] and can be found, in different versions, in most Prolog systems (DEC-10, C, Quintus, BIM, Sic-stus, IBM, LPA,. . . ).
Reference: [Ueda 86] <author> K.Ueda, </author> <title> Making Exhaustive Search Programs Deterministic, </title> <booktitle> in: Proceedings of the 3rd International Conference on Logic Programming, </booktitle> <pages> pp. 270-282 </pages>
Reference-contexts: Introduction The solution collecting predicates findall, bagof, setof of Prolog have been quite extensively discussed in the literature| [PerPor 81], [Warren 82], <ref> [Ueda 86] </ref>, [Ueda 87], [O'Keefe 90], [Demoen 91], [Dodd 91], [WG17 92] and can be found, in different versions, in most Prolog systems (DEC-10, C, Quintus, BIM, Sic-stus, IBM, LPA,. . . ).
Reference: [Ueda 87] <author> K.Ueda, </author> <title> Making Exhaustive Search Programs Deterministic, </title> <booktitle> Part 2, in: Proceedings of the 4th International Conference on Logic Programming, </booktitle> <pages> pp. 356-375 </pages>
Reference-contexts: Introduction The solution collecting predicates findall, bagof, setof of Prolog have been quite extensively discussed in the literature| [PerPor 81], [Warren 82], [Ueda 86], <ref> [Ueda 87] </ref>, [O'Keefe 90], [Demoen 91], [Dodd 91], [WG17 92] and can be found, in different versions, in most Prolog systems (DEC-10, C, Quintus, BIM, Sic-stus, IBM, LPA,. . . ).
Reference: [Warren 82] <author> D.H.D.Warren, </author> <title> Higher Order Extensions to Prolog: Are they Needed?, </title> <booktitle> in: Machine Intelligence 10(1982), </booktitle> <pages> pp. 441-454 </pages>
Reference-contexts: Introduction The solution collecting predicates findall, bagof, setof of Prolog have been quite extensively discussed in the literature| [PerPor 81], <ref> [Warren 82] </ref>, [Ueda 86], [Ueda 87], [O'Keefe 90], [Demoen 91], [Dodd 91], [WG17 92] and can be found, in different versions, in most Prolog systems (DEC-10, C, Quintus, BIM, Sic-stus, IBM, LPA,. . . ). <p> alternative computed parameter values. &gt;From the wording of Requirement 4 it is clear why we had to put an additional condition on Requirement 1: if g had no solutions, Requirement 4 would prohibit us to return an empty bag, since it would not reflect any computed parameter value (see also <ref> [Warren 82] </ref>). Thus, Requirement 4'. If g has no solution, bagof (t; g; l) should fail. Requirements 3 and 4 should not be taken too literally; they would namely be contradictory.
Reference: [WG17 92] <author> PROLOG. </author> <title> Part 1, General Core, Committee Draft 1.0 , ISO/IEC JTC1 SC22 WG17 N.92 This article was processed using the L a T E X macro package with LLNCS style 13 </title>
Reference-contexts: Introduction The solution collecting predicates findall, bagof, setof of Prolog have been quite extensively discussed in the literature| [PerPor 81], [Warren 82], [Ueda 86], [Ueda 87], [O'Keefe 90], [Demoen 91], [Dodd 91], <ref> [WG17 92] </ref> and can be found, in different versions, in most Prolog systems (DEC-10, C, Quintus, BIM, Sic-stus, IBM, LPA,. . . ). Discussion has however mainly been about whether and why they should be used, and whether and how they are eliminable. <p> The specification thus pertains to any SLD-resolution based language. We relate the specification of bagof to the underlying fundamental mathematical principles of comprehension (abstraction) and parametrization. Some choices, made in (current practice and) the draft standard proposal <ref> [WG17 92] </ref> for bagof , turn out to be best justified by combining proof theoretical and model theoretical considerations. Once the specification is given, we can prove that bagof cannot be defined by SLD-resolution alone. We also prove that the algorithm, probably intended by the ISO Prolog standardization committee [WG17 92], <p> proposal <ref> [WG17 92] </ref> for bagof , turn out to be best justified by combining proof theoretical and model theoretical considerations. Once the specification is given, we can prove that bagof cannot be defined by SLD-resolution alone. We also prove that the algorithm, probably intended by the ISO Prolog standardization committee [WG17 92], and ? in: Computational Logic and Proof Theory, G.Gottlob, A.Leitsch, D.Mundici Eds., Springer LNCS 713, 1993, pp.1-13. expressed by an elegant piece of Prolog code by [Demoen 91], is correct with respect to our specification. <p> be understood in a very narrow sense (say only in terms of simple fixpoint constructions like classical T P ) 4 3 Correctness of Demoen's specification of bagof In case of Prolog, several descriptions of bagof have been put forward in the context of the standardization effort in ISO WG17 <ref> [Demoen 91, Dodd 91, WG17 92] </ref>. <p> Since implementations of Pro-log usually do not provide the occur-check , semantic reasoning about Prolog programs usually applies only to situations satisfying the following additional general assumption: (iii) All unifications executed are not subject to the occur-check. In view of the fact that the draft Prolog standard proposal <ref> [WG17 92] </ref> does not specify behaviour of systems when this assumption is violated, there is little that can be said in that case. In particular, since most implementations produce idempotent and relevant mgu's as soon as assumption (iii) holds, we will in this section rely on that. <p> Both (a) and (b) are simple and well justified in case of ground terms. In case of uninstantiated variables in terms however, both (a) and (b) require definition. Trying to find a common demoninator of current practice, ISO WG17 has decided <ref> [WG17 92] </ref> to interprete duplicates as identical terms in sense of Prolog predicate == =2. <p> In both cases it is simple to adapt our specification of bagof , to yield an appropriate setof , without complicating the implementation excessively. As to sorting criterion, it is really the fixation on names which must have led to term ordering as a supposedly natural choice <ref> [WG17 92] </ref>|even though different implementations cannot be reasonably expected to agree on ordering of uninstantiated variables. In some cases the ordering is thus left undefined, making it implementation dependent and not portable.
References-found: 12

