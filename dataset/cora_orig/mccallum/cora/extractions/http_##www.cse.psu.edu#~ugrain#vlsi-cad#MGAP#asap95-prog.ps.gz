URL: http://www.cse.psu.edu/~ugrain/vlsi-cad/MGAP/asap95-prog.ps.gz
Refering-URL: http://www.cse.psu.edu/~ugrain/publications.html
Root-URL: 
Title: The MGAP's Programming Environment and the *C++ Language  
Author: R. S. Bajwa R. M. Owens M. J. Irwin 
Note: 1: Introduction 2: MGAP Architecture  
Address: Park, PA., 16802  
Affiliation: Department of Computer Science and Engineering Pennsylvania State University University  
Abstract: The MGAP is a special-purpose, workstation co-processor board in which the computing elements are fine grain processors implemented as custom ASICs. In this paper we present the language *C++, used for programming on the MGAP. Using the class concept of C++ we create special parallel data-types like bit, digit, word and array and overload operators to manipulate the parallel data required by the MGAP. The hierarchical relationships among the data-types are used by the compiler to generate parallel code for the MGAP. We demonstrate that using the same high-level language and the same program we can operate on data at all levels of granularity, from bits to arrays, without any loss in performance. The Micro-Grain Array Processor (MGAP) has been designed to serve as a co-processor that can bring nearly a teraop of additional computing power to desktop systems. To access this power easily end users must have a language with which they can exploit the features of the underlying architecture. The language we developed, *C++, is different from both C* [5] and dbC [3] in that it is used to program a machine in which the computational units are abstracted as processors (as in the CM-2) but provides word length flexibility (as in dbC). Neither dbC nor C* permit data manipulation at the bit level. A *C++ compiler which is closely coupled to the MGAP architecture has been developed for generating parallel code. To our knowledge, *C++ is the only language which allows users to express their programs at different granularities (from the bit level to the array level) in the same high level language for SIMD array processors. A block diagram of the MGAP is shown in Fig. 1(a). Its peak performance at 25 MHz is 0.8 teraops. The local memory of each digit processor (DP) is very small (16 bits), hence the unit of data that each DP operates on is a single bit or digit rather than a full precision operand. We chose to use MRR4 number representation [2] due to its advantages [1]. As precision increases, each operand is distributed over a larger collection of DPs, referred to as a word processor (WP). Fig. 1(b) shows four different WP configurations. WPs are logical entities and the different configurations are user-programmable. Thus the architecture is programmable with respect to local interconnect, the word size and the digit size. 
Abstract-found: 1
Intro-found: 0
Reference: [1] <author> R. S. Bajwa, R. M. Owens, and M. J. Irwin. </author> <title> Image Processing with the MGAP: A Cost Effective Approach. </title> <booktitle> In Intl. Parallel Processing Symposium, </booktitle> <pages> pages 439-443, </pages> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: The local memory of each digit processor (DP) is very small (16 bits), hence the unit of data that each DP operates on is a single bit or digit rather than a full precision operand. We chose to use MRR4 number representation [2] due to its advantages <ref> [1] </ref>. As precision increases, each operand is distributed over a larger collection of DPs, referred to as a word processor (WP). Fig. 1 (b) shows four different WP configurations. WPs are logical entities and the different configurations are user-programmable.
Reference: [2] <author> M. J. Irwin and R. M. Owens. </author> <title> Digit Pipelined Arithmetic as Illustrated by the Paste-Up System. </title> <journal> IEEE Computer, </journal> <volume> 20(4) </volume> <pages> 61-73, </pages> <month> Apr. </month> <year> 1987. </year>
Reference-contexts: The local memory of each digit processor (DP) is very small (16 bits), hence the unit of data that each DP operates on is a single bit or digit rather than a full precision operand. We chose to use MRR4 number representation <ref> [2] </ref> due to its advantages [1]. As precision increases, each operand is distributed over a larger collection of DPs, referred to as a word processor (WP). Fig. 1 (b) shows four different WP configurations. WPs are logical entities and the different configurations are user-programmable.
Reference: [3] <author> M. Gokhale and R. Minnich. </author> <title> FPGA Computing in a Data Parallel C. </title> <booktitle> In FCCM, </booktitle> <pages> pages 94-102, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: To access this power easily end users must have a language with which they can exploit the features of the underlying architecture. The language we developed, *C++, is different from both C* [5] and dbC <ref> [3] </ref> in that it is used to program a machine in which the computational units are abstracted as processors (as in the CM-2) but provides word length flexibility (as in dbC). Neither dbC nor C* permit data manipulation at the bit level.
Reference: [4] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: The application development environment for the MGAP includes a compiler for *C++, a simulator for debugging parallel assembly code, an assembler, a linker, a loader and a library of low-level operations. 3.1: The *C++ Programming Language *C++ is essentially C++ <ref> [4] </ref> extended to handle parallel data types by using the class construct. All extensions are within the scope of existing C++ syntax. bit is the only primitive parallel data type and int is the only primitive scalar data-type.
Reference: [5] <institution> Thinking Machines Corporation. </institution> <note> Getting Started in C*, </note> <month> February </month> <year> 1991. </year>
Reference-contexts: To access this power easily end users must have a language with which they can exploit the features of the underlying architecture. The language we developed, *C++, is different from both C* <ref> [5] </ref> and dbC [3] in that it is used to program a machine in which the computational units are abstracted as processors (as in the CM-2) but provides word length flexibility (as in dbC). Neither dbC nor C* permit data manipulation at the bit level.
References-found: 5

