URL: http://www.cs.wustl.edu/cs/techreports/1998/wucs-98-10.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Title: TCP/IP Implementation with Endsystem QoS  
Author: Sherlia Y. Shi Gurudatta M. Parulkar R. Gopalakrishnan 
Address: in St. Louis  
Affiliation: Department of Computer Science Washington University  AT&T Research Lab  
Abstract: This paper presents a Real-time Upcall (rtu) [1] based tcp/ip implementation that guarantees throughput for continuous media applications and ensures low latency bounds for interactive applications. rtu is an endsystem rate-based scheduling mechanism that provides quality of service (qos), in terms of cpu cycles, to applications. We restructured the existing netbsd tcp/ip implementation to exploit the rtu concurrency model and to provide predictable performance. Our experimental results show that on two 200 MHz netbsd pcs connected by a 155Mbps atm link, the rtu based kernel tcp/ip implementation provides excellent throughput guarantees for periodic connections regardless the system or network load. The round trip time (rtt) for low-delay connections with message size of 1 kb is typically as low as 600 micro seconds, and only increases slowly with increasing system load. Another important result is that this performance is preserved even when all three type of connections coexist in our testbed: the periodic connection is guaranteed its share of bandwidth, the low-delay connection achieves low rtt of 1.2 msec, while the best-effort connection still makes steady progress.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Gopalakrishnan and G.M. Parulkar. </author> <title> Design and Implementation of a Real Time Upcall Mechanism. </title> <type> Technical report, </type> <institution> Washington University in St. Louis, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: this problem is to use admission control mechanism to reserve a certain amount of cpu bandwidth for best-effort connections. 1.2 Previous work and our motivations Real-time Upcall (rtu) is a novel scheduling mechanism that uses a priority-based scheduling policy to allocate cpu cycles to applications in a periodic guaranteed manner <ref> [1] </ref>. Furthermore, rtu reduces the cost of context switches by adopting a delay preemption policy. <p> The rtu scheduler uses Rate-monotonic with Delayed Preemption (rmdp) policy that exploits the iterative nature of protocol processing to reduce context switching overhead and to increase endsystem efficiency. More details of the rtu mechanism can be found in <ref> [1] </ref>. In this section, we briefly introduce the necessary background information by first examining how the cpu requirements of protocol processing can 3 be characterized with a periodic processing model. <p> The application then creates user level rtus to handle data transmission or receiving via the rtu system call interfaces <ref> [1] </ref> and associates qos with the user level rtu. These qos parameters are also recorded in the rtu control block (rcb) associated with this connection, for the reason we discussed below. The application then calls connect () to establish a connection to the other end host.
Reference: [2] <author> L. Zhang and et. al. Rsvp: </author> <title> A new resource reservation protocol. </title> <journal> IEEE Network, </journal> <pages> pages 8-18, </pages> <year> 1993. </year>
Reference-contexts: Providing qos for multimedia applications is essentially an end-to-end issue but can be decoupled into two parts: qos provision in networks and in endsystems. Protocols such as rsvp <ref> [2] </ref> have been proposed to manage network resources efficiently and to support different classes of application specific qos.
Reference: [3] <author> R. Gopalakrishnan and G.M. Parulkar. </author> <title> Efficient User Space Protocol Implementations with QoS Guarantees using Real-time Upcalls. </title> <type> Technical report, </type> <institution> Washington University in St. Louis, </institution> <year> 1996. </year>
Reference-contexts: Furthermore, rtu reduces the cost of context switches by adopting a delay preemption policy. The design and implementation details of the rtu mechanism are deferred to Section 3. rtu has been used to implement the tcp/ip protocol suite in the user space <ref> [3] </ref>, and experimental results show that the restructured protocol processing reliably provides qos guarantees. However, for reasons such as efficiency and security, protocol suites continue to be kernel-resident. Applications and middleware, such as corba, often rely on the standard socket system call interface. <p> Furthermore, real-time os, such as Solaris, only provides a fixed number of priority levels and is not geared towards the periodic scheduling of various multimedia applications. Another approach of supporting different priorities in protocol processing is to implement the protocol stack as a user library <ref> [3, 10, 11, 12, 13] </ref>. As a result, communication protocol processing becomes an extension of process threads and can be treated as fully preemptive blocks by the os scheduler.
Reference: [4] <author> K.Jeffey. </author> <title> On kernel support for real-time multimedia applications. </title> <booktitle> In Proc. Third IEEE Workshop on Workstation Operating Systems, </booktitle> <pages> pages 39-46, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In section 5, we presents our rtu based tcp/ip architecture. Implementation details and experimental results are given in section 6 and 7. Section 8 concludes the paper. 2 2 Related Work Earlier work in <ref> [4, 5] </ref> identifies the time constraints and computation requirements of continuous media applications, and introduces cpu scheduling mechanisms to support real-time communication and computation services including data computations, I/O services, and communication protocol processing.
Reference: [5] <author> R. Govindan and D.P. Anderson. </author> <title> Scheduling and ipc mechanisms for continuous media. </title> <booktitle> In 13 th ACM Symposium on Operating Systems Principles, </booktitle> <year> 1991. </year>
Reference-contexts: In section 5, we presents our rtu based tcp/ip architecture. Implementation details and experimental results are given in section 6 and 7. Section 8 concludes the paper. 2 2 Related Work Earlier work in <ref> [4, 5] </ref> identifies the time constraints and computation requirements of continuous media applications, and introduces cpu scheduling mechanisms to support real-time communication and computation services including data computations, I/O services, and communication protocol processing.
Reference: [6] <author> J. </author> <title> Nieh and M.S. Lan. The design, implementation and evaluation of smart: A scheduler for multimedia applications. </title> <booktitle> In the 6 th ACM Symposium on Operating Systems Principles, </booktitle> <month> Oct </month> <year> 1997. </year>
Reference-contexts: More recent work in os scheduling support for multimedia applications addresses a richer set of qos requirements <ref> [6, 7] </ref>, where the support for real-time applications is integrated with the support for interactive and conventional applications. Protocol processing in multimedia systems constitutes a relative large part of the total computation time required by multimedia applications. Lots of work has been done in supporting real-time protocol processing.
Reference: [7] <author> P. Goyal, X. Guo, and H.M. Vin. </author> <title> A hierarchical cpu scheduler for multimedia operating systems. </title> <booktitle> In Symposium on Operating Systems Design and Implementation, </booktitle> <year> 1997. </year>
Reference-contexts: More recent work in os scheduling support for multimedia applications addresses a richer set of qos requirements <ref> [6, 7] </ref>, where the support for real-time applications is integrated with the support for interactive and conventional applications. Protocol processing in multimedia systems constitutes a relative large part of the total computation time required by multimedia applications. Lots of work has been done in supporting real-time protocol processing.
Reference: [8] <author> H. Tokuda and C.W Mercer. </author> <title> Arts: A distributed real-time kernel. </title> <booktitle> ACM Operating Systems Review, </booktitle> <pages> pages 29-53, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Protocol processing in multimedia systems constitutes a relative large part of the total computation time required by multimedia applications. Lots of work has been done in supporting real-time protocol processing. In <ref> [8, 9] </ref>, real-time threads are used for prioritized protocol processing. Each thread handles a different priority class and the priority of the thread matches the priority of the packets it handles. The disadvantage of using multithreading is its context switching overheads due to the preemptive scheduling required for real-time threads.
Reference: [9] <author> N.C Hutchinson and L.L Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEE Transactions on Software Engineering, </journal> <pages> pages 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Protocol processing in multimedia systems constitutes a relative large part of the total computation time required by multimedia applications. Lots of work has been done in supporting real-time protocol processing. In <ref> [8, 9] </ref>, real-time threads are used for prioritized protocol processing. Each thread handles a different priority class and the priority of the thread matches the priority of the packets it handles. The disadvantage of using multithreading is its context switching overheads due to the preemptive scheduling required for real-time threads.
Reference: [10] <author> C. Lee, K. Yoshida, C.W. Mercer, and R. Rajkumar. </author> <title> Predictable communication protocol processing in real-time mach. </title> <booktitle> In Real-time Technology and Applications Symposium RTAS, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Furthermore, real-time os, such as Solaris, only provides a fixed number of priority levels and is not geared towards the periodic scheduling of various multimedia applications. Another approach of supporting different priorities in protocol processing is to implement the protocol stack as a user library <ref> [3, 10, 11, 12, 13] </ref>. As a result, communication protocol processing becomes an extension of process threads and can be treated as fully preemptive blocks by the os scheduler.
Reference: [11] <author> C. Maeda and B.N. Bershad. </author> <title> Protocol service decomposition for high performance networking. </title> <booktitle> In 14 th aCM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-55, </pages> <month> Dec </month> <year> 1993. </year>
Reference-contexts: Furthermore, real-time os, such as Solaris, only provides a fixed number of priority levels and is not geared towards the periodic scheduling of various multimedia applications. Another approach of supporting different priorities in protocol processing is to implement the protocol stack as a user library <ref> [3, 10, 11, 12, 13] </ref>. As a result, communication protocol processing becomes an extension of process threads and can be treated as fully preemptive blocks by the os scheduler.
Reference: [12] <author> C.A. Thekkath, T.D. Nguyen, E. Moy, and E.D. Lazowska. </author> <title> Implementing network protocols at user level. </title> <booktitle> In ACM SIGCOMM, </booktitle> <month> Sept 93. </month>
Reference-contexts: Furthermore, real-time os, such as Solaris, only provides a fixed number of priority levels and is not geared towards the periodic scheduling of various multimedia applications. Another approach of supporting different priorities in protocol processing is to implement the protocol stack as a user library <ref> [3, 10, 11, 12, 13] </ref>. As a result, communication protocol processing becomes an extension of process threads and can be treated as fully preemptive blocks by the os scheduler.
Reference: [13] <author> D. Yau and S.S. Lam. </author> <title> An architecture towards efficient os support for distributed multimedia. </title> <booktitle> In Proc. IS&T/SPIE Multimedia Computing and Networking Conference, </booktitle> <address> San Jose, CA, </address> <month> Jan </month> <year> 1996. </year> <note> [14] http://www.cs.arizona.edu/scout/. </note>
Reference-contexts: Furthermore, real-time os, such as Solaris, only provides a fixed number of priority levels and is not geared towards the periodic scheduling of various multimedia applications. Another approach of supporting different priorities in protocol processing is to implement the protocol stack as a user library <ref> [3, 10, 11, 12, 13] </ref>. As a result, communication protocol processing becomes an extension of process threads and can be treated as fully preemptive blocks by the os scheduler.
Reference: [15] <author> A. Mehra, A. Indiresan, and K.G. Shin. </author> <title> Structuring communication software for quality-of-service guarantees. </title> <booktitle> In 17 th Real-Time Systems Symposium, </booktitle> <month> Dec </month> <year> 1996. </year>
Reference-contexts: The Scout os [14] uses the notion of paths to associate resource requirements with the flow processing components. In <ref> [15] </ref>, a similar idea of process-per-channel is used. qos for multiple channels are provided via appropriate cpu scheduling of channel handlers. However, work in [15] only provides coarse grained qos support, in that flows are classified as real-time or best-effort, and fifo scheduling is used within each class. <p> The Scout os [14] uses the notion of paths to associate resource requirements with the flow processing components. In <ref> [15] </ref>, a similar idea of process-per-channel is used. qos for multiple channels are provided via appropriate cpu scheduling of channel handlers. However, work in [15] only provides coarse grained qos support, in that flows are classified as real-time or best-effort, and fifo scheduling is used within each class.
Reference: [16] <author> K. Jeffay and D. Bennett. </author> <title> A rate-based execution abstraction for multimedia computing. </title> <booktitle> In NOSSDAV, </booktitle> <year> 1995. </year>
Reference-contexts: Although qos requirements vary among applications, they can be realized using the periodic processing model shown in Figure 1. Numerous proposals have been made for multimedia computing processing models. <ref> [16] </ref> We choose the periodic model because it is easy to implement and adequate for analysis.
Reference: [17] <author> R. Gopalakrishnan and G.M. Parulkar. </author> <title> Bringing Real-time Scheduling Theory and Practice Closer for Multimedia Computing. </title> <booktitle> ACM SIGMETRICS, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: The scheduler ensures that at least one, and up to B p , pdus will be processed in a period, depending on the system load. 3.2 The RMDP Scheduling Policy A complete analysis of Rate-Monotonic with Delayed Preemption (rmdp) scheduling can be found in <ref> [17] </ref>. We illustrate this policy only briefly to aid understanding of some of our experimental results. processing by treating each iteration as an atomic operation. Preemptions only occur at the boundaries of data units where no data locking is required.
Reference: [18] <author> D. D. Clark. </author> <title> The structuring of systems using upcalls. </title> <booktitle> In 15 th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 171-180, </pages> <month> dec </month> <year> 1985. </year>
Reference-contexts: misbehaving rtu handler by ensuring that: (1) an rtu handler invocation does not run past its stated computation time; and (2) an rtu yields the cpu when it is requested to do so. 3.3 The Real-Time Upcall Approach The upcall mechanism is a well recognized operation for efficient protocol implementation <ref> [18] </ref>.
Reference: [19] <author> J.C. Brustoloni and P. Steenkiste. </author> <title> Evaluation of data passing and scheduling avoidance. </title> <booktitle> In NOSSDAV, </booktitle> <year> 1997. </year>
Reference-contexts: However, such unscheduled processing may cause unpredictable behavior and may jeopardize the system normal scheduling, so techniques must be used to prevent reactive rtus from monopolizing the cpu <ref> [19] </ref>.
Reference: [20] <author> M.K. Mckusick, K. Bostic, M.J. Karels, and J.S. Quarterman. </author> <title> The Design and Implementation of the 4.4 BSD Operating System. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: problems that need to be solved to achieve efficient real-time protocol processing with qos guarantees as follows. * Concurrency control between protocol and application data processing For security reasons, operating systems usually execute kernel-level code in a protected mode, and enforce kernel- and user-level code boundaries using hardware protection facilities <ref> [20] </ref>. As the kernel provides basic system 6 facilities, controls user programs to access underlying hardware (e.g. network links, disks) and software constructs (e.g. protocols, filesystems), it executes at a higher priority than the user-level code.
Reference: [21] <author> C. Partridge. </author> <title> A Proposed Flow Specification, rfc-1363. Internet Request for Comments, </title> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: This computation time is specified in terms of number of adus and passed to the rtu scheduler during the rtu initiation. There are more sophisticated qos flow specifications, which include other qos parameters such as flow jitter, loss sensitivities, traffic shaping, etc., <ref> [21] </ref> and qos adaptation schemes, which allow systems to dynamically raise or reduce qos depending on resource availability and user requirements [22].
Reference: [22] <author> A.T. Campbell and G. Coulson. </author> <title> A qos adaptive multimedia transport system: Design, implementation and experiences. </title> <journal> Distributed Systems Engineering Journal Special Issue on Quality of Service, </journal> <month> april </month> <year> 1997. </year>
Reference-contexts: There are more sophisticated qos flow specifications, which include other qos parameters such as flow jitter, loss sensitivities, traffic shaping, etc., [21] and qos adaptation schemes, which allow systems to dynamically raise or reduce qos depending on resource availability and user requirements <ref> [22] </ref>. In this paper, we are mainly focusing on how qos can be enforced in the endsystem based on our integration of protocol processing with real-time scheduling, rather than providing an entirety of qos transport system.
Reference: [23] <author> G.R. Wright and W.R. </author> <title> Stevens. </title> <journal> TCP/IP Illustrated, </journal> <volume> Volume 2. </volume> <publisher> Addison Wesley, </publisher> <year> 1995. </year> <month> 18 </month>
Reference-contexts: Since our implementation focuses on the tcp/ip data transfer path, the protocol control path including connection establishment, connection tear down, flow and congestion control, and other protocol optimizations are left unchanged <ref> [23] </ref>. In the rest of this section, we describe the operations of rtus for the duration of a tcp connection (rtutcp). 10 The Connection Establishment: An application creates a socket via the socket () system call with rtutcp as the attached protocol.
References-found: 22

