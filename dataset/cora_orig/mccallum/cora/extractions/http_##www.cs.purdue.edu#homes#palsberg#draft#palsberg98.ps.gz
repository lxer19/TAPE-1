URL: http://www.cs.purdue.edu/homes/palsberg/draft/palsberg98.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Title: CPS Transformation of Flow Information  
Author: Jens Palsberg 
Date: July 24, 1998  
Affiliation: Purdue University  
Abstract: How does a continuation-passing-style (CPS) transformation change the flow analysis of a program? This has been studied by Nielson, Filho et al, and Sabry and Felleisen. Their work indicates that the flow information sometimes gets better and sometimes gets worse. In this paper we present an algorithm for CPS transformation of flow information. From the least solution to the flow constraints of a program, our algorithm constructs the least solution to the flow constraints for the CPS-transformed program. Our algorithm has the property that for a program point in the original program and the corresponding program point in the CPS-transformed program, the flow information is the same. Thus, the algorithm does not change the flow information, it merely extends it to cover the new program points. For a compiler that needs flow information after CPS transformation, our algorithm can help save time. Rather than analyzing the CPS-transformed program, it can instead CPS transform flow information for the source program.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Michael Ashley. </author> <title> A practical and flexible flow analysis for higher-order languages. </title> <booktitle> In Proc. POPL'96, 23nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-194, </pages> <year> 1996. </year>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>.
Reference: [2] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: Labels and overlinings are not affected by fi-reduction. A program is a closed expression. We assume Barendregt's Variable Convention <ref> [2] </ref>: when a -term occurs in this article, all bound variables are chosen to be different from the free variables. This can be achieved by renaming bound variables.
Reference: [3] <author> Anders Bondorf and Jesper Jtrgensen. </author> <title> Efficient analyses for realistic off-line partial evaluation. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3) </volume> <pages> 315-346, </pages> <year> 1993. </year>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>. <p> applying the Weakening lemma to get a derivation-tree for A 6 ` [[e 2 ]] : (s * ! o) ! o. 4 The Result The following definition expresses that the flow information in a derivation-tree T is equality-based flow information in the style of, for example, Bondorf and Jtrgensen <ref> [3] </ref>, Heintze [8], and Defouw, Grove, and Chambers [5].
Reference: [4] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Representing control, a study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <year> 1992. </year>
Reference-contexts: We address the question: Question: Can we CPS transform flow information? Our result is that for: * a simply-typed -calculus, * an equality-based monovariant constraint-based flow-analysis, and * Plotkin's call-by-value CPS transformation [14], in the variant introduced by Danvy and Filinski <ref> [4] </ref>, we present an algorithm for CPS transformation flow information. From the least solution to the flow constraints of a program, our algorithm constructs the least solution to the flow constraints for the CPS-transformed program. <p> Since T 00 j= types (T 00 ), we have T 1 j= types (T 1 ), so T v T 1 , and hence T = T 1 . We conclude that F (T ) = F (T 1 ) = T 00 . Danvy and Filinski <ref> [4] </ref> explained that all administrative reductions can be performed "on the fly" in a single pass. By combining Theorem 4.5 and Theorem 4.10, we get that if we begin with a least type-derivation, then we will afterwards still have a least type-derivation. Acknowledgments.
Reference: [5] <author> Greg DeFouw, David Grove, and Craig Chambers. </author> <title> Fast interprocedural class analysis. </title> <booktitle> In Proc. POPL'98, 25th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 222-236, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>. <p> for A 6 ` [[e 2 ]] : (s * ! o) ! o. 4 The Result The following definition expresses that the flow information in a derivation-tree T is equality-based flow information in the style of, for example, Bondorf and Jtrgensen [3], Heintze [8], and Defouw, Grove, and Chambers <ref> [5] </ref>.
Reference: [6] <author> Filho, J. Muylaert, and G. Burn. </author> <title> Continuation passing transformation and abstract interpretation. </title> <booktitle> In Proc. First Imperial College, Department of Computing, Workshop on Theory and Formal Methods, </booktitle> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Background How does a continuation-passing-style (CPS) transformation change the flow analysis of a program? This has been studied by Nielson [11], Filho et al <ref> [6] </ref>, and Sabry and Felleisen [15]. In a seminal paper, Nielson [11] showed for an imperative language that an analysis based on a continuation semantics can be more precise than an analysis based on a direct semantics. Similarly, Filho, Muylaert, and Burn [6] showed for a call-by-name language that CPS transformation <p> been studied by Nielson [11], Filho et al <ref> [6] </ref>, and Sabry and Felleisen [15]. In a seminal paper, Nielson [11] showed for an imperative language that an analysis based on a continuation semantics can be more precise than an analysis based on a direct semantics. Similarly, Filho, Muylaert, and Burn [6] showed for a call-by-name language that CPS transformation can improve an analysis. Sabry and Felleisen [15] analyzed the source of these improvements and they concluded that the gain in precision is solely due to the duplication of the analysis of continuations.
Reference: [7] <author> Carsten K. Gomard and Neil D. Jones. </author> <title> A partial evaluator for the untyped lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <year> 1991. </year> <month> 12 </month>
Reference-contexts: First all overlined constructs are reduced away using arbitrary fi-reduction, denoted by ! ar , where ar stands for "administrative reduction." If the type of the target program does not contain the overlined type constructor, then indeed all overlined constructs can be reduced away <ref> [7] </ref>. If this happens, then the residual program is in the source-language subset.
Reference: [8] <author> Nevin Heintze. </author> <title> Control-flow analysis and type systems. </title> <booktitle> In Proc. SAS'95, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS 983), </publisher> <address> Glasgow, Scotland, </address> <month> Septem-ber </month> <year> 1995. </year>
Reference-contexts: We can now annotate the function type constructor with flow information in the style promoted by Wells, Dimock, Muller, and Turbak [20, 18], building on ideas of Heintze <ref> [8] </ref>. The idea is that if an expression has the type s ! t then ' is a set of labels of -abstractions to which the expression can evaluate, and is a set of labels of application points where those -abstractions can be applied. <p> Weakening lemma to get a derivation-tree for A 6 ` [[e 2 ]] : (s * ! o) ! o. 4 The Result The following definition expresses that the flow information in a derivation-tree T is equality-based flow information in the style of, for example, Bondorf and Jtrgensen [3], Heintze <ref> [8] </ref>, and Defouw, Grove, and Chambers [5].
Reference: [9] <author> Nevin Heintze and David McAllester. </author> <title> Linear-time subtransitive control flow analysis. </title> <booktitle> In Proc. ACM SIGPLAN 1997 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 261-272, </pages> <year> 1997. </year>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>.
Reference: [10] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda-calculi. </title> <booktitle> In Proc. Logics of Programs, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag (LNCS 193), </publisher> <year> 1985. </year>
Reference-contexts: From the classical paper by Meyer and Wand <ref> [10] </ref>, we have that if A ` e : t, then A * ` [[e]] : (t * ! o) ! o, where o is a type of answers, where t * is defined inductively: ff * = ff and where A * (x) = t * if A (x) =
Reference: [11] <author> Flemming Nielson. </author> <title> A denotational framework for data flow analysis. </title> <journal> Acta Informatica, </journal> <volume> 18 </volume> <pages> 265-287, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction 1.1 Background How does a continuation-passing-style (CPS) transformation change the flow analysis of a program? This has been studied by Nielson <ref> [11] </ref>, Filho et al [6], and Sabry and Felleisen [15]. In a seminal paper, Nielson [11] showed for an imperative language that an analysis based on a continuation semantics can be more precise than an analysis based on a direct semantics. <p> 1 Introduction 1.1 Background How does a continuation-passing-style (CPS) transformation change the flow analysis of a program? This has been studied by Nielson <ref> [11] </ref>, Filho et al [6], and Sabry and Felleisen [15]. In a seminal paper, Nielson [11] showed for an imperative language that an analysis based on a continuation semantics can be more precise than an analysis based on a direct semantics. Similarly, Filho, Muylaert, and Burn [6] showed for a call-by-name language that CPS transformation can improve an analysis.
Reference: [12] <author> Jens Palsberg. </author> <title> Closure analysis in constraint form. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(1) </volume> <pages> 47-62, </pages> <month> January </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> CAAP'94, </editor> <booktitle> Colloquium on Trees in Algebra and Programming, </booktitle> <publisher> Springer-Verlag (LNCS 787), </publisher> <pages> pages 276-290, </pages> <address> Edinburgh, Scotland, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>.
Reference: [13] <author> Jens Palsberg and Patrick M. O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <month> July </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> POPL'95, </editor> <booktitle> 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-378, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>.
Reference: [14] <author> Gordon D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: We address the question: Question: Can we CPS transform flow information? Our result is that for: * a simply-typed -calculus, * an equality-based monovariant constraint-based flow-analysis, and * Plotkin's call-by-value CPS transformation <ref> [14] </ref>, in the variant introduced by Danvy and Filinski [4], we present an algorithm for CPS transformation flow information. From the least solution to the flow constraints of a program, our algorithm constructs the least solution to the flow constraints for the CPS-transformed program. <p> If this happens, then the residual program is in the source-language subset. If the residual program is in CPS, then there is no difference between executing it call by value or call by name <ref> [14] </ref>. 3 CPS Transformation We now define CPS transformations of terms, types, type environments, and derivation-trees. Terms.
Reference: [15] <author> Amr Sabry and Matthias Felleisen. </author> <title> Is continuation-passing useful for data flow analysis? In Proc. </title> <booktitle> SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction 1.1 Background How does a continuation-passing-style (CPS) transformation change the flow analysis of a program? This has been studied by Nielson [11], Filho et al [6], and Sabry and Felleisen <ref> [15] </ref>. In a seminal paper, Nielson [11] showed for an imperative language that an analysis based on a continuation semantics can be more precise than an analysis based on a direct semantics. Similarly, Filho, Muylaert, and Burn [6] showed for a call-by-name language that CPS transformation can improve an analysis. <p> Similarly, Filho, Muylaert, and Burn [6] showed for a call-by-name language that CPS transformation can improve an analysis. Sabry and Felleisen <ref> [15] </ref> analyzed the source of these improvements and they concluded that the gain in precision is solely due to the duplication of the analysis of continuations. <p> For example, at a call site and at a conditional the continuation may be duplicated for each possible path, thereby enabling separate analysis for each copy. Sabry and Felleisen <ref> [15] </ref> also showed that a CPS transformation can decrease the precision of an analysis. <p> During that final call, both a 1 and a 2 gets bound to the merge of 1 and 2. Sabry and Felleisen state that "the loss of information is due to the confusion of distinct procedure returns" <ref> [15] </ref>. For example, the two calls (f 1) and (f 2) become confused in the CPS program. Programs can be analyzed in other ways than by an operational abstract interpretation.
Reference: [16] <author> Peter Sestoft. </author> <title> Analysis and Efficient Implementation of Functional Programs. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>.
Reference: [17] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, CMU, </type> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>.
Reference: [18] <author> Franklyn Turbak, Allyn Dimock, Robert Muller, and Joe Wells. </author> <title> Compiling with polymorphic and polyvariant flow types. </title> <booktitle> In Proc. ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: We can now annotate the function type constructor with flow information in the style promoted by Wells, Dimock, Muller, and Turbak <ref> [20, 18] </ref>, building on ideas of Heintze [8].
Reference: [19] <author> Mitchell Wand and Paul Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In Proc. POPL'94, 21st Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 434-445, </pages> <year> 1994. </year>
Reference-contexts: Such analyses have the purpose of conservatively answering such questions as: 1) at a call site, which functions can be applied?, and 2) for a function, at which call sites can it be applied? There is a substantial literature on such flow analysis, for example <ref> [17, 16, 1, 3, 9, 12, 13, 19, 5] </ref>.
Reference: [20] <author> Joe Wells, Allyn Dimock, Robert Muller, and Franklyn Turbak. </author> <title> A typed intermediate language for flow-directed compilation. </title> <booktitle> In Proc. TAPSOFT'97, Theory and Practice of Software Development. </booktitle> <publisher> Springer-Verlag (LNCS ), 1997. </publisher> <pages> 13 </pages>
Reference-contexts: We can now annotate the function type constructor with flow information in the style promoted by Wells, Dimock, Muller, and Turbak <ref> [20, 18] </ref>, building on ideas of Heintze [8]. <p> The type rules for the source language are rules (1)-(3), and only source-language types can be used. The set of source-language derivation-trees is denoted by DerivTree (Source). Notice that DerivTree (Source) DerivTree. Source programs are executed call by value. Subject Reduction has been proved in <ref> [20] </ref>. Target programs are intended to be executed in two stages.
References-found: 20

