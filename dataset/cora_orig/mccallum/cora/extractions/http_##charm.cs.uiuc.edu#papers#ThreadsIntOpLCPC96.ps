URL: http://charm.cs.uiuc.edu/papers/ThreadsIntOpLCPC96.ps
Refering-URL: http://charm.cs.uiuc.edu/papers/ThreadsIntOpLCPC96.html
Root-URL: http://www.cs.uiuc.edu
Email: jyelon@cs.uiuc.edu, kale@cs.uiuc.edu  
Title: Threads for Interoperable Parallel Programming  
Author: L. V. Kale, J. Yelon, and T. Knauff 
Address: Urbana Illinois 61801,  
Affiliation: Dept. of Computer Science, University of Illinois,  
Abstract: Many thread packages are freely available on the Internet. Yet, most parallel language design groups seem to have rejected all existing packages and implemented their own. This is unsurprising. Existing thread packages were designed for sequential computers, not parallel machines, and do not fit well in a parallel environment. Also importantly, existing thread packages try to impose a number of design decisions, especially in regard to scheduling and preemption. Designers of parallel languages are simply not willing to have scheduling methods decided for them, nor are they willing to allow the threads package to decide how concurrency control will work. In this paper, we explore the special issues raised when threads packages are used on parallel machines, particularly as parts of new parallel languages and systems. We describe the Converse threads subsystem, whose goals are to support the special needs of parallel programs, and to support interoperability among parallel languages. We then demonstrate how the Converse threads subsystem addresses the problems created when threads are used on a parallel computer.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Ball and S. Hoyt. </author> <title> The Adaptive Time-Warp Concurrency Control Algorithm. </title> <booktitle> In Proceedings of the SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 174-177, </pages> <year> 1990. </year>
Reference-contexts: The following programming models have been implemented with the help of Converse: Charm++ [5], based on remote method invocation, IMPORT [9], a successor to Modsim, using time-warp <ref> [1] </ref> methodology, - SMT, a message-passing threads model, - PVM [15], a simple but popular message-passing model - DP [7], a data-parallel Fortran-based language Of these languages, Charm++ uses stackless threads unless the programmer explicitly creates a Cth thread, DP and IMPORT use stackless threads exclusively, and SMT and PVM are
Reference: 2. <author> M. Haines, D. Cronk, and P. Mehrotra. </author> <title> On the design of Chant: A talking threads package. </title> <booktitle> In Proceedings of Supercomputing 1994, </booktitle> <month> Nov </month> <year> 1994. </year>
Reference-contexts: An interesting style of parallel programming is the model where threads on different processors communicate by sending messages to each other. Chant <ref> [2] </ref> is an example of a prominent system that supports such a capability. In this section, we describe a simple "language" that supports threads sending messages to and receiving messages from each other. This language supports a subset of the features of Chant, and so is easier to describe here.
Reference: 3. <author> R. Halstead. </author> <title> Multilisp: A Language for Concurrent Symbolic Computation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <month> October </month> <year> 1985. </year>
Reference-contexts: Expanding the SMT runtime to provide most of the features of the Chant runtime is straightforward. The implementation techniques described in this section can be directly used to implement runtime systems for several thread-based languages including Mul-tiLisp <ref> [3] </ref>, Cid [10], and so forth. The ease of their implementation, using the Converse facilities, and the automatic interoperability provided by the framework, suggests that one will be able to run multilingual programs in near future, each module implemented using the language that suits its structure the best.
Reference: 4. <author> L.V. Kale, M. Bhandarkar, N. Jagathesan, S. Krishnan, and J. Yelon. </author> <title> Converse: An Interoperable Framework for Parallel Programming. </title> <note> In International Parallel Processing Symposium 1996 (to appear), </note> <year> 1996. </year>
Reference-contexts: Converse commits to a model which acknowledges the fact that several levels of sharing are possible, each with its own advantages. Converse therefore provides primitives to declare and access data at each level of sharing. 2 Converse Threads Subsystem Converse <ref> [4] </ref> is a machine interface for parallel systems and languages. <p> Chief among these resources is CPU time itself. An important part of Converse's mechanisms for allocating and managing CPU time is the Converse threads subsystem, which is the focus of this paper. The other parts of Converse are discussed elsewhere <ref> [4] </ref>. The Converse threads subsystem is not a threads package in the traditional sense of the phrase. It includes some software, to be sure, but its goal is not just to provide some useful subroutines. <p> However, this would not adequately demonstrate their special properties. Instead, we demonstrate them in the context of a multi-language program with message-passing and other concurrency mechanisms. Therefore, we briefly describe the Converse scheduling and messaging subsystems <ref> [4] </ref>, which together with the threads make up the heart of Converse. The Converse scheduler is much like the scheduler for a normal threads package. However, in addition to regular threads, the Converse scheduler supports stackless threads. <p> Some use varying buffer-management policies which are more efficient than this one (Converse has a variety of buffer management policies designed to minimize overhead). Further information about Converse's messaging mechansisms and buffering policies can be found in <ref> [4] </ref>.
Reference: 5. <author> L.V. Kale and Sanjeev Krishnan. </author> <title> Charm++ : A portable concurrent object oriented system based on C++. </title> <booktitle> In Proceedings of the Conference on Object Oriented Programmi ng Systems, Languages and Applications, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: In doing so, we demonstrated the feasibility and simplicity of implementing multithreaded languages using the Converse threads subsystem and the remainder of the Converse framework. The following programming models have been implemented with the help of Converse: Charm++ <ref> [5] </ref>, based on remote method invocation, IMPORT [9], a successor to Modsim, using time-warp [1] methodology, - SMT, a message-passing threads model, - PVM [15], a simple but popular message-passing model - DP [7], a data-parallel Fortran-based language Of these languages, Charm++ uses stackless threads unless the programmer explicitly creates a
Reference: 6. <author> David Keppel. </author> <title> Tools and techniques for building fast portable threads packages. </title> <type> Technical Report UWCSE 93-05-06, </type> <institution> University of Washington Department of Computer Science and Engineering, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: One could attempt to devise a more sophisticated scheduler to try to handle these complex needs. However, it is obvious that such a scheduler would be language-dependent, and therefore could not be part of the threads package. Fortunately, there is at least one threads package, QuickThreads <ref> [6] </ref>, which allows one to implement one's own scheduler. Thus, each language's runtime system could contain a scheduler appropriate to its needs.
Reference: 7. <author> E. Kornkven and L.V. Kale. </author> <title> Efficient Implementation of High Performance Fortran via Adaptive Scheduling An Overview. </title> <editor> In V. K. Prasanna, V. P. Bhatkar, L. M. Patnaik, and S. K. Tripathi, editors, </editor> <booktitle> Proceedings of the 1st International Workshop on Parallel Processing. </booktitle> <publisher> Tata McGraw-Hill, </publisher> <address> New Delhi, India, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: The following programming models have been implemented with the help of Converse: Charm++ [5], based on remote method invocation, IMPORT [9], a successor to Modsim, using time-warp [1] methodology, - SMT, a message-passing threads model, - PVM [15], a simple but popular message-passing model - DP <ref> [7] </ref>, a data-parallel Fortran-based language Of these languages, Charm++ uses stackless threads unless the programmer explicitly creates a Cth thread, DP and IMPORT use stackless threads exclusively, and SMT and PVM are based upon full-fledged threads.
Reference: 8. <author> Message Passing Interface Forum. </author> <title> MPI: A Message-Passing Interface Standard, </title> <month> May </month> <year> 1994. </year>
Reference-contexts: Immediate goals for the Converse threads subsystem include a detailed analysis of the performance of the thread subsystem, possibly optimized implementations for specific platforms, an implementation of MPI <ref> [8] </ref> that runs within a set of threads, and a runtime layer for the multithreaded Cid [10] language.
Reference: 9. <author> Vance P. Morrison. </author> <title> Import/dome language reference manual. </title> <type> Technical report, US. </type> <institution> Army Corps of Engineering Research Laboratory, ASSET group., </institution> <year> 1995. </year>
Reference-contexts: In doing so, we demonstrated the feasibility and simplicity of implementing multithreaded languages using the Converse threads subsystem and the remainder of the Converse framework. The following programming models have been implemented with the help of Converse: Charm++ [5], based on remote method invocation, IMPORT <ref> [9] </ref>, a successor to Modsim, using time-warp [1] methodology, - SMT, a message-passing threads model, - PVM [15], a simple but popular message-passing model - DP [7], a data-parallel Fortran-based language Of these languages, Charm++ uses stackless threads unless the programmer explicitly creates a Cth thread, DP and IMPORT use stackless
Reference: 10. <author> Rishiyur S. Nikhil. </author> <booktitle> Parallel Symbolic Computing in Cid. In Parallel Symbolic Languages and Systems, </booktitle> <year> 1995. </year>
Reference-contexts: Expanding the SMT runtime to provide most of the features of the Chant runtime is straightforward. The implementation techniques described in this section can be directly used to implement runtime systems for several thread-based languages including Mul-tiLisp [3], Cid <ref> [10] </ref>, and so forth. The ease of their implementation, using the Converse facilities, and the automatic interoperability provided by the framework, suggests that one will be able to run multilingual programs in near future, each module implemented using the language that suits its structure the best. <p> Immediate goals for the Converse threads subsystem include a detailed analysis of the performance of the thread subsystem, possibly optimized implementations for specific platforms, an implementation of MPI [8] that runs within a set of threads, and a runtime layer for the multithreaded Cid <ref> [10] </ref> language.
Reference: 11. <author> John Plevyak, Vijay Karamcheti, Xingbin Zhang, and Andrew A. Chien. </author> <title> A hybrid execution model for fine-grained languages on distributed memory multicomputers. </title> <booktitle> In Supercomputing '95. </booktitle>
Reference-contexts: However, thread-packages which have the compiler's support can be significantly more efficient, as is demonstrated by such languages as Concert <ref> [11] </ref>. It therefore seems likely that popular compilers like gcc will eventually be extended to include support for high-speed threads. However, by the time this occurs, most users will already be using a conventional thread package.
Reference: 12. <editor> PORTS- POrtable Runtime System consortium. </editor> <title> The PORTS0 Interface. </title> <type> Technical report, </type> <month> Jan </month> <year> 1995. </year>
Reference: 13. <institution> POSIX System Application Program Interface: </institution> <note> Threads Extension to C Language. Technical Report POSIX 1003.4a Draft 8, Available from the IEEE Standards Department. </note>
Reference: 14. <author> M. L. Powell, S. R. Kleiman, S. Barton, D. Shah, D. Stein, and M. Weeks. </author> <title> SunOS Multi-thread Architecture. </title> <booktitle> In Proceedings of the Winter 1991 USENIX Conference. </booktitle>
Reference-contexts: Therefore, thread-packages for parallel computers make inconsistent decisions about global variables. For example, Solaris threads <ref> [14] </ref> treats global variables as shared across threads, whereas the Convex vendor-supplied threads treat them as private. Other thread packages have other policies. The prac-tical consequence for those attempting to write portable code is this: global variables have completely unpredictable behavior, and therefore, undefined semantics.
Reference: 15. <author> V.S. Sunderam. </author> <title> PVM: A Framework for Parallel Distributed Computing. </title> <journal> Con-currency: Practice and Experience, </journal> <volume> 2(4), </volume> <month> December </month> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The following programming models have been implemented with the help of Converse: Charm++ [5], based on remote method invocation, IMPORT [9], a successor to Modsim, using time-warp [1] methodology, - SMT, a message-passing threads model, - PVM <ref> [15] </ref>, a simple but popular message-passing model - DP [7], a data-parallel Fortran-based language Of these languages, Charm++ uses stackless threads unless the programmer explicitly creates a Cth thread, DP and IMPORT use stackless threads exclusively, and SMT and PVM are based upon full-fledged threads.
References-found: 15

