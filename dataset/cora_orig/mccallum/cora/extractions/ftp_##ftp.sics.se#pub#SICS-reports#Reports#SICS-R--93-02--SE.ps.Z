URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--93-02--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Title: Implementational Issues in GCLA: A Sufficiency and the Definiens Operation  
Author: by Martin Aronsson 
Keyword: GCLA, inequality, constraints, negation  
Note: This is an extended version of a paper first published in Springer Verlags Lecture Notes in Artificial Intelligence 1993: Extensions of Logic Programming, proceedings of a workshop held in  
Address: Box 1263 S 164 28 Kista Sweden  Italy, 1992.  
Affiliation: Knowledge Based Systems Laboratory; 1993-03-22 Swedish Institute of Computer Science  Bologna,  
Pubnum: R93:02 ISSN  
Email: email: martin@sics.se  
Date: 0283-3638  
Abstract: We present algorithms for computing Asufficient substitutions and constraint sets together with the definiens operation. These operations are primitive operations in the language GCLA. The paper first defines those primitives, which together form a dual rule to SLD resolution, and then describes the different algorithms and some of their properties together with examples. One of the algorithms shows how a definition can be compiled into a representation holding all possible Asufficient substitutions/constraint sets together with their corresponding definiens. This representation makes the computation at runtime of a definiens and an Asufficient substitution/constraint set have the same complexity as the table lookup operation clause/2 in Prolog. The paper also describes the generalisation from unification (sets of equalities) to constraint sets and satisfiability of systems of equalities and inequalities. 
Abstract-found: 1
Intro-found: 1
Reference: [Aro90] <author> M. Aronsson, L-H Eriksson, A. Gredal, L. Hallns, P. Olin, </author> <title> The Programming Language GCLA: A Definitional Approach to Logic Programming, </title> <booktitle> New Generation Computing 7(4), </booktitle> <pages> pp 381 - 404, </pages> <year> 1990 </year>
Reference-contexts: 1. Introduction GCLA is a programming system developed at SICS for some years <ref> [Aro90, Aro92a, Kre92, HS-H90, HS-H91] </ref>. It is best regarded as a logic programming language, although it does not have the same theoretical foundation as most other logic programming languages.
Reference: [Aro91] <author> M. Aronsson, </author> <title> GCLA User's manual, </title> <type> Technical Report SICS T91:21, </type> <year> 1991 </year>
Reference: [Aro92a] <author> M. Aronsson, </author> <title> Methodology and Programming Techniques in GCLAII, </title> <booktitle> Extensions of Logic Programming: Proceedings of a workshop held at SICS, </booktitle> <month> January </month> <year> 1991, </year> <note> in Springer Lecture Notes in Artificial Intelligence. Also available as SICS Research Report R92:05. </note>
Reference-contexts: 1. Introduction GCLA is a programming system developed at SICS for some years <ref> [Aro90, Aro92a, Kre92, HS-H90, HS-H91] </ref>. It is best regarded as a logic programming language, although it does not have the same theoretical foundation as most other logic programming languages. <p> Background and Definitions Although in GCLAII <ref> [Kre92, Aro92a] </ref> the programmer is free to write any inference rule he wants, we will stick to the original rules presented in [HS-H90, HS-H91].
Reference: [Aro92b] <author> M.Aronsson, </author> <title> Implementation Issues in GCLA II, </title> <type> forthcoming SICS technical report. </type> <institution> D22 </institution>
Reference-contexts: Rules handling nonatomic conditions are those rules that do not use the definition, for example arrow right, which adds an element to the antecedent. Those rules do not use the definition, and therefore we will not further discuss the implementation of the structural rules in this paper (see <ref> [Aro92b] </ref>), but look at algorithms and representational ideas for definitions, in particular together with the definiens operation and Asufficient substitutions. Before going into detail, we define the syntax of a GCLA definition. Since we talk about inductive definitions, we have no predicates or functions, just terms and conditions.
Reference: [Dra91] <author> W. Drabent, </author> <title> Constructive Negation by Failed Answers, </title> <institution> Research Report LiTH-IDA-R-91-23, Department of Computer and Information Science, Linkping University, </institution> <year> 1991. </year>
Reference-contexts: However, when incorporating satisfiability of equalities and inequalities, there is a lot of related work in the field of constructive negation (c.f. <ref> [MN89, Dra91, Kun87, Wal87, Har91] </ref>, among others). <p> We are then able to express that two terms t 1 and t 2 are unequal, where arbitrary variables in t 1 or t 2 could be universally quantified. For example, the Prolog predicate dif/2 could be expressed either as "=([],X,Y), or as "=([Z],p (X,Y),p (Z,Z)). <ref> [Dra91] </ref> gives the notion of SLDFA resolution, which uses constraints of equalities and inequalities. <p> A negated literal L in a goal is solved by finding a set of constraints for which L is finitely failed. [Wal87] gives a treatment of negation in logic programming with constraints which in much is very similar with <ref> [Dra91] </ref>. [Har91] defines the completion of clauses on hereditary Harrop (HH) form, and discusses their properties, in particular that the completion is a HH formula itself, and thus is in the language.
Reference: [Eri92] <author> Lars-Henrik Eriksson, </author> <title> A Finitary Version of the Calculus of Partial Inductive Definitions, </title> <booktitle> Extensions of Logic Programming: Proceedings of a workshop held at SICS, </booktitle> <month> January </month> <year> 1991, </year> <note> in Springer Lecture Notes in Artificial Intelligence. Also available as SICS Research Report R92:08. </note>
Reference-contexts: Intuitively, the variable-check for s means that every clause from which Ts can be obtained by substitution, satisfies the no-extra-variable condition. D6 The variable check must be carried out to ensure that the algorithms presented here produce Asufficient substitutions. Once explicit quantifiers are introduced into the langauge, as in <ref> [Eri92] </ref>, the variable check could be replaced by explicit quantifiers. In the rest of this paper we will assume that the s considered passes the variable check. 3. Algorithms without Constraints We will present three algorithms. The first one is the original one described in [HS-H91].
Reference: [Hal91] <author> L. Hallns, </author> <title> Partial Inductive Definitions, </title> <booktitle> Theoretical Computer Science 87, </booktitle> <pages> pp 115 - 142, </pages> <year> 1991. </year>
Reference-contexts: It is best regarded as a logic programming language, although it does not have the same theoretical foundation as most other logic programming languages. While traditional logic programming languages are based on logic, GCLA is based on a more general concept of inductive definitions, called Partial Inductive Definitions <ref> [Hal91] </ref>. One of the basic ideas in GCLA is that the program, called the definition, forms a partial inductive definition, and to that definition a consequence relation is associated, denoted by -D , where D denotes a particular definition.
Reference: [HS-H90] <author> L. Hallns, P. Schroeder-Heister, </author> <title> A Proof-Theoretic Approach to Logic Programming. I, Clauses as Rules, </title> <journal> Journal of Logic and Computation vol. </journal> <volume> 1 no. 2, </volume> <pages> pp 261 - 283, </pages> <year> 1990. </year>
Reference-contexts: 1. Introduction GCLA is a programming system developed at SICS for some years <ref> [Aro90, Aro92a, Kre92, HS-H90, HS-H91] </ref>. It is best regarded as a logic programming language, although it does not have the same theoretical foundation as most other logic programming languages. <p> Background and Definitions Although in GCLAII [Kre92, Aro92a] the programmer is free to write any inference rule he wants, we will stick to the original rules presented in <ref> [HS-H90, HS-H91] </ref>. The definiens operation and the computation of Asufficient substitutions are primitive operations of GCLAII, which the user can utilize in his own inference rules, and thus these primitives must have an efficient implementation.
Reference: [HS-H91] <author> L. Hallns, P. Schroeder-Heister, </author> <title> A Proof-Theoretic Approach to Logic Programming. II, Programs as Definitions, </title> <journal> Journal of Logic and Computation vol. </journal> <volume> 1 no. 5, </volume> <pages> pp 635 - 660, </pages> <year> 1991. </year>
Reference-contexts: 1. Introduction GCLA is a programming system developed at SICS for some years <ref> [Aro90, Aro92a, Kre92, HS-H90, HS-H91] </ref>. It is best regarded as a logic programming language, although it does not have the same theoretical foundation as most other logic programming languages. <p> The corresponding inference rule is called the definition-left inference rule (D-), and it is this operation that gives GCLA most of its power compared to ordinary Horn clause logic programming systems (e.g. Prolog). The operation described in <ref> [HS-H91] </ref> is complex and laborious to perform, and it is divided into two suboperations; the definiens operation and the calculation of Asufficient substitutions. It is in the latter one much of the execution time is spent, and therefore it is of great interest to develop better algorithms for this operation. <p> It is in the latter one much of the execution time is spent, and therefore it is of great interest to develop better algorithms for this operation. Section 2 gives the background and the necessary definitions. Section 3 of the paper presents three algorithms; the 'original' one presented in <ref> [HS-H91] </ref>, and two others of which one compiles the definition into a new representation that is used to compute a definiens and an Asufficient substitution. We also present some test values and comparisons of various data, such as execution time, number of mgu's calculated, number of mgu's needed etc. <p> Background and Definitions Although in GCLAII [Kre92, Aro92a] the programmer is free to write any inference rule he wants, we will stick to the original rules presented in <ref> [HS-H90, HS-H91] </ref>. The definiens operation and the computation of Asufficient substitutions are primitive operations of GCLAII, which the user can utilize in his own inference rules, and thus these primitives must have an efficient implementation. <p> In the rest of this paper we will assume that the s considered passes the variable check. 3. Algorithms without Constraints We will present three algorithms. The first one is the original one described in <ref> [HS-H91] </ref>. Algorithm 2 is a refined version of the first, while the third one generates a new representation of the definition D to hold the possible defining conditions and Asufficient substitutions. <p> We will identify a sum (B 1 ; ... ; B n ; false) with (B 1 ; ... ; B n ). For further details on how sums and other constructs are handled the reader should consult [Kre92]. 3.1 Algorithm 1 The first algorithm was presented in <ref> [HS-H91] </ref>, and could be very inefficient. The complexity is O (n!), where n is the number of clauses considered, and '!' is the factorial operation. <p> Those two solutions would be regarded as the same, if we regard the second argument of the pair as a set. 3.1.3 Soundness That the algorithm above produces an Asufficient substitution s is proved in <ref> [HS-H91] </ref>, provided that the variable-check for s is satisfied. That it is not complete is shown by the following example: Consider the program p (1) &lt;= b1. and let A = p (X).
Reference: [Har91] <author> J. Harland, </author> <title> A Clausal Form for the Completion of Logic Programs, </title> <booktitle> Proc. of the International Conference on Logic Programming no. </booktitle> <volume> 8, </volume> <pages> pp 711 - 725, </pages> <year> 1991. </year>
Reference-contexts: However, when incorporating satisfiability of equalities and inequalities, there is a lot of related work in the field of constructive negation (c.f. <ref> [MN89, Dra91, Kun87, Wal87, Har91] </ref>, among others). <p> A negated literal L in a goal is solved by finding a set of constraints for which L is finitely failed. [Wal87] gives a treatment of negation in logic programming with constraints which in much is very similar with [Dra91]. <ref> [Har91] </ref> defines the completion of clauses on hereditary Harrop (HH) form, and discusses their properties, in particular that the completion is a HH formula itself, and thus is in the language.
Reference: [Kre92] <author> P. Kreuger, GCLAII, </author> <title> A Definitional Approach to Control,, </title> <booktitle> Extensions of Logic Programming: Proceedings of a workshop held at SICS, </booktitle> <month> January </month> <year> 1991, </year> <note> in Springer Lecture Notes in Artificial Intelligence. Also available as SICS Research Report R92:09. </note>
Reference-contexts: 1. Introduction GCLA is a programming system developed at SICS for some years <ref> [Aro90, Aro92a, Kre92, HS-H90, HS-H91] </ref>. It is best regarded as a logic programming language, although it does not have the same theoretical foundation as most other logic programming languages. <p> Background and Definitions Although in GCLAII <ref> [Kre92, Aro92a] </ref> the programmer is free to write any inference rule he wants, we will stick to the original rules presented in [HS-H90, HS-H91]. <p> We will identify a sum (B 1 ; ... ; B n ; false) with (B 1 ; ... ; B n ). For further details on how sums and other constructs are handled the reader should consult <ref> [Kre92] </ref>. 3.1 Algorithm 1 The first algorithm was presented in [HS-H91], and could be very inefficient. The complexity is O (n!), where n is the number of clauses considered, and '!' is the factorial operation. <p> This makes this algorithm have a complexity of O (2 n+1 ). A version of this algorithm is also described in <ref> [Kre92] </ref>, but without step 3) below. D8 3.2.1 Definition The heads that should be considered are those that are unifiable with the atom A considered: -H | (H &lt;= B) D and mgu (H,A) exists Call this set L.
Reference: [Kun87] <author> K. Kunen, </author> <title> Answer Sets and Negation as Failure, </title> <booktitle> Proc. of the International Conference on Logic Programming no. </booktitle> <volume> 4, </volume> <pages> pp 219 - 228, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: However, when incorporating satisfiability of equalities and inequalities, there is a lot of related work in the field of constructive negation (c.f. <ref> [MN89, Dra91, Kun87, Wal87, Har91] </ref>, among others).
Reference: [LMM88] <author> J-L. Lassez, M.J. Maher, K. Marriott, </author> <title> Unification Revisited, </title> <editor> in J. Minker, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, </address> <year> 1988. </year>
Reference-contexts: To see that satisfiability of a set of equalities and inequalities is computable and terminating, consider the algorithm below, based on Herbrands algorithm <ref> [LMM88] </ref> for computing an unifier of a set of equalities. For other algorithms see [Wal87] and [Smi91]. <p> An equation set (possible empty) is in solved form if it has the form -v 1 = t 1 , ..., v n =t n - and the v i 's are distinct variables which do not occur in the right hand side of any equation (see <ref> [LMM88] </ref> for further details). That this algorithm terminates and leaves the set in solved form is proved in [LMM88]. Our algorithm for determining satisfiability of a set of equalities and inequalities has two passes. <p> 1 = t 1 , ..., v n =t n - and the v i 's are distinct variables which do not occur in the right hand side of any equation (see <ref> [LMM88] </ref> for further details). That this algorithm terminates and leaves the set in solved form is proved in [LMM88]. Our algorithm for determining satisfiability of a set of equalities and inequalities has two passes. <p> Of course there are other, more efficient algorithms. One D16 such is to use unification combined with corouting for checking inequalities in the same manner as corouting can be used to implement dif/2 in many Prologs, in particular [Smi91] discusses a constraint system which is similar to ours. <ref> [LMM88] </ref> also treats the solving of systems of equalities and inequalities. 4.2 Algorithm 2 with Constraints To generalize algorithm 2 to handle constraints the function mgu is replaced with a check for satisfiability, and the algorithm starts with an initial constraint set instead of the empty substitution. 4.2.1 Definition Let the <p> In our case this is the generation of constraints which correspond to an empty definiens, i.e. the Asufficient constraint set to which the definiens operation is empty. <ref> [LMM88] </ref> gives a very thorough treatment of substitutions and unifiers of set of equalities and inequalities. [Smi91] defines U-constraints as universally quantified disequalities, denoted by T 1 &lt;&gt;T 2 where T 1 and/or T 2 can contain universally quantified variables, which is similar to our not-instance-relation "=.
Reference: [MN89] <author> J. Maluszynski, T. Nslund, </author> <title> Fail Substitutions for Negation as Failure, </title> <booktitle> in Proceedings of the North American Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1989 </year>
Reference-contexts: However, when incorporating satisfiability of equalities and inequalities, there is a lot of related work in the field of constructive negation (c.f. <ref> [MN89, Dra91, Kun87, Wal87, Har91] </ref>, among others).
Reference: [Smi91] <author> D.A. Smith, </author> <title> Constraint Operations for CLP(FT), </title> <booktitle> in Proc. of ICLP 8, </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: To see that satisfiability of a set of equalities and inequalities is computable and terminating, consider the algorithm below, based on Herbrands algorithm [LMM88] for computing an unifier of a set of equalities. For other algorithms see [Wal87] and <ref> [Smi91] </ref>. Especially [Smi91], where the notion of U-constraints (universally quantified disequalities) is described, is very close to the satisfiability discussed here, although he considers inequalities where arbitrary arguments of terms can be universally declared variables (see section 5). <p> To see that satisfiability of a set of equalities and inequalities is computable and terminating, consider the algorithm below, based on Herbrands algorithm [LMM88] for computing an unifier of a set of equalities. For other algorithms see [Wal87] and <ref> [Smi91] </ref>. Especially [Smi91], where the notion of U-constraints (universally quantified disequalities) is described, is very close to the satisfiability discussed here, although he considers inequalities where arbitrary arguments of terms can be universally declared variables (see section 5). Nondeterministically choose an equation from the equation set to which a numbered step applies. <p> Of course there are other, more efficient algorithms. One D16 such is to use unification combined with corouting for checking inequalities in the same manner as corouting can be used to implement dif/2 in many Prologs, in particular <ref> [Smi91] </ref> discusses a constraint system which is similar to ours. [LMM88] also treats the solving of systems of equalities and inequalities. 4.2 Algorithm 2 with Constraints To generalize algorithm 2 to handle constraints the function mgu is replaced with a check for satisfiability, and the algorithm starts with an initial constraint <p> In our case this is the generation of constraints which correspond to an empty definiens, i.e. the Asufficient constraint set to which the definiens operation is empty. [LMM88] gives a very thorough treatment of substitutions and unifiers of set of equalities and inequalities. <ref> [Smi91] </ref> defines U-constraints as universally quantified disequalities, denoted by T 1 &lt;&gt;T 2 where T 1 and/or T 2 can contain universally quantified variables, which is similar to our not-instance-relation "=.
Reference: [Wal87] <author> M. Wallace, </author> <title> Negation by Constraints: A Sound and Efficient Implementation of Negation in Deductive Databases, </title> <booktitle> in Proc. of 1987 Symposium on Logic Programming, </booktitle> <address> San Francisco, </address> <pages> pp 253 - 2633, </pages> <year> 1987 </year>
Reference-contexts: To see that satisfiability of a set of equalities and inequalities is computable and terminating, consider the algorithm below, based on Herbrands algorithm [LMM88] for computing an unifier of a set of equalities. For other algorithms see <ref> [Wal87] </ref> and [Smi91]. Especially [Smi91], where the notion of U-constraints (universally quantified disequalities) is described, is very close to the satisfiability discussed here, although he considers inequalities where arbitrary arguments of terms can be universally declared variables (see section 5). <p> However, when incorporating satisfiability of equalities and inequalities, there is a lot of related work in the field of constructive negation (c.f. <ref> [MN89, Dra91, Kun87, Wal87, Har91] </ref>, among others). <p> A negated literal L in a goal is solved by finding a set of constraints for which L is finitely failed. <ref> [Wal87] </ref> gives a treatment of negation in logic programming with constraints which in much is very similar with [Dra91]. [Har91] defines the completion of clauses on hereditary Harrop (HH) form, and discusses their properties, in particular that the completion is a HH formula itself, and thus is in the language.
References-found: 16

