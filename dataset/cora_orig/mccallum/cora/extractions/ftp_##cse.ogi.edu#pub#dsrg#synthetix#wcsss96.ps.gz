URL: ftp://cse.ogi.edu/pub/dsrg/synthetix/wcsss96.ps.gz
Refering-URL: http://www.cse.ogi.edu/DISC/projects/synthetix/publications.html
Root-URL: http://www.cse.ogi.edu
Email: E-mail: fvolanski,muller,conselg@irisa.fr  
Title: Safe Operating System Specialization: the RPC Case Study  
Author: Eugen-Nicolae Volanschi Gilles Muller Charles Consel Irisa/Inria, 
Address: F-35042 Rennes Cedex, France  
Affiliation: Campus de Beaulieu,  
Abstract: Adaptive operating systems allow one to optimize system functionalities with respect to common situations. We present an experiment aimed at optimizing the RPC implementation in Chorus by manual specialization. We show that there exist numerous opportunities for specialization and that they can lead to great improvements. Then, we discuss how this optimization can be reproduced automatically with a specializer for C programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bershad, C. Chambers, S. Eggers, C. Maeda, D. Mc-Namee, P. Pardyak, S. Savage, and E. Gun Sirer. </author> <title> SPIN an extensible microkernel for application-specific operating system services. </title> <type> Technical Report 94-03-03, </type> <institution> University of Washington, </institution> <address> Seattle, Washington, </address> <month> Febru-ary </month> <year> 1994. </year>
Reference-contexts: As new applications and hardware platforms emerge, this increasing generality penalizes performance. This conflict between generality and performance is at the basis of several research projects which are aimed at designing operating systems which can adapt to usage patterns to treat common cases efficiently <ref> [6, 9, 1, 7] </ref>. This adaptation is mainly based on customizing/specializing operating system calls with respect to some contextual information. <p> Let us examine how this requirement is addressed by the three main approaches to adaptive operating systems. In Synthesis [11], adaptation relies on templates written by the programmer. As a consequence, the specialized code may be unsafe. In the SPIN operating system <ref> [1] </ref>, extensions are written in a strongly-typed language; this makes it possible to ensure some degree of safety. Other safety aspects are handled at run time using predicates on the code.
Reference: [2] <author> C. Bryce and G. Muller. </author> <title> Matching micro-kernels to modern applications using fine-grained memory protection. </title> <booktitle> In Procedings of the seventh IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 272-279, </pages> <address> San Antonio (Tx), </address> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: For safety reasons, access from the application to this code should be restricted, even if it lies in the same address space. To do so, an approach proposed by Muller and Bryce consists of defining several domains of protection (DP) <ref> [2] </ref> within the application. This insures both protection and scalability. The specialized code is placed in a DP supervisor, and only previously declared entry points allow the application program to exploit this code.
Reference: [3] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993, </year> <pages> pages 493-501. </pages> <publisher> ACM, ACM, </publisher> <year> 1993. </year>
Reference-contexts: This new system will allow us to reproduce automatically the optimization of the RPC. 4.1 The Tempo Platform Tempo is a partial evaluator. It takes a source program written in C and parts of its input, and produces a specialized version. Tempo is an off-line partial evaluator <ref> [3, 8] </ref> in that it processes a program in two steps: during the first phase only a known/unknown division of the input is given. The program is analyzed and a transformation is associated with each program construct.
Reference: [4] <author> C. Consel, L. Hornof, F. Noel, J. Noye, and E.-N. Volan-schi. </author> <title> A uniform approach for compile-time and run-time specialization. </title> <note> Publication interne 979, </note> <institution> Irisa, Rennes, France, </institution> <month> Dec. </month> <year> 1995. </year> <booktitle> To appear in the Proceedings of the Seminar on Partial Evaluation, </booktitle> <address> Dagstuhl, </address> <year> 1996. </year>
Reference-contexts: This adaption is achieved by applying systematically specialization techniques. Performance measurements of the specialized fragments demonstrate that this approach produces major improvements (on these fragments). After briefly presenting a specializer for C programs, named Tempo <ref> [4] </ref>, we also discuss how this optimization on RPC could be done automatically using Tempo. fl This research is supported in part by France Telecom/SEPT, ARPA grant N00014-94-1-0845, and NSF grant CCR-92243375. 2 Specializing Operating Systems Trusting optimized code. <p> We are currently developing a specialization system for C programs, named Tempo <ref> [4] </ref>. Advanced features are being incorporated to process system code. This new system will allow us to reproduce automatically the optimization of the RPC. 4.1 The Tempo Platform Tempo is a partial evaluator.
Reference: [5] <author> C. Consel and F. Noel. </author> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In Proceedings of the 23 rd Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </booktitle> <address> St. Peters-burg Beach, Florida, USA, Jan. 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In the former case, a concrete value is given for each known input at compile time, and the program is specialized at compile time as well. In the latter case, the concrete values only become known at run time, and specialization relies on a strategy based on templates <ref> [5] </ref>. In both cases, the specialization process is guided by the transformations generated by the first phase. The input to the first phase is given in a binding-time context file. The values for the second phase are given in a specialization context file.
Reference: [6] <author> C. Consel, C. Pu, and J. Walpole. </author> <title> Incremental partial evaluation: The key to high performance, modularity, and portability in operating systems. </title> <booktitle> In ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 44-46, </pages> <address> Copenhagen, </address> <year> 1993. </year>
Reference-contexts: As new applications and hardware platforms emerge, this increasing generality penalizes performance. This conflict between generality and performance is at the basis of several research projects which are aimed at designing operating systems which can adapt to usage patterns to treat common cases efficiently <ref> [6, 9, 1, 7] </ref>. This adaptation is mainly based on customizing/specializing operating system calls with respect to some contextual information.
Reference: [7] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole Jr. Exok-ernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating Systems Principles, </booktitle> <year> 1995. </year>
Reference-contexts: As new applications and hardware platforms emerge, this increasing generality penalizes performance. This conflict between generality and performance is at the basis of several research projects which are aimed at designing operating systems which can adapt to usage patterns to treat common cases efficiently <ref> [6, 9, 1, 7] </ref>. This adaptation is mainly based on customizing/specializing operating system calls with respect to some contextual information.
Reference: [8] <author> N. D. Jones, C. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice Hall International, International Series in Computer Science, </booktitle> <month> June </month> <year> 1993. </year> <note> ISBN number 0-13-020249-5 (pbk). </note>
Reference-contexts: This new system will allow us to reproduce automatically the optimization of the RPC. 4.1 The Tempo Platform Tempo is a partial evaluator. It takes a source program written in C and parts of its input, and produces a specialized version. Tempo is an off-line partial evaluator <ref> [3, 8] </ref> in that it processes a program in two steps: during the first phase only a known/unknown division of the input is given. The program is analyzed and a transformation is associated with each program construct.
Reference: [9] <author> A. B. Montz, D. Mosberger, S. W. O'Malley, L. L. Pe--terson, T. A. Proebsting, and J. H. Hartman. </author> <title> Scout: A communications-oriented operating system. </title> <type> Technical Report TR-94-20, </type> <institution> University of Arizona, Tucson, Arizona, </institution> <year> 1994. </year>
Reference-contexts: As new applications and hardware platforms emerge, this increasing generality penalizes performance. This conflict between generality and performance is at the basis of several research projects which are aimed at designing operating systems which can adapt to usage patterns to treat common cases efficiently <ref> [6, 9, 1, 7] </ref>. This adaptation is mainly based on customizing/specializing operating system calls with respect to some contextual information.
Reference: [10] <author> C. Pu, T. Autrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <year> 1995. </year>
Reference-contexts: Like any optimizer, if it is semantic preserving the specializer will produce optimized code that can be trusted (if the non-specialized one is). This approach has already been applied to the HP-UX file system as reported by Pu et al. <ref> [10] </ref>. In this work, the notion of optimistic specialization is introduced. That is, at run time, when invariants become valid, they are used to specialize specific code fragments. If the invariants are invalidated, the specialized fragments are removed and the general versions are reinstalled. <p> Additionally, if the new server runs on a different architecture, we must modify the packing routines for scalar types, used during marshaling. For the runtime support, we will use the technique of guards and re-plugging presented by Pu et al. <ref> [10] </ref>. Comparison When comparing manual and automatic specialization, there are a number of differences to consider.
Reference: [11] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: An important requirement when importing code in an operating system is to ensure that it can be trusted. Let us examine how this requirement is addressed by the three main approaches to adaptive operating systems. In Synthesis <ref> [11] </ref>, adaptation relies on templates written by the programmer. As a consequence, the specialized code may be unsafe. In the SPIN operating system [1], extensions are written in a strongly-typed language; this makes it possible to ensure some degree of safety.
Reference: [12] <author> Thekkath, Lazowska, Nguyen, and Moy. </author> <title> Implementing network protocols at user lvel. </title> <type> Technical Report TR 93-03-01, </type> <institution> University of Washington, </institution> <month> 03 </month> <year> 1993. </year>
Reference-contexts: Other safety aspects are handled at run time using predicates on the code. In the context of RPC, this run-time approach is used by Thekkath et al. <ref> [12] </ref> to ensure the safety of the optimized code. This is achieved by a mechanism similar to packet filtering. In contrast, we propose to optimize system components by specializing the existing code.
References-found: 12

