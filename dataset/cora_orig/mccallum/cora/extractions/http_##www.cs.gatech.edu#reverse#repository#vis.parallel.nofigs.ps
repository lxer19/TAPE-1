URL: http://www.cs.gatech.edu/reverse/repository/vis.parallel.nofigs.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Email: E-mail: fstasko,eileeng@cc.gatech.edu  
Title: Issues in Visualization for the Comprehension of Parallel Programs  
Author: Eileen Kraemer and John T. Stasko 
Address: Atlanta, GA 30332-0280  
Affiliation: College of Computing, Georgia Institute of Technology,  
Abstract: Parallel and distributed computers are becoming more widely used. Thus, the comprehension of parallel programs is increasingly important. Understanding parallel programs is more challenging than understanding serial programs because of the issues of concurrency, scale, communications, shared resources, and shared state. In this article, we argue that the use of visualizations and animations of programs can be an invaluable asset to program comprehension. We present example problems and visualizations, showing how graphical displays can assist program understanding. We also describe the Animation Choreographer, a tool that helps programmers better comprehend the temporal characteristics of their programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ruven Brooks. </author> <title> Towards a theory of the comprehension of computer programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: A number of models, techniques, program representations, and tools have been developed to address the problems of program comprehension. In the top-down or problem-driven model [5], program comprehension is achieved through the formation, confirmation, rejection, and refinement of expectations of domain concepts. The user may search for confirming beacons <ref> [1] </ref> of these expectations. This method is thought to be common among expert programmers or if the code or 1 This research has been supported in part by a grant from the National Science Foundation (CCR9121607) and a graduate fellowship from the Intel Corporation. type of code is familiar.
Reference: [2] <author> Marc H. Brown. </author> <title> Exploring algorithms using Balsa-II. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 14-36, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: PUNDIT [16] combines statically collected semantic information with debugging capabilities, and provides both graphical and textual displays. Graphical displays include a dynamic call graph, an animated control flow graph, and data structure displays. Other types of software visualization [26, 19] systems including BALSA <ref> [2] </ref>, Zeus [3], and TANGO [24] focus on algorithm animation; they support the user in the design of arbitrary visualizations.
Reference: [3] <author> Marc H. Brown. ZEUS: </author> <title> A system for algorithm animation and multi-view editing. </title> <booktitle> In Proceedings of the IEEE 1991 Workshop on Visual Languages, </booktitle> <pages> pages 4-9, </pages> <address> Kobe Japan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: PUNDIT [16] combines statically collected semantic information with debugging capabilities, and provides both graphical and textual displays. Graphical displays include a dynamic call graph, an animated control flow graph, and data structure displays. Other types of software visualization [26, 19] systems including BALSA [2], Zeus <ref> [3] </ref>, and TANGO [24] focus on algorithm animation; they support the user in the design of arbitrary visualizations.
Reference: [4] <author> G. Canfora, A. Cimitile, and U. DeCarlini. Vaps: </author> <title> Visual aids for pascal software comprehension. </title> <booktitle> In Proceedings of the Program Comprehension Workshop, </booktitle> <pages> pages 13-15, </pages> <year> 1992. </year>
Reference-contexts: Use of these combined program representations allows a program comprehension tool to reference a single in ternal representation, yet construct a variety of views, thus allowing the analyst to gain a better understanding of the program. Systems such as CARE [14], VAPS <ref> [4] </ref>, and VIFOR [20] visualize program dependencies. VAPS displays include a control flow graph, declaration and nesting trees, and a structure chart. VIFOR uses a two-column entity-relationship display. CARE uses a similar model, but presents a multi-column, colonnade display in addition to the traditional call-graph display.
Reference: [5] <author> T. A. Corbi. </author> <title> Program understanding : Challenge for the 1990's. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2), </volume> <month> Febru-ary </month> <year> 1989. </year>
Reference-contexts: A number of models, techniques, program representations, and tools have been developed to address the problems of program comprehension. In the top-down or problem-driven model <ref> [5] </ref>, program comprehension is achieved through the formation, confirmation, rejection, and refinement of expectations of domain concepts. The user may search for confirming beacons [1] of these expectations.
Reference: [6] <author> Janice E. Cuny, Alfred A. Hough, and Joydip Kundu. </author> <title> Logical time in visualizations produced by parallel programs. In Visualization '92, </title> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Within the constraints of partial ordering, a number of feasible orderings exist. Visualizations that adhere to different feasible orderings can give the viewer different perspectives on the computation. Several authors [27], [13], and <ref> [6] </ref>, have emphasized the value of displaying alternate orderings of a program's execution. To truly comprehend a parallel pro gram, the analyst must understand what these various orderings are and how they can affect the program under study.
Reference: [7] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Pro--gramming Languages and Systems, </journal> <volume> 9(3), </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: A number of graphical representations of program information have been proposed. These graphical representations may be used internally to calculate results such as program slices or data flow information, or they may serve as the basis for displays that are presented to the analyst. See <ref> [7] </ref>, [17], [8], and [9] for a more detailed discussion of program graph types. Use of these combined program representations allows a program comprehension tool to reference a single in ternal representation, yet construct a variety of views, thus allowing the analyst to gain a better understanding of the program.
Reference: [8] <author> M. Harrold and B. Malloy. </author> <title> A unified interprocedu-ral program representation for a maintenance environment. </title> <booktitle> In Proceedings of the Conference on Software Maintenance, </booktitle> <pages> pages 138-147, </pages> <address> Sorrento, Italy, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: A number of graphical representations of program information have been proposed. These graphical representations may be used internally to calculate results such as program slices or data flow information, or they may serve as the basis for displays that are presented to the analyst. See [7], [17], <ref> [8] </ref>, and [9] for a more detailed discussion of program graph types. Use of these combined program representations allows a program comprehension tool to reference a single in ternal representation, yet construct a variety of views, thus allowing the analyst to gain a better understanding of the program.
Reference: [9] <author> David Kinloch and Malcolm Munro. </author> <title> A combined representation for the maintenance of c programs. </title> <booktitle> In Proceedings of the Program Comprehension Workshop, </booktitle> <pages> pages 119-127, </pages> <year> 1993. </year>
Reference-contexts: A number of graphical representations of program information have been proposed. These graphical representations may be used internally to calculate results such as program slices or data flow information, or they may serve as the basis for displays that are presented to the analyst. See [7], [17], [8], and <ref> [9] </ref> for a more detailed discussion of program graph types. Use of these combined program representations allows a program comprehension tool to reference a single in ternal representation, yet construct a variety of views, thus allowing the analyst to gain a better understanding of the program.
Reference: [10] <author> Eileen Kraemer and John T. Stasko. </author> <title> The visualization of parallel systems: An overview. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 105-117, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This leads us to a discussion of the importance of time and event order in the visualization of parallel programs. 3 Time and event order in the visual ization of parallel programs A number of systems providing visualizations of concurrent programs have been developed <ref> [10] </ref>. However, not all visualization systems are designed to deal with concurrency. Many follow a serial paradigm in which the visualization system receives some data from the executing program, animates the display to represent that event, and then processes another event (piece of data).
Reference: [11] <author> Eileen Kraemer and John T. Stasko. </author> <title> Toward flexible control of the temporal mapping from concurrent program events to animations. </title> <booktitle> Proceedings Eighth International Parallel Processing Symposium, </booktitle> <pages> pages 902-908, </pages> <year> 1994. </year>
Reference-contexts: Of course, the many combinations of possible event orders makes it unmanageable to generate and display every feasible ordering. Instead, we utilize an Animation Choreographer <ref> [11] </ref> that provides several useful, canonical orderings, based on the synchronization events produced by the program under study. In addition, the Choreographer allows the user to interactively adjust these to produce any additional orderings.
Reference: [12] <author> P.J. Layzell, R. Champion, and M.J. Freeman. Docket: </author> <title> Program comprehension-in-the-large. </title> <booktitle> In Proceedings of the Program Comprehension Workshop, </booktitle> <pages> pages 140-148, </pages> <year> 1993. </year>
Reference-contexts: Charon [22] produces an intermediate result that can be passed on to a CASE tool. Ghinsu [15] allows the analyst to interactively explore the program, select target statements and variables, and perform analysis such as slicing, dicing, ripple analysis, and dependence analysis. DOCKET <ref> [12] </ref> creates a system model that may be interactively queried or browsed by the analyst. A number of graphical representations of program information have been proposed.
Reference: [13] <author> Thomas J. LeBlanc, John M. Mellor-Crummey, and Robert J. Fowler. </author> <title> Analyzing parallel program execution using multiple views. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9(2) </volume> <pages> 203-217, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Within the constraints of partial ordering, a number of feasible orderings exist. Visualizations that adhere to different feasible orderings can give the viewer different perspectives on the computation. Several authors [27], <ref> [13] </ref>, and [6], have emphasized the value of displaying alternate orderings of a program's execution. To truly comprehend a parallel pro gram, the analyst must understand what these various orderings are and how they can affect the program under study.
Reference: [14] <author> Panagiotos Linos, Philippe Aubet, Laurent Dumas, Yan Helleboid, Patricia Lejeune, and Philippe Tulula. </author> <title> Facilitating the comprehension of c programs: An experimental study. </title> <booktitle> In Proceedings of the Program Comprehension Workshop, </booktitle> <pages> pages 55-63, </pages> <year> 1993. </year>
Reference-contexts: Use of these combined program representations allows a program comprehension tool to reference a single in ternal representation, yet construct a variety of views, thus allowing the analyst to gain a better understanding of the program. Systems such as CARE <ref> [14] </ref>, VAPS [4], and VIFOR [20] visualize program dependencies. VAPS displays include a control flow graph, declaration and nesting trees, and a structure chart. VIFOR uses a two-column entity-relationship display. CARE uses a similar model, but presents a multi-column, colonnade display in addition to the traditional call-graph display.
Reference: [15] <author> Panos E. Livadas and Scott D. Alden. </author> <title> A toolset for program understanding. </title> <booktitle> In Proceedings of the Program Comprehension Workshop, </booktitle> <pages> pages 110-118, </pages> <year> 1993. </year>
Reference-contexts: For example, TIBER (described in [22]) and Synchronized Refinement [21] focus on producing improved documentation. Charon [22] produces an intermediate result that can be passed on to a CASE tool. Ghinsu <ref> [15] </ref> allows the analyst to interactively explore the program, select target statements and variables, and perform analysis such as slicing, dicing, ripple analysis, and dependence analysis. DOCKET [12] creates a system model that may be interactively queried or browsed by the analyst.
Reference: [16] <author> David P. Olshefski. </author> <title> Position paper: </title> <booktitle> Tools facilitating software comprehension. In Proceedings of the Program Comprehension Workshop, </booktitle> <pages> pages 32-34, </pages> <year> 1992. </year>
Reference-contexts: VAPS displays include a control flow graph, declaration and nesting trees, and a structure chart. VIFOR uses a two-column entity-relationship display. CARE uses a similar model, but presents a multi-column, colonnade display in addition to the traditional call-graph display. PUNDIT <ref> [16] </ref> combines statically collected semantic information with debugging capabilities, and provides both graphical and textual displays. Graphical displays include a dynamic call graph, an animated control flow graph, and data structure displays.
Reference: [17] <author> Karl J. Ottenstein and Linda M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <journal> SIGPLAN Notices, </journal> <volume> 9 </volume> <pages> 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: A number of graphical representations of program information have been proposed. These graphical representations may be used internally to calculate results such as program slices or data flow information, or they may serve as the basis for displays that are presented to the analyst. See [7], <ref> [17] </ref>, [8], and [9] for a more detailed discussion of program graph types. Use of these combined program representations allows a program comprehension tool to reference a single in ternal representation, yet construct a variety of views, thus allowing the analyst to gain a better understanding of the program.
Reference: [18] <author> Cherri M. Pancake and Sue Utter. </author> <title> Models for visualization in parallel debuggers. </title> <booktitle> In Proceedings of Supercomputing '89, </booktitle> <pages> pages 627-636, </pages> <address> Reno, NV, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: These displays are most useful when they closely match the mental model <ref> [18] </ref> that the programmer/analyst forms through the process of program comprehension. The presentation of multiple views, and a facility that allows the viewer to hide, rearrange, or interact with objects in the display, all assist the analyst in achieving this match, and thus facilitate the comprehension of the program.
Reference: [19] <author> Blaine A. Price, Ronald M. Baecker, and Ian S. </author> <title> Small. A principled taxonomy of software visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 4(3) </volume> <pages> 211-266, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: PUNDIT [16] combines statically collected semantic information with debugging capabilities, and provides both graphical and textual displays. Graphical displays include a dynamic call graph, an animated control flow graph, and data structure displays. Other types of software visualization <ref> [26, 19] </ref> systems including BALSA [2], Zeus [3], and TANGO [24] focus on algorithm animation; they support the user in the design of arbitrary visualizations.
Reference: [20] <author> V. Rajlich, N. Damaskinos, P. Linos, and W. Khorsid. </author> <title> Vifor: A tool for software maintenance. </title> <journal> Software Practice and Experience, </journal> <pages> pages 67-77, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Use of these combined program representations allows a program comprehension tool to reference a single in ternal representation, yet construct a variety of views, thus allowing the analyst to gain a better understanding of the program. Systems such as CARE [14], VAPS [4], and VIFOR <ref> [20] </ref> visualize program dependencies. VAPS displays include a control flow graph, declaration and nesting trees, and a structure chart. VIFOR uses a two-column entity-relationship display. CARE uses a similar model, but presents a multi-column, colonnade display in addition to the traditional call-graph display.
Reference: [21] <author> Spencer Rugaber. </author> <title> Reverse engineering by simultaneous program analysis and domain synthesis. </title> <booktitle> In Proceedings of the Program Comprehension Workshop, </booktitle> <pages> pages 45-47, </pages> <year> 1992. </year>
Reference-contexts: Some of these tools produce predefined sets of reports or displays or furnish answers to fixed sets of queries, others allow the analyst to interactively select the analysis to be performed or the information to be displayed. For example, TIBER (described in [22]) and Synchronized Refinement <ref> [21] </ref> focus on producing improved documentation. Charon [22] produces an intermediate result that can be passed on to a CASE tool. Ghinsu [15] allows the analyst to interactively explore the program, select target statements and variables, and perform analysis such as slicing, dicing, ripple analysis, and dependence analysis.
Reference: [22] <author> Oreste Signore and Mario Loffredo. Charon: </author> <title> a tool for code redocumentation and re-engineering. </title> <booktitle> In Proceedings of the Program Comprehension Workshop, </booktitle> <pages> pages 169-175, </pages> <year> 1993. </year>
Reference-contexts: Some of these tools produce predefined sets of reports or displays or furnish answers to fixed sets of queries, others allow the analyst to interactively select the analysis to be performed or the information to be displayed. For example, TIBER (described in <ref> [22] </ref>) and Synchronized Refinement [21] focus on producing improved documentation. Charon [22] produces an intermediate result that can be passed on to a CASE tool. <p> For example, TIBER (described in <ref> [22] </ref>) and Synchronized Refinement [21] focus on producing improved documentation. Charon [22] produces an intermediate result that can be passed on to a CASE tool. Ghinsu [15] allows the analyst to interactively explore the program, select target statements and variables, and perform analysis such as slicing, dicing, ripple analysis, and dependence analysis.
Reference: [23] <author> E. Soloway and K. Ehrlich. </author> <title> Empirical studies of programming knowledgekk. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):595-609, </volume> <year> 1984. </year>
Reference-contexts: In the bottom-up or code-driven model <ref> [23] </ref>, comprehension is achieved through the detection of patterns or plans in the program code. This approach is common when the code is completely new to the programmer. In practice, comprehension may proceed top-down, bottom-up or a combination of the two.
Reference: [24] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: PUNDIT [16] combines statically collected semantic information with debugging capabilities, and provides both graphical and textual displays. Graphical displays include a dynamic call graph, an animated control flow graph, and data structure displays. Other types of software visualization [26, 19] systems including BALSA [2], Zeus [3], and TANGO <ref> [24] </ref> focus on algorithm animation; they support the user in the design of arbitrary visualizations.
Reference: [25] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 258-264, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Many follow a serial paradigm in which the visualization system receives some data from the executing program, animates the display to represent that event, and then processes another event (piece of data). Unfortunately, we then lose the con-currency inherent in the program. The POLKA <ref> [25] </ref> animation system that we use to develop visualizations can support concurrent animations actions, however. POLKA allows designers to create graphical objects such as lines, text, circles, rectangles, etc., and then make the objects move, resize, change color, flash, and so on.
Reference: [26] <author> John T. Stasko and Charles Patterson. </author> <title> Understanding and characterizing software visualization systems. </title> <booktitle> In Proceedings of the IEEE 1992 Workshop on Visual Languages, </booktitle> <pages> pages 3-10, </pages> <address> Seattle, WA, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: PUNDIT [16] combines statically collected semantic information with debugging capabilities, and provides both graphical and textual displays. Graphical displays include a dynamic call graph, an animated control flow graph, and data structure displays. Other types of software visualization <ref> [26, 19] </ref> systems including BALSA [2], Zeus [3], and TANGO [24] focus on algorithm animation; they support the user in the design of arbitrary visualizations.
Reference: [27] <author> Janice M. Stone. </author> <title> A graphical representation of concurrent processes. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 226-235, </pages> <month> January </month> <year> 1989. </year> <booktitle> (Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988). </year>
Reference-contexts: Within the constraints of partial ordering, a number of feasible orderings exist. Visualizations that adhere to different feasible orderings can give the viewer different perspectives on the computation. Several authors <ref> [27] </ref>, [13], and [6], have emphasized the value of displaying alternate orderings of a program's execution. To truly comprehend a parallel pro gram, the analyst must understand what these various orderings are and how they can affect the program under study.
Reference: [28] <author> E. Tufte. </author> <title> The Visual Display of Quantitative Information. </title> <publisher> Graphics Press, </publisher> <address> Cheshire, CT, </address> <year> 1983. </year>
Reference-contexts: We know that two-dimensional displays of information, such as bar charts and graphs, give viewers insight into the data presented <ref> [28, 29] </ref>. Graphical animation can provide additional insight and allow the viewer to absorb more information by tapping into our well-developed visual abilities for detecting patterns, for tracking moving objects, and for spotting anomalies in patterns. Visualization is a rich medium for communicating information about a program and its execution.
Reference: [29] <author> E. Tufte. </author> <title> Envisioning Information. </title> <publisher> Graphics Press, </publisher> <address> Cheshire, CT, </address> <year> 1990. </year>
Reference-contexts: We know that two-dimensional displays of information, such as bar charts and graphs, give viewers insight into the data presented <ref> [28, 29] </ref>. Graphical animation can provide additional insight and allow the viewer to absorb more information by tapping into our well-developed visual abilities for detecting patterns, for tracking moving objects, and for spotting anomalies in patterns. Visualization is a rich medium for communicating information about a program and its execution.
References-found: 29

