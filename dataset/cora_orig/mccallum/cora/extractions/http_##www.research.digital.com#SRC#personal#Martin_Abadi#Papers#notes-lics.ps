URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/notes-lics.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Email: ma@pa.dec.com  Cedric.Fournet@inria.fr  Georges.Gonthier@inria.fr  
Title: Secure Implementation of Channel Abstractions  
Author: Martin Abadi Georges Gonthier 
Address: Cedric Fournet  
Affiliation: Digital Equipment Corporation Systems Research Center  INRIA Rocquencourt  INRIA Rocquencourt  
Abstract: Communication in distributed systems often relies on useful abstractions such as channels, remote procedure calls, and remote method invocations. The implementations of these abstractions sometimes provide security properties, in particular through encryption. In this paper we study those security properties, focusing on channel abstractions. We introduce a simple high-level language that includes constructs for creating and using secure channels. The language is a variant of the join-calculus and belongs to the same family as the pi-calculus. We show how to translate the high-level language into a lower-level language that includes cryptographic primitives. In this translation, we map communication on secure channels to encrypted communication on public channels. We obtain a correctness theorem for our translation; this theorem implies that one can reason about programs in the high-level language without mentioning the subtle cryptographic protocols used in their lower-level implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi. </author> <title> Secrecy by typing in security protocols. </title> <booktitle> In Theoretical Aspects of Computer Software, volume 1281 of Lecture Notes in Computer Science, </booktitle> <pages> pages 611-638. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus [15, 16, 17, 18], and the application of the pi-calculus and the spi-calculus for reasoning about security protocols <ref> [4, 5, 6, 1, 13] </ref>. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3].
Reference: [2] <author> M. Abadi. </author> <title> Protection in programming-language translations. </title> <booktitle> In Proceedings of the 25th International Colloquium on Automata, Languages and Programming, </booktitle> <month> July </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus <ref> [2, 3] </ref>. Those projects also produced the work most closely related to that described here, including partial encodings of encryption in the pi-calculus [4, 13]. Our translation goes in the direction opposite to those encodings. <p> This property is important because it means that our translations do not identify "too many" join-calculus processes or even|trivially|all join-calculus processes. For security, however, full abstraction is interesting mainly in the "downwards" direction <ref> [2] </ref>: if two join-calculus processes are equivalent, then their implementations in the sjoin-calculus are equivalent too.
Reference: [3] <author> M. Abadi, C. Fournet, and G. Gonthier. </author> <title> Secure implementation of channel abstractions. </title> <type> Manuscript, </type> <note> full version of this paper, on the Web at http:// pauillac.inria.fr/join, </note> <year> 1998. </year>
Reference-contexts: Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus <ref> [2, 3] </ref>. Those projects also produced the work most closely related to that described here, including partial encodings of encryption in the pi-calculus [4, 13]. Our translation goes in the direction opposite to those encodings. <p> In sections 3 and 4, we present our translation, with several variants, and in section 5 we study its theory. We conclude in section 6. In this summary we omit many examples, results, and proofs, which are in the full paper <ref> [3] </ref>. 2 From the join-calculus to the sjoin-calculus In this section, we introduce our high-level language and our low-level language. The appendix contains formal details, including the definition of binary relations j and ! on processes.
Reference: [4] <author> M. Abadi and A. D. Gordon. </author> <title> A calculus for cryptographic protocols: The spi calculus. </title> <type> Technical Report 414, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> Jan. </month> <year> 1997. </year> <note> Extended version of both [5] and [6]. A revised version appeared as Digital Equipment Corporation Systems Research Center report No. 149, January 1998, and an abridged version will appear in Information and Computation. </note>
Reference-contexts: The language is a variant of the join-calculus [15] and belongs to the same family as the pi-calculus [30, 28]. * We show how to translate the high-level language into a lower-level language that includes cryptographic primitives (like the spi-calculus <ref> [4] </ref>). In this translation, we implement communication on secure channels by encrypted communication on public channels. * We state and prove a soundness property for our translation. <p> This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus [15, 16, 17, 18], and the application of the pi-calculus and the spi-calculus for reasoning about security protocols <ref> [4, 5, 6, 1, 13] </ref>. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3]. <p> Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3]. Those projects also produced the work most closely related to that described here, including partial encodings of encryption in the pi-calculus <ref> [4, 13] </ref>. Our translation goes in the direction opposite to those encodings. In the next section we describe the source language and the target language of our translation, and give an informal overview of some of the themes of the paper.
Reference: [5] <author> M. Abadi and A. D. Gordon. </author> <title> A calculus for cryptographic protocols: The spi calculus. </title> <booktitle> In Proceedings of the Fourth ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 36-47, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus [15, 16, 17, 18], and the application of the pi-calculus and the spi-calculus for reasoning about security protocols <ref> [4, 5, 6, 1, 13] </ref>. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3].
Reference: [6] <author> M. Abadi and A. D. Gordon. </author> <title> Reasoning about cryptographic protocols in the spi calculus. </title> <editor> In A. Mazurkiewicz and J. Winkowski, editors, </editor> <booktitle> Proceedings of the 8th International Conference on Con-currency Theory, volume 1243 of Lecture Notes in Computer Science, </booktitle> <pages> pages 59-73. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1997. </year>
Reference-contexts: This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus [15, 16, 17, 18], and the application of the pi-calculus and the spi-calculus for reasoning about security protocols <ref> [4, 5, 6, 1, 13] </ref>. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3].
Reference: [7] <author> K. F. Alden and E. P. Wobber. </author> <title> The AltaVista tunnel: Using the Internet to extend corporate networks. </title> <journal> Digital Technical Journal, </journal> <volume> 9(2) </volume> <pages> 5-15, </pages> <month> Oct. </month> <year> 1997. </year> <note> On the Web at http://www.digital.com/ info/DTJQ01/DTJQ01HM.HTM. </note>
Reference-contexts: The second technique relies on a context F S [ ] that operates as a filter, applying encryption and converting message formats (much like a firewall with an encrypting tunnel <ref> [11, 7] </ref>).
Reference: [8] <author> G. Berry and G. Boudol. </author> <title> The chemical abstract machine. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 96 </volume> <pages> 217-248, </pages> <year> 1992. </year>
Reference-contexts: dv [J ] ] dv [J 0 ] def dv [fresh x] def dv [keys x + ; x ] def dv [D ^ D 0 ] = dv [D] [ dv [D 0 ] Chemical semantics We present our operational semantics in the chemical style of Berry and Boudol <ref> [8] </ref>, as a variant of the reflexive chemical abstract machine [15].
Reference: [9] <author> A. D. Birrell. </author> <title> Secure communication using remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 1-14, </pages> <month> Feb. </month> <year> 1985. </year>
Reference-contexts: In recent years, several APIs (application program interfaces) for security have appeared, providing such abstractions and services <ref> [22, 23, 26, 24, 9, 21, 34] </ref>. Although there are substantial differences among these APIs, they generally offer the promise of making application code more modular, simpler, and ultimately more robust. In this paper we consider high-level abstractions that largely hide the difficulties of network security from applications.
Reference: [10] <author> E. Brinksma, A. Rensink, and W. Vogler. </author> <title> Fair testing. </title> <editor> In I. Lee and S. A. Smolka, editors, </editor> <booktitle> Proceedings of the 6th International Conference on Concurrency Theory, volume 962 of Lecture Notes in Computer Science, </booktitle> <pages> pages 313-327. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Our full-abstraction results are rather robust, as they hold for a range of equivalence relations on processes, including observational equivalence and may-testing equivalence, and also intermediate equivalences that incorporate notions of fairness, such as fair-testing equivalence <ref> [10] </ref>. Much as in the spi-calculus, observational equivalence can often be proved more directly than may-testing equivalence. While may-testing equivalence probably has a more intuitive meaning, our results for observational equivalence demonstrate that our translations preserve even the branching structure of processes.
Reference: [11] <author> P.-C. Cheng, J. A. Garay, A. Herzberg, and H. Kraw-czyk. </author> <title> Design and implementation of modular key management protocol and IP secure tunnel on AIX. </title> <booktitle> In Proceedings of the 5th USENIX UNIX Security Symposium, </booktitle> <month> June </month> <year> 1995. </year> <booktitle> [12] 10th IEEE Computer Security Foundations Workshop. IEEE Computer Society, 1997. Proceedings. </booktitle>
Reference-contexts: The second technique relies on a context F S [ ] that operates as a filter, applying encryption and converting message formats (much like a firewall with an encrypting tunnel <ref> [11, 7] </ref>).
Reference: [13] <author> M. Dam. </author> <title> Proving trust in systems of second-order processes: Preliminary results. </title> <type> Draft, </type> <year> 1997. </year>
Reference-contexts: This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus [15, 16, 17, 18], and the application of the pi-calculus and the spi-calculus for reasoning about security protocols <ref> [4, 5, 6, 1, 13] </ref>. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3]. <p> Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3]. Those projects also produced the work most closely related to that described here, including partial encodings of encryption in the pi-calculus <ref> [4, 13] </ref>. Our translation goes in the direction opposite to those encodings. In the next section we describe the source language and the target language of our translation, and give an informal overview of some of the themes of the paper.
Reference: [14] <author> R. De Nicola and M. C. B. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference-contexts: R Q if and only if Env [ [[P ]] ] R Env [ [[Q]] ] In particular, may-testing equivalence (' may ) is coarser than observational equivalence and is a congruence. (It is perhaps the most important relation that satisfies these conditions, because of its correspondence with safety properties <ref> [14] </ref>.) Therefore, we obtain, for example: P ' may Q if and only if Env [ [[P ]] ] ' may Env [ [[Q]] ] Theorem 2 immediately implies that analogous results hold for the filtering translation. 5.3 Discussion The "upwards" direction of our full-abstraction results says that two join-calculus processes
Reference: [15] <author> C. Fournet and G. Gonthier. </author> <title> The reflexive chemical abstract machine and the join-calculus. </title> <booktitle> In Proceedings of POPL '96, </booktitle> <pages> pages 372-385. </pages> <publisher> ACM, </publisher> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: We address these issues, focusing on channel abstractions. * We introduce a simple high-level language that includes constructs for creating and using secure channels. The language is a variant of the join-calculus <ref> [15] </ref> and belongs to the same family as the pi-calculus [30, 28]. * We show how to translate the high-level language into a lower-level language that includes cryptographic primitives (like the spi-calculus [4]). <p> To our knowledge, results of this kind have not previously appeared in the literature. This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus <ref> [15, 16, 17, 18] </ref>, and the application of the pi-calculus and the spi-calculus for reasoning about security protocols [4, 5, 6, 1, 13]. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3]. <p> [fresh x] def dv [keys x + ; x ] def dv [D ^ D 0 ] = dv [D] [ dv [D 0 ] Chemical semantics We present our operational semantics in the chemical style of Berry and Boudol [8], as a variant of the reflexive chemical abstract machine <ref> [15] </ref>. The state of a computation is represented by a pair of multisets (D; P), called a chemical solution, and written D ` P, where P is a multiset of processes (intuitively the processes running) and D is a multiset of definitions. The rules for computation operate on chemical solutions.
Reference: [16] <author> C. Fournet, G. Gonthier, J.-J. Levy, L. Maranget, and D. Remy. </author> <title> A calculus of mobile agents. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> Proceedings of the 7th International Conference on Concurrency Theory, volume 1119 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> Aug. </month> <year> 1996. </year>
Reference-contexts: To our knowledge, results of this kind have not previously appeared in the literature. This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus <ref> [15, 16, 17, 18] </ref>, and the application of the pi-calculus and the spi-calculus for reasoning about security protocols [4, 5, 6, 1, 13]. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3].
Reference: [17] <author> C. Fournet, C. Laneve, L. Maranget, and D. Remy. </author> <title> Implicit typing a la ML for the join-calculus. </title> <editor> In A. Mazurkiewicz and J. Winkowski, editors, </editor> <booktitle> Proceedings of the 8th International Conference on Concur-rency Theory, volume 1243 of Lecture Notes in Computer Science, </booktitle> <pages> pages 196-212. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1997. </year>
Reference-contexts: To our knowledge, results of this kind have not previously appeared in the literature. This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus <ref> [15, 16, 17, 18] </ref>, and the application of the pi-calculus and the spi-calculus for reasoning about security protocols [4, 5, 6, 1, 13]. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3]. <p> Each channel has an arity (a fixed size for the tuples passed on the channel). We enforce the consistent use of arities with a type system. While there exists a rich, polymorphic type system for the join-calculus <ref> [17] </ref>, a v ::= values x name P ::= processes xhevi message j def D in P local definition j if v = v 0 then P else P 0 comparison j P j P 0 parallel composition j 0 null process D ::= definitions J .
Reference: [18] <author> C. Fournet and L. Maranget. </author> <title> The join-calculus language. Web pages at http://pauillac.inria.fr/ join, </title> <month> June </month> <year> 1997. </year>
Reference-contexts: To our knowledge, results of this kind have not previously appeared in the literature. This paper represents the confluence of several projects, including the development of secure network objects [34] and of the join-calculus <ref> [15, 16, 17, 18] </ref>, and the application of the pi-calculus and the spi-calculus for reasoning about security protocols [4, 5, 6, 1, 13]. Those projects encountered some of the questions treated here; the join-calculus provides a more convenient setting for this study than network-object systems or the pi-calculus [2, 3]. <p> This is a name-passing calculus, like the pi-calculus, with an emphasis on distributed programming. It constitutes the core of a programming language with a fully distributed implementation <ref> [18] </ref>. The join-calculus also draws on functional languages with pattern matching and on object-oriented languages. The syntax of the join-calculus assumes a set of names. In the pure join-calculus, names are used only as names of channels, and a value is simply a name.
Reference: [19] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Inf., </journal> <volume> 1 </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: More generally, many interesting questions in security can be seen as problems of refinement|relating views at different levels of abstraction (e.g., <ref> [19] </ref>). Different views of security are appropriate for different communities of users, administrators, designers, and programmers. The gaps between these views are sources of confusion and vulnerability. Unfortunately, some of these gaps are still a fuzzy subject for research, because they stem from fuzzy human expectations.
Reference: [20] <author> K. Honda and N. Yoshida. </author> <title> On reduction-based process semantics. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 151 </volume> <pages> 437-486, </pages> <year> 1995. </year>
Reference-contexts: The concept of observational equivalence goes back to Milner's work on CCS [27]; more specifically, we adopt a reduction-based semantics, as for example in the work of Honda and Yoshida <ref> [20] </ref>. All the definitions are fairly standard, and apply to the join-calculus and to the sjoin-calculus.
Reference: [21] <author> B. Lampson, M. Abadi, M. Burrows, and E. Wob-ber. </author> <title> Authentication in distributed systems: </title> <journal> Theory and practice. ACM Transactions on Computer Systems, </journal> <volume> 10(4) </volume> <pages> 265-310, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: In recent years, several APIs (application program interfaces) for security have appeared, providing such abstractions and services <ref> [22, 23, 26, 24, 9, 21, 34] </ref>. Although there are substantial differences among these APIs, they generally offer the promise of making application code more modular, simpler, and ultimately more robust. In this paper we consider high-level abstractions that largely hide the difficulties of network security from applications. <p> For example, when an application requires secure communication between a client and a server, the application code may include a call to create a secure channel <ref> [21] </ref>. In the local case, the implementation of the secure channel can rely on a local operating system, whereas in the distributed case it involves a network connection and a key.
Reference: [22] <author> J. Linn. </author> <title> RFC 1508: Generic security service application program interface. </title> <note> Web page at ftp://ds .internic.net/rfc/rfc1508.txt, </note> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: In recent years, several APIs (application program interfaces) for security have appeared, providing such abstractions and services <ref> [22, 23, 26, 24, 9, 21, 34] </ref>. Although there are substantial differences among these APIs, they generally offer the promise of making application code more modular, simpler, and ultimately more robust. In this paper we consider high-level abstractions that largely hide the difficulties of network security from applications.
Reference: [23] <author> J. Linn. </author> <title> Generic interface to security services. </title> <journal> Computer Communications, </journal> <volume> 17(7) </volume> <pages> 476-482, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: In recent years, several APIs (application program interfaces) for security have appeared, providing such abstractions and services <ref> [22, 23, 26, 24, 9, 21, 34] </ref>. Although there are substantial differences among these APIs, they generally offer the promise of making application code more modular, simpler, and ultimately more robust. In this paper we consider high-level abstractions that largely hide the difficulties of network security from applications.
Reference: [24] <author> D. L. McDonald, B. G. Phan, and R. J. Atkin-son. </author> <title> A socket-based key management API (and surrounding infrastructure). </title> <booktitle> In Proceedings of INET96, </booktitle> <year> 1996. </year> <note> On the Web at http://www.isoc.org/isoc/ whatis/conferences/inet/96/proceedings/. </note>
Reference-contexts: In recent years, several APIs (application program interfaces) for security have appeared, providing such abstractions and services <ref> [22, 23, 26, 24, 9, 21, 34] </ref>. Although there are substantial differences among these APIs, they generally offer the promise of making application code more modular, simpler, and ultimately more robust. In this paper we consider high-level abstractions that largely hide the difficulties of network security from applications.
Reference: [25] <editor> A. J. Menezes, P. C. van Oorschot, and S. A. Vanstone. </editor> <booktitle> Handbook of Applied Cryptography. </booktitle> <publisher> CRC Press, </publisher> <year> 1996. </year>
Reference-contexts: Note that x + and x range over ordinary names: the symbols + and are used only conventionally, and have no formal meaning. In general, the names x + and x will be different; this distinction models the separation of encryption key and decryption key in public-key cryptosystems (e.g., <ref> [25] </ref>). However, we use keys x; x when x is a shared key (so x is its own inverse), and abbreviate keys x; x to key x. This notation yields a concise model of shared-key cryptography as a special case of public-key cryptography.
Reference: [26] <institution> Microsoft. CryptoAPI. </institution> <note> Web pages at http:// www.microsoft.com/security/tech/. </note>
Reference-contexts: In recent years, several APIs (application program interfaces) for security have appeared, providing such abstractions and services <ref> [22, 23, 26, 24, 9, 21, 34] </ref>. Although there are substantial differences among these APIs, they generally offer the promise of making application code more modular, simpler, and ultimately more robust. In this paper we consider high-level abstractions that largely hide the difficulties of network security from applications.
Reference: [27] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference-contexts: The concept of observational equivalence goes back to Milner's work on CCS <ref> [27] </ref>; more specifically, we adopt a reduction-based semantics, as for example in the work of Honda and Yoshida [20]. All the definitions are fairly standard, and apply to the join-calculus and to the sjoin-calculus.
Reference: [28] <author> R. Milner. </author> <title> Functions as processes. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2 </volume> <pages> 119-141, </pages> <year> 1992. </year>
Reference-contexts: We address these issues, focusing on channel abstractions. * We introduce a simple high-level language that includes constructs for creating and using secure channels. The language is a variant of the join-calculus [15] and belongs to the same family as the pi-calculus <ref> [30, 28] </ref>. * We show how to translate the high-level language into a lower-level language that includes cryptographic primitives (like the spi-calculus [4]). In this translation, we implement communication on secure channels by encrypted communication on public channels. * We state and prove a soundness property for our translation.
Reference: [29] <author> R. Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <editor> In Bauer, Brauer, and Schwichtenberg, editors, </editor> <title> Logic and Algebra of Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We use repl P as an abbreviation for def xhi .(P j xhi) in xhi for a fresh x; this is the replication of P (also written !P <ref> [29] </ref>). The meaning of most of the process constructs should be clear. The process xhevi sends the tuple of values ev on the channel x; this message is asynchronous, in the sense that it does not require any form of handshake.
Reference: [30] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, parts I and II. </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-40 and 41-77, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: We address these issues, focusing on channel abstractions. * We introduce a simple high-level language that includes constructs for creating and using secure channels. The language is a variant of the join-calculus [15] and belongs to the same family as the pi-calculus <ref> [30, 28] </ref>. * We show how to translate the high-level language into a lower-level language that includes cryptographic primitives (like the spi-calculus [4]). In this translation, we implement communication on secure channels by encrypted communication on public channels. * We state and prove a soundness property for our translation.
Reference: [31] <author> R. M. Needham and M. D. Schroeder. </author> <title> Using encryption for authentication in large networks of computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> Dec. </month> <year> 1978. </year>
Reference-contexts: Either of these protocols, or any other protocol with the same properties, can be used in the translation of section 4. 3.1 The low-level network model Our informal assumptions about the network used by sjoin-calculus processes are similar to those of Need-ham and Schroeder <ref> [31] </ref>: "We assume that an intruder can interpose a computer in all communication paths, and thus can alter or copy parts of messages, replay messages, or emit false material. [. . . ] We also assume that each principal has a secure environment in which to compute, such as is provided
Reference: [32] <author> D. Sangiorgi and R. Milner. </author> <title> The problem of "weak bisimulation up to". </title> <editor> In W. R. Cleaveland, editor, </editor> <booktitle> Proceedings of CONCUR'92, volume 630 of Lecture Notes in Computer Science, </booktitle> <pages> pages 32-46. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: May-testing equivalence (' may ) is the largest symmetric relation R that meets only requirements (1) and (2). Expansion () <ref> [32] </ref> is the largest relation R that meets requirements (1), (2), and (3), such that its converse meets those requirements too, and such that if P R Q and P ! P 0 then, for some Q 0 , P 0 R Q 0 and Q ! = Q 0 ,
Reference: [33] <author> Sun Microsystems, Inc. </author> <title> RMI enhancements. </title> <note> Web pages at http://java.sun.com/products/jdk/1.2/ docs/guide/rmi/index.html, </note> <year> 1997. </year>
Reference-contexts: Similarly, the application code may include a method invocation, which may look the same whether the method invocation is local or remote <ref> [34, 35, 33] </ref>. Security for remote method invocations may be guaranteed by the transport implementation, fairly transparently to the application. Up to now, the design and implementation of abstractions for secure communication has been more an art than a science.
Reference: [34] <author> L. van Doorn, M. Abadi, M. Burrows, and E. Wobber. </author> <title> Secure network objects. </title> <booktitle> In Proceedings 1996 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 211-221, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: In recent years, several APIs (application program interfaces) for security have appeared, providing such abstractions and services <ref> [22, 23, 26, 24, 9, 21, 34] </ref>. Although there are substantial differences among these APIs, they generally offer the promise of making application code more modular, simpler, and ultimately more robust. In this paper we consider high-level abstractions that largely hide the difficulties of network security from applications. <p> Similarly, the application code may include a method invocation, which may look the same whether the method invocation is local or remote <ref> [34, 35, 33] </ref>. Security for remote method invocations may be guaranteed by the transport implementation, fairly transparently to the application. Up to now, the design and implementation of abstractions for secure communication has been more an art than a science. <p> We construct only a few protocols and show that their low-level details match the high-level definition of secure channels. To our knowledge, results of this kind have not previously appeared in the literature. This paper represents the confluence of several projects, including the development of secure network objects <ref> [34] </ref> and of the join-calculus [15, 16, 17, 18], and the application of the pi-calculus and the spi-calculus for reasoning about security protocols [4, 5, 6, 1, 13].
Reference: [35] <author> A. Wollrath, R. Riggs, and J. Waldo. </author> <title> A distributed object model for the Java system. </title> <journal> Computing Systems, </journal> <volume> 9(4) </volume> <pages> 265-290, </pages> <month> Fall </month> <year> 1996. </year>
Reference-contexts: Similarly, the application code may include a method invocation, which may look the same whether the method invocation is local or remote <ref> [34, 35, 33] </ref>. Security for remote method invocations may be guaranteed by the transport implementation, fairly transparently to the application. Up to now, the design and implementation of abstractions for secure communication has been more an art than a science.
References-found: 34

