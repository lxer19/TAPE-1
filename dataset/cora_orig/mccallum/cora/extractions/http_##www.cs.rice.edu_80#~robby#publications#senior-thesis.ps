URL: http://www.cs.rice.edu:80/~robby/publications/senior-thesis.ps
Refering-URL: http://www.cs.rice.edu:80/~robby/publications/
Root-URL: 
Title: Modular Abstract Interpreters  constant propagation in that framework.  
Author: Robby Findler 
Note: I built the framework for the modular interpreters described in this thesis and implemented  Contents  
Date: 5 May 1995  
Abstract: High-level programming languages allow more elegant and comprehensible expression of programs, but compilers for high-level languages can require sophisticated optimization to generate machine code that runs quickly. Optimizations are usually expressed in terms of some statically discoverable information, and abstract interpretation provides a good framework for discovering that information. Abstract interpretation is a framework for relating alternative semantics for a programming language to each other. However, abstract interpretation is difficult because one has to prove the correctness and termination of the abstract interpreters and each program analysis problem needs a different abstract interpreter. I used a monadic programming style to define a framework for modular abstract interpreters in SML extended with extensible datatypes. Monadic programming is a style of programming that allows easy expression of modularity. The modularity simplifies the construction of the interpreters which reduces possibility of errors and makes it easy to add whatever analyses you want to your system. 
Abstract-found: 1
Intro-found: 1
Reference: [BHA86] <author> G.L. Burn, C. Hankin, and S. Abramsky. </author> <title> Stricness analysis for higher-order functions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 7(3) </volume> <pages> 249-78, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Note that this abstraction is very conservative. Whenever a function application happens, all information is lost because of the use of %. The abstraction will terminate, but will only tell you information about lambda-less terms. Abstract interpretation bas been successfully used for alias analysis [Deu92], strictness analysis <ref> [BHA86] </ref>, binding time analysis [BHA86, JGB + 90, Con90] and many other program analysis problems. 3 Modular Interpreters People have been writing interpreters for a long time. <p> Whenever a function application happens, all information is lost because of the use of %. The abstraction will terminate, but will only tell you information about lambda-less terms. Abstract interpretation bas been successfully used for alias analysis [Deu92], strictness analysis [BHA86], binding time analysis <ref> [BHA86, JGB + 90, Con90] </ref> and many other program analysis problems. 3 Modular Interpreters People have been writing interpreters for a long time. They are easy to write when compared to compilers, and because of the relative ease of implementation they are used to rapidly prototype languages.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction of approximations of fixpoints. </title> <booktitle> In Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977. </year>
Reference-contexts: This particular expression would become: fn x:int ) x + 1 and the type of the whole expression would be int ! int. A third example of program analysis is abstract interpretation <ref> [CC77] </ref>. Abstract interpretation is a framework for relating two different semantics of a programming language. Furthermore, the alternative semantics are written in such a way that one of them can be statically computed. <p> Abstract analysis subsumes many other analyses of programs. It is a very general framework that applies to a wide range of program analyses. The Cousots <ref> [CC77] </ref> popularized abstract interpretation and put it on a sound semantic footing. The description of abstract interpretation that I give here is a simplification from the general framework. See [CC77] for a more general treatment. <p> It is a very general framework that applies to a wide range of program analyses. The Cousots <ref> [CC77] </ref> popularized abstract interpretation and put it on a sound semantic footing. The description of abstract interpretation that I give here is a simplification from the general framework. See [CC77] for a more general treatment. Abstract interpretation is a framework for relating alternative semantics for a programming language to the standard semantics for the programming language.
Reference: [Col] <author> Christopher P. Colby. </author> <title> Computing invariants via abstract interpretation. internal correspondence. </title>
Reference-contexts: It is guaranteed to terminate and will try to provide information about variables that are bound to constants or sums and products of constants. The structure for this particular constant propagator is a direct translation of Christopher Colby's <ref> [Col] </ref> constant propagator. signature CONSTPROP MODULE=sig include MODULE 26 5 MODULAR ABSTRACT INTERPRETERS constructor value = Top j Bottom end The CONSTPROP MODULE adds two new values, Top and Bottom. Top represents an unknown value.
Reference: [Con90] <author> Charles Consel. </author> <title> Binding time analysis for higher order untyped functional languages. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 264-272, </pages> <year> 1990. </year>
Reference-contexts: Whenever a function application happens, all information is lost because of the use of %. The abstraction will terminate, but will only tell you information about lambda-less terms. Abstract interpretation bas been successfully used for alias analysis [Deu92], strictness analysis [BHA86], binding time analysis <ref> [BHA86, JGB + 90, Con90] </ref> and many other program analysis problems. 3 Modular Interpreters People have been writing interpreters for a long time. They are easy to write when compared to compilers, and because of the relative ease of implementation they are used to rapidly prototype languages.
Reference: [Deu92] <author> Alain Deutsch. </author> <title> A storeless model of aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In Proceedings of the IEEE 1992 International Conference on Computer Languages, </booktitle> <address> San Fransisco, California, </address> <pages> pages 2-13, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Note that this abstraction is very conservative. Whenever a function application happens, all information is lost because of the use of %. The abstraction will terminate, but will only tell you information about lambda-less terms. Abstract interpretation bas been successfully used for alias analysis <ref> [Deu92] </ref>, strictness analysis [BHA86], binding time analysis [BHA86, JGB + 90, Con90] and many other program analysis problems. 3 Modular Interpreters People have been writing interpreters for a long time. <p> They used Gofer's user-defined overloading and type-classes and a monadic programming style to define each module of the interpreter. Steele [GLS94] used Haskell <ref> [Deu92] </ref> and monads to define his modular interpreters, relying heavily on the laziness of Haskell to tie his modules together. 4 SML SML [MTH90] is a programming language that supports static polymorphic type-checking with datatypes, pattern matching and an expressive module system.
Reference: [FSDF93] <author> Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> Conference on Programming Language Design and Imlementation, </booktitle> <month> June </month> <year> 1993. </year> <note> 46 REFERENCES </note>
Reference-contexts: look at the term that it receives, evaluate it and bind it's program point to the result of the evaluation, returning the new state and the program point that was just bound. parse and anorm are helper functions for the evaluator. parse parses text into abstract syntax and anorm A-Normalizes <ref> [FSDF93] </ref> the abstract syntax tree. A-Normalization is a process which inserts a name for every program point in the program and renames all of the variables so that no two names are the same.
Reference: [GLS94] <author> Jr. Guy L. Steele. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Proceedings of the Symposium of Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: They used Gofer's user-defined overloading and type-classes and a monadic programming style to define each module of the interpreter. Steele <ref> [GLS94] </ref> used Haskell [Deu92] and monads to define his modular interpreters, relying heavily on the laziness of Haskell to tie his modules together. 4 SML SML [MTH90] is a programming language that supports static polymorphic type-checking with datatypes, pattern matching and an expressive module system. <p> When you try to plug them together you find that you need the finished interpreter before you start to tie off the recursion. Steele <ref> [GLS94] </ref> does something similar to this, except that he uses Gofer, a lazy language and is able to express this easily because the language is lazy.
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow analysis cof computer programs. </title> <publisher> North-Holland, </publisher> <address> New-York, </address> <year> 1977. </year>
Reference-contexts: Different analysis solve this problem in different ways. There are several good approaches to program analysis. Dataflow analysis <ref> [Hec77] </ref> is a form of program analysis that can be easily computed and gives lots of interesting information to an optimizer. Dataflow analysis computes the live range of each variable. In dataflow analysis terminology, a variable is a value that the program computes.
Reference: [JGB + 90] <author> Neil D. Jones, Carsten K. Gomard, Anders Bondorf, Olivier Danvy, and Torben Mo-gensen. </author> <title> A self-applicable partial evaluator for the lambda calculus. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer Languages, </booktitle> <pages> pages 49-58, </pages> <year> 1990. </year>
Reference-contexts: Whenever a function application happens, all information is lost because of the use of %. The abstraction will terminate, but will only tell you information about lambda-less terms. Abstract interpretation bas been successfully used for alias analysis [Deu92], strictness analysis [BHA86], binding time analysis <ref> [BHA86, JGB + 90, Con90] </ref> and many other program analysis problems. 3 Modular Interpreters People have been writing interpreters for a long time. They are easy to write when compared to compilers, and because of the relative ease of implementation they are used to rapidly prototype languages.
Reference: [Jon94] <author> Mark P. Jones. </author> <title> The implementation of the gofer functional programming system. </title> <type> Technical Report YALEU/DCS/RR-1030, </type> <institution> Yale University Department of Computer Science, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: out different features of a programming language into orthogonal modules can sometimes be impossible and finding the right compromise between generality and easy composition of the different features can be difficult. 10 4 SML Liang Sheng, Mark Jones and Paul Hudak [LHJ95] devised an approach to modular interpreters in Gofer <ref> [Jon94] </ref>. They used Gofer's user-defined overloading and type-classes and a monadic programming style to define each module of the interpreter.
Reference: [LHJ95] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: To separate out different features of a programming language into orthogonal modules can sometimes be impossible and finding the right compromise between generality and easy composition of the different features can be difficult. 10 4 SML Liang Sheng, Mark Jones and Paul Hudak <ref> [LHJ95] </ref> devised an approach to modular interpreters in Gofer [Jon94]. They used Gofer's user-defined overloading and type-classes and a monadic programming style to define each module of the interpreter. <p> An extensible datatype is a datatype for which you can declare new constructors at any time in your program. I used Sheng's <ref> [LHJ95] </ref> basic framework to define my modular interpreters, but in a different context. Each module of the abstract interpreter must match a MODULE signature and then can be easily combined with other MODULE's to form larger interpreters. 5.1 Individual Modules Monads are key in the definition of the interpreters. <p> A monad has three important components, the type of monads, unitM and bindM. Their use and definition have been well documented in <ref> [Mog91a, Mog91b, LHJ95, Wad92] </ref>. <p> env ) M.inEnv (M.Env.bind env (v,P.lookup s arg)) (M.bindM (step (body,s),fn (s,res id) ) step (a,P.bind ((id,P.lookup s res id),s))))) j ) raise Error application of non-function handle P.Lookup ) (print handled P.Lookup in letappnn; raise P.Lookup)) j ) raise Step Unknown x the idea for this monad comes from <ref> [LHJ95] </ref> 24 5 MODULAR ABSTRACT INTERPRETERS val == = fn == ) let infix == in fn (Lambda (id, , ),Lambda (id', , )) ) id=id' j (Lambda , ) ) false j ( ,Lambda ) ) false j ) raise Eq Unknown end The step function handles binding of variables <p> Each module of the interpreter is an SML structure which is easily combined with any other modules of the interpreter to build complicated abstract interpreters. The composability of these modules has been shown <ref> [LHJ95] </ref> to be very flexible and it's extension to abstract interpretation is natural and should be able to support abstract definition over the range of the expressions in any language.
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal or Computer and System Science, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Dataflow analysis can also be used to eliminate dead code. If you know that a variable's def-use chain has only the definition and no uses, than you do not need to compute the variable. Type-inference <ref> [Mil78] </ref> is another example of program analysis. A type-inference algorithm determines what the type for each variable (in the usually sense of a variable) in a program, and rejects programs whose types do not make sense. Type-inference also allows the programmer to omit definition of variables.
Reference: [Mog91a] <author> Eugenio Moggi. </author> <title> A modular approach to denotational semantics. </title> <editor> In D. H. Pitt, P.-L. Curien, S. Abramsky, A. M. Pitts, A. Poigne, and D. E. Rydeheard, editors, </editor> <booktitle> Category Theory and Computer Science, Lecture Notes in Computer Science, </booktitle> <volume> volume 301. </volume> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A monad has three important components, the type of monads, unitM and bindM. Their use and definition have been well documented in <ref> [Mog91a, Mog91b, LHJ95, Wad92] </ref>.
Reference: [Mog91b] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: A monad has three important components, the type of monads, unitM and bindM. Their use and definition have been well documented in <ref> [Mog91a, Mog91b, LHJ95, Wad92] </ref>.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: They used Gofer's user-defined overloading and type-classes and a monadic programming style to define each module of the interpreter. Steele [GLS94] used Haskell [Deu92] and monads to define his modular interpreters, relying heavily on the laziness of Haskell to tie his modules together. 4 SML SML <ref> [MTH90] </ref> is a programming language that supports static polymorphic type-checking with datatypes, pattern matching and an expressive module system. The major points of interest for this thesis are the datatypes and the module system. 4.1 Datatypes Datatypes provide a way for users of SML to define their own types.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In G erard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: 1 | x 2 =&gt; E 2 ,! V ev-destruct-mismatch If E evaluates to a constructor applied to a value that is different from the constructor mentioned in the destruct statement, bind x 2 to E and evaluate E 2 6.4 Elf Semantics I implemented the above semantics in Elf <ref> [Pfe91] </ref>. Elf is a logical programming language that allows proofs and semantics to be expressed and checked. Elf uses a technique called higher order abstract syntax, which allows you to use elf variables to represent the object language variables, in this case the non-polymorphic mini-ML's variables.
Reference: [Rep91] <author> J. H. Reppy. </author> <title> CML: a higher-order concurrent language. </title> <booktitle> In Proceedings of the ACM SIGPLAN 1991 Conference on Programming Language Design and Implementation, </booktitle> <year> 1991. </year>
Reference-contexts: A more complicated attempt that also does not work: signature MODULE=sig type term type value val eval : (term fl value option CML.chan) CML.chan end The idea here is that you can use CML <ref> [Rep91] </ref> channels and instantiate all of the eval threads at once, and then at some later time spawn a process to watch each of them. You would then have an evaluator that relied heavily on concurrency.
Reference: [Wad92] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Proceedings of the 19'th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: A monad has three important components, the type of monads, unitM and bindM. Their use and definition have been well documented in <ref> [Mog91a, Mog91b, LHJ95, Wad92] </ref>.
References-found: 18

