URL: http://www.cs.washington.edu/homes/jake/work/inv-tr980803.ps
Refering-URL: http://www.cs.washington.edu/homes/jake/work/work.html
Root-URL: http://www.cs.washington.edu
Title: Dynamically Discovering Likely Program Invariants to Support Program Evolution  
Author: Michael Ernst Jake Cockrell William G. Griswold and David Notkin 
Keyword: Program invariants, formal specification, software evolution, dynamic extraction, logical inference, pattern recognition  
Address: Box 352350, Seattle WA 98195-2350 USA  San Diego, 0114 La Jolla, CA 92093-0114 USA  
Affiliation: University of Washington  Dept. Computer Science Engineering University of Washington  Dept. Computer Science Engineering University of California  
Pubnum: Technical Report UW-CSE-98-08-03  
Email: fmernst,jake,notking@cs.washington.edu  wgg@cs.ucsd.edu  
Phone: +1-206-543-1695  +1-619-534-6898  
Date: August 27, 1998  
Abstract: Explicitly stated program invariants can help programmers by identifying program properties that must be preserved when modifying code. In practice, however, these invariants are usually implicit. An alternative to expecting programmers to fully annotate code with invariants is to automatically infer invariants from the program itself. This research focuses on dynamic techniques for discovering invariants from execution traces. This paper reports two results. First, it describes techniques for dynamically discovering invariants, along with an instrumentation and inference engine that embodies these techniques. Second, it reports on the application of the engine to two sets of target programs. In programs from Gries's work on program derivation, we rediscovered predefined invariants. In C programs lacking explicit invariants, we discovered invariants that assisted a software evolution task. 
Abstract-found: 1
Intro-found: 1
Reference: [BBM97] <author> N. Bjorner, A. Browne, and Z. Manna. </author> <title> Automatic generation of invariants and intermediate assertions. </title> <journal> Theoretical Computer Science, </journal> <volume> 173(1) </volume> <pages> 49-87, </pages> <month> Feb. </month> <year> 1997. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program <ref> [Weg74, GW75, KM76, BBM97] </ref>. Variable types are a variety of formal specification and documentation and whose checking can detect errors.
Reference: [BG93] <author> I. Bratko and M. Grobelnik. </author> <title> Inductive learning applied to program construction and verification. </title> <editor> In J. Cuena, editor, </editor> <volume> AIFIPP '92, </volume> <pages> pp 169-182. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: a software change has affected the invariants, an invariant-differencing tool could help focus on invariants that have changed. 6 RELATED WORK Dynamic Inference The research most directly related to ours uses inductive logic programming (ILP) [Qui90, Coh94] to construct Horn clause loop invariants from variable values on particular loop executions <ref> [BG93] </ref>.
Reference: [BLS96] <author> S. Bensalem, Y. Lakhnech, and H. Saidi. </author> <title> Powerful techniques for the automatic generation of invariants. </title> <booktitle> In CAV, </booktitle> <pages> pp 323-335, </pages> <year> 1996. </year>
Reference-contexts: Considerable research has addressed checking formal specifications [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92]; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than actually doing the checking <ref> [Weg74, BLS96] </ref>; our goal is the discovery of such properties from a broad class of possible ones. Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program [Weg74, GW75, KM76, BBM97].
Reference: [Coh94] <author> W. W. Cohen. </author> <title> Grammatically biased learning: learning logic programs using an explicit antecedent description language. </title> <journal> Artificial Intelligence, </journal> <volume> 68 </volume> <pages> 303-366, </pages> <year> 1994. </year>
Reference-contexts: Since a programmer might like to know how a software change has affected the invariants, an invariant-differencing tool could help focus on invariants that have changed. 6 RELATED WORK Dynamic Inference The research most directly related to ours uses inductive logic programming (ILP) <ref> [Qui90, Coh94] </ref> to construct Horn clause loop invariants from variable values on particular loop executions [BG93].
Reference: [CW98a] <author> J. E. Cook and A. L. Wolf. </author> <title> Discovering models of software processes from event-based data. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> July </month> <year> 1998. </year>
Reference-contexts: Cook and Wolf use event traces, which describe the sequence of events in a possibly concurrent system, to produce a finite state machine generating the trace <ref> [CW98b, CW98a] </ref>. Static Inference Static analyses operate on the program text, not particular test runs, and are typically sound but conservative.
Reference: [CW98b] <author> J. E. Cook and A. L. Wolf. </author> <title> Event-based detection of concurrency. </title> <booktitle> In FSE, </booktitle> <address> Orlando, FL, </address> <month> Nov. </month> <year> 1998. </year>
Reference-contexts: Cook and Wolf use event traces, which describe the sequence of events in a possibly concurrent system, to produce a finite state machine generating the trace <ref> [CW98b, CW98a] </ref>. Static Inference Static analyses operate on the program text, not particular test runs, and are typically sound but conservative.
Reference: [DC94] <author> M. B. Dwyer and L. A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <booktitle> In FSE, </booktitle> <pages> pp 62-75, </pages> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of checking some such properties at runtime makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically.
Reference: [Det96] <author> D. L. Detlefs. </author> <title> An overview of the Extended Static Checking system. </title> <booktitle> In First Workshop on Formal Methods in Software Practice, </booktitle> <pages> pp 1-9, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of checking some such properties at runtime makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically.
Reference: [EGHT94] <author> D. Evans, J. Guttag, J. Horning, and Y. M. Tan. LCLint: </author> <title> A tool for using specifications to check code. </title> <booktitle> FSE, </booktitle> <pages> pp 87-97, </pages> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of checking some such properties at runtime makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically.
Reference: [Eva96] <author> D. Evans. </author> <title> Static detection of dynamic memory errors. </title> <booktitle> In PLDI, </booktitle> <pages> pp 44-53, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of checking some such properties at runtime makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically.
Reference: [GH96] <author> R. Ghiya and L. J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In POPL, </booktitle> <pages> pp 1-15, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Variable types are a variety of formal specification and documentation and whose checking can detect errors. Type inference extends partial type annotations to full ones; similarly, Givan [Giv96] extends specifications on the inputs of a procedure to its output, and ADDS propagates data structure shape descriptions through a program <ref> [HHN92, GH96] </ref>. In the case of array bounds checking [SI77, Gup90, KW95, XP98], the desired property is obvious. Other related work includes the Illustrating Compiler, which heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90].
Reference: [Giv96] <author> R. Givan. </author> <title> Inferring program specifications in polynomial-time. </title> <booktitle> In SAS, </booktitle> <pages> pp 205-219, </pages> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: Variable types are a variety of formal specification and documentation and whose checking can detect errors. Type inference extends partial type annotations to full ones; similarly, Givan <ref> [Giv96] </ref> extends specifications on the inputs of a procedure to its output, and ADDS propagates data structure shape descriptions through a program [HHN92, GH96]. In the case of array bounds checking [SI77, Gup90, KW95, XP98], the desired property is obvious.
Reference: [Gri81] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: Our first result is a set of techniques, and an implementation, for discovering invariants from execution traces (Section 3). Our second result is the application of the engine to two sets of target programs. The first set of programs, taken from The Science of Programming <ref> [Gri81] </ref>, was derived from formal preconditions, postconditions, and loop invariants. Given runs of the program based on randomized inputs, our techniques derive those same program properties, plus some additional ones (Section 2). <p> Section 6 surveys related work, and Section 7 concludes. 2 REDISCOVERY OF INVARIANTS To introduce our approach and illustrate the output of our tool, we present the invariants detected in a simple program taken from The Science of Programming <ref> [Gri81] </ref>, a book that espouses deriving programs from specifications. Unlike typical programs, for which it may be difficult to determine the desired output of invariant detection, many of the book's programs include preconditions, postconditions, and loop invariants that embody important properties of the computation.
Reference: [Gup90] <author> R. Gupta. </author> <title> A fresh look at optimizing array bound checking. </title> <booktitle> In PLDI, </booktitle> <pages> pp 272-282, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Type inference extends partial type annotations to full ones; similarly, Givan [Giv96] extends specifications on the inputs of a procedure to its output, and ADDS propagates data structure shape descriptions through a program [HHN92, GH96]. In the case of array bounds checking <ref> [SI77, Gup90, KW95, XP98] </ref>, the desired property is obvious. Other related work includes the Illustrating Compiler, which heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90].
Reference: [GW75] <author> S. M. German and B. Wegbreit. </author> <title> A synthesizer of inductive assertions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(1) </volume> <pages> 68-75, </pages> <month> Mar. </month> <year> 1975. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program <ref> [Weg74, GW75, KM76, BBM97] </ref>. Variable types are a variety of formal specification and documentation and whose checking can detect errors.
Reference: [HFGO94] <author> M. Hutchins, H. Foster, T. Goradia, and T. </author> <title> Ostrand. Experiments on the effectiveness of dataflow- and controlflow-based test adequacy criteria. </title> <booktitle> In ICSE, </booktitle> <pages> pp 191-200, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Given runs of the program based on randomized inputs, our techniques derive those same program properties, plus some additional ones (Section 2). In contrast, the second set|eight C programs, originally from Siemens <ref> [HFGO94] </ref>, and modified by Rothermel and Harrold [RH98]|is not annotated with invariants, nor is there any indication that invariants were used in their construction. Section 4 shows how numeric invariants dynamically inferred from these programs assist in understanding, and making changes to, them. <p> This section demonstrates that derived invariants can help a programmer to evolve a program that contains no explicitly stated invariants. In particular, we used invariants produced by our implementation in evolving a program from the Siemens suite <ref> [HFGO94, RH98] </ref>. The Task The Siemens replace program, 563 lines of C, takes a regular expression and a replacement string as command-line arguments, writing an input stream to an output stream while replacing any substring matched by the regular expression with the replacement string.
Reference: [HHN92] <author> L. J. Hendren, J. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In PLDI, </booktitle> <pages> pp 249-260, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Variable types are a variety of formal specification and documentation and whose checking can detect errors. Type inference extends partial type annotations to full ones; similarly, Givan [Giv96] extends specifications on the inputs of a procedure to its output, and ADDS propagates data structure shape descriptions through a program <ref> [HHN92, GH96] </ref>. In the case of array bounds checking [SI77, Gup90, KW95, XP98], the desired property is obvious. Other related work includes the Illustrating Compiler, which heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90].
Reference: [HRWY98] <author> M. J. Harrold, G. Rothermel, R. Wu, and L. Yi. </author> <title> An empirical investigation of program spectra. </title> <booktitle> In PASTE '98, </booktitle> <pages> pp 83-90, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: However, we believe applying these techniques to subproblems of our task will be fruitful. Other dynamic analyses that examine program executions are used for software tasks from testing to debugging. Program spectra (specific aspects of program runs, such as event traces, code coverage, or outputs) <ref> [RBDL97, HRWY98] </ref> can reveal differences in inputs or program versions. Cook and Wolf use event traces, which describe the sequence of events in a possibly concurrent system, to produce a finite state machine generating the trace [CW98b, CW98a].
Reference: [HWF90] <author> R. Henry, K. M. Whaley, and B. Forstall. </author> <title> The University of Washington Illustrating Compiler. </title> <booktitle> In PLDI, </booktitle> <pages> pp 223-246, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In the case of array bounds checking [SI77, Gup90, KW95, XP98], the desired property is obvious. Other related work includes the Illustrating Compiler, which heuristically detects the abstract datatype implemented by a collection of concrete operations <ref> [HWF90] </ref>. Staging and binding-time analyses determine invariant or semi-invariant values for use in partial evaluation [JGS93]. 7 CONCLUSIONS This paper documents the feasibility of discovering program invariants based on execution traces, as well as the usefulness of these invariants in a software evolution task.
Reference: [JGS93] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Other related work includes the Illustrating Compiler, which heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90]. Staging and binding-time analyses determine invariant or semi-invariant values for use in partial evaluation <ref> [JGS93] </ref>. 7 CONCLUSIONS This paper documents the feasibility of discovering program invariants based on execution traces, as well as the usefulness of these invariants in a software evolution task. The techniques we have developed, along with the prototype implementation, are adequately fast when applied to programs of several hundred lines.
Reference: [JvH + 98] <author> B. Jacobs, J. van den Berg, M. Huisman, M. van Berkum, U. Hensel, and H. Tews. </author> <title> Reasoning about Java classes. </title> <booktitle> In OOPSLA, </booktitle> <address> Vancouver, BC, Canada, </address> <month> Oct. </month> <year> 1998. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of checking some such properties at runtime makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically.
Reference: [KM76] <author> S. Katz and Z. Manna. </author> <title> Logical analysis of programs. </title> <journal> Communications of the ACM, </journal> <volume> 19(4) </volume> <pages> 188-206, </pages> <month> Apr. </month> <year> 1976. </year>
Reference-contexts: Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program <ref> [Weg74, GW75, KM76, BBM97] </ref>. Variable types are a variety of formal specification and documentation and whose checking can detect errors.
Reference: [KW95] <author> P. Kolte and M. Wolfe. </author> <title> Elimination of redundant array subscript range checks. </title> <booktitle> In PLDI, </booktitle> <pages> pp 270-278, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Type inference extends partial type annotations to full ones; similarly, Givan [Giv96] extends specifications on the inputs of a procedure to its output, and ADDS propagates data structure shape descriptions through a program [HHN92, GH96]. In the case of array bounds checking <ref> [SI77, Gup90, KW95, XP98] </ref>, the desired property is obvious. Other related work includes the Illustrating Compiler, which heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90].
Reference: [LN98] <author> K. R. M. Leino and G. Nelson. </author> <title> An extended static checker for Modula-3. </title> <booktitle> In Compiler Construction '98, </booktitle> <pages> pp 302-305. </pages> <publisher> Springer-Verlag, </publisher> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of checking some such properties at runtime makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically.
Reference: [Mit97] <author> T. M. Mitchell. </author> <title> Machine Learning. </title> <address> WCB/McGraw-Hill, Boston, MA, </address> <year> 1997. </year>
Reference-contexts: Traditionally, machine learning attempts to learn a function over n 1 variables producing the n th or to classify examples into specified categories, neither of which is directly applicable to our problem <ref> [Mit97] </ref>. However, we believe applying these techniques to subproblems of our task will be fruitful. Other dynamic analyses that examine program executions are used for software tasks from testing to debugging.
Reference: [NCOD97] <author> G. Naumovich, L. A. Clarke, L. J. Osterweil, and M. B. Dwyer. </author> <title> Verification of concurrent software with FLAVERS. </title> <booktitle> In ICSE, </booktitle> <pages> pp 594-595. </pages> <publisher> Springer, </publisher> <month> May </month> <year> 1997. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of checking some such properties at runtime makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically.
Reference: [OJ97] <author> R. O'Callahan and D. Jackson. Lackwit: </author> <title> A program understanding tool based on type inference. </title> <booktitle> In ICSE, </booktitle> <pages> pp 338-348, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: More complicated derived variables may be added for complex expressions that appear in the program text; derived variables or invariants may also involve functions defined in the program. Type analysis can indicate which variables are incomparable, even if they have the same type in the programming language <ref> [OJ97] </ref>. User Interface A large data set and large number of derived invariants can be overwhelming. We have already developed a tool that retrieves from the data set the variable-value tuples that satisfy or falsify an invariant. There are also several ways to improve the presentation of invariants themselves.
Reference: [Pfe92] <author> F. Pfenning. </author> <title> Dependent types in logic programming. </title> <booktitle> In Types in Logic Programming, chapter 10, </booktitle> <pages> pp 285-311. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: For instance, accurate alias analysis is still beyond the state of the art, so many static checkers must give up in the face of pointer manipulation. The ease of checking some such properties at runtime makes static and dynamic techniques complementary. Considerable research has addressed checking formal specifications <ref> [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92] </ref>; this work could be used to verify likely invariants discovered dynamically.
Reference: [Qui90] <author> J. R. Quinlan. </author> <title> Learning logical definitions from relations. </title> <journal> Machine Learning, </journal> <volume> 5 </volume> <pages> 239-266, </pages> <year> 1990. </year>
Reference-contexts: Since a programmer might like to know how a software change has affected the invariants, an invariant-differencing tool could help focus on invariants that have changed. 6 RELATED WORK Dynamic Inference The research most directly related to ours uses inductive logic programming (ILP) <ref> [Qui90, Coh94] </ref> to construct Horn clause loop invariants from variable values on particular loop executions [BG93].
Reference: [RBDL97] <author> T. Reps, T. Ball, M. Das, and J. Larus. </author> <title> The use of program profiling for software maintenance with applications to the year 2000 problem. </title> <booktitle> In ESEC/FSE, </booktitle> <pages> pp 432-449, </pages> <month> Sept. </month> <year> 1997. </year>
Reference-contexts: However, we believe applying these techniques to subproblems of our task will be fruitful. Other dynamic analyses that examine program executions are used for software tasks from testing to debugging. Program spectra (specific aspects of program runs, such as event traces, code coverage, or outputs) <ref> [RBDL97, HRWY98] </ref> can reveal differences in inputs or program versions. Cook and Wolf use event traces, which describe the sequence of events in a possibly concurrent system, to produce a finite state machine generating the trace [CW98b, CW98a].
Reference: [RH98] <author> G. Rothermel and M. J. Harrold. </author> <title> Empirical studies of a safe regression test selection technique. </title> <journal> Transactions on Software Engineering, </journal> <volume> 24(6) </volume> <pages> 401-419, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: This section demonstrates that derived invariants can help a programmer to evolve a program that contains no explicitly stated invariants. In particular, we used invariants produced by our implementation in evolving a program from the Siemens suite <ref> [HFGO94, RH98] </ref>. The Task The Siemens replace program, 563 lines of C, takes a regular expression and a replacement string as command-line arguments, writing an input stream to an output stream while replacing any substring matched by the regular expression with the replacement string.
Reference: [SI77] <author> N. Suzuki and K. Ishihata. </author> <title> Implementation of an array bound checker. </title> <booktitle> In POPL, </booktitle> <pages> pp 132-143, </pages> <address> Los Angeles, California, </address> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: Type inference extends partial type annotations to full ones; similarly, Givan [Giv96] extends specifications on the inputs of a procedure to its output, and ADDS propagates data structure shape descriptions through a program [HHN92, GH96]. In the case of array bounds checking <ref> [SI77, Gup90, KW95, XP98] </ref>, the desired property is obvious. Other related work includes the Illustrating Compiler, which heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90].
Reference: [van97] <author> G. van Rossum. </author> <title> Python Reference Manual, </title> <note> release 1.5 edition, </note> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: On average, 500 test cases produce 4775 samples per instrumentation point, and our system takes 207 seconds to infer the invariants for that point on a 200MHz UltraSPARC 2. Our prototype implementation uses the interpreted language Python <ref> [van97] </ref>. At one point we improved performance by nearly a factor of ten by inlining two one-line procedures, but we have not yet seriously optimized our implementation.
Reference: [Weg74] <author> B. Wegbreit. </author> <title> The synthesis of loop predicates. </title> <journal> Communications of the ACM, </journal> <volume> 17(2) </volume> <pages> 102-112, </pages> <month> Feb. </month> <year> 1974. </year>
Reference-contexts: Considerable research has addressed checking formal specifications [DC94, EGHT94, Det96, Eva96, NCOD97, LN98, JvH + 98, Pfe92]; this work could be used to verify likely invariants discovered dynamically. Determining what property to check is considered harder than actually doing the checking <ref> [Weg74, BLS96] </ref>; our goal is the discovery of such properties from a broad class of possible ones. Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program [Weg74, GW75, KM76, BBM97]. <p> Some formal proof systems generate intermediate assertions for help in proving a given goal formula by propagating known invariants forward or backward in the program <ref> [Weg74, GW75, KM76, BBM97] </ref>. Variable types are a variety of formal specification and documentation and whose checking can detect errors.
Reference: [XP98] <author> H. Xi and F. Pfenning. </author> <title> Eliminating array bound checking through dependent types. </title> <booktitle> In PLDI, </booktitle> <pages> pp 249-257, </pages> <month> June </month> <year> 1998. </year> <month> 10 </month>
Reference-contexts: Type inference extends partial type annotations to full ones; similarly, Givan [Giv96] extends specifications on the inputs of a procedure to its output, and ADDS propagates data structure shape descriptions through a program [HHN92, GH96]. In the case of array bounds checking <ref> [SI77, Gup90, KW95, XP98] </ref>, the desired property is obvious. Other related work includes the Illustrating Compiler, which heuristically detects the abstract datatype implemented by a collection of concrete operations [HWF90].
References-found: 35

