URL: http://www.iro.umontreal.ca/~mckenzie/jelamc97.ps
Refering-URL: http://www.iro.umontreal.ca/~mckenzie/publications.html
Root-URL: http://www.iro.umontreal.ca
Title: Tree Isomorphism and Some Other Complete Problems for Deterministic Logspace Nous signalons finalement l'effet du
Author: Birgit Jenner Klaus-Jorn Lange Pierre McKenzie complexite de certains problemes de calculs de la classe L. 
Keyword: Resume  
Note: 2 e sommets.  During academic year 1996-97 on vacation from Wilhelm-Schickard-Institut  Work supported by NSERC of Canada and by FCAR  
Address: Montreal  Oberer Eselsberg, 89075 Ulm.  Tubingen, Sand 13, D-72076 Tubingen, Germany.  Sand 13, D-72076 Tubingen, Germany.  Montreal, C.P. 6128, Suc-cursale Centre-ville, Montreal (Quebec), H3C 3J7 Canada.  du Quebec.  
Affiliation: Universitat Ulm  Universitat Tubingen  Universite de  Abt. Theoretische Informatik, Universitat Ulm,  fur Informatik, Universitat  Wilhelm-Schickard-Institut fur Informatik, Universitat Tubingen,  Dep. d'informatique et recherche operationnelle, Universite de  
Email: E-mail: jenner@informatik.uni-ulm.de  E-mail: lange@informatik.uni-tuebingen.de  E-mail: mckenzie@iro.umontreal.ca  
Date: March 27, 1997  
Abstract: Several new tree problems are shown complete for deterministic logarithmic space. These include the tree centroid problem and the tree isomorphism problem, which thus becomes the first isomorphism problem of a combinatorial nature shown complete for a fundamental resource-based complexity class. The crucial role of the input representation of trees, as edge lists or as bracketed expressions, on the hardness of tree problems, is also discussed. Nous demontrons que certains problemes concernant des arbres sont complets pour la classe de complexite L formee des langages reconnus en espace loga-rithmique. Un de ces problemes est celui de determiner si deux arbres sont isomorphes. Il s'agit donc dans ce cas d'un premier probleme d'isomorphisme a caractere combinatoire dont on puisse demontrer la completude pour une classe de complexite robuste definie par bornes de ressources. Un autre probleme dont nous prouvons la L-completude est celui de determiner si le retrait d'un sommet donne d'un arbre de n sommets resulte en sous-arbres d'au plus d n 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Alvarez and B. Jenner. </author> <title> On adaptive dlogtime and polylogtime reductions. </title> <journal> Theoretical Computer Science, </journal> 1974 175-193, 1995. 
Reference: [2] <author> J. Avenhaus and K. Madlener. </author> <title> The Nielsen reduction and P-complete problems in free groups. </title> <journal> Theoretical Computer Science, </journal> <volume> 32 </volume> <pages> 61-76, </pages> <year> 1984. </year>
Reference-contexts: TI thus becomes one the select few isomorphism problems found complete for a robust complexity class. To the best of our knowledge, the one example of a complete isomorphism problem is the isomorphism problem for two given subgroups of a free group, shown P-complete by Avenhaus and Madlener <ref> [2] </ref>. Isomorphism problems defined from computational models, as for example, Boolean circuits or branching programs, are not known to be complete for a complexity class (see for example the introduction of [22]).
Reference: [3] <author> D. A. M. Barrington, N. Immerman, and H. Straubing. </author> <title> On uniformity within N C 1 . Journal of Computer and System Sciences, </title> <booktitle> 41 </booktitle> <pages> 274-306, </pages> <year> 1990. </year>
Reference-contexts: Hence the most common resources chosen are NC 1 , AC 0 , DLOGTIME, and quantifier-free projections. Here NC 1 (AC 0 ) 3 denotes the class of functions computable with DLOGTIME-uniform (semi--unbounded fan-in) Boolean circuit families of polynomial size and logarithmic (constant) depth (see e.g. <ref> [3] </ref>). DLOGTIME is the class of problems computable by logarithmic time-bounded Turing machines (see e.g.[1]); for quantifier-free projections see [14]. For our completeness results, we will use two variants of AC 0 -reducibility, namely, AC 0 -many-one reducibility and AC 0 -Turing reducibility.
Reference: [4] <author> M. Beaudry and P. McKenzie. </author> <title> Circuits, matrices and nonassociative computation. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 50(3) </volume> <pages> 441-455, </pages> <year> 1995. </year> <month> 14 </month>
Reference-contexts: Vice versa, the NC 1 -complete Boolean Formula Value Problem becomes L-complete, when defined over trees that are presented via pairs of nodes (see <ref> [4, p. 445] </ref> or [15]). Accordingly, changing the representation of forests or trees is itself FL-complete: Compute Bracketed Expression (CBE) Given: A forest F = (V; E). Problem: Compute the bracketed expression E (F ) of F . Classification: FL-complete. <p> Accordingly, changing the representation of forests or trees is itself FL-complete: Compute Bracketed Expression (CBE) Given: A forest F = (V; E). Problem: Compute the bracketed expression E (F ) of F . Classification: FL-complete. Reference: <ref> [4, 15] </ref> Remarks: Hardness is via NC 1 -Turing reducibility. Transforming the bracketed expression into a list of the edge relation is solvable in TC 0 .
Reference: [5] <author> A. K. Chandra, L. Stockmeyer, and U. Vishkin. </author> <title> Constant depth reducibil-ity. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13(2) </volume> <pages> 423-439, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: between L- or FL-complete problems are in fact such that in the reducing AC 0 -circuits, any path from the input gates to the output gate (s) contains at most one oracle gate. 1 This is the special notion of AC 0 -reducibility used by Chandra, Stockmeyer, and Vishkin in <ref> [5] </ref>. Throughout this paper, unless specifically mentioned otherwise, L-completeness will refer to AC 0 m , and FL-completeness will refer to AC 0 T . Some L-Complete Problems L has many natural complete problems from different areas including formal language theory, algebra, and graph theory.
Reference: [6] <author> S. A. Cook. </author> <title> Towards a complexity theory of synchronous parallel computation. </title> <address> L'Enseignement Mathematique, XXVII(1-2):75-100, </address> <year> 1981. </year>
Reference-contexts: Furthermore, L and its functional variant FL, the class of functions computable in logspace, have a variety of natural complete problems arising from formal language theory, from algebra, from graph theory, etc. <ref> [16, 6, 8, 9] </ref>. An up-to-date collection of Land FL-complete problems is in preparation [15]. In this paper we add four graph-theoretic problems to the list of L-complete problems. These are the isomorphism problem for trees, the node subtree iso-morphism problem, the tree size problem, and the centroid problem. <p> In the Turing case, the reduction is realized by AC 0 -circuits which contain so-called oracle gates that solve the incoming problem instances at unit cost: The size and depth of any such gate is one (see e.g. [23]). For NC 1 this reducibility was introduced by Cook <ref> [6, 7] </ref>. Turing reducibility is typically used when functional classes like FL are considered, since it allows interreducing functional and decisional problems easily (see e.g. [8]). <p> A tree is a forest with one connected component, and a line is a graph that consists of a sequence of edges. Now, acyclicity is only known to be computable in L for undirected graphs (in fact, it is L-complete) <ref> [6] </ref>. For directed graphs acyclicity is well-known to be NL-complete [16]. Are all the problems involving directed graphs below therefore promise problems 2 ? The answer is no, since the indegree conditions on the directed graphs input to these problems reduce testing acyclicity to testing acyclicity in undirected graphs. <p> Classification: L-complete. Reference: [15] Hint: For undirected graphs, G is a forest iff G is acyclic, that is, G does not contain any cycles, which is the L-complete problem CYCLE of <ref> [6] </ref>. For directed graphs, we can reduce IF to CYCLE, since the indegree one bound ensures that removing the directions of the edges does not increase the number of cycles. Also, the graph constructed for hardness in [6] obeys the indegree bound. <p> G does not contain any cycles, which is the L-complete problem CYCLE of <ref> [6] </ref>. For directed graphs, we can reduce IF to CYCLE, since the indegree one bound ensures that removing the directions of the edges does not increase the number of cycles. Also, the graph constructed for hardness in [6] obeys the indegree bound. Is Tree (IT) Given: A (di)graph G = (V; E).
Reference: [7] <author> S. A. Cook. </author> <title> A taxonomy of problems with fast parallel algorithms. </title> <journal> Information and Control, </journal> <volume> 64(1) </volume> <pages> 2-22, </pages> <year> 1985. </year>
Reference-contexts: In the Turing case, the reduction is realized by AC 0 -circuits which contain so-called oracle gates that solve the incoming problem instances at unit cost: The size and depth of any such gate is one (see e.g. [23]). For NC 1 this reducibility was introduced by Cook <ref> [6, 7] </ref>. Turing reducibility is typically used when functional classes like FL are considered, since it allows interreducing functional and decisional problems easily (see e.g. [8]).
Reference: [8] <author> S. A. Cook and P. McKenzie. </author> <title> Problems complete for deterministic logarithmic space. </title> <journal> Journal of Algorithms, </journal> <volume> 8 </volume> <pages> 385-394, </pages> <year> 1987. </year>
Reference-contexts: Furthermore, L and its functional variant FL, the class of functions computable in logspace, have a variety of natural complete problems arising from formal language theory, from algebra, from graph theory, etc. <ref> [16, 6, 8, 9] </ref>. An up-to-date collection of Land FL-complete problems is in preparation [15]. In this paper we add four graph-theoretic problems to the list of L-complete problems. These are the isomorphism problem for trees, the node subtree iso-morphism problem, the tree size problem, and the centroid problem. <p> For NC 1 this reducibility was introduced by Cook [6, 7]. Turing reducibility is typically used when functional classes like FL are considered, since it allows interreducing functional and decisional problems easily (see e.g. <ref> [8] </ref>). More formally, AC 0 -Turing reducibility is defined as follows: For problems A; B fl , we have A AC 0 T B, if there exists an AC 0 -circuit family fC n g with oracle gates for B that computes A. <p> Disjunctive AC 0 -Turing reducibility is obtained by restricting the reducing circuit family fC n g to consisting of _-gates. One last special case is relevant to the study of classes L or FL. Any of the reductions given by Cook and McKenzie in <ref> [8] </ref> between L- or FL-complete problems are in fact such that in the reducing AC 0 -circuits, any path from the input gates to the output gate (s) contains at most one oracle gate. 1 This is the special notion of AC 0 -reducibility used by Chandra, Stockmeyer, and Vishkin in <p> Some L-Complete Problems L has many natural complete problems from different areas including formal language theory, algebra, and graph theory. A partial list of such problems can be found in <ref> [8] </ref>, and an up-to-date collection will appear in [15]. Here we recall some of the examples which we will require later in our hardness proofs. <p> Problem: Determine whether t belongs to the tree with root good. Classification: L-complete. Reference: <ref> [8] </ref> Hint: This is basically the problem Directed Forest Accessibility (DFA) of [8], where for a given acyclic directed graph G of outdegree zero or one with exactly two weakly connected components, and nodes u and v, it is required to determine whether there is a path between u and v. <p> Problem: Determine whether t belongs to the tree with root good. Classification: L-complete. Reference: <ref> [8] </ref> Hint: This is basically the problem Directed Forest Accessibility (DFA) of [8], where for a given acyclic directed graph G of outdegree zero or one with exactly two weakly connected components, and nodes u and v, it is required to determine whether there is a path between u and v. <p> Simply reverse the edges in G to obtain two directed (or rooted undirected) trees and choose u to be the root of T good . Remarks: The trees can also be unrooted. This is the problem UFA of <ref> [8] </ref>. <p> Problem: Is i 0 mapped to j 0 by the product of permutations k i=1 p i ? Classification: L-complete. Reference: <ref> [8, 14] </ref> Remarks: In [8] this problem is called Permutation Product (PP). PP is the functional variant that computes the resulting permutation. Hardness is proved with respect to NC 1 -Turing reducibility. [14] proves hardness with respect to quantifier-free projections. <p> Problem: Is i 0 mapped to j 0 by the product of permutations k i=1 p i ? Classification: L-complete. Reference: [8, 14] Remarks: In <ref> [8] </ref> this problem is called Permutation Product (PP). PP is the functional variant that computes the resulting permutation. Hardness is proved with respect to NC 1 -Turing reducibility. [14] proves hardness with respect to quantifier-free projections. <p> The latter problem, 1CC, is L-complete as shown in [15]. Hardness follows from the hardness of the problem Single Cycle Permutation of <ref> [8] </ref> by simply removing one edge. If there was a single cycle, then the result is a line, which is a tree; if there were two or more cycles, then removing an edge leaves at least one cycle and thus no tree. <p> Problem: Compute the bracketed expression E (F ) of F . Classification: FL-complete. Reference: [4, 15] Remarks: Hardness is via NC 1 -Turing reducibility. Transforming the bracketed expression into a list of the edge relation is solvable in TC 0 . Cook and McKenzie <ref> [8] </ref> pointed out similar representation-dependent complexity variations for permutation problems and showed that the transformation of a permutation presented pointwise (as (1); : : : ; (n)) to the disjoint cycle representation of is L-complete, while the reverse direction is computable in NC 1 (in fact, it is computable in AC
Reference: [9] <author> K. Etessami. </author> <title> Counting quantifiers, successor relations, and logarithmic space. </title> <booktitle> In Proc. of the 10th Structure in Complexity Theory Conf., </booktitle> <pages> pages 2-11. </pages> <publisher> IEEE, </publisher> <year> 1995. </year>
Reference-contexts: Furthermore, L and its functional variant FL, the class of functions computable in logspace, have a variety of natural complete problems arising from formal language theory, from algebra, from graph theory, etc. <ref> [16, 6, 8, 9] </ref>. An up-to-date collection of Land FL-complete problems is in preparation [15]. In this paper we add four graph-theoretic problems to the list of L-complete problems. These are the isomorphism problem for trees, the node subtree iso-morphism problem, the tree size problem, and the centroid problem. <p> Order between Vertices (ORD) Given: A digraph G = (V; E) that is a line, and two nodes i; j 2 V . Problem: Determine whether i &lt; j in the total order on V induced by G. Classification: L-complete. Reference: <ref> [9] </ref> Remarks: Hardness proved with respect to quantifier-free projections. Observe that it can be checked in L whether a digraph is a line (see problem IL of Section 3).
Reference: [10] <author> H. N. Gabow. Centroids, </author> <title> representations, and submodular flows. </title> <journal> Journal of Algorithms, </journal> <volume> 18 </volume> <pages> 586-628, </pages> <year> 1995. </year>
Reference-contexts: In 1869 Jordan showed that any tree has a centroid (see [12]). The computation of centroids is a tool of many algorithms of practical relevance (see e.g. <ref> [10] </ref>). All the L-complete problems that we present are defined on directed (and hence rooted) trees, but can be extended to undirected trees or forests (i.e., undirected acyclic graphs). <p> In 1869 Jordan showed that any tree has a centroid (see [12]). The computation of centroids is a tool in many algorithms of practical relevance (see e.g. <ref> [10] </ref>). The following problems correspond to checking and computing centroids for a given tree. Is Centroid (IC) Given: A tree T and one of its nodes v.
Reference: [11] <author> R. Greenlaw, H. J. Hoover, and W. L. Ruzzo. </author> <title> A Compendium of Problems Complete for P . Oxford University Press, </title> <year> 1994. </year>
Reference-contexts: A partial list of such problems can be found in [8], and an up-to-date collection will appear in [15]. Here we recall some of the examples which we will require later in our hardness proofs. We adopt the presentation format used by Greenlaw, Hoover, and Ruzzo <ref> [11] </ref>. 1 In fact, Cook and McKenzie use NC 1 -circuits instead of AC 0 -circuits. <p> Problem: Determine whether there is subgraph of T 1 that is iso morphic to T 2 . STI is known to be in solvable in P " RNC, but neither known to be P-complete <ref> [11] </ref> nor to be computable in NC. Our variant NSTI does not search for an arbitrary subgraph of T , but limits its quest to subgraphs that are complete subtrees subtended by particular nodes of T .
Reference: [12] <author> F. Harary. </author> <title> Graph Theory. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference-contexts: The fourth problem that we prove L-complete is the centroid problem. A centroid of a tree with n nodes is a node whose deletion leaves no subtree containing more than n 2 nodes ([24]). In 1869 Jordan showed that any tree has a centroid (see <ref> [12] </ref>). The computation of centroids is a tool of many algorithms of practical relevance (see e.g. [10]). All the L-complete problems that we present are defined on directed (and hence rooted) trees, but can be extended to undirected trees or forests (i.e., undirected acyclic graphs). <p> In 1869 Jordan showed that any tree has a centroid (see <ref> [12] </ref>). The computation of centroids is a tool in many algorithms of practical relevance (see e.g. [10]). The following problems correspond to checking and computing centroids for a given tree. Is Centroid (IC) Given: A tree T and one of its nodes v.
Reference: [13] <author> N. Immerman. </author> <title> Languages that capture complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 16(4) </volume> <pages> 760-778, </pages> <year> 1987. </year>
Reference-contexts: The class L is robust. Indeed, L was defined above using the Turing machine, but L is also characterized by k-head finite-automata, by (uniform) polynomial-size deterministic branching programs [20], and by logical formalisms <ref> [13] </ref>. Furthermore, L and its functional variant FL, the class of functions computable in logspace, have a variety of natural complete problems arising from formal language theory, from algebra, from graph theory, etc. [16, 6, 8, 9]. An up-to-date collection of Land FL-complete problems is in preparation [15].
Reference: [14] <author> N. Immerman and S. Landau. </author> <title> The complexity of iterated multiplication. </title> <journal> Information and Computation, </journal> <volume> 116 </volume> <pages> 103-116, </pages> <year> 1994. </year>
Reference-contexts: Here NC 1 (AC 0 ) 3 denotes the class of functions computable with DLOGTIME-uniform (semi--unbounded fan-in) Boolean circuit families of polynomial size and logarithmic (constant) depth (see e.g. [3]). DLOGTIME is the class of problems computable by logarithmic time-bounded Turing machines (see e.g.[1]); for quantifier-free projections see <ref> [14] </ref>. For our completeness results, we will use two variants of AC 0 -reducibility, namely, AC 0 -many-one reducibility and AC 0 -Turing reducibility. The former will be used only for reducing between languages, that is, for decision problems, and the latter will serve for both decision and functional problems. <p> Problem: Is i 0 mapped to j 0 by the product of permutations k i=1 p i ? Classification: L-complete. Reference: <ref> [8, 14] </ref> Remarks: In [8] this problem is called Permutation Product (PP). PP is the functional variant that computes the resulting permutation. Hardness is proved with respect to NC 1 -Turing reducibility. [14] proves hardness with respect to quantifier-free projections. <p> Reference: [8, 14] Remarks: In [8] this problem is called Permutation Product (PP). PP is the functional variant that computes the resulting permutation. Hardness is proved with respect to NC 1 -Turing reducibility. <ref> [14] </ref> proves hardness with respect to quantifier-free projections. Order between Vertices (ORD) Given: A digraph G = (V; E) that is a line, and two nodes i; j 2 V . Problem: Determine whether i &lt; j in the total order on V induced by G. Classification: L-complete.
Reference: [15] <author> B. Jenner. </author> <title> Between NC 1 and NC 2 : Classification of Problems by Logspace Resources. </title> <booktitle> Manuskript of Habilitation thesis, </booktitle> <year> 1997. </year>
Reference-contexts: Furthermore, L and its functional variant FL, the class of functions computable in logspace, have a variety of natural complete problems arising from formal language theory, from algebra, from graph theory, etc. [16, 6, 8, 9]. An up-to-date collection of Land FL-complete problems is in preparation <ref> [15] </ref>. In this paper we add four graph-theoretic problems to the list of L-complete problems. These are the isomorphism problem for trees, the node subtree iso-morphism problem, the tree size problem, and the centroid problem. We also discuss functional variants of these problems that are FL-complete. <p> Some L-Complete Problems L has many natural complete problems from different areas including formal language theory, algebra, and graph theory. A partial list of such problems can be found in [8], and an up-to-date collection will appear in <ref> [15] </ref>. Here we recall some of the examples which we will require later in our hardness proofs. We adopt the presentation format used by Greenlaw, Hoover, and Ruzzo [11]. 1 In fact, Cook and McKenzie use NC 1 -circuits instead of AC 0 -circuits. <p> This is made precise in the comments accompanying the problem definitions below. Is Forest (IF) Given: A (di)graph G = (V; E). Problem: Determine whether G is a forest, i.e., an acyclic undi-rected graph or an acyclic directed graph with maximal indegree one. Classification: L-complete. Reference: <ref> [15] </ref> Hint: For undirected graphs, G is a forest iff G is acyclic, that is, G does not contain any cycles, which is the L-complete problem CYCLE of [6]. <p> In our case, if Q specifies a property that is in fact checkable within logspace, then the relevant problem is in reality not a promise problem. 6 Classification: L-complete Reference: <ref> [15] </ref> Hint: For containment, we check acyclicity and the existence of at most one connected component. The latter problem, 1CC, is L-complete as shown in [15]. Hardness follows from the hardness of the problem Single Cycle Permutation of [8] by simply removing one edge. <p> specifies a property that is in fact checkable within logspace, then the relevant problem is in reality not a promise problem. 6 Classification: L-complete Reference: <ref> [15] </ref> Hint: For containment, we check acyclicity and the existence of at most one connected component. The latter problem, 1CC, is L-complete as shown in [15]. Hardness follows from the hardness of the problem Single Cycle Permutation of [8] by simply removing one edge. <p> Compute Line (CL) Given: A (di)graph G = (V; E) that is a line. Problem: Compute the sequence of nodes of G in the total order on V induced by G, that is, starting with the indegree zero node up to the outdegree zero node. Classification: FL-complete. Reference: <ref> [15] </ref> Hint: For containment, just check that there is no cycle in G. For hardness, reduce IL to CL. Unless specified otherwise, we assume that all forests or trees in our problems have specified roots (which always is ensured if the edges are directed). <p> Vice versa, the NC 1 -complete Boolean Formula Value Problem becomes L-complete, when defined over trees that are presented via pairs of nodes (see [4, p. 445] or <ref> [15] </ref>). Accordingly, changing the representation of forests or trees is itself FL-complete: Compute Bracketed Expression (CBE) Given: A forest F = (V; E). Problem: Compute the bracketed expression E (F ) of F . Classification: FL-complete. Reference: [4, 15] Remarks: Hardness is via NC 1 -Turing reducibility. <p> Accordingly, changing the representation of forests or trees is itself FL-complete: Compute Bracketed Expression (CBE) Given: A forest F = (V; E). Problem: Compute the bracketed expression E (F ) of F . Classification: FL-complete. Reference: <ref> [4, 15] </ref> Remarks: Hardness is via NC 1 -Turing reducibility. Transforming the bracketed expression into a list of the edge relation is solvable in TC 0 .
Reference: [16] <author> N. Jones. </author> <title> Space-bounded reducibility among combinatorial problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 11 </volume> <pages> 68-85, </pages> <year> 1975. </year>
Reference-contexts: Furthermore, L and its functional variant FL, the class of functions computable in logspace, have a variety of natural complete problems arising from formal language theory, from algebra, from graph theory, etc. <ref> [16, 6, 8, 9] </ref>. An up-to-date collection of Land FL-complete problems is in preparation [15]. In this paper we add four graph-theoretic problems to the list of L-complete problems. These are the isomorphism problem for trees, the node subtree iso-morphism problem, the tree size problem, and the centroid problem. <p> Now, acyclicity is only known to be computable in L for undirected graphs (in fact, it is L-complete) [6]. For directed graphs acyclicity is well-known to be NL-complete <ref> [16] </ref>. Are all the problems involving directed graphs below therefore promise problems 2 ? The answer is no, since the indegree conditions on the directed graphs input to these problems reduce testing acyclicity to testing acyclicity in undirected graphs.
Reference: [17] <author> R. M. Karp. </author> <title> Reducibility among combinatorial problems. </title> <editor> In R. E. Miller and J. W. Thatcher, editors, </editor> <booktitle> Complexity of Computer Computations, </booktitle> <pages> pages 85-103. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1972. </year>
Reference-contexts: Indeed it seems that the existential quantifier underlying the definition of NP is stronger than the existential quantifier implicit in the graph isomorphism problem. This "weakness" of the problem can be compensated by considering the subgraph isomorphism problem, which is NP-complete <ref> [17] </ref>.
Reference: [18] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> The Graph Isomorphism Problem | Its Structural Complexity. </title> <booktitle> Progress in Theoretical Computer Science. </booktitle> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1993. </year>
Reference-contexts: A more prominent example, the graph isomorphism problem, is trivially contained in NP but is probably not NP-hard (see <ref> [18] </ref>). Indeed it seems that the existential quantifier underlying the definition of NP is stronger than the existential quantifier implicit in the graph isomorphism problem. This "weakness" of the problem can be compensated by considering the subgraph isomorphism problem, which is NP-complete [17]. <p> An algorithm solving the promise problem is only required to decide R (x) under the assumption that x in fact satisfies predicate Q, and it may answer arbitrarily on inputs for which :Q (x) (see [21] or <ref> [18, p. 39] </ref>). The predicate Q is appropriately called a promise only when the complexity of Q is not known to be bounded by the complexity of R.
Reference: [19] <author> S. Lindell. </author> <title> A logspace algorithm for tree canonization. </title> <booktitle> In Proc. of the 24th STOC, </booktitle> <pages> pages 400-404. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: These are the isomorphism problem for trees, the node subtree iso-morphism problem, the tree size problem, and the centroid problem. We also discuss functional variants of these problems that are FL-complete. It was shown by Lindell <ref> [19] </ref> that tree isomorphism (TI) is contained in L. We show here that TI is actually complete for L with respect to (disjunctive) AC 0 -Turing reductions and that the node subtree isomorphism problem NSTI is complete for L with respect to AC 0 -many-one reductions. <p> permutation presented pointwise (as (1); : : : ; (n)) to the disjoint cycle representation of is L-complete, while the reverse direction is computable in NC 1 (in fact, it is computable in AC 0 ). 4 Tree Isomorphism First we define tree isomorphism and subtree isomorphism formally (see also <ref> [19] </ref>). Let S and T be two trees. <p> The following problem was shown by Lindell <ref> [19] </ref> to be contained in L. Tree Isomorphism (TI) Given: Two trees T 1 and T 2 . Problem: Determine whether T 1 is isomorphic to T 2 . Reference: [19] Remarks: Lindell shows that for a given tree the canon can be computed in logspace (see problem CC below), which <p> The following problem was shown by Lindell <ref> [19] </ref> to be contained in L. Tree Isomorphism (TI) Given: Two trees T 1 and T 2 . Problem: Determine whether T 1 is isomorphic to T 2 . Reference: [19] Remarks: Lindell shows that for a given tree the canon can be computed in logspace (see problem CC below), which yields TI 2 L. TI can be generalized to the problem Forest Isomorphism, if forests instead of trees are given. Lindell showed that FI is also contained in L. <p> TI can be generalized to the problem Forest Isomorphism, if forests instead of trees are given. Lindell showed that FI is also contained in L. We first show Theorem 4.1 TI is L-complete with respect to disjunctive AC 0 T -reducibility. Proof. For containment, see the article of Lindell <ref> [19] </ref> who shows that the canon c (T ) of a (rooted) tree T , can be computed in logspace. Hence, for two given trees we determine isomorphism by computing and comparing their canons symbol by symbol. <p> Theorem 4.2 NSTI is L-complete with respect to AC 0 m -reducibility. Proof. For containment, simply check for all nodes v of T 1 whether its subtree is isomorphic to T 2 using Lindell's algorithm that shows TI 2 L <ref> [19] </ref>. To mark the current node v only logspace is necessary, and for any node u it can be checked in logspace whether u belongs to the subtree of v. For hardness, we reduce ORD to NSTI as in the proof of Theorem 4.1. <p> Compute Canon (CC) Given: A tree T . Problem: Compute the canon of T . Reference: <ref> [19] </ref> Remarks: [19] shows that CC 2 FL: Proposition 4.4 CC is FL-complete with respect to AC 0 T reducibility. Proof. Containment follows with Lindell [19]. For hardness, reduce TI to CC. <p> Compute Canon (CC) Given: A tree T . Problem: Compute the canon of T . Reference: <ref> [19] </ref> Remarks: [19] shows that CC 2 FL: Proposition 4.4 CC is FL-complete with respect to AC 0 T reducibility. Proof. Containment follows with Lindell [19]. For hardness, reduce TI to CC. Two oracle gates are queried in parallel for the canons of the given trees T 1 ; T 2 . <p> Compute Canon (CC) Given: A tree T . Problem: Compute the canon of T . Reference: <ref> [19] </ref> Remarks: [19] shows that CC 2 FL: Proposition 4.4 CC is FL-complete with respect to AC 0 T reducibility. Proof. Containment follows with Lindell [19]. For hardness, reduce TI to CC. Two oracle gates are queried in parallel for the canons of the given trees T 1 ; T 2 .
Reference: [20] <author> C. Meinel. </author> <title> The power of nondeterminism in polynomial-size bounded-width branching programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 62 </volume> <pages> 319-325, </pages> <year> 1988. </year> <month> 15 </month>
Reference-contexts: The class L is robust. Indeed, L was defined above using the Turing machine, but L is also characterized by k-head finite-automata, by (uniform) polynomial-size deterministic branching programs <ref> [20] </ref>, and by logical formalisms [13]. Furthermore, L and its functional variant FL, the class of functions computable in logspace, have a variety of natural complete problems arising from formal language theory, from algebra, from graph theory, etc. [16, 6, 8, 9].
Reference: [21] <author> A. L. Selman. </author> <title> Promise problems and complexity classes. </title> <journal> Information and Computation, </journal> <volume> 78 </volume> <pages> 87-98, </pages> <year> 1988. </year>
Reference-contexts: An algorithm solving the promise problem is only required to decide R (x) under the assumption that x in fact satisfies predicate Q, and it may answer arbitrarily on inputs for which :Q (x) (see <ref> [21] </ref> or [18, p. 39]). The predicate Q is appropriately called a promise only when the complexity of Q is not known to be bounded by the complexity of R.
Reference: [22] <author> T. Thierauf. </author> <title> The isomorphism problem for one-time-only branching programs and arithmetic circuits. </title> <type> Technical Report ECCC-TR96-040, </type> <note> http://www.eccc.uni-trier.de/eccc/, 1996. </note>
Reference-contexts: Isomorphism problems defined from computational models, as for example, Boolean circuits or branching programs, are not known to be complete for a complexity class (see for example the introduction of <ref> [22] </ref>). A more prominent example, the graph isomorphism problem, is trivially contained in NP but is probably not NP-hard (see [18]). Indeed it seems that the existential quantifier underlying the definition of NP is stronger than the existential quantifier implicit in the graph isomorphism problem.
Reference: [23] <author> C. B. Wilson. </author> <title> On the decomposability of NC and AC. </title> <journal> SIAM Journal on Computing, </journal> <volume> 19(2) </volume> <pages> 384-396, </pages> <year> 1990. </year>
Reference-contexts: In the Turing case, the reduction is realized by AC 0 -circuits which contain so-called oracle gates that solve the incoming problem instances at unit cost: The size and depth of any such gate is one (see e.g. <ref> [23] </ref>). For NC 1 this reducibility was introduced by Cook [6, 7]. Turing reducibility is typically used when functional classes like FL are considered, since it allows interreducing functional and decisional problems easily (see e.g. [8]).
Reference: [24] <author> R. J. Wilson and J. J. Watkins. </author> <title> Graphs: An Introductory Approach. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1990. </year> <month> 16 </month>
References-found: 24

