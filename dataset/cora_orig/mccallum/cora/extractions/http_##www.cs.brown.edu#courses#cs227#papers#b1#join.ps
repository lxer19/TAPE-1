URL: http://www.cs.brown.edu/courses/cs227/papers/b1/join.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Title: Rapid Bushy Join-order Optimization with Cartesian Products  
Author: Bennet Vance David Maier 
Date: November 30, 1995  
Affiliation: Oregon Graduate Institute of Science Technology  
Abstract: Query optimizers often limit the search space for join orderings, for example by excluding Cartesian products in subplans or requiring at least one input of each join to be a stored relation. Such exclusions are widely assumed to reduce optimization effort while minimally affecting plan quality. However, we show that searching the complete space of plans is more affordable than has been previously recognized, and that the common exclusions may be of little benefit. We start by presenting a Cartesian product optimizer that easily searches the space of bushy plans for 15-way Cartesian products in a matter of seconds on high-performance workstations. By building on this optimizer we then obtain a join-order optimizer that achieves a similar level of performance, and retains the ability to include Cartesian products in subplans wherever appropriate. The main contribution of the paper is in fully separating join-order enumeration from predicate analysis, and in showing that the former problem in particular can be solved swiftly by novel implementation techniques. A secondary contribution is to initiate a systematic approach to the benchmarking of join-order optimization, which we apply to the evaluation of our method. 
Abstract-found: 1
Intro-found: 1
Reference: [CM95] <author> Sophie Cluet and Guido Moerkotte. </author> <title> On the complexity of generating optimal left-deep processing trees with cross products. </title> <editor> In Georg Gottlob and Moshe Y. Vardi, editors, </editor> <booktitle> Proceedings of the 5th 20 International Conference on Database Theory, volume 893 of Lecture Notes in Computer Science, </booktitle> <pages> pages 54-67, </pages> <address> Prague, Czech Republic, </address> <month> January </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Admittedly, in the work described here, we assume that predicates are uncorrelated, and the cost models we consider are relatively simple. Note, though, that such simplifications are not unusual in the research literature <ref> [GLPK94, CM95, SMK93] </ref>. In benchmarking our join-optimization method, we attempt to isolate the characteristics of the input that influence performance. <p> The complexity for star queries is O (n2 n ), again without Cartesian products. When Cartesian products are considered, complexity is O (n2 n ) for a left-deep search, and O (3 n ) for a bushy search, regardless of the join graph. Cluet and Moerkotte <ref> [CM95] </ref>, also noting the potential value of Cartesian products in join plans, study the feasibility of optimization with Cartesian products from a theoretical standpoint. Their work, which considers only left-deep plan spaces, addresses the question of extending a join-optimization result from Ibaraki and Kameda [IK84].
Reference: [GLPK94] <author> Cesar Galindo-Legaria, Arjan Pellenkoft, and Martin Kersten. </author> <title> Fast, </title> <booktitle> randomized join-order selection |why use transformations? In Proceedings of the 20th International Conference on Very Large Data Bases, </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Admittedly, in the work described here, we assume that predicates are uncorrelated, and the cost models we consider are relatively simple. Note, though, that such simplifications are not unusual in the research literature <ref> [GLPK94, CM95, SMK93] </ref>. In benchmarking our join-optimization method, we attempt to isolate the characteristics of the input that influence performance. <p> Graefe and McKenna [GM93] describe the extensible rule-based Volcano optimizer. Their test runs allow bushy plans but not Cartesian products, and yield timings that, to our knowledge, reflect the state of the art in rule-based optimization. Galindo-Legaria, Pellenkoft, and Kersten <ref> [GLPK94] </ref> propose an unconventional stochastic approach to join-order optimization.
Reference: [GM93] <author> Goetz Graefe and William J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <pages> pages 209-218, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: In some theoretical sense, then, join optimization is fundamentally harder with Cartesian products than without. Graefe and McKenna <ref> [GM93] </ref> describe the extensible rule-based Volcano optimizer. Their test runs allow bushy plans but not Cartesian products, and yield timings that, to our knowledge, reflect the state of the art in rule-based optimization. Galindo-Legaria, Pellenkoft, and Kersten [GLPK94] propose an unconventional stochastic approach to join-order optimization.
Reference: [HS93] <author> Joseph M. Hellerstein and Michael Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <editor> In Peter Buneman and Sushil Jajodia, editors, </editor> <booktitle> Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 267-276, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: However, Hellerstein and Stonebraker <ref> [HS93] </ref> describe a cost-based predicate-placement technique that achieves huge gains when expensive predicates are deferred. 11 can be computed by multiplying together the cardinalities of all the relations, and the selectivities of all the predicates, that are represented in the induced subgraph (S; Q) shown in Figure 3 (b). 5.2 Cardinality
Reference: [IK84] <author> Toshihide Ibaraki and Tiko Kameda. </author> <title> On the optimal nesting order for computing N-relational joins. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(3) </volume> <pages> 482-502, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: 1 Introduction The NP-completeness of join-order optimization <ref> [IK84] </ref> precludes theoretical breakthroughs in solving the problem rapidly in the general case. Database implementors therefore face the engineering task of deciding which cases are most important to solve well, and of finding ways to obtain acceptable solutions in those cases. <p> Cluet and Moerkotte [CM95], also noting the potential value of Cartesian products in join plans, study the feasibility of optimization with Cartesian products from a theoretical standpoint. Their work, which considers only left-deep plan spaces, addresses the question of extending a join-optimization result from Ibaraki and Kameda <ref> [IK84] </ref>. That result showed optimization complexity for queries with tree graphs to be polynomial under a certain class of cost models, but when Cartesian products are considered, optimization becomes NP-complete under the same class of cost models.
Reference: [IK91] <author> Yannis E. Ioannidis and Younkyung Cha Kang. </author> <title> Left-deep vs. bushy trees: An analysis of strategy spaces and its implication for query optimization. </title> <editor> In James Clifford and Roger King, editors, </editor> <booktitle> Proceedings of the 1991 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 168-177, </pages> <address> Denver, Colorado, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Plans with Cartesian products are frequently excluded on the grounds that they are unlikely to be optimal, and so it is not worth expending effort in analyzing such plans. Many optimizers also restrict their attention to left-deep plans <ref> [IK91] </ref>, on the grounds that (a) the the space of bushy plans is vastly larger than the space of left-deep plans, and hence much more expensive to search; and (b) there fl Department of Computer Science and Engineering Oregon Graduate Institute of Science & Technology P.O. <p> Of particular interest to us is their observation, based on extensive measurements, that bushy stochastic searches generally produce plans no better than those obtained by a left-deep search given the same effort. The observed effect, which is apparently at odds with the results obtained by Ioannidis and Kang <ref> [IK91] </ref>, suggests that stochastic techniques for bushy optimization are not yet mature, and that for now the only reliable way to obtain bushy optima (or near-optima) is by exhaustive search. 3 3 Cartesian Product Optimization We present below a straightforward dynamic programming algorithm for optimizing Cartesian products.
Reference: [Knu73] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1973. </year>
Reference-contexts: In aggregate, the number of executions of this code across all calls to find best split is cond count = P n n H 2 m . Using the fact H k ln k + fl where fl = 0:57721 <ref> [Knu73] </ref>, we obtain cond count P n n P n n fl = (ln 2=2)n2 n + fl2 n . Let us disregard the fl2 n term and view the net contribution of the conditionally executed code as n2 n T cond for some constant T cond .
Reference: [MO95] <author> O. Martin and S. Otto. </author> <title> Combining simulated annealing with local search heuristics. </title> <note> To appear as a chapter of Metaheuristics in Combinatorial Optimization, volume 60 in the series Annals of Operations Research, </note> <editor> edited by G. Laporte and I. Osman, </editor> <year> 1995. </year>
Reference-contexts: Stochastic methods offer a way around both these problems. We are currently experimenting with a hybrid method inspired by the Chained Local Optimization technique of Martin and Otto <ref> [MO95] </ref>. Our hybrid combines dynamic programming with randomized search, and will be the subject of a future paper.
Reference: [OL90] <author> Kiyoshi Ono and Guy M. Lohman. </author> <title> Measuring the complexity of join enumeration in query optimization. </title> <editor> In Dennis McLeod, Ron Sacks-Davis, and Hans Schek, editors, </editor> <booktitle> Proceedings of the 16th International Conference on Very Large Data Bases, </booktitle> <pages> pages 314-325, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Section 7 concludes. 2 Related Work Selinger et al. [SAC + 79] introduced the use of dynamic programming for join-order optimization in the System R optimizer. Their optimizer focused on left-deep plans and excluded Cartesian products, but searched exhaustively subject to those restrictions. Ono and Lohman <ref> [OL90] </ref> point out that the optimal plan for a multiway join may contain Cartesian products, and note that it is desirable for an optimizer to permit flexibility in optimization trade-offs.
Reference: [SAC + 79] <author> P. Griffiths Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <editor> In Philip A. Bernstein, editor, </editor> <booktitle> Proceedings of the ACM-SIGMOD 1979 International Conference on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, Massachusetts, </address> <month> May </month> <year> 1979. </year> <month> 21 </month>
Reference-contexts: Section 4 then shows how that algorithm can be implemented extremely efficiently. Section 5 revises the algorithm to incorporate join predicates. Section 6 reports on the resultant join-order optimizer's measured performance. Section 7 concludes. 2 Related Work Selinger et al. <ref> [SAC + 79] </ref> introduced the use of dynamic programming for join-order optimization in the System R optimizer. Their optimizer focused on left-deep plans and excluded Cartesian products, but searched exhaustively subject to those restrictions.
Reference: [SMK93] <author> Michael Steinbrunn, Guido Moerkotte, and Alfons Kemper. </author> <title> Optimizing join orders. </title> <type> Technical Report MIP-9307, </type> <institution> Universitat Passau, </institution> <year> 1993. </year>
Reference-contexts: Admittedly, in the work described here, we assume that predicates are uncorrelated, and the cost models we consider are relatively simple. Note, though, that such simplifications are not unusual in the research literature <ref> [GLPK94, CM95, SMK93] </ref>. In benchmarking our join-optimization method, we attempt to isolate the characteristics of the input that influence performance. <p> Their test runs allow bushy plans but not Cartesian products, and yield timings that, to our knowledge, reflect the state of the art in rule-based optimization. Galindo-Legaria, Pellenkoft, and Kersten [GLPK94] propose an unconventional stochastic approach to join-order optimization. Whereas previous stochastic techniques (e.g., simulated annealing and iterated improvement <ref> [SMK93] </ref>) used transformations on plan trees to move from one state of the plan space to a neighboring state, the method of Galindo-Legaria et al. instead probes points of the plan space at random, avoiding the expense of navigating the space by applying transformations. <p> Thus, our approach and that of Galindo-Legaria et al., though performing different kinds of searches, share the intuition that query-tree transformation incurs unnecessary overhead. The technical report on join-order optimization by Steinbrunn et al. <ref> [SMK93] </ref>, which analyzes a variety of heuristic and stochastic techniques, has proved to be a valuable resource. Of particular interest to us is their observation, based on extensive measurements, that bushy stochastic searches generally produce plans no better than those obtained by a left-deep search given the same effort. <p> In our tests, we use three cost models drawn from Steinbrunn et al. <ref> [SMK93] </ref>: the naive model introduced in Section 3.1, a sort-merge cost model ( sm ), and a disk-nested-loops model ( dnl ).
References-found: 11

