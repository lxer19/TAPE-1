URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/multireset.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Title: Multitolerance in Distributed Reset  
Author: Sandeep S. Kulkarni Anish Arora 
Keyword: distributed systems; masking, nonmasking, safe, and stabilizing fault-tolerance  
Address: Columbus, Ohio 43210 USA  
Affiliation: Department of Computer and Information Science 1 The Ohio State University  
Abstract: A reset of a distributed system is safe if it does not complete "prematurely", i.e., without having reset some process in the system. Safe resets are possible in the presence of certain faults, such as process fail-stops and repairs, but are not always possible in the presence of more general faults, such as arbitrary transients. In this paper, we design a bounded-memory distributed reset program that possesses two tolerances: (i) in the presence of fail-stops and repairs, it always executes resets safely, and (ii) in the presence of a finite number of transient faults, it eventually executes resets safely. Designing this multitolerance in the reset program introduces the novel concern of designing a safety detector that is itself multitolerant. A broad application of our multitolerant safety detector is to make any total program likewise multitolerant. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Arora and S. S. Kulkarni. </author> <title> Multitolerance and its design. </title> <note> Submitted to IEEE Transactions on Software Engineering, Special Issue on Formal Methods, </note> <year> 1996. </year>
Reference-contexts: In such a system, it would be inappropriate to fail safely in the presence of all three fault-classes, or it would be inefficient or impossible to mask all three fault-classes. Thus, it is desirable that modern distributed systems be designed to be "multitolerant" <ref> [1] </ref>, that is, tolerant to each of a number of fault-classes, in a manner that is best suited to each fault-class. In this paper, we present a bounded-memory multitolerant distributed program that enables the processes in a distributed system to reset the state of the system. <p> If the reset is premature, the initiator repeats the reset operation. Finally, we transform this program again so as to add stabilizing tolerance to transient faults, while ensuring that the masking tolerance to fail-stops and repairs is preserved. (The interested reader is referred to <ref> [1] </ref> for the foundations of this stepwise design of multitolerance.) The rest of the paper is organized as follows: In Section 2, we define programs, faults and fault-tolerances, and state our assumptions about distributed systems.
Reference: [2] <author> A. Arora and M. G. Gouda. </author> <title> Distributed reset. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 43(9) </volume> <pages> 1026-1038, </pages> <year> 1994. </year> <booktitle> Extended abstract in Proceedings of the Tenth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <year> 1990, </year> <pages> 316-331. </pages>
Reference-contexts: In this paper, we present a bounded-memory multitolerant distributed program that enables the processes in a distributed system to reset the state of the system. We focus our attention on the so-called "distributed reset" program <ref> [2] </ref> owing to its wide applicability in designing fault-tolerance. We consider two fault-classes, one of which effectively fail-stops or repairs processes and the other of which transiently and arbitrarily corrupts the state of processes. Our program is masking tolerant to the first fault-class, and stabilizing tolerant to the second. <p> They do, however, allow channels to fail and the messages sent on those channels to be lost. Their program is not stabilizing tolerant. While little work has been done on bounded-memory masking tolerant resets, bounded-memory 3 stabilizing tolerant resets have received more attention <ref> [2, 6, 7, 8, 9, 10, 11] </ref>. All of these programs are stabilizing tolerant to fail-stops and repairs, but they are not masking tolerant to them. Specifically, in the presence of fail-stops and repairs, they allow premature completion of distributed resets. <p> Towards this end, any request made by a process is propagated towards the root, which then performs the reset. This extension is identical to the one given in <ref> [2] </ref> and is not discussed in this paper. 10 5 Masking Fault-tolerant Distributed Reset In this section, we transform the fault-intolerant program of Section 4 to add masking tolerance to fail-stop and repair faults. <p> The program is easily extended to allow any process to initiate a reset, by propagating a reset request towards the root along the parent tree. (The interested reader is referred to <ref> [2] </ref> for the implementation of this request propagation.) Moreover, the program is systematically extended to add masking tolerance to channel failure and repairs, as well as to use message passing communication. 25
Reference: [3] <author> M. Jayaram and G. Varghese. </author> <title> Crash failures can drive protocols to arbitrary states. </title> <booktitle> ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1996. </year>
Reference-contexts: Stabilizing tolerance is ideal when an arbitrary state may be reached in the presence of faults. Arbitrary states may be reached, for example, in the presence of fail-stops, repairs, message loss, as demonstrated by Jayaram and Varghese <ref> [3] </ref>. In such cases, masking tolerance cannot be designed as the fault itself may perturb the program to a state where the reset operation has completed prematurely. Since arbitrary states can be reached in the presence of arbitrary transient faults, the ideal tolerance to transient faults is stabilizing tolerance.
Reference: [4] <author> G. Tel. </author> <title> Structure of Distributed Algorithms. </title> <type> PhD thesis, </type> <institution> University of Utrecht; also published by Cambridge University Press, </institution> <year> 1989. </year>
Reference-contexts: As discussed in Section 8, our bounded-memory multitolerant solution for distributed reset is also useful in designing a bounded-memory multitolerant solution for any total program <ref> [4] </ref>, e.g., leader election, termination detection, and global snapshot. A total program characteristically has one or more "decider" actions whose execution depends on the state of all processes. <p> The program was designed by iteratively transforming a fault-intolerant program so as to add tolerance to each class of faults. Distributed reset programs belong to the class of total programs <ref> [4] </ref>. Total programs characteristically contain one or more "decider" actions, whose execution depends on the state of all processes. In the case of distributed reset programs, the action which declares the completion of a reset operation is a decider action.
Reference: [5] <author> Y. Afek and E. Gafni. </author> <title> Bootstrap network resynchronization. </title> <booktitle> Proceedings of 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 295-307, </pages> <year> 1991. </year>
Reference-contexts: Related work. To our knowledge, this is the first bounded-memory multitolerant distributed reset program. In fact, we are not aware of bounded-memory distributed reset program that is masking tolerant to fail-stops and repairs. We note that Afek and Gafni <ref> [5] </ref> have shown a masking tolerant solution under the severe assumption that processes do not lose their memory if they fail. They do, however, allow channels to fail and the messages sent on those channels to be lost. Their program is not stabilizing tolerant.
Reference: [6] <author> G. Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <type> PhD thesis, </type> <institution> MIT/LCS/TR-583, </institution> <year> 1993. </year>
Reference-contexts: They do, however, allow channels to fail and the messages sent on those channels to be lost. Their program is not stabilizing tolerant. While little work has been done on bounded-memory masking tolerant resets, bounded-memory 3 stabilizing tolerant resets have received more attention <ref> [2, 6, 7, 8, 9, 10, 11] </ref>. All of these programs are stabilizing tolerant to fail-stops and repairs, but they are not masking tolerant to them. Specifically, in the presence of fail-stops and repairs, they allow premature completion of distributed resets. <p> In our program, in stable states, the processes form a rooted tree and all reset operations are performed on this underlying tree. An alternative approach would be to construct the tree dynamically in every reset operation, as in <ref> [7, 6] </ref>. Analogous to their reset program, there exists a reset program that is masking tolerant to fail-stop and repair faults and stabilizing tolerant to transient faults and that does not use an underlying tree.
Reference: [7] <author> B Awerbuch, B Patt-Shamir, and G Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <booktitle> In FOCS91 Proceedings of the 31st Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 268-277, </pages> <year> 1991. </year>
Reference-contexts: They do, however, allow channels to fail and the messages sent on those channels to be lost. Their program is not stabilizing tolerant. While little work has been done on bounded-memory masking tolerant resets, bounded-memory 3 stabilizing tolerant resets have received more attention <ref> [2, 6, 7, 8, 9, 10, 11] </ref>. All of these programs are stabilizing tolerant to fail-stops and repairs, but they are not masking tolerant to them. Specifically, in the presence of fail-stops and repairs, they allow premature completion of distributed resets. <p> In our program, in stable states, the processes form a rooted tree and all reset operations are performed on this underlying tree. An alternative approach would be to construct the tree dynamically in every reset operation, as in <ref> [7, 6] </ref>. Analogous to their reset program, there exists a reset program that is masking tolerant to fail-stop and repair faults and stabilizing tolerant to transient faults and that does not use an underlying tree.
Reference: [8] <author> B Awerbuch, B Patt-Shamir, G Varghese, and S Dolev. </author> <title> Self-stabilizing by local checking and global reset. </title> <booktitle> In WDAG94 Distributed Algorithms 8th International Workshop Proceedings, </booktitle> <publisher> Springer-Verlag LNCS:857, </publisher> <pages> pages 326-339, </pages> <year> 1994. </year>
Reference-contexts: They do, however, allow channels to fail and the messages sent on those channels to be lost. Their program is not stabilizing tolerant. While little work has been done on bounded-memory masking tolerant resets, bounded-memory 3 stabilizing tolerant resets have received more attention <ref> [2, 6, 7, 8, 9, 10, 11] </ref>. All of these programs are stabilizing tolerant to fail-stops and repairs, but they are not masking tolerant to them. Specifically, in the presence of fail-stops and repairs, they allow premature completion of distributed resets.
Reference: [9] <author> B Awerbuch and R Ostrovsky. </author> <title> Memory-efficient and self-stabilizing network reset. </title> <booktitle> In PODC94 Proceedings of the Thirteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 254-263, </pages> <year> 1994. </year>
Reference-contexts: They do, however, allow channels to fail and the messages sent on those channels to be lost. Their program is not stabilizing tolerant. While little work has been done on bounded-memory masking tolerant resets, bounded-memory 3 stabilizing tolerant resets have received more attention <ref> [2, 6, 7, 8, 9, 10, 11] </ref>. All of these programs are stabilizing tolerant to fail-stops and repairs, but they are not masking tolerant to them. Specifically, in the presence of fail-stops and repairs, they allow premature completion of distributed resets.
Reference: [10] <author> E Anagnostou and V Hadzilacos. </author> <title> Tolerating transient and permanent failures. </title> <booktitle> In WDAG93 Distributed Algorithms 7th International Workshop Proceedings, </booktitle> <publisher> Springer-Verlag LNCS:725, </publisher> <pages> pages 174-188, </pages> <year> 1993. </year>
Reference-contexts: They do, however, allow channels to fail and the messages sent on those channels to be lost. Their program is not stabilizing tolerant. While little work has been done on bounded-memory masking tolerant resets, bounded-memory 3 stabilizing tolerant resets have received more attention <ref> [2, 6, 7, 8, 9, 10, 11] </ref>. All of these programs are stabilizing tolerant to fail-stops and repairs, but they are not masking tolerant to them. Specifically, in the presence of fail-stops and repairs, they allow premature completion of distributed resets.
Reference: [11] <author> S Dolev, A Israeli, and S Moran. </author> <title> Self-stabilization of dynamic systems assuming only read/write atomicity. </title> <journal> Distibuted Computing, </journal> <volume> 7 </volume> <pages> 3-16, </pages> <year> 1993. </year>
Reference-contexts: They do, however, allow channels to fail and the messages sent on those channels to be lost. Their program is not stabilizing tolerant. While little work has been done on bounded-memory masking tolerant resets, bounded-memory 3 stabilizing tolerant resets have received more attention <ref> [2, 6, 7, 8, 9, 10, 11] </ref>. All of these programs are stabilizing tolerant to fail-stops and repairs, but they are not masking tolerant to them. Specifically, in the presence of fail-stops and repairs, they allow premature completion of distributed resets.
Reference: [12] <author> T. Masuzawa. </author> <title> A fault-tolerant and self-stabilizing protocol for topology problem. </title> <booktitle> Proceedings of the Second Workshop on Self-Stabilizing Systems, </booktitle> <year> 1995. </year>
Reference-contexts: All of these programs are stabilizing tolerant to fail-stops and repairs, but they are not masking tolerant to them. Specifically, in the presence of fail-stops and repairs, they allow premature completion of distributed resets. Masuzawa has presented a reset program <ref> [12] </ref> that tolerates two fault-classes: transient faults and undetectable crash faults. His solution assumes that at most M processes fail undetectably for some fixed M such that the process graph is (M + 1)-connected.
Reference: [13] <author> A. Arora and M. G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, 1993. 
Reference-contexts: In Section 7, we describe how this reset program can be used to design multitolerant application programs. Finally, we make concluding remarks in Section 8. 2 Preliminaries In this section, we first recall a formal definition of programs, faults, and fault-tolerances <ref> [13] </ref>. We then state our assumptions about the distributed systems considered in this paper. Programs. A program is a set of variables and a finite set of actions. Each variable has a predefined domain.
Reference: [14] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: Note that many other state predicates may be closed in p, some of which may not be true at states where the invariant holds; the state predicate false provides a trivial example of such a predicate. Techniques for the design of the invariant predicate have been articulated by Dijkstra <ref> [14] </ref>, using the notion of auxilliary variables, and by Gries [15], using the heuristics of state predicate ballooning and shrinking. Techniques for the mechanical calculation of the invariant predicate have been discussed by Alpern and Schneider [16]. Convergence.
Reference: [15] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Techniques for the design of the invariant predicate have been articulated by Dijkstra [14], using the notion of auxilliary variables, and by Gries <ref> [15] </ref>, using the heuristics of state predicate ballooning and shrinking. Techniques for the mechanical calculation of the invariant predicate have been discussed by Alpern and Schneider [16]. Convergence.
Reference: [16] <author> B. Alpern and F. Schneider. </author> <title> Proving boolean combinations of deterministic properties. </title> <booktitle> Proceedings of the Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 131-137, </pages> <year> 1987. </year>
Reference-contexts: Techniques for the design of the invariant predicate have been articulated by Dijkstra [14], using the notion of auxilliary variables, and by Gries [15], using the heuristics of state predicate ballooning and shrinking. Techniques for the mechanical calculation of the invariant predicate have been discussed by Alpern and Schneider <ref> [16] </ref>. Convergence. A state predicate Q converges to a state predicate R in p iff Q and R are closed in p, and starting from any state where Q holds, every computation of p reaches a state where R holds. Faults.
Reference: [17] <author> A. Arora. </author> <title> Efficient reconfiguration of trees: A case study in the methodical design of nonmasking fault-tolerance. </title> <booktitle> Proceedings of the Third International Symposium on Formal Techniques in Real Time and Fault-Tolerance, </booktitle> <year> 1994. </year> <note> Science of Computer Programming to appear. </note>
Reference-contexts: To achieve (1), we ensure that eventually the tree spanning all up processes is restored, so that a diffusing computation can reach all up processes. To this end, we reuse a nonmasking tolerant tree program due to Arora <ref> [17] </ref> that, in the presence of fail-stops and repairs, maintains the graph of the parent relation of all up processes to always be a forest and, when faults stop occurring, restores the graph to be a spanning tree. The details of this program are given in Section 5.1. <p> To construct a spanning tree, we use Arora's program for tree maintenance <ref> [17] </ref>, which allows fail-stops and repairs to yield states where there are multiple, possibly unrooted, trees. We briefly describe, next, how the program deals with multiple trees and unrooted trees, and thereby eventually converges to a state where there is exactly one tree spanning all processes. <p> We briefly describe, next, how the program deals with multiple trees and unrooted trees, and thereby eventually converges to a state where there is exactly one tree spanning all processes. We refer the reader to <ref> [17] </ref> for the proof of the nonmasking program. The program merges multiple trees in a way such that no cycles are formed: Each process maintains a variable root:j to denote the process j believes to be the root.
Reference: [18] <author> A. Arora and S. S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <booktitle> Proceedings of the Fourteenth Symposium on Reliable Distributed Systems, Bad Neuenahr, </booktitle> <volume> 14 </volume> <pages> 174-185, </pages> <year> 1995. </year> <note> Submitted to IEEE Transactions on Software Engineering. </note>
Reference-contexts: second stage, we transform the nonmasking fault-tolerant program into one that is masking fault-tolerant, by restricting the actions of the former program so that a process declares completion of a distributed reset only if all up processes have participated in the last reset wave. (The interested reader is referred to <ref> [18] </ref> for the foundations of this two-stage method for adding masking tolerance.) Below, in Section 5.1, we design the nonmasking program to tolerate fail-stop and repair faults.
Reference: [19] <author> S. S. Kulkarni and A. Arora. </author> <title> Stepwise design of tolerances in barrier computations. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: Also, for any pair of incarnation numbers, it is easy to determine which of the two is associated with the current reset wave. We now briefly describe how the application and the reset program use the incarnation number. 22 (The interested reader is referred to <ref> [19] </ref> for a detailed discussion). When to reset the local state of a process. When process j propagates a reset wave, it resets its state iff the incarnation number of the parent of j is one greater (in mod 3 arithmetic) than the incarnation number of j.
Reference: [20] <author> M. G. Gouda and N. Multari. </author> <title> Stabilizing communication protocols. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(4) </volume> <pages> 448-458, </pages> <year> 1991. </year>
References-found: 20

