URL: http://www.cms.dmu.ac.uk/~drs/public_fp/notes/reuse.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/notes/
Root-URL: 
Title: Higher-order Polymorphic Reusable  
Author: Simon Thompson 
Address: CT2 7NF, U.K.  
Affiliation: Computing Laboratory, University of Kent Canterbury,  
Abstract: This paper explores how certain ideas in object oriented languages have their correspondents in functional languages. In particular we look at the analogue of the iterators of the C++ standard template library. We also give an example of the use of constructor classes which feature in Haskell 1.3 and Gofer.
Abstract-found: 1
Intro-found: 1
Reference: [Goguen, 1990] <author> Joseph Goguen. </author> <title> Higher-order functions considered unnecessary for higher-order programming. </title> <editor> In David A. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The way in which instantiation takes place is assumed here to be function application; an argument can be made for replacing higher-order functions by parametrised modules, <ref> [Goguen, 1990] </ref>, but this mechanism appears to be simultaneously more cumbersome and less powerful; we discuss this further in Section 9 below. 2 This greater than anticipated generality is not an isolated phenomenon. 3 This intuitive characterisation can be made formal; the functions are strict in the spine the list, but <p> Structures and signatures The approach of binding structures to signatures in Standard ML is permissive, but will not allow the overloading of multiple bindings per scope. The same restriction applies to parametrised modules, as in <ref> [Goguen, 1990] </ref>. Dynamic binding In most object-oriented languages there are mechanisms for dynamic binding. In C++, for example, a virtual class forces all its subclasses to provide operations, such as those of a tree-like type.
Reference: [Hudak et al., 1992] <editor> Paul Hudak, Simon Peyton Jones, and Philip Wadler (Editors). </editor> <title> Report on the Programming Language Haskell, version 1.2. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <year> 1992. </year>
Reference-contexts: to Ian Utting for his patient explanations of some of the arcana of C++, and for pointing me in the direction of the Standard Template Library, [Stepanov and Lee, 1994], which is implemented using the iterator classes. 2 Functional programming Modern functional programming languages like Miranda, Standard ML and Haskell <ref> [Turner, 1985, Milner et al., 1990, Hudak et al., 1992] </ref> are based on function definitions as equations or more generally as sequences of equations.
Reference: [Jones, 1993] <author> Mark Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <booktitle> In FPCA 93 Functional Programming Languages and Computer Architecture. </booktitle> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Any language allowing higher order functions can be used to implement these ideas, but extra features can facilitate it further. In particular the constructor classes of Gofer, 1 Miranda is a trade mark of Research Software Ltd. 1 <ref> [Jones, 1993] </ref>, allow the recursion operators to be overloaded, avoiding the necessity of passing the appropriate parameters into applications. The paper concludes with a survey of the different language features which can be used to aid the implementation of these ideas. <p> An instance of the latter might be to consider ordinary recursion (fold) and snoc-recursion (foldAlt) in the same scope. Constructor classes The Gofer language supports constructor classes, <ref> [Jones, 1993] </ref>, which generalise the type classes of Haskell by (essentially) allowing the classification of type constructors rather than types. Our classifications of lists and trees in this paper give exactly constructor classes.
Reference: [Kershenbaum et al., 1988] <author> Aaron Kershenbaum, David Musser, and Alexander Stepanov. </author> <title> Higher order imperative programming. </title> <type> Technical report, </type> <institution> Computer Science Department, Rensselaer Polytechnic Institute, </institution> <year> 1988. </year>
Reference: [Milner et al., 1990] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: to Ian Utting for his patient explanations of some of the arcana of C++, and for pointing me in the direction of the Standard Template Library, [Stepanov and Lee, 1994], which is implemented using the iterator classes. 2 Functional programming Modern functional programming languages like Miranda, Standard ML and Haskell <ref> [Turner, 1985, Milner et al., 1990, Hudak et al., 1992] </ref> are based on function definitions as equations or more generally as sequences of equations.
Reference: [Musser and Stepanov, 1994] <author> David Musser and Alexander Stepanov. </author> <title> Algorithm-oriented Generic Libraries. </title> <journal> Software Practice and Experience, </journal> <volume> 24, </volume> <year> 1994. </year>
Reference-contexts: The examples in the paper include treating lists as trees, and trees as lists. The inspiration for this work came from the iterators of <ref> [Musser and Stepanov, 1994] </ref>. An iterator is an abstract index into a sequential structure, giving a uniform treatment of lists arrays and trees. The aim of the work here is to extend that approach in two ways. <p> The novelty of this approach is that t * can be any family of types: we shall see in the next Section that trees and error types conform to this signature. This characterisation is inspired by the iterators of the Standard Template Library for C++, <ref> [Stepanov and Lee, 1994, Musser and Stepanov, 1994] </ref>. Iterators are an abstraction from indices (or pointers), allowing a walk through a sequential structure. <p> We illustrated the proposition with the example of data abstraction the treatment of one type as if it were structured like another 15 which supports a general, `algorithm oriented' style, as introduced in <ref> [Musser and Stepanov, 1994] </ref>.
Reference: [Stepanov and Lee, 1994] <author> Alexander Stepanov and Meng Lee. </author> <title> The Standard Template Library. </title> <type> Technical report, </type> <institution> Hewlett-Packard Laboratories, Palo Alto, USA, </institution> <year> 1994. </year>
Reference-contexts: I am grateful to Ian Utting for his patient explanations of some of the arcana of C++, and for pointing me in the direction of the Standard Template Library, <ref> [Stepanov and Lee, 1994] </ref>, which is implemented using the iterator classes. 2 Functional programming Modern functional programming languages like Miranda, Standard ML and Haskell [Turner, 1985, Milner et al., 1990, Hudak et al., 1992] are based on function definitions as equations or more generally as sequences of equations. <p> The novelty of this approach is that t * can be any family of types: we shall see in the next Section that trees and error types conform to this signature. This characterisation is inspired by the iterators of the Standard Template Library for C++, <ref> [Stepanov and Lee, 1994, Musser and Stepanov, 1994] </ref>. Iterators are an abstraction from indices (or pointers), allowing a walk through a sequential structure.
Reference: [Turner, 1985] <author> David A. Turner. Miranda: </author> <title> a non-strict functional language with polymorphic types. </title> <editor> In J. P. Jouannaud, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 16 </month>
Reference-contexts: to Ian Utting for his patient explanations of some of the arcana of C++, and for pointing me in the direction of the Standard Template Library, [Stepanov and Lee, 1994], which is implemented using the iterator classes. 2 Functional programming Modern functional programming languages like Miranda, Standard ML and Haskell <ref> [Turner, 1985, Milner et al., 1990, Hudak et al., 1992] </ref> are based on function definitions as equations or more generally as sequences of equations.
References-found: 8

