URL: http://ana-www.lcs.mit.edu/anaweb/ps-papers/ftlo-MEng.ps
Refering-URL: http://ana-www.lcs.mit.edu/anaweb/ps-papers/
Root-URL: 
Title: A Model of Composite Objects for Information Mesh  
Author: by Felix Tun-Han Lo Karen R. Sollins 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Master of Engineering in Electrical Engineering and Computer Science and Bachelor of Science in Electrical Engineering and Computer Science at the  c flFelix Tun-Han Lo, MCMXCVI. All rights reserved. The author hereby grants to M.I.T. permission to reproduce and to distribute copies of this thesis document in whole or in part, and to grant others the right to do so. Author  Certified by  Scientist Thesis Supervisor Accepted by Frederic R. Morgenthaler Chairman, Departmental Committee on Graduate Theses  
Date: September 1996  August 26, 1996  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  Research  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> David D. Clark, Karen R. Sollins, John T. Wroclawski, and Michael L. Dertouzos. </author> <title> Critical technology for universal information access. </title> <note> Research proposal submitted to ARPA, </note> <year> 1994. </year>
Reference-contexts: Introduction The Information Mesh is an infrastructure which provides better supports for distributed information applications. One of the major design goals of the Information Mesh is its evolvability. A flexible object-typing model has been developed so that the Information Mesh may evolve along with changing applications and supporting infrastructures <ref> [1] </ref>. Currently, the Information Mesh project has not developed a model of composite objects that takes advantage of the flexibility of the underlying object system. A composite object is composed of a collection of Mesh objects; it requires certain relationships among Mesh objects [3].
Reference: [2] <author> Karen R. Sollins and Jeffrey R. Van Dyke. </author> <title> Linking in a Global Information Architecture. </title> <booktitle> In Fourth International World Wide Web Conference Proceedings O'Reilly and Assoc., </booktitle> <month> Dec </month> <year> 1995. </year>
Reference-contexts: A component should not be aware of its containing objects. Otherwise, the list of contained objects can be very large. The cost of maintaining a large list is undesirable. This constraint is stated in the Linking in a Global Information Architecture paper <ref> [2] </ref>. 2. A component can be included in more than one composite. 10 3. A component is allowed to contain other components. <p> An error in one component may propagate to many components. 18 19 Most importantly, this replacement process violates a constraint stated in the Linking in a Global Information Architecture paper: "contained objects are not aware of their inclusion in a composite object. <ref> [2] </ref>" This constraint is violated in our example, in which changes in one component cause changes in other components.
Reference: [3] <author> Jeffrey R. Van Dyke. </author> <title> Link Architecture for a Global Information Infrastructure. </title> <address> MIT/LCS/TR-659, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Currently, the Information Mesh project has not developed a model of composite objects that takes advantage of the flexibility of the underlying object system. A composite object is composed of a collection of Mesh objects; it requires certain relationships among Mesh objects <ref> [3] </ref>. These relationship requirements reduce the flexibility allowed by the object system. This work proposes a composite model which is compatible with the existing object system. The model is designed to retain the flexibility of the Information Mesh object system. <p> Composition is necessary at the Information Mesh level. Another motivation comes from the nature of the Information Mesh itself. <ref> [3] </ref> The Information Mesh is a distributed system, and may not be able to provide complete, system-wide, information on individual objects. With the lack of system-wide knowledge, each object may need to maintain its own information. <p> We will first look briefly at the overall vision and goals of the Information Mesh, then at the object model. 1.3.1 Overall Vision and Goals The overall vision of the Information Mesh Project is to provide a long-lived global architecture for networked-based distributed information reference, manipulation and access <ref> [3] </ref>. The architecture should provide a minimal set of requirements so it does not restrict the evolution of the network. The hope is that the Information Mesh will become the primitive abstraction around which applications are built [4].
Reference: [4] <author> Paradigms for universality: </author> <title> Networking in the information Age. Abridged Version of Proposal. Submitted in Support of Work by the Advanced Network Architecture Group, </title> <year> 1991. </year>
Reference-contexts: The architecture should provide a minimal set of requirements so it does not restrict the evolution of the network. The hope is that the Information Mesh will become the primitive abstraction around which applications are built <ref> [4] </ref>. The specific goals to meet this vision of the Information Mesh are: * Global Scope. The Information Mesh should provide a general agreement on object re ferral in a highly scalable manner. * Ubiquity.
Reference: [5] <author> Andrew B. </author> <title> Hastings Distributed Lock Management in a Transaction Processing Environment CMU-CS-89-152, </title> <month> May 27, </month> <year> 1989. </year>
Reference-contexts: Another possible extension to the system is a distributed lock management. Lock management is needed to provide consistent shared data for users. Though lock management is well established in a transaction processing environment <ref> [5] </ref>, it may be different inside a model of composite objects. One major issue is the granularity of locking [6]. If the entire document is the item to lock, much flexibility is restricted.
Reference: [6] <author> Andrew S. </author> <title> Tanenbaum Modern Operating systems. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Lock management is needed to provide consistent shared data for users. Though lock management is well established in a transaction processing environment [5], it may be different inside a model of composite objects. One major issue is the granularity of locking <ref> [6] </ref>. If the entire document is the item to lock, much flexibility is restricted. If a chapter or a page is the item to lock, the item may change even if it is not modified. For example, a page may change when someone modifies another page.
Reference: [7] <author> David Ragett. </author> <title> Hypertext markup language Specification Version 3.0. </title> <address> In-ternetDraft, MIT/W3C, </address> <year> 1995. </year> <note> See http://www.w3.org/pub/WWW/MarkUp/ html3/html3.txt </note>
Reference: [8] <author> James Gosling and Henry McGilton. </author> <title> The Java(tm) Language Environment: A White Paper. Sun Microsystems, </title> <booktitle> 1995. </booktitle> <pages> 87 </pages>
Reference-contexts: Second, Java supports interactions with Web browsers. So page and chapter instances of a book can be displayed on a web browser. Third, Java is "architecturally neutral", allowing code to be portable and "is secure to survive in the network-based environment <ref> [8] </ref>." On the other hand, Java may have worse performance than C++ because Java is an interpreted language. However, the performance of Java should be adequate for most applications [8]. <p> Third, Java is "architecturally neutral", allowing code to be portable and "is secure to survive in the network-based environment <ref> [8] </ref>." On the other hand, Java may have worse performance than C++ because Java is an interpreted language. However, the performance of Java should be adequate for most applications [8]. Since the overall performance is not the primary issue in building the prototype, the performance of Java should be sufficient for this project. The book paradigm can be presented in different ways. <p> The implementation utilizes Java applets and CORBA (Common Object Request Broker Architecture). The Java programming language is architecturally neutral and is portable across multiple machines. Building mobile code system is secure with Java, whose run-time system has built-in protection against viruses and tampering <ref> [8] </ref>. CORBA provides the mechanisms by which objects transparently make requests and receive responses through the CORBA ORB. [12] The CORBA ORB is similar to a "bus" on a hardware circuit [13]. It provides interoperability between applications built in different languages on different machines.
Reference: [9] <editor> Tim Ritchey Programming with Java. </editor> <publisher> New Riders Publishing, </publisher> <year> 1995. </year>
Reference: [10] <author> Frank Halasz. </author> <title> Reflections on notecards: Seven issues for the next generation of hypermedia systems. </title> <journal> Communications of the ACM, </journal> <volume> 31(7), </volume> <year> 1988. </year>
Reference-contexts: Many distributed information applications recognize composition as an essential capability. In a study of hypertext system, F. Halasz suggests that "the basic hypermedia model lacks a composition mechanism, i.e., a way of representing and dealing with groups of (objects) as unique entities separate from their components. <ref> [10] </ref>" His Dexter Model of Hypermedia System supports composition as a hierarchical structuring mechanism. [11] Furthermore, Halasz suggests that composition should be "implemented within, as opposed to on top of, all hypermedia systems. `[10]" Therefore, a hypertext model requires composite capability, and this capability should be implemented within hypermedia systems. <p> A component can be included in more than one composite. 10 3. A component is allowed to contain other components. Thus a restriction is needed to prevent any cycle in composite/component relationship, that is, a composite should not be a component, directly or transitively, of itself <ref> [10] </ref>. 1.3 The Information Mesh Environment The development of a composite model is a step in achieving the overall vision and goals of the Information Mesh project. The composite model needs to be consistent with the overall Information Mesh object system.
Reference: [11] <author> Frank Halasz and Mayer Schwartz. </author> <title> The dexter hypertext reference. </title> <journal> Communications of the ACM, </journal> <volume> 37(2), </volume> <year> 1994. </year>
Reference-contexts: Halasz suggests that "the basic hypermedia model lacks a composition mechanism, i.e., a way of representing and dealing with groups of (objects) as unique entities separate from their components. [10]" His Dexter Model of Hypermedia System supports composition as a hierarchical structuring mechanism. <ref> [11] </ref> Furthermore, Halasz suggests that composition should be "implemented within, as opposed to on top of, all hypermedia systems. `[10]" Therefore, a hypertext model requires composite capability, and this capability should be implemented within hypermedia systems. Composition is necessary at the Information Mesh level.
Reference: [12] <author> Object Management Group(OMG). </author> <title> The Common Object Request Broker: Architecture and Specification, Revision 2.0 Object Management Group, </title> <month> July </month> <year> 1995. </year>
Reference-contexts: The Java programming language is architecturally neutral and is portable across multiple machines. Building mobile code system is secure with Java, whose run-time system has built-in protection against viruses and tampering [8]. CORBA provides the mechanisms by which objects transparently make requests and receive responses through the CORBA ORB. <ref> [12] </ref> The CORBA ORB is similar to a "bus" on a hardware circuit [13]. It provides interoperability between applications built in different languages on different machines. The different langauges are mapped to a common interface called IDL (Interface definition language).
Reference: [13] <author> Robert Orfali, Dan Harkey, and Jeri Edwards. </author> <title> The Essential Distributed Objects Survival Guide. </title> <publisher> John Wiley and Sons, INC., </publisher> <year> 1996 </year>
Reference-contexts: Building mobile code system is secure with Java, whose run-time system has built-in protection against viruses and tampering [8]. CORBA provides the mechanisms by which objects transparently make requests and receive responses through the CORBA ORB. [12] The CORBA ORB is similar to a "bus" on a hardware circuit <ref> [13] </ref>. It provides interoperability between applications built in different languages on different machines. The different langauges are mapped to a common interface called IDL (Interface definition language). By giving the ORB a remote object's uid (unique identifier), the ORB is able to return a reference to the object.
Reference: [14] <institution> Sun Microsystems Java IDL alpha 2.0 Sun Microsystems, </institution> <month> June, </month> <year> 1996. </year> <note> See http://splash.javasoft.com/JavaIDL/pages/index.html </note>
Reference-contexts: However, there are freeware options which provide the technology of distributed computing. Moreover, they are all specialized for the Java programming 36 language. Among the freeware products that support remote object invocation, there are Java IDL <ref> [14] </ref>, Java RMI [15], and HORB [16]. Java RMI is probably the most efficient and easiest to use. However, the netscape browser does not support it yet. Netscape does support Java IDL and HORB. HORB supports only with Java JDK 1.0.1, but not Java JDK 1.0.2.
Reference: [15] <institution> Sun Microsystems Java Remote Method Invocation alpha 2.0 Sun Microsystems, </institution> <month> June, </month> <year> 1996. </year> <note> See http://chatsubo.javasoft.com/current/rmi/index.html </note>
Reference-contexts: However, there are freeware options which provide the technology of distributed computing. Moreover, they are all specialized for the Java programming 36 language. Among the freeware products that support remote object invocation, there are Java IDL [14], Java RMI <ref> [15] </ref>, and HORB [16]. Java RMI is probably the most efficient and easiest to use. However, the netscape browser does not support it yet. Netscape does support Java IDL and HORB. HORB supports only with Java JDK 1.0.1, but not Java JDK 1.0.2.
Reference: [16] <institution> Hirano Satoshi HORB 1.2.1 Electrotechnical Laboratory, </institution> <year> 1996. </year> <note> See http:// ring.etl.go.jp/openlab/horb </note>
Reference-contexts: However, there are freeware options which provide the technology of distributed computing. Moreover, they are all specialized for the Java programming 36 language. Among the freeware products that support remote object invocation, there are Java IDL [14], Java RMI [15], and HORB <ref> [16] </ref>. Java RMI is probably the most efficient and easiest to use. However, the netscape browser does not support it yet. Netscape does support Java IDL and HORB. HORB supports only with Java JDK 1.0.1, but not Java JDK 1.0.2. Therefore Java IDL was chosen for this project.
Reference: [17] <institution> Sun Microsystems Java Object Serialization alpha 2.0 Sun Microsystems, </institution> <month> June, </month> <year> 1996. </year> <note> See http://chatsubo.javasoft.com/current/serial/index.html 88 </note>
Reference-contexts: Thus the storage can be an integer or a user defined table. Persistent object storage has the advantage that objects of any type can be stored and restored without conversion. Our project chooses persistent object storage, using Java Object Serialization <ref> [17] </ref>. After establishing persistent object storage as our choice, we need to figure out which objects to store. The main consideration is the object size and the abstraction model. Storing large objects may provide better abstractions and may be more convenient in the implementation.
References-found: 17

