URL: http://www.cs.berkeley.edu/~manku/papers/symmetry.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~manku/papers.html
Root-URL: 
Email: (manku@almaden.ibm.com)  (hojati@hdac.com)  (brayton@ic.berkeley.edu)  
Phone: 2  3  
Title: Structural Symmetry and Model Checking  
Author: Gurmeet Singh Manku and Ramin Hojati and Robert Brayton 
Address: Center  HDAC Inc.  Berkeley  
Affiliation: 1 IBM Almaden Research  University of California at Berkeley and  University of California at  
Abstract: A fully automatic framework is presented for identifying symmetries in structural descriptions of digital circuits and CTL* formulas and using them in a model checker. The set of sub-formulas of a formula is partitioned into equivalence classes so that truth values for only one sub-formula in any class need be evaluated for model checking. Structural symmetries in net-list descriptions of digital circuits and CTL* formulas are formally defined and their relationship with the corresponding Kripke structures is described. A technique for automatic identification of structural symmetries is described that requires computation of the automorphism group of a suitable labeled directed graph. A novel fast algorithm for this problem is presented. Finally, experimental results are reported for BLIF-MV net-lists derived from Verilog. 
Abstract-found: 1
Intro-found: 1
Reference: [AT96] <author> M. AGRAWAL AND T. THIERAUF. </author> <title> The Boolean Isomorphism Problem. </title> <booktitle> In Proc. Symp. on Foundations of Computer Science, </booktitle> <pages> pp. 422430, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: 3.2 Computing Equivalence Classes Given G Aut M L AP and a CTL* formula f , how do we find two sub-formulas g and h such that g G h? This is a computationally hard problem even if f is a simple boolean formula without path operators or temporal quantifiers <ref> [AT96] </ref>. If we replace G by G s , the problem is as hard as graph isomorphism [Man97]. We outline a technique that can identify symmetric sub-formulas if the symmetry in the specification is reflected in the formula as well, which is true in practice.
Reference: [B + 91] <author> R. K. BRAYTON ET AL. BLIF-MV: </author> <title> An Interchange Format for Design Verification and Synthesis. </title> <type> Technical Report UCB/ERL M91/97, </type> <institution> UC Berkeley, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: In both the cases, we need to compute G 1 H. We now describe how G, H and G 1 H can be computed automatically from net-lists of digital circuits and CTL* formulas, with no assistance from the designer. We have chosen BLIF-MV <ref> [B + 91] </ref> as a representative structural hardware description language. 5.1 Characterizing a BLIF-MV Circuit We model a BLIF-MV circuit as a five tuple C = hI; O; L; T ; Si, consisting of a set of primary input ports I, a set of primary output ports O, a set of <p> Let Aut C L AP denote the set of all such permutations. It can be verified that Theorem 5 still holds. A detailed proof can be found in [Man97], which also shows how multiple-output tables, the = construct <ref> [B + 91] </ref>, pseudo inputs and other special cases can be handled. The size of the graph is linear in the size of the flattened BLIF-MV description. Here are two interesting theoretical questions: First, is every group possible? Let G Aut M L AP .
Reference: [BCL + 94] <author> J. R. BURCH, E. M. CLARKE, D. E. LONG, K. L. MCMILLAN, AND D. L. DILL. </author> <title> Symbolic Model Checking for Sequential Circuit Verification. </title> <booktitle> IEEE Tran. on Comp. Aided Design of Integrated Circuits and Sys., </booktitle> <address> 13(4):401424, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: A Binary Decision Diagrams based symbolic model checker that can handle more than 10 120 states on some pipelined circuits has been described by Burch et al <ref> [BCL + 94] </ref>. Permutation Groups: A permutation is a bijective mapping : S ! S defined over a finite non-empty set S. We denote the action of on an element s 2 S by s. We use H G to denote that H is a subgroup of G.
Reference: [CEFJ96] <author> E. M. CLARKE, R. ENDERS, T. FILKORN, AND S. JHA. </author> <title> Exploiting Symmetry in Temporal Logic Model Checking. Formal Meth. </title> <booktitle> in Sys. Design, </booktitle> <address> 9(1/2):77104, </address> <year> 1996. </year>
Reference-contexts: This is commonly known as State Space Explosion. Among the techniques being developed for countering this problem are partial order methods, abstraction, compositional approaches, and symmetry reductions. Symmetries abound in hardware circuits, distributed algorithms and concurrent programs. Emerson and Sistla [ES96] and Clarke et al <ref> [CEFJ96] </ref> show how symmetries in Kripke structures and CTL* formulas allow the construction of a smaller sized quotient structure such that the formula need be verified only for the quotient. In both works, symmetries are specified by hand by the designer. <p> If M = (S; R; K) is a Kripke structure, (M; s j= f ) denotes that the state formula f is true for state s 2 S. Similarly, (M; j= g) denotes that path formula g is true for path . See <ref> [CEFJ96] </ref> for a formal definition of j= using this notation. We say that two CTL* formulas are logically equivalent if their truth values are identical for every state in any Kripke structure. We say that two CTL* formulas are structurally equivalent if they also have isomorphic parse trees. <p> The representation for G 1 H would allow us to easily identify the partitions induced by G1H s and produce witnesses that transform one sub-formula into another. 4 Quotient Structures We now develop a theory of symmetries for Kripke structures, extending those developed by Clarke et al <ref> [CEFJ96] </ref> and Emerson and Sistla [ES96]. Let M = (S; R; K) be a Kripke structure with 2 L states. Let G Aut M L X for some set of labels X AP . <p> The fundamental result in <ref> [CEFJ96] </ref> is captured by the following theorem: Theorem 3. [CEFJ96] For a Kripke structure M = (S; R; K) and a group G Aut M L AP , if (8 2 G)(8p 2 AP )(p = p), then for any CTL* formula f , it is true that (8s 2 S)((M; <p> The fundamental result in <ref> [CEFJ96] </ref> is captured by the following theorem: Theorem 3. [CEFJ96] For a Kripke structure M = (S; R; K) and a group G Aut M L AP , if (8 2 G)(8p 2 AP )(p = p), then for any CTL* formula f , it is true that (8s 2 S)((M; s j= f ) , (M G ; [[s]]
Reference: [CES86] <author> E. M. CLARKE, E. A. EMERSON, AND A. P. SISTLA. </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2):244263, </volume> <year> 1986. </year>
Reference-contexts: Model Checking Problem: Given a set of atomic propositions AP , a Kripke structure M = (S; R; K), a CTL* formula f and a set of initial states I S, does every state in I satisfy f ? Clarke, Emerson and Sistla <ref> [CES86] </ref> presented the first algorithm for CTL model checking using explicit state space exploration. A Binary Decision Diagrams based symbolic model checker that can handle more than 10 120 states on some pipelined circuits has been described by Burch et al [BCL + 94].
Reference: [CYB93] <author> S.-T. CHENG, G. YORK, AND R. K. BRAYTON. VL2MV: </author> <note> A Compiler from Verilog to BLIF-MV, </note> <month> October </month> <year> 1993. </year>
Reference-contexts: 378 11 25 39 144 7 z4ml 527 929 5 14 19 108 4 4-arbit 3158 4000 19 52 105 3110 60 Example back-track maxset numchoices ctlp20 0 20 19 ping-pong 0 2 1 z4ml 8 4 21 tain a BLIF-MV description using a compiler called vl2mv written by Cheng <ref> [CYB93] </ref>. The BLIF-MV description is flattened using a standard VIS command. The flattened circuit along with a bipartition is fed to our program which first generates a suitable labeled directed graph, then refines the labels and finally runs the branch and bound algorithm.
Reference: [EJP97] <author> E. A. EMERSON, S. JHA, AND D. PELED. </author> <title> Combining Partial Order and Symmetry Reductions. </title> <booktitle> In Proc. </booktitle> <volume> TACAS 97, </volume> <pages> pp. </pages> <year> 1934, </year> <month> April </month> <year> 1997. </year>
Reference-contexts: In both works, symmetries are specified by hand by the designer. Emerson and Sistla [ES95] have developed theory for using symmetries with fairness constraints. Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Emerson, Jha and Peled <ref> [EJP97] </ref> have combined partial orders and symmetries. Symmetries have also been shown to speedup transistor-level verification [PB97]. Ip and Dill [ID96] use symmetries for speeding up verification of safety properties using explicit techniques for designs specified in a guarded command language.
Reference: [ES95] <author> E. A. EMERSON AND A. P. SISTLA. </author> <title> Utilizing Symmetry when Model Checking under Fairness Assumptions: An Automata-theoretic Approach. </title> <booktitle> In Proc. CAV 95, </booktitle> <pages> pp. 309324, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: In both works, symmetries are specified by hand by the designer. Emerson and Sistla <ref> [ES95] </ref> have developed theory for using symmetries with fairness constraints. Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Emerson, Jha and Peled [EJP97] have combined partial orders and symmetries. Symmetries have also been shown to speedup transistor-level verification [PB97].
Reference: [ES96] <author> E. A. EMERSON AND A. P. SISTLA. </author> <title> Symmetry and Model Checking. Formal Meth. </title> <booktitle> in Sys. Design, </booktitle> <address> 9(1/2):105131, </address> <year> 1996. </year>
Reference-contexts: This is commonly known as State Space Explosion. Among the techniques being developed for countering this problem are partial order methods, abstraction, compositional approaches, and symmetry reductions. Symmetries abound in hardware circuits, distributed algorithms and concurrent programs. Emerson and Sistla <ref> [ES96] </ref> and Clarke et al [CEFJ96] show how symmetries in Kripke structures and CTL* formulas allow the construction of a smaller sized quotient structure such that the formula need be verified only for the quotient. In both works, symmetries are specified by hand by the designer. <p> for G 1 H would allow us to easily identify the partitions induced by G1H s and produce witnesses that transform one sub-formula into another. 4 Quotient Structures We now develop a theory of symmetries for Kripke structures, extending those developed by Clarke et al [CEFJ96] and Emerson and Sistla <ref> [ES96] </ref>. Let M = (S; R; K) be a Kripke structure with 2 L states. Let G Aut M L X for some set of labels X AP . Let two states s and t in S be related if there exists 2 G such that s = t. <p> In the extreme case, we could have AP = L, giving each state a unique label and making G trivial. Emerson and Sistla <ref> [ES96] </ref> present a generalization of Theorem 3. However, their theory is built for Kripke structures derived from systems of communicating isomorphic processes, the set of atomic propositions being the set of shared variables. In our terminology, it amounts to assuming AP = L and a single initial state. <p> See [Man97] for a summary of known results for computing ~ G1H . Theorem 4 can be further extended along the lines of Auto f in <ref> [ES96] </ref> by introducing an additional set of labels corresponding to all sub-formulas that have E; X or U as the topmost operator.
Reference: [FH + 83] <author> G. FOWLER, R. HARALICK, ET AL. </author> <title> Efficient Graph Automorphism by Vertex Partitioning. </title> <booktitle> Aritificial Intelligence, </booktitle> <address> 21:245269, </address> <year> 1983. </year>
Reference-contexts: Some such functions that satisfy U min 4 U are easy to compute. The intersection of two such functions U 1 f U 2 is also guaranteed to be at least as coarse as U min . Such functions are called vertex invariants <ref> [FH + 83] </ref>. Some vertex invariants that can be computed in O (m + n) time are the in-degree and out-degree of vertices, the set of degrees of vertices incident at a vertex and the set of degrees of vertices which a vertex is incident upon. <p> For a vertex v, let U 0 compute the set of labels of vertices incident upon v. Then U 0 is a vertex invariant such that U min 4 U 0 <ref> [FH + 83] </ref>. U can be refined by computing U f U 0 in O (m + n) time repeatedly. At most n 1 iterations are required.
Reference: [Gap] <author> GAP: </author> <title> Groups, Algorithms and Programs, </title> <note> Version 3, Release 4. Available via ftp from ftp.math.rwth-aachen.de, directory /pub/gap. </note>
Reference-contexts: A detailed description of an algorithm for computing Aut A, that draws ideas from computational group theory and uses the algorithm in it is yet to be implemented. We initially experimented with a software package called GAP <ref> [Gap] </ref>, which offers a graph automorphism program called nauti [McK90] based on one of the earliest such programs written by McKay [McK81]. It is natural to ask: Why write another graph automorphism program? Existing packages are general purpose and carry around a lot of baggage.
Reference: [GS97] <author> V. GYURIS AND A. P. SISTLA. </author> <title> On-the-Fly Model Checking under Fairness that Exploits Symmetry. </title> <booktitle> In Proc. CAV 97, </booktitle> <address> Haifa, Israel, </address> <month> June </month> <year> 1997, </year> <pages> pp. 232243, </pages> <year> 1997. </year>
Reference-contexts: In both works, symmetries are specified by hand by the designer. Emerson and Sistla [ES95] have developed theory for using symmetries with fairness constraints. Gyuris and Sistla <ref> [GS97] </ref> have developed an on-the-fly model checker that utilizes symmetries under fairness. Emerson, Jha and Peled [EJP97] have combined partial orders and symmetries. Symmetries have also been shown to speedup transistor-level verification [PB97].
Reference: [Hof80] <author> C. M. HOFFMAN. </author> <title> On the Complexity of Intersecting Permutation Groups and its Relationship with Graph Isomorphism. </title> <type> Technical Report 4/80, </type> <institution> Institut for Informatik und Praktische Mathematik, Christian-Albrechts-Universitat Kiel, </institution> <year> 1980. </year>
Reference-contexts: G need be computed only once for a given circuit. However, computing group intersections is as hard as graph isomorphism <ref> [Hof80] </ref>, though polynomial time algorithms do exist for special cases. A simpler approach is to join the two graphs corresponding to G and H together by drawing an edge between every pair of vertices that correspond to the same p 2 AP in both the graphs.
Reference: [ID96] <author> C. N. IP AND D. L. DILL. </author> <title> Better Verification Through Symmetry. Formal Meth. </title> <booktitle> in Sys. Design, </booktitle> <address> 9(1/2):4176, </address> <year> 1996. </year>
Reference-contexts: Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Emerson, Jha and Peled [EJP97] have combined partial orders and symmetries. Symmetries have also been shown to speedup transistor-level verification [PB97]. Ip and Dill <ref> [ID96] </ref> use symmetries for speeding up verification of safety properties using explicit techniques for designs specified in a guarded command language. They propose augmentation of the language itself by introducing a new data type with syntactic constraints for sets of fully symmetric variables called scalarsets.
Reference: [Man97] <author> GURMEET SINGH MANKU. </author> <title> Structural Symmetries and Model Checking. </title> <type> Master's thesis UCB/ERL M97/92, </type> <institution> University of California at Berkeley, </institution> <year> 1997. </year> <note> Available as http://www-cad.eecs.berkeley.edu/manku/papers/ms.ps.gz. </note>
Reference-contexts: A detailed proof can be found in <ref> [Man97] </ref>. For a Kripke structure M and CTL* formula f defined on AP , let SF denote the set of all sub-formulas of f , including any atomic propositions in AP that occur in f . Recall the definitions of logical and structural equivalence from Section 2. <p> If we replace G by G s , the problem is as hard as graph isomorphism <ref> [Man97] </ref>. We outline a technique that can identify symmetric sub-formulas if the symmetry in the specification is reflected in the formula as well, which is true in practice. <p> Briefly, we need to compute the canonical state function ~ G1H and modify the model checker so that it canonicalizes every state encountered during state space traversal. See <ref> [Man97] </ref> for a summary of known results for computing ~ G1H . Theorem 4 can be further extended along the lines of Auto f in [ES96] by introducing an additional set of labels corresponding to all sub-formulas that have E; X or U as the topmost operator. <p> Let Aut C L AP denote the set of all such permutations. It can be verified that Theorem 5 still holds. A detailed proof can be found in <ref> [Man97] </ref>, which also shows how multiple-output tables, the = construct [B + 91], pseudo inputs and other special cases can be handled. The size of the graph is linear in the size of the flattened BLIF-MV description. <p> Is there any group G &lt;L&gt; that does not correspond to any BLIF-MV circuit? If so, we can focus on the remaining groups to solve the canonical state problem. However, the answer is negative <ref> [Man97] </ref>. Second, how hard is it to identify scalarsets? A scalarset is an automorphism of the graph A C such that the automorphism can be written as a product of disjoint transpositions. Note that A C is not an arbitrary directed graph. <p> Note that A C is not an arbitrary directed graph. It has been derived from a valid BLIF-MV circuit. See <ref> [Man97] </ref> for a simple proof that the problem is as hard as graph isomorphism. 5.3 Graphs for CTL* Formulas To compute H Aut f AP SF , draw the parse tree for the formula f . Label each internal node with the operator it represents. <p> Some vertex invariants that can be computed in O (m + n) time are the in-degree and out-degree of vertices, the set of degrees of vertices incident at a vertex and the set of degrees of vertices which a vertex is incident upon. See <ref> [Man97] </ref> for references to articles that describe other vertex invariants that are more expensive to compute. An important trick is to treat a unipartition U as a labeling function and use it to refine itself. <p> We found GAP to be slow. We can exploit a lot of structure in the graphs we construct. For a detailed description of several other motivating reasons see <ref> [Man97] </ref>. 7 Experimental Results We implemented the algorithm in Figure 1 to convince ourselves that our modeling of the circuit is sufficient to allow discovering symmetries. As it stands, it is useful when a circuit verifier suspects that certain symmetries exist in the circuit at hand.
Reference: [McK81] <author> B. D. MCKAY. </author> <title> Practical Graph Isomorphism. </title> <booktitle> In Proc. Tenth Manitoba Conf. on Numerical Math. and Computing, Winnepeg, 1980, </booktitle> <volume> vol 1, </volume> <pages> pp. 4587, </pages> <year> 1981. </year>
Reference-contexts: We initially experimented with a software package called GAP [Gap], which offers a graph automorphism program called nauti [McK90] based on one of the earliest such programs written by McKay <ref> [McK81] </ref>. It is natural to ask: Why write another graph automorphism program? Existing packages are general purpose and carry around a lot of baggage. We found GAP to be slow. We can exploit a lot of structure in the graphs we construct.
Reference: [McK90] <author> B. D. MCKAY. </author> <title> Nauty Users Guide (Version 1.5). </title> <type> Technical Report TR-CS-90-02, </type> <institution> Computer Science Department, Australian National University, Australia, </institution> <year> 1990. </year>
Reference-contexts: A detailed description of an algorithm for computing Aut A, that draws ideas from computational group theory and uses the algorithm in it is yet to be implemented. We initially experimented with a software package called GAP [Gap], which offers a graph automorphism program called nauti <ref> [McK90] </ref> based on one of the earliest such programs written by McKay [McK81]. It is natural to ask: Why write another graph automorphism program? Existing packages are general purpose and carry around a lot of baggage. We found GAP to be slow.
Reference: [PB97] <author> M. PANDEY AND E. BRYANT. </author> <title> Exploiting Symmetry when Verifying Transistor-Level Circuits by Symbolic Trajectory Evaluation. </title> <booktitle> In Proc. CAV 97, </booktitle> <address> Haifa, Israel, </address> <month> June </month> <year> 1997, </year> <pages> pp. 244255, </pages> <year> 1997. </year>
Reference-contexts: Emerson and Sistla [ES95] have developed theory for using symmetries with fairness constraints. Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Emerson, Jha and Peled [EJP97] have combined partial orders and symmetries. Symmetries have also been shown to speedup transistor-level verification <ref> [PB97] </ref>. Ip and Dill [ID96] use symmetries for speeding up verification of safety properties using explicit techniques for designs specified in a guarded command language. They propose augmentation of the language itself by introducing a new data type with syntactic constraints for sets of fully symmetric variables called scalarsets.
Reference: [vL90] <author> J. VAN LEEUWEN. </author> <title> Graph Algorithms. In Algorithms and Complexity, </title> <booktitle> volume A of Handbook of Theoretical Computer Science, </booktitle> <pages> pp. 525631. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: We start with U max , as defined in Lemma 2, since U max is consistent with every automorphism of A. Ideally, we should start with U min , as it is the finest such partition. However, computing U min itself is as hard as graph isomorphism <ref> [vL90] </ref>. Therefore, we compute an approximation U such that U min 4 U 4 U max using REFINE, which we describe in detail in Section 6.2. U is consistent with every automorphism of A. Having computed U , we check whether P and U are compatible.
References-found: 19

