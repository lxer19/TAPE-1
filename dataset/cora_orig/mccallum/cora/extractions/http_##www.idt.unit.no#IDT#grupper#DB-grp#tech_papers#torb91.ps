URL: http://www.idt.unit.no/IDT/grupper/DB-grp/tech_papers/torb91.ps
Refering-URL: http://www.idt.unit.no/IDT/grupper/DB-grp/tech_papers/tech_papers.html
Root-URL: 
Title: Parallel Relational Database Algorithms  
Author: ystein Torbjtrnsen 
Keyword: Parallel algorithms, relational databases, join, sorting, database machines.  
Address: 7034 Trondheim, Norway  
Affiliation: Division of Computer Systems and Telematics, The Norwegian Institute of Technology,  
Abstract: The paper describes two classes of algorithms to perform relational database operations in parallel on a distributed memory parallel computer with a disk for each processor. Bucket algorithms partition the relations into disjoint subrelations that can be processed locally on each processor while broadcast algorithms broadcast one relation to all the nodes before local processing is done. The paper focus on equi-join processing but also shows how a bucket algorithm can be used to sort a relation. The article also describes how bit vector filters and semijoin filters can speed up the processing of operations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> Data Structures and Algorithms. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1983. </year>
Reference: [2] <author> E. Babb. </author> <title> Implementing a relational database by means of specialized hardware. </title> <journal> ACM transactions on Database Systems, </journal> <volume> 4(1), </volume> <year> 1979. </year>
Reference: [3] <author> Chaitanya K. Baru and Ophir Friedler. </author> <title> Database operations in a cube-connected multicomputer system. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38(6), </volume> <month> June </month> <year> 1989. </year>
Reference-contexts: This occur when A is much smaller than B and this difference in size must increase with the number of nodes available. The broadcast based parallel join algorithm presented here is based on one described in <ref> [3] </ref>. The algorithm is meant for a parallel machine based on a hypercube communication network but is adapted here for a general network.
Reference: [4] <author> Bjtrn Arild W. Baugstt. </author> <title> Parallelle sorteringsmetoder for store datamengder i en hyperkubisk databasemaskin. </title> <type> Diploma Thesis, </type> <institution> In Norwegian, </institution> <month> February </month> <year> 1989. </year>
Reference: [5] <author> Bjtrn Arild W. Baugstt, Jarle F. Greipsland, and Joost Kamerbeek. </author> <title> Sorting large files on POOMA. </title> <booktitle> In Proceedings from CONPAR 90 | VAPP IV, </booktitle> <pages> pages 536-547. </pages> <publisher> Springer-Verlag, </publisher> <month> September 10-13 </month> <year> 1990. </year>
Reference-contexts: The graph shows that phase 1 is negligible and phase 2 the dominant one (sampling 2% of the tuples makes phase 1 take less that 2% of total sort time). Implementing the algorithm on two different parallel machines (HC16-186 and POOMA <ref> [5] </ref>) has shown that phase 2 is CPU bound and phase 3 disk bound.
Reference: [6] <author> Bjtrn Arild W. Baugstt and Jarle Fredrik Greipsland. </author> <title> Parallel sorting methods for large data volumes on a hypercube database computer. </title> <editor> In H. Boral and P. Faudemay, editors, </editor> <booktitle> Proceedings from Sixth International Workshop on Database Machines, IWDM '89, Lecture Notes in Computer Science 368, </booktitle> <pages> pages 127 - 141. </pages> <publisher> Springer-Verlag, </publisher> <month> June 89. </month>
Reference-contexts: A better method is to sample a small number of key values from the partitions and use those to estimate the distribution and find good subranges. All nodes must use the same subranges and they can therefore not be computed locally but instead requires a distributed algorithm (see <ref> [6] </ref>). The time spent in this phase depends on the number of tuples sampled. More samples gives better estimates but longer execution times. Phase 2 The second phase does the main work in the algorithm. After the subranges are determined in phase 1, each node starts two independent processes. <p> Implementing the algorithm on two different parallel machines (HC16-186 and POOMA [5]) has shown that phase 2 is CPU bound and phase 3 disk bound. This Postsort algorithms as got its name because the tuples is sorted on the destination node after they are reallocated. <ref> [6] </ref> also compare this algorithm with a Presort algorithm which sort the data into sorted subpartitions before sending it to the destination node where these sorted subpartitions are merged. There are several problems with the Presort compared with Postsort.
Reference: [7] <author> P. A. Bernstein and D. M. Chiu. </author> <title> Using semi-joins to solve relational queries. </title> <journal> Journal of the ACM, </journal> <volume> 28(1), </volume> <year> 1981. </year>
Reference: [8] <author> Kjell Bratbergsengen. </author> <title> Hashing methods and relational algebra operations. </title> <booktitle> In Proceedings of Very Large Databases, </booktitle> <year> 1984. </year>
Reference-contexts: Filters Filters are well known methods used in database processing ([2, 7, 8]). The idea of filters is to reduce the data volume as early as possible in the computations resulting in less disk I/O and fewer tuple comparisons. Both <ref> [8, 13] </ref> and [17] have shown that filters results in a significant improvement for sequential join algorithms. Parallel algorithms can in addition use filters to reduce the communication overhead. Below I will briefly discuss two techniques, bit vector filters and semijoin filters.
Reference: [9] <author> Kjell Bratbergsengen. </author> <title> Algebra operations on a parallel computer performance evaluation. </title> <booktitle> In Fifth International Workshop on Database Machines, </booktitle> <year> 1987. </year>
Reference-contexts: If the bit is set the B tuple is reallocated and joined as normal. Since potentially more than one key value maps to the same bit there might still exist tuples not matching any A tuples. <ref> [9] </ref> and [18] reports significant improvements using bit vector filters. The number of bits in the bit vector and the hash function is crucial for the efficiency of this method. If there are to few bits in the vector most bits becomes set and almost no tuples eliminated.
Reference: [10] <author> Kjell Bratbergsengen and Torgrim Gjelsvik. </author> <title> The development of the CROSS8 and HC16-186 parallel (database) computers. </title> <editor> In H. Boral and P Faudemay, editors, </editor> <booktitle> Proceedings from Sixth International Workshop on Database Machines, Lecture Notes in Computer Science 368, </booktitle> <pages> pages 359-372. </pages> <publisher> Springer-Verlag, </publisher> <month> June 19-21 </month> <year> 1989. </year>
Reference: [11] <author> E. F. Codd. </author> <title> A relational model of data for large shared data banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6), </volume> <month> June </month> <year> 1979. </year>
Reference-contexts: The next section shows how data can be sorted in parallel on this machine before the description of two classes of parallel equi-join algorithms: bucket join and broadcast join algorithms. Relational Databases Relational database system is based on the mathematical concept of the relational model defined in <ref> [11] </ref>. There are no room in this paper to discuss this ideas in depth but I will give a short introduction to define the terminology. A relation is an unordered set of tuples. A tuple is a collection of attributes.
Reference: [12] <author> D. DeWitt, R. Katz, F. Olken, D. Shaphiro, M. Stonebraker, and D. Wood. </author> <title> Implementation techniques for main memory database systems. </title> <booktitle> In Proceedings of the 1984 SIGMOD Conference, </booktitle> <address> Boston, MA, USA, </address> <month> June </month> <year> 1984. </year>
Reference: [13] <author> David J. DeWitt and Robert Gerber. </author> <title> Multiprocessor hash-based join algorithms. </title> <booktitle> In Proceedings of Very Large Databases, </booktitle> <pages> pages 151-164, </pages> <address> Stockholm, </address> <year> 1985. </year>
Reference-contexts: These two streams are on the fly scanned and matching tuples joined together. Since they are sorted it is easy to find matching tuples by scanning the two streams in parallel and synchronized. In <ref> [13] </ref> DeWitt and Gerber compares the algorithms described and concludes that Hybrid hash join is the best choice in almost all cases. The Nested loop join algorithm behaves bad when little memory is available since B must be read multiple times from disk. <p> Filters Filters are well known methods used in database processing ([2, 7, 8]). The idea of filters is to reduce the data volume as early as possible in the computations resulting in less disk I/O and fewer tuple comparisons. Both <ref> [8, 13] </ref> and [17] have shown that filters results in a significant improvement for sequential join algorithms. Parallel algorithms can in addition use filters to reduce the communication overhead. Below I will briefly discuss two techniques, bit vector filters and semijoin filters.
Reference: [14] <author> Goetz Graefe. </author> <title> Encapsulation of parallelism in the Volcano query processing system. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conference on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: Inter-query parallelism executes multiple queries in parallel, inter-operator parallelism runs the different operators a query is composed of concurrently, and intra operator parallelism where the individual operator is evaluated in parallel. The rest of this paper will discuss algorithms for intra-operator parallelism. See <ref> [14, 19] </ref> for more information on the two other items. Parallel Sorting Although sorting not is a relational algebra operation it is a essential operation in relational database systems. Sorting speeds up initial building of indices and can be used to execute other relational database operations (eg. sort-merge join).
Reference: [15] <author> M. Kitsuregawa, H. Tanaka, and T. Moto-oka. </author> <title> Relational algebra machine grace. </title> <booktitle> In RIMS Symposia on Software Science and Engineering 1982, Lecture Notes in Computer Science, </booktitle> <pages> pages 191-212. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference: [16] <author> Donald E. Knuth. </author> <title> The Art of Computer Programming, Sorting and Searching, volume 3. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1973. </year>
Reference: [17] <author> John Peck, Satish Dharmaraj, and Roy Pargas. </author> <title> Analysis of distributed join algorithms. </title> <booktitle> In Proceedings of The Fifth Distributed Memory Computing Conference, </booktitle> <volume> volume 2, </volume> <pages> pages 1411-1419. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: Filters Filters are well known methods used in database processing ([2, 7, 8]). The idea of filters is to reduce the data volume as early as possible in the computations resulting in less disk I/O and fewer tuple comparisons. Both [8, 13] and <ref> [17] </ref> have shown that filters results in a significant improvement for sequential join algorithms. Parallel algorithms can in addition use filters to reduce the communication overhead. Below I will briefly discuss two techniques, bit vector filters and semijoin filters. <p> For long tuples it performs much better than the nested loop algorithm but for small tuple sizes the situation is turned around. I will not describe any such algorithms here but refer to <ref> [17, 20] </ref> for more details. Load balancing As described for the parallel sort algorithm much effort was spent on finding a good partitioning of the relation over the nodes with one partition for each node.
Reference: [18] <author> Donovan A. Schneider and David J. DeWitt. </author> <title> A performance evaluation of four parallel join algorithms in a shared-nothing multiprocessor environment. </title> <booktitle> In Proc. of the ACM SIGMOD Conference, </booktitle> <pages> pages 110 - 121, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: If the bit is set the B tuple is reallocated and joined as normal. Since potentially more than one key value maps to the same bit there might still exist tuples not matching any A tuples. [9] and <ref> [18] </ref> reports significant improvements using bit vector filters. The number of bits in the bit vector and the hash function is crucial for the efficiency of this method. If there are to few bits in the vector most bits becomes set and almost no tuples eliminated.
Reference: [19] <author> Donovan A. Schneider and David J. DeWitt. </author> <title> Tradeoffs in processing complex join queries via hashing in multiprocessor database machines. </title> <booktitle> In Proc. of the 16th International Conference on Very Large Data Bases, </booktitle> <pages> pages 469-480, </pages> <month> August </month> <year> 1990. </year> <title> [20] ystein Torbjtrnsen. Shortest path routing in a failsoft hypercube database machine. </title> <booktitle> In Proceedings of The Fifth Distributed Memory Computing Conference, </booktitle> <volume> volume 2, </volume> <pages> pages 839-844. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: Inter-query parallelism executes multiple queries in parallel, inter-operator parallelism runs the different operators a query is composed of concurrently, and intra operator parallelism where the individual operator is evaluated in parallel. The rest of this paper will discuss algorithms for intra-operator parallelism. See <ref> [14, 19] </ref> for more information on the two other items. Parallel Sorting Although sorting not is a relational algebra operation it is a essential operation in relational database systems. Sorting speeds up initial building of indices and can be used to execute other relational database operations (eg. sort-merge join).
Reference: [21] <author> J. Tuazon, J. Peterson, and M. Pniel. </author> <title> Mark IIIfp hypercube concurrent processor architecture. </title> <booktitle> In Proc. of The Third Conference on Hypercube Concurrent Computers and Applications, </booktitle> <volume> volume 1, </volume> <pages> pages 71-80, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: The machine is a 64 node JPL Mark III hypercube <ref> [21] </ref>. No disks are used. all the bits set to zero. When an A tuple is received on a node the corresponding bit is set. There might be more than one join key value being mapped to the same bit in the bit vector.
References-found: 20

