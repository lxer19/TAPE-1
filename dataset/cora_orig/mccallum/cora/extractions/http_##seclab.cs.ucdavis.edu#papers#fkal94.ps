URL: http://seclab.cs.ucdavis.edu/papers/fkal94.ps
Refering-URL: http://seclab.cs.ucdavis.edu/papers.html
Root-URL: http://www.cs.ucdavis.edu
Email: gfink@cs.ucdavis.edu  
Title: Towards a Property-based Testing Environment with Applications to Security-Critical Software  
Author: George Fink Calvin Ko Myla Archer Karl Levitt 
Address: Davis  
Affiliation: Department of Computer Science, University of California,  
Abstract: We consider an approach to testing that combines white-box and black-box techniques. Black-box testing is used for testing a program's effects against its specification. White-box testing is essential if subtle implementation errors are to be identified, e.g., errors due to race conditions. Full white-box testing is a large task. However, for many properties, only a small portion of the program is relevant | hence property-based testing has the potential to substantially simplify much of the testing work. The portion of a program that relates to a given property can be identified through slicing. We describe the ongoing development of a Tester's Assistant, which in the long term, will include a specification-driven slicer for C programs, a test data generator, a coverage analyzer, and an execution monitor. The slicer and execution monitor are described in this paper, and applications to Unix security are indicated. Security is an important application of property-based testing because of the subtle undetected security errors in delivered operating systems. It is also a promising application because of the (unexpectedly) concise specifications that capture most security requirements, and because of the operating system support for execution monitoring. fl The work reported here is being supported in part by ARPA under contract USNN00014-94-1-0065 and by the Lawrence Livermore National Laboratory under work order LLNL-IUTB234584. 
Abstract-found: 1
Intro-found: 1
Reference: [BH92] <author> Thomas Ball and Susan Horwitz. </author> <title> Slicing programs with arbitrary control flow. </title> <institution> Department of Computer Science, University of Wisconsin-Madison, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: For simple imperative languages, generation of the flow graphs and the resultant slice is relatively easy. More complicated language constructs such as procedures, gotos, and pointers require alterations in the slicing algorithm. Interprocedural slicing [LC92] and slicing for programs with arbitrary control flow <ref> [BH92] </ref> have been studied. In order to slice C code, the problems of pointers and pointer aliasing need to be addressed. Weiser noted that slices are implicitly used in debugging [Wei82]. In the Tester's Assistant, the uses of slices are made explicit.
Reference: [LC91] <author> Panas E. Livadas and Stephen Croll. </author> <title> The C-Ghinsu tool. </title> <type> Technical Report SERC-TR-55-F, </type> <institution> University of Florida, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: The specification of setuid indicates that paths which traverse both are secure, and thus do not need further testing. Determining slices in this manner is called dicing <ref> [LC91] </ref>. The current version of the Tester's Assistant slicer does a data-flow breakdown of the program, and can find simple slices. Significantly, interprocedural and pointer analysis are not complete, so slices do not cross procedural boundaries and have to make limiting assumptions about pointer behavior.
Reference: [LC92] <author> Panas E. Livadas and Stephen Croll. </author> <title> Program slicing. </title> <type> Technical Report SERC-TR-61-F, </type> <institution> University of Florida, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: For simple imperative languages, generation of the flow graphs and the resultant slice is relatively easy. More complicated language constructs such as procedures, gotos, and pointers require alterations in the slicing algorithm. Interprocedural slicing <ref> [LC92] </ref> and slicing for programs with arbitrary control flow [BH92] have been studied. In order to slice C code, the problems of pointers and pointer aliasing need to be addressed. Weiser noted that slices are implicitly used in debugging [Wei82]. <p> Using ELI, we are able to quickly prototype the Tester's Assistant. The dataflow representation has been implemented. The slicer is partially implemented: it is operational on single-procedure programs using most of C's operations and properties. Inter-procedural slices generated by algorithms from <ref> [LC92] </ref> will greatly increase the number of programs we can analyze. Pointer anti-aliasing will be introduced to make slices more efficient. Currently, the slicer makes worst case assumptions about pointer aliasing, though the well-behavedness assumption limits the scope of the aliasing assumptions.
Reference: [Lo92] <author> Raymond Waiman Lo. </author> <title> Static Analysis of Programs with Application to Malicious Code Detection. </title> <type> PhD thesis, </type> <institution> University of California, Davis, </institution> <year> 1992. </year>
Reference-contexts: A pointer is well-behaved if, once assigned to an object in memory, it does not, through pointer addition or typecasting, try to refer to a different object in memory. A program is well-behaved if all of its pointers are well-behaved. Lo <ref> [Lo92] </ref> showed that static analysis can establish the well-behavedness property in many cases. The well-behavedness property can also be affirmed through testing with respect to appropriate safety specifications. Unfortunately, much of the power of C as a language derives from being able to do ill-behaved operations.
Reference: [Lut93] <author> Robin R. Lutz. </author> <title> Targeting safety-related errors during software requirements analysis. </title> <booktitle> In Proceedings of the First ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 99-105, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The final category of specification describes safety properties, which have been enumerated many times <ref> [Lut93] </ref> [Spa92]. Safety properties cover common programming mistakes which can cause flaws.
Reference: [OT89] <author> Debra J. Richardson Owen O'Malley and Cindy Tittle. </author> <title> Approaches to specification-based testing. </title> <booktitle> In Proceedings of the First ACM SIGSOFT '89 Third Symposium on Testing, Analysis, and Verification(TAV3), </booktitle> <pages> pages 86-96, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Specifications are necessary in order to describe the properties which drive the testing process. We have found that it is relatively easy to specify most security-related properties. It is not necessary, in general, to provide a full specification of the program's behavior, as in the work described in <ref> [OT89] </ref>, and as we demonstrate below for security specifications. In some instances, no specification of the program itself is necessary for detecting security-related flaws. Certain generic flaws [Spa92] been shown to be the cause of many security problems. <p> An executable oracle derived from the security requirements is desirable. The use of specifications as oracles to test programs is not new: Richardson <ref> [OT89] </ref> and Sankar [SH94] [San89] used specifications to generate assertion-checking functions. What is unique about our approach is the relative (small) size of the specifications, and the ability to associate them with a slice of the program.
Reference: [San89] <author> S. Sankar. </author> <title> Automatic Runtime Consistency Checking and Debugging of Formally Specified Programs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1989. </year> <institution> Also Stanford University Department of Computer Science Technical Report No. STAN-CS-89-1282, and Computer Systems Laboratory Technical Report No. CSL-TR-89-391. </institution>
Reference-contexts: An executable oracle derived from the security requirements is desirable. The use of specifications as oracles to test programs is not new: Richardson [OT89] and Sankar [SH94] <ref> [San89] </ref> used specifications to generate assertion-checking functions. What is unique about our approach is the relative (small) size of the specifications, and the ability to associate them with a slice of the program.
Reference: [SH94] <author> S. Sankar and R. Hayes. </author> <title> Adl | an interface definition language for specifying and testing software. </title> <type> Technical Report CMU-CS-94-WIDL-1, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: An executable oracle derived from the security requirements is desirable. The use of specifications as oracles to test programs is not new: Richardson [OT89] and Sankar <ref> [SH94] </ref> [San89] used specifications to generate assertion-checking functions. What is unique about our approach is the relative (small) size of the specifications, and the ability to associate them with a slice of the program.
Reference: [Spa92] <author> Eugene H. Spafford. </author> <title> Common system vulnerabilities. Future Directions in Intrusion and Misuses Detection, </title> <year> 1992. </year>
Reference-contexts: It is not necessary, in general, to provide a full specification of the program's behavior, as in the work described in [OT89], and as we demonstrate below for security specifications. In some instances, no specification of the program itself is necessary for detecting security-related flaws. Certain generic flaws <ref> [Spa92] </ref> been shown to be the cause of many security problems. These generic flaws can be captured in specifications for use in property-based testing. By not requiring full specifications, property-based testing is relatively easy to apply to systems that do not typically come with full specifications. <p> The final category of specification describes safety properties, which have been enumerated many times [Lut93] <ref> [Spa92] </ref>. Safety properties cover common programming mistakes which can cause flaws.
Reference: [Tan87] <author> Andrew S. Tanenbaum. </author> <title> Operating Systems - Design and Implementation. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Finally, these examples provide a fairly representative sample of the range of specifications and programs relevant to computer security. To illustrate, Figure 4 is a slice of the MINIX <ref> [Tan87] </ref> login program with respect to the setuid system call. The original program contains 337 lines, the slice only 20, demonstrating the effectiveness of slicing in this case 5 .
Reference: [W + 93] <author> William Waite et al. </author> <title> Eli system manuals. </title> <type> Unpublished Manuals, </type> <year> 1993. </year>
Reference-contexts: All of the components coordinate through a common data-flow program representation. To generate the dataflow representation and correct the instrumentation necessary for coverage analysis and monitoring, the ELI <ref> [W + 93] </ref> system is used. ELI is a text processing and compiler construction toolkit. In ELI, high-level specifications are converted into high-performance executable translators and compilers. Using ELI, we are able to quickly prototype the Tester's Assistant. The dataflow representation has been implemented.
Reference: [Wei82] <author> Mark Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <month> July </month> <year> 1982. </year>
Reference-contexts: Interprocedural slicing [LC92] and slicing for programs with arbitrary control flow [BH92] have been studied. In order to slice C code, the problems of pointers and pointer aliasing need to be addressed. Weiser noted that slices are implicitly used in debugging <ref> [Wei82] </ref>. In the Tester's Assistant, the uses of slices are made explicit. Slicing impacts the other testing algorithms (e.g., coverage) by enabling an algorithm to be utilized on a subset of the original program (the slice), giving an increase in efficiency.
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-375, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Weiser <ref> [Wei84] </ref> originally implemented slicing for FORTRAN programs. A criterion for the slice is selected. In the simplest scenario, a criterion is a variable and a location in the program.
References-found: 13

