URL: http://www.cs.nmsu.edu/lldap/download/jicslp/henk.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp/henk.html
Root-URL: http://www.cs.nmsu.edu
Email: fhenk.vandecasteele, bart.demoeng@cs.kuleuven.ac.be  
Title: The Use of Mercury for the Implementation of a Finite Domain Solver Keywords: Logic Programming,
Author: Henk Vandecasteele Bart Demoen Joachim Van Der Auwera 
Date: September 9, 1996  
Address: Celestijnenlaan 200A B-3001 Heverlee Belgium  
Affiliation: Department of Computer Science  
Abstract: Mercury [SHC94]is a recent phenomenon in the field of logic programming: it is faster than other logic language implementations (e.g. Prolog) and better suited for the development of large applications because of its compile-time error-detection capabilities. The concepts and technology used in the implementation of Mercury are rather new and not yet evaluated thoroughly outside its implementors group. This paper reports on an evaluation of Mercury, by describing the porting from the medium-sized constraint solving tool ROPE written originally in Prolog, to Mercury. At first our aim and hope, was only to arrive at a faster implementation of the constraint solving tool, but in the course of the porting, it became clear that the main feature necessary for efficiency and missing from the current implementation of Mercury, is efficient backtrackable destructive assignment, at least for our application. We report on a naive port of the Prolog implementation of ROPE in Mercury, a redesigned version using more efficient data-structures and finally a version which uses our own hacked together implementation of backtrackable destructive assignment: a future version of Mercury will hopefully support this functionality through user-declarations or analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [AB92] <author> Abderrahmane Aggoun and Nicolas Beldiceanu. </author> <title> Extending CHIP in order to solve complex scheduling and placement problems. </title> <booktitle> JFPL, </booktitle> <pages> pages 51-66, </pages> <year> 1992. </year>
Reference-contexts: A new version of the bridge problem was added. In this version all disjunctions are added to the system before any choices are made. The old version of the bridge problem is called "bridge1", the new version "bridge2". A variant of the perfect square <ref> [AB92] </ref> was added with small dimensions. Also a Japanese puzzle called suudoku.
Reference: [BW88] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18 </volume> <pages> 807-820, </pages> <year> 1988. </year>
Reference-contexts: The first results show that this first pure implementation in Mercury is slower than the implementation on top of Prolog using proLog by BIM. Two versions were tried, one with garbage collection and one without. Mercury uses garbage collection at the level of C <ref> [BW88] </ref>.
Reference: [HD91] <author> Pascal Van Hentenryck and Yves Deville. </author> <title> The cardinality operator: A new logical connective for constraint logic programming. </title> <booktitle> In proceedings of ICLP, </booktitle> <year> 1991. </year>
Reference-contexts: This last parameter could express for example that on backtracking a new variable must be chosen for assignment, while in classical methods the same variable is assigned another value. The language also contains a version of the cardinality constraint <ref> [HD91] </ref> and the possibility to express an optimization function. 2.3. Implementation of ROPE on top of Prolog 2.3.1. Data representation A domain in ROPE is a finite set of natural numbers which is represented as an union of disjunct intervals. For example the set f1,2,3,8,9,12g is represented as 1..3:8..9:12..12 . <p> This section describes the addition of backtrackable destructive assignment to Mercury, and the effect on the efficiency of our constraint solver. In the pure version of the previous section only "in"-constraints were implemented. It was also very difficult to implement for example the cardinality constraint <ref> [HD91] </ref>. Such a constraint causes the need to remove constraints from the dependency lists connected to a variable. In Prolog this is realized by including a free variable with each constraint. To remove a constraint from a list this variable is instantiated. This is not possible in Mercury. <p> Results Given backtrackable destructive assignment also the cardinality constraint <ref> [HD91] </ref> was added to the system. With the additional cardinality constraints a wider range of examples was possible. A new version of the bridge problem was added. In this version all disjunctions are added to the system before any choices are made.
Reference: [Hen89] <author> Pascal Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> The MIT press, </publisher> <year> 1989. </year>
Reference-contexts: A fixpoint algorithm like AC3 [Mac77] can be used to accomplish this task. 2.2. Features of ROPE The finite domain solver ROPE allows the user to express a wide range of different pruning strategies for each constraint. These pruning strategies include forward checking, partial lookahead and full lookahead <ref> [Hen89] </ref>, but also contain many other pruning behaviours in between forward checking and lookahead. The existence of such pruning strategies was suggested in [Nad89]. In [VDS94] these pruning strategies were presented and discussed. <p> In another version of the Mercury program checking for duplicates in the constraint-queue was added. This was implemented with the help of the same binary tree used in the previous experiment. Also another example was added to the test-examples. It concerns the bridge problem described in <ref> [Hen89] </ref>. mrope ROPE queens (10) 65s 39s bridge1 (200) 5s 27s With the checking for duplicates the queens program is slowed down again, while with the new example we get an interesting speedup. So, it is possible that some examples run 5 times faster in this pure implementation of Mercury.
Reference: [HSD93] <author> Pascal Van Hentenryck, Vijay Saraswat, and Yves Deville. </author> <title> Design, implementation and evaluation of the constraint language cc(fd). </title> <type> Technical report, </type> <institution> Brown University, </institution> <year> 1993. </year>
Reference-contexts: For example the set f1,2,3,8,9,12g is represented as 1..3:8..9:12..12 . The operator ../2 denotes an interval, the operator :/2 denotes the union of the two operands. A constraint is usually transformed to a set of "in"-constraints, as done in <ref> [HSD93] </ref>. Each constraint can lead to a different set of "in"-constraints depending on the desired pruning behaviour.
Reference: [Mac77] <author> Alan K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: The removal of inconsistent values from a domain can lead to new inconsistent values for other variables. A fixpoint algorithm like AC3 <ref> [Mac77] </ref> can be used to accomplish this task. 2.2. Features of ROPE The finite domain solver ROPE allows the user to express a wide range of different pruning strategies for each constraint.
Reference: [Nad89] <author> Bernard A. </author> <title> Nadel. Constraint satisfaction algorithms. </title> <journal> Computational Intelligence, </journal> <volume> 5(4) </volume> <pages> 188-224, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: These pruning strategies include forward checking, partial lookahead and full lookahead [Hen89], but also contain many other pruning behaviours in between forward checking and lookahead. The existence of such pruning strategies was suggested in <ref> [Nad89] </ref>. In [VDS94] these pruning strategies were presented and discussed. Another feature of the finite domain language is a powerful enumeration primitive [Van94]: consistency techniques (removal of inconsistent values) are not enough to solve a finite domain problem. Most problems also need sophisticated enumeration.
Reference: [SHC94] <author> Zoltan Somogy, Fergus Henderson, and Thomas Conway. </author> <title> The implemenatation of mercury: an efficient declarative logic programming language. </title> <booktitle> In Proceedings of the ILPS'p4 Post-conference Workshop on Implementation Techniques for Logic Programming Languages, </booktitle> <year> 1994. </year>
Reference: [Van94] <author> Henk Vandecasteele. </author> <title> On backtracking in finite domain problems. </title> <booktitle> In Proceedings of the Fifth Benelux Workshop on Logic Programming, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: The existence of such pruning strategies was suggested in [Nad89]. In [VDS94] these pruning strategies were presented and discussed. Another feature of the finite domain language is a powerful enumeration primitive <ref> [Van94] </ref>: consistency techniques (removal of inconsistent values) are not enough to solve a finite domain problem. Most problems also need sophisticated enumeration.
Reference: [VDS94] <author> Henk Vandecasteele and Danny De Schreye. </author> <title> Implementing a finite-domain CLP-language on top of Prolog : a transformational approach. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Proceedings of Logic Programming and Automated Reasoning, number 822 in Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 84-98. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: 1. Motivation In the past years, we have developed a prototype finite domain solver ROPE on top of Prolog <ref> [VDS94] </ref>. This implementation will further we referred to as ROPE. This prototype lacks efficiency 1 2 1996 Compulog Net Meeting on Parallelism and Implementation Technology because its implementation doesn't rely on any non-standard support of the Prolog implementation. <p> Finally we added backtrackable destructive assignment to the Mercury-system and report on this in section 4. We end with some conclusions. 2. The finite domain solver ROPE 2.1. Finite domain solvers in general The finite domain solver ROPE <ref> [VDS94] </ref> is a system within the paradigm of constraint logic programming, an extension of logic programming. In constraint logic programming languages unification is substituted with a more general constraint solving method. <p> These pruning strategies include forward checking, partial lookahead and full lookahead [Hen89], but also contain many other pruning behaviours in between forward checking and lookahead. The existence of such pruning strategies was suggested in [Nad89]. In <ref> [VDS94] </ref> these pruning strategies were presented and discussed. Another feature of the finite domain language is a powerful enumeration primitive [Van94]: consistency techniques (removal of inconsistent values) are not enough to solve a finite domain problem. Most problems also need sophisticated enumeration.
References-found: 10

