URL: ftp://www.elet.polimi.it/pub/data/Pierguido.Caironi/eurwrt96.ps.gz
Refering-URL: http://www.elet.polimi.it/~caironi/listpub.html
Root-URL: 
Email: Email: caironi@ipmel2.elet.polimi.it, mezzalir@ipmel2.elet.polimi.it, sami@ipmel2.elet.polimi.it  
Phone: Phone +39 2 2399 3400 fax +39 2 2399 3411  
Title: Context Reorder Buffer: an Architectural Support for Real-Time Processing on RISC Architectures  
Author: Pierguido V.C. CAIRONI, Lorenzo MEZZALIRA, Mariagiovanna SAMI 
Address: Piazza Leonardo da Vinci 32 20133 Milano ITALY  
Affiliation: Dipartimento di Elettronica e Informazione Politecnico di Milano  
Abstract: The CRB architecture assures precise nested interrupts and exceptions, minimal interrupt fetching latency and high throughput. Moreover, our architecture supports speculative execution of depth limited only by the number of entries within the CRB and does not require a change to the current programming model of RISC and real-time CPUs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. E. Smith, A. R. Pleszkun. </author> <title> Implementing Precise Interrupts in Pipelined Processors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 37, no. 5, </volume> <pages> pp. 562-573, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Solutions like c) which reconstruct a state consistent with a particular return program counter before starting the interrupt service are called precise interrupts , while solution like a) and b) are called imprecise interrupts <ref> [1] </ref>. The concept of precision may be applied to exceptions too. Because of this and other similarities, exceptions and interrupts have often been treated together in literature. Published precise solutions, besides solution c), are: in-order instruction completion , reorder buffer , history buffer, future file [1], register update unit [3] and <p> b) are called imprecise interrupts <ref> [1] </ref>. The concept of precision may be applied to exceptions too. Because of this and other similarities, exceptions and interrupts have often been treated together in literature. Published precise solutions, besides solution c), are: in-order instruction completion , reorder buffer , history buffer, future file [1], register update unit [3] and checkpoint repair mechanism [4]. Imprecise solutions, besides solutions a) and b), are: invisible exchange packet [5] and others (see [1]). <p> Published precise solutions, besides solution c), are: in-order instruction completion , reorder buffer , history buffer, future file <ref> [1] </ref>, register update unit [3] and checkpoint repair mechanism [4]. Imprecise solutions, besides solutions a) and b), are: invisible exchange packet [5] and others (see [1]). In practice, due to simplicity and cost requirements, in current implemented architectures interrupts and exceptions are made precise only if process recovery is strictly required (such as in the case of TLB miss, or unimplemented code exceptions). <p> Processors specifically designed for real-time applications tend to adopt more conservative approaches which, while being less aggressive as computing power than the ones already mentioned, grant lower and much more predictable interrupt handling latencies (instances of these approaches are linear pipelines <ref> [1] </ref>, tightly coupled pipelines [15], shadow registers or stacks [6]). Current computational requirements of real-time applications are however pushing these solutions to their architectural limits and some real-time processors with more aggressive architectures are appearing (e.g., Motorola 88110 [16]). <p> The present paper offers a hardware solution to the problem of interrupt in a RISC superscalar architecture devised for real-time applications. This solution (based on the reorder buffer concept <ref> [1] </ref>) assures precise interrupts and exceptions, does not require any change to the programming model of standard real-time processors and grants that the interrupt handler fetching starts the clock cycle after the interrupt handler address has been loaded from the interrupt vector. <p> The CRB architecture In this section we will introduce the main concepts of the CRB functionality. Further details on structural implementation and functional characteristics will be given in Sections 4 and 5. The CRB ensues from reorder buffer (RB) architecture as presented by Smith and Pleszkun <ref> [1] </ref>. Let us summarize it. The RB architecture is composed of a result shift register (used to control the result bus from the functional units to the RB) and the actual RB (a circular register file accessed as a FIFO through two pointers: head and tail). <p> Moreover, we do not use the result shift register as a mean to manage the result bus from the functional units to the reorder buffer entries. As introduced by Smith and Pleszkun <ref> [1] </ref>, the result shift register requires the execution latency of any instruction being known at issue stage; in our reference architecture, due to explicit consideration of data-dependency in reservation stations, this is difficult. Therefore, we prefer to use a tag that identifies the proper CRB instruction entry. <p> The CRB entry is divided in the following fields 3 (some of them taken by Smith and Pleszkun <ref> [1] </ref>): CRB [.].dest_regs: encoding of the destination registers of the instruction CRB [.].results: encoding of the results of the instruction. CRB [.].exception: encoding of the possible type of exception caused by the instruction. It is set to 0, if no exception is detected. CRB [.].PC: program counter of the instruction.
Reference: [2] <author> D. A. Patterson, J. L. Hennessy. </author> <title> Computer Organization & Design: </title> <publisher> the Hardware/Software Interface . Morgan Kaufmann Publishers, </publisher> <address> San Mateo, California, </address> <year> 1994 </year>
Reference-contexts: 1. Introduction Initially conceived as high-performance CPUs for workstation-class computers, RISC CPUs <ref> [2] </ref> are now also proposed as core devices for embedded real-time systems or coupled with real-time controllers in process control applications.
Reference: [3] <author> G. S. Sohi. </author> <title> Instruction Issue Logic for High-Performance, Interruptible, Multiple Functional Unit, Pipelined Computers. </title> <journal> IEEE Transactions on Computers , vol. </journal> <volume> 39, no. 3, </volume> <pages> pp. 349-359, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The concept of precision may be applied to exceptions too. Because of this and other similarities, exceptions and interrupts have often been treated together in literature. Published precise solutions, besides solution c), are: in-order instruction completion , reorder buffer , history buffer, future file [1], register update unit <ref> [3] </ref> and checkpoint repair mechanism [4]. Imprecise solutions, besides solutions a) and b), are: invisible exchange packet [5] and others (see [1]).
Reference: [4] <author> W. W. Hwu, Y. N. Patt. </author> <title> Checkpoint Repair for High-Performance Out-of-Order Execution Machines. </title> <journal> IEEE Transactions on Computers , vol. </journal> <volume> C-36, no. 12, </volume> <pages> pp. 1496-1514, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Because of this and other similarities, exceptions and interrupts have often been treated together in literature. Published precise solutions, besides solution c), are: in-order instruction completion , reorder buffer , history buffer, future file [1], register update unit [3] and checkpoint repair mechanism <ref> [4] </ref>. Imprecise solutions, besides solutions a) and b), are: invisible exchange packet [5] and others (see [1]).
Reference: [5] <author> Control Data Corp. </author> <title> CDC CYBER 200 Model 205 Computer System Hardware Reference Manual . Arden Hills, </title> <address> MN, </address> <year> 1981. </year>
Reference-contexts: Published precise solutions, besides solution c), are: in-order instruction completion , reorder buffer , history buffer, future file [1], register update unit [3] and checkpoint repair mechanism [4]. Imprecise solutions, besides solutions a) and b), are: invisible exchange packet <ref> [5] </ref> and others (see [1]). In practice, due to simplicity and cost requirements, in current implemented architectures interrupts and exceptions are made precise only if process recovery is strictly required (such as in the case of TLB miss, or unimplemented code exceptions).
Reference: [6] <author> W. Walker, H. G. Cragon. </author> <title> Interrupt Processing in Concurrent Processors. </title> <journal> IEEE Computer , pp. </journal> <pages> 36-46, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Processors specifically designed for real-time applications tend to adopt more conservative approaches which, while being less aggressive as computing power than the ones already mentioned, grant lower and much more predictable interrupt handling latencies (instances of these approaches are linear pipelines [1], tightly coupled pipelines [15], shadow registers or stacks <ref> [6] </ref>). Current computational requirements of real-time applications are however pushing these solutions to their architectural limits and some real-time processors with more aggressive architectures are appearing (e.g., Motorola 88110 [16]).
Reference: [7] <author> J. E. Smith, S. Weiss. </author> <title> PowerPC 601 and Alpha 21064: A Tale of Two RISCs. </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 46-58, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Especially for long-latency instructions (such as floating point ones) fully precise exception processing is generally left to less performing operative modes or to special trap instructions <ref> [7] </ref> [8] [9] [10] [11] [12] [13] [14]. The interrupt handling problem is further complicated by real-time constraints . Two additional requirements must be considered: worst case latency of interrupt service has to be limited; interrupt management overhead should not decrease the throughput (especially if interrupts are frequent).
Reference: [8] <author> J. H. Edmondson, P. Rubinfield, R. Preston, V. Rajagopalan. </author> <title> Superscalar Instruction Execution in the 21164 Alpha Microprocessor. </title> <journal> IEEE Micro , pp. </journal> <pages> 33-43, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Especially for long-latency instructions (such as floating point ones) fully precise exception processing is generally left to less performing operative modes or to special trap instructions [7] <ref> [8] </ref> [9] [10] [11] [12] [13] [14]. The interrupt handling problem is further complicated by real-time constraints . Two additional requirements must be considered: worst case latency of interrupt service has to be limited; interrupt management overhead should not decrease the throughput (especially if interrupts are frequent).
Reference: [9] <author> S. Weiss, J. E. Smith. </author> <title> POWER and PowerPC: </title> <booktitle> Principles, </booktitle> <publisher> Architecture and Implementation . Morgan Kaufmann Publishers, </publisher> <address> San Francisco, California, </address> <year> 1994. </year>
Reference-contexts: Especially for long-latency instructions (such as floating point ones) fully precise exception processing is generally left to less performing operative modes or to special trap instructions [7] [8] <ref> [9] </ref> [10] [11] [12] [13] [14]. The interrupt handling problem is further complicated by real-time constraints . Two additional requirements must be considered: worst case latency of interrupt service has to be limited; interrupt management overhead should not decrease the throughput (especially if interrupts are frequent).
Reference: [10] <author> T. Potte r, M. Vaden, J. Young, N. Ullah. </author> <title> Resolution of Data and Control-Flow Dependencies in the PowerPC 601. </title> <booktitle> IEEE Micro, </booktitle> <pages> pp. 18-29, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Especially for long-latency instructions (such as floating point ones) fully precise exception processing is generally left to less performing operative modes or to special trap instructions [7] [8] [9] <ref> [10] </ref> [11] [12] [13] [14]. The interrupt handling problem is further complicated by real-time constraints . Two additional requirements must be considered: worst case latency of interrupt service has to be limited; interrupt management overhead should not decrease the throughput (especially if interrupts are frequent).
Reference: [11] <author> S. P. Song, M. Denman, J. Chang. </author> <title> The PowerPC 604 RISC Microprocessor. </title> <booktitle> IEEE Micro, </booktitle> <pages> pp. 8-17, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Especially for long-latency instructions (such as floating point ones) fully precise exception processing is generally left to less performing operative modes or to special trap instructions [7] [8] [9] [10] <ref> [11] </ref> [12] [13] [14]. The interrupt handling problem is further complicated by real-time constraints . Two additional requirements must be considered: worst case latency of interrupt service has to be limited; interrupt management overhead should not decrease the throughput (especially if interrupts are frequent). <p> Interface with the precise state This section of the CRB interface logic deals with instruction results committing, exception activation and speculative execution. This control logic is completely combinatorial and comparable, as complexity, to the control logic of many current implementations of the reorder buffer <ref> [11] </ref>. In this paper we give just a brief summary of it. More details can be found in [19].
Reference: [12] <author> S. Mirapuri, M. Woodacre, N. Vasseghi. </author> <title> The MIPS R4000 Processor. </title> <booktitle> IEEE Micro, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Especially for long-latency instructions (such as floating point ones) fully precise exception processing is generally left to less performing operative modes or to special trap instructions [7] [8] [9] [10] [11] <ref> [12] </ref> [13] [14]. The interrupt handling problem is further complicated by real-time constraints . Two additional requirements must be considered: worst case latency of interrupt service has to be limited; interrupt management overhead should not decrease the throughput (especially if interrupts are frequent).
Reference: [13] <author> G. Kane, J. Heinrich. </author> <title> MIPS, RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: Especially for long-latency instructions (such as floating point ones) fully precise exception processing is generally left to less performing operative modes or to special trap instructions [7] [8] [9] [10] [11] [12] <ref> [13] </ref> [14]. The interrupt handling problem is further complicated by real-time constraints . Two additional requirements must be considered: worst case latency of interrupt service has to be limited; interrupt management overhead should not decrease the throughput (especially if interrupts are frequent).
Reference: [14] <author> T. R. </author> <title> Halfhill. </title> <journal> Intels P6. BYTE, </journal> <pages> pp. 42-58, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Especially for long-latency instructions (such as floating point ones) fully precise exception processing is generally left to less performing operative modes or to special trap instructions [7] [8] [9] [10] [11] [12] [13] <ref> [14] </ref>. The interrupt handling problem is further complicated by real-time constraints . Two additional requirements must be considered: worst case latency of interrupt service has to be limited; interrupt management overhead should not decrease the throughput (especially if interrupts are frequent).
Reference: [15] <author> J. Circello, G. Edgington, D. McCarthy, J. Gay, D. Schimke, S. Sullivan, R. Duerden, C. Hinds, D. Marquette, L. Sood, A. Crouch, D. Chow. </author> <title> The Superscalar Architecture of the MC68060. </title> <booktitle> IEEE Micro, </booktitle> <pages> pp. 10-21, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Processors specifically designed for real-time applications tend to adopt more conservative approaches which, while being less aggressive as computing power than the ones already mentioned, grant lower and much more predictable interrupt handling latencies (instances of these approaches are linear pipelines [1], tightly coupled pipelines <ref> [15] </ref>, shadow registers or stacks [6]). Current computational requirements of real-time applications are however pushing these solutions to their architectural limits and some real-time processors with more aggressive architectures are appearing (e.g., Motorola 88110 [16]).
Reference: [16] <author> K. Diefendorff. M. </author> <title> Allen Organization of the Motorola 88110 Superscalar RISC Microprocessor. </title> <booktitle> IEEE Micro, </booktitle> <pages> pp. 40-63, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Current computational requirements of real-time applications are however pushing these solutions to their architectural limits and some real-time processors with more aggressive architectures are appearing (e.g., Motorola 88110 <ref> [16] </ref>). The present paper offers a hardware solution to the problem of interrupt in a RISC superscalar architecture devised for real-time applications.
Reference: [17] <author> R. M. Tomasulo. </author> <title> An Efficient Algorithm for Exploiting Multiple Arithmetic Units. </title> <journal> IBM Journal , Vol. </journal> <volume> 11, </volume> <pages> pp. 25-33, </pages> <month> January </month> <year> 1967. </year>
Reference-contexts: An incorrect branch prediction is not a problem since correct instruction sequencing for branch instructions is checked in the CRB before committing the branch. Decode: decode stage. Reservation stations : initially proposed by Tomasulo <ref> [17] </ref> and further extended by Weiss and Smith [18], they manage data-dependencies and availability of registers. Instructions wait in reservation stations for their operands to be available. Depending on data-dependencies, instructions may exit the reservation stations out of program order even if they entered them in program order.
Reference: [18] <author> S. Weiss, J. E. Smith. </author> <title> Instruction issue logic in pipelined supercomputers. </title> <journal> IEEE Transactions on Computers , vol. </journal> <volume> C-33, </volume> <pages> pp. 1013-1022, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: An incorrect branch prediction is not a problem since correct instruction sequencing for branch instructions is checked in the CRB before committing the branch. Decode: decode stage. Reservation stations : initially proposed by Tomasulo [17] and further extended by Weiss and Smith <ref> [18] </ref>, they manage data-dependencies and availability of registers. Instructions wait in reservation stations for their operands to be available. Depending on data-dependencies, instructions may exit the reservation stations out of program order even if they entered them in program order.
Reference: [19] <author> P. V. C. Caironi. </author> <title> Context Reorder Buffer: an Architectural Support for Real-Time Interrupt Processing in RISC Superscalar Architectures. </title> <type> Technical Report n. </type> <institution> 96.008, Politecnico di Milano, Italy, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: This control logic is completely combinatorial and comparable, as complexity, to the control logic of many current implementations of the reorder buffer [11]. In this paper we give just a brief summary of it. More details can be found in <ref> [19] </ref>. The CRB commit control logic performs a number of mutually exclusive functions based on the contents of the entry pointed to by head (i.e., the oldest entry of the CRB) and, possibly, that of the entry pointed to by inc_head (to check branch prediction).
References-found: 19

