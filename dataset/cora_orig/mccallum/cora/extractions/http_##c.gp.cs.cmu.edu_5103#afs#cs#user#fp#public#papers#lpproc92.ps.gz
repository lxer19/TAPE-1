URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/lpproc92.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/
Root-URL: http://www.cs.cmu.edu
Email: spiro@cis.ohio-state.edu  fp@cs.cmu.edu  
Title: An Empirical Study of the Runtime Behavior of Higher-Order Logic Programs 1 (Preliminary Version)  
Author: Spiro Michaylov Frank Pfenning 
Address: 228 Bolz Hall 2036 Neil Avenue Mall Columbus, OH 43210-1277, U.S.A.  Pittsburgh, PA 15213-3890, U.S.A.  
Affiliation: Department of Computer and Information Science The Ohio State University  School of Computer Science Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Penny Anderson. </author> <title> Program Development by Proof Transformation. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year> <note> In preparation. </note>
Reference-contexts: Abs Number of abstractions over a uvar. Abs/Uv Normalized ratio of such abstractions to substitutions of uvars. The examples used are as follows: * Extraction | Constructive theorem proving and program extraction <ref> [1] </ref> Spiro Michaylov and Frank Pfenning 7 All Unifications Dynamic Unifications Dynamic/Assume Program Unif %Ind %S %F Dyn %Ind %S %F Ass U/Ass AU/Ass Mini-ML 15333 87 13 0 1532 93 7 0 67 22.87 1.61 Canonical 177 66 28 6 8 50 50 0 3 2.67 1.33 Prop 677 60
Reference: [2] <author> Scott Dietzen and Frank Pfenning. </author> <title> Higher-order and modal logic as a framework for explanation-based generalization. </title> <journal> Machine Learning, </journal> <volume> 9 </volume> <pages> 23-55, </pages> <year> 1992. </year>
Reference-contexts: Some initial work on compiler design for higher-order logic programming languages can be found in [11, 16, 18, 19] 2 . At the same time, the language design process for such languages is far from complete. Extensions <ref> [2, 7] </ref> as well as restrictions [14] of Prolog have been proposed to increase its expressive power or simplify the language theory or its implementation. Obviously, further language design and implementation efforts must be closely linked. It is easy to design unimplementable languages or implement unusable languages.
Reference: [3] <author> Timothy G. Griffin. </author> <title> Logical interpretations as computational simulations. </title> <type> Draft paper. </type> <institution> Talk given at the North American Jumelage, AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Because of the large number of cases, indexing has a stronger effect than in all other examples. * CPS | Interpretation of propositional logics and CPS conversions <ref> [3, 23] </ref> Various forms of conversion of simply-typed terms to continuation-passing and exception-returning style. Substitutions are all parameter substitutions, and unification involves an unusually large number of gvar-anything cases.
Reference: [4] <author> John Hannan and Frank Pfenning. </author> <title> Compiler verification in LF. </title> <editor> In Andre Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 407-418, </pages> <address> Santa Cruz, California, June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: This involves only parameter substitutions, and assumptions are heavily used. * DeBruijn <ref> [4] </ref> A compiler from untyped -terms to terms using deBruijn indices, including a call-by-value operational semantics for source and target language. The proof manipulation queries check compiler correctness for concrete programs. Indexing works quite poorly, and an unusually large number of abst-abst cases arise in unification. * CLS [4] A second <p> * DeBruijn <ref> [4] </ref> A compiler from untyped -terms to terms using deBruijn indices, including a call-by-value operational semantics for source and target language. The proof manipulation queries check compiler correctness for concrete programs. Indexing works quite poorly, and an unusually large number of abst-abst cases arise in unification. * CLS [4] A second compiler from terms in deBruijn representation to the CLS abstract machine. Simple queries execute the CLS machine on given programs, proof manipulation queries check compiler correctness for concrete programs. This is almost completely first-order.
Reference: [5] <author> Robert Harper and Frank Pfenning. </author> <title> A module system for a programming language based on the LF logical framework. </title> <type> Technical Report CMU-CS-92-191, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: A small number of non-parameter substitutions arise, but mostly unification is first-order. Here, too, there is much redundant type computation. * Prop | Propositional Theorem Proving and Transformation <ref> [5] </ref> This is mostly first-order. In the transformations between various proof formats (natural deduction and Hilbert calculi), a fairly large number of assumptions arise, and are quite heavily used.
Reference: [6] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 131-142, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: This indicates that the input was not annotated with enough type information (within the polymorphic type discipline, not within the framework). * Records | A lambda-calculus with records and polymorphism Type checking for a lambda-calculus with records and polymorphism as described in <ref> [6] </ref>. This involves only parameter substitutions, and assumptions are heavily used. * DeBruijn [4] A compiler from untyped -terms to terms using deBruijn indices, including a call-by-value operational semantics for source and target language. The proof manipulation queries check compiler correctness for concrete programs.
Reference: [7] <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. Information and Computation, 199? To appear. </title> <booktitle> A preliminary version appeared in the Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Some initial work on compiler design for higher-order logic programming languages can be found in [11, 16, 18, 19] 2 . At the same time, the language design process for such languages is far from complete. Extensions <ref> [2, 7] </ref> as well as restrictions [14] of Prolog have been proposed to increase its expressive power or simplify the language theory or its implementation. Obviously, further language design and implementation efforts must be closely linked. It is easy to design unimplementable languages or implement unusable languages.
Reference: [8] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: They are explained further in Section 3. We briefly summarize what we consider to be some of the central issues and our conclusion. Full unification in higher-order languages is clearly impractical, due to the non-existence of minimal complete sets of most-general unifiers <ref> [8] </ref>. Therefore, work on Prolog has used Huet's algorithm for pre-unification [8], where so-called flex-flex pairs (which are always unifiable) are postponed as constraints, in effect turning Prolog into a constraint logic programming language. Yet, even pre-unifiability is undecidable, and sets of most general pre-unifiers may be infinite. <p> We briefly summarize what we consider to be some of the central issues and our conclusion. Full unification in higher-order languages is clearly impractical, due to the non-existence of minimal complete sets of most-general unifiers <ref> [8] </ref>. Therefore, work on Prolog has used Huet's algorithm for pre-unification [8], where so-called flex-flex pairs (which are always unifiable) are postponed as constraints, in effect turning Prolog into a constraint logic programming language. Yet, even pre-unifiability is undecidable, and sets of most general pre-unifiers may be infinite.
Reference: [9] <author> Joxan Jaffar, Spiro Michaylov, Peter J. Stuckey, and Roland H. C. Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: This leads us to suggest a strategy for efficient implementation of higher-order logic programming languages, which is essentially the strategy described for Constraint Logic Programming languages in <ref> [9, 12] </ref>. That is: * The languages should not be restricted syntactically. * The unification instances corresponding to those of L should be identified as directly solvable, and the remainder as hard. Hard constraints should be delayed until they become directly solvable as a result of further variable instantiation.
Reference: [10] <author> Joxan Jaffar, Spiro Michaylov, and Roland Yap. </author> <title> A methodology for managing hard constraints in CLP systems. </title> <editor> In Barbara Ryder, editor, </editor> <booktitle> Proceedings of the ACM SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 306-316, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year> <booktitle> 14 Proceedings of the 1992 Prolog Workshop </booktitle>
Reference-contexts: Hard constraints should be delayed until they become directly solvable as a result of further variable instantiation. The relevant terminology, concepts and implementation methods are described in <ref> [10] </ref>. * Data structures and algorithms should be designed to favor the simple cases of unification. 2 Properties of Programs Since our concern in this paper is with efficient implementation (and its interaction with language design), the properties of programs that we most need to study are the dynamic properties: how
Reference: [11] <author> Keehang Kwon, Gopalan Nadathur, and Debra Sue Wilson. </author> <title> Implementing logic programming languages with polymorphic typing. </title> <type> Technical Report CS-1991-39, </type> <institution> Duke University, Durham, North Carolina, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Some initial work on compiler design for higher-order logic programming languages can be found in <ref> [11, 16, 18, 19] </ref> 2 . At the same time, the language design process for such languages is far from complete. Extensions [2, 7] as well as restrictions [14] of Prolog have been proposed to increase its expressive power or simplify the language theory or its implementation. <p> Consider the rule above: the head of this rule requires only first order unification, which could be implemented as simple variable binding. Type redundancy. Both in Prolog and Elf there is a potential for much redundant run-time type computation. In Prolog, this is due to polymorphism (see <ref> [11] </ref>), in Elf it is due to type dependency. Such redundancy can be detected statically. However, the question about the dynamic properties of programs remains: how much type computation remains after all redundant ones have been eliminated. Level of indexing. This is an Elf-specific property of a program. <p> It is rather obvious that runtime type computation must be avoided whenever possible as suggested in <ref> [11] </ref>, and that proof building must be avoided whenever the proof object will not be needed. We need special efficient mechanisms for direct binding and first-order unification. Furthermore, unification as in L and substitution of parameters for bound variables are very important special cases that merit special attention.
Reference: [12] <author> Spiro Michaylov. </author> <title> Design and Implementation of Practical Constraint Logic Programming Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1992. </year> <note> Available as Technical Report CMU-CS-92-168. </note>
Reference-contexts: This leads us to suggest a strategy for efficient implementation of higher-order logic programming languages, which is essentially the strategy described for Constraint Logic Programming languages in <ref> [9, 12] </ref>. That is: * The languages should not be restricted syntactically. * The unification instances corresponding to those of L should be identified as directly solvable, and the remainder as hard. Hard constraints should be delayed until they become directly solvable as a result of further variable instantiation. <p> to Elf only), which saves about 50% of total computation time, although the savings are not additive (some of the occurs-check overhead arises in building proofs). 4 Conclusions We briefly summarize our preliminary conclusions, which are very much in line with the experience gained in other constraint logic programming languages <ref> [12] </ref>. Language Design. Statically prohibiting difficult cases in unification (by a restriction to L , for example) is not a good idea, since it leads to a proliferation of code and significantly complicates meta-theory as it is typically expressed in Elf.
Reference: [13] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: Because of our interest in the syntactic restriction to L , we need to understand how often and why programs do not fall into this subset. An important use of general variable applications appears in a rule like the following (taken from a natural semantics in <ref> [13] </ref>) eval_app_lam : eval (app E1 E2) V &lt;- eval E1 (lam E1') &lt;- eval E2 V2 &lt;- eval (E1' V2) V. 4 Proceedings of the 1992 Prolog Workshop where we see an application of two existential variables (E1' V2) to implement substitution in an object language by meta-level fi-reduction. <p> Indexing is particularly effective here, and assumed rules are used unusually infrequently. Note that these examples do not include any basic computation. * Mini-ML <ref> [13] </ref> An implementation of Mini-ML, including type-checking, evaluation, and the type soundness proof.
Reference: [14] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In Peter Schroeder-Heister, editor, </editor> <booktitle> Extensions of Logic Programming: International Workshop, Tubingen FRG, </booktitle> <month> December </month> <year> 1989, </year> <pages> pages 253-281. </pages> <publisher> Springer-Verlag LNCS 475, </publisher> <year> 1991. </year>
Reference-contexts: Some initial work on compiler design for higher-order logic programming languages can be found in [11, 16, 18, 19] 2 . At the same time, the language design process for such languages is far from complete. Extensions [2, 7] as well as restrictions <ref> [14] </ref> of Prolog have been proposed to increase its expressive power or simplify the language theory or its implementation. Obviously, further language design and implementation efforts must be closely linked. It is easy to design unimplementable languages or implement unusable languages. <p> It can result in thrashing when certain combinations of unification problems have to be solved by extensive backtracking. Moreover, in a straightforward implementation, common cases of unification incur a high overhead. These problems have led to a search for natural, decidable subcase of higher-order unification. Miller <ref> [14] </ref> has suggested a syntactic restriction (L ) to Prolog, easily extensible to related languages [22], where most general unifiers are unique modulo fiff-equivalence. Miller's restriction has many attractive features. Unification is deterministic and thrashing behavior due to unification is avoided. <p> We measure various aspects of unification and constraint satisfaction. Terms involved in equations (disagreement pairs) are classified as rigid (con Spiro Michaylov and Frank Pfenning 5 stant head), uvars (parameters, i.e., temporary constants), evars (simple logic variables), gvars (generalized variables, i.e., logic variables applied to distinct, dominated parameters <ref> [14] </ref>), flexible (compound terms with a logic variable at the head, but not a gvar), abst (a term beginning with a -abstraction), or quant (a term beginning with a -quantification, in Elf only).
Reference: [15] <author> Dale Miller. </author> <title> Unification of simply typed lambda-terms as logic programming. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proceedings of the Eighth International Conference on Logic Programming, </booktitle> <pages> pages 255-269. </pages> <publisher> MIT Press, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: Miller's restriction has many attractive features. Unification is deterministic and thrashing behavior due to unification is avoided. Higher-order unification in its full power can be implemented if some additional control constructs (when) are available <ref> [15] </ref>. However, our study suggests that this solution is unsatisfactory, since it has a detrimental effect on programming methodology, and potentially introduces a new efficiency problem. Object-level variables are typically represented by meta-level variables, which means that object-level capture-avoiding substitution can be implemented via meta-level fi-reduction.
Reference: [16] <author> Gopalan Nadathur and Bharat Jayaraman. </author> <title> Towards a WAM model for lambda Prolog. </title> <booktitle> In Proceedings of the 1989 North American Conference on Logic Programming, </booktitle> <pages> pages 1180-1198. </pages> <publisher> MIT Press, </publisher> <month> October </month> <year> 1989. </year>
Reference-contexts: Some initial work on compiler design for higher-order logic programming languages can be found in <ref> [11, 16, 18, 19] </ref> 2 . At the same time, the language design process for such languages is far from complete. Extensions [2, 7] as well as restrictions [14] of Prolog have been proposed to increase its expressive power or simplify the language theory or its implementation.
Reference: [17] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction Implementation technology for higher-order logic programming languages such as Prolog <ref> [17] </ref> and Elf [21] is still in its infancy. There are many features of these languages that do not occur in ordinary Prolog programs, such as types, variable binding constructs for terms, embedded implication and universal quantification, or dependent types and explicit construction of proofs.
Reference: [18] <author> Gopalan Nadathur and Debra Sue Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <booktitle> In Proceedings of the 1990 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 341-348. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Some initial work on compiler design for higher-order logic programming languages can be found in <ref> [11, 16, 18, 19] </ref> 2 . At the same time, the language design process for such languages is far from complete. Extensions [2, 7] as well as restrictions [14] of Prolog have been proposed to increase its expressive power or simplify the language theory or its implementation. <p> Moreover, the relative frequency of parameter substitution suggests that it is crucial for it to be highly efficient, while general substitution is somewhat less critical. A proposal regarding efficient implementation of terms has been made in <ref> [18] </ref>. For our study we eliminated substitutions which arose due to clause copying and during type reconstruction, since these are residuals effects of the interpreter and would most likely be eliminated in any reasonable compiler. Unification and Constraint Satisfaction. We measure various aspects of unification and constraint satisfaction.
Reference: [19] <author> Pascal Brisset Olivier Ridoux, Serge Le Huitouze. Prolog/mali. </author> <note> Available via ftp over the Internet, </note> <month> March </month> <year> 1992. </year> <note> Send mail to pm@irisa.fr for further information. </note>
Reference-contexts: Some initial work on compiler design for higher-order logic programming languages can be found in <ref> [11, 16, 18, 19] </ref> 2 . At the same time, the language design process for such languages is far from complete. Extensions [2, 7] as well as restrictions [14] of Prolog have been proposed to increase its expressive power or simplify the language theory or its implementation.
Reference: [20] <author> Frank Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 153-163, </pages> <address> Snowbird, Utah, July 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A relatively high per centage of the substitutions are non-parameter substitutions. * Polylam | Type inference in the polymorphic lambda calculus <ref> [20] </ref> Type inference for the polymorphic -calculus involves postponed constraints, but mostly parameter substitutions. Unification can be highly non-deterministic.
Reference: [21] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year> <note> Spiro Michaylov and Frank Pfenning 15 </note>
Reference-contexts: 1 Introduction Implementation technology for higher-order logic programming languages such as Prolog [17] and Elf <ref> [21] </ref> is still in its infancy. There are many features of these languages that do not occur in ordinary Prolog programs, such as types, variable binding constructs for terms, embedded implication and universal quantification, or dependent types and explicit construction of proofs. <p> Substitutions are all parameter substitutions, and unification involves an unusually large number of gvar-anything cases. The redundant type computations are very significant in this example|all the examples are level 2 judgments. * Canonical | Canonical forms in the simply-typed lambda-calculus <ref> [21] </ref> Conversion of lambda-terms to canonical form. A small number of non-parameter substitutions arise, but mostly unification is first-order. Here, too, there is much redundant type computation. * Prop | Propositional Theorem Proving and Transformation [5] This is mostly first-order.
Reference: [22] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amsterdam, The Nether-lands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Moreover, in a straightforward implementation, common cases of unification incur a high overhead. These problems have led to a search for natural, decidable subcase of higher-order unification. Miller [14] has suggested a syntactic restriction (L ) to Prolog, easily extensible to related languages <ref> [22] </ref>, where most general unifiers are unique modulo fiff-equivalence. Miller's restriction has many attractive features. Unification is deterministic and thrashing behavior due to unification is avoided. Higher-order unification in its full power can be implemented if some additional control constructs (when) are available [15].
Reference: [23] <author> Frank Pfenning and Ekkehard Rohwedder. </author> <title> Implementing the meta-theory of deductive systems. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 537-551, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference-contexts: Because of the large number of cases, indexing has a stronger effect than in all other examples. * CPS | Interpretation of propositional logics and CPS conversions <ref> [3, 23] </ref> Various forms of conversion of simply-typed terms to continuation-passing and exception-returning style. Substitutions are all parameter substitutions, and unification involves an unusually large number of gvar-anything cases.
Reference: [24] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: There is rather little abstraction. * Forsythe | Forsythe type checking Forsythe is an Algol-like language with intersection types developed by Reynolds <ref> [24] </ref>. This example involves very few substitutions, all of which are parameter substitutions. Thus the runtime behavior suggests an almost entirely first-order program, which is not apparent from the code. * Lam | Lambda calculus convertibility Normalization and equivalence proofs of terms in a typed -calculus.
References-found: 24

