URL: http://www.cs.uoregon.edu/~sabry/papers/debugging.ps
Refering-URL: http://www.cs.uoregon.edu/~sabry/papers/index.html
Root-URL: http://www.cs.uoregon.edu
Email: sabry@cs.uoregon.edu sparud@cs.york.ac.uk  
Title: Debugging Reactive Systems in Haskell  
Author: Amr Sabry Jan Sparud 
Address: Eugene, OR 97403 Heslington, York Y01 5DD, UK  
Affiliation: Department of Computer Science Department of Computer Science University of Oregon University of York  
Abstract: We support the use of Haskell in two classes of applications. First, we note that although Haskell is well-suited for stream-oriented applications, like reactive systems, most implementations lack tools for locating subtle errors like deadlocks. To support the use of Haskell in such applications, we have designed and implemented a debugger with an intuitive graphical interface. The debugger simplifies the task of locating deadlocks by providing users with a mostly declarative view of programs as systems of recursive equations over streams. Second, we investigate the use of Haskell in the implementation of the debugger. As expected, this effort requires a variant of Haskell, currently used in the intermediate phases of Haskell compilers, that combines call-by-need semantics with computational effects. To support robust programming in this system-oriented variant, we formalize the semantics of handleable exceptions in a call-by-need language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abelson, H., and Sussman, G. J. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: 1 Streams and Deadlocks As Kahn showed in 1974 [23], any deterministic network of processes can be modeled using recursive equations over streams. Such networks occur in telephones, missiles, and many other embedded reactive programs. The stream model corresponds in spirit to the electrical engineer's concept of a signal-processing system <ref> [1] </ref> and thus provides a natural formalism for the design, specification, and verification of these networks [11]. Additionally, stream-based specifications are directly executable in a variety of high-level languages.
Reference: [2] <author> Ariola, Z. M., and Felleisen, M. </author> <title> The call-by-need lambda calculus. </title> <note> To appear in the Journal of Functional Programming, </note> <year> 1996. </year>
Reference-contexts: Int ` M : Int ` throw M : t ` M : t ` N : Int ! t ` catch M N : t 6.1 Evaluation Contexts Because of the lazy semantics of the language, the definition of the axioms is intertwined with the definition of evaluation contexts <ref> [2, 3] </ref>. Intuitively, "needed" variables within sub-terms correspond to those variables that occur in evaluation context positions. Therefore, we define evaluation contexts first before defining the semantics of the language.
Reference: [3] <author> Ariola, Z. M., Felleisen, M., Maraist, J., Oder-sky, M., and Wadler, P. </author> <title> A call-by-need lambda calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1995), </booktitle> <pages> pp. 233-246. </pages>
Reference-contexts: Int ` M : Int ` throw M : t ` M : t ` N : Int ! t ` catch M N : t 6.1 Evaluation Contexts Because of the lazy semantics of the language, the definition of the axioms is intertwined with the definition of evaluation contexts <ref> [2, 3] </ref>. Intuitively, "needed" variables within sub-terms correspond to those variables that occur in evaluation context positions. Therefore, we define evaluation contexts first before defining the semantics of the language.
Reference: [4] <author> Ashcroft, E. A., and Wadge, W. W. </author> <title> Lucid, a non-procedural language with iteration. </title> <journal> Communications of the ACM 20, </journal> <volume> 7 (1977), </volume> <pages> 519-526. </pages>
Reference-contexts: Additionally, stream-based specifications are directly executable in a variety of high-level languages. Examples of languages that elegantly support computations over streams include modern lazy functional languages such as Haskell [19], hardware-description languages such as MHDL [7] (an extension of Haskell), data-flow programming languages such as Lucid <ref> [4, 5] </ref>, and synchronous programming languages such as Esterel [9, 10], Lustre [12], and Signal [8]. These languages have been remarkably successful in supporting the rapid development of reliable systems.
Reference: [5] <author> Ashcroft, E. A., and Wadge, W. W. </author> <title> Lucid, </title> <booktitle> the Data-Flow Programming Language. </booktitle> <publisher> Academic Press, </publisher> <year> 1985. </year>
Reference-contexts: Additionally, stream-based specifications are directly executable in a variety of high-level languages. Examples of languages that elegantly support computations over streams include modern lazy functional languages such as Haskell [19], hardware-description languages such as MHDL [7] (an extension of Haskell), data-flow programming languages such as Lucid <ref> [4, 5] </ref>, and synchronous programming languages such as Esterel [9, 10], Lustre [12], and Signal [8]. These languages have been remarkably successful in supporting the rapid development of reliable systems.
Reference: [6] <author> Augustsson, L., Rittri, M., and Synek, D. </author> <title> Split--ting infinite sets of unique names by hidden state changes. </title> <type> Tech. Rep. 67, </type> <institution> Chalmers University of Technology, </institution> <year> 1992. </year>
Reference-contexts: We therefore study a variant of Haskell with call-by-need semantics and handleable exceptions. This variant of Haskell is reminiscent of the informal Haskell dialect used by some programmers, at their own risk, to implement generation of new names <ref> [6] </ref>, memoization [20], non-deterministic choice [21] and other paradigms that are not expressible in a modular way in a purely functional language. It is also reminiscent of the intermediate language of Haskell compilers like the Glasgow Haskell compiler, that implement monadic state by updates on a global shared store.
Reference: [7] <author> Barton, D. L., and Dunlop, D. D. </author> <title> An introduction to MHDL. </title> <booktitle> In Proceedings of IEEE 1993 MTT-S Symposium (San Diego, </booktitle> <address> CA, </address> <month> May </month> <year> 1993), </year> <pages> pp. 1487-1490. </pages> <note> (Paper UU-1). </note>
Reference-contexts: Additionally, stream-based specifications are directly executable in a variety of high-level languages. Examples of languages that elegantly support computations over streams include modern lazy functional languages such as Haskell [19], hardware-description languages such as MHDL <ref> [7] </ref> (an extension of Haskell), data-flow programming languages such as Lucid [4, 5], and synchronous programming languages such as Esterel [9, 10], Lustre [12], and Signal [8]. These languages have been remarkably successful in supporting the rapid development of reliable systems.
Reference: [8] <author> Benveniste, A., LeGuernic, P., and Jacquemot, C. </author> <title> Synchronous programming with events and relations: The Signal language and its semantics. </title> <booktitle> Science of Computer Programming 16 (1991), </booktitle> <pages> 103-149. </pages>
Reference-contexts: Examples of languages that elegantly support computations over streams include modern lazy functional languages such as Haskell [19], hardware-description languages such as MHDL [7] (an extension of Haskell), data-flow programming languages such as Lucid [4, 5], and synchronous programming languages such as Esterel [9, 10], Lustre [12], and Signal <ref> [8] </ref>. These languages have been remarkably successful in supporting the rapid development of reliable systems. First, streams (lazy lists) are the fundamental and most widely To appear in: ACM SIGPLAN Haskell Workshop, 1997 supported data structure in most of these languages.
Reference: [9] <author> Berry, G., and Cosserat, I. </author> <title> The Esterel synchronous programming language and its mathematical semantics. </title> <booktitle> In Seminar on Concurrency (1985), </booktitle> <editor> S. Brookes and G. Winskel, Eds., </editor> <volume> vol. </volume> <booktitle> 197 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer. </publisher>
Reference-contexts: Examples of languages that elegantly support computations over streams include modern lazy functional languages such as Haskell [19], hardware-description languages such as MHDL [7] (an extension of Haskell), data-flow programming languages such as Lucid [4, 5], and synchronous programming languages such as Esterel <ref> [9, 10] </ref>, Lustre [12], and Signal [8]. These languages have been remarkably successful in supporting the rapid development of reliable systems. First, streams (lazy lists) are the fundamental and most widely To appear in: ACM SIGPLAN Haskell Workshop, 1997 supported data structure in most of these languages.
Reference: [10] <author> Berry, G., and Gonthier, G. </author> <title> The Esterel synchronous programming language, design, semantics, </title> <booktitle> implementation. Science of Computer Programming 19, 2 (1992), </booktitle> <pages> 87-152. </pages>
Reference-contexts: Examples of languages that elegantly support computations over streams include modern lazy functional languages such as Haskell [19], hardware-description languages such as MHDL [7] (an extension of Haskell), data-flow programming languages such as Lucid [4, 5], and synchronous programming languages such as Esterel <ref> [9, 10] </ref>, Lustre [12], and Signal [8]. These languages have been remarkably successful in supporting the rapid development of reliable systems. First, streams (lazy lists) are the fundamental and most widely To appear in: ACM SIGPLAN Haskell Workshop, 1997 supported data structure in most of these languages.
Reference: [11] <editor> Broy, M., et al. </editor> <title> The design of distributed systems| an introduction to focus. </title> <type> Tech. Rep. </type> <institution> SFB-Bericht Nr. 342/2-2/92 A, Technische Universitat Munchen, </institution> <year> 1992. </year>
Reference-contexts: Such networks occur in telephones, missiles, and many other embedded reactive programs. The stream model corresponds in spirit to the electrical engineer's concept of a signal-processing system [1] and thus provides a natural formalism for the design, specification, and verification of these networks <ref> [11] </ref>. Additionally, stream-based specifications are directly executable in a variety of high-level languages. <p> Indeed Caspi and Pouzet [13] report that some of the programs running on the Airbus A320 have been obtained in this way. Also Broy et al. <ref> [11] </ref> use this methodology for the development of various distributed systems. Despite its appeal, programming with streams is quite subtle. A common mistake consists of writing a system of recursive equations over streams whose fixed point is semantically undefined [32].
Reference: [12] <author> Caspi, P., Halbwachs, N., Pilaud, D., and Plaice, J. Lustre: </author> <title> A declarative language for programming synchronous systems. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1987). </booktitle>
Reference-contexts: Examples of languages that elegantly support computations over streams include modern lazy functional languages such as Haskell [19], hardware-description languages such as MHDL [7] (an extension of Haskell), data-flow programming languages such as Lucid [4, 5], and synchronous programming languages such as Esterel [9, 10], Lustre <ref> [12] </ref>, and Signal [8]. These languages have been remarkably successful in supporting the rapid development of reliable systems. First, streams (lazy lists) are the fundamental and most widely To appear in: ACM SIGPLAN Haskell Workshop, 1997 supported data structure in most of these languages.
Reference: [13] <author> Caspi, P., and Pouzet, M. </author> <title> Synchronous Kahn networks. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming (1996), </booktitle> <pages> pp. 226-238. </pages>
Reference-contexts: Second synchronization is dealt with automatically: programmers are only required to specify sets of recursive functions over streams without having to worry about many tedious and error-prone details. Indeed Caspi and Pouzet <ref> [13] </ref> report that some of the programs running on the Airbus A320 have been obtained in this way. Also Broy et al. [11] use this methodology for the development of various distributed systems. Despite its appeal, programming with streams is quite subtle.
Reference: [14] <author> Edwards, S. </author> <title> An Esterel compiler for a synchronous/ reactive development system. </title> <publisher> ftp://ic.eecs.berke-ley.edu/pub/Esterel/esterelcomp.ps.gz. </publisher>
Reference-contexts: Furthermore, conventional debugging techniques for imperative languages such as setting breakpoints, single-stepping, tracing, and watching variables are not particularly suited for locating deadlocks occurring in lazy functional languages [15, 16, 29, 33] or synchronous languages <ref> [14] </ref>. Indeed our own personal experience in specifying reactive systems in Haskell quickly convinced us of the need for a special-purpose debugging technology specifically tailored towards computations over streams.
Reference: [15] <author> Hall, C. V., Hammond, K., and O'Donnell, J. T. </author> <title> An algorithmic and semantic approach to debugging. </title> <booktitle> In Proceedings of the Glasgow Workshop on Functional Programming (1990). </booktitle>
Reference-contexts: Furthermore, conventional debugging techniques for imperative languages such as setting breakpoints, single-stepping, tracing, and watching variables are not particularly suited for locating deadlocks occurring in lazy functional languages <ref> [15, 16, 29, 33] </ref> or synchronous languages [14]. Indeed our own personal experience in specifying reactive systems in Haskell quickly convinced us of the need for a special-purpose debugging technology specifically tailored towards computations over streams.
Reference: [16] <author> Hall, C. V., and O'Donnell, J. T. </author> <title> Debugging in applicative languages. </title> <booktitle> Lisp and Symbolic Computation (1988). </booktitle>
Reference-contexts: Furthermore, conventional debugging techniques for imperative languages such as setting breakpoints, single-stepping, tracing, and watching variables are not particularly suited for locating deadlocks occurring in lazy functional languages <ref> [15, 16, 29, 33] </ref> or synchronous languages [14]. Indeed our own personal experience in specifying reactive systems in Haskell quickly convinced us of the need for a special-purpose debugging technology specifically tailored towards computations over streams.
Reference: [17] <author> Harel, D. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming 8 (1987), </booktitle> <pages> 231-274. </pages>
Reference-contexts: Section 6 presents the semantics of such exceptions in a call-by-need language. Finally Section 7 puts our work in perspective by explaining its weaknesses and charting ideas for future development. 2 Programming Reactive Systems Reactive systems are programs that must continuously react to external stimuli from their surrounding environment <ref> [17] </ref>. For example, a digital filter is usually specified as a weighted sum of the n last samples of the input signal.
Reference: [18] <author> Henderson, P., and Morris, Jr., J. H. </author> <title> A lazy evaluator. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1976), </booktitle> <pages> pp. 95-103. </pages>
Reference-contexts: analysis [22]. 5 Implementing the Debugger Having argued that the debugger would be useful to include in a programming environment for Haskell, we turn our attention to the details of our current implementation in the context of the Chalmers Haskell compiler `hbc.' 5.1 Background The fundamental philosophy behind lazy evaluation <ref> [18] </ref> is that expressions are not evaluated unless their values are demanded. The initial demand usually starts from the top level routine that seeks to print the answer of the program. During debugging, the initial demand starts when the user clicks on one of the streams.
Reference: [19] <author> Hudak, P., Peyton Jones, S. L., and Wadler, P. </author> <title> Report on the programming language Haskell, a non-strict purely functional language (version 1.2). </title> <journal> SIG-PLAN Notices 27, </journal> <month> 5 </month> <year> (1992). </year>
Reference-contexts: Additionally, stream-based specifications are directly executable in a variety of high-level languages. Examples of languages that elegantly support computations over streams include modern lazy functional languages such as Haskell <ref> [19] </ref>, hardware-description languages such as MHDL [7] (an extension of Haskell), data-flow programming languages such as Lucid [4, 5], and synchronous programming languages such as Esterel [9, 10], Lustre [12], and Signal [8]. These languages have been remarkably successful in supporting the rapid development of reliable systems.
Reference: [20] <author> Hughes, J. </author> <title> Lazy memo-functions. </title> <type> Tech. Rep. 21, </type> <institution> Chalmers University of Technology, </institution> <year> 1985. </year>
Reference-contexts: We therefore study a variant of Haskell with call-by-need semantics and handleable exceptions. This variant of Haskell is reminiscent of the informal Haskell dialect used by some programmers, at their own risk, to implement generation of new names [6], memoization <ref> [20] </ref>, non-deterministic choice [21] and other paradigms that are not expressible in a modular way in a purely functional language. It is also reminiscent of the intermediate language of Haskell compilers like the Glasgow Haskell compiler, that implement monadic state by updates on a global shared store.
Reference: [21] <author> Hughes, J., and Moran, A. </author> <title> Making choices lazily. </title> <booktitle> In Conference on Functional Programming and Computer Architecture (1995). To appear. </booktitle>
Reference-contexts: We therefore study a variant of Haskell with call-by-need semantics and handleable exceptions. This variant of Haskell is reminiscent of the informal Haskell dialect used by some programmers, at their own risk, to implement generation of new names [6], memoization [20], non-deterministic choice <ref> [21] </ref> and other paradigms that are not expressible in a modular way in a purely functional language. It is also reminiscent of the intermediate language of Haskell compilers like the Glasgow Haskell compiler, that implement monadic state by updates on a global shared store.
Reference: [22] <author> Hughes, J., Pareto, L., and Sabry, A. </author> <title> Proving the correctness of reactive systems using sized types. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1996). </booktitle>
Reference-contexts: Operationally this error may manifest itself in terms of an obscure error message from the compiler or an equally obscure error message from the run-time system. For example, when suspecting a deadlock, our liveness analysis <ref> [22] </ref> returns a large (and incomprehensible) list of unsatisfied constraints. <p> Experience with the implementation indicates that the system works remarkably well for small but realistic programs. The debugger nicely complements our formal liveness analysis <ref> [22] </ref> providing users with a useful set of tools for developing reactive programs. Like many system-level Haskell programs, the implementation of the debugger relies on expressions with side-effects. <p> A proof that the new code does not produce deadlocks is outside the scope of this paper but could be achieved either by compiling the code to a finite state machine or subjecting it to our liveness analysis <ref> [22] </ref>. 5 Implementing the Debugger Having argued that the debugger would be useful to include in a programming environment for Haskell, we turn our attention to the details of our current implementation in the context of the Chalmers Haskell compiler `hbc.' 5.1 Background The fundamental philosophy behind lazy evaluation [18] is
Reference: [23] <author> Kahn, G. </author> <title> The semantics of a simple language for parallel programming. </title> <booktitle> In Proceedings of the IFIP Congress (1974), </booktitle> <editor> J. L. Rosenfeld, Ed., </editor> <publisher> North-Holland, </publisher> <pages> pp. 471-475. </pages>
Reference-contexts: 1 Streams and Deadlocks As Kahn showed in 1974 <ref> [23] </ref>, any deterministic network of processes can be modeled using recursive equations over streams. Such networks occur in telephones, missiles, and many other embedded reactive programs.
Reference: [24] <author> Launchbury, J., and Peyton Jones, S. L. </author> <title> State in Haskell. </title> <booktitle> Lisp and Symbolic Computation 8 (1995), </booktitle> <pages> 193-341. </pages>
Reference-contexts: Since Haskell bans such expressions, programmers that need this functionality either write low-level routines in C or in an ad hoc variant of Haskell that integrates computational ef-fects with the call-by-need semantics. Recently Launchbury and Peyton Jones <ref> [24] </ref> convincingly argued for the second approach: "Should we outlaw interleaveST on the grounds that it is insufficiently well behaved? Not necessarily. Outlawing interleaveST would simply drive its functionality underground rather than prevent it happening. For example, we want to have lazy file reading. <p> Nevertheless a proof of safety would be interesting. This situation is reminiscent of the use of assignments in the implementation of monadic state without affecting the purity of the source language <ref> [24, 25] </ref>. Third, the debugger can only cope with streams defined at the top level of the program. Thus if we have a large program in which one function uses locally defined streams, we cannot debug the program until these streams are globally defined at the top level.
Reference: [25] <author> Launchbury, J., and Sabry, A. </author> <title> Monadic state: Axiomatization and type safety. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming (1997). </booktitle>
Reference-contexts: However this is no worse than the current intermediate languages of Haskell compilers, like the Glasgow Haskell compiler, that use a call-by-need language with assignments to implement monadic state efficiently. Indeed fi is also unsound in the intermediate language of the compiler for precisely the same reason <ref> [31, 25] </ref>. 7 Abbreviations for one-step contexts: G ::= H j catch [ ] M H ::= ([ ] M ) j [ ] + M j n + [ ] j (x:E [x]) [ ] Axioms: (x:E [x]) V = (x:E [V ]) V n 1 + n 2 = <p> Nevertheless a proof of safety would be interesting. This situation is reminiscent of the use of assignments in the implementation of monadic state without affecting the purity of the source language <ref> [24, 25] </ref>. Third, the debugger can only cope with streams defined at the top level of the program. Thus if we have a large program in which one function uses locally defined streams, we cannot debug the program until these streams are globally defined at the top level.
Reference: [26] <author> Lewerentz, C., and Lindner, T. </author> <title> Formal Development of Reactive Systems: Case Study Production Cell. </title> <booktitle> Lecture Notes in Computer Science 891. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: These properties make algorithmic debugging unsuitable for locating deadlocks in stream computations. 4 Controlling An Elevating Table We present a simplified version of the actual program fragment that spurred the idea of the new debugger. 4.1 The Program cell <ref> [26] </ref>. This fragment is concerned with the implementation of the controller of a simple elevating table and testing it with a simulated hardware environment. The table is initially in a low position. When the controller detects an input blank, it issues an Up command to the motor interface. <p> We will give the precise implementation of the protocols implementing the commands Up and Down. First we formally describe the sets of messages that are required by the specification of the table <ref> [26] </ref>: data MotorCmd = Up | Down data Sensor = Low Bool | High Bool type SensorVector = (Sensor,Sensor) data Actuator = MotorUp | MotorDown | MotorStop | GetStatus The specification of the system requires the existence of two sensors that identify the current location of the table.
Reference: [27] <author> Naish, L., and Barbour, T. </author> <title> Towards a portable lazy functional declarative debugger. </title> <type> Technical Report 95/27, </type> <institution> Department of Computer Science, University of Melbourne, Australia, </institution> <year> 1995. </year>
Reference-contexts: This led researchers to propose declarative debugging as a viable strategy for debugging lazy functional programs <ref> [27, 28, 29] </ref>. One promising declarative debugging technique is algorithmic debugging [30, 33, 34]. Algorithmic debugging is a two phase process. First, the program is run and an execution dependence tree is built. Then, this tree is interactively traversed.
Reference: [28] <author> Nilsson, H. </author> <title> A declarative approach to debugging for lazy functional languages. </title> <type> Licentiate Thesis No. 450, </type> <institution> Department of Computer and Information Science, Linkoping University, </institution> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: This led researchers to propose declarative debugging as a viable strategy for debugging lazy functional programs <ref> [27, 28, 29] </ref>. One promising declarative debugging technique is algorithmic debugging [30, 33, 34]. Algorithmic debugging is a two phase process. First, the program is run and an execution dependence tree is built. Then, this tree is interactively traversed.
Reference: [29] <author> Nilsson, H., and Fritzson, P. </author> <title> Algorithmic debugging for lazy functional languages. </title> <journal> Journal of Functional Programming 4, </journal> <month> 3 (July </month> <year> 1994), </year> <pages> 337-370. </pages>
Reference-contexts: Furthermore, conventional debugging techniques for imperative languages such as setting breakpoints, single-stepping, tracing, and watching variables are not particularly suited for locating deadlocks occurring in lazy functional languages <ref> [15, 16, 29, 33] </ref> or synchronous languages [14]. Indeed our own personal experience in specifying reactive systems in Haskell quickly convinced us of the need for a special-purpose debugging technology specifically tailored towards computations over streams. <p> This led researchers to propose declarative debugging as a viable strategy for debugging lazy functional programs <ref> [27, 28, 29] </ref>. One promising declarative debugging technique is algorithmic debugging [30, 33, 34]. Algorithmic debugging is a two phase process. First, the program is run and an execution dependence tree is built. Then, this tree is interactively traversed.
Reference: [30] <author> Nilsson, H., and Sparud, J. </author> <title> The evaluation dependence tree as a basis for lazy functional debugging. </title> <journal> Journal of Automated Software Engineering 4, </journal> <month> 2 (April </month> <year> 1997), </year> <pages> 152-205. </pages>
Reference-contexts: This led researchers to propose declarative debugging as a viable strategy for debugging lazy functional programs [27, 28, 29]. One promising declarative debugging technique is algorithmic debugging <ref> [30, 33, 34] </ref>. Algorithmic debugging is a two phase process. First, the program is run and an execution dependence tree is built. Then, this tree is interactively traversed. Each node in the tree corresponds to a function call and its result.
Reference: [31] <author> Sabry, A. </author> <title> What is a purely functional language? Unpublished manuscript, </title> <month> April </month> <year> 1997. </year>
Reference-contexts: However this is no worse than the current intermediate languages of Haskell compilers, like the Glasgow Haskell compiler, that use a call-by-need language with assignments to implement monadic state efficiently. Indeed fi is also unsound in the intermediate language of the compiler for precisely the same reason <ref> [31, 25] </ref>. 7 Abbreviations for one-step contexts: G ::= H j catch [ ] M H ::= ([ ] M ) j [ ] + M j n + [ ] j (x:E [x]) [ ] Axioms: (x:E [x]) V = (x:E [V ]) V n 1 + n 2 =
Reference: [32] <author> Sijtsma, B. </author> <title> On the productivity of recursive list definitions. </title> <journal> ACM Transactions on Programming Languages and Systems 11, </journal> <volume> 4 (1989), </volume> <pages> 633-649. </pages>
Reference-contexts: Also Broy et al. [11] use this methodology for the development of various distributed systems. Despite its appeal, programming with streams is quite subtle. A common mistake consists of writing a system of recursive equations over streams whose fixed point is semantically undefined <ref> [32] </ref>. Operationally this error may manifest itself in terms of an obscure error message from the compiler or an equally obscure error message from the run-time system. For example, when suspecting a deadlock, our liveness analysis [22] returns a large (and incomprehensible) list of unsatisfied constraints.
Reference: [33] <author> Sparud, J. </author> <title> A transformational approach to debugging lazy functional programs. </title> <type> Licentiate Thesis, </type> <institution> Department of Computing Science, Chalmers University of Technology, </institution> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: Furthermore, conventional debugging techniques for imperative languages such as setting breakpoints, single-stepping, tracing, and watching variables are not particularly suited for locating deadlocks occurring in lazy functional languages <ref> [15, 16, 29, 33] </ref> or synchronous languages [14]. Indeed our own personal experience in specifying reactive systems in Haskell quickly convinced us of the need for a special-purpose debugging technology specifically tailored towards computations over streams. <p> This led researchers to propose declarative debugging as a viable strategy for debugging lazy functional programs [27, 28, 29]. One promising declarative debugging technique is algorithmic debugging <ref> [30, 33, 34] </ref>. Algorithmic debugging is a two phase process. First, the program is run and an execution dependence tree is built. Then, this tree is interactively traversed. Each node in the tree corresponds to a function call and its result.
Reference: [34] <author> Sparud, J., and Nilsson, H. </author> <title> The architecture of a debugger for lazy functional languages. </title> <booktitle> In Proceedings of AADEBUG '95, 2nd International Workshop on Automated and Algorithmic Debugging (Saint-Malo, </booktitle> <address> France, </address> <month> May </month> <year> 1995), </year> <editor> M. Ducasse, Ed., </editor> <publisher> IRISA, </publisher> <address> Campus Univer-sitaire de Beaulieu, 35042 Rennes, Cedex, France. </address>
Reference-contexts: This led researchers to propose declarative debugging as a viable strategy for debugging lazy functional programs [27, 28, 29]. One promising declarative debugging technique is algorithmic debugging <ref> [30, 33, 34] </ref>. Algorithmic debugging is a two phase process. First, the program is run and an execution dependence tree is built. Then, this tree is interactively traversed. Each node in the tree corresponds to a function call and its result.
Reference: [35] <author> Steele, G. L. </author> <title> Common Lisp|The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year> <month> 9 </month>
Reference-contexts: The intended semantics of throw and catch is the usual one <ref> [35] </ref> adapted to a call-by-need language. Given an expression M , the evaluation of (throw M ) aborts the computation and returns M . The evaluation of (catch M N ) where N is a handler proceeds as follows.
Reference: [36] <author> Wadler, P. </author> <title> Comprehending monads. </title> <booktitle> In ACM Con--ference on Lisp and Functional Programming (1990), </booktitle> <pages> pp. 61-78. </pages>
Reference-contexts: This problem is a general Haskell problem: it is impossible to perform any computational effect (e.g., printing) as a side-effect of evaluating an expression. Instead computational effects must be propagated to the top level either explicitly or by using a monad <ref> [36] </ref>. This is the major limitation of the debugger; we are actively seeking a solution to this problem.
Reference: [37] <author> Wright, A. K., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 91-160, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year> <note> Final version in Information and Computation 115 (1), </note> <year> 1994, </year> <pages> 38-94. 10 </pages>
Reference-contexts: A type judgment ` e : t means that under the assumptions in the type environment , expression e has type t . The typing rules for the functional core are standard. The typing rules for throw and catch are similar to the ones found in SML <ref> [37] </ref> but, for simplicity, we have restricted all thrown expressions to be of type Int. If typechecking guarantees anything, it is that some obviously faulty terms are not typable.
References-found: 37

