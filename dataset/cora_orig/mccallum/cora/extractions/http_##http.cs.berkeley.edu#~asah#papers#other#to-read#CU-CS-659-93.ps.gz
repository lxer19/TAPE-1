URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/CU-CS-659-93.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: Garbage Collection using a Dynamic Threatening Boundary  
Author: David A. Barrett and Benjamin G. Zorn 
Date: July 1993  
Address: Campus Box #430  Boulder 80309-0430  Boulder  
Affiliation: Department of Computer Science  University of Colorado,  ffi University of Colorado at  
Pubnum: CU-CS-659-93  
Abstract: Technical Report CU-CS-659-93 Department of Computer Science Campus Box 430 University of Colorado Boulder, Colorado 80309 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Apple Computer Inc. </author> <title> Macintosh Common Lisp Reference, </title> <note> version 2 edition, </note> <year> 1992. </year> <pages> pages 631-637. </pages>
Reference-contexts: The success of generational collection algorithms is evinced by their frequent use in language environments that require automatic storage reclamation <ref> [7, 1, 9, 4] </ref>. Despite their success, generational collectors must be tuned for applications that use memory differently than anticipated by the collector's designer. <p> The selection criteria for these sets distinguishes various collection algorithms. Consider how a traditional generational collector selects its threatened and immune sets. The threatened set contains those objects that have survived fewer than a specified number of collections|typically one or two <ref> [16, 1, 7] </ref>. The root objects and all objects in older generations are immune. The threatening boundary divides the young threatened objects from the old immune objects.
Reference: [2] <author> Thomas Ball and James R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: constrained arbitrarily and the same techniques used to implement multiple generations for other collectors apply to ours (e.g., Caudill's Smalltalk-80 implementation [5]). 5 Methods In order to determine the effectiveness of the dynamic threatening boundary collector, we instrumented a set of four allocation-intensive C programs using Larus' trace generator QPT <ref> [11, 2] </ref>. The programs are described in detail in Tables 5 and 6 in Appendix A. We used memory allocation and deallocation events in these programs to drive a simulation of the different garbage collection algorithms.
Reference: [3] <author> David Barrett and Benjamin Zorn. </author> <title> Using lifetime predictors to improve memory allocation performance. </title> <booktitle> In ACM SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 187-196, </pages> <address> Albuquerque, New Mexico, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Generational garbage collection algorithms provide a partial solution to these performance problems. By making use of the observation that most dynamically allocated objects cease to be used very shortly after their creation <ref> [16, 8, 17, 3] </ref>, generational collectors reduce pause times by reclaiming storage for recently allocated objects more often than older objects. The success of generational collection algorithms is evinced by their frequent use in language environments that require automatic storage reclamation [7, 1, 9, 4].
Reference: [4] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In ACM SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <month> June </month> <year> 1991. </year> <institution> Toronto, </institution> <address> Ontario, Canada. </address>
Reference-contexts: The success of generational collection algorithms is evinced by their frequent use in language environments that require automatic storage reclamation <ref> [7, 1, 9, 4] </ref>. Despite their success, generational collectors must be tuned for applications that use memory differently than anticipated by the collector's designer. <p> Finally, we conclude with some observations about how these results may be used to improve future garbage collection technology. 2 Related Work Generational algorithms [12, 14, 13] have proven successful at reducing the pause times and page fault rate of garbage collection <ref> [4, 6, 14] </ref>. Our work is based upon a formalization developed by Demers et al [6]. Their generational Collector II used a threatening boundary to divide memory into a threatened space for new objects, and an immune space for old objects, which were collected less frequently.
Reference: [5] <author> Patrick Caudill and Allen Wirfs-Brock. </author> <title> A third generation Smalltalk-80 implementation. </title> <editor> In Normam Meyrowitz, editor, </editor> <booktitle> OOPSLA'86 Conference Proceedings, </booktitle> <pages> pages 119-130, </pages> <address> Portland, OR, </address> <month> September </month> <year> 1986. </year> <note> ACM. </note>
Reference-contexts: If less precision is desired, (e.g., to maintain the write barrier using virtual memory) ages can be constrained arbitrarily and the same techniques used to implement multiple generations for other collectors apply to ours (e.g., Caudill's Smalltalk-80 implementation <ref> [5] </ref>). 5 Methods In order to determine the effectiveness of the dynamic threatening boundary collector, we instrumented a set of four allocation-intensive C programs using Larus' trace generator QPT [11, 2]. The programs are described in detail in Tables 5 and 6 in Appendix A.
Reference: [6] <author> Alan Demers, Mark Weiser, Barry Hayes, Hans Boehm, Daniel Bobrow, and Scott Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Conference Record of the Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Finally, we conclude with some observations about how these results may be used to improve future garbage collection technology. 2 Related Work Generational algorithms [12, 14, 13] have proven successful at reducing the pause times and page fault rate of garbage collection <ref> [4, 6, 14] </ref>. Our work is based upon a formalization developed by Demers et al [6]. Their generational Collector II used a threatening boundary to divide memory into a threatened space for new objects, and an immune space for old objects, which were collected less frequently. <p> Our work is based upon a formalization developed by Demers et al <ref> [6] </ref>. Their generational Collector II used a threatening boundary to divide memory into a threatened space for new objects, and an immune space for old objects, which were collected less frequently. <p> Only the application programmer (or worse, the user) can identify these specific cases, and then he or she must learn about all the policy decisions described in the previous paragraph in order adjust each tuning parameter appropriately for their application. 1 4 A Dynamic Threating Boundary Collector Demers et al <ref> [6] </ref> have provided a useful formal framework for modeling generational garbage collection algorithms. As mentioned, their model partitions the object space into threatened and immune sets. Threatened objects are those that the collector traces to find unreachable objects and reclaim them. <p> Unlike previous work, our collector can arbitrarily select the boundary between these two spaces in order to directly meet the resource constraints specified by the user. Based on the formal framework defined by Demers et al <ref> [6] </ref>, we have shown how a dynamic threatening boundary collector can be used to meet a user-specified maximum memory or median pause-time constraint. Using trace-driven simulation we compared the two variants of the dynamic threatening boundary algorithm with existing algorithms, including Ungar and Jackson's Feedback Mediation [15].
Reference: [7] <author> Franz Inc. </author> <title> Allegro CL User Guide, </title> <note> Version 4.1, revision 2 edition, </note> <month> March </month> <year> 1992. </year> <title> Chapter 15: Garbage Collection. </title>
Reference-contexts: The success of generational collection algorithms is evinced by their frequent use in language environments that require automatic storage reclamation <ref> [7, 1, 9, 4] </ref>. Despite their success, generational collectors must be tuned for applications that use memory differently than anticipated by the collector's designer. <p> The selection criteria for these sets distinguishes various collection algorithms. Consider how a traditional generational collector selects its threatened and immune sets. The threatened set contains those objects that have survived fewer than a specified number of collections|typically one or two <ref> [16, 1, 7] </ref>. The root objects and all objects in older generations are immune. The threatening boundary divides the young threatened objects from the old immune objects. <p> Scavenging the mth older generation corresponds to temporarily choosing a threatening boundary to the age corresponding 1 One LISP manual <ref> [7] </ref> uses 27 pages to describe how to use various tuning parameters such as: auto-step, newspace, oldspace initial oldspace, current-generation, tenure-limit, generation-spread, free-bytes-new-pages, free-percent-new, quantum, tenure, and tenured-bytes-limit. 6 to a the mth previous generation boundary. Generation boundaries simply constrain the set of allowable threatening boundaries.
Reference: [8] <author> Barry Hayes. </author> <title> Using key object opportunism to collect old objects. </title> <booktitle> In ACM SIGPLAN 1991 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '91), </booktitle> <pages> pages 33-46, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: Generational garbage collection algorithms provide a partial solution to these performance problems. By making use of the observation that most dynamically allocated objects cease to be used very shortly after their creation <ref> [16, 8, 17, 3] </ref>, generational collectors reduce pause times by reclaiming storage for recently allocated objects more often than older objects. The success of generational collection algorithms is evinced by their frequent use in language environments that require automatic storage reclamation [7, 1, 9, 4]. <p> When age is not a reliable indicator of garbage other methods must be used. Hudson and Moss [10] describe a Mature Object Space that is collected incrementally based upon object connectivity rather than age. Likewise, Hayes <ref> [8] </ref> showed that when certain Key Objects die, they may indicate other unused ones as well.
Reference: [9] <author> Antony L. Hosking, J. Eliot B. Moss, and Darko Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In ACM SIGPLAN 1992 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '92), </booktitle> <pages> pages 92-109, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: The success of generational collection algorithms is evinced by their frequent use in language environments that require automatic storage reclamation <ref> [7, 1, 9, 4] </ref>. Despite their success, generational collectors must be tuned for applications that use memory differently than anticipated by the collector's designer.
Reference: [10] <author> Richard L. Hudson and J. Eliot B. Moss. </author> <title> Incremental collection of mature objects. </title> <booktitle> In Proceedings of the International Workshop on Memory Management, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag Lecture Notes in Computer Science vol. 637. </note>
Reference-contexts: Like generational collection, our algorithm uses age as an indicator of when objects are most likely to die. When age is not a reliable indicator of garbage other methods must be used. Hudson and Moss <ref> [10] </ref> describe a Mature Object Space that is collected incrementally based upon object connectivity rather than age. Likewise, Hayes [8] showed that when certain Key Objects die, they may indicate other unused ones as well.
Reference: [11] <author> Jamer R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <type> Technical Report 1083, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <address> 1210 West Dayton Street, Madison, WI 53706 USA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: constrained arbitrarily and the same techniques used to implement multiple generations for other collectors apply to ours (e.g., Caudill's Smalltalk-80 implementation [5]). 5 Methods In order to determine the effectiveness of the dynamic threatening boundary collector, we instrumented a set of four allocation-intensive C programs using Larus' trace generator QPT <ref> [11, 2] </ref>. The programs are described in detail in Tables 5 and 6 in Appendix A. We used memory allocation and deallocation events in these programs to drive a simulation of the different garbage collection algorithms.
Reference: [12] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Then, after discussing simulation methods, we present performance comparisons against other algorithms and show how well our algorithm met imposed resource constraints. Finally, we conclude with some observations about how these results may be used to improve future garbage collection technology. 2 Related Work Generational algorithms <ref> [12, 14, 13] </ref> have proven successful at reducing the pause times and page fault rate of garbage collection [4, 6, 14]. Our work is based upon a formalization developed by Demers et al [6].
Reference: [13] <author> David A. Moon. </author> <title> Garbage collection in a large Lisp system. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 235-246, </pages> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: Then, after discussing simulation methods, we present performance comparisons against other algorithms and show how well our algorithm met imposed resource constraints. Finally, we conclude with some observations about how these results may be used to improve future garbage collection technology. 2 Related Work Generational algorithms <ref> [12, 14, 13] </ref> have proven successful at reducing the pause times and page fault rate of garbage collection [4, 6, 14]. Our work is based upon a formalization developed by Demers et al [6].
Reference: [14] <author> David Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In SIGSOFT/SIGPLAN Practical Programming Environments Conference, </booktitle> <pages> pages 157-167, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Then, after discussing simulation methods, we present performance comparisons against other algorithms and show how well our algorithm met imposed resource constraints. Finally, we conclude with some observations about how these results may be used to improve future garbage collection technology. 2 Related Work Generational algorithms <ref> [12, 14, 13] </ref> have proven successful at reducing the pause times and page fault rate of garbage collection [4, 6, 14]. Our work is based upon a formalization developed by Demers et al [6]. <p> Finally, we conclude with some observations about how these results may be used to improve future garbage collection technology. 2 Related Work Generational algorithms [12, 14, 13] have proven successful at reducing the pause times and page fault rate of garbage collection <ref> [4, 6, 14] </ref>. Our work is based upon a formalization developed by Demers et al [6]. Their generational Collector II used a threatening boundary to divide memory into a threatened space for new objects, and an immune space for old objects, which were collected less frequently.
Reference: [15] <author> David Ungar and Frank Jackson. </author> <title> An adaptive tenuring policy for generation scavengers. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(1) </volume> <pages> 1-27, </pages> <month> January </month> <year> 1992. </year> <month> 19 </month>
Reference-contexts: One important policy for all generational collectors is when to promote objects from threatened space to immune space. Typically objects are promoted only after a fixed number of collections, specified as one of the tuning parameters made available to the application programmer. Ungar and Jackson <ref> [15] </ref> found that object lifetime distributions vary from one program to the next and often change as a program executes, showing that a fixed-age promotion policy will often be inappropriate. Instead, their Feedback Mediation collector promoted a number of objects only when a pause-time constraint was exceeded. <p> These simulation parameters were selected because they approximate those used by Ungar and Jackson to measure their Feedback Mediation collector <ref> [15] </ref>. Scavenges 12 were triggered after every 1 million bytes of allocation. The maximum pause-time was set to 100 milliseconds (50 thousand bytes traced) and the maximum memory constraint for DtbMem was 3000 kilobytes. <p> Using trace-driven simulation we compared the two variants of the dynamic threatening boundary algorithm with existing algorithms, including Ungar and Jackson's Feedback Mediation <ref> [15] </ref>. We also show how the other algorithms we considered fit easily into the general dynamic threatening boundary framework. Our results show that our memory-constrained threatening boundary algorithm meets the user-imposed memory constraint and uses available memory to reduce CPU overhead.
Reference: [16] <author> Paul R. Wilson and Thomas G. Moher. </author> <title> Design of the opportunistic garbage collector. </title> <booktitle> In ACM SIGPLAN 1989 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '89), </booktitle> <pages> pages 23-35, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Generational garbage collection algorithms provide a partial solution to these performance problems. By making use of the observation that most dynamically allocated objects cease to be used very shortly after their creation <ref> [16, 8, 17, 3] </ref>, generational collectors reduce pause times by reclaiming storage for recently allocated objects more often than older objects. The success of generational collection algorithms is evinced by their frequent use in language environments that require automatic storage reclamation [7, 1, 9, 4]. <p> Unlike their algorithm, ours reduces tenured garbage by allowing objects to be demoted back into threatened space later when the pause-time falls. Additionally, we allow a memory-constraint policy to be used instead if the user so desires. Wilson and Moher's Opportunistic Collector <ref> [16] </ref> allocates objects created since the last collection in chronological order in memory. By selecting an appropriate address, only objects allocated since a specific time may be selected for promotion. <p> The selection criteria for these sets distinguishes various collection algorithms. Consider how a traditional generational collector selects its threatened and immune sets. The threatened set contains those objects that have survived fewer than a specified number of collections|typically one or two <ref> [16, 1, 7] </ref>. The root objects and all objects in older generations are immune. The threatening boundary divides the young threatened objects from the old immune objects.
Reference: [17] <author> Benjamin Zorn and Dirk Grunwald. </author> <title> Empirical measurements of six allocation-intensive C programs. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(12) </volume> <pages> 71-80, </pages> <month> December </month> <year> 1992. </year> <month> 20 </month>
Reference-contexts: Generational garbage collection algorithms provide a partial solution to these performance problems. By making use of the observation that most dynamically allocated objects cease to be used very shortly after their creation <ref> [16, 8, 17, 3] </ref>, generational collectors reduce pause times by reclaiming storage for recently allocated objects more often than older objects. The success of generational collection algorithms is evinced by their frequent use in language environments that require automatic storage reclamation [7, 1, 9, 4].
References-found: 17

