URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1997/GIT-CC-97-33.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.97.html
Root-URL: 
Phone: 2  
Title: Future Branches Beyond Speculative Execution  
Author: Bill Appelbe Raja Das and Reid Harmon 
Address: RMIT, Melbourne, Victoria 3001, Australia  Atlanta, GA 30327, USA  
Affiliation: 1 Department of Computer Science,  College of Computing, Georgia Institute of Technology  
Abstract: Speculative execution of conditional branches has a high hardware cost, is limited by dynamic branch prediction accuracies, and does not scale well for increasingly superscalar architectures. Future branches are additional branch instructions that overcome the performance bottleneck of conventional branches. Future branch instructions includes a branch source address (the location of the impending conditional branch) as well as the branch target. The branch actually occurs when the program counter reaches the source address. If a future branch is executed before instruction fetching reaches the branch source, then there are no pipeline stalls or prediction necessary. Benchmark micro-architecture simulation studies show that at high su- perscalarities, losses to speculative execution consistently are higher than 10%, and these losses can be avoided by future branches. In addition, a hardware implementation of future branches for the PowerPC 604 has a very modest cost.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bill Appelbe, Reid Harmon, Phil May, Scott Wills, and Maurizio Vitale. </author> <title> Hoisting branch conditions improving super-scalar processor performance. </title> <booktitle> In Eighth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <year> 1995. </year>
Reference-contexts: Future branches allows a branch condition to be evaluated anywhere in a program, subject to just two constraints: Data and control dependencies must be preserved (using program transfor <p>- mations such as code hoisting for the branch condition <ref> [1] </ref>) Future branches for the same source address must be executed in order The remainder of this paper gives performance results for future branch instructions, followed by an outline of an architecture definition for future branch instructions, and hardware design for incorporation in the PowerPC 604. 2 Simulation Studies Determining the <p> The extra instructions are needed because the inner condition loop condition is a recurrence 7 . 5 It is not very difficult to construct a pathological case in which no branch can be hoisted, as all the computation in a routine is devoted to determining a branch outcome <ref> [1] </ref>.
Reference: 2. <author> M. Bekerman and A. Mendelson. </author> <title> A Performance Analysis of Pentium Processor Systems. </title> <journal> IEEE Micro, </journal> <volume> 15(5) </volume> <pages> 72-83, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Performance analysis of the Pentium (at most two-way superscalar, but with sophisticated branch prediction), show that on several of the SPEC benchmarks the overhead of incorrect branch prediction is between 5% and 8% of overall execution time <ref> [2] </ref>. Research continues into more sophisticated mechanisms for using branch histories to improve branch predic-tion accuracy, but gains tend to be slight [6] and increase hardware costs further.
Reference: 3. <author> Sreeram Duvvuru and Siamak Arya. </author> <title> Evaluation of a Branch Target Address Cache. </title>
Reference: 4. <author> J. R. Goodman, J. T. Hseih, K. Liou, A. R. Pleszkun, P.B. Schechter, and H. C. Young. </author> <title> Pipe: A vlsi decoupled architecture. </title> <booktitle> In Proceedings of The Twelfth Annual Symposium on Computer Architecture, </booktitle> <pages> pages 20-27, </pages> <year> 1989. </year>
Reference-contexts: Decoupling the branch decision from the branch itself has been used in many architectures, ranging from those which have separate instructions for computing the branch condition to branch instructions with a variable number of delay slots <ref> [4] </ref>. However, these have the limitation that the computation of a branch condition (direction) and the branch itself must be close together. This usually limits placing the instructions that evaluate the branch condition in the same basic block as the branch instruction itself.
Reference: 5. <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: Instead of a hardware implementation, we extended a micro- architecture simulator, and have incorporated algorithms for generating future branches into a compiler toolkit called GiL based upon gcc. Future branches can be added to almost any instruction set architecture. For the simulation studies we used the DLX instruction-set <ref> [5] </ref>, as we had access to a reconfigurable micro-architecture simulator for DLX, SuperDLX from McGill university.
Reference: 6. <author> Stuart Sechrest, Chih-Chieh Lee, and Trevor Mudge. </author> <title> Correlation and aliasing in dynamic branch predictors. </title> <booktitle> In Proceedings of The 23nd Annual Symposium on Computer Architecture, </booktitle> <pages> pages 22-31, </pages> <year> 1996. </year>
Reference-contexts: Research continues into more sophisticated mechanisms for using branch histories to improve branch predic-tion accuracy, but gains tend to be slight <ref> [6] </ref> and increase hardware costs further. Aside from its high hardware cost and imprecision, another fundamental problem with speculative execution is that it does not scale well with increasingly superscalar processors.
Reference: 7. <author> Motorola Semiconductor Products Sector. </author> <title> MC88110 Second Generation RISC Microprocessor Users Manual. Motorola, </title> <publisher> Inc., </publisher> <address> Phoenix, Arizona, </address> <year> 1991. </year>
Reference-contexts: We have also designed future branches for the Motorola 88110 instruction set <ref> [7] </ref>. The PowerPC instruction set supports four different branch instructions [12] [8] including unconditional branch b, branch conditional bc, branch conditional to counter register bcctr, and branch conditional to link register bclr.
Reference: 8. <author> Motorola Semiconductor Products Sector. </author> <title> PowerPC 601 RISC Processor Users Manual. Motorola, </title> <publisher> Inc., </publisher> <address> Phoenix, Arizona, </address> <year> 1993. </year>
Reference-contexts: We have also designed future branches for the Motorola 88110 instruction set [7]. The PowerPC instruction set supports four different branch instructions [12] <ref> [8] </ref> including unconditional branch b, branch conditional bc, branch conditional to counter register bcctr, and branch conditional to link register bclr. <p> The major differences are the lack of the AA and LK fields, the 7-bit source field, and a reduced width Target field (BD in the PowerPC bc instruction). The BO (branch condition) and BI (condition register bit index) fields are identical to the PowerPC bc instruction [12] <ref> [8] </ref>. These two fields determine the branch predicate. The Source field encodes the relative distance to the corresponding bc instruction as did the Source field in the fb instruction.
Reference: 9. <author> S. Peter Song and Marvin Denman. </author> <title> The PowerPC 604 Microprocessor. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 8-17, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Branch caches enable the branch target address and subsequent instructions to be determined with high probability at a modest hardware cost <ref> [9] </ref>. By contrast, determining the direction of a conditional branch with high probability is far more difficult. Most modern superscalar processors use speculative execution, in which the direction of the branch is predicted dynamically using a history of previous branch directions. <p> Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracies around 90% for non-scientific applications (e.g., Ultra SPARC [11]: SPECint 88%, SPECfloat 94% [11]; Power 620 <ref> [9] </ref>: SPEC composite 90%). Performance analysis of the Pentium (at most two-way superscalar, but with sophisticated branch prediction), show that on several of the SPEC benchmarks the overhead of incorrect branch prediction is between 5% and 8% of overall execution time [2]. <p> is in case the execution of the program has proceeded more than 64 instructions from the future branch source instruction when the ufb instruction is encountered. 4 Future Branch Hardware Implementation The implementation of the future branch hardware is based on the hardware used in the Power PC 604 processor <ref> [9] </ref>. Thus our implementation of future branches for the PowerPC instruction set tries to exploit the existing 604 hardware rather than modifying it extensively. <p> This implementation was simply chosen as a reference point. Further details of the implementation are available from ftp://ftp.cc.gatech.edu/pub/people/bill/papers/fb-hardware.ps. 4.1 PowerPC 604 Instruction Pipeline The PowerPC 604 pipeline <ref> [9] </ref> was used in developing the future branch hardware implementation. Figure 3 shows the 604 pipeline and what future branch processing occurs at each stage. The following list identifies the future branch processing that takes place at each stage in the processor pipeline. <p> We estimate that these transistors would occupy 6.5 mm 2 using a .5 micron process. Using data on the 604 die <ref> [9] </ref> size (approximately 196 mm 2 , our future branch implementation would use an additional 3.3% of the existing 604 die area.
Reference: 10. <author> Tom Thompson and Bob Ryan. </author> <title> PowerPC 620 Soars. </title> <journal> BYTE, </journal> <pages> pages 113-120, </pages> <month> November </month> <year> 1994. </year>
Reference: 11. <author> Peter Wayner. </author> <title> SPARC Strikes Back. </title> <journal> BYTE, </journal> <pages> pages 105-112, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Most modern superscalar processors use speculative execution, in which the direction of the branch is predicted dynamically using a history of previous branch directions. Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracies around 90% for non-scientific applications (e.g., Ultra SPARC <ref> [11] </ref>: SPECint 88%, SPECfloat 94% [11]; Power 620 [9]: SPEC composite 90%). Performance analysis of the Pentium (at most two-way superscalar, but with sophisticated branch prediction), show that on several of the SPEC benchmarks the overhead of incorrect branch prediction is between 5% and 8% of overall execution time [2]. <p> Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracies around 90% for non-scientific applications (e.g., Ultra SPARC <ref> [11] </ref>: SPECint 88%, SPECfloat 94% [11]; Power 620 [9]: SPEC composite 90%). Performance analysis of the Pentium (at most two-way superscalar, but with sophisticated branch prediction), show that on several of the SPEC benchmarks the overhead of incorrect branch prediction is between 5% and 8% of overall execution time [2].
Reference: 12. <author> Shlomo Weiss and James E. Smith. </author> <title> POWER and PowerPC. </title> <publisher> Morgan Kauffman, </publisher> <address> San Francisco, California, </address> <year> 1994. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: We have also designed future branches for the Motorola 88110 instruction set [7]. The PowerPC instruction set supports four different branch instructions <ref> [12] </ref> [8] including unconditional branch b, branch conditional bc, branch conditional to counter register bcctr, and branch conditional to link register bclr. <p> The major differences are the lack of the AA and LK fields, the 7-bit source field, and a reduced width Target field (BD in the PowerPC bc instruction). The BO (branch condition) and BI (condition register bit index) fields are identical to the PowerPC bc instruction <ref> [12] </ref> [8]. These two fields determine the branch predicate. The Source field encodes the relative distance to the corresponding bc instruction as did the Source field in the fb instruction.
References-found: 12

