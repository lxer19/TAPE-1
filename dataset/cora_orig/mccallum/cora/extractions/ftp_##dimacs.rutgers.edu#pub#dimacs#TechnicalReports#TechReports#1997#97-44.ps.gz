URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1997/97-44.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1997.html
Root-URL: http://www.cs.rutgers.edu
Title: Practical Algorithms for Polycyclic Matrix Groups  
Author: by Gretchen Ostheimer 
Note: DIMACS is a partnership of Rutgers University, Princeton University, AT&T Labs, Bellcore, and Bell Labs. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Address: Medford, MA 02155  
Affiliation: Dept. of Mathematics Tufts University  
Abstract: DIMACS Technical Report 97-44 September 1997 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Laszlo Babai, Robert Beals, Jin yi Cai, Gabor Ivanyos, and Eugene M. Luks. </author> <title> Multiplicative equations over commuting matrices. </title> <booktitle> In Proc. 3rd ACM-SIAM SODA (Symp. on Discrete Algorithms), </booktitle> <year> 1996. </year> <note> to appear. </note>
Reference-contexts: As with subgroups of Tr 1 (n; Z), if G is also abelian, then we can make our membership test constructive, and we can find a presentation for G. Alternative methods for working with abelian subgroups of Tr 1 (n; Q) are described in <ref> [1] </ref>. 2.4 Abelian groups The following proposition indicates how the problem of finding presentations for finitely generated abelian groups can be reduced to the corresponding problems for abelian groups embedded in fields and finitely generated abelian unitriangular groups. Proposition 2.3 Let G be an abelian subgroup of GL (n; R). <p> It is clear that these algorithms in [2] are not practical, even for simple examples. Algorithms for testing membership in an abelian subgroup of GL (n; R), as well as algorithms to find a presentation for such a group, were discovered independently by the author and <ref> [1] </ref>. The algorithm in [1] is proved to have a run-time which is polynomial in the length of the input. <p> Algorithms for testing membership in an abelian subgroup of GL (n; R), as well as algorithms to find a presentation for such a group, were discovered independently by the author and <ref> [1] </ref>. The algorithm in [1] is proved to have a run-time which is polynomial in the length of the input. <p> In [3] the work in <ref> [1] </ref> concerning abelian matrix groups is extended to the case of abelian-by-finite matrix groups. In this paper, we described two algorithms for testing membership in a polycyclic-by-finite subgroup of GL (n; R), one of which relies on these abelian-by-finite results and the other of which does not.
Reference: [2] <author> Gilbert Baumslag, Frank B. Cannonito, Derek J. S. Robinson, and Dan Segal. </author> <title> The algorithmic theory of polycyclic-by-finite groups. </title> <journal> J. Algebra, </journal> <volume> 142 </volume> <pages> 118-149, </pages> <year> 1991. </year>
Reference-contexts: A subgroup of GL (n; Z) is solvable if and only if it is poly-cyclic, so in GL (n; Z) we can also decide whether or not a given group is polycyclic-by-finite. In <ref> [2] </ref> many fundamental and useful problems concerning polycyclic matrix groups, including all of the problems discussed in this paper, are proved to be decidable. Many of the algorithms in [2] are not suitable for computer implementation as that was not the goal of that paper (Section 3). <p> In <ref> [2] </ref> many fundamental and useful problems concerning polycyclic matrix groups, including all of the problems discussed in this paper, are proved to be decidable. Many of the algorithms in [2] are not suitable for computer implementation as that was not the goal of that paper (Section 3). On the other hand, the algorithms in this paper are suitable for computer implementation. <p> Use the algorithm in [3] to decide whether or not (a) 2 (G), and, if so, to find a g 2 G such that (a) = (g). Then a 2 G if and only if ag 1 2 H. 3 Related Work In <ref> [2] </ref> many fundamental and useful problems concerning polycyclic matrix groups, including all of the problems discussed in this paper, are proved to be decidable. Many of the algorithms in [2] are not suitable for computer implementation as that was not the goal of that paper. <p> Then a 2 G if and only if ag 1 2 H. 3 Related Work In <ref> [2] </ref> many fundamental and useful problems concerning polycyclic matrix groups, including all of the problems discussed in this paper, are proved to be decidable. Many of the algorithms in [2] are not suitable for computer implementation as that was not the goal of that paper. On the other hand, as will be shown in the Section 4, the algorithms in this paper are suitable for computer implementation. We will not describe the algorithms in [2] completely here, but we will <p> Many of the algorithms in <ref> [2] </ref> are not suitable for computer implementation as that was not the goal of that paper. On the other hand, as will be shown in the Section 4, the algorithms in this paper are suitable for computer implementation. We will not describe the algorithms in [2] completely here, but we will highlight several particularly inefficient steps in order to contrast them with the algorithms in Section 2. Suppose that G is a polycyclic-by-finite matrix group. In [2] an algorithm is given to decide whether or not a given matrix a is an element of G. <p> We will not describe the algorithms in <ref> [2] </ref> completely here, but we will highlight several particularly inefficient steps in order to contrast them with the algorithms in Section 2. Suppose that G is a polycyclic-by-finite matrix group. In [2] an algorithm is given to decide whether or not a given matrix a is an element of G. If m is a positive integer, let m be the map from GL (n; Z) to GL (n; Z=mZ). <p> If a is not an element of G, then there exists an m such that m (a) is not an element of m (G) (Theorem 5 in Chapter 5 of [19]). In <ref> [2] </ref>, the authors verify that a is not an element of G by simply trying all positive integers m, testing whether or not m (a) is an element of m (G), and stopping if it is not. <p> They verify that a is an element of G by enumerating the elements of G, stopping if a is found. These two procedures are then run in parallel. Eventually one of them stops, and then it is known whether or not a 2 G. The algorithm in <ref> [2] </ref> to decide whether or not a given matrix group is polycyclic-by-finite relies on this algorithm for testing membership in such a group. In [2] an algorithm is given to verify that G is triangularizable. <p> Eventually one of them stops, and then it is known whether or not a 2 G. The algorithm in <ref> [2] </ref> to decide whether or not a given matrix group is polycyclic-by-finite relies on this algorithm for testing membership in such a group. In [2] an algorithm is given to verify that G is triangularizable. This algorithm enumerates the algebraic number fields F and enumerates for each F the n fi n nonsingular matrices p over F , testing whether or not p 1 Gp is upper-triangular, stopping if this is the case. <p> The unipotent part of G is then found by triangulating the matrices in H over F . Note that one might have to consider number fields F whose degree over Q is as much as n!. It is clear that these algorithms in <ref> [2] </ref> are not practical, even for simple examples. Algorithms for testing membership in an abelian subgroup of GL (n; R), as well as algorithms to find a presentation for such a group, were discovered independently by the author and [1].
Reference: [3] <author> Robert Beals. </author> <title> Towards polynomial time algorithms for matrix groups. </title> <booktitle> In DIMACS Series in Discrete Mathematics and Computer Science, </booktitle> <volume> volume 28, </volume> <pages> pages 31-54, </pages> <year> 1997. </year>
Reference-contexts: such fundamental problems as the membership problem: given a finite set X of n fi n invertible matrices and given another such matrix a, decide whether or not a is an element of the group generated by X under multiplication. (For polynomial-time algorithms for finite matrix groups, see [15] and <ref> [3] </ref>, for example.) When we pass to infinite matrix groups, this same question becomes undecidable [16]. Therefore, when studying infinite matrix groups it makes sense to restrict our attention somewhat. It is natural to consider the class of polycyclic groups | solvable groups in which every subgroup is finitely generated. <p> This approach might be particularly efficient in the case when G is polycyclic, since then we can use algorithms developed for working with solvable matrix groups over finite fields. (See [15].) The second algorithm for deciding whether or not a 2 G relies on the algorithms in <ref> [3] </ref> for working with abelian-by-finite matrix groups as well as the algorithm in Section 2.3 for testing membership in a unitriangular matrix group. Recall that K /G, jG : Kj &lt; 1, and K is triangularizable. <p> Use the algorithm in <ref> [3] </ref> to find a presentation for (G), and from that obtain a set fh 1 ; : : : ; h l g of normal generators for H. Let f H = hh 1 ; : : : ; h l i. <p> Use the algorithm in <ref> [3] </ref> to decide whether or not (a) 2 (G), and, if so, to find a g 2 G such that (a) = (g). <p> While that algorithm is in some respects similar to the one presented here, the method for testing membership in a matrix group which is both unipotent and abelian is quite different since the algorithm described in this paper works for all finitely generated unipotent groups. In <ref> [3] </ref> an algorithm is given for deciding whether or not a given finitely generated subgroup of GL (n; R) is solvable-by-finite. The author proves that the run-time of his algorithm is polynomial in the length of input; the practicality of the algorithm has not been tested. <p> The author proves that the run-time of his algorithm is polynomial in the length of input; the practicality of the algorithm has not been tested. We described in Section 2.8 a practical alternative to the algorithm in <ref> [3] </ref>. As we saw in Sections 2.8 and 2.9, our algorithms for solvable-by-finite matrix groups rely on the observation in [7] that solvable-by-finite subgroups of the p-congruence subgroup of GL (n; Z p ) are triangularizable for p an odd prime. <p> In <ref> [3] </ref> the work in [1] concerning abelian matrix groups is extended to the case of abelian-by-finite matrix groups.
Reference: [4] <author> Johannes Buchmann and Michael Pohst. </author> <title> Computing a lattice basis from a system of generating vectors. </title> <booktitle> In EUROCAL '87, Lecture Notes in Comput. Sci., </booktitle> <volume> volume 378, </volume> <pages> pages 54-63. </pages> <publisher> Springer, </publisher> <year> 1989. </year>
Reference-contexts: An algorithm for finding generators for K is described in <ref> [4] </ref>. The algorithm requires as input a lower bound M for the length of the shortest nonzero vector in L. <p> Let fff 1 ; : : : ; ff d g be the algebraic conjugates of ff. If d Y maxf1; jff j jg 1 + 1 log d ; then ff is a root of unity. The run-time of the algorithm in <ref> [4] </ref> is polynomial in s + k and the size of the input data. The authors illustrate the practicality of their algorithm by finding (for real quartic fields with discriminants below 100000) a multiplicative relation between four given units. <p> Let L be the image of this map, a lattice in a hyperplane of R s . The algorithm in <ref> [4] </ref> was used to find a presentation for (H) and hence for H; the algorithm requires as input a lower bound for the length of a nonzero vector in L. <p> In these experiments, the fields in question were of low degree; therefore, I computed the lower bound using the fundamental units for each of the - 19 - fields F 1 ; : : : ; F r . I then followed the <ref> [4] </ref> algorithm closely. In each of the seven experiments, the [4] algorithm showed that a 4 was not an element of the group and it produced three unitriangular elements b 1 ; b 2 ; b 3 such that a i 2 G if and only if b i 2 U <p> I then followed the <ref> [4] </ref> algorithm closely. In each of the seven experiments, the [4] algorithm showed that a 4 was not an element of the group and it produced three unitriangular elements b 1 ; b 2 ; b 3 such that a i 2 G if and only if b i 2 U , where U was the unipotent part of G.
Reference: [5] <author> Henri Cohen. </author> <title> A Course in Computational Algebraic Number Theory. </title> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The image of G under is a lattice L in a hyperplane of R s . (See Theorem 4.9.7 of <ref> [5] </ref>.) Let K be the subgroup of Z k consisting of elements x such that (g x ) = 1. An algorithm for finding generators for K is described in [4]. The algorithm requires as input a lower bound M for the length of the shortest nonzero vector in L. <p> If A is a low degree extension of Q, then accurate bounds on the length of a shortest nonzero vector can be obtained by finding a system of fundamental units for the group of units for O A . (See Section 6.5 of <ref> [5] </ref>.) When this is impractical, the following lemma from [8] can be used to obtain a lower bound. Lemma 2.1 Let ff be a nonzero algebraic integer of degree d. Let fff 1 ; : : : ; ff d g be the algebraic conjugates of ff. <p> To create examples of such abelian groups, I used the tables in <ref> [5] </ref> describing over 200 number fields of degree two or three.
Reference: [6] <author> John D. Dixon. </author> <title> The Structure of Linear Groups. </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1971. </year>
Reference-contexts: If H is a subgroup of C, and H is solvable-by-finite, then H is triangularizable (over Q p ). Proof. In [7] Dixon shows that H is connected in the Zariski topology of M (n; Q p ). By the Lie-Kolchin theorem (as stated in Lemma 8.6 of <ref> [6] </ref>), H is triangularizable over Q p . * 2 Algorithms for Matrix Groups In this section we develop a suite of algorithms for studying polycyclic-by-finite matrix groups. We will start by considering two special cases, abelian groups (Sections 2.1 and 2.4) and unitriangular groups (Sections 2.2 and 2.3).
Reference: [7] <author> John D. Dixon. </author> <title> The orbit-stabilizer problem for linear groups. Can. </title> <journal> J. Math., </journal> <volume> 37 </volume> <pages> 238-259, </pages> <year> 1985. </year>
Reference-contexts: As we saw in Section 1.1, G is triangularizable over Q p if and only if G is triangularizable over C. In <ref> [7] </ref> Dixon gives a sufficient condition for a subgroup of GL (n; Z p ) to be triangularizable over Q p . <p> If H is a subgroup of C, and H is solvable-by-finite, then H is triangularizable (over Q p ). Proof. In <ref> [7] </ref> Dixon shows that H is connected in the Zariski topology of M (n; Q p ). <p> This allows us to reduce problems concerning solvable-by-finite groups to corresponding problems concerning trian-gularizable groups. We will now elaborate on how this reduction can be achieved. First we must obtain a description of K. One way to do so (as in <ref> [7] </ref>) is to get a set T of coset representatives for G=K and to then use the Schreier construction to get a set of 1 + jT j (k 1) generators for K. (See Proposition 3.4 in Chapter 4 of [20].) If we have a reasonable number of generators for K, <p> We described in Section 2.8 a practical alternative to the algorithm in [3]. As we saw in Sections 2.8 and 2.9, our algorithms for solvable-by-finite matrix groups rely on the observation in <ref> [7] </ref> that solvable-by-finite subgroups of the p-congruence subgroup of GL (n; Z p ) are triangularizable for p an odd prime. We also saw that it is an easy consequence of this result that problems concerning solvable-by-finite matrix groups can be reduced to problems about triangularizable matrix groups.
Reference: [8] <author> E. Dobrowolski. </author> <title> On a question of Lehmer and the number of irreducible factors of a polynomial. </title> <journal> Acta Arith., </journal> <volume> 34 </volume> <pages> 391-401, </pages> <year> 1979. </year>
Reference-contexts: is a low degree extension of Q, then accurate bounds on the length of a shortest nonzero vector can be obtained by finding a system of fundamental units for the group of units for O A . (See Section 6.5 of [5].) When this is impractical, the following lemma from <ref> [8] </ref> can be used to obtain a lower bound. Lemma 2.1 Let ff be a nonzero algebraic integer of degree d. Let fff 1 ; : : : ; ff d g be the algebraic conjugates of ff.
Reference: [9] <author> David Eisenbud, Craig Huneke, and Wolmer Vasconcelos. </author> <title> Direct methods for primary decomposition. </title> <journal> Invent. Math., </journal> <volume> 110 </volume> <pages> 207-235, </pages> <year> 1992. </year>
Reference-contexts: The development of practical algorithms for finding primary decompositions is an active area of research. In [10], for example, the authors show that there exists a polynomial time algorithm for computing the primary decomposition of the radical of a matrix algebra. In <ref> [9] </ref>, the authors discuss the problem of finding a practical algorithm for computing the primary decomposition of an ideal in a polynomial ring. IBM's symbolic computation package AXIOM has a function for finding the primary decomposition for a zero-dimensional ideal in a polynomial ring. <p> Further research on practical algorithms for computing the primary decomposition will shed light on how best to achieve the reduction we seek here. One method is to mimic the proof of Proposition 2.3, relying on methods in <ref> [9] </ref> or [10] for deciding whether or not A is a field and, if it is not, for finding a zero divisor a in A. Note that when R = Z, we find a basis for Z n relative to which G has the desired form.
Reference: [10] <author> Katalin Friedl and Lajos Ronyai. </author> <title> Polynomial time solutions of some problems in abstract algebra. </title> <booktitle> In Proc. 17th ACM STOC, </booktitle> <pages> pages 153-162, </pages> <year> 1985. </year>
Reference-contexts: The development of practical algorithms for finding primary decompositions is an active area of research. In <ref> [10] </ref>, for example, the authors show that there exists a polynomial time algorithm for computing the primary decomposition of the radical of a matrix algebra. In [9], the authors discuss the problem of finding a practical algorithm for computing the primary decomposition of an ideal in a polynomial ring. <p> Further research on practical algorithms for computing the primary decomposition will shed light on how best to achieve the reduction we seek here. One method is to mimic the proof of Proposition 2.3, relying on methods in [9] or <ref> [10] </ref> for deciding whether or not A is a field and, if it is not, for finding a zero divisor a in A. Note that when R = Z, we find a basis for Z n relative to which G has the desired form.
Reference: [11] <author> Guoqiang Ge. </author> <title> Algorithms Related to Multiplicative Representations of Algebraic Numbers. </title> <type> PhD thesis, </type> <address> U. C. </address> <institution> Berkeley, Math Dept., </institution> <year> 1993. </year>
Reference-contexts: Suppose that A, the enveloping algebra of G, is a field. We want to find generators for the subgroup H of Z k consisting of elements x such that g x = 1. This problem was solved in <ref> [11] </ref>. Ge assumes that the field is described by d 3 structure constants, where d is the dimension of A as a vector space over Q.
Reference: [12] <author> G. Havas, B. S. Majewski, and K. R. Matthews. </author> <title> Extended GCD algorithms. </title> <type> Technical Report 302, </type> <institution> The University of Queensland, </institution> <year> 1995. </year> <month> - 22 </month> - 
Reference-contexts: Havas' techniques are based on the work in [14] and <ref> [12] </ref>. It would be interesting to investigate whether his techniques can be adapted to our context. - 21 - 6 Acknowledgments I would like to thank my Ph. D. thesis advisor, Charles Sims, for many helpful conversations over the years; part of this paper is based on my thesis.
Reference: [13] <author> George Havas, </author> <year> 1996. </year> <type> personal communication. </type>
Reference-contexts: When performing Hermite normal form calculations, it is not unusual to encounter alarmingly large entries in the matrix p (despite small entries in h) much as I encountered alarmingly large exponents in my calculations (despite small entries in my final generating set). <ref> [13] </ref> describes very successful techniques for avoiding this problem. Havas' techniques are based on the work in [14] and [12]. It would be interesting to investigate whether his techniques can be adapted to our context. - 21 - 6 Acknowledgments I would like to thank my Ph.
Reference: [14] <author> George Havas and B. S. Majewski. </author> <title> Hermite normal form computation for integer matrices. </title> <journal> Congressus Numerantium, </journal> <volume> 105 </volume> <pages> 87-96, </pages> <year> 1994. </year>
Reference-contexts: Havas' techniques are based on the work in <ref> [14] </ref> and [12]. It would be interesting to investigate whether his techniques can be adapted to our context. - 21 - 6 Acknowledgments I would like to thank my Ph.
Reference: [15] <author> Eugene M. Luks. </author> <title> Computing in solvable matrix groups. </title> <booktitle> In Proc. 33rd IEEE FOCS, </booktitle> <pages> pages 111-120, </pages> <year> 1992. </year>
Reference-contexts: algorithms for such fundamental problems as the membership problem: given a finite set X of n fi n invertible matrices and given another such matrix a, decide whether or not a is an element of the group generated by X under multiplication. (For polynomial-time algorithms for finite matrix groups, see <ref> [15] </ref> and [3], for example.) When we pass to infinite matrix groups, this same question becomes undecidable [16]. Therefore, when studying infinite matrix groups it makes sense to restrict our attention somewhat. <p> If G is solvable, then we can instead use special methods for finding presentations for solvable subgroups of GL (n; F p ). (See <ref> [15] </ref>.) Suppose now that K is given by normal generators, i.e., suppose we have generators for f K such that f K G = K. We can decide whether or not f K is triangularizable, and if it is, then we can test membership in f K. <p> Then a 2 G if and only if ag 1 2 K. This approach might be particularly efficient in the case when G is polycyclic, since then we can use algorithms developed for working with solvable matrix groups over finite fields. (See <ref> [15] </ref>.) The second algorithm for deciding whether or not a 2 G relies on the algorithms in [3] for working with abelian-by-finite matrix groups as well as the algorithm in Section 2.3 for testing membership in a unitriangular matrix group.
Reference: [16] <author> K. A. Mihailova. </author> <title> The occurence problem for direct products of groups. </title> <journal> Dokl. Akad. Nauk, </journal> <volume> 119 </volume> <pages> 1103-1105, </pages> <year> 1958. </year>
Reference-contexts: n invertible matrices and given another such matrix a, decide whether or not a is an element of the group generated by X under multiplication. (For polynomial-time algorithms for finite matrix groups, see [15] and [3], for example.) When we pass to infinite matrix groups, this same question becomes undecidable <ref> [16] </ref>. Therefore, when studying infinite matrix groups it makes sense to restrict our attention somewhat. It is natural to consider the class of polycyclic groups | solvable groups in which every subgroup is finitely generated.
Reference: [17] <author> Gretchen Ostheimer. </author> <title> Algorithms for Polycyclic-by-Finite Groups. </title> <type> PhD thesis, </type> <institution> Rutgers Univerisity, Math Dept., </institution> <year> 1996. </year>
Reference-contexts: In both cases, we show that through a change of basis over Q, the groups have a certain block upper triangular form. Part of this paper is based on the author's Ph. D. thesis <ref> [17, 18] </ref>. 1.1 Notation and definitions Throughout this paper let Z denote the ring of integers, Q the field of rationals, and C the field of complex numbers. Let R denote either Z or Q.
Reference: [18] <author> Gretchen Ostheimer. </author> <title> Algorithms for polycyclic-by-finite matrix groups. </title> <booktitle> In DIMACS Series in Discrete Mathematics and Computer Science, </booktitle> <pages> pages 297-307, </pages> <year> 1997. </year>
Reference-contexts: In both cases, we show that through a change of basis over Q, the groups have a certain block upper triangular form. Part of this paper is based on the author's Ph. D. thesis <ref> [17, 18] </ref>. 1.1 Notation and definitions Throughout this paper let Z denote the ring of integers, Q the field of rationals, and C the field of complex numbers. Let R denote either Z or Q.
Reference: [19] <author> Daniel Segal. </author> <title> Polycyclic Groups. </title> <publisher> Cambridge University Press, </publisher> <year> 1983. </year>
Reference-contexts: If G is a subgroup of GL (n; F ) and if G is triangularizable over some extension field E of F , then there exists a finite extension L of F over which G is triangularizable. (See p. 33 of <ref> [19] </ref>.) Therefore, a subgroup G of GL (n; Q) is triangularizable if and only if it is triangularizable over C. Let Tr 1 (n; R) denote the group of upper triangular matrices with entries in R and 1's along the diagonal. Elements of Tr 1 (n; R) are called unitriangular. <p> We reduce the problem of testing membership in G to the problem of testing membership in a subgroup of Tr 1 (n; Z). In <ref> [19] </ref> (Lemma 2, Chapter 6), Segal shows that if G = hg 1 ; : : : ; g k i is a finitely generated subgroup of Tr 1 (n; Q), then it is easy to find an x in GL (n; Q) such that x 1 Gx Tr 1 (n; <p> As described in Section 2.1, it follows that we can also test membership in G constructively. 2.5 A structure theorem for triangularizable groups Recall that an abelian subgroup G of GL (n; R) is triangularizable. (See p. 29 of <ref> [19] </ref>.) We can use this fact to construct other examples of triangularizable subgroups. Let n = n 1 + +n r , and let G i be an abelian subgroup of GL (n i ; R). <p> Proof. There exists a subgroup H / G such that jG : Hj &lt; 1 and H is triangularizable. (See Theorem 3, Chapter 2 of <ref> [19] </ref> as well as Lemma 1.1 of this paper.) Let V 0 (H); : : : ; V r (H) be defined as in Section 2.5. By Lemma 2.6, it suffices to show that each V i (H) is invariant under G. <p> If m is a positive integer, let m be the map from GL (n; Z) to GL (n; Z=mZ). If a is not an element of G, then there exists an m such that m (a) is not an element of m (G) (Theorem 5 in Chapter 5 of <ref> [19] </ref>). In [2], the authors verify that a is not an element of G by simply trying all positive integers m, testing whether or not m (a) is an element of m (G), and stopping if it is not.
Reference: [20] <author> Charles C. Sims. </author> <title> Computation with Finitely Presented Groups. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: The identity element of GL (n; R) is denoted by 1. The commutator subgroup of G is denoted by G 0 . - 3 - 1.2 Basic algorithms for polycyclic groups Chapter 9 in <ref> [20] </ref> gives a good introduction to polycyclic groups. A group G is polycyclic if there is a sequence of subgroups G 1 , . . . , G k+1 for G such that G = G 1 . G 2 . . G k . <p> Intuitively, a consistent polycyclic presentation is one from which the polycyclic structure of the group is easily gleaned. In particular, the generators in a consistent polycyclic presentation form a polycyclic generating sequence for G. (See Section 9.6 of <ref> [20] </ref> for a precise definition.) Throughout this paper we rely on basic algorithms in [20] for working with polycyclic groups given by consistent polycyclic presentations. <p> In particular, the generators in a consistent polycyclic presentation form a polycyclic generating sequence for G. (See Section 9.6 of <ref> [20] </ref> for a precise definition.) Throughout this paper we rely on basic algorithms in [20] for working with polycyclic groups given by consistent polycyclic presentations. For example, practical algorithms exist for testing membership in a subgroup of a polycyclic group, and for finding the kernel of a homomorphism between two polycyclic groups, providing these groups are given by consistent polycyclic presentations. <p> We also rely on the fact that a polycyclic group satisfies the ascending chain condition on subgroups. In Section 2, we will refer in some detail to two algorithms in Section 9.6 of <ref> [20] </ref> for testing membership in a subgroup H of G: POLY SUBGROUP and POLY MEMBER. POLY SUBGROUP calculates a polycyclic generating sequence for H. POLY MEMBER uses such a sequence to test membership in H. <p> Since H is the kernel of the map from K to T " G taking x to g x , we can use the techniques of Section 9.6 of <ref> [20] </ref> to find generators for H. Ge uses a technique which is similar to that described above, but he uses complex logarithms instead of real logarithms. <p> have been developed for working with polycyclic groups given by consistent polycyclic presentations. (See Section 1.2 for a description of POLY SUBGROUP and POLY MEMBER.) Since Tr 1 (n; Z) is a finitely generated nilpotent group, it is also polycyclic. (See Example 2.1 and Proposition 3.4 in Chapter 9 of <ref> [20] </ref>.) It is easy to find a consistent polycyclic presentation hXjRi for Tr 1 (n; Z): Example 4.1 in Chapter 9 of [20] is easily generalized. It is also easy to express a given unitriangular matrix in terms of the generators in X. <p> and POLY MEMBER.) Since Tr 1 (n; Z) is a finitely generated nilpotent group, it is also polycyclic. (See Example 2.1 and Proposition 3.4 in Chapter 9 of <ref> [20] </ref>.) It is easy to find a consistent polycyclic presentation hXjRi for Tr 1 (n; Z): Example 4.1 in Chapter 9 of [20] is easily generalized. It is also easy to express a given unitriangular matrix in terms of the generators in X. Use POLY SUBGROUP to calculate a polycyclic generating sequence h 1 ; : : : ; h l for G and POLY MEMBER to then test membership in G. <p> One way to do so (as in [7]) is to get a set T of coset representatives for G=K and to then use the Schreier construction to get a set of 1 + jT j (k 1) generators for K. (See Proposition 3.4 in Chapter 4 of <ref> [20] </ref>.) If we have a reasonable number of generators for K, then we can decide whether or not G is solvable-by-finite since we can decide whether or not K is triangularizable. (See Section 2.7.) The Schreier construction will be impractical in many cases since even if p is small, jT j <p> Subroutines included versions of POLY SUBGROUP and POLY MEMBER (from Section 9.6 of <ref> [20] </ref>). My algorithms were slightly different from those in [20]: there was no need to rewrite matrices as words in the standard generators for Tr 1 (n; Z). For n = 6, the routine to compute the power of a matrix was optimized by Eddie H. Lo. <p> Subroutines included versions of POLY SUBGROUP and POLY MEMBER (from Section 9.6 of <ref> [20] </ref>). My algorithms were slightly different from those in [20]: there was no need to rewrite matrices as words in the standard generators for Tr 1 (n; Z). For n = 6, the routine to compute the power of a matrix was optimized by Eddie H. Lo. <p> For n = 6, the routine to compute the power of a matrix was optimized by Eddie H. Lo. Lo's idea is based on an observation by Hall that collection in a finitely presented nilpotent group can be performed using polynomials <ref> [20] </ref>. Choose any ordering on the 15 off-diagonal entries in a given matrix in Tr 1 (6; Z). <p> Indeed, in the experiments in which G was constructed from two abelian groups, the unipotent part is abelian. It would be wise to exploit this! Secondly, as discussed in Section 9.5 of <ref> [20] </ref>, POLY SUBGROUP can be viewed as a generalization of an algorithm to compute the Hermite normal form h of an integer matrix m. The powers to which we raise group elements in POLY SUBGROUP correspond to the entries in a matrix p such that pm = h.
Reference: [21] <author> B. A. F. Wehrfritz. </author> <title> Infinite Linear Groups. </title> <publisher> Springer-Verlag, </publisher> <year> 1973. </year>
Reference-contexts: If G &lt; GL (n; R) consists entirely of unipotent elements, then G is said to be unipotent. In this case there is a basis for R n with respect to which G is unitriangular. (The case when R = Q is proved as Corollary 1.21 in <ref> [21] </ref>, and the case when R = Z follows easily.) If G is a subgroup of GL (n; R), then there is a unique normal unipotent subgroup of G which is maximal among all such subgroups of G. (See 13.40 of [21].) This subgroup is called the unipotent part of G. <p> R = Q is proved as Corollary 1.21 in <ref> [21] </ref>, and the case when R = Z follows easily.) If G is a subgroup of GL (n; R), then there is a unique normal unipotent subgroup of G which is maximal among all such subgroups of G. (See 13.40 of [21].) This subgroup is called the unipotent part of G. If x 2 Z k and g 1 ; : : : ; g k 2 GL (n; R), then g x denotes g x 1 1 g k .
References-found: 21

