URL: ftp://theory.lcs.mit.edu/pub/people/oded/dgw.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/zk.html
Root-URL: 
Title: Honest Verifier vs Dishonest Verifier in Public Coin Zero-Knowledge Proofs  
Author: Ivan Damgard Oded Goldreich Tatsuaki Okamoto Avi Wigderson 
Address: Murray Hill, NJ, USA  
Note: and BRICS, Basic Research In Computer Science, center of the Danish National Research Foundation. NTT Laboratories, Yokosuka-shi, 238-03 Japan. Work done while visiting AT&T Bell  
Affiliation: Dept. of Computer Science, Aarhus Univesity, Denmark  Laboratories,  
Date: September 12, 1995  
Abstract: This paper presents two transformations of public-coin/Arthur-Merlin proof systems which are zero-knowledge with respect to the honest verifier into (public-coin/Arthur-Merlin) proof systems which are zero-knowledge with respect to any verifier. The first transformation applies only to constant-round proof systems. It builds on Damgard's transformation (see Crypto93), using ordinary hashing functions instead of the interactive hashing protocol (of Naor, Ostrovsky, Venkatesan and Yung see Crypto92) which was used by Damgard. Consequently, the protocols resulting from our transformation have much lower round-complexity than those derived by Damgard's transformation. As in Damgard's transformation, our transformation preserves statistical/perfect zero-knowledge and does not rely on any computational assumptions. However, unlike Damgard's transformation, the new transformation is not applicable to argument systems or to proofs of knowledge. The second transformation can be applied to proof systems of arbitrary number of rounds, but it only preserves statistical zero-knowledge. It assumes the existence of secure commitment schemes and transforms any public-coin proof which is statistical zero-knowledge with respect to the honest into one which is statistical zero-knowledge (in general). It follows, by a result of Ostrovsky and Wigderson (1993), that any language which is hard on the average and has a public-coin proof system which is statistical zero-knowledge with respect to the honest verifier, has a proof system which is statistical zero-knowledge (with respect to any verifier). y Dept. of Computer Science and Applied Math., Weizmann Institute of Science, Rehovot, Israel. Work done while visiting BRICS, Basic Research In Computer Science, center of the Danish National Research Foundation. Supported in part by grant No. 92-00226 from the United States - Israel Binational Reseach Foundation (BSF), Jerusalem, Israel. x Institute for Computer Science, Hebrew University, Jerusalem, Israel. Work done while visiting BRICS, Basic Research In Computer Science, center of the Danish National Research Foundation. This research was partially supported by a grant from the Wolfson Research Awards, administered by the Israeli Academy of Sciences and Humanities. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Babai. </author> <title> Trading Group Theory for Randomness, </title> <booktitle> Proc. of 17th STOC, </booktitle> <pages> pages 421-420, </pages> <year> 1985. </year>
Reference-contexts: Recall that the statistical difference between two random variable X and Y is 1 X jProb (X = ff) Prob (Y = ff)j We say that X is "-away from Y if the statistical difference between them is ". Proposition 1 Let n be an integer, " 2 <ref> [0; 1] </ref> and m def = n 4 log 2 (n="). Suppose that H n;m is a family of almost n-wise independent hashing functions. <p> Such interactive proofs are called Arthur-Merlin games <ref> [1] </ref> or public-coins interactive proofs (cf., [17]). <p> Soundness properties are preserved as well, but with some slackness which results from the imperfectness of the Random Selection protocol. In particular, Proposition 5 Let : f0; 1g fl 7! <ref> [0; 1] </ref> be a function bounding the probability that verifier V accepts inputs when interacting with any (possibly cheating) prover. Namely, (x) is a bound on the probability that V accepts x. Suppose that on input x, the interactive proof (P; V ) runs for t (jxj) rounds. <p> Namely, when producing a transcript with less likely r i 's, the simulator will discard it with some probability. The required probability (with which to discard transcripts) can be easily computed. 3.4 Conclusions Combining Propositions 5 and 6, we get Theorem 1 Let : N 7! <ref> [0; 1] </ref>. Suppose L has a constant-round Arthur-Merlin proof system, with error bound , which is perfect (resp. almost-perfect) [resp. computational] zero-knowledge with respect to the honest verifier. <p> Here, when i = j and I = J , we suppose that e S has already executed the procedures for i from 1 through j 1 and the procedures for I from 1 through J 1 in the procedure for i = j. (i.e., <ref> [1; 1] </ref>; : : : ; [1; l 1 ], : : : ; [j 1; 1]; : : : ; [j 1; l j1 ], [j; 1]; : : : ; [j; J 1].) So, the initial status of A fl in the following procedure is the final status of <p> when i = j and I = J , we suppose that e S has already executed the procedures for i from 1 through j 1 and the procedures for I from 1 through J 1 in the procedure for i = j. (i.e., [1; 1]; : : : ; <ref> [1; l 1 ] </ref>, : : : ; [j 1; 1]; : : : ; [j 1; l j1 ], [j; 1]; : : : ; [j; J 1].) So, the initial status of A fl in the following procedure is the final status of A fl just before the procedure. <p> , we suppose that e S has already executed the procedures for i from 1 through j 1 and the procedures for I from 1 through J 1 in the procedure for i = j. (i.e., [1; 1]; : : : ; [1; l 1 ], : : : ; <ref> [j 1; 1] </ref>; : : : ; [j 1; l j1 ], [j; 1]; : : : ; [j; J 1].) So, the initial status of A fl in the following procedure is the final status of A fl just before the procedure. <p> i from 1 through j 1 and the procedures for I from 1 through J 1 in the procedure for i = j. (i.e., [1; 1]; : : : ; [1; l 1 ], : : : ; [j 1; 1]; : : : ; [j 1; l j1 ], <ref> [j; 1] </ref>; : : : ; [j; J 1].) So, the initial status of A fl in the following procedure is the final status of A fl just before the procedure. <p> (i) I 2 f0; 1g, from A fl 10 (d) e S checks whether the following equation holds or not: b I c I = e I : If it holds, then e S goes to the next procedure, [i; I + 1]. (Note: [i; l i + 1] means <ref> [i + 1; 1] </ref>.) Otherwise, e S makes A fl to Init [i;I] and returns to the first step of this procedure, [i; I]. 3. Finally e S arranges these values in the order of (M fl fl ) protocol, and outputs them. <p> Clearly, after procedure [i; I] is completed, the simulated conversation from <ref> [1; 1] </ref> to [i; I] is not affected by the following procedures. (i.e., there is no back-track.) Hence, totally, e S terminates in expected time of polynomial (i.e., O (2 ( P k i=1 l 1 ) fi T ); where T is the running time of each procedure described above).
Reference: [2] <author> M. Bellare, S. Micali and R. Ostrovsky: </author> <title> The (true) Complexity of Statistical Zero-Knowledge, </title> <booktitle> Proc. of STOC 90. </booktitle>
Reference-contexts: Assuming various intractability assumptions, such transformations have been presented by Bellare et. al. <ref> [2] </ref>, and Ostrovsky et. al. [23]. A transformation which does not rely on any intractability assumptions has been presented by Damgard in Crypto93. His transformation (of honest-verifier zero-knowledge into general zero-knowledge) has two shortcomings. <p> Other Related Work The idea of transforming honest verifier zero-knowledge into zero-knowledge in general was first studied by Bellare, Micali and Ostrovsky <ref> [2] </ref>. Their transformation needed a computational assumption of a specific algebraic type. Since then several constructions have reduced the computational assumptions needed. The latest in this line of work is by Ostrovsky, Venkatesan and Yung [23], who give a transformation which is based on interactive hashing and preserved statistical zero-knowledge.
Reference: [3] <author> M. Ben-Or, O. Goldreich, S. Goldwasser, J. Hastad, J. Killian, S. Micali and P. Rogaway: </author> <title> Everything Provable is Provable in Zero-Knowledge, </title> <booktitle> Proc. of Crypto 88. </booktitle>
Reference-contexts: They have proved that the existence of honest verifier zero-knowledge proof system for a language which is hard on the average implies the existence of one-way functions. Combined with the results of [14] and <ref> [19, 3] </ref>, this yields a (computational and general) zero-knowledge proof for the same language. Thus, computational honest-verifier zero-knowledge interactive proofs, for hard on the average languages, get transformed into computational zero-knowledge interactive proofs for these languages.
Reference: [4] <author> G. Brassard, D. Chaum and C. Crepeau: </author> <title> Minimum Disclosure Proofs of Knowledge, </title> <journal> JCSS. </journal>
Reference-contexts: We preserve some of the positive properties of Damgard's transformation. In particular, our transformation does not rely on any computational assumptions and preserves perfect and almost-perfect (statistical) zero-knowledge. However, unlike Damgard's transformation, the new transformation is not applicable to argument systems (i.e., the BCC model <ref> [4] </ref>) or to proofs of knowledge. Our transformation builds on Damgard's work [6]. <p> The technique of using the bit-commitment for the transformation can be also applied to the argument model <ref> [4] </ref>.
Reference: [5] <author> G. Brassard, C. Crepeau and M. Yung: </author> <title> Everything in NP can be Argued in Perfect Zero-Knowledge in a Constant Number of Rounds, </title> <booktitle> 16th ICALP, </booktitle> <pages> pp. 123-136, </pages> <year> 1989. </year>
Reference: [6] <author> I. Damgard: </author> <title> Interactive Hashing can Simplify Zero-Knowledge Protocol Design Without Computational Assumptions, </title> <booktitle> Proc. of Crypto 93. </booktitle>
Reference-contexts: In particular, our transformation does not rely on any computational assumptions and preserves perfect and almost-perfect (statistical) zero-knowledge. However, unlike Damgard's transformation, the new transformation is not applicable to argument systems (i.e., the BCC model [4]) or to proofs of knowledge. Our transformation builds on Damgard's work <ref> [6] </ref>. <p> This is the reason we can handle any constant number of rounds. 7 We now compare the round complexity of the protocols resulting from our transformation to those resulting from Damgard's transformation of <ref> [6] </ref>. Suppose we start with a c-round proof system which uses r (n) random coins and has error (n). Clearly, (n) 2 r (n) and r (n) &gt; log 2 n (otherwise the language is in BPP [15]). <p> This result can be considered to improve the two previous results partially: one is the result by Ostrovsky, Venkatesan and Yung [23] and the other is by Damgard <ref> [6] </ref> (see Introduction of Part I). That is, our result generalizes the assumption of [23], from one-way permutations to one-way functions, although our transformation is only applicable to public coin proof systems.
Reference: [7] <author> I. Damgard, O. Goldreich, and A. Wigderson: </author> <title> Hashing Functions can Simplify Zero-Knowledge Protocol Design (too), </title> <booktitle> BRICS Technical Rerport RS-94-39, </booktitle> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Due to space limitations the proofs of all propositions have been omitted. The complete proofs appear in our technical report <ref> [7] </ref>. 2 Random Selection We consider a randomized two-party protocol for selecting strings. The two parties to the protocol are called the challenger and the responder. These names are supposed to reflect the asymmetric requirements (presented below) as well as the usage of the protocol in our zero-knowledge transformation.
Reference: [8] <author> U. Feige and A. Shamir: </author> <title> Zero-Knowledge Proofs of Knowledge in Two Rounds, </title> <booktitle> Advances in Cryptology - Crypto89 (proceedings), </booktitle> <pages> pp. 526-544, </pages> <year> 1990. </year>
Reference: [9] <author> O. Goldreich: </author> <title> Foundation of Cryptography Fragments of a Book, </title> <month> February </month> <year> 1995. </year> <note> Available from the Electronic Colloquium on Computational Complexity (ECCC), http://www.eccc.uni-trier.de/eccc/. </note>
Reference-contexts: Clearly, this definition implies the standard one, but the converse is not known to hold see <ref> [9] </ref>. This definition is more convenient for establishing zero-knowledge claims and in particular for our purposes, but our results do not depend on it (and can be derived under the standard definitions). Due to space limitations the proofs of all propositions have been omitted.
Reference: [10] <author> O. Goldreich, S. Goldwasser and N. Linial: </author> <title> Fault-Tolerant Computation without Assumptions: the Two-Party Case, </title> <booktitle> 32nd FOCS, </booktitle> <pages> pp. 447-457, </pages> <year> 1991. </year>
Reference-contexts: However, perfect honest-verifier zero-knowledge proofs (for such languages) do not get transformed into perfect zero-knowledge proofs. A two-party protocol for random selection, with unrelated properties, has been presented in <ref> [10] </ref>. This protocol guarantees that, as long as one party plays honestly, the outcome of the protocol hits any set S f0; 1g with probability at most ~ O ( p jSj=2 n ), where ~ O (") def = " polylog (1=").
Reference: [11] <author> O. Goldreich and A. Kahan: </author> <title> How to Construct Constant-Round Zero-Knowledge Proof Systems for NP, </title> <note> to appear in Journal of Crypology, </note>
Reference-contexts: Likewise, assuming the existence of one-way function, there exist constant-round interactive proofs for any NP-language which are zero-knowledge with respect to the honest verifier. Yet, constant-round interactive proofs for NP which are zero-knowledge in general are known only under seemingly stronger assumptions and are also more complex (cf., <ref> [11] </ref>). In view of the relative simplicity of designing protocols which are zero-knowledge with respect to the honest verifier, a transformation of such protocols into protocols which are zero-knowledge in general (i.e., w.r.t. any verifier) may be very valuable.
Reference: [12] <author> O. Goldreich and H. Krawcyzk: </author> <title> On the Composition of Zero-Knowledge Proof Systems, </title> <booktitle> 17th ICALP, </booktitle> <pages> pp. 268-282, </pages> <year> 1990. </year>
Reference-contexts: Our transformation only increases the number of rounds by a factor of two. However, it also increases the error probability of the proof system by a non-negligible amount which can be made arbitrarily small. This increase is inevitible in view of a result of Goldreich and Krawcyzk <ref> [12] </ref>, see discussion in subsection 3.4. Thus, to get proof systems with negligible error probability, one may repeat the protocols resulting from our transformation a non-constant number of times. Still, the resulting proof systems will have much lower round complexity than those resulting from Damgard's transformation. <p> Furthermore, the zero-knowledge property can be demonstrated using a black-box simulation. Also, if the original system had no error on inputs in L then the same holds for the new system. Theorem 1 does not preserve the error probability of the original system. This seems inevitible, in light of <ref> [12] </ref>. Recall that there are languages believed not to be in BPP which have constant-round Arthur-Merlin proof systems, with exponentially small error probability, which are zero-knowledge with respect to the honest verifier. <p> Now, a stronger version of Theorem 1, say one in which 0 (n) (n) is a negligible function of n, would imply that these languages have constant-round Arthur-Merlin (balck-box) zero-knowledge proof systems (with negligible error probability). But, according to <ref> [12] </ref>, languages having constant-round Arthur-Merlin (balck-box) zero-knowledge proof systems lie in BPP.
Reference: [13] <author> O. Goldreich, Y. Mansour and M. Sipser: </author> <title> Proofs that Never Fail and Random Selection, </title> <booktitle> Proc. of FOCS 87. </booktitle>
Reference-contexts: Another two-party protocol for random selection, with other unrelated properties, has been presented in <ref> [13] </ref>. Loosely speaking, this protocol allows a computationally restricted party, interacting with a powerful and yet untrustful party, to uniformly select an element in an easily recognizable set S f0; 1g .
Reference: [14] <author> O. Goldreich, S. Micali and A. Wigderson: </author> <title> Proofs that yield Nothing but their Validity and a Methodology of Cryptographic Protocol Design, </title> <booktitle> Proc. of FOCS 86. </booktitle>
Reference-contexts: 1 Introduction to Part I Zero-knowledge proof systems, introduced by Goldwasser, Micali and Rackoff [16], are a key tool in the design of cryptographic protocols. The results of Goldreich, Micali and Wigderson <ref> [14] </ref> guarantee that such proof systems can be constructed for any NP-statement, provided that one-way functions exist. However, the general construction presented in [14] and subsequent works may yield quite inefficient proof systems for particular applications of interest. <p> The results of Goldreich, Micali and Wigderson <ref> [14] </ref> guarantee that such proof systems can be constructed for any NP-statement, provided that one-way functions exist. However, the general construction presented in [14] and subsequent works may yield quite inefficient proof systems for particular applications of interest. Thus, developing methodoligies for the design of zero-knowledge proofs is still of interest. <p> They have proved that the existence of honest verifier zero-knowledge proof system for a language which is hard on the average implies the existence of one-way functions. Combined with the results of <ref> [14] </ref> and [19, 3], this yields a (computational and general) zero-knowledge proof for the same language. Thus, computational honest-verifier zero-knowledge interactive proofs, for hard on the average languages, get transformed into computational zero-knowledge interactive proofs for these languages. <p> For example, Graph Isomorphism has such a system (for perfect zero-knowledge), and assuming the existence of one-way functions, every language in N P has such a system (for computational zero-knowledge) <ref> [14] </ref>. Now, a stronger version of Theorem 1, say one in which 0 (n) (n) is a negligible function of n, would imply that these languages have constant-round Arthur-Merlin (balck-box) zero-knowledge proof systems (with negligible error probability).
Reference: [15] <author> O. Goldreich and Y. Oren: </author> <title> Definitions and Properties of Zero-Knowledge Proof Systems. </title> <journal> Jour. of Crypto., </journal> <volume> Vol. 7, </volume> <pages> pp. 1-32, </pages> <year> 1994. </year>
Reference-contexts: Suppose we start with a c-round proof system which uses r (n) random coins and has error (n). Clearly, (n) 2 r (n) and r (n) &gt; log 2 n (otherwise the language is in BPP <ref> [15] </ref>). Now, the proof system resulting from Damgard's transformation will have c + r (n) rounds and maintain the error bound of the original proof system. On the other hand, the protocol resulting from our transformation will have 2c rounds and error (n) + 1 poly (n) .
Reference: [16] <author> S. Goldwasser, S. Micali and C. Rackoff: </author> <title> The Knowledge Complexity of Interactive Proof Systems, </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 18, </volume> <pages> pp. 186-208, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction to Part I Zero-knowledge proof systems, introduced by Goldwasser, Micali and Rackoff <ref> [16] </ref>, are a key tool in the design of cryptographic protocols. The results of Goldreich, Micali and Wigderson [14] guarantee that such proof systems can be constructed for any NP-statement, provided that one-way functions exist.
Reference: [17] <author> S. Goldwasser and M. Sipser. </author> <title> Private Coins versus Public Coins in Interactive Proof Systems, </title> <booktitle> Proc. of 18th STOC, </booktitle> <pages> pages 59-68, </pages> <year> 1986. </year>
Reference-contexts: Such interactive proofs are called Arthur-Merlin games [1] or public-coins interactive proofs (cf., <ref> [17] </ref>).
Reference: [18] <author> J. Hastad, R. Impagliazzo, L.A. Levin and M. Luby: </author> <title> Construction of Pseudorandom Generator from any One-Way Function, </title> <type> manuscript, </type> <year> 1993. </year> <note> See preliminary versions by Impagliazzo et. </note> <editor> al. </editor> <booktitle> in 21st STOC and Hastad in 22nd STOC. </booktitle>
Reference-contexts: Remarks Concerning this Part of the Paper We use the standard definitions of interactive proofs and zero-knowledge, except for the following minor modification. We require the simulator (in the definition of zero-knowledge) to to run in 3 Secure commitment schemes exist provided that one-way functions exist <ref> [18, 20] </ref> and the latter exist if some languages which is hard on the average have proof systems which are zero-knowledge with respect to the honest verifier [24]. 2 strictly polynomial-time (rather than in expected polynomial-time), but we allow it to produce output only with some non-negligible probability (rather than always). <p> 2 r (n) .) Part II Using Commitment Schemes to Simplify Zero-Knowledge Protocol Design 7 4 Introduction to Part II In this part, we will show another transformation, which can be applied to arbitrary number of round statistical zero-knowledge proofs, assuming the existence of secure commitment schemes (i.e., one-way functions <ref> [18, 20] </ref>). This assumption can be replaced by the restriction on the applicable languages, that they are hard on the average (not in AVBPP) [24]. <p> P sends BC (s; t; b) to R. 2. [Reveal stage:] C sends s and b to R, and R checks the validity. A pseudo-random generator exits if and only if a one-way function exists <ref> [18] </ref>. Next, we show the protocol of (M fl fl ) using Naor's bit-commitment protocol. Protocol (M fl fl Common input: x What to prove: x 2 L. Repeat the following protocol for i from 1 to k sequentially.
Reference: [19] <author> R. Impagliazzo and M. Yung, </author> <title> Direct Minimum-Knowledge Computations, </title> <booktitle> Advances in Cryptology - Crypto87 (proceedings), </booktitle> <year> 1987, </year> <pages> pp. 40-51. </pages>
Reference-contexts: They have proved that the existence of honest verifier zero-knowledge proof system for a language which is hard on the average implies the existence of one-way functions. Combined with the results of [14] and <ref> [19, 3] </ref>, this yields a (computational and general) zero-knowledge proof for the same language. Thus, computational honest-verifier zero-knowledge interactive proofs, for hard on the average languages, get transformed into computational zero-knowledge interactive proofs for these languages.
Reference: [20] <author> M. Naor: </author> <title> Bit Commitments from Pseudorandomness, </title> <booktitle> Proc. of Crypto 89. </booktitle>
Reference-contexts: Remarks Concerning this Part of the Paper We use the standard definitions of interactive proofs and zero-knowledge, except for the following minor modification. We require the simulator (in the definition of zero-knowledge) to to run in 3 Secure commitment schemes exist provided that one-way functions exist <ref> [18, 20] </ref> and the latter exist if some languages which is hard on the average have proof systems which are zero-knowledge with respect to the honest verifier [24]. 2 strictly polynomial-time (rather than in expected polynomial-time), but we allow it to produce output only with some non-negligible probability (rather than always). <p> 2 r (n) .) Part II Using Commitment Schemes to Simplify Zero-Knowledge Protocol Design 7 4 Introduction to Part II In this part, we will show another transformation, which can be applied to arbitrary number of round statistical zero-knowledge proofs, assuming the existence of secure commitment schemes (i.e., one-way functions <ref> [18, 20] </ref>). This assumption can be replaced by the restriction on the applicable languages, that they are hard on the average (not in AVBPP) [24]. <p> Let l i be the (bit) size of ff i . Let BC be Naor's bit-commitment function based on a pseudo-random generator, G, <ref> [20] </ref>. That is, Naor's bit-commitment protocol is as follows: 1. [Commit stage:] Receiver (R) sends a (3n bits) random string, t, to Committer (C).
Reference: [21] <author> M. Naor, R. Ostrovsky, R. Venkatesan and M. Yung: </author> <title> Zero-Knowledge Arguments for NP can be Based on General Complexity Assumptions, </title> <booktitle> Proc. of Crypto 92. </booktitle>
Reference: [22] <author> R. Ostrovsky, R. Venkatesan and M. Yung: </author> <title> Fair Games Against an All-Powerful Adversary, </title> <booktitle> presented at DIMACS Complexity and Cryptography Workshop, </booktitle> <month> October </month> <year> 1990, </year> <institution> Princeton. </institution>
Reference-contexts: isomorphic copies of each graph, randomly shuffles all these copies together, and asks the prover to specify the origin of each copy. 1 sent by the verifier (in each round) are replaced by a multi-round interactive hashing protocol, which in turn originates in the work of Ostrovsky, Venkatesan and Yung <ref> [22] </ref>. Instead, in our transformation, the random messages sent by the verifier are replaced by a 3 2 -round protocol, called Random Selection.
Reference: [23] <author> R. Ostrovsky, R. Venkatesan and M. Yung: </author> <title> Interactive Hashing Simplifies Zero-Knowledge Protocol Design, </title> <booktitle> Proc. of EuroCrypt 93. </booktitle>
Reference-contexts: Assuming various intractability assumptions, such transformations have been presented by Bellare et. al. [2], and Ostrovsky et. al. <ref> [23] </ref>. A transformation which does not rely on any intractability assumptions has been presented by Damgard in Crypto93. His transformation (of honest-verifier zero-knowledge into general zero-knowledge) has two shortcomings. <p> Their transformation needed a computational assumption of a specific algebraic type. Since then several constructions have reduced the computational assumptions needed. The latest in this line of work is by Ostrovsky, Venkatesan and Yung <ref> [23] </ref>, who give a transformation which is based on interactive hashing and preserved statistical zero-knowledge. Their transformation relies on existence of a one-way permutation. The transformation works for any protocol, provided that the verifier is probabilistic polynomial-time. <p> This assumption can be replaced by the restriction on the applicable languages, that they are hard on the average (not in AVBPP) [24]. This result can be considered to improve the two previous results partially: one is the result by Ostrovsky, Venkatesan and Yung <ref> [23] </ref> and the other is by Damgard [6] (see Introduction of Part I). That is, our result generalizes the assumption of [23], from one-way permutations to one-way functions, although our transformation is only applicable to public coin proof systems. <p> This result can be considered to improve the two previous results partially: one is the result by Ostrovsky, Venkatesan and Yung <ref> [23] </ref> and the other is by Damgard [6] (see Introduction of Part I). That is, our result generalizes the assumption of [23], from one-way permutations to one-way functions, although our transformation is only applicable to public coin proof systems.
Reference: [24] <author> R. Ostrovsky and A. Wigderson: </author> <title> One-Way Functions are Essential for Non-Trivial Zero-Knowledge, </title> <booktitle> Proc. 2nd Israel Symp. on Theory of Computing and Systems, </booktitle> <year> 1993. </year> <month> 12 </month>
Reference-contexts: An indirect way of converting protocols which are zero-knowledge with respect to the honest verifier into ones which are zero-knowledge in general, is available through a recent result of Os-trovsky and Wigderson <ref> [24] </ref>. They have proved that the existence of honest verifier zero-knowledge proof system for a language which is hard on the average implies the existence of one-way functions. Combined with the results of [14] and [19, 3], this yields a (computational and general) zero-knowledge proof for the same language. <p> We require the simulator (in the definition of zero-knowledge) to to run in 3 Secure commitment schemes exist provided that one-way functions exist [18, 20] and the latter exist if some languages which is hard on the average have proof systems which are zero-knowledge with respect to the honest verifier <ref> [24] </ref>. 2 strictly polynomial-time (rather than in expected polynomial-time), but we allow it to produce output only with some non-negligible probability (rather than always). Clearly, this definition implies the standard one, but the converse is not known to hold see [9]. <p> This assumption can be replaced by the restriction on the applicable languages, that they are hard on the average (not in AVBPP) <ref> [24] </ref>. This result can be considered to improve the two previous results partially: one is the result by Ostrovsky, Venkatesan and Yung [23] and the other is by Damgard [6] (see Introduction of Part I). <p> Hence, Prob [e (i) (i) (i) Thus, the simulated ff i is statistically close to the real one. 2 We can immediately obtain the following corollary from Theorem 2 and <ref> [24] </ref>. Corollary 1 If language L has a statistical zero-knowledge public-coin proof and L is not in AVBPP, then L has a statistical zero-knowledge public-coin proof against any verifier.
References-found: 24

