URL: http://www.cis.ohio-state.edu/~paolo/research/publications/cs-tr-96-08.ps
Refering-URL: http://www.cis.ohio-state.edu/~paolo/research/
Root-URL: http://www.cis.ohio-state.edu
Email: mani@cs.caltech.edu  
Title: A World-Wide Distributed System Using Java and the Internet  
Author: K. Mani Chandy, Boris Dimitrov, Huy Le, Jacob Mandelson, Matthew Richardson, Adam Rifkin, Paolo A.G. Sivilotti, Wesley Tanaka, and Luke Weisman 
Keyword: Distributed systems, collaborative environments.  
Date: March 8, 1996  
Address: Pasadena, California 91125  
Affiliation: California Institute of Technology 256-80  
Abstract: This paper describes the design of a distributed system built using Java that supports peer-to-peer communication among processes spread across a network. We identify the requirements of a software layer that supports distributed computing, and we propose a design that meets those requirements. Our primary concern is the identification, specification, and implementation of software components that can be composed in different ways to develop correct distributed applications. Though our implementation uses Java, the fundamental ideas apply to any object-oriented language that supports messaging and threads. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. D. Birrell. </author> <title> An introduction to programming with threads. </title> <type> Technical Report Report 35, </type> <institution> Digital Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: When a session terminates, component dapplets unlink themselves from each other. 3.2 Overall Distributed System Design Our distributed system implementation is written in the Java language [6], and uses Java socket classes [7] and thread primitives <ref> [1] </ref>. The initial implementation uses UDP [9, 10], and it includes a layer to ensure that messages are delivered in the order they were sent. We describe the overall design, and highlight the software components we believe are useful for developing distributed applications.
Reference: [2] <author> K. M. Chandy and C. Kesselman. </author> <title> Cc++: A declarative concurrent object-oriented programming notation. In Research Directions in Concurrent Object-Oriented Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Communication Layer Features. Our simple communication layer, when used with objects and threads, can provide features present in more complex systems. Some languages, such as CC++ <ref> [2] </ref>, have a two-level hierarchy of address spaces: a global address space and a collection of local address spaces. So, pointers are of two kinds: global and local. A global pointer in one local address space can point to an object in any local address space.
Reference: [3] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining the global states of distributed systems. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: The problem is that dapplets do not share a global clock. Though local clocks are quite accurate they are not perfectly synchronized. We can, however, use unsynchronized clocks for checkpointing provided they satisfy the global snapshot criterion <ref> [3] </ref>. The global snapshot criterion is satisfied provided every message that is sent when the senders clock is T is received when the receiver's clock exceeds T .
Reference: [4] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: Research issues for the two classes of distributed systems are somewhat different. The former class of distributed systems, the class on which human lives depend, is extremely important and has benefited from a great deal of research (c.f., the survey of critical distributed systems issues in <ref> [4] </ref>). This paper, however, deals with facilitating the development of the latter class of applications. The class of collaborative Web-based applications, though less critical than traditional distributed applications, has interesting engineering challenges nonetheless. Dapplets and Sessions. <p> A consortium of institutions forms a research center, and the executive committee of the center has members from its component institutions. The director of the center wants to pick a date and place for a meeting of the executive committee. Several algorithms (c.f., <ref> [4] </ref>) can be used to solve this problem. The traditional approach has the director (or someone on the staff) call each member of the committee repeatedly, and negotiate with each one in turn until an agreement is reached.
Reference: [5] <author> K. M. Chandy and P. A. G. Sivilotti. </author> <title> Toward high confidence distributed programming with java: Reliable thread libraries. </title> <booktitle> In International Conference on Software Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: We focus our discussion here on inter-dapplet services. Methods for coordination within a dapplet use standard Java classes <ref> [5] </ref>. The questions we address are: How can objects associated with a service be bound into a dapplet in a straightforward way, and, what sorts of services are helpful for dapplet designers? There are complementary ways of providing services to dapplets. <p> We have implemented and verified other kinds of synchronization constructs | barriers, single-assignment variables, channels, and semaphores | for threads within a dapplet <ref> [5] </ref>. We are extending these designs to allow synchronizations between threads in different dapplets in different address spaces. 5 Summary This paper identifies a class of distributed systems that is different from the traditional variety, and gives an analysis of the requirements of such systems.
Reference: [6] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. Addison-Wesley Developers Press, Sunsoft Java Series, </title> <year> 1996. </year>
Reference-contexts: We postpone consideration of which actions the initiator could take if a session cannot be established. When a session terminates, component dapplets unlink themselves from each other. 3.2 Overall Distributed System Design Our distributed system implementation is written in the Java language <ref> [6] </ref>, and uses Java socket classes [7] and thread primitives [1]. The initial implementation uses UDP [9, 10], and it includes a layer to ensure that messages are delivered in the order they were sent.
Reference: [7] <author> J. Gosling, F. Yellin, </author> <title> and the Java Team. The Java Application Programming Interface. Addison-Wesley Developers Press, Sunsoft Java Series, </title> <note> 1996. See also http://java.sun.com/JDK-beta2/api/java.net.Socket.html </note>
Reference-contexts: We postpone consideration of which actions the initiator could take if a session cannot be established. When a session terminates, component dapplets unlink themselves from each other. 3.2 Overall Distributed System Design Our distributed system implementation is written in the Java language [6], and uses Java socket classes <ref> [7] </ref> and thread primitives [1]. The initial implementation uses UDP [9, 10], and it includes a layer to ensure that messages are delivered in the order they were sent. We describe the overall design, and highlight the software components we believe are useful for developing distributed applications. <p> Dap-plet designers can separate the generic concerns of clock synchronization from other concerns specific to their application. 9 4.3 Synchronization Constructs Java provides constructs for synchronizing threads within a dapplet by using something like a monitor <ref> [7] </ref>. We have implemented and verified other kinds of synchronization constructs | barriers, single-assignment variables, channels, and semaphores | for threads within a dapplet [5].
Reference: [8] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: We can, however, use unsynchronized clocks for checkpointing provided they satisfy the global snapshot criterion [3]. The global snapshot criterion is satisfied provided every message that is sent when the senders clock is T is received when the receiver's clock exceeds T . A simple algorithm <ref> [8] </ref> to establish this criterion is: every message is timestamped with the sender's clock; upon receiving a message, if the receiver's clock value does not exceed the timestamp of the message, then the receiver's clock is set to a value greater than the timestamp.
Reference: [9] <author> J. Postel. </author> <title> User Datagram Protocol. </title> <type> RFC 768, </type> <pages> 3 pages, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: When a session terminates, component dapplets unlink themselves from each other. 3.2 Overall Distributed System Design Our distributed system implementation is written in the Java language [6], and uses Java socket classes [7] and thread primitives [1]. The initial implementation uses UDP <ref> [9, 10] </ref>, and it includes a layer to ensure that messages are delivered in the order they were sent. We describe the overall design, and highlight the software components we believe are useful for developing distributed applications.
Reference: [10] <author> W. R. Stevens. </author> <title> Unix Network Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1990. </year>
Reference-contexts: When a session terminates, component dapplets unlink themselves from each other. 3.2 Overall Distributed System Design Our distributed system implementation is written in the Java language [6], and uses Java socket classes [7] and thread primitives [1]. The initial implementation uses UDP <ref> [9, 10] </ref>, and it includes a layer to ensure that messages are delivered in the order they were sent. We describe the overall design, and highlight the software components we believe are useful for developing distributed applications.
Reference: [11] <author> A. S. Tanenbaum. </author> <title> Distributed Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1995. </year> <month> 10 </month>
Reference-contexts: The challenge is to provide the distributed infrastructure that sets up sessions that modify the persistent states of their participants, allows a member to participate in concurrent sessions, and ensures that sessions that interfere with each other are not scheduled concurrently. Composition of Services. A traditional distributed system <ref> [11] </ref> is architected in a series of well-defined layers, with each layer providing services to the layer above it and using services of the layer below. <p> Our focus in this paper is on the former approach; we give a few examples of service objects and show how these services can be used within a dapplet. 4.1 Tokens and Capabilities Distributed operating systems manage indivisible resources shared by processes <ref> [11] </ref>; we would like to provide service objects with this functionality, which a dapplet designer can incorporate as needed. A problem is that generic service objects do not have information about the specific resources used in a given application. A solution is to treat indivisible resources in a generic way.
References-found: 11

