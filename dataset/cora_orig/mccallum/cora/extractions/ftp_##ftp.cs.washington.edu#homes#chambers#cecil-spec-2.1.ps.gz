URL: ftp://ftp.cs.washington.edu/homes/chambers/cecil-spec-2.1.ps.gz
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/cecil-spec.html
Root-URL: 
Title: The Cecil Language Specification and Rationale Version 2.1  
Author: Craig Chambers 
Date: March 31, 1997  
Address: Box 352350, Seattle, Washington 98195-2350 USA  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract-found: 0
Intro-found: 1
Reference: [Agrawal et al. 91] <author> Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static Type Checking of Multi-Methods. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 113-128, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference-contexts: If all methods in a Cecil program specialized on their first argument only, Cecils type checking rules would reduce to those found in a traditional singly-dispatched language. Few multiply-dispatched languages support static type systems. Two that are most relevant are Polyglot <ref> [Agrawal et al. 91] </ref> and Kea [Mugridge et al. 91]. <p> Dylan supports a form of type declarations, but these are not checked statically, cannot be parameterized, and are treated both as argument specializers and type declarations, unlike Cecil where argument specializers and argument type declarations are distinct. Polyglot is a CLOS-like language with a static type system <ref> [Agrawal et al. 91] </ref>. However, the type system for Polyglot does not distinguish subtyping from code inheritance (classes are the same as types in Polyglot), does not support parameterized or parametrically polymorphic classes or methods, and does not support abstract methods or signatures.
Reference: [America & van der Linden 90] <author> Pierre America and Frank van der Linden. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 161-168, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: Trellis restricts the inheritance hierarchy to conform to the subtype hierarchy; it only supports isa-style superclasses. POOL is a statically-typed object-oriented language that distinguishes inheritance of implementation from inheritance of interface <ref> [America & van der Linden 90] </ref>. POOL generates types automatically from all class declarations (Cecil allows the programmer to restrict which objects may be used as types). Subtyping is implicit (structural) in POOL: all possible legal subtype relationships are assumed to be in force.
Reference: [Andersen & Reenskaug 92] <author> Egil P. Andersen and Trygve Reenskaug. </author> <title> System Design by Composing Structures of Interacting Objects. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 133-152, </pages> <address> Utrecht, the Netherlands, </address> <month> June/July </month> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: A module encapsulates its internal implementation details and presents an interface to external clients. This encapsulation mechanism is specially designed to work in the presence of multi-methods and inheritance/subtyping across module boundaries. Modules can be used to encapsulate roles <ref> [Andersen & Reenskaug 92] </ref> or subjects [Harrison & Ossher 93], programming idioms where pieces of the total interface of an object are split apart into application-specific facets. A given module can include method and field declarations that extend one or more previously-defined objects with additional specialized state and behavior.
Reference: [Apple 92] <author> Dylan, </author> <title> an Object-Oriented Dynamic Language. </title> <institution> Apple Computer, </institution> <month> April, </month> <year> 1992. </year>
Reference-contexts: Cecils mechanism differs from CLOSs in that in Cecil such a method also will apply to any children of the specializing object, while in CLOS the method will apply only for that object. Dylan, a descendant of CLOS, has a singleton specializer that is analogous to CLOSs eql specializer <ref> [Apple 92] </ref>. As mentioned in subsection 2.1.3, methods can be added to existing objects without needing to modify those existing objects. <p> Cecil offers a simpler, purer object model, optional static type checking, and encapsulation. CLOS and its predecessors include extensive support for method combination rules and reective operations [Kiczales et al. 91] not present in Cecil. Dylan <ref> [Apple 92] </ref> is a new language which can be viewed as a slimmed-down CLOS, based in a Scheme-like language instead of Common Lisp. Dylan is similar to CLOS in most of the respects described above, except that Dylan always accesses state through messages.
Reference: [Barnes 91] <author> J. G. P. Barnes. </author> <title> Programming in Ada, 3rd Edition. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1991. </year>
Reference-contexts: However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. A number of languages, including C++ [Stroustrup 86, Ellis & Stroustrup 90], Ada <ref> [Barnes 91] </ref>, and Haskell [Hudak et al. 90], support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments (and results, in the case of Ada) rather than on their dynamic types as would be required for true multiple dispatching.
Reference: [Black et al. 86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 78-86, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference: [Black & Hutchinson 90] <author> Andrew P. Black and Norman C. Hutchinson. </author> <title> Typechecking Polymorphism in Emerald. </title> <type> Technical report TR 90-34, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> December, </month> <year> 1990. </year>
Reference-contexts: This enables parameterized types to be used to describe patterns of types that are not necessarily subtypes of one another. Versions of F-bounded polymorphism have appeared in single-dispatching languages such as Emerald <ref> [Black & Hutchinson 90] </ref>, Axiom (formerly Scratchpad II) [Watt et al. 88, Jenks & Sutor 92], Strongtalk [Bracha & Griswold 93], and k-bench [Santas 93].
Reference: [Bobrow et al. 86] <author> Daniel G. Bobrow, Kenneth Kahn, Gregor Kiczales, Larry Masinter, Mark Stefik, and Frank Zdybel. CommonLoops: </author> <title> Merging Lisp and Object-Oriented Programming. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 17-29, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: However, linearization can produce unexpected method lookup results, especially if the program contains errors [Snyder 86]. CommonLoops <ref> [Bobrow et al. 86] </ref> and CLOS extend this linearization approach to multi-methods, totally ordering multi-methods by prioritizing argument position, with earlier argument positions completely dominating later argument positions. <p> However, Cecil does not incorporate dynamic inheritance, one of the most interesting features of Self; predicate objects are Cecils more structured but more restricted alternative to dynamic inheritance. Freeman-Benson independently developed a proposal for adding multi-methods to Self [Freeman-Benson 89]. Common Loops <ref> [Bobrow et al. 86] </ref> and CLOS [Bobrow et al. 88, Gabriel et al. 91] incorporate multi-methods in dynamically-typed class-based object-oriented extensions to Lisp. Method specializations (at least in CLOS) can be either on the class of the argument object or on its value.
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. Cecil was inspired initially by Self [Ungar & Smith 87, Hlzle et al. 91a], CLOS <ref> [Bobrow et al. 88, Gabriel et al. 91] </ref>, and Trellis [Schaffert et al. 85, Schaffert et al. 86]. <p> However, Cecil does not incorporate dynamic inheritance, one of the most interesting features of Self; predicate objects are Cecils more structured but more restricted alternative to dynamic inheritance. Freeman-Benson independently developed a proposal for adding multi-methods to Self [Freeman-Benson 89]. Common Loops [Bobrow et al. 86] and CLOS <ref> [Bobrow et al. 88, Gabriel et al. 91] </ref> incorporate multi-methods in dynamically-typed class-based object-oriented extensions to Lisp. Method specializations (at least in CLOS) can be either on the class of the argument object or on its value.
Reference: [Borning 86] <author> A. H. Borning. </author> <title> Classes Versus Prototypes in Object-Oriented Languages. </title> <booktitle> In Proceedings of the 1986 Fall Joint Computer Conference, </booktitle> <pages> pp. 36-40, </pages> <address> Dallas, TX, </address> <month> November, </month> <year> 1986. </year>
Reference: [Bracha & Griswold 93] <author> Gilad Bracha and David Griswold. Strongtalk: </author> <title> Typechecking Smalltalk in a Production Environment. </title> <booktitle> In OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 215-230, </pages> <address> Washington, D.C., </address> <month> September </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(10), </note> <month> October </month> <year> 1993. </year>
Reference-contexts: This enables parameterized types to be used to describe patterns of types that are not necessarily subtypes of one another. Versions of F-bounded polymorphism have appeared in single-dispatching languages such as Emerald [Black & Hutchinson 90], Axiom (formerly Scratchpad II) [Watt et al. 88, Jenks & Sutor 92], Strongtalk <ref> [Bracha & Griswold 93] </ref>, and k-bench [Santas 93].
Reference: [Canning et al. 89] <author> Peter S. Canning, William R. Cook, Walter L. Hill, John C. Mitchell, and William Olthoff. </author> <title> F-Bounded Quantification for Object-Oriented Programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1989. </year>
Reference-contexts: need to do for this case is to be able to describe that two objects come from related types, e.g., that both arguments to min are subtypes of number or that both are subtypes of the collection type instantiated with related types. 4.7.2 F-Bounded Polymorphism in Singly-Dispatched Languages F-bounded polymorphism <ref> [Canning et al. 89, Cook et al. 90] </ref> supports parameterization where the upper bound constraint of a type parameter can be a function of the type parameter itself. This enables parameterized types to be used to describe patterns of types that are not necessarily subtypes of one another.
Reference: [Cardelli & Wegner 85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <booktitle> In Computing Surveys 17(4), </booktitle> <pages> pp. 471-522, </pages> <month> December, </month> <year> 1985. </year>
Reference-contexts: If the &lt;= type upper bound is omitted, then &lt;= any is assumed. Similar facilities appear under the name of bounded quantification <ref> [Cardelli & Wegner 85] </ref> and constrained genericity [Meyer 86]. Type parameters are scoped over the whole declaration; type parameters must have distinct names.
Reference: [Castagna et al. 92] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A Calculus for Overloaded Functions with Subtyping. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 182-192, </pages> <address> San Francisco, </address> <month> June, </month> <year> 1992. </year> <note> Published as Lisp Pointers 5(1), January-March, </note> <year> 1992. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli [Ghelli 91], Castagna <ref> [Castagna et al. 92, Castagna 95] </ref>, and Pierce and Turner [Pierce & Turner 92, Pierce & Turner 93]. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Castagna 95] <author> Giuseppe Castagna. </author> <title> Covariance and Contravariance: Conict without a Cause. </title> <booktitle> In ACM Transactions on Programming Languages and Systems 17(3), </booktitle> <pages> pp. 431-447, </pages> <month> May </month> <year> 1995. </year> <month> 92 </month>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli [Ghelli 91], Castagna <ref> [Castagna et al. 92, Castagna 95] </ref>, and Pierce and Turner [Pierce & Turner 92, Pierce & Turner 93]. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Chambers et al. 89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 49-70, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Object representatives are analogous to concrete classes in a class-based language and maps in the Self implementation <ref> [Chambers et al. 89] </ref>.
Reference: [Chambers et al. 91] <author> Craig Chambers, David Ungar, Bay-Wei Chang, and Urs Hlzle. </author> <title> Parents are Shared Parts: Inheritance and Encapsulation in Self. In Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Furthermore, inheriting the instance variable part of the implementation of one data type into another is more difficult in Self than in class-based languages, relying on complex inheritance rules and dynamic inheritance <ref> [Chambers et al. 91] </ref> or programming environment support [Ungar 95]. Copy-down fields in Cecil solve these problems in Self without sacrificing the simple classless object model. <p> Our experience with Self also encourages us to strive for the simplest possible inheritance rules that are adequate. Even apparently straightforward extensions can have subtle interactions that make the extensions difficult to understand and use <ref> [Chambers et al. 91] </ref>. Complex inheritance patterns can hinder future program evolution, since method lookup can depend on program details such as parent ordering and argument ordering, and it usually is unclear from the program text which details are important for a particular application.
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference: [Chambers 92a] <author> Craig Chambers. </author> <title> The Design and Implementation of the Self Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> March, </month> <year> 1992. </year>
Reference-contexts: Other languages such as Scheme [Rees & Clinger 86] avoid the need for such a primitive by relying instead on user-level tail recursion and implementation-provided tail-recursion elimination. However, tail-recursion elimination precludes complete source-level debugging <ref> [Chambers 92a, Hlzle et al. 92] </ref> and consequently is undesirable in general. The primitive loop method may be viewed as a simple tail-recursive method for which the implementation has been instructed to perform tail-recursion elimination.
Reference: [Chambers 92b] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <pages> pp. 33-56, </pages> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science 615, Springer-Verlag, Berlin, </note> <year> 1992. </year>
Reference-contexts: 1 Introduction This document describes the current design of Cecil, an object-oriented language intended to support the rapid construction of high-quality, reusable, extensible software systems <ref> [Chambers 92b, Chambers 93b, Chambers & Leavens 94] </ref>. Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. <p> This has no semantic implication, but it helps to visually organize a collection of object and method 9 declarations in the absence of a more powerful graphical programming environment <ref> [Chambers 92b] </ref>. 2.2.1 Argument Specializers and Multi-Methods In Cecil, a method specifies the kinds of arguments for which its code is designed to work. <p> In ADT-based or singly-dispatched languages, direct access to an objects representation can be limited to a statically-determined region of the program. An earlier approach to encapsulation in Cecil suffered from the problem that privileged access could always be gained by writing methods that specialized on the desired data structures <ref> [Chambers 92b] </ref>. The Cecil module system has been designed to support integration of separately developed code, encapsulation, and modular design. This system can restrict access to parts of an implementation to a bounded region of program text while preserving the exibility of multi-methods.
Reference: [Chambers 93a] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical report #93-03-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> March, </month> <year> 1993. </year>
Reference-contexts: Cecil was inspired initially by Self [Ungar & Smith 87, Hlzle et al. 91a], CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis [Schaffert et al. 85, Schaffert et al. 86]. The current version of Cecil extends the earlier version <ref> [Chambers 93a] </ref> with predicate objects, modules, and efficient typechecking algorithms. 1.1 Design Goals and Major Features Cecils design results from several goals: Maximize the programmers ability to develop software quickly and to reuse and modify existing software easily.
Reference: [Chambers 93b] <author> Craig Chambers. </author> <title> Predicate Classes. </title> <booktitle> In ECOOP 93 Conference Proceedings, </booktitle> <pages> pp. 268-296, </pages> <address> Kaiserslautern, Germany, </address> <month> July, </month> <year> 1993. </year> <note> Published as Lecture Notes in Computer Science 707, Springer-Verlag, Berlin, </note> <year> 1993. </year>
Reference-contexts: 1 Introduction This document describes the current design of Cecil, an object-oriented language intended to support the rapid construction of high-quality, reusable, extensible software systems <ref> [Chambers 92b, Chambers 93b, Chambers & Leavens 94] </ref>. Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. <p> Moreover, the old semantics can be simulated with a combination of a copy-down field that accesses a shared field to get the fields initial value. 17 2.4 Predicate Objects To enable inheritance and classes to be used to capture run-time varying object behavior, Cecil support predicate objects <ref> [Chambers 93b] </ref>. Predicate objects are like normal objects except that they have an associated predicate expression.
Reference: [Chambers & Leavens 94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <booktitle> In OOPSLA 94 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year> <note> Published as SIGPLAN Notices 29(10), October 1994. An expanded and revised version to appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: 1 Introduction This document describes the current design of Cecil, an object-oriented language intended to support the rapid construction of high-quality, reusable, extensible software systems <ref> [Chambers 92b, Chambers 93b, Chambers & Leavens 94] </ref>. Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. <p> Conceptually, for each signature, the type checker enumerates all possible message representatives that are covered by the signature, where the arguments to the message representative are object representatives that conform to the signatures argument types. (A much more efficient algorithm to perform this checking is described elsewhere <ref> [Chambers & Leavens 94] </ref>.) For each message representative, the type checker simulates method lookup and checks that the simulated message would locate exactly one most-specific method. If no method is found, the type checker reports a signature implemented incompletely error.
Reference: [Chang & Ungar 90] <author> Bay-Wei Chang and David Ungar. </author> <title> Experiencing Self Objects: An Object-Based Artificial Reality. </title> <type> Unpublished manuscript, </type> <year> 1990. </year>
Reference: [Cook 89] <author> W. R. Cook. </author> <title> A Proposal for Making Eiffel Type-Safe. </title> <booktitle> In ECOOP 89 Conference Proceedings, </booktitle> <pages> pp. 57-70, </pages> <publisher> Cambridge University Press, </publisher> <month> July, </month> <year> 1989. </year>
Reference-contexts: Other times, a class reusing another classs code cannot or should not be considered a subtype; covariant redefinition as commonly occurs in Eiffel programs is one example of this case <ref> [Cook 89] </ref>. To increase exibility and expressiveness, Cecil separates subtyping from code inheritance. Types and signatures can be declared independently of object representations and method implementations.
Reference: [Cook et al. 90] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not Subtyping. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: In Cecil, the subtype graph is distinguished from the code inheritance graph, since type checking has different goals and requirements than have code reuse and module extension <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. To support the independent construction of subsystems, Cecil includes a module system. A module encapsulates its internal implementation details and presents an interface to external clients. <p> need to do for this case is to be able to describe that two objects come from related types, e.g., that both arguments to min are subtypes of number or that both are subtypes of the collection type instantiated with related types. 4.7.2 F-Bounded Polymorphism in Singly-Dispatched Languages F-bounded polymorphism <ref> [Canning et al. 89, Cook et al. 90] </ref> supports parameterization where the upper bound constraint of a type parameter can be a function of the type parameter itself. This enables parameterized types to be used to describe patterns of types that are not necessarily subtypes of one another.
Reference: [Cook 92] <author> William R. Cook. </author> <title> Interfaces and Specifications for the Smalltalk-80 Collection Classes. </title> <booktitle> In In OOPSLA 92 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Vancouver, Canada, </address> <month> October, </month> <year> 1992. </year> <note> Published as SIGPLAN Notices 27(10), </note> <month> October, </month> <year> 1992. </year>
Reference-contexts: However, there is merit in clearly separating the two concepts, and allowing inheritance of code from objects which are not legal supertypes. Studies have found this to be fairly common in dynamically-typed languages <ref> [Cook 92] </ref>. With the current Cecil design, the only way that an object might not be a legal (structural) subtype of an object from which it inherits is if the child overrides a method of the parent and restricts at least one argument type declaration, a relatively rare occurrence.
Reference: [Day et al. 95] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Meyers. </author> <title> Subtypes vs. Where Clauses: Constraining Parametric Polymorphism. </title> <booktitle> In Proceedings of the 1995 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 95), </booktitle> <pages> pp. 156-168, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil. Some more recent languages support some means for distinguishing subtyping from inheritance. These languages include Theta <ref> [Day et al. 95] </ref>, Java [Sun 95], and Sather [Omohundro 93]. Theta additionally supports an enhanced CLU-like where-clause mechanism that provides an alternative to F-bounded polymorphism. C++s private inheritance supports a kind of inheritance without subtyping. Several languages support some form of mixed static and dynamic type checking.
Reference: [Dean & Chambers 94] <author> Jeffrey Dean and Craig Chambers. </author> <title> Towards Better Inlining Decisions Using Inlining Trials. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pp. 273-282, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year> <note> Published as Lisp Pointers 7(3), July-September 1994. </note>
Reference: [Dean et al. 95a] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Selective Specialization in Object-Oriented Languages. </title> <booktitle> In Proceedings of the 1995 SIGPLAN Conference on Programming Language Design and Implementation (PLDI 95), </booktitle> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year> <month> 93 </month>
Reference: [Dean et al. 95b] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming (ECOOP 95), </booktitle> <address> rhus, Denmark, </address> <month> August </month> <year> 1995. </year>
Reference: [Ellis & Stroustrup 90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Similarly, particular applications may need to add application-specific behavior to objects defined as part of other applications. For example, a text-processing application may add specialized tab-to-space conversion behavior to strings and other collections of characters defined in the standard library. Other object-oriented languages such as C++ <ref> [Stroustrup 86, Ellis & Stroustrup 90] </ref> and Eiffel do not allow programmers to add behavior to existing classes without modifying the source code of the existing classes, and completely disallow adding behavior to built-in classes like strings. <p> However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. A number of languages, including C++ <ref> [Stroustrup 86, Ellis & Stroustrup 90] </ref>, Ada [Barnes 91], and Haskell [Hudak et al. 90], support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments (and results, in the case of Ada) rather than on their dynamic types as would
Reference: [Freeman-Benson 89] <author> Bjorn N. Freeman-Benson. </author> <title> A Proposal for Multi-Methods in Self. </title> <type> Unpublished manuscript, </type> <month> December, </month> <year> 1989. </year>
Reference-contexts: Cecils model of object creation is different than Selfs. However, Cecil does not incorporate dynamic inheritance, one of the most interesting features of Self; predicate objects are Cecils more structured but more restricted alternative to dynamic inheritance. Freeman-Benson independently developed a proposal for adding multi-methods to Self <ref> [Freeman-Benson 89] </ref>. Common Loops [Bobrow et al. 86] and CLOS [Bobrow et al. 88, Gabriel et al. 91] incorporate multi-methods in dynamically-typed class-based object-oriented extensions to Lisp. Method specializations (at least in CLOS) can be either on the class of the argument object or on its value.
Reference: [Gabriel et al. 91] <author> Richard P. Gabriel, Jon L White, and Daniel G. Bobrow. </author> <title> CLOS: </title> <booktitle> Integrating Object-Oriented and Functional Programming. In Communications of the ACM 34(9), </booktitle> <pages> pp. 28-38, </pages> <month> September, </month> <year> 1991. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. Cecil was inspired initially by Self [Ungar & Smith 87, Hlzle et al. 91a], CLOS <ref> [Bobrow et al. 88, Gabriel et al. 91] </ref>, and Trellis [Schaffert et al. 85, Schaffert et al. 86]. <p> However, Cecil does not incorporate dynamic inheritance, one of the most interesting features of Self; predicate objects are Cecils more structured but more restricted alternative to dynamic inheritance. Freeman-Benson independently developed a proposal for adding multi-methods to Self [Freeman-Benson 89]. Common Loops [Bobrow et al. 86] and CLOS <ref> [Bobrow et al. 88, Gabriel et al. 91] </ref> incorporate multi-methods in dynamically-typed class-based object-oriented extensions to Lisp. Method specializations (at least in CLOS) can be either on the class of the argument object or on its value.
Reference: [Ghelli 91] <author> Giorgio Ghelli. </author> <title> A Static Type System for Message Passing. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 129-145, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli <ref> [Ghelli 91] </ref>, Castagna [Castagna et al. 92, Castagna 95], and Pierce and Turner [Pierce & Turner 92, Pierce & Turner 93].
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: A non-local return returns to the caller of the closest lexically-enclosing non-closure method rather than to the caller of the eval method, just like a non-local return in Smalltalk-80 * <ref> [Goldberg & Robson 83] </ref> and Self and similar to a return statement in C.
Reference: [Goldberg 84] <author> Adele Goldberg. </author> <title> Smalltalk-80: The Interactive Programming Environment. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1984. </year>
Reference: [Grove et al. 95] <author> David Grove, Jeffrey Dean, Charles Garrett, and Craig Chambers. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> In Proceedings of the 1995 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 95), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference: [Grove 95] <author> David Grove. </author> <title> The Impact of Interprocedural Class Analysis on Optimization. </title> <booktitle> In Proceedings of CASCON 95, </booktitle> <pages> pp. 195-203, </pages> <address> Toronto, Canada, </address> <month> November </month> <year> 1995. </year>
Reference: [Halbert & OBrien 86] <author> Daniel C. Halbert and Patrick D. OBrien. </author> <title> Using Types and Inheritance in Object-Oriented Languages. </title> <type> Technical report DEC-TR-437, </type> <institution> Digital Equipment Corp., </institution> <month> April, </month> <year> 1986. </year>
Reference-contexts: In Cecil, the subtype graph is distinguished from the code inheritance graph, since type checking has different goals and requirements than have code reuse and module extension <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. To support the independent construction of subsystems, Cecil includes a module system. A module encapsulates its internal implementation details and presents an interface to external clients.
Reference: [Harbison 92] <author> Samuel P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: BETA uses the same syntax to access both global variables and inherited instance variables, making the semantics of the construct somewhat more complicated. 36 Nested methods can be used to achieve the effect of a typecase statement as found in other languages, including Trellis and Modula-3 <ref> [Nelson 91, Harbison 92] </ref>. <p> Cedar supports a similar mechanism through its REF ANY type [Teitelman 84]. Modula-3 retains the REFANY type and includes several operations including NARROW and TYPECASE that can produce a more precisely-typed value from a REFANY type <ref> [Nelson 91, Harbison 92] </ref>. Cecil provides better support for exploratory programming than these other languages since there is no source code overhead for using dynamic typing: variable type declarations are simply omitted, and coercions between dynamically-typed expressions and statically-typed variables are implicit.
Reference: [Harrison & Ossher 90] <author> William Harrison and Harold Ossher. </author> <title> Subdivided Procedures: A Language Extension Supporting Extensible Programming. </title> <booktitle> In Proceedings of the 1990 International Conference on Computer Languages, </booktitle> <pages> pp. 190-197, </pages> <address> New Orleans, LA, </address> <month> March, </month> <year> 1990. </year>
Reference-contexts: The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations <ref> [Harrison & Ossher 90] </ref>. However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers.
Reference: [Harrison & Ossher 93] <author> William Harrison and Harold Ossher. </author> <title> Subject-Oriented Programming (A Critique of Pure Objects). </title> <booktitle> In OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 411-428, </pages> <address> Washington, D.C., </address> <month> September </month> <year> 1993. </year> <note> Published as SIGPLAN Notices 28(10), </note> <month> October </month> <year> 1993. </year>
Reference-contexts: A module encapsulates its internal implementation details and presents an interface to external clients. This encapsulation mechanism is specially designed to work in the presence of multi-methods and inheritance/subtyping across module boundaries. Modules can be used to encapsulate roles [Andersen & Reenskaug 92] or subjects <ref> [Harrison & Ossher 93] </ref>, programming idioms where pieces of the total interface of an object are split apart into application-specific facets. A given module can include method and field declarations that extend one or more previously-defined objects with additional specialized state and behavior. Cecil includes other kinds of static declarations.
Reference: [Hlzle et al. 91a] <author> Urs Hlzle, Bay-Wei Chang, Craig Chambers, Ole Agesen, and David Ungar. </author> <title> The Self Manual, </title> <note> Version 1.1. Unpublished manual, </note> <month> February, </month> <year> 1991. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. Cecil was inspired initially by Self <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>, CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis [Schaffert et al. 85, Schaffert et al. 86]. <p> ; module_names ::= module_name -, module_name-module_name ::= name import_decl ::= [privacy] import [friend] module_names ; Also, most declarations have an optional privacy annotation allowed. [The precise semantics of modules is still under development.] 87 6 Related Work Cecil builds upon much of the work done with the Self programming language <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>. Self offers a simple, pure, classless object model with state accessed via message passing just like methods. Cecil extends Self with multi-methods, copy-down and initialize-only data slots, lexically-scoped local methods and fields, object extensions, static typing, and a module system.
Reference: [Hlzle et al. 91b] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Programming Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91 Conference Proceedings, </booktitle> <pages> pp. 21-38, </pages> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference: [Hlzle et al. 92] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Debugging Optimized Code with Dynamic Deoptimization. </title> <booktitle> To appear in Proceedings of the SIGPLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <address> San Francisco, CA, </address> <month> June, </month> <year> 1992. </year>
Reference-contexts: Other languages such as Scheme [Rees & Clinger 86] avoid the need for such a primitive by relying instead on user-level tail recursion and implementation-provided tail-recursion elimination. However, tail-recursion elimination precludes complete source-level debugging <ref> [Chambers 92a, Hlzle et al. 92] </ref> and consequently is undesirable in general. The primitive loop method may be viewed as a simple tail-recursive method for which the implementation has been instructed to perform tail-recursion elimination.
Reference: [Hlzle 93] <author> Urs Hlzle. </author> <title> Integrating Independently-Developed Components in Object-Oriented Languages. </title> <booktitle> In ECOOP 93 Conference Proceedings, </booktitle> <pages> pp. 36-56, </pages> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1993. </year> <note> Published as Lecture Notes in Computer Science 707, Springer-Verlag, Berlin, </note> <year> 1993. </year>
Reference-contexts: Allowing types to be extended externally to have additional supertypes allows third-parties to integrate separately-developed libraries without modifying the separate libraries directly <ref> [Hlzle 93] </ref>. 3.3.4 Signature Declarations Signatures can be declared using the following syntax: signature_decl ::= signature method_name ( [arg_types] ) [type_decl] ; arg_types ::= arg_type - , arg_type - arg_type ::= [[name] :] type type_decl ::= : type The names of formals in a signature are for documentation purposes only; they
Reference: [Hudak et al. 90] <author> Paul Hudak, Philip Wadler, Arvind, Brian Boutel, Jon Fairbairn, Joseph Fasel, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Simon Peyton Jones, Mike Reeve, David Wise, Jonathan Young. </author> <title> Report on the Programming Language Haskell, </title> <note> Version 1.0. Unpublished manual, </note> <month> April, </month> <year> 1990. </year> <month> 94 </month>
Reference-contexts: However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. A number of languages, including C++ [Stroustrup 86, Ellis & Stroustrup 90], Ada [Barnes 91], and Haskell <ref> [Hudak et al. 90] </ref>, support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments (and results, in the case of Ada) rather than on their dynamic types as would be required for true multiple dispatching.
Reference: [Hutchinson 87] <author> Norman C. Hutchinson. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> Ph.D. thesis, </type> <institution> University of Washington, </institution> <month> January, </month> <year> 1987. </year>
Reference: [Hutchinson et al. 87] <author> Norman C. Hutchinson, Rajendra K. Raj, Andrew P. Black, Henry M. Levy, and Eric Jul. </author> <title> The Emerald Programming Language Report. </title> <type> Technical Report 87-10-07, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> October, </month> <year> 1987. </year>
Reference: [Ingalls 86] <author> Daniel H. H. Ingalls. </author> <title> A Simple Technique for Handling Multiple Polymorphism. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 347-349, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference: [Jenks & Sutor 92] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> Axiom: the Scientific Computing System. </title> <publisher> Springer-Verlag. </publisher> <year> 1992. </year>
Reference-contexts: Types cannot have default implementations; only object representations can have methods attached. In other languages, such as Axiom (formerly Scratchpad II) <ref> [Watt et al., Jenks & Sutor 92] </ref>, default implementations can be stored with the type (called the category in Axiom). However, in Axiom method lookup rules are complicated by the possibility of methods being inherited both from superclasses and from categories, i.e., along both inheritance and subtyping links. <p> This enables parameterized types to be used to describe patterns of types that are not necessarily subtypes of one another. Versions of F-bounded polymorphism have appeared in single-dispatching languages such as Emerald [Black & Hutchinson 90], Axiom (formerly Scratchpad II) <ref> [Watt et al. 88, Jenks & Sutor 92] </ref>, Strongtalk [Bracha & Griswold 93], and k-bench [Santas 93].
Reference: [Kiczales et al. 91] <author> Gregor Kiczales, James des Rivires, and Daniel G. Bobrow. </author> <title> The Art of the Meta-Object Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Cecil offers a simpler, purer object model, optional static type checking, and encapsulation. CLOS and its predecessors include extensive support for method combination rules and reective operations <ref> [Kiczales et al. 91] </ref> not present in Cecil. Dylan [Apple 92] is a new language which can be viewed as a slimmed-down CLOS, based in a Scheme-like language instead of Common Lisp.
Reference: [Kristensen et al. 87] <author> B. B. Kristensen, Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> The BETA Programming Language. </title> <booktitle> In Research Directions in Object-Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Once this augmented inheritance graph is constructed, method lookup proceeds as before without reference to the scope in which some object or method is defined. Other languages, such as BETA <ref> [Kristensen et al. 87] </ref>, take the opposite approach, searching for a matching method in one scope before proceeding to the enclosing scope. If a matching method is found in one scope, it is selected even if a more specialized method is defined in an enclosing scope.
Reference: [LaLonde et al. 86] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> An Exemplar Based Smalltalk. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 322-330, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference: [Leavens 89] <author> Gary Todd Leavens. </author> <title> Verifying Object-Oriented Programs that use Subtypes. </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <year> 1989. </year>
Reference-contexts: It appears that Kea has a notion of abstract methods as well. Leavens describes a statically-typed applicative language NOAL that supports multi-methods using run-time overloading on the declared argument types of methods <ref> [Leavens 89, Leavens & Weihl 90] </ref>.
Reference: [Leavens & Weihl 90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-Oriented Programs that use Subtypes. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 212-223, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: It appears that Kea has a notion of abstract methods as well. Leavens describes a statically-typed applicative language NOAL that supports multi-methods using run-time overloading on the declared argument types of methods <ref> [Leavens 89, Leavens & Weihl 90] </ref>.
Reference: [Lieberman 86] <author> Henry Lieberman. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 214-223, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: In class-based languages, instance variables declared in a superclass are automatically copied down into subclasses; the declaration is inherited, not the variables contents. Class variables, on the other hand, are shared among the class, its instances, and its subclasses. In some prototype-based languages, including Self and Actra <ref> [Lieberman 86] </ref>, instance variables of one object are not copied down into inheriting objects; rather, these variables are shared, much like class variables in a class-based language.
Reference: [Lieberman et al. 87] <author> Henry Lieberman, Lynn Andrea Stein, and David Ungar. </author> <booktitle> The Treaty of Orlando. In Addendum to the OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 43-44, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 23(5), </note> <month> May, </month> <year> 1988. </year>
Reference: [Liskov et al. 77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and J. Craig Schaffert. </author> <title> Abstraction Mechanisms in CLU. </title> <booktitle> In Communications of the ACM 20(8), </booktitle> <pages> pp. 564-576, </pages> <month> August, </month> <year> 1977. </year>
Reference-contexts: Theta additionally supports an enhanced CLU-like where-clause mechanism that provides an alternative to F-bounded polymorphism. C++s private inheritance supports a kind of inheritance without subtyping. Several languages support some form of mixed static and dynamic type checking. For example, CLU <ref> [Liskov et al. 77, Liskov et al. 81] </ref> allows variables to be declared to be of type any.
Reference: [Liskov et al. 81] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, Eliot Moss, J. Craig Schaffert, Robert Scheier, and Alan Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Theta additionally supports an enhanced CLU-like where-clause mechanism that provides an alternative to F-bounded polymorphism. C++s private inheritance supports a kind of inheritance without subtyping. Several languages support some form of mixed static and dynamic type checking. For example, CLU <ref> [Liskov et al. 77, Liskov et al. 81] </ref> allows variables to be declared to be of type any.
Reference: [Meyer 86] <author> Bertrand Meyer. </author> <title> Genericity versus Inheritance. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 391-405, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: If the &lt;= type upper bound is omitted, then &lt;= any is assumed. Similar facilities appear under the name of bounded quantification [Cardelli & Wegner 85] and constrained genericity <ref> [Meyer 86] </ref>. Type parameters are scoped over the whole declaration; type parameters must have distinct names.
Reference: [Meyer 88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Inheriting from the same ancestor more than once, either directly or indirectly, has no effect other than to place the ancestor in relation to other ancestors; Cecil has no repeated inheritance as in Eiffel <ref> [Meyer 88, Meyer 92] </ref>. An object need not have any (explicit) parents; all objects are considered to inherit from the predefined any object (see section 2.1.4). The inheritance graph must be acyclic. Inheritance in Cecil requires a child to accept all of the fields and methods defined in the parents.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Inheriting from the same ancestor more than once, either directly or indirectly, has no effect other than to place the ancestor in relation to other ancestors; Cecil has no repeated inheritance as in Eiffel <ref> [Meyer 88, Meyer 92] </ref>. An object need not have any (explicit) parents; all objects are considered to inherit from the predefined any object (see section 2.1.4). The inheritance graph must be acyclic. Inheritance in Cecil requires a child to accept all of the fields and methods defined in the parents.
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Even so, the expression x ** y ** z would parse backwards in Self, if ** were defined. (Self uses power: for exponentiation, perhaps to avoid problems like this.) Also, expressions like x + y - z are illegal in Self, requiring explicit parenthesization. Standard ML <ref> [Milner et al. 90] </ref> allows any operator to be declared prefix (called nonfix in SML) or infix, and infix operators can be declared left or right-associative. Infix declarations also specify a precedence level, which is an integer from 0 (loosest binding) to 9 (tightest binding), with 0 being the default. <p> Like explicit type parameters, implicit type parameters may be used in the type declarations of earlier formal arguments, as in the prepend method above, as long as no cyclic dependencies result. Implicit type parameters are akin to polymorphic type variables in languages like ML <ref> [Milner et al. 90] </ref>. Note that unlike 'a type variables in ML, the back-quote in Cecils T is not part of the type name, but rather identifies that the use of the type T is a binding occurrence as opposed to a simple use of a previously-defined type. <p> Emerald is not based on multiple dispatching and in fact does not include support for inheritance of implementation. Types in Emerald are arranged in a subtype lattice, however. * Formerly known as Owl and Trellis/Owl. 89 Rapide [Mitchell et al. 91] is an extension of Standard ML modules <ref> [Milner et al. 90] </ref> with subtyping and inheritance. Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil. Some more recent languages support some means for distinguishing subtyping from inheritance.
Reference: [Mitchell et al. 91] <author> John Mitchell, Sigurd Meldal, and Neel Hadhav. </author> <title> An Extension of Standard ML Modules with Subtyping and Inheritance. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> Williamsburg, VA, </address> <month> January, </month> <year> 1991. </year>
Reference-contexts: Emerald is not based on multiple dispatching and in fact does not include support for inheritance of implementation. Types in Emerald are arranged in a subtype lattice, however. * Formerly known as Owl and Trellis/Owl. 89 Rapide <ref> [Mitchell et al. 91] </ref> is an extension of Standard ML modules [Milner et al. 90] with subtyping and inheritance. Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil.
Reference: [Moon 86] <author> David A. Moon. </author> <title> Object-Oriented Programming with Flavors. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 1-8, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year> <month> 95 </month>
Reference-contexts: Consequently, the key distinguishing characteristic of method lookup in a language with multiple inheritance and/or multiple dispatching is how exactly this ambiguity problem is resolved. Some languages resolve all ambiguities automatically. For example, Flavors <ref> [Moon 86] </ref> linearizes the class hierarchy, producing a total ordering on classes, derived from each class local left-to-right ordering of superclasses, that can be searched without ambiguity just as in the single inheritance case. However, linearization can produce unexpected method lookup results, especially if the program contains errors [Snyder 86].
Reference: [Mugridge et al. 91] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-Methods in a Statically-Typed Programming Language. </title> <type> Technical report #50, </type> <institution> Department of Computer Science, University of Auckland, </institution> <year> 1991. </year> <booktitle> Also in ECOOP 91 Conference Proceedings, </booktitle> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: If all methods in a Cecil program specialized on their first argument only, Cecils type checking rules would reduce to those found in a traditional singly-dispatched language. Few multiply-dispatched languages support static type systems. Two that are most relevant are Polyglot [Agrawal et al. 91] and Kea <ref> [Mugridge et al. 91] </ref>. In both of these systems, type checking of method consistency and completeness requires that all related methods (all methods in the same generic function in Polyglot and all variants of a function in Kea) be available to the type checker, just as does Cecil. <p> This requirement is similar to that of Cecil that the whole program be available at type-check-time to guarantee that two multi-methods are not mutually ambiguous for some set of argument objects. Kea is a higher-order polymorphic functional language supporting multi-methods <ref> [Mugridge et al. 91] </ref>. Like Polyglot (and most other object-oriented languages), inheritance and subtyping in Kea 88 are unified. Keas type checking of multi-methods is similar to Cecils in that multi-methods must be both complete and consistent. It appears that Kea has a notion of abstract methods as well.
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: BETA uses the same syntax to access both global variables and inherited instance variables, making the semantics of the construct somewhat more complicated. 36 Nested methods can be used to achieve the effect of a typecase statement as found in other languages, including Trellis and Modula-3 <ref> [Nelson 91, Harbison 92] </ref>. <p> Cedar supports a similar mechanism through its REF ANY type [Teitelman 84]. Modula-3 retains the REFANY type and includes several operations including NARROW and TYPECASE that can produce a more precisely-typed value from a REFANY type <ref> [Nelson 91, Harbison 92] </ref>. Cecil provides better support for exploratory programming than these other languages since there is no source code overhead for using dynamic typing: variable type declarations are simply omitted, and coercions between dynamically-typed expressions and statically-typed variables are implicit.
Reference: [Omohundro 93] <author> Stephen Omohundro. </author> <title> The Sather 1.0 Specification. Unpublished manual, </title> <month> June </month> <year> 1993. </year>
Reference-contexts: Sather is a notable exception, allowing a new class to be defined which is a superclass of some existing classes <ref> [Omohundro 93] </ref>. Section 3.3.3 explains how object extensions are particularly useful to declare that two objects, provided by two independent vendors, are subtypes of some third abstract type. <p> Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil. Some more recent languages support some means for distinguishing subtyping from inheritance. These languages include Theta [Day et al. 95], Java [Sun 95], and Sather <ref> [Omohundro 93] </ref>. Theta additionally supports an enhanced CLU-like where-clause mechanism that provides an alternative to F-bounded polymorphism. C++s private inheritance supports a kind of inheritance without subtyping. Several languages support some form of mixed static and dynamic type checking.
Reference: [Pierce & Turner 92] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Statically Typed Multi-Methods via Partially Abstract Types. </title> <type> Unpublished manuscript, </type> <month> October, </month> <year> 1992. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli [Ghelli 91], Castagna [Castagna et al. 92, Castagna 95], and Pierce and Turner <ref> [Pierce & Turner 92, Pierce & Turner 93] </ref>. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Pierce & Turner 93] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Object-Oriented Programming Without Recursive Types. </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1993. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli [Ghelli 91], Castagna [Castagna et al. 92, Castagna 95], and Pierce and Turner <ref> [Pierce & Turner 92, Pierce & Turner 93] </ref>. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Rees & Clinger 86] <editor> Jonathan Rees and William Clinger, editors. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme. </title> <booktitle> In SIGPLAN Notices 21(12), </booktitle> <month> December, </month> <year> 1986. </year>
Reference-contexts: Looping primitive behavior is provided by the loop primitive method specialized on the closure predefined object. This method repeatedly invokes its argument closure until some closure performs a non-local return to break out of the loop. Other languages such as Scheme <ref> [Rees & Clinger 86] </ref> avoid the need for such a primitive by relying instead on user-level tail recursion and implementation-provided tail-recursion elimination. However, tail-recursion elimination precludes complete source-level debugging [Chambers 92a, Hlzle et al. 92] and consequently is undesirable in general.
Reference: [Rouaix 90] <author> Francois Rouaix. </author> <title> Safe Run-Time Overloading. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 355-366, </pages> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix <ref> [Rouaix 90] </ref>, Ghelli [Ghelli 91], Castagna [Castagna et al. 92, Castagna 95], and Pierce and Turner [Pierce & Turner 92, Pierce & Turner 93].
Reference: [Santas 93] <author> Philip S. Santas. </author> <title> A Type System for Computer Algebra. </title> <booktitle> In International Symposium on Symbolic and Algebraic Computation. </booktitle> <year> 1993. </year>
Reference-contexts: Versions of F-bounded polymorphism have appeared in single-dispatching languages such as Emerald [Black & Hutchinson 90], Axiom (formerly Scratchpad II) [Watt et al. 88, Jenks & Sutor 92], Strongtalk [Bracha & Griswold 93], and k-bench <ref> [Santas 93] </ref>.
Reference: [Schaffert et al. 85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical report DEC-TR-372, </type> <month> November, </month> <year> 1985. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. Cecil was inspired initially by Self [Ungar & Smith 87, Hlzle et al. 91a], CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>. <p> Trellis * supports an expressive, safe static type system <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>. Cecils parameterized type system includes features not present in Trellis, such as implicitly-bound type variables and uniform treatment of constrained type variables. Trellis restricts the inheritance hierarchy to conform to the subtype hierarchy; it only supports isa-style superclasses.
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. Cecil was inspired initially by Self [Ungar & Smith 87, Hlzle et al. 91a], CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>. <p> Trellis * supports an expressive, safe static type system <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>. Cecils parameterized type system includes features not present in Trellis, such as implicitly-bound type variables and uniform treatment of constrained type variables. Trellis restricts the inheritance hierarchy to conform to the subtype hierarchy; it only supports isa-style superclasses.
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 38-45, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: In Cecil, the subtype graph is distinguished from the code inheritance graph, since type checking has different goals and requirements than have code reuse and module extension <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. To support the independent construction of subsystems, Cecil includes a module system. A module encapsulates its internal implementation details and presents an interface to external clients. <p> However, linearization can produce unexpected method lookup results, especially if the program contains errors <ref> [Snyder 86] </ref>. CommonLoops [Bobrow et al. 86] and CLOS extend this linearization approach to multi-methods, totally ordering multi-methods by prioritizing argument position, with earlier argument positions completely dominating later argument positions. <p> In most object-oriented languages, the code inheritance graph and the subtyping graph are joined: a class is a subtype of another class if and only if it inherits from that other class. Sometimes this constraint becomes awkward <ref> [Snyder 86] </ref>, for example when a class supports the interface of some other class or type, but does not wish to inherit any code.
Reference: [Steele 84] <author> Guy L. Steele Jr. </author> <title> Common LISP. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: This avoids potential misunderstandings about the meaning of apparently self-referential or mutually recursive initializers while still supporting a kind of let* <ref> [Steele 84] </ref> variable binding sequence. 24 Variable declarations may appear at the top level as well as inside a method. However, the ordering of variable declarations at the top level (and consequently the order of evaluation of the initializing expressions) is less well defined.
Reference: [Stroustrup 86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Similarly, particular applications may need to add application-specific behavior to objects defined as part of other applications. For example, a text-processing application may add specialized tab-to-space conversion behavior to strings and other collections of characters defined in the standard library. Other object-oriented languages such as C++ <ref> [Stroustrup 86, Ellis & Stroustrup 90] </ref> and Eiffel do not allow programmers to add behavior to existing classes without modifying the source code of the existing classes, and completely disallow adding behavior to built-in classes like strings. <p> However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. A number of languages, including C++ <ref> [Stroustrup 86, Ellis & Stroustrup 90] </ref>, Ada [Barnes 91], and Haskell [Hudak et al. 90], support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments (and results, in the case of Ada) rather than on their dynamic types as would
Reference: [Sun 95] <author> Sun Microsystems. </author> <title> The Java Language Specification. Unpublished manual, </title> <month> May </month> <year> 1995. </year>
Reference-contexts: Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil. Some more recent languages support some means for distinguishing subtyping from inheritance. These languages include Theta [Day et al. 95], Java <ref> [Sun 95] </ref>, and Sather [Omohundro 93]. Theta additionally supports an enhanced CLU-like where-clause mechanism that provides an alternative to F-bounded polymorphism. C++s private inheritance supports a kind of inheritance without subtyping. Several languages support some form of mixed static and dynamic type checking.
Reference: [Teitelman 84] <author> Warren Teitelman. </author> <title> The Cedar Programming Environment: A Midterm Report and Examination. </title> <note> Xerox PARC technical report CSL-83-11, </note> <month> June, </month> <year> 1984. </year>
Reference-contexts: Any expression may be assigned to a variable of type any, but any assignments of an expression of type any to an expression of another type must be explicitly coerced using the parameterized force procedure. Cedar supports a similar mechanism through its REF ANY type <ref> [Teitelman 84] </ref>. Modula-3 retains the REFANY type and includes several operations including NARROW and TYPECASE that can produce a more precisely-typed value from a REFANY type [Nelson 91, Harbison 92].
Reference: [Touretzky 86] <author> D. Touretzky. </author> <title> The Mathematics of Inheritance Systems. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: Accordingly, we have striven for a very simple system of multiple inheritance and multiple dispatching for Cecil. 2.7.2 Semantics Method lookup in Cecil uses a form of Touretzkys inferential distance heuristic <ref> [Touretzky 86] </ref>, where children override parents.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless object model, multiple dispatching (multi-methods), modules, and mixed static and dynamic type checking. Cecil was inspired initially by Self <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>, CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis [Schaffert et al. 85, Schaffert et al. 86]. <p> To illustrate, the following method resolves the ambiguity of height for vlsi_cell in favor of the rectangle version of height: * * This example was adapted from Ungar and Smiths original Self paper <ref> [Ungar & Smith 87] </ref>. 38 object rectangle; field height (@rectangle); object tree_node; method height (t@tree_node) - 1 + height (t.parent) - object vlsi_cell isa rectangle, tree_node; method height (v@vlsi_cell) - resend (v@rectangle) - This model of undirected and directed resends is a simplification of the Self rules, extended to the multiple <p> ; module_names ::= module_name -, module_name-module_name ::= name import_decl ::= [privacy] import [friend] module_names ; Also, most declarations have an optional privacy annotation allowed. [The precise semantics of modules is still under development.] 87 6 Related Work Cecil builds upon much of the work done with the Self programming language <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>. Self offers a simple, pure, classless object model with state accessed via message passing just like methods. Cecil extends Self with multi-methods, copy-down and initialize-only data slots, lexically-scoped local methods and fields, object extensions, static typing, and a module system.
Reference: [Ungar et al. 91] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Hlzle. </author> <title> Organizing Programs without Classes. In Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Similarly, Cecils classless object model is designed so that a single object declaration can define an entire data type. This contrasts with the situation in Self, where two objects are needed to define most data types <ref> [Ungar et al. 91] </ref>. Similarly, Cecils object model supports both concise inheritance of representation and concise overriding of representation, unlike most class-based object-oriented languages which only support the former and most classless object-oriented languages which only conveniently support the latter. Finally, Cecil avoids requiring annotations for exploratory programming. <p> object-specific state, most data types are actually defined with two objects: one object, the prototype, includes all the instance-specific variables that objects of the data type need, while the other object, the traits object, is inherited by the prototype and holds the methods and shared state of the data type <ref> [Ungar et al. 91] </ref>. New Self objects are created by cloning (shallow-copying) a prototype, thus giving new objects their own instance variables while sharing the parent traits object and its methods and state.
Reference: [Ungar 95] <author> David Ungar. </author> <title> Annotating Objects for Transport to Other Worlds. </title> <booktitle> In Proceedings of the 1995 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 95), </booktitle> <pages> pp. 73-87, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Furthermore, inheriting the instance variable part of the implementation of one data type into another is more difficult in Self than in class-based languages, relying on complex inheritance rules and dynamic inheritance [Chambers et al. 91] or programming environment support <ref> [Ungar 95] </ref>. Copy-down fields in Cecil solve these problems in Self without sacrificing the simple classless object model. In Cecil, only one object needs to be defined for a given data type, and the field declarations can be in the same place as the method declarations that access them.
Reference: [Watt et al. 88] <author> Steven M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> The Scratchpad II Type System: Domains and Subdomains. </title> <booktitle> In Proceedings of the International Workshop on Scientific Computation, </booktitle> <address> Capri, Italy, </address> <year> 1988. </year> <title> Published in Computing Tools for Scientific Problem Solving, </title> <editor> A. M. Miola, ed., </editor> <publisher> Academic Press, </publisher> <year> 1990. </year> <month> 96 </month>
Reference-contexts: This enables parameterized types to be used to describe patterns of types that are not necessarily subtypes of one another. Versions of F-bounded polymorphism have appeared in single-dispatching languages such as Emerald [Black & Hutchinson 90], Axiom (formerly Scratchpad II) <ref> [Watt et al. 88, Jenks & Sutor 92] </ref>, Strongtalk [Bracha & Griswold 93], and k-bench [Santas 93].
References-found: 87

