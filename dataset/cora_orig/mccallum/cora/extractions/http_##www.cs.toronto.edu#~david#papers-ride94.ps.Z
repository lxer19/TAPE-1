URL: http://www.cs.toronto.edu/~david/papers-ride94.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: fdavid,chomickig@cis.ksu.edu  
Title: Implementing Temporal Integrity Constraints Using an Active DBMS  
Author: David Toman Jan Chomicki 
Address: 66506  
Affiliation: Department of Computing and Information Science Kansas State University, Manhattan, KS  
Abstract: The system presented in this paper allows automatic and efficient translation of integrity constraints formulated in past temporal logic into rules of the Starburst DBMS. During the compilation the set of constraints is checked for the safe evaluation property. The result of the compilation is a set of Starburst SQL statements that define all the necessary rules needed for enforcing the given constraints. There is no need for an additional runtime constraint monitor. When the rules are activated, all updates to the database that violate any of the constraints are automatically rejected (i.e., the corresponding transaction is aborted). In addition to efficient implementation, this approach offers a clean separation of application programs and the integrity checking code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Chomicki J.. </author> <title> History-less Checking of Dynamic Integrity Constraints. </title> <booktitle> IEEE International Conference on Data Engineering, </booktitle> <address> Phoenix AZ, </address> <month> Febru-ary </month> <year> 1992. </year>
Reference-contexts: To achieve efficient implementation we restrict the language to the Past fragment of the Temporal Logic; the constraint checking can then be done without referring to the whole past history of the database as shown in <ref> [1] </ref>. The work on integrity constraints has been mainly focused on efficient detection of constraint violations. <p> It leads also to much more compact and understandable application programs. Moreover the application programs and the integrity constraints specification form independent "modules"| this allows building modular applications, where one (or more) modules specifies the integrity constraints. We adopt the approach taken in <ref> [1] </ref> where Past Temporal Logic (PastTL) is used for specifying the temporal integrity constraints. <p> In practice this is not acceptable|we would have to store every past state of the database. To avoid this problem we first convert the PastTL formula into a set of FOL formulas. Here we use the idea from <ref> [1] </ref>: create rule rule-name [when finserted (T i )jdeleted (T i )jupdated (T i )g fl jcommit] [if SQL predicate] then SQL action fl [precedes rule-name fl ] [follows rule-name fl ] During the commit the rule system checks the guard of the rule (when); if the guard is true, then
Reference: [2] <author> Chomicki J.. </author> <title> Real-Time Integrity Constraints. </title> <booktitle> In Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: proper names of tables and views (in our case T and old T ). 6 Future work The front-end of the system. (the TL2FOL module): We can introduce other TL constructs in the PastTL language and try to capture bigger class of temporal constraints (for example real-time constraints described in <ref> [2] </ref>). We can refine the translation from TL to FOL: in several cases we have found examples where the amount of information stored in the auxiliary relations can be reduced. The FOL2RALG and RALG2SQL modules: Here we can write specific routines for query optimization.
Reference: [3] <author> Van Gelder A. and Topor R.W. </author> <title> Safety and Translation of Relational Calculus Queries. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 16(2) </volume> <pages> 235-278, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Also the possibility of adopting different rule systems is briefly discussed. This conversion uses compilation of First Order Logic formulas to SQL as one of its steps using modification of the approach described in <ref> [3] </ref>. The paper is concluded with a discussion of the possibilities of extension of this system in the future. 2 Specification Language This section gives the syntax and semantics of the PastTL language used in our system. The standard notation for temporal formulas is used here [13]. <p> This is done in two steps: first the formula is converted to Relational Algebra Normal Form and then to SQL. The conversion of FOL formulas to Relational Algebra is based on ideas presented in <ref> [3] </ref>. All the algorithms were carefully redesigned to take advantage of the structure of the formulas they are working on. This usually leads to more efficient bottom-up execution. <p> Let X = fx 1 ; x 2 ; : : :g be the set of variable names, G = fg; c; f g the set of distinct tags (g stands for GEN, c for CON, and f for not GEN and not CON using terminology from <ref> [3] </ref>), and L the set of (finite disjunctions of) atoms (base relations). <p> A (FOL) formula F is called allowed if the second condition is replaced by (x; g; ) 2 F V (A) for all sub-formulas 9x:A of F . The evaluable property is the key for distinguishing formulas, that can be safely converted (see <ref> [3] </ref> for more detailed discussion). Conversion of formulas which do not meet this criterion may lead into Join Anomalies and unsafe reformulations of the original formula|all such formulas must be rejected. Conversion to allowed and simplified formula. <p> The transformation was described in <ref> [3] </ref> and works as follows: 9x:A ! 9x:(A ^ 9 fl x:(_G)) _ R where G is the third component of the (x; c; G) element in F V (A)|this is finite disjunction of atoms such that (x; g; G) 2 F V (_G), 9 fl x (_G) denotes the sequence
Reference: [4] <author> International Organization for Standardization (ISO). </author> <title> Database Language SQL. </title> <note> Document ISO/IEC 9075:1992. (Also ANSI X3.135-1992). </note>
Reference-contexts: General integrity constraints are difficult to enforce efficiently, thus general-purpose integrity enforcement subsystems are currently present only in a few experimental database systems|commercial DBMS's can usually enforce only the simplest constraints, e.g., constraints on primary and foreign keys <ref> [4] </ref>. On the other hand there were recent proposals of general constraint management subsystems, especially in [6, 8, 11]. The first paper develops an SQL-based constraint specification language and then shows several techniques of converting such specification into triggers in the Starburst system. <p> Many workarounds had to be invented to get the system running. The presented version produces standard SQL (i.e., accepted by most commercial DBMS's); the Starburst variant of the system can take advantage of extensions to the SQL present in the system. The SQL/92 standard <ref> [4] </ref> these extensions but unfortunately most available DBMS do not. 5.1 First Order Logic to Relational Alge bra Normal Form The whole conversion consists of three phases: first the FOL formula is checked for safe evaluation property (Join Anomaly Detection) and simultaneously simplified to a normal form (ENF).
Reference: [5] <author> Widom J., Cochrane R.J., and Lindsay B.G. </author> <title> Implementing Set-oriented Production Rules as an Extension to Starburst. </title> <booktitle> In Proc. International Conference on VLDB, </booktitle> <year> 1991. </year>
Reference-contexts: The evaluation order of the rules is controlled with the precedes and follows clauses. Only the then part of the rule is mandatory. Moreover, for all tables, specified in the when clause the system provides appropriate transition tables inserted, deleted, old-updated, and new-updated <ref> [5] </ref>. 1. each temporal subformula ff is replaced by the auxiliary atom r ff (introduction of this atom results in creating an auxiliary relation in the resulting code): F ! F [r ff =ff] for ff 2 f5A; A since Bg where the arity of r ff is equal to the
Reference: [6] <author> S. Ceri, J. Widom. </author> <title> Deriving Production Rules for Constraint Maintenance. </title> <booktitle> In Proc. International Conference on VLDB, </booktitle> <year> 1990. </year>
Reference-contexts: On the other hand there were recent proposals of general constraint management subsystems, especially in <ref> [6, 8, 11] </ref>. The first paper develops an SQL-based constraint specification language and then shows several techniques of converting such specification into triggers in the Starburst system. But the system does not allow fully automatic translation of logic formulas to Star-burst rules.
Reference: [7] <editor> H. Gallaire, J. Minker, and J. Nicolas. </editor> <title> Logic and Databases: a Deductive Approach. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(2) </volume> <pages> 153-185, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Temporal constraints allow imposing restrictions on the transactions over the database like: "salary of an employee cannot decrease" or "once a student drops out, she should not be readmitted". Static constraints have been studied in many papers, e.g., <ref> [7] </ref>. They can be usually formulated in First Order Logic (FOL). For dealing with temporal constraints the choice of Temporal Logic is a natural solution.
Reference: [8] <author> Gertz M., Lipeck U.W. </author> <title> Deriving Integrity Maintaining Triggers from Transition Graphs. </title> <booktitle> In International Conference on Data Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: On the other hand there were recent proposals of general constraint management subsystems, especially in <ref> [6, 8, 11] </ref>. The first paper develops an SQL-based constraint specification language and then shows several techniques of converting such specification into triggers in the Starburst system. But the system does not allow fully automatic translation of logic formulas to Star-burst rules.
Reference: [9] <author> Blakeley J.A., Larson P.A., and Tompa F.W. </author> <title> Efficiently Updating Materialized Views. </title> <booktitle> In Proc. ACM SIGMOD, </booktitle> <address> pp.61-71, Washington D.C., </address> <month> June </month> <year> 1986. </year>
Reference-contexts: The Rule generator: We can optimize the process of rematerialization of the auxiliary relations as shown in <ref> [9, 10] </ref>. This pass can be easily added on top of the existing system. 4 This is not a problem in Starburst where extensions to SQL allow to handle the nested subqueries directly. Also systems conforming with the SQL/92 standard can handle nested queries directly.
Reference: [10] <author> Gupta A., </author> <title> Mumick I.S., Subrahmanian V.S. Maintaining views incrementally. </title> <booktitle> In Proc. ACM SIGMOD pp.157-167, </booktitle> <address> Washington D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The Rule generator: We can optimize the process of rematerialization of the auxiliary relations as shown in <ref> [9, 10] </ref>. This pass can be easily added on top of the existing system. 4 This is not a problem in Starburst where extensions to SQL allow to handle the nested subqueries directly. Also systems conforming with the SQL/92 standard can handle nested queries directly.
Reference: [11] <author> Sistla A.P., Wolfson O. </author> <title> Temporal Triggers in Active Databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <note> (to appear) 1993. </note>
Reference-contexts: On the other hand there were recent proposals of general constraint management subsystems, especially in <ref> [6, 8, 11] </ref>. The first paper develops an SQL-based constraint specification language and then shows several techniques of converting such specification into triggers in the Starburst system. But the system does not allow fully automatic translation of logic formulas to Star-burst rules. <p> Also, checking the formulas for the safe evaluation property is solely the user responsibility whereas our method accepts arbitrary Past Temporal formulas as long as they can be safely converted to Relational Algebra; unsafe formulas are rejected by the system. Another approach can be found in <ref> [11] </ref>. The temporal language chosen in that approach has nonstandard freeze quantifiers and is not related to our work. Our implementation allows the user to specify the constraints using the language of Past Temporal Logic.
Reference: [12] <author> R. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On Rules, Procedures, Caching, and Views in Data Base Systems. </title> <booktitle> In ACM SIG-MOD Int. Conf. on Management of Data, </booktitle> <year> 1991. </year>
Reference-contexts: All these features are utilized by our implementation. On the other hand it will be possible to modify the rule generator for conceptually different rule systems. This might be considerably more complex in the case the rule system is tuple oriented (like in <ref> [12] </ref>): essentially we will have to simulate the set-oriented system explicitly by additional rules for each table (mentioned in the constraints specification) that will maintain the (also explicit) transition tables. <p> The system is fully operational. The general philosophy of our system fits well with the Starburst active DBMS developed in IBM Al-maden which supports set-oriented triggers that are invoked at the end of the transactions rather than after each single update (as, e.g., in Postgres <ref> [12] </ref>). We also utilized the possibility of ordering the evaluation of the rules in an essential way.
Reference: [13] <author> Manna Z. and Pnueli A. </author> <title> The temporal logic of reactive and concurrent systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The paper is concluded with a discussion of the possibilities of extension of this system in the future. 2 Specification Language This section gives the syntax and semantics of the PastTL language used in our system. The standard notation for temporal formulas is used here <ref> [13] </ref>.
References-found: 13

