URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3874/3874.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: Analysis and Applications of Receptive Safety Properties in Concurrent Systems 1  
Author: Gilberto Matos 
Note: 1 This research is Supported by the Office of Naval Research under contract ONR N000149410320  
Abstract-found: 0
Intro-found: 1
Reference: [ABC + 91] <author> G. S. Avrunin, U. A. Buy, J. Corbett, L. Dillon, and J. Wileden. </author> <title> "Experiments with an improved constrained expression toolset". </title> <booktitle> In Proceedings of TAV4, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Their method extracted the regularity of the philosopher definition to reduce the complexity of the part of the state space that it had to analyze, and limited its growth to a linear function of the number of philosophers. Constrained expressions <ref> [ABC + 91] </ref> provide another way of analyzing the behavior of the philosophers where the time requirements are a linear function of the number of philosophers.
Reference: [AFB + 88] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Two examples of this approach are SCR <ref> [Hen80, AFB + 88] </ref> and RSML [LHHR94]. The tabular approach has the advantage of being simple for the end users to understand and comment on from the domain knowledge point of view. <p> This makes its alphabet the set of all possible combinations of boolean 18 values for the variables in A, represented above by the powerset 2 A . This definition of component behavior is similar to the tabular approaches in SCR <ref> [Hen80, AFB + 88] </ref> and RSML [LHHR94]. Variables used to determine the enabled transitions for a given component are considered to be monitored, while the variables altered by its effects are controlled as defined in the SCR notation [Hen80].
Reference: [AG93] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven System Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The tabular approach has the advantage of being simple for the end users to understand and comment on from the domain knowledge point of view. The tabular notation makes these languages simple to automatically analyze for completeness and consistency [HL96], and refine their behavior by modifying the specification table <ref> [AG93] </ref>. We use this basic notation for the component specifications in GenEx, because of the simplicity of component behavior modifications. Several systems have used the code generation to implement synchronized concurrent systems, LUSTRE [CRR91] and Esterel [BG92] being based on a similar model of computation as GenEx.
Reference: [AG94] <author> R. Allen and D. Garlan. </author> <title> "Formalizing Architectural Connection". </title> <booktitle> In Proceedings of the 16th International Conference on SW Engineering, </booktitle> <year> 1994. </year>
Reference-contexts: By limiting the approach to a certain class of systems, we can make better tools for integration and system verification, allowing us to automatically generate correct implementations. 1.3.1 Interface Specifications, Verification and Synthesis Garlan and others <ref> [GS93, AG94] </ref> investigated the interface specifications from the standpoint of external control, and introduced the concept of glue protocols. Behavior of individual component interfaces is a set of possible execution traces, but some traces incompatible with the glue are made unreachable to make the interface consistent with the glue.
Reference: [AL93] <author> Martin Abadi and Leslie Lamport. </author> <title> "Composing Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15 </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Theoretical work by Abadi and Lamport <ref> [AL93] </ref> established a framework for the proof of correctness and safety of systems synchronized automatically using GenEx. They also identified the receptive safety properties and defined the relationship between receptiveness and realizability. <p> Dill distinguishes properties that require restrictions on the environment behavior from those that can be satisfied by a system regardless of the environment actions. Receptive properties are those whose valid behaviors are closed under concatenation of environment events. Receptiveness was further developed by Abadi and Lamport <ref> [AL93] </ref>, through the relationship between a property and a controlled agent set that can enforce it. Moreover, they isolated safety properties as a specific domain of receptive properties that can be preserved under composition. Receptiveness is also strongly related to the concepts of realizable and unrealizable properties [AW89]. <p> A safety rule that restricts only controlled components is receptive because no environment action can force the rule violation as long as the system uses a safe synchronization strategy for the components. 1.1.2 Composability of Safety Properties The work on specification composition <ref> [AL93] </ref> proved that a composed system preserves some types of properties enforced by its components. These results make a clear distinction between the composability of safety properties, and that of more complex properties that include liveness, and fair behaviors. <p> The basic rules of this game are described by the semantic execution model that specifies when the players can make a move and what are the legal moves at any instant. The interaction between control systems and environments was studied by Abadi and Lamport <ref> [AL93] </ref>, and we will use their classification of properties and their relationship to controller strategies to clarify the need for identifying receptive safety properties. This classification and theorem proofs are based on the agent set semantic model. <p> We will give a short overview of their definitions, and more details can be found in <ref> [AL93] </ref>. Definition 2.1 A state is an element of a nonempty set S of states. Every element of S represents the state, at some instant, of the system universe. System state represents a combination of the current controller state and environment state. <p> The following theorem shows the relationship between the realizability and receptiveness for arbitrary system properties. Theorem 2.1 For any property P defined as a set of acceptable behaviors, its realizable part R (P ) is a receptive property. Proof: Proof in <ref> [AL93] </ref> This theorem shows that for any realizable property, there exists a receptive property that must be satisfied by any implementation that satisfies the original property. The importance of the receptive properties is even greater in the safety domain, because any receptive safety property constrains only the controlled agent set. <p> The importance of the receptive properties is even greater in the safety domain, because any receptive safety property constrains only the controlled agent set. Theorem 2.2 A receptive safety property constrains at most the controller agents. Proof: Proof in <ref> [AL93] </ref> A corollary to theorem 2.2 is that violations of receptive safety properties are always caused by a controlled agent. The controlled agents in our semantic model represent groups of component transitions and one or more of the components must cause the event that triggers the safety violation. <p> We now need to show some extensions that apply specifically to the safety properties and their 27 realizability. These theorems are simple extensions to the work in <ref> [AL93] </ref>, but were not clearly expressed there, probably because their goal was to prove composition of working components rather than deal with automated property enforcement. The following theorems show that any realizable safety property can be represented in the form of constraints on system component execution.
Reference: [AW89] <author> Martin Abadi and Leslie Lamportand Pierre Wolper. </author> <title> "Realizable and Unrealizable Specifications of Reactive Systems". </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 372 </volume> <pages> 1-17, </pages> <year> 1989. </year>
Reference-contexts: Moreover, they isolated safety properties as a specific domain of receptive properties that can be preserved under composition. Receptiveness is also strongly related to the concepts of realizable and unrealizable properties <ref> [AW89] </ref>. Intuitively, a rule is receptive if a system can enforce that rule regardless 10 of environment actions. In general, any rule that can be violated by a sequence of environment actions is nonreceptive because no strategy of the system can prevent the violation from happening. <p> The disjointness of the controller and environment agent sets implies that they always execute in some interleaving pattern and never in parallel. Both agent sets can be reduced to a single agent each, representing all disjoint controller and environment actions <ref> [AW89] </ref>.
Reference: [AWZ88] <author> Bowen Alpern, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> "Detecting Equality of Variables in Programs". </title> <booktitle> In Proceedings of the Fifteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: The same principle does not apply to the liveness properties whose violations only occur on infinite traces. A useful concept in reasoning about system properties is the safety closure <ref> [AWZ88] </ref>, which defines a safety approximaton for arbitrary properties. 23 Definition 2.12 The safety closure P of a property P is the smallest safety property that accepts all behaviors accepted by P. 2.4.1 Finite State Representation of Safety Properties The safety properties in our system are defined using the same formalism
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.J. Dill, and L.J. Hwang. </author> <title> "Symbolic Model Checking: 10 20 States and Beyond". </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This approach is orthogonal to automatic synchronization, and the same abstraction and removal of irrelevant states can be used in GenEx to reduce the complexity of the reachability analysis. Symbolic model checking <ref> [BCM + 90] </ref> relies on the symbolic representation of the state space, where regularities in the state space are exploited to minimize the complexity of the representation. These techniques are very powerful analysis tools, but they require the designer to correct all inconsistencies.
Reference: [BG92] <author> G. Berry and G. Gonthier. </author> <title> "The Esterel Synchronous Programming Language: Design, Semantics, </title> <booktitle> Implementation". Science of Computer Programming, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: We use this basic notation for the component specifications in GenEx, because of the simplicity of component behavior modifications. Several systems have used the code generation to implement synchronized concurrent systems, LUSTRE [CRR91] and Esterel <ref> [BG92] </ref> being based on a similar model of computation as GenEx. These systems use a synchronous transitions model of computation, where every component executes one action in every system cycle. The synchronous transitions model makes them simple to analyze and generate code for. <p> These systems are based on various divergent and even conflicting assumptions. These assumptions deal with the semantics of component execution, whether they execute asynchronously [Hen80], synchronously <ref> [HLR92, BG92] </ref>, or with runtime determination of synchronization requirements [CK95]. <p> Other important differences between concurrent system specification methods arise in the area of time, where some systems assume a continuous timeline model [GMM90], some operate with finite intervals and a timeline made of discrete events <ref> [BG92] </ref>, and others work with branching time model [McM93, CLM89]. In this chapter we will define the type of concurrent systems that our system handles, as well as the semantics of their behavior and properties. <p> Our research concentrates on the composability of systems from independent components, and we selected a different but related semantic execution model. The synchronous transition model <ref> [McM93, BG92] </ref> defines controller actions as a combination of parallel component actions, and specifies strict interleaving between the controller and environment actions. <p> Safety rules are defined as finite state machines whose behavior depends on the system states, similarly to the Esterel concept of Observer <ref> [BG92] </ref>. A safety rule observes the components in the sense that it uses their states to determine its enabled transitions. In practice, this means that the components and safety rules are interleaved during execution, and the states of both components and safety rule observers combined represent the system state.
Reference: [BK93] <author> Eric A Brewer and Bradley C. Kuszmaul. </author> <title> "How to Get Good Performance from the CM5 Data Network". </title> <booktitle> In Proceedings of the 1994 International Parallel Processing Symposium, </booktitle> <pages> pages 858-867, </pages> <month> April </month> <year> 1993. </year> <month> 105 </month>
Reference-contexts: Despite this shortcoming, the system is an example of how simple methods can solve complex problems, given the right domain. Brewer and Kuszmaul <ref> [BK93] </ref> investigated the impact of synchronizationon system performance, and found that synchronization in some cases can contribute to improving the performance of a system beyond what could be achieved by asynchronous execution. This shows that performance requirements can sometimes be reduced to safety properties which can be enforced using synchronization.
Reference: [Bro86] <author> Michael C. Browne. </author> <title> "An Improved Algorithm for the Automatic Verification of Finite State Systems Using Temporal Logic". </title> <booktitle> In Proceedings of the Symposium on Logic in Computer Science, </booktitle> <pages> pages 260-266, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Proving correctness of abstract descriptions is of limited use because of the possible discrepancies between the implementation and the description. In general the scalability of this approach is limited by the complexity of the system. When complexity is kept low, mcb <ref> [Bro86, CES86] </ref> can successfully and efficiently check formulas in first order temporal logic CTL. Proofs on real code are rarely used because their complexity is generally unacceptably high, and they are often undecidable.
Reference: [CE82] <author> E. M. Clarke and E. A. Emerson. </author> <title> "Synthesis of synchronization skeletons from branching time temporal logic". </title> <booktitle> Lecture Notes Comp. Sci., </booktitle> <volume> 131 </volume> <pages> 52-71, </pages> <year> 1982. </year>
Reference-contexts: Our approach in GenEx is to automate the design of one aspect of the system components, that related to their control behavior. We modify the components to make the system enforce a given set of receptive safety properties. 1.1.1 System Control, Synchronization and Receptiveness Clarke <ref> [EC82, CE82] </ref> has shown that properties of the control aspect for many systems are simpler than the properties of their data processing, and that the implementation of these two aspects can be separated. He discussed the generation of synchronization skeletons from temporal descriptions of system behavior.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Proving correctness of abstract descriptions is of limited use because of the possible discrepancies between the implementation and the description. In general the scalability of this approach is limited by the complexity of the system. When complexity is kept low, mcb <ref> [Bro86, CES86] </ref> can successfully and efficiently check formulas in first order temporal logic CTL. Proofs on real code are rarely used because their complexity is generally unacceptably high, and they are often undecidable. <p> The next two sections describe these synchronization algorithms. 3.3 Reachability Analysis of Receptive Safety Rule Violations Reachability analysis of system behavior is a well known method for verifying correctness of a system with respect to its safety requirements <ref> [CES86] </ref>. The strength of this method is that it naturally produces proof for the detected safety violations, by tracing back along the path from the starting state to the violating one.
Reference: [CG94] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Implementations". </title> <booktitle> In Proceedings of the 1994 ISSTA, </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: STeP [ZM + 94] tries to prove the given assertions automatically and when that fails it lets the designer guide the proof by choosing the assertions that are to be proved. Analyzer <ref> [CG94, Che96] </ref> requires additional information related to the abstract component description to be inserted in the source code, and combines it with the program reachability graph to check the consistency of the program and SCR [Hen80] style specifications.
Reference: [CGK97] <author> S. C. Cheung, Dimitra Giannakopoulou, and J. Kramer. </author> <title> "Verification of Liveness Properties Using Compositional Reachability Analysis". </title> <booktitle> In Proceedings of the 6th European Software Engineering Conference, </booktitle> <pages> pages 227-243, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: Apart from requiring high skill, the manual refinement might also involve sizeable effort because the physical size of the description might have to increase. Labeled transition system (LTS) <ref> [CK95, CK96, CGK97] </ref> is another finite state notation for component specifications that uses a synchronous transition model.
Reference: [Che96] <author> M. Chechik. </author> <title> "Automatic Analysis of Consistency Between Requirements and Designs". </title> <type> PhD thesis, </type> <institution> University of Maryland, College Park, </institution> <year> 1996. </year>
Reference-contexts: STeP [ZM + 94] tries to prove the given assertions automatically and when that fails it lets the designer guide the proof by choosing the assertions that are to be proved. Analyzer <ref> [CG94, Che96] </ref> requires additional information related to the abstract component description to be inserted in the source code, and combines it with the program reachability graph to check the consistency of the program and SCR [Hen80] style specifications.
Reference: [CK95] <author> S. C. Cheung and J. Kramer. </author> <title> "Compositional Reachability Analysis of Finite-State Distributed Systems with User-Specified Constraints". </title> <booktitle> In SIGSOFT'95 Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 140-151, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Apart from requiring high skill, the manual refinement might also involve sizeable effort because the physical size of the description might have to increase. Labeled transition system (LTS) <ref> [CK95, CK96, CGK97] </ref> is another finite state notation for component specifications that uses a synchronous transition model. <p> These systems are based on various divergent and even conflicting assumptions. These assumptions deal with the semantics of component execution, whether they execute asynchronously [Hen80], synchronously [HLR92, BG92], or with runtime determination of synchronization requirements <ref> [CK95] </ref>. Other important differences between concurrent system specification methods arise in the area of time, where some systems assume a continuous timeline model [GMM90], some operate with finite intervals and a timeline made of discrete events [BG92], and others work with branching time model [McM93, CLM89].
Reference: [CK96] <author> S. C. Cheung and J. Kramer. </author> <title> "Checking Subsystem Safety Properties in Compositional Reachability Analysis". </title> <booktitle> In 18th International Conference on Software Engineering, </booktitle> <pages> pages 144-154, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Apart from requiring high skill, the manual refinement might also involve sizeable effort because the physical size of the description might have to increase. Labeled transition system (LTS) <ref> [CK95, CK96, CGK97] </ref> is another finite state notation for component specifications that uses a synchronous transition model.
Reference: [CLM89] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> "Compositional Model Checking". </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 464-475, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Compositional and symbolic model checking are two approaches that try to reduce the complexity of the state space representations. Compositional model checking <ref> [CLM89] </ref>, [FG94] tries to limit the complexity by constructing abstractions that can represent system components in further analysis of the given properties. By eliminating states that are irrelevant to the property, it can achieve significant reduction in the complexity of the analysis. <p> Other important differences between concurrent system specification methods arise in the area of time, where some systems assume a continuous timeline model [GMM90], some operate with finite intervals and a timeline made of discrete events [BG92], and others work with branching time model <ref> [McM93, CLM89] </ref>. In this chapter we will define the type of concurrent systems that our system handles, as well as the semantics of their behavior and properties.
Reference: [CRR91] <author> N. Halbwachs C. Ratel and P. Raymond. </author> <title> "Programming and veryfying critical systems by means of the synchronous data-flow programming language LUSTRE". </title> <booktitle> Software Engineering Notes, </booktitle> <pages> pages 112-119, </pages> ? <year> 1991. </year>
Reference-contexts: We use this basic notation for the component specifications in GenEx, because of the simplicity of component behavior modifications. Several systems have used the code generation to implement synchronized concurrent systems, LUSTRE <ref> [CRR91] </ref> and Esterel [BG92] being based on a similar model of computation as GenEx. These systems use a synchronous transitions model of computation, where every component executes one action in every system cycle. The synchronous transitions model makes them simple to analyze and generate code for.
Reference: [Dij] <author> Edgser Dijkstra. </author> <title> "Two starvation-free solutions of a general exclusion problem". </title>
Reference-contexts: The game theory aspect of system design is simple in this case because the controller has total visibility of the system state, and its actions can be determined based on the current situation. This system has been extensively studied in literature, both for synchronization design <ref> [Dij, Hoa78] </ref> and for system verification [YY91]. We will use this system to illustrate different aspects of automated synchronization. 2.2 Systems as Sets of Components The modular architecture of software systems is based on active concurrent components that communicate through passive interfaces. <p> In this chapter we will show some details of the system specification and of the computation of synchronization conditions. We will also explain how our method avoids deadlocks and starvation in the synchronization for this and any other exclusion based system. Dijkstra introduced the dining philosophers problem <ref> [Dij] </ref> and analyzed its mutual exclusion requirements and possible implementations. A group of n philosophers is alternatively thinking and dining at a round table, but they are restricted by the lack of forks at the table.
Reference: [Dil88] <author> David L. Dill. </author> <title> "Trace Theory for Automatic Hierarchical Verification of Speed-Independent circuits". </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1988. </year>
Reference-contexts: The intractability of analysis in this method stems from the unrestricted nature of temporal properties that are enforced; our method selects a restricted set of properties whose enforcement requires dramatically lower complexity of analysis. The concept of property receptiveness, introduced by Dill <ref> [Dil88] </ref>, gives an intuitive classification of properties for open systems. Open systems consist of a controller and its environment and the interaction between them determines the system behavior. The environment in open systems can not be controlled, and no restrictions can be imposed on its behavior. <p> The intuitive distinction between these properties is that the unrealizable ones require restrictions on the environment events, while the realizable properties can be satisfied by controller strategies. Dill <ref> [Dil88] </ref> introduced the notion of receptiveness as the lack of restrictions on external events. The term receptive property suggests that the property is not influenced by the environment, regardless of its behavior.
Reference: [EC82] <author> E. Allen Emerson and Edmund M. Clarke. </author> <title> "Using Branching Time Temporal Logic to Synthesize Synchronization Skeletons". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2(3) </volume> <pages> 241-266, </pages> <month> Dec </month> <year> 1982. </year>
Reference-contexts: Our approach in GenEx is to automate the design of one aspect of the system components, that related to their control behavior. We modify the components to make the system enforce a given set of receptive safety properties. 1.1.1 System Control, Synchronization and Receptiveness Clarke <ref> [EC82, CE82] </ref> has shown that properties of the control aspect for many systems are simpler than the properties of their data processing, and that the implementation of these two aspects can be separated. He discussed the generation of synchronization skeletons from temporal descriptions of system behavior.
Reference: [FG94] <author> Jeffrey Fischer and Richard Gerber. </author> <title> "Compositional Model Checking of Ada Tasking Programs". </title> <type> Technical report, </type> <institution> University of Maryland, College Park, </institution> <month> February </month> <year> 1994. </year> <month> 106 </month>
Reference-contexts: Compositional and symbolic model checking are two approaches that try to reduce the complexity of the state space representations. Compositional model checking [CLM89], <ref> [FG94] </ref> tries to limit the complexity by constructing abstractions that can represent system components in further analysis of the given properties. By eliminating states that are irrelevant to the property, it can achieve significant reduction in the complexity of the analysis.
Reference: [Fra86] <author> Nissim Francez. </author> <title> "Fairness". </title> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: In our implementation of the dining philosophers, this pattern is possible for finite executions, but the starvation can not be indefinite because the nondeterministic relative priority signals implement what amounts to extreme fairness. Extreme fairness is defined in <ref> [Fra86] </ref> [Mai93] and it applies to systems with probabilistic choice of possible executions. When a path to the desired state has some finite probability from an infinitely often occurring state, the desired state is eventually reached along all paths.
Reference: [GMM90] <author> Carlo Ghezzi, Dino Mandrioli, and Angelo Morzenti. </author> <title> "TRIO: A Logic Language for Executable Specifications of Real-Time Systems". </title> <journal> Journal of Systems and Software, </journal> <volume> 12(2) </volume> <pages> 107-123, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: These assumptions deal with the semantics of component execution, whether they execute asynchronously [Hen80], synchronously [HLR92, BG92], or with runtime determination of synchronization requirements [CK95]. Other important differences between concurrent system specification methods arise in the area of time, where some systems assume a continuous timeline model <ref> [GMM90] </ref>, some operate with finite intervals and a timeline made of discrete events [BG92], and others work with branching time model [McM93, CLM89]. In this chapter we will define the type of concurrent systems that our system handles, as well as the semantics of their behavior and properties.
Reference: [GS93] <author> D. Garlan and C. Scott. </author> <title> "Adding Implicit Invocation to Traditional Programming Languages". </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: By limiting the approach to a certain class of systems, we can make better tools for integration and system verification, allowing us to automatically generate correct implementations. 1.3.1 Interface Specifications, Verification and Synthesis Garlan and others <ref> [GS93, AG94] </ref> investigated the interface specifications from the standpoint of external control, and introduced the concept of glue protocols. Behavior of individual component interfaces is a set of possible execution traces, but some traces incompatible with the glue are made unreachable to make the interface consistent with the glue.
Reference: [Har87] <author> David Harel. "StateCharts: </author> <title> A Visual Formalism for Complex Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Many programming languages and specification notations have been developed to help produce reliable concurrent systems, where some properties or behaviors are guaranteed by design, and do not require any verification. One of the first broadly used formal notations for concurrent systems was StateCharts <ref> [Har87] </ref>, a graphical notation using states and transitions to represent complex systems. They use hierarchical clustering and refinement to specify complex components from sets of simpler ones.
Reference: [Hen80] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Analyzer [CG94, Che96] requires additional information related to the abstract component description to be inserted in the source code, and combines it with the program reachability graph to check the consistency of the program and SCR <ref> [Hen80] </ref> style specifications. Due to the undecidability of the program behavior, this analysis is either optimistic or pessimistic, and exact analysis is impossible. <p> Two examples of this approach are SCR <ref> [Hen80, AFB + 88] </ref> and RSML [LHHR94]. The tabular approach has the advantage of being simple for the end users to understand and comment on from the domain knowledge point of view. <p> These systems are based on various divergent and even conflicting assumptions. These assumptions deal with the semantics of component execution, whether they execute asynchronously <ref> [Hen80] </ref>, synchronously [HLR92, BG92], or with runtime determination of synchronization requirements [CK95]. <p> This makes its alphabet the set of all possible combinations of boolean 18 values for the variables in A, represented above by the powerset 2 A . This definition of component behavior is similar to the tabular approaches in SCR <ref> [Hen80, AFB + 88] </ref> and RSML [LHHR94]. Variables used to determine the enabled transitions for a given component are considered to be monitored, while the variables altered by its effects are controlled as defined in the SCR notation [Hen80]. <p> Variables used to determine the enabled transitions for a given component are considered to be monitored, while the variables altered by its effects are controlled as defined in the SCR notation <ref> [Hen80] </ref>. Variables may be used for communication between components when they would be controlled by some components and monitored by others. From the standpoint of a controller system, variables are controlled if they are controlled by any of its components, and monitored if they are controlled by its environment.
Reference: [HL96] <author> M.P.E. Heimdahl and N.G. Leveson. </author> <title> "Completeness and Consistency in Hierarchical State-Based Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(6) </volume> <pages> 363-377, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: The tabular approach has the advantage of being simple for the end users to understand and comment on from the domain knowledge point of view. The tabular notation makes these languages simple to automatically analyze for completeness and consistency <ref> [HL96] </ref>, and refine their behavior by modifying the specification table [AG93]. We use this basic notation for the component specifications in GenEx, because of the simplicity of component behavior modifications.
Reference: [HLR92] <author> Nicolas Halbwachs, Fabienne Lagnier, and Christophe Ratel. </author> <title> "Programming and Verifying Real-Time Systems by Means of the Synchronous Data-Flow Language LUSTRE". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9) </volume> <pages> 785-793, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: These systems are based on various divergent and even conflicting assumptions. These assumptions deal with the semantics of component execution, whether they execute asynchronously [Hen80], synchronously <ref> [HLR92, BG92] </ref>, or with runtime determination of synchronization requirements [CK95].
Reference: [Hoa78] <author> C.A.R. Hoare. </author> <title> "Communicating Sequential Processes". </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: The game theory aspect of system design is simple in this case because the controller has total visibility of the system state, and its actions can be determined based on the current situation. This system has been extensively studied in literature, both for synchronization design <ref> [Dij, Hoa78] </ref> and for system verification [YY91]. We will use this system to illustrate different aspects of automated synchronization. 2.2 Systems as Sets of Components The modular architecture of software systems is based on active concurrent components that communicate through passive interfaces.
Reference: [JEH79] <author> Jeffrey D. Ullman John E. Hopcroft. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: Systems are composed by executing the components concurrently, in some cases in lockstep with each component executing one transition in parallel, and this model is known as the synchronous transition model. In our system we use components defined in the form of Mealy finite state machines <ref> [JEH79] </ref>, whose output depends on the executed transition. <p> This limitation on the number of accesses by the adjacent philosophers guarantees that the second philosopher can not be starved. Since both L1 and L2 are regular languages, by closure of regular language intersection <ref> [JEH79] </ref>, so is the language L. Knowing that L is a regular language guarantees that a finite state machine M (L) can be produced. M (L) accepts system behaviors if they belong to the language L1 " L2, and rejects them otherwise.
Reference: [Kat93] <author> Shmuel Katz. </author> <title> "A Superimposition Control Construct for Distributed Systems". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 337-355, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: The interface and glue specifications are manually designed, and may be verified for consistency and compatibility. Another similar approach was developed by Katz <ref> [Kat93] </ref>, where control constructs are superimposed on the behavior of the components to achieve specific system behaviors. 14 Yellin and Strom [YS97] discuss the automated synthesis of interface adaptors according to finite state protocol descriptions for the connectors being interfaced.
Reference: [KIL + 97] <author> Gregor Kiczales, John Irwin, John Lamping, Jean-Marc Loingtier, Cristina Lopes, Chris Maeda, and Anurag Mendhekar. </author> <title> "Aspect Oriented Programming". </title> <booktitle> In Proceedings of DSL97 First ACM SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: This shows that performance requirements can sometimes be reduced to safety properties which can be enforced using synchronization. We will show later how other non-safety properties can often be reduced to receptive safety properties and enforced by automated synchronization. Aspect-oriented computing <ref> [KIL + 97] </ref> is closely related to our work by its emphasis on separating different aspects of system behavior and the use of automated integration to generate system implementations. This field is very broad, and involves many types of system properties, and different types of systems and objects.
Reference: [LHHR94] <author> N.G. Leveson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. </author> <title> "Requirements Specification for Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Two examples of this approach are SCR [Hen80, AFB + 88] and RSML <ref> [LHHR94] </ref>. The tabular approach has the advantage of being simple for the end users to understand and comment on from the domain knowledge point of view. <p> This makes its alphabet the set of all possible combinations of boolean 18 values for the variables in A, represented above by the powerset 2 A . This definition of component behavior is similar to the tabular approaches in SCR [Hen80, AFB + 88] and RSML <ref> [LHHR94] </ref>. Variables used to determine the enabled transitions for a given component are considered to be monitored, while the variables altered by its effects are controlled as defined in the SCR notation [Hen80].
Reference: [Lim93] <author> Alvin See Sek Lim. </author> <title> "A State Machine Approach to Reliable and Dynamically Reconfigurable Distributed Systems ". PhD thesis, </title> <institution> University of Wisconsin., Madison, Wisconsin, </institution> <year> 1993. </year>
Reference-contexts: The problem with the LTS approach is that the constraint is very restrictive and results in very easy occurrence of deadlock states when all labels are disabled. 1.3 Requirement Decomposition and Enforcement The concept of product state machines, as described in <ref> [Lim93, Lim96] </ref>, is conceptually very similar to GenEx. The main difference between them is the scalability. In this system, the global reachability graph is constructed and then restricted to eliminate violation states. The restricted graph is then used in the execution.
Reference: [Lim96] <author> Alvin Lim. </author> <title> "Compositional Synchronization". </title> <booktitle> In International Conference on DCS, </booktitle> <year> 1996. </year>
Reference-contexts: The problem with the LTS approach is that the constraint is very restrictive and results in very easy occurrence of deadlock states when all labels are disabled. 1.3 Requirement Decomposition and Enforcement The concept of product state machines, as described in <ref> [Lim93, Lim96] </ref>, is conceptually very similar to GenEx. The main difference between them is the scalability. In this system, the global reachability graph is constructed and then restricted to eliminate violation states. The restricted graph is then used in the execution.
Reference: [LL95] <author> Claus Lewerentz and Thomas Lindner. </author> <title> "Formal Development of Reactive Systems". </title> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: Chapter 5 introduces another example of automated synchronization used in a complex concurrent system. The production cell controller was used as the basis for a case study of concurrent system design and verification methods <ref> [LL95] </ref>. We show how a controller for this system can be designed and automatically synchronized using GenEx, and how easy it is to modify that controller to implement a more complex fault tolerant version. <p> The Production Cell system was the object of a large case study involving over a dozen leading formal design and verification methods <ref> [LL95] </ref>. The goal of the case study was to produce a controller for the production cell and to verify its correctness. Most of the implementations limited themselves to the implementation without verifying its correctness. <p> The complexity of the system was estimated to be around 50 million states <ref> [LL95] </ref>, a hard problem to analyze even using the best of the existing automated verification tools. The complexity of the analysis required to synchronize the system for the specified properties was up to 500 states for the reachability analysis, and up to 20 states per property using static analysis.
Reference: [Mai93] <author> Michael G. </author> <title> Main. "Complete proof rules for strong fairness and strong extreme fairness". </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 111(1-2):125-143, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: In our implementation of the dining philosophers, this pattern is possible for finite executions, but the starvation can not be indefinite because the nondeterministic relative priority signals implement what amounts to extreme fairness. Extreme fairness is defined in [Fra86] <ref> [Mai93] </ref> and it applies to systems with probabilistic choice of possible executions. When a path to the desired state has some finite probability from an infinitely often occurring state, the desired state is eventually reached along all paths.
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: To declare a system correct, all of its behaviors must satisfy the relevant system requirements. Consistency of a system with its requirements can be verified manually or by using automated model checking or proof techniques. Model checking tools <ref> [McM93] </ref> can verify that a system implementation satisfies all defined requirements by analyzing a symbolic representation of its state space. Proof techniques generally support the user in the construction of proofs that the system implementation implies that its requirements are satisfied. <p> Other important differences between concurrent system specification methods arise in the area of time, where some systems assume a continuous timeline model [GMM90], some operate with finite intervals and a timeline made of discrete events [BG92], and others work with branching time model <ref> [McM93, CLM89] </ref>. In this chapter we will define the type of concurrent systems that our system handles, as well as the semantics of their behavior and properties. <p> Our research concentrates on the composability of systems from independent components, and we selected a different but related semantic execution model. The synchronous transition model <ref> [McM93, BG92] </ref> defines controller actions as a combination of parallel component actions, and specifies strict interleaving between the controller and environment actions. <p> The formal model of the system or its parts can be used to verify the correctness of the design using the symbolic model checking tool SMV <ref> [McM93] </ref>. While GenEx synchronizes the components to enforce the given receptive safety properties, and the generated controller is guaranteed to satisfy them, other system requirements may be violated. <p> GenEx produces formal models of the system or its subsystems to allow the users to verify the correctness of the generated synchronized systems with respect to the implicit and explicit correctness criteria. GenEx generates models of the synchronized system in the SMV <ref> [McM93] </ref> notation that allows symbolic model checking; However, the complexity of the synchronized systems quickly grows out of the range that can be verified in practice, even with symbolic model checking.
Reference: [PM97] <author> J.C. Park and R. Miller. </author> <title> "Synthesizing Protocol Specificationsfrom Service Specifications in Timed Extended Finite State Machines". </title> <booktitle> In Proceedings of the 17th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 253-260, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: The mapping specifies a partial order for the messages according to the dependence between their parameters. This partial order makes a finite state structure where the synthesis by state enumeration is possible. Park and Miller <ref> [PM97] </ref> worked on automatic synthesis of interfaces to implement a service specification involving a number of components with real-time characteristics. Their work is based on timed finite state machines, and the individual protocol synthesis concentrates on interval planning, and introduction of synchronizing actions in the machines.
Reference: [Pur94] <author> James Purtilo. </author> <title> "The POLYLITH Software Bus". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 151-174, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: It is also an extendible execution structure, allowing the embedding of data processing segments in the component code without violating the synchronous execution assumption. 3.7.1 Distributed Execution Support In the case of distributed execution, we use Polylith <ref> [Pur94] </ref> to provide a heterogeneous communication mechanism that supports the synchronization and state data broadcasting throughout the system. Polylith is a software bus implementation, providing platform independent high level communication support. The structure of distributed applications is a star of synchronized processes, with the control process in the center.
Reference: [Sta90] <author> John T. Stasko. </author> <title> "TANGO: A Framework and System for Algorithm Animation". </title> <journal> IEEE Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The tool represents the system at the level of formal components, safety rule observers and signals, and provides an intuitive and familiar model of execution. This visualization tool is based on the xtango <ref> [Sta90, Sta92] </ref> algorithm animation engine, and is embedded in the execution support kernel. The animation tool represents the components and safety rule observers as graphs, showing their current and previously visited states. The signals are represented as switches and interactively modifiable, to allow the user to control the system execution.
Reference: [Sta92] <author> John T. Stasko. </author> <title> "Animating Algorithms with XTANGO". </title> <journal> SIGACT News, </journal> <volume> 23(2) </volume> <pages> 67-71, </pages> <month> Spring </month> <year> 1992. </year>
Reference-contexts: The tool represents the system at the level of formal components, safety rule observers and signals, and provides an intuitive and familiar model of execution. This visualization tool is based on the xtango <ref> [Sta90, Sta92] </ref> algorithm animation engine, and is embedded in the execution support kernel. The animation tool represents the components and safety rule observers as graphs, showing their current and previously visited states. The signals are represented as switches and interactively modifiable, to allow the user to control the system execution.
Reference: [WK95] <author> Kevin G. Wika and John C. Knight. </author> <title> "On the Enforcement of Software Safety Policies". </title> <booktitle> In Proceedings of the Tenth Annual Conference on Computer Assurance, </booktitle> <pages> pages 83-93, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Conceptually, GenEx does the same thing, but the emphasis is on the local analysis and synchronization of components, and the complexity is kept low because the synchronization mechanism for every safety rule is independent. Another related concept is that of Safety Kernel <ref> [WK95] </ref> that is less formal, but involves the code generation capability and automatic safety implementation. This centralized, and more importantly sequential, paradigm makes the code generation trivial by reducing it to a simple runtime check of the desired property.
Reference: [Yeh93] <author> Wei Jen Yeh. </author> <title> "Controlling State Explosion in Reachability Analysis". </title> <type> PhD thesis, </type> <institution> Purdue University, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: The analysis of this state space is clearly not a viable way to find the safety violations and compute the synchronization conditions that prevent them. The analysis of the dining philosophers implementation does not require full state space traversals as was shown by Young and Yeh <ref> [YY91, Yeh93] </ref>. Their method extracted the regularity of the philosopher definition to reduce the complexity of the part of the state space that it had to analyze, and limited its growth to a linear function of the number of philosophers.
Reference: [YS97] <author> Daniel M. Yellin and Robert E. Strom. </author> <title> "Protocol specifications and component adaptors". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 19(2) </volume> <pages> 292-333, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: The interface and glue specifications are manually designed, and may be verified for consistency and compatibility. Another similar approach was developed by Katz [Kat93], where control constructs are superimposed on the behavior of the components to achieve specific system behaviors. 14 Yellin and Strom <ref> [YS97] </ref> discuss the automated synthesis of interface adaptors according to finite state protocol descriptions for the connectors being interfaced. This work is conceptually similar to the GenEx synchronization, but lacks the modular nature in the adaptor synthesis, and is limited to the message passing constraints, not the component behavior itself.
Reference: [YY91] <author> Michal Young and Wei Jen Yeh. </author> <title> "Compositional reachability analysis using process algebra". </title> <booktitle> In Proceedings of the Symposium on Softvare Testing, Analysis and Verification (TAV 4), </booktitle> <pages> pages 49-59, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: This system has been extensively studied in literature, both for synchronization design [Dij, Hoa78] and for system verification <ref> [YY91] </ref>. We will use this system to illustrate different aspects of automated synchronization. 2.2 Systems as Sets of Components The modular architecture of software systems is based on active concurrent components that communicate through passive interfaces. A component can be described by its control behavior and its data processing aspect. <p> Similar rules can be imposed for other pairs of philosophers to specify the interleaving of their eating. 63 4.3 Complexity Growth for Dining Philosophers The complexity of the state space for the dining philosophers is an exponential function of the number of philosophers, with up to 3 N philo states <ref> [YY91] </ref>. Every philosopher has 3 possible states, where the second state is reached when the philosopher takes one fork. <p> The analysis of this state space is clearly not a viable way to find the safety violations and compute the synchronization conditions that prevent them. The analysis of the dining philosophers implementation does not require full state space traversals as was shown by Young and Yeh <ref> [YY91, Yeh93] </ref>. Their method extracted the regularity of the philosopher definition to reduce the complexity of the part of the state space that it had to analyze, and limited its growth to a linear function of the number of philosophers.
Reference: [ZM + 94] <author> Nikolaj Bjorner Zohar Manna, Anuchit Anuchitanukul et al. </author> <title> "STeP: the Stanford Temporal Prover". </title> <month> June </month> <year> 1994. </year> <month> 108 </month>
Reference-contexts: This example shows the conceptual simplicity of composing systems for safety as well as a potential pitfall in automated synchronization. 11 source and do partial analysis. STeP <ref> [ZM + 94] </ref> tries to prove the given assertions automatically and when that fails it lets the designer guide the proof by choosing the assertions that are to be proved.
References-found: 50

