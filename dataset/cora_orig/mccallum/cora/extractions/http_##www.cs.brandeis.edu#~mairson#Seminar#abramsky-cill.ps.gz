URL: http://www.cs.brandeis.edu/~mairson/Seminar/abramsky-cill.ps.gz
Refering-URL: http://www.cs.brandeis.edu/~mairson/PL-oldtalks.html
Root-URL: http://www.cs.brandeis.edu
Email: sa@doc.ic.ac.uk  
Title: Computational Interpretations of Linear Logic  
Author: Samson Abramsky 
Date: October 30, 1990  
Address: Gate, London SW7 2BZ, England  
Affiliation: Department of Computing Imperial College of Science, Technology and Medicine 180 Queen's  
Abstract: We study Girard's Linear Logic from the point of view of giving a concrete computational interpretation of the logic, based on the Curry-Howard isomorphism. In the case of Intuitionistic Linear Logic, this leads to a refinement of the lambda calculus, giving finer control over order of evaluation and storage allocation, while maintaining the logical content of programs as proofs, and computation as cut-elimination. In the classical case, it leads to a concurrent process paradigm with an operational semantics in the style of Berry and Boudol's Chemical Abstract Machine. This opens up a promising new approach to the parallel implementation of functional programming languages; and offers the prospect of typed concurrent programming in which correctness is guaranteed by the typing. 
Abstract-found: 1
Intro-found: 1
Reference: [AH87] <editor> S. Abramsky and C. L. Hankin, editors. </editor> <title> Abstract Interpretation for Declarative Languages. </title> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference: [Bar84] <author> H. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> revised edition, </address> <year> 1984. </year>
Reference-contexts: To ensure that suitable linearity constraints are satisfied, we shall adopt the following Name Convention (cf. the Variable Convention in <ref> [Bar84] </ref>): different names are introduced for each instance of the Axiom, With and Of Course rules. <p> This is extended to a sub stitution on terms, coequations, proof expressions etc. in the usual way. Now we define structural equivalence of proof expressions: P Q () 9: ((P ) ff fl Q): Structural equivalence merely factors out irrelevant syntactic detail, similarly to ff equivalence in the -calculus <ref> [Bar84] </ref>. We can now state the appropriate form of Determinacy: Determinacy : P +Q & P +R =) Q R: The remainder of this subsection is devoted to proving this property. Firstly, it will be convenient to decompose the transition relation !. <p> Proof. If P = x ? t; fi; t ! c fi; t [t=x] ! r ffi; t [t=x], then P ! r x ? t; ffi; t ! c ffi; t [t=x]: By standard arguments <ref> [Bar84] </ref>, Propositions 7.4-7.7 imply the corresponding proper ties for ! fl r , ! fl Now we show that ! fl is confluent up to structural equivalence. <p> Cut (P; Q) = fi; ffi; t ? u; t; u: More precisely, we choose P 0 P , Q 0 Q such that N (P 0 ) " N (Q 0 ) = ?, and form Cut (P 0 ; Q 0 ) (compare the definition of substitution in <ref> [Bar84] </ref>); we will generally take this renaming for granted, and not refer to it explicitly. Note that Cut (P; Q) is only defined for proof expressions with non-empty main body; we will shortly take steps to excise this minor nuisance.
Reference: [BB90] <author> G. Berry and G. Boudol. </author> <title> The Chemical Abstract Machine. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 81-94, </pages> <year> 1990. </year>
Reference-contexts: In fact, our presentation of the operational semantics fits very nicely into the framework of the Chemical Abstract Machine proposed recently by Berry and Boudol <ref> [BB90] </ref> as a paradigm for concurrent abstract machines. They describe the basic ideas thus: Most available concurrency models are based on architectural concepts, e.g. networks of processes communicating by means of ports or channels. Such concepts convey a rigid geometrical vision of concurrency.
Reference: [BH90] <author> H. Barendregt and K. Hemerik. </author> <title> Types in lambda calculi and programming languages. </title> <booktitle> In Proceedings of ESOP 90, </booktitle> <year> 1990. </year>
Reference: [BW88] <author> R. Bird and P. Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference: [Coh81] <author> P. M. Cohn. </author> <title> Universal Algebra. </title> <address> D. </address> <publisher> Reidel, </publisher> <year> 1981. </year>
Reference-contexts: Given U PE, we can define U ? = fP 2 PE j 8Q 2 U: (P ? Q)g: Now by standard facts about Galois connections <ref> [Coh81] </ref>, we have: Proposition 7.12 (i) The operator () ?? is monotone, inflationary and idempotent. (ii) U ??? = U ? . A semantic type is a subset U PE satisfying: * U 6= ? * U = U ?? We write U for the set of all semantic types.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference: [FH88] <author> A. J. Field and P. G. Harrison. </author> <title> Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference: [Gal90] <author> J. Gallier. </author> <title> On Girard's "Candidats de Reductibilite". </title> <editor> In P.-G. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science. </booktitle> <publisher> North Holland, </publisher> <year> 1990. </year>
Reference: [Gir72] <author> J.-Y. Girard. </author> <title> Interpretation fonctionelle et elimination des coupures dans l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference: [Gir87] <author> J.-Y. Girard. </author> <title> Linear Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50(1) </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: Of course, these ideas are entirely in line with Girard's emphatic hints that Classical Linear Logic opens the way to a logical view of parallel computation <ref> [Gir87, Gir89b] </ref>. We shall now present a computational interpretation of CLL which seeks to embody these ideas in a simple and elegant form, in the general framework we have established in the preceding sections. <p> So each rule has a clear logical content. Finally, some brief remarks about the relationship between our proof-expressions and Girard's proof nets <ref> [Gir87] </ref>. (A detailed comparison must be left to future work.) I must admit that I have always found proof nets rather intractable. In fact, they formed the principal impediment to my understanding of Linear Logic. <p> Very roughly speaking, proof expressions correspond to proof nets, the lazy forms x (P [] Q) and x (P ) to proof boxes, and the reaction rules to the symmetric contractions, as described in <ref> [Gir87] </ref>. A more precise comparison would require some care; for example, the use of channels for both axiom contraction and the synchronization associated with the lazy types in our calculus does not appear in the proof net formalism. <p> To recapitulate: * Our operational definitions are much more compact, elegant, and memorable than 31 the calculus of proof nets presented in <ref> [Gir87] </ref>. * They correspond much better to what would actually be done in an implementation. (See Section 8.) * There are considerable technical benefits, the main one being that Determinacy is preserved. See Theorem 7.9, and Lemma 7.10. <p> Firstly, we will prove a very useful lemma, which will play a role in our work analogous to Girard's use of the Standardization Theorem in <ref> [Gir87] </ref>. Lemma 7.10 P ! fl Q & CSN (Q) =) CSN (P ). 36 Proof. We begin by making a number of reductions of what is to be proved. <p> In the light of this Proposition, we write P + rather than CSN (P ). Also, we define P * () :(P +). We now proceed with the proof of Convergence, following much the same lines as Girard's proof of Strong Normalization for PN2 in <ref> [Gir87] </ref>, but in the style of Section 5, and with some significant modifications dictated by the differences in our framework. 37 Firstly, some notation. <p> Next, we will establish the desired relationship between Cut (OfCourse ((P Q)); Q)+ and OfCourse (P ) QQ+. At the corresponding point in his proof in <ref> [Gir87] </ref>, Girard is able to use the commutative conversions, under which we would have OfCourse (P ) QQ ! fl Cut (OfCourse ((P Q)); Q): As the commutative conversions are not part of our calculus, we need a more elaborate argument.
Reference: [Gir89a] <author> J.-Y. Girard. </author> <title> Geometry of interaction 1: Interpretation of System F. </title> <editor> In R. Ferro et al., editor, </editor> <booktitle> Logic Colloquium 88. </booktitle> <publisher> North Holland, </publisher> <year> 1989. </year>
Reference: [Gir89b] <author> J.-Y. Girard. </author> <title> Towards a geometry of interaction. </title> <editor> In J. W. Gray and Andre Scedrov, editors, </editor> <booktitle> Categories in Computer Science and Logic, volume 92 of Contemporary Mathematics, </booktitle> <pages> pages 69-108. </pages> <publisher> American Mathematical Society, </publisher> <year> 1989. </year>
Reference-contexts: Of course, these ideas are entirely in line with Girard's emphatic hints that Classical Linear Logic opens the way to a logical view of parallel computation <ref> [Gir87, Gir89b] </ref>. We shall now present a computational interpretation of CLL which seeks to embody these ideas in a simple and elegant form, in the general framework we have established in the preceding sections.
Reference: [GJ86] <editor> H. Ganzinger and N. D. Jones, editors. </editor> <title> Programs as Data Objects, </title> <booktitle> volume 217 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference: [GLT89] <author> J.-Y. Girard, Y. Lafont, and P. Taylor. </author> <title> Proofs and Types, </title> <booktitle> volume 7 of Cam-bridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference: [GSS90] <author> J.-Y. Girard, A. Scedrov, and P. J. Scott. </author> <title> Bounded linear logic. </title> <editor> In S. R. Buss and P. J. Scott, editors, </editor> <booktitle> Proc. Math. Sci. Institute Workshop on Feasible Mathematics. </booktitle> <publisher> Birkhauser, </publisher> <year> 1990. </year>
Reference: [Hen80] <author> P. Henderson. </author> <title> Functional Programming: Applications and Implementation. </title> <publisher> Prentice Hall, </publisher> <year> 1980. </year> <month> 50 </month>
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: In particular, by linearity channels are used exactly once, so to determine the "strength" of the connection between terms t and u, we can simply count N (t) " N (u). (Contrast this with occam [LTD88] or CSP <ref> [Hoa85] </ref>, where what matters is not the number of channels two processes have in common, but the number of times the channels will be used.) A mapping algorithm could then attempt to optimize locality of reference by making the distance between two coequations inversely proportional to the strength of their connection.
Reference: [Hol88] <author> Soren Holmstrom. </author> <title> Linear functional programming. </title> <editor> In T. Johnsson, S. Peyton Jones, and K. Karlsson, editors, </editor> <booktitle> Proceedings of the Workshop on Implementation of Lazy Functional Languages, </booktitle> <pages> pages 13-32, </pages> <year> 1988. </year>
Reference: [Hue90] <editor> G. Huet, editor. </editor> <booktitle> Logical Foundations of Functional Programming. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference: [HW88] <author> P. Hudak and P. Wadler. </author> <title> Report on the functional programming language Haskell. </title> <type> Technical Report YALEU/DCS/RR666, </type> <institution> Department of Computer Science, Yale University, </institution> <month> November </month> <year> 1988. </year>
Reference: [JJK88] <editor> T. Johnsson, S. Peyton Jones, and K. Karlsson, editors. </editor> <booktitle> Proceedings of the Workshop on Implementation of Lazy Functional Languages. Programming Methodology Group, </booktitle> <institution> Chalmers University, </institution> <year> 1988. </year>
Reference-contexts: In particular: * The only requirement for inter-agent sharing and synchronization arises from the handling of names as described above. This seems much simpler than recent pro posals e.g. for architectures to perform parallel graph reduction <ref> [JJK88] </ref>. * There are no centralized resources. Indeed, there are no distinguished nodes in the network.
Reference: [Kah87] <author> G. Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proc. Symposium on Theoretical Aspects of Computer Science, volume 247 of Lecture Notes in Computer Science, </booktitle> <pages> pages 22-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference: [Laf88] <author> Y. Lafont. </author> <title> The Linear Abstract Machine. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 59(1,2):157-180, </address> <year> 1988. </year>
Reference: [Lan64] <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1964. </year>
Reference: [Lan65] <author> P. J. Landin. </author> <title> A correspondence between ALGOL 60 and Church's lambda notation. </title> <journal> Communications of the ACM, </journal> <volume> 8 89-101,158-165, </volume> <year> 1965. </year>
Reference: [LTD88] <author> INMOS LTD. </author> <title> occam 2 Reference Manual. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: In particular, by linearity channels are used exactly once, so to determine the "strength" of the connection between terms t and u, we can simply count N (t) " N (u). (Contrast this with occam <ref> [LTD88] </ref> or CSP [Hoa85], where what matters is not the number of channels two processes have in common, but the number of times the channels will be used.) A mapping algorithm could then attempt to optimize locality of reference by making the distance between two coequations inversely proportional to the strength
Reference: [MC88] <author> A. Meyer and S. Cosmodakis. </author> <title> Semantical Paradigms. </title> <booktitle> In Proc. Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 236-255. </pages> <publisher> Computer Society Press, </publisher> <year> 1988. </year>
Reference: [McC63] <author> J. McCarthy. </author> <title> A basis for a mathematical theory of computation. </title> <editor> In P. Braffort and D. Hirschberg, editors, </editor> <booktitle> Computer Programming and Formal Systems, </booktitle> <pages> pages 33-69. </pages> <publisher> North Holland, </publisher> <year> 1963. </year>
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus for Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: At this point it becomes very natural to invoke concurrency theory, as offering just the kind of generalization we need. As Milner has emphasized throughout his work on concurrency <ref> [Mil80, Mil90] </ref>, communicating processes can be thought of as a generalization of functions, while the key operation of parallel composition is a commutative operation which generalizes function application or composition.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: We shall use a technique inspired by concurrency theory <ref> [Mil89] </ref>. We say that a relation R PE 2 is a simulation if it satisfies P RQ & P ! R =) 9P 0 ; Q 0 :(R ! fl P 0 & Q ! + Q 0 & P 0 RQ 0 ): We need to establish some notation.
Reference: [Mil90] <author> R. Milner. </author> <title> Functions as processes. </title> <booktitle> In Proceedings of ICALP 90, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-180. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: At this point it becomes very natural to invoke concurrency theory, as offering just the kind of generalization we need. As Milner has emphasized throughout his work on concurrency <ref> [Mil80, Mil90] </ref>, communicating processes can be thought of as a generalization of functions, while the key operation of parallel composition is a commutative operation which generalizes function application or composition. <p> coequation either as a single sequential process, or as a tightly-coupled synchronous parallel composition of two processes, proceeding in lockstep. (So coequations could be modelled by "membranes" in Berry and Boudol's terminology; but we shall not pursue this idea.) We distinguish between two kinds of rule for the CHAM (cf. <ref> [Mil90] </ref>): structural rules, which describe the "magical mixing" of the solution; and reaction rules, which describe the actual computation steps.
Reference: [ML84] <author> P. Martin-Lof. </author> <title> Intuitionistic Type Theory. </title> <publisher> Bibliopolis, </publisher> <address> Naples, </address> <year> 1984. </year>
Reference: [MP85] <author> J. C. Mitchell and G. D. Plotkin. </author> <title> Abstract types have existential type. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 37-51, </pages> <year> 1985. </year> <month> 51 </month>
Reference-contexts: This property is easily checked to hold for derivable proof expressions, and to be preserved under the transition relation. Stripping off the types again, this establishes the Proposition. The appearance of 9 in the hypotheses of this proposition should not be a surprise. 9 provides "information hiding" (cf. <ref> [MP85] </ref>), and the information hidden may well include the use of lazy types. Theorem 7.20 If PE 2 ` fi; t : , fi; t+P , and does not contain any occurrences of &, ! or 9, then P is cut-free. Proof.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [Myc80] <author> A. Mycroft. </author> <title> The theory and practice of transforming call-by-need into call-by-value. </title> <editor> In B. Robinet, editor, </editor> <booktitle> International Symposium on Programming, volume 83 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference: [PJ87] <editor> S. L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference: [Plo75] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference: [Plo85] <author> G. D. Plotkin. </author> <title> Lectures on predomains and partial functions. Notes for a course given at the Center for the Study of Language and Information, </title> <publisher> Stanford, </publisher> <year> 1985. </year>
Reference: [Rey85] <author> J. C. Reynolds. </author> <title> Three approaches to type structure. </title> <editor> In H. Ehrig, C. Floyd, M. Nivat, and J. Thatcher, editors, </editor> <booktitle> Mathematical Foundations of Software Development, volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-138. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [San89] <author> D. Sands. </author> <title> Complexity analysis for a lazy higher order language. </title> <booktitle> In Proceedings of the Second Glasgow Workshop on Functional Programming, </booktitle> <year> 1989. </year>
Reference: [Tur85] <author> D. A. Turner. </author> <title> Miranda|a non-strict functional language with polymorphic types. </title> <editor> In J.P. Jouannaud, editor, </editor> <booktitle> Functional programming languages and Computer Architectures, volume 201 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [Tur90] <editor> D. A. Turner, editor. </editor> <booktitle> Research Topics in Functional Programming. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference: [Wad89] <author> P. Wadler. </author> <title> Linear types can change the world! Draft paper, </title> <booktitle> 1989. </booktitle> <pages> 52 </pages>
References-found: 44

