URL: http://www.cs.purdue.edu/homes/spaf/spyder/TR103P.ps
Refering-URL: http://www.cs.purdue.edu/homes/spaf/students.html
Root-URL: http://www.cs.purdue.edu
Title: TOWARDS AUTOMATIC DEBUGGING OF COMPUTER PROGRAMS  
Author: by Hiralal Agrawal 
Degree: A Thesis Submitted to the Faculty of  In Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy  
Date: August 1991  
Affiliation: Purdue University  
Abstract-found: 0
Intro-found: 1
Reference: <institution> 173 BIBLIOGRAPHY </institution>
Reference: [AB82] <author> W. R. Adrion and M. A. Branstad. </author> <title> Validation, verification, and testing of computer software. </title> <journal> ACM Computing Surveys, </journal> <volume> 14(2) </volume> <pages> 159-192, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: Much research has gone into answering the question of how to select testcases judiciously (see e.g. <ref> [DMMP87, How87, AB82] </ref>). But, surprisingly, much less work has been done on the equally important topic of how to localize bugs revealed by these testcases. Few tools or techniques are available to help programmers debug their programs.
Reference: [ACS84] <author> James E. Archer, Jr., Richard Conway, and Fred B. Schneider. </author> <title> User recovery and reversal in interactive systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 1-19, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: In Chapter 7 we present a structured backtracking approach to execution backtracking which attempts to overcome this problem. Igor [FB88] and Cope <ref> [ACS84] </ref> also provide execution backtracking by performing periodic checkpointing of memory pages or file blocks modified during program execution.
Reference: [AM86] <author> Evan Adams and Steven S. Muchnick. Dbxtool: </author> <title> a window-based symbolic debugger for Sun work-stations. </title> <journal> Software Practice and Experience, </journal> <volume> 16(7) </volume> <pages> 653-669, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: The usual debugging cycle for compiled programs | edit, compile, execute, and debug | is considerably shortened in such systems. Window- and mouse-based symbolic debuggers using bitmapped displays like Dbx-tool <ref> [AM86] </ref>, Pi [Car83, Car86], and Saber C bring about a significant improvement over traditional command-driven debuggers from the user-interface perspective. With such debuggers instead of having to type the debugging commands the user can simply select them using the mouse and button-clicks. <p> Source code is simultaneously displayed in one or more windows, and the current control location is highlighted, e.g., with an arrow pointing at the next statement to be executed. In Dbxtool <ref> [AM86] </ref> and Saber C, the user can select any variables or expressions in the source-window with the help of the mouse and request their values to be displayed.
Reference: [ANS83] <author> ANSI/IEEE. </author> <title> IEEE standard glossary of software engineering terminology. </title> <publisher> IEEE Std 729-1983, IEEE, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: Because of the presence of faults, the automaton may fail on certain inputs. The incorrect output produced by a faulty automaton is referred to as a failure, and faults in the automaton that cause the failure are referred to as bugs <ref> [ANS83] </ref>. In other words, a fault is a cause and a failure is a symptom. Faults get introduced in a program because of errors committed by programmers while translating specifications into implementations or because of errors in specifications themselves.
Reference: [AS89] <author> Hiralal Agrawal and Eugene H. Spafford. </author> <title> A bibliography on debugging and backtracking. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 14(2) </volume> <pages> 49-56, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: As the problem of debugging parallel, logic, functional, or optimized programs is not in the scope of this dissertation, we have not included related work in these areas here, though research is also being carried out in these areas (see, e.g., <ref> [MH89, AS89, Hen82, Zel84, Cou88] </ref>). 22 3. SIMPLE DYNAMIC SLICING Often during debugging, value of a variable, var , at a program statement, S, is observed to be incorrect.
Reference: [Bal69] <author> R. M. Balzer. </author> <title> Exdams: Extendible debugging and monitoring system. </title> <booktitle> In AFIPS Proceedings, Spring Joint Computer Conference, </booktitle> <volume> volume 34, </volume> <pages> pages 567-580, </pages> <address> Montvale, New Jersey, 1969. </address> <publisher> AFIPS Press. </publisher>
Reference-contexts: Exdams, an interactive debugging tool for Fortran developed in the late 1960s, provided an execution replay facility <ref> [Bal69] </ref>. In that system, first the complete history tape of the program being debugged for a testcase was saved. Then the program was "executed" through a "playback" of this tape.
Reference: [BC85] <author> Jean-Francois Bergeretti and Bernard A. Carre. </author> <title> Information-flow and data-flow analysis of while programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 37-61, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Berg-eretti and Carre also defined information-flow relations somewhat similar to data- and control dependence relations, that can be used to obtain static program slices (referred to as "partial statements" by them) <ref> [BC85] </ref>. Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, software metrics, etc. (see, e.g., [Wei84, BC85, HPR89b, GL89, OT89, LOS86]). <p> Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, software metrics, etc. (see, e.g., <ref> [Wei84, BC85, HPR89b, GL89, OT89, LOS86] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition.
Reference: [Bea83] <author> Bert Beander. </author> <title> Vax DEBUG: an interactive, symbolic, multilingual debugger. </title> <booktitle> In Proceedings of the Software Engineering Symposium on High-Level Debugging, </booktitle> <address> Pacific Grove, CA, </address> <month> March </month> <year> 1983. </year> <journal> ACM SIG-SOFT/SIGPLAN. Software Engineering Notes, </journal> <volume> 8(4) </volume> <month> 173-179, </month> <journal> August 1983; SIGPLAN Notices, </journal> 18(8):173-179, August 1983. 
Reference-contexts: Further, these print statements usually need to be deleted (or commented out) from the program once the bug has been detected and fixed. 12 Interactive symbolic debuggers allow runtime control over display of debugging information without requiring the user to modify the source code <ref> [Bea83, Dun86, Kat79] </ref>. They provide the capability of setting breakpoints in the program as their basic debugging facility. The user can specify one or more statements as breakpoints, so whenever the control reaches any of these locations the program execution is suspended and control is passed to the debugger.
Reference: [Boe81] <author> B. W. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: Anyone who has ever engaged in serious programming knows that software testing and debugging are hard problems. As much as twenty-five to fifty percent of the total system development cost and time may be spent on these activities alone <ref> [Zel78, Boe81] </ref>. It has been suggested that the best solution to the problem of bugs 2 is to ensure that they never get into the program in the first place.
Reference: [Bro88] <author> M. H. Brown. </author> <title> Algorithm Animation. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year> <month> 174 </month>
Reference-contexts: The arrow moves up or down (and new rectangles added or deleted) as numbers are pushed on or popped off the stack. Such debuggers are still in their infancy, and presently are able to handle only small programs with simple data-structures. Research in the area of algorithm animation <ref> [BS85, Bro88, LD85] </ref> has much to offer in this respect. 2.3 Debugging with Specifications A debugging technique called "two-dimensional pinpointing" [LST91] aims at locating inconsistencies in software that is structured in levels. It requires that formal specifications defining the program's desired behavior at each structural level be provided.
Reference: [BS85] <author> M. H. Brown and R. Sedgewick. </author> <title> Techniques for algorithm animation. </title> <journal> IEEE Software, </journal> <pages> pages 28-39, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: The arrow moves up or down (and new rectangles added or deleted) as numbers are pushed on or popped off the stack. Such debuggers are still in their infancy, and presently are able to handle only small programs with simple data-structures. Research in the area of algorithm animation <ref> [BS85, Bro88, LD85] </ref> has much to offer in this respect. 2.3 Debugging with Specifications A debugging technique called "two-dimensional pinpointing" [LST91] aims at locating inconsistencies in software that is structured in levels. It requires that formal specifications defining the program's desired behavior at each structural level be provided.
Reference: [Car83] <author> Thomas A. Cargill. </author> <title> The Blit debugger. </title> <journal> Journal of Systems and Software, </journal> <volume> 3(4) </volume> <pages> 277-284, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: The usual debugging cycle for compiled programs | edit, compile, execute, and debug | is considerably shortened in such systems. Window- and mouse-based symbolic debuggers using bitmapped displays like Dbx-tool [AM86], Pi <ref> [Car83, Car86] </ref>, and Saber C bring about a significant improvement over traditional command-driven debuggers from the user-interface perspective. With such debuggers instead of having to type the debugging commands the user can simply select them using the mouse and button-clicks.
Reference: [Car86] <author> Thomas A. Cargill. </author> <title> The feel of Pi. </title> <booktitle> In Proceedings of the Winter Usenix Conference, </booktitle> <pages> pages 62-71, </pages> <address> Denver, CO, </address> <month> January </month> <year> 1986. </year>
Reference-contexts: The usual debugging cycle for compiled programs | edit, compile, execute, and debug | is considerably shortened in such systems. Window- and mouse-based symbolic debuggers using bitmapped displays like Dbx-tool [AM86], Pi <ref> [Car83, Car86] </ref>, and Saber C bring about a significant improvement over traditional command-driven debuggers from the user-interface perspective. With such debuggers instead of having to type the debugging commands the user can simply select them using the mouse and button-clicks. <p> In Dbxtool [AM86] and Saber C, the user can select any variables or expressions in the source-window with the help of the mouse and request their values to be displayed. Pi <ref> [Car86] </ref> provides context dependent pop-up menus of variable names, visible in the current scope, for selecting and displaying their values. 14 2.2 Pictorial Debugging Some debuggers like VIPS [ISO87, SI91] and PROVIDE [Moh88] go a step further and attempt to present both the control-flow and the data-structures pictorially to the user.
Reference: [CC87a] <author> Fun Ting Chan and Tsong Yueh Chen. </author> <title> AIDA|a dynamic data flow anomaly detection system for Pascal programs. </title> <journal> Software Practice and Experience, </journal> <volume> 17(3) </volume> <pages> 227-239, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: Dynamic anomaly detection techniques, on the other hand, detect anomalous conditions that arise during actual program executions <ref> [Hua79, CC87a] </ref>. These techniques instrument the program with extra code that checks for any anomalous behavior, such as the conditions mentioned above, to occur during the program execution. The anomalies detected this way are almost always indicative of errors or inefficient program behavior.
Reference: [CC87b] <author> James S. Collofello and Larry Cousins. </author> <title> Towards automatic software fault location through decision to decision path analysis. </title> <booktitle> In Proceedings of the 1987 National Computer Conference, </booktitle> <pages> pages 539-544, </pages> <year> 1987. </year>
Reference-contexts: Examining the difference, in this case, should lead to faster localization of the fault on line 19 compared to examining the complete dynamic program slice shown in Figure 6.1. Collofello and Cousins <ref> [CC87b] </ref> have proposed a similar approach where they find basic-blocks (referred to as "decision-to-decision-paths" by them) in the program that control reaches when the program is executed for an error-revealing testcase but that are not reached when the program is executed for any non-error-revealing testcase.
Reference: [CF89] <author> Robert Cartwright and Matthias Felleisen. </author> <title> The semantics of program dependence. </title> <booktitle> In Proceedings of the ACM SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 13-27, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: We examine the consequences of this requirement in Chapter 3 (Section 3.4.4.1). Several people have also investigated the semantic basis of program slicing <ref> [Ven91, RY88, CF89, Sel89] </ref>. 2.7 Program Dicing Slicing uses the information that the value of a variable is incorrect to narrow down the search for the fault. It does not, however, use the information that values of many other variables may be correct.
Reference: [Cou88] <author> Deborah S. Coutant. </author> <title> Doc: a practical approach to source-level debugging of globally optimized code. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 125-134, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: As the problem of debugging parallel, logic, functional, or optimized programs is not in the scope of this dissertation, we have not included related work in these areas here, though research is also being carried out in these areas (see, e.g., <ref> [MH89, AS89, Hen82, Zel84, Cou88] </ref>). 22 3. SIMPLE DYNAMIC SLICING Often during debugging, value of a variable, var , at a program statement, S, is observed to be incorrect.
Reference: [CWZ90] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Further, when such a reference occurs inside a loop, the memory location referenced may vary from one loop iteration to another. The difficulty is compounded if the language used is not strongly-typed and permits integer arithmetic over pointer variables. Techniques proposed in <ref> [CWZ90, HPR89a, LH88] </ref> may be used to obtain conservative static approximations of what a pointer might point to at run time, but in the presence of unconstrained pointers, as in C, such analysis has only limited usefulness.
Reference: [DE88] <author> Mireille Ducasse and Anna-Maria Emde. </author> <title> A review of automated debugging systems: Knowledge, strategies and techniques. </title> <booktitle> In Proceedings of the Tenth International Conference on Software Engineering, </booktitle> <pages> pages 162-171, </pages> <address> Singapore, </address> <month> April </month> <year> 1988. </year> <note> IEEE. </note>
Reference-contexts: Their approach is targeted to find simple operator and operand faults in the program. 2.5 Knowledge-Based Debugging Attempts have also been made to apply artificial intelligence techniques to the debugging problem. In particular, many experimental systems have been developed using the knowledge-based approach (see, e.g., <ref> [Sev87, DE88] </ref>). However, all these 16 systems can presently handle only a restricted class of bugs in small programs. We discuss a few representative knowledge-based debugging systems below.
Reference: [Dij76] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1976. </year>
Reference-contexts: To this effect, it has been argued that program verification or "proving programs correct" would eliminate the need for testing and debugging <ref> [Dij76, Hoa69, NR69] </ref>. Program verification requires that the program behavior be expressed as assertions on its input and output. Then one has to prove that the output assertion holds whenever the program is executed on an input that satisfies the input assertion.
Reference: [DKM91] <author> Richard A. DeMillo, Edward W. Krauser, and Aditya P. Mathur. </author> <title> Compiler-integrated program mutation. </title> <booktitle> In Proceedings of the Fifteenth Annual Computer Software and Applications Conference. IEEE, Septem-ber 1991. </booktitle> <pages> 175 </pages>
Reference-contexts: Another promising approach to reduce the context switching overhead is to have the debugger "patch" the object code of the debugging process with instructions that do all the necessary logging of information required for dynamic slicing and backtracking purposes <ref> [Kra91, DKM91] </ref>. 9.4 Future Directions We conclude this dissertation by listing some ideas on extending our work and some preliminary thoughts on other research directions. 9.4.1 Fault Prediction Heuristics In Chapter 6, we discussed several heuristics based on combining multiple dynamic slices in certain ways.
Reference: [DLP79] <author> R. A. DeMillo, R. J. Lipton, and A. J. Perlis. </author> <title> Social processes and the proofs of theorems and programs. </title> <journal> Communications of the ACM, </journal> <volume> 22(5) </volume> <pages> 271-280, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Then one has to prove that the output assertion holds whenever the program is executed on an input that satisfies the input assertion. While this approach works well in theory, several problems arise in practice <ref> [DLP79] </ref>: Firstly, for many real-life programs, characterizing their behavior mathematically may not always be feasible, thus precluding the use of any mathematical reasoning on them. Further, constructing program-proofs can be an arduous task. Proofs are generally much more difficult to construct and understand than the programs themselves.
Reference: [DM91] <author> Richard A. DeMillo and Aditya P. Mathur. </author> <title> On the use of software artifacts to evaluate the effectiveness of mutation analysis for detecting errors in production software. </title> <type> Technical Report SERC-TR-92-P, </type> <institution> Software Engineering Research Center, Purdue University, West Lafayette, IN, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: we explore how we can use this observation to derive several heuristics that help further localize the fault. 109 6.1.1 Varying the Testcase Argument A testcase, T , for a program, P , is said to be an error-revealing testcase if P produces an incorrect output when executed on T <ref> [DM91] </ref>, and it is called a non-error-revealing testcase if it produces the correct output. 6.1.1.1 Difference of Dynamic Slices Many times we have a situation where a program works correctly on one testcase but fails on another.
Reference: [DMMP87] <author> R. A. DeMillo, W. M. McCracken, R. J. Martin, and J. F. Passafiume. </author> <title> Software Testing and Evaluation. </title> <publisher> Benjamin/Cummings Publishing Co., </publisher> <address> Menlo Park, CA, </address> <year> 1987. </year>
Reference-contexts: Much research has gone into answering the question of how to select testcases judiciously (see e.g. <ref> [DMMP87, How87, AB82] </ref>). But, surprisingly, much less work has been done on the equally important topic of how to localize bugs revealed by these testcases. Few tools or techniques are available to help programmers debug their programs.
Reference: [Dun86] <author> Kevin J. Dunlap. </author> <title> Debugging with Dbx. In Unix Programmers Manual, </title> <type> Supplementary Documents 1. </type> <institution> 4.3 Berkeley Software Distribution, Computer Science Division, University of California, Berkeley, </institution> <address> CA, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: Few tools or techniques are available to help programmers debug their programs. The tools that are available all basically provide breakpoints and traces as their main debugging aids <ref> [Kat79, MB79, Dun86, Wei82] </ref>. Unfortunately, these traditional mechanisms are often inadequate for the task of quickly isolating program faults. In this dissertation, we present a new paradigm for debugging based on dynamic program slicing, fault guessing, and execution backtracking techniques. <p> Further, these print statements usually need to be deleted (or commented out) from the program once the bug has been detected and fixed. 12 Interactive symbolic debuggers allow runtime control over display of debugging information without requiring the user to modify the source code <ref> [Bea83, Dun86, Kat79] </ref>. They provide the capability of setting breakpoints in the program as their basic debugging facility. The user can specify one or more statements as breakpoints, so whenever the control reaches any of these locations the program execution is suspended and control is passed to the debugger.
Reference: [FB88] <author> Stuart I. Feldman and Channing B. Brown. Igor: </author> <title> a system for program debugging via reversible execution. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988. </year> <journal> ACM SIG-PLAN/SIGOPS. SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 112-123, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: As new events occur, the existing events on the list are aged, with oldest events "forgotten." Thus returning to points arbitrarily far back in the execution may not be possible. In Chapter 7 we present a structured backtracking approach to execution backtracking which attempts to overcome this problem. Igor <ref> [FB88] </ref> and Cope [ACS84] also provide execution backtracking by performing periodic checkpointing of memory pages or file blocks modified during program execution.
Reference: [Fet88] <author> J. H. </author> <title> Fetzer. Program verification: the very idea. </title> <journal> Communications of the ACM, </journal> <volume> 31(9) </volume> <pages> 1048-1063, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: This principle manifests itself in numerous undecidability results, that cover most interesting aspects of program behavior for any non-trivial programming system [HR67]. More recently, in <ref> [Fet88] </ref>, Fetzer goes as far as suggesting that "the success of program verification as a generally applicable and completely reliable method for guaranteeing program performance is not even a theoretical possibility." Structured programming is another solution often cited to be the cure for bugs.
Reference: [FO76] <author> Lloyd D. Fosdick and Leon J. Osterweil. </author> <title> Data flow analysis in software reliability. </title> <journal> ACM Computing Surveys, </journal> <volume> 8(3) </volume> <pages> 305-330, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: We discuss this approach again in Chapter 6. 2.8 Anomaly Detection In the static anomaly detection approach, a program is analyzed using data-flow analysis to detect certain conditions in the program that are generally indicative of errors or inefficiencies <ref> [OF76, FO76] </ref>.
Reference: [FOW87] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its uses in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: is the set of edges that reflect control dependencies between vertices in V [fIng, and In is a dummy initial node that is not in V (unlike a flow-graph where En and Ex both belong to 4 At other places in the literature, particularly that related to vectorizing compilers, e.g., <ref> [KKL + 81, FOW87] </ref>, direction of edges in the Data Dependence Graphs is reversed, but for the purposes of program slicing our definition is more suitable, as will become apparent later. 32 33 V ).
Reference: [GL89] <author> Keith B. Gallagher and James R. Lyle. </author> <title> A program decomposition scheme with applications to software modification and testing. </title> <booktitle> In Proceedings of the Twenty-Second Annual Hawaii International Conference on System Sciences, volume II, Software Track, </booktitle> <pages> pages 479-485, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, software metrics, etc. (see, e.g., <ref> [Wei84, BC85, HPR89b, GL89, OT89, LOS86] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition.
Reference: [Gou75] <author> J. D. Gould. </author> <title> Some psychological evidence on how people debug computer programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 7(1) </volume> <pages> 151-182, </pages> <month> January </month> <year> 1975. </year>
Reference-contexts: However, for many programs, especially lengthy ones, such analysis is much too difficult to perform. One logical way to proceed in such situations would be to think backwards|deduce the conditions under which the program produces the incorrect output <ref> [Sch71, Gou75, Luk80] </ref>. Consider, for example, the program in the main window panel of Figure 1.1. 1 This program computes the sum of the areas of N triangles. It reads the value of N , followed by the lengths of the three sides of each of these N triangles.
Reference: [Hen82] <author> John Hennessy. </author> <title> Symbolic debugging of optimized code. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 323-344, </pages> <year> 1982. </year>
Reference-contexts: As the problem of debugging parallel, logic, functional, or optimized programs is not in the scope of this dissertation, we have not included related work in these areas here, though research is also being carried out in these areas (see, e.g., <ref> [MH89, AS89, Hen82, Zel84, Cou88] </ref>). 22 3. SIMPLE DYNAMIC SLICING Often during debugging, value of a variable, var , at a program statement, S, is observed to be incorrect.
Reference: [Hoa69] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-580, 583, </pages> <month> October </month> <year> 1969. </year> <month> 176 </month>
Reference-contexts: To this effect, it has been argued that program verification or "proving programs correct" would eliminate the need for testing and debugging <ref> [Dij76, Hoa69, NR69] </ref>. Program verification requires that the program behavior be expressed as assertions on its input and output. Then one has to prove that the output assertion holds whenever the program is executed on an input that satisfies the input assertion.
Reference: [How87] <author> W. E. Howden. </author> <title> Functional Program Testing and Analysis. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Much research has gone into answering the question of how to select testcases judiciously (see e.g. <ref> [DMMP87, How87, AB82] </ref>). But, surprisingly, much less work has been done on the equally important topic of how to localize bugs revealed by these testcases. Few tools or techniques are available to help programmers debug their programs.
Reference: [HPR89a] <author> Susan Horwitz, Phil Pfeiffer, and Thomas Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 28-40, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Further, when such a reference occurs inside a loop, the memory location referenced may vary from one loop iteration to another. The difficulty is compounded if the language used is not strongly-typed and permits integer arithmetic over pointer variables. Techniques proposed in <ref> [CWZ90, HPR89a, LH88] </ref> may be used to obtain conservative static approximations of what a pointer might point to at run time, but in the presence of unconstrained pointers, as in C, such analysis has only limited usefulness.
Reference: [HPR89b] <author> Susan Horwitz, Jan Prins, and Thomas Reps. </author> <title> Integrating noninterfering versions of programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 345-387, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, software metrics, etc. (see, e.g., <ref> [Wei84, BC85, HPR89b, GL89, OT89, LOS86] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition.
Reference: [HR67] <author> Jr. Hartley Rogers. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1967. </year>
Reference-contexts: This principle manifests itself in numerous undecidability results, that cover most interesting aspects of program behavior for any non-trivial programming system <ref> [HR67] </ref>. More recently, in [Fet88], Fetzer goes as far as suggesting that "the success of program verification as a generally applicable and completely reliable method for guaranteeing program performance is not even a theoretical possibility." Structured programming is another solution often cited to be the cure for bugs.
Reference: [HRB90] <author> Susan Horwitz, Thomas Reps, and David Binkeley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Horwitz, Reps, and Binkley extended the program dependence graph representation to what they call the "system dependence graph" to find inter-procedural static slices under the same graph-reachability framework <ref> [HRB90] </ref>. Berg-eretti and Carre also defined information-flow relations somewhat similar to data- and control dependence relations, that can be used to obtain static program slices (referred to as "partial statements" by them) [BC85]. <p> Memory cells that correspond to def sets belong to the current activation record of proc on the stack. Note that unlike interprocedural static slicing <ref> [HRB90] </ref>, our approach for dynamic slicing does not require that we determine which global variables are referenced inside a procedure, or which variables may be aliases to each other, nor do we need to eliminate name conflicts among variables in different procedures.
Reference: [Hua79] <author> J. C. Huang. </author> <title> Detection of data flow anomaly through program instrumentation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(3):226-236, </volume> <month> May </month> <year> 1979. </year>
Reference-contexts: Dynamic anomaly detection techniques, on the other hand, detect anomalous conditions that arise during actual program executions <ref> [Hua79, CC87a] </ref>. These techniques instrument the program with extra code that checks for any anomalous behavior, such as the conditions mentioned above, to occur during the program execution. The anomalies detected this way are almost always indicative of errors or inefficient program behavior.
Reference: [ISO87] <author> Sadahiro Isoda, Takao Shimomura, and Yuji Ono. </author> <title> Vips: a visual debugger. </title> <journal> IEEE Software, </journal> <volume> 4(3) </volume> <pages> 8-19, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Pi [Car86] provides context dependent pop-up menus of variable names, visible in the current scope, for selecting and displaying their values. 14 2.2 Pictorial Debugging Some debuggers like VIPS <ref> [ISO87, SI91] </ref> and PROVIDE [Moh88] go a step further and attempt to present both the control-flow and the data-structures pictorially to the user. The graphical representations on the screen are updated dynamically as the program execution proceeds.
Reference: [JS85] <author> W. L. Johnson and E. Soloway. </author> <title> Proust: Knowledge-based program understanding. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(3) </volume> <pages> 267-275, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: Then it constructs an assertion describing the program behavior by combining the assertions fetched from the knowledge-base. The constructed assertion is matched with the given assertion, and if the two differ the process is traced back to suggest possible bugs. Proust <ref> [JS85] </ref> uses the opposite approach. It also takes a program and a formal specification of the program as inputs, but it tries to "synthesize" a program from the specifications, while trying to match the synthesized program with the given program.
Reference: [Kat79] <author> H. Katsoff. Sdb: </author> <title> a symbolic debugger. Unix Programmer's Manual, </title> <year> 1979. </year>
Reference-contexts: Few tools or techniques are available to help programmers debug their programs. The tools that are available all basically provide breakpoints and traces as their main debugging aids <ref> [Kat79, MB79, Dun86, Wei82] </ref>. Unfortunately, these traditional mechanisms are often inadequate for the task of quickly isolating program faults. In this dissertation, we present a new paradigm for debugging based on dynamic program slicing, fault guessing, and execution backtracking techniques. <p> Further, these print statements usually need to be deleted (or commented out) from the program once the bug has been detected and fixed. 12 Interactive symbolic debuggers allow runtime control over display of debugging information without requiring the user to modify the source code <ref> [Bea83, Dun86, Kat79] </ref>. They provide the capability of setting breakpoints in the program as their basic debugging facility. The user can specify one or more statements as breakpoints, so whenever the control reaches any of these locations the program execution is suspended and control is passed to the debugger.
Reference: [KKL + 81] <author> D. J. Kuck, R. H. Kuhn, B. Leasure, D. A. Padua, and M. Wolfe. </author> <title> Dependence graphs and compiler optimizations. </title> <booktitle> In Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-218, </pages> <address> Williamsburg, VA, </address> <month> January </month> <year> 1981. </year> <journal> ACM SIGPLAN. </journal>
Reference-contexts: is the set of edges that reflect control dependencies between vertices in V [fIng, and In is a dummy initial node that is not in V (unlike a flow-graph where En and Ex both belong to 4 At other places in the literature, particularly that related to vectorizing compilers, e.g., <ref> [KKL + 81, FOW87] </ref>, direction of edges in the Data Dependence Graphs is reversed, but for the purposes of program slicing our definition is more suitable, as will become apparent later. 32 33 V ).
Reference: [KL88a] <author> Bogdan Korel and Janusz Laski. </author> <title> Dynamic program slicing. </title> <journal> Information Processing Letters, </journal> <volume> 29 </volume> <pages> 155-163, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Nodes in bold give the Dynamic Slice for this testcase with respect to variable Z at the end of execution 57 DynamicSlice (hist , var ) = ReachableNodes (DynamicReachingDefn (var , hist ), DynamicDep (hist )) Contrast this definition of a dynamic slice with that proposed by Korel and Laski <ref> [KL88a] </ref>. Their definition may yield unnecessarily large dynamic slices.
Reference: [KL88b] <author> Bogdan Korel and Janusz Laski. </author> <title> Stad|a system for testing and debugging: User perspective. </title> <booktitle> In Proceedings of the Second Workshop on Software Testing, Verification, and Analysis, </booktitle> <pages> pages 13-20, </pages> <address> Banff, Canada, </address> <month> July </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: Then other debugging techniques may be used to further localize the bug within that procedure. Korel and Laski's STAD (A System for Testing and Debugging) provides a similar fault-diagnosis approach at the intra-procedure level for a subset of Pascal <ref> [KL91, KL88b] </ref>, except that instead of asking users to verify the input-output correctness of procedure calls, it asks them questions like if a given assignment is the correct reaching definition of a variable at a given location, or if the control has correctly reached a given location, etc.
Reference: [KL90] <author> Bogdan Korel and Janusz Laski. </author> <title> Dynamic slicing of computer programs. </title> <journal> Journal of Systems and Software, </journal> <volume> 13(3) </volume> <pages> 187-195, </pages> <month> November </month> <year> 1990. </year> <month> 177 </month>
Reference-contexts: To 18 detect program faults other than infinite loops, however, strong control dependence gives much finer slices compared to weak control dependence. The definition of data-dependence remains the same in both cases. Korel and Laski extended Weiser's static slicing algorithms for the dynamic case <ref> [KL90] </ref>. Their definition of a dynamic slice is different from ours (see Chapter 3).
Reference: [KL91] <author> Bogdan Korel and Janusz Laski. </author> <title> Algorithmic software fault localization. </title> <booktitle> In Proceedings of the Twenty-Fourth Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 246-252, </pages> <year> 1991. </year>
Reference-contexts: Then other debugging techniques may be used to further localize the bug within that procedure. Korel and Laski's STAD (A System for Testing and Debugging) provides a similar fault-diagnosis approach at the intra-procedure level for a subset of Pascal <ref> [KL91, KL88b] </ref>, except that instead of asking users to verify the input-output correctness of procedure calls, it asks them questions like if a given assignment is the correct reaching definition of a variable at a given location, or if the control has correctly reached a given location, etc.
Reference: [Kra91] <author> Edward W. Krauser. </author> <title> Compiler-Integrated Software testing. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Purdue University, West Lafayette, IN, </institution> <year> 1991. </year>
Reference-contexts: Another promising approach to reduce the context switching overhead is to have the debugger "patch" the object code of the debugging process with instructions that do all the necessary logging of information required for dynamic slicing and backtracking purposes <ref> [Kra91, DKM91] </ref>. 9.4 Future Directions We conclude this dissertation by listing some ideas on extending our work and some preliminary thoughts on other research directions. 9.4.1 Fault Prediction Heuristics In Chapter 6, we discussed several heuristics based on combining multiple dynamic slices in certain ways.
Reference: [LD85] <author> R. L. London and R. A. Duisberg. </author> <title> Animating programs using Smalltalk. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 61-71, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: The arrow moves up or down (and new rectangles added or deleted) as numbers are pushed on or popped off the stack. Such debuggers are still in their infancy, and presently are able to handle only small programs with simple data-structures. Research in the area of algorithm animation <ref> [BS85, Bro88, LD85] </ref> has much to offer in this respect. 2.3 Debugging with Specifications A debugging technique called "two-dimensional pinpointing" [LST91] aims at locating inconsistencies in software that is structured in levels. It requires that formal specifications defining the program's desired behavior at each structural level be provided.
Reference: [LH88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation. ACM SIGPLAN, </booktitle> <month> July </month> <year> 1988. </year> <journal> SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 21-34, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Further, when such a reference occurs inside a loop, the memory location referenced may vary from one loop iteration to another. The difficulty is compounded if the language used is not strongly-typed and permits integer arithmetic over pointer variables. Techniques proposed in <ref> [CWZ90, HPR89a, LH88] </ref> may be used to obtain conservative static approximations of what a pointer might point to at run time, but in the presence of unconstrained pointers, as in C, such analysis has only limited usefulness.
Reference: [LOS86] <author> H. Longworth, L. Ott, and M. Smith. </author> <title> The relationship between program complexity and slice complexity during debugging tasks. </title> <booktitle> In Proceedings of COMPSAC. IEEE, </booktitle> <year> 1986. </year>
Reference-contexts: Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, software metrics, etc. (see, e.g., <ref> [Wei84, BC85, HPR89b, GL89, OT89, LOS86] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition.
Reference: [LST91] <author> David Luckham, Sriram Sankar, and Shuzo Takahashi. </author> <title> Two-dimensional pinpointing: Debugging with formal specifications. </title> <journal> IEEE Software, </journal> <pages> pages 74-84, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Such debuggers are still in their infancy, and presently are able to handle only small programs with simple data-structures. Research in the area of algorithm animation [BS85, Bro88, LD85] has much to offer in this respect. 2.3 Debugging with Specifications A debugging technique called "two-dimensional pinpointing" <ref> [LST91] </ref> aims at locating inconsistencies in software that is structured in levels. It requires that formal specifications defining the program's desired behavior at each structural level be provided. The technique works by first checking the actual execution behavior of the program under a test sequence against the top level specifications.
Reference: [Luk80] <author> F. J. Lukey. </author> <title> Understanding and debugging programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 12(2) </volume> <pages> 189-202, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: However, for many programs, especially lengthy ones, such analysis is much too difficult to perform. One logical way to proceed in such situations would be to think backwards|deduce the conditions under which the program produces the incorrect output <ref> [Sch71, Gou75, Luk80] </ref>. Consider, for example, the program in the main window panel of Figure 1.1. 1 This program computes the sum of the areas of N triangles. It reads the value of N , followed by the lengths of the three sides of each of these N triangles. <p> In particular, many experimental systems have been developed using the knowledge-based approach (see, e.g., [Sev87, DE88]). However, all these 16 systems can presently handle only a restricted class of bugs in small programs. We discuss a few representative knowledge-based debugging systems below. PUDSY (Program Understanding and Debugging System) <ref> [Luk80] </ref> maintains a knowledge-base of simple programming schemas for solving simple programming tasks, e.g., swapping two values, finding the maximum element of an array, etc. For each such schema an assertion describing the function performed by the schema is also stored.
Reference: [LW87] <author> James R. Lyle and Mark Weiser. </author> <title> Automatic program bug location by program slicing. </title> <booktitle> In Proceedings of the Second International Conference on Computers and Applications, </booktitle> <address> Beijing, China, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: It does not, however, use the information that values of many other variables may be correct. Lyle and Weiser proposed the notion of program dicing <ref> [LW87] </ref> which attempts to further narrow down the search for the fault using information gained during testing about which variables in the program are observed to have incorrect values and which have correct values when the program is executed on various testcases. <p> In this chapter we discuss how we can further narrow down our search for the fault by combining multiple dynamic slices. 6.1 Combining Dynamic Program Slices In Chapter 2, we mentioned that program dicing <ref> [LW87] </ref> attempts to reduce the size of the relevant program text to be examined by combining multiple static slices. We can naturally extend that approach to using dynamic slices instead of static slices to get even finer error localization information. <p> This strategy is the dynamic analogue of program dicing strategy proposed by Lyle and Weiser <ref> [LW87] </ref> For example, consider the program in Figure 6.9. It reads a date (month, day, year) and finds the corresponding day-of-the-year and day-of-the-week. This program has a fault on line 68 where the right-hand-side of the assignment performs an addition instead of a subtraction.
Reference: [MB79] <author> J. Maranzano and S. Bourne. </author> <title> A tutorial introduction to ADB. Unix Programmers Manual, </title> <year> 1979. </year>
Reference-contexts: Few tools or techniques are available to help programmers debug their programs. The tools that are available all basically provide breakpoints and traces as their main debugging aids <ref> [Kat79, MB79, Dun86, Wei82] </ref>. Unfortunately, these traditional mechanisms are often inadequate for the task of quickly isolating program faults. In this dissertation, we present a new paradigm for debugging based on dynamic program slicing, fault guessing, and execution backtracking techniques.
Reference: [MC88] <author> Barton P. Miller and Jong-Deok Choi. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 135-144, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: However, if a program was stopped at some location it was not possible to change values of variables before executing forward again because Exdams simply replayed the program behavior recorded earlier. Miller and Choi's Ppd <ref> [MC88] </ref> also performs flow-back analysis like Exdams but it uses a notion of incremental tracing where portions of the program state are 20 checkpointed at the start and the end of segments of program-code called emulation-blocks.
Reference: [MH89] <author> Charles E. McDowell and David P. Helmbold. </author> <title> Debugging concurrent programs. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(4) </volume> <pages> 593-623, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: As the problem of debugging parallel, logic, functional, or optimized programs is not in the scope of this dissertation, we have not included related work in these areas here, though research is also being carried out in these areas (see, e.g., <ref> [MH89, AS89, Hen82, Zel84, Cou88] </ref>). 22 3. SIMPLE DYNAMIC SLICING Often during debugging, value of a variable, var , at a program statement, S, is observed to be incorrect.
Reference: [Moh88] <author> Thomas G. Moher. </author> <title> Provide: a process visualization and debugging environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(6) </volume> <pages> 849-857, </pages> <month> June </month> <year> 1988. </year> <month> 178 </month>
Reference-contexts: Pi [Car86] provides context dependent pop-up menus of variable names, visible in the current scope, for selecting and displaying their values. 14 2.2 Pictorial Debugging Some debuggers like VIPS [ISO87, SI91] and PROVIDE <ref> [Moh88] </ref> go a step further and attempt to present both the control-flow and the data-structures pictorially to the user. The graphical representations on the screen are updated dynamically as the program execution proceeds.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Techniques for handling pointers, arrays, structures, and procedures are discussed in the next chapter. 3.1 Notation In the following sections we use a let in construct (adapted from a similar construct in the programming language ML <ref> [MTH90] </ref>). Consider the following generic use of let : let &lt;declarations&gt; in &lt;expression&gt; Here, &lt;declarations&gt; consists of a sequence of name bindings that may be used inside &lt;expression&gt;. The scope of these bindings is limited to &lt;expression&gt;.
Reference: [NR69] <author> P. Nauer and B. Randell, </author> <title> editors. </title> <institution> Software Engineering. Scientific Affairs Div., NATO, </institution> <address> Brussels, Belgium, </address> <month> January </month> <year> 1969. </year>
Reference-contexts: To this effect, it has been argued that program verification or "proving programs correct" would eliminate the need for testing and debugging <ref> [Dij76, Hoa69, NR69] </ref>. Program verification requires that the program behavior be expressed as assertions on its input and output. Then one has to prove that the output assertion holds whenever the program is executed on an input that satisfies the input assertion.
Reference: [OCHW91] <author> Ronald A. Olsson, Richard H. Crawford, W. Wilson Ho, and Christo-pher E. Wee. </author> <title> Sequential debugging at a high level of abstraction. </title> <journal> IEEE Software, </journal> <pages> pages 27-36, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Note that single-stepping is also a special case of breakpoints where breakpoints are set after consecutive source statements. 13 Most symbolic debuggers provide limited control over what actions can be performed when a breakpoint is reached. Dalek <ref> [OCHW91] </ref>, a symbolic debugger built on top of the Gnu Debugger Gdb, provides a full programming language including conditionals, loops, blocks, procedures, functions, and variables, to program higher-level actions to be performed at breakpoints. It also provides support for events to form high level abstractions during program executions.
Reference: [OF76] <author> Leon J. Osterweil and Lloyd D. Fosdick. </author> <title> DAVE|a validation error detection and documentation system for Fortran programs. </title> <journal> Software Practice and Experience, </journal> <volume> 6 </volume> <pages> 473-486, </pages> <year> 1976. </year>
Reference-contexts: We discuss this approach again in Chapter 6. 2.8 Anomaly Detection In the static anomaly detection approach, a program is analyzed using data-flow analysis to detect certain conditions in the program that are generally indicative of errors or inefficiencies <ref> [OF76, FO76] </ref>.
Reference: [OO84] <author> Karl J. Ottenstein and Linda M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Symposium on Practical Software Development Environments, </booktitle> <address> Pittaburgh, PA, </address> <month> April </month> <year> 1984. </year> <journal> ACM SIGSOFT/SIGPLAN. SIGPLAN Notices, </journal> <volume> 19(5) </volume> <pages> 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Weiser's algorithm to compute slices was based on iterative solutions of data-flow equations. Ottenstein and Ottenstein presented an algorithm in terms of graph reachability in the program dependence graph, but they only considered the intra-procedural case <ref> [OO84] </ref> (we describe this algorithm in Chapter 3 in the context of static slicing). Horwitz, Reps, and Binkley extended the program dependence graph representation to what they call the "system dependence graph" to find inter-procedural static slices under the same graph-reachability framework [HRB90].
Reference: [OT89] <author> L. Ott and J. Thuss. </author> <title> The relationship between slices and module cohesion. </title> <booktitle> In Proceedings of the Eleventh International Conference on Software Engineering. IEEE, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, software metrics, etc. (see, e.g., <ref> [Wei84, BC85, HPR89b, GL89, OT89, LOS86] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition.
Reference: [Par85] <author> D. L. Parnas. </author> <title> Software aspects of strategic defense systems. </title> <journal> Communications of the ACM, </journal> <volume> 28(12) </volume> <pages> 1326-1335, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: While structured-programming certainly helps improve program comprehensibility (and thus, reliability), it would be naive to think that it reduces the need for software 3 testing and debugging. As Parnas points out in <ref> [Par85] </ref>: "Even in highly structured systems, surprise and unreliability occur because the human mind is not able to fully comprehend the many conditions that can arise because of the interactions of the components." Thus one thing is evident: there is no escape from testing and debugging of programs if we are
Reference: [PC90] <author> Andy Podgurski and Lori A. Clarke. </author> <title> A formal model of program dependences and its implications for software testing, debugging, and maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 965-979, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The issue of non-termination of program execution is not addressed under this definition. Podgurski and Clark have extended the regular notion of control dependence (which they refer to as "strong control dependence") to "weak control dependence" that includes inter-statement dependencies involving program non-termination <ref> [PC90] </ref>. To 18 detect program faults other than infinite loops, however, strong control dependence gives much finer slices compared to weak control dependence. The definition of data-dependence remains the same in both cases. Korel and Laski extended Weiser's static slicing algorithms for the dynamic case [KL90].
Reference: [RW88] <author> Charles Rich and R. C. Waters. </author> <title> The Programmer's Apprentice: A research overview. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 10-25, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: The synthesis is performed with the help of a knowledge-base of "programming plans" for solving simple "goals". If the synthesis fails to produce a program matching the given program, the discrepancies are analyzed, and possible faults are suggested. The Programmer's Apprentice <ref> [RW88] </ref> also uses a similar approach. Given a "plan" for the intended program, it infers the existence of bugs in the program by performing a kind of pattern-matching between the plan and the program itself. Note that all three systems above perform static program analysis irrespective of any runtime inputs.
Reference: [RY88] <author> Thomas Reps and W. Yang. </author> <title> The semantics of program slicing. </title> <type> Technical Report TR-777, </type> <institution> Computer Science Department, University of Wisconsin, Madison, WI, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: We examine the consequences of this requirement in Chapter 3 (Section 3.4.4.1). Several people have also investigated the semantic basis of program slicing <ref> [Ven91, RY88, CF89, Sel89] </ref>. 2.7 Program Dicing Slicing uses the information that the value of a variable is incorrect to narrow down the search for the fault. It does not, however, use the information that values of many other variables may be correct.
Reference: [Sch71] <author> Jacob T. Schwartz. </author> <title> An overview of bugs. </title> <editor> In Randall Rustin, editor, </editor> <booktitle> Debugging Techniques in Large Systems, </booktitle> <pages> pages 1-16. </pages> <publisher> Prentice-Hall, </publisher> <address> En-gelwood Cliffs, NJ, </address> <year> 1971. </year>
Reference-contexts: 1. INTRODUCTION The presence of bugs in programs can be regarded as a fundamental phenomenon; the bug-free program is an abstract theoretical concept like the absolute zero of thermodynamics, which can be envisaged but never attained. Jacob Schwartz, in <ref> [Sch71] </ref>. Such pessimism is not unfounded. A computer program is a complex automaton. As the size of the program grows, the complexity of the underlying automaton soon starts exploding. <p> However, for many programs, especially lengthy ones, such analysis is much too difficult to perform. One logical way to proceed in such situations would be to think backwards|deduce the conditions under which the program produces the incorrect output <ref> [Sch71, Gou75, Luk80] </ref>. Consider, for example, the program in the main window panel of Figure 1.1. 1 This program computes the sum of the areas of N triangles. It reads the value of N , followed by the lengths of the three sides of each of these N triangles.
Reference: [SD60] <author> T. G. Stockham and J. B. Dennis. </author> <title> Flit|flexowriter interrogation tape: a symbolic utility for TX-O. </title> <type> Memo 5001-23, </type> <institution> Dept. of Electical Engineering, Massachusetts Institute of Technology, </institution> <month> July </month> <year> 1960. </year> <month> 179 </month>
Reference-contexts: That is quite surprising given the very high cost (in terms of programmer time) associated with debugging. The basic notion of user-controlled breakpoints, upon which almost all commonly used debuggers today are based, was introduced by assembly language debuggers FLIT <ref> [SD60] </ref> and DDT [SW65] developed in the late 50's. We have not come much farther from there.
Reference: [Sel89] <author> R. P. Selke. </author> <title> A rewriting semantics for program dependence graphs. </title> <booktitle> In Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 12-24. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: We examine the consequences of this requirement in Chapter 3 (Section 3.4.4.1). Several people have also investigated the semantic basis of program slicing <ref> [Ven91, RY88, CF89, Sel89] </ref>. 2.7 Program Dicing Slicing uses the information that the value of a variable is incorrect to narrow down the search for the fault. It does not, however, use the information that values of many other variables may be correct.
Reference: [Sev87] <author> Rudolph E. Seviora. </author> <title> Knowledge-based program debugging systems. </title> <journal> IEEE Software, </journal> <volume> 4(3) </volume> <pages> 20-32, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Their approach is targeted to find simple operator and operand faults in the program. 2.5 Knowledge-Based Debugging Attempts have also been made to apply artificial intelligence techniques to the debugging problem. In particular, many experimental systems have been developed using the knowledge-based approach (see, e.g., <ref> [Sev87, DE88] </ref>). However, all these 16 systems can presently handle only a restricted class of bugs in small programs. We discuss a few representative knowledge-based debugging systems below.
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> Algorithmic Program Debugging. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1983. </year>
Reference-contexts: Further, constructing program-proofs can be an arduous task. Proofs are generally much more difficult to construct and understand than the programs themselves. Thus, proofs themselves can be bug-prone! Also, proofs are constructed with respect to program specifications. But specifications themselves can be "buggy." As Shapiro explains in <ref> [Sha83] </ref>: No matter what language we use to convey [the specifications], we are bound to make mistakes. <p> This process continues at successive lower levels until a fault is detected. 2.4 Algorithmic Debugging Shapiro's "Divide & Query" interactive fault-diagnosis approach <ref> [Sha83] </ref> uses a kind of binary search on the computation tree of the program to localize bugs. It relies upon the user to verify the correctness of intermediate function calls based on 15 their input and output values.
Reference: [SI91] <author> Takao Shimomura and Sadahiro Isoda. </author> <title> Linked-list visualization for debugging. </title> <journal> IEEE Software, </journal> <pages> pages 44-51, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Pi [Car86] provides context dependent pop-up menus of variable names, visible in the current scope, for selecting and displaying their values. 14 2.2 Pictorial Debugging Some debuggers like VIPS <ref> [ISO87, SI91] </ref> and PROVIDE [Moh88] go a step further and attempt to present both the control-flow and the data-structures pictorially to the user. The graphical representations on the screen are updated dynamically as the program execution proceeds.
Reference: [SKF90] <author> Nahid Shahmehri, Mariam Kamkar, and Peter Fritzson. </author> <title> Semi-automatic bug localization in software maintenance. </title> <booktitle> In Proceedings of the IEEE Conference on Software Maintenance, </booktitle> <address> San Diego, CA, </address> <month> November </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: This cycle is repeated until the fault is located. The above approach works particularly well for side-effect free languages like the logic programming language Prolog. But it can also be applied to imperative languages such as Pascal at the procedure-call level <ref> [SKF90] </ref>. Using this approach the fault can be localized to a procedure that contains the fault. Then other debugging techniques may be used to further localize the bug within that procedure.
Reference: [Sta89] <author> Richard M. Stallman. </author> <title> GDB Manual, third edition, GDB version 3.4. Free Software Foundation, </title> <address> Cambridge, MA, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: could be supported by Spyder, but as our goal was to demonstrate usefulness of slicing, guessing, and backtracking functions, we implemented only the bare minimum of other functions we needed. 8.3 Implementation Spyder is built into versions of the GNU C compiler "Gcc" [Sta90] and the GNU source-level debugger "Gdb" <ref> [Sta89] </ref>. As mentioned earlier, our intent was not to write a production-quality tool but to demonstrate the feasibility as well as the usefulness of the above mechanisms. We decided, therefore, to modify an existing compiler and debugger rather than write a new system.
Reference: [Sta90] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC, version 1.37. Free Software Foundation, </title> <address> Cambridge, MA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: screen. 162 Many more standard debugging commands could be supported by Spyder, but as our goal was to demonstrate usefulness of slicing, guessing, and backtracking functions, we implemented only the bare minimum of other functions we needed. 8.3 Implementation Spyder is built into versions of the GNU C compiler "Gcc" <ref> [Sta90] </ref> and the GNU source-level debugger "Gdb" [Sta89]. As mentioned earlier, our intent was not to write a production-quality tool but to demonstrate the feasibility as well as the usefulness of the above mechanisms. We decided, therefore, to modify an existing compiler and debugger rather than write a new system.
Reference: [STJ83] <author> Robert L. Sedlmeyer, William B. Thompson, and Paul E. Johnson. </author> <title> Knowledge-based fault localization in debugging. </title> <booktitle> In Proceedings of the Software Engineering Symposium on High-Level Debugging, </booktitle> <address> Pacific Grove, CA, </address> <month> March </month> <year> 1983. </year> <journal> ACM SIGSOFT/SIGPLAN. Software Engineering Notes, </journal> <volume> 8(4) </volume> <month> 25-31, </month> <journal> August 1983; SIGPLAN Notices, </journal> 18(8):25-31, August 1983. 
Reference-contexts: Given a "plan" for the intended program, it infers the existence of bugs in the program by performing a kind of pattern-matching between the plan and the program itself. Note that all three systems above perform static program analysis irrespective of any runtime inputs. Falosy <ref> [STJ83] </ref>, on the other hand, expects both the actual and the expected output of the program on the failed testcase to be supplied. It compares the two outputs and tries to infer the fault from the differences between the two, with the help of a knowledge-base of error-cause heuristics.
Reference: [SW65] <author> R. Saunders and R. Wagner. </author> <title> On-line debugging systems. </title> <booktitle> In Proceedings of IFIP Congress, </booktitle> <volume> volume 2, </volume> <pages> pages 545-546, </pages> <year> 1965. </year>
Reference-contexts: That is quite surprising given the very high cost (in terms of programmer time) associated with debugging. The basic notion of user-controlled breakpoints, upon which almost all commonly used debuggers today are based, was introduced by assembly language debuggers FLIT [SD60] and DDT <ref> [SW65] </ref> developed in the late 50's. We have not come much farther from there.
Reference: [Tei72] <author> Warren Teitelman. </author> <title> Automated programming: The Programmer's Assistant. </title> <booktitle> In Afips Proceedings, Fall Joint Computer Conference, </booktitle> <volume> volume 41, </volume> <pages> pages 917-921, </pages> <address> Montvale, New Jersey, 1972. </address> <publisher> AFIPS Press. </publisher>
Reference-contexts: It also provides support for events to form high level abstractions during program executions. Interpreted environments, where the program source is interpreted instead of being compiled, provide a much greater degree of flexibility for debugging purposes. Integrated Programming Environments such as INTERLISP [Tei78], The Programmer's Assistant <ref> [Tei72] </ref>, The Cornell Program Synthesizer [TR81], and Saber C provide integrated support for program editing, execution, and debugging. If an error is encountered during the program execution, it is possible to correct the erroneous function immediately and continue execution from there on.
Reference: [Tei78] <author> Warren Teitelman. </author> <note> Interlisp Reference Manual, Fourth Edition. </note> <institution> Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1978. </year>
Reference-contexts: It also provides support for events to form high level abstractions during program executions. Interpreted environments, where the program source is interpreted instead of being compiled, provide a much greater degree of flexibility for debugging purposes. Integrated Programming Environments such as INTERLISP <ref> [Tei78] </ref>, The Programmer's Assistant [Tei72], The Cornell Program Synthesizer [TR81], and Saber C provide integrated support for program editing, execution, and debugging. If an error is encountered during the program execution, it is possible to correct the erroneous function immediately and continue execution from there on. <p> Such problems frequently arise in artificial intelligence applications, for instance. However, because the user must program the Retrace statements into the code, this approach does not provide an interactive control over backtracking while debugging. Interlisp <ref> [Tei78] </ref> and the Cornell Program Synthesizer [TR81] also provide facilities to undo operations. All these systems maintain a fixed-length history list of side-effects caused by operations.
Reference: [TR81] <author> Tim Teitelbaum and Thomas Reps. </author> <title> The Cornell Program Synthesizer: a syntax-directed programming environment. </title> <journal> Communications of the ACM, </journal> <volume> 24(9) </volume> <pages> 563-573, </pages> <month> September </month> <year> 1981. </year> <month> 180 </month>
Reference-contexts: Interpreted environments, where the program source is interpreted instead of being compiled, provide a much greater degree of flexibility for debugging purposes. Integrated Programming Environments such as INTERLISP [Tei78], The Programmer's Assistant [Tei72], The Cornell Program Synthesizer <ref> [TR81] </ref>, and Saber C provide integrated support for program editing, execution, and debugging. If an error is encountered during the program execution, it is possible to correct the erroneous function immediately and continue execution from there on. <p> Such problems frequently arise in artificial intelligence applications, for instance. However, because the user must program the Retrace statements into the code, this approach does not provide an interactive control over backtracking while debugging. Interlisp [Tei78] and the Cornell Program Synthesizer <ref> [TR81] </ref> also provide facilities to undo operations. All these systems maintain a fixed-length history list of side-effects caused by operations. As new events occur, the existing events on the list are aged, with oldest events "forgotten." Thus returning to points arbitrarily far back in the execution may not be possible.
Reference: [Ven91] <author> G. A. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> June </month> <year> 1991. </year> <journal> ACM SIG-PLAN. SIGPLAN Notices, </journal> <volume> 26(6) </volume> <pages> 107-119, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: We examine the consequences of this requirement in Chapter 3 (Section 3.4.4.1). Several people have also investigated the semantic basis of program slicing <ref> [Ven91, RY88, CF89, Sel89] </ref>. 2.7 Program Dicing Slicing uses the information that the value of a variable is incorrect to narrow down the search for the fault. It does not, however, use the information that values of many other variables may be correct.
Reference: [Wei82] <author> Mark Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <volume> 25(7) </volume> <pages> 446-452, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Few tools or techniques are available to help programmers debug their programs. The tools that are available all basically provide breakpoints and traces as their main debugging aids <ref> [Kat79, MB79, Dun86, Wei82] </ref>. Unfortunately, these traditional mechanisms are often inadequate for the task of quickly isolating program faults. In this dissertation, we present a new paradigm for debugging based on dynamic program slicing, fault guessing, and execution backtracking techniques. <p> The system searches 17 for faults in the program corresponding to the output discrepancies observed. It performs pattern-matching over code-schemas, as in Proust, to locate the faults. 2.6 Program Slicing The static slicing approach to program debugging was proposed by Weiser <ref> [Wei84, Wei82] </ref>. A program slice is helpful in debugging because it presents the user with only that subset of the program that may have some effect on the value of an erroneous variable. <p> The program slice with respect to var at S gives the set of program statements that directly or indirectly affect the value of var as observed at S <ref> [Wei82] </ref>. But this notion of a program slice does not make any use of the particular inputs that revealed the error.
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: The system searches 17 for faults in the program corresponding to the output discrepancies observed. It performs pattern-matching over code-schemas, as in Proust, to locate the faults. 2.6 Program Slicing The static slicing approach to program debugging was proposed by Weiser <ref> [Wei84, Wei82] </ref>. A program slice is helpful in debugging because it presents the user with only that subset of the program that may have some effect on the value of an erroneous variable. <p> Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, automatic integration of program versions, software metrics, etc. (see, e.g., <ref> [Wei84, BC85, HPR89b, GL89, OT89, LOS86] </ref>). When a program slice is defined with respect to a variable occurrence, it is assumed that control does eventually reach the corresponding program location. The issue of non-termination of program execution is not addressed under this definition. <p> Unlike a dynamic slice, a static program slice also has another property: it is an executable program itself. It evaluates the variable in question identically to the original program for all testcases <ref> [Wei84] </ref>. 5.3 Summary A program slice may be viewed as a closure of the corresponding data and control slices. A data slice is the closure of relevant data dependencies alone while a control slice gives the closure of control dependencies alone.
Reference: [Zel71] <author> M. V. Zelkowitz. </author> <title> Reversible Execution As a Diagnostic Tool. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> January </month> <year> 1971. </year>
Reference-contexts: Later these emulation blocks may be reexecuted to generate the corresponding segments of the execution history. Zelkowitz incorporated a backtracking facility within the programming language PL/1 by adding a Retrace statement to the language <ref> [Zel71] </ref>. With this statement, execution could be backtracked over a desired number of statements, up to a statement with a given label, or until the program state matched a certain condition.
Reference: [Zel78] <author> Marvin V. Zelkowitz. </author> <title> Perspectives on software engineering. </title> <journal> ACM Computing Surveys, </journal> <volume> 10(2) </volume> <pages> 197-216, </pages> <month> June </month> <year> 1978. </year>
Reference-contexts: Anyone who has ever engaged in serious programming knows that software testing and debugging are hard problems. As much as twenty-five to fifty percent of the total system development cost and time may be spent on these activities alone <ref> [Zel78, Boe81] </ref>. It has been suggested that the best solution to the problem of bugs 2 is to ensure that they never get into the program in the first place.

References-found: 88

