URL: http://www.csl.sri.com/reports/postscript/dcca97.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Email: Rushby@csl.sri.com  
Title: Systematic Formal Verification for Fault-Tolerant Time-Triggered Algorithms  
Author: John Rushby 
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Note: Expanded version of a paper from the Sixth Working Conference on Dependable Computing for Critical Applications, Garmisch-Partenkirchen, Germany, March, 1997. IEEE Computer Society Press, pp. 203-222.  This work was supported by the Air Force Office of Scientific Research, Air Force Materiel Command, USAF, under contract F49620-95-C0044, by the National Science Foundation under contract CCR-9509931, and by NASA Langley Research Center under contract NAS1-20334.  
Abstract: Many critical real-time applications are implemented as time-triggered systems. We present a systematic way to derive a time-triggered implementation from a fault-tolerant algorithm specified as a functional program. It is relatively easy to formally and mechanically verify correctness and fault-tolerance properties of algorithms expressed in this latter form. The functional program is next transformed into an untimed synchronous system, and then to a time-triggered implementation. The second step is independent of the algorithm concerned and we prove its correctness; the proof has also been formalized and mechanically checked with the PVS verification system. This approach provides a methodology that can ease the formal specification and assurance of critical fault-tolerant systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> ARINC Specification 659: Backplane Data Bus. Aeronautical Radio, Inc, Annapolis, MD, </institution> <month> December </month> <year> 1993. </year> <title> Prepared by the Airlines Electronic Engineering Committee. </title>
Reference: [2] <author> W. R. Bevier and W. D. Young. </author> <title> The design and proof of correctness of a fault-tolerant circuit. </title> <editor> In J. F. Meyer and R. D. Schlichting, editors, </editor> <title> Dependable Computing for Critical Applications|2, </title> <booktitle> volume 6 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 243-260. </pages> <publisher> Springer-Verlag, </publisher> <address> Vienna, Austria, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: Numerous algorithms have been developed to perform these functions and, because of their criticality and subtlety, several of them have been subjected to detailed formal [15, 23, 43] and mechanically checked <ref> [2, 26-28, 34] </ref> verifications, as have their combination into larger functions such as diagnosis [25], and their synthesis into a fault-tolerant architecture based on active (state-machine) replication [11, 35]. Formal, and especially mechanically-checked, verification of these algorithms is still something of a tour de force, however. <p> Some of the differences can be attributed to the ways in which the problems are formalized or to the different resources of the formal specification languages and theorem provers employed. For example, Rushby [34] and Bevier and Young <ref> [2] </ref> describe mechanically checked formal verifications of the same "Oral Messages" algorithm [24] for the consensus problem that were performed using different verification systems. Young [42] argues that differences in the difficulty of these treatments (that of [34] is generally considered simpler and clearer than that of [2]) are due to <p> Bevier and Young <ref> [2] </ref> describe mechanically checked formal verifications of the same "Oral Messages" algorithm [24] for the consensus problem that were performed using different verification systems. Young [42] argues that differences in the difficulty of these treatments (that of [34] is generally considered simpler and clearer than that of [2]) are due to different choices in the way things are formalized. We may assume that such differences will be reduced or eliminated as experience is gained and the better choices become more widely known. <p> There is a fairly systematic transformation between synchronous systems and functional programs that can ease the verification task by allowing it to be performed on a functional program. I illustrate the idea (which comes from Bevier Systematic Formal Verification for Time-Triggered Algorithms 17 and Young <ref> [2] </ref>) using the OM (1) algorithm from Section 2. Because that algorithm has already been introduced as a synchronous system, I will illustrate its transformation to a functional program; once the technique becomes familiar, it is easy to perform the transformation in the other direction. <p> How this "gathering together" is represented will depend on the resources of the specification language and logic concerned: in the treatment using the Boyer-Moore logic, for example, it is represented by a list of values <ref> [2] </ref>. In a higher-order logic such as PVS [32], however, it can be represented by a function, specified as a -abstraction: q : send (1; send (0; v; T; q); q; p) (i.e., a function that, when applied to q, returns the value that p received from q).
Reference: [3] <author> Robert S. Boyer and J Strother Moore. </author> <title> MJRTY|a fast majority vote algorithm. </title> <type> Technical Report 32, </type> <institution> Institute for Computing Science, University of Texas, Austin TX, </institution> <month> February </month> <year> 1981. </year>
Reference: [4] <author> Robert S. Boyer and J Strother Moore. </author> <title> MJRTY|a fast majority vote algorithm. </title> <editor> In Robert S. Boyer, editor, </editor> <booktitle> Automated Reasoning: Essays in Honor of Woody Bled-soe, volume 1 of Automated Reasoning Series, </booktitle> <pages> pages 105-117. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1991. </year>
Reference-contexts: The function maj returns the majority value if one exists; otherwise some functionally determined value. (This behavior can either be specified axiomatically, or defined constructively using an algorithm such as Boyer and Moore's linear time MJRTY <ref> [4] </ref>.) Thus, p's decision in the computation phase of the second round is represented by maj (rcvrs; q : send (1; send (0; v; T; q); q; p)) where rcvrs is the set of all receiver processors.
Reference: [5] <author> Ricky W. Butler and Ben L. Di Vito. </author> <title> Formal design and verification of a reliable computing platform for real-time control: Phase 2 results. </title> <type> NASA Technical Memorandum 104196, </type> <institution> NASA Langley Research Center, Hampton, VA, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: The proof identifies necessary timing constraints and is independent of the particular algorithm concerned; it provides a more general and abstract treatment of the analysis Systematic Formal Verification for Time-Triggered Algorithms 19 performed for a particular system by Di Vito and Butler <ref> [5] </ref>. The relative simplicity of the proof supports the argument that time-triggered systems allow for straightforward analysis and should be preferred in critical applications for that reason [20].
Reference: [6] <author> Tushar D. Chandra, Vassos Hadzilicos, Sam Toueg, and Bernadette Charron-Bost. </author> <title> On the impossibility of group membership. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 322-330, </pages> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year> <institution> Association for Computing Machinery. </institution> <month> 20 </month>
Reference-contexts: This property contrasts with asynchronous systems, where there are no upper bounds on processing and message delays, and where it is therefore provably impossible to achieve certain forms of consistent knowledge or coordinated action in the presence of even simple faults <ref> [6, 13] </ref>. For these reasons, fault-tolerant systems for critical control applications in aircraft, trains, automobiles, and industrial plants are usually based on the synchronous approach, though they differ in the extent to which the basic mechanisms of the system really do guarantee satisfaction of the synchrony assumption.
Reference: [7] <author> Flaviu Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Systems, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year>
Reference-contexts: A number of basic functions have been identified that provide important building blocks in the construction of fault-tolerant synchronous systems [8, 10]; these include consensus (also known as interactive consistency and Byzantine agreement) [33], reliable and atomic broadcast [9], and group membership <ref> [7] </ref>. <p> Some algorithms were first introduced using an event-triggered formulation (for example, Cristian's atomic broadcast and group membership algorithms <ref> [7, 9] </ref>), but it is possible to reconstruct explicitly round-based equivalents for them, and then transform them to time-triggered implementations (Kopetz' time-triggered algorithms [19] for the same problems do this to some extent).
Reference: [8] <author> Flaviu Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: A number of basic functions have been identified that provide important building blocks in the construction of fault-tolerant synchronous systems <ref> [8, 10] </ref>; these include consensus (also known as interactive consistency and Byzantine agreement) [33], reliable and atomic broadcast [9], and group membership [7].
Reference: [9] <author> Flaviu Cristian, Houtan Aghili, Ray Strong, and Danny Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <booktitle> In Fault Tolerant Computing Symposium 15, </booktitle> <pages> pages 200-206, </pages> <address> Ann Arbor, MI, </address> <month> June </month> <year> 1985. </year> <booktitle> IEEE Computer Society. Reprinted in [18, </booktitle> <pages> pp. 431-437]. </pages>
Reference-contexts: A number of basic functions have been identified that provide important building blocks in the construction of fault-tolerant synchronous systems [8, 10]; these include consensus (also known as interactive consistency and Byzantine agreement) [33], reliable and atomic broadcast <ref> [9] </ref>, and group membership [7]. <p> Some algorithms were first introduced using an event-triggered formulation (for example, Cristian's atomic broadcast and group membership algorithms <ref> [7, 9] </ref>), but it is possible to reconstruct explicitly round-based equivalents for them, and then transform them to time-triggered implementations (Kopetz' time-triggered algorithms [19] for the same problems do this to some extent).
Reference: [10] <author> Flaviu Cristian, Bob Dancey, and Jon Dehn. </author> <title> Fault-tolerance in air traffic control systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 14(3) </volume> <pages> 265-286, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: A number of basic functions have been identified that provide important building blocks in the construction of fault-tolerant synchronous systems <ref> [8, 10] </ref>; these include consensus (also known as interactive consistency and Byzantine agreement) [33], reliable and atomic broadcast [9], and group membership [7].
Reference: [11] <author> Ben L. Di Vito and Ricky W. Butler. </author> <title> Formal techniques for synchronized fault-tolerant systems. </title> <editor> In C. E. Landwehr, B. Randell, and L. Simoncini, editors, </editor> <title> Dependable Computing for Critical Applications|3, </title> <booktitle> volume 8 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 163-188. </pages> <publisher> Springer-Verlag, </publisher> <address> Vienna, Austria, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: functions and, because of their criticality and subtlety, several of them have been subjected to detailed formal [15, 23, 43] and mechanically checked [2, 26-28, 34] verifications, as have their combination into larger functions such as diagnosis [25], and their synthesis into a fault-tolerant architecture based on active (state-machine) replication <ref> [11, 35] </ref>. Formal, and especially mechanically-checked, verification of these algorithms is still something of a tour de force, however. To have real impact on practice, we need to reduce the difficulty of formal verification in this domain to a routine and largely automated process.
Reference: [12] <author> Carl S. Droste and James E. Walker. </author> <title> The General Dynamics Case Study on the F16 Fly-by-Wire Flight Control System. AIAA Professional Study Series. </title> <institution> American Institute of Aeronautics and Astronautics. Undated. </institution>
Reference-contexts: Now processor q will still be on 4 For example, the outputs of different processors may energize separate coils of a single solenoid, or multiple hydraulic pistons may be linked to a single shaft (see, e.g., <ref> [12, Figure 3.2-2] </ref>). Systematic Formal Verification for Time-Triggered Algorithms 15 round r and in its communication phase provided X &lt; P and this is ensured by the inequality just derived when taken together with Constraint 3.
Reference: [13] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: This property contrasts with asynchronous systems, where there are no upper bounds on processing and message delays, and where it is therefore provably impossible to achieve certain forms of consistent knowledge or coordinated action in the presence of even simple faults <ref> [6, 13] </ref>. For these reasons, fault-tolerant systems for critical control applications in aircraft, trains, automobiles, and industrial plants are usually based on the synchronous approach, though they differ in the extent to which the basic mechanisms of the system really do guarantee satisfaction of the synchrony assumption.
Reference: [14] <author> Gerard Florin, Roberto Gomez, and Ivan Lavallee. </author> <title> Systematic building of a distributed recursive algorithm. </title> <institution> Rapport de recherche 1902, INRIA, Rocquencourt, France, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Not all synchronous systems can be so easily transformed into a recursive function, nor can their properties always be formally verified so easily. Nonetheless, I believe the approach has promise for many algorithms of practical interest. A similar method has been advocated by Florin, Gomez, and Lavallee <ref> [14] </ref>. 5 Conclusion Many round-based fault-tolerant algorithms can be formulated as synchronous systems.
Reference: [15] <author> Yuri Gurevich and Raghu Mani. </author> <title> Group membership protocol: Specification and verification. </title> <editor> In Egon Borger, editor, </editor> <title> Specification and Validation Methods, </title> <booktitle> International Schools for Computer Scientists, </booktitle> <pages> pages 295-328. </pages> <publisher> Oxford University Press, Oxford, </publisher> <address> UK, </address> <year> 1995. </year>
Reference-contexts: Numerous algorithms have been developed to perform these functions and, because of their criticality and subtlety, several of them have been subjected to detailed formal <ref> [15, 23, 43] </ref> and mechanically checked [2, 26-28, 34] verifications, as have their combination into larger functions such as diagnosis [25], and their synthesis into a fault-tolerant architecture based on active (state-machine) replication [11, 35].
Reference: [16] <author> Akira Hachiga. </author> <title> The concepts and technologies of dependable and real-time computer systems for Shinkansen train control. </title> <editor> In H. Kopetz and Y. Kakuda, editors, </editor> <booktitle> Responsive Computer Systems, volume 7 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 225-252. </pages> <publisher> Springer-Verlag, </publisher> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: The Honeywell SAFEbus TM [1,17] that provides the safety-critical backplane for the Boeing 777 Airplane Information Management System (AIMS) [31, 39], the control system for the Shinkansen (Japanese Bullet Train) <ref> [16] </ref>, and the Time-Triggered Protocol (TTP) proposed for safety-critical automobile functions [21] all use this latter approach.
Reference: [17] <author> Kenneth Hoyme and Kevin Driscoll. </author> <booktitle> SAFEbus TM . IEEE Aerospace and Electronic Systems Magazine, </booktitle> <volume> 8(3) </volume> <pages> 34-39, </pages> <month> March </month> <year> 1993. </year>
Reference: [18] <institution> Fault Tolerant Computing Symposium 25: </institution> <note> Highlights from 25 Years, </note> <institution> Pasadena, </institution> <address> CA, June 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference: [19] <author> H. Kopetz, G. Grunsteidl, and J. Reisinger. </author> <title> Fault-tolerant membership service in a synchronous distributed real-time system. </title> <editor> In A. Avizienis and J. C. Laprie, editors, </editor> <title> Dependable Computing for Critical Applications, </title> <booktitle> volume 4 of Dependable Systematic Formal Verification for Time-Triggered Algorithms 21 Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 411-429, </pages> <address> Santa Barbara, CA, </address> <month> August </month> <year> 1989. </year> <institution> Springer-Verlag, Vienna, Austria. </institution>
Reference-contexts: Some algorithms were first introduced using an event-triggered formulation (for example, Cristian's atomic broadcast and group membership algorithms [7, 9]), but it is possible to reconstruct explicitly round-based equivalents for them, and then transform them to time-triggered implementations (Kopetz' time-triggered algorithms <ref> [19] </ref> for the same problems do this to some extent). Event-triggered systems are generally easier to construct than time-triggered ones (which require a big planning and scheduling effort upfront) and achieve better CPU utilization under light load.
Reference: [20] <author> Hermann Kopetz. </author> <title> Should responsive systems be event-triggered or time-triggered? IEICE Transactions on Information and Systems, </title> <address> E76-D(11):1325-1332, </address> <month> November </month> <year> 1993. </year> <journal> Institute of Electronics, Information, and Communications Engineers, Japan. </journal>
Reference-contexts: The relative simplicity of the proof supports the argument that time-triggered systems allow for straightforward analysis and should be preferred in critical applications for that reason <ref> [20] </ref>. I have also shown, by example, how a round-based algorithm formulated as a synchronous system can be transformed into a functional "program" in a specification logic, where its properties can be verified more easily, and more mechanically.
Reference: [21] <author> Hermann Kopetz and Gunter Grunsteidl. </author> <title> TTP|a protocol for fault-tolerant real-time systems. </title> <journal> IEEE Computer, </journal> <volume> 27(1) </volume> <pages> 14-23, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The Honeywell SAFEbus TM [1,17] that provides the safety-critical backplane for the Boeing 777 Airplane Information Management System (AIMS) [31, 39], the control system for the Shinkansen (Japanese Bullet Train) [16], and the Time-Triggered Protocol (TTP) proposed for safety-critical automobile functions <ref> [21] </ref> all use this latter approach. A number of basic functions have been identified that provide important building blocks in the construction of fault-tolerant synchronous systems [8, 10]; these include consensus (also known as interactive consistency and Byzantine agreement) [33], reliable and atomic broadcast [9], and group membership [7]. <p> TTP goes further and includes all critical state information (operating mode, time, and group membership) in its messages as part of the CRC calculation <ref> [21] </ref>. Less drastic clock skews may leave a processor in the right round, but sending messages at the wrong time, so that they arrive during the computation phases of the other (correct) processors. <p> Systematic transformations of fault-tolerant algorithms from functional programs to synchronous systems to time-triggered implementations provides a methodology that can significantly ease the specification and assurance of critical fault-tolerant systems. In current work, we are applying the methodology to some of the algorithms of TTP <ref> [21] </ref>. Acknowledgments Discussions with N. Shankar and advice from Joseph Sifakis were instrumental in the development of this work. Comments by the anonymous referees improved the presentation.
Reference: [22] <author> L. Lamport and P. M. Melliar-Smith. </author> <title> Synchronizing clocks in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 32(1) </volume> <pages> 52-78, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Nonfaulty clocks are monotonic increasing functions: t 1 &lt; t 2 C p (t 1 ) &lt; C p (t 2 ): Satisfying this assumption requires some care in implementation, because clock synchronization algorithms can make adjustments to clocks that cause them to 2 In the terminology of <ref> [22] </ref>, these are actually "inverse" clocks. 10 jump backwards. Lamport and Melliar-Smith describe some solutions [22], and a particularly clever and economical technique for one particular algorithm is introduced by Torres-Pomales [40] and formally verified by Miner and Johnson [30]. <p> (t 1 ) &lt; C p (t 2 ): Satisfying this assumption requires some care in implementation, because clock synchronization algorithms can make adjustments to clocks that cause them to 2 In the terminology of <ref> [22] </ref>, these are actually "inverse" clocks. 10 jump backwards. Lamport and Melliar-Smith describe some solutions [22], and a particularly clever and economical technique for one particular algorithm is introduced by Torres-Pomales [40] and formally verified by Miner and Johnson [30]. Schmuck and Cristian [38] examine the general case and show that monotonicity can be achieved with no loss of precision. Assumption 2 Clock Drift Rate.
Reference: [23] <author> Leslie Lamport and Stephan Merz. </author> <title> Specifying and verifying fault-tolerant systems. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vytopil, editors, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 41-76, </pages> <address> Lubeck, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: Numerous algorithms have been developed to perform these functions and, because of their criticality and subtlety, several of them have been subjected to detailed formal <ref> [15, 23, 43] </ref> and mechanically checked [2, 26-28, 34] verifications, as have their combination into larger functions such as diagnosis [25], and their synthesis into a fault-tolerant architecture based on active (state-machine) replication [11, 35]. <p> Following this approach, the special case of a two-round algorithm (a variant of the algorithm known as OM (1)) is specified in [28] in a couple of lines and its verification is almost completely automatic. In contrast, the treatment of OM (1) in <ref> [23] </ref> is long and detailed and quite complicated. The reason for its length and complexity is that this treatment explicitly considers the distributed, message passing character of the intended implementation, and calculates tight real-time bounds on the timeouts employed.
Reference: [24] <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The Byzantine Generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: For example, Rushby [34] and Bevier and Young [2] describe mechanically checked formal verifications of the same "Oral Messages" algorithm <ref> [24] </ref> for the consensus problem that were performed using different verification systems. Young [42] argues that differences in the difficulty of these treatments (that of [34] is generally considered simpler and clearer than that of [2]) are due to different choices in the way things are formalized.
Reference: [25] <author> Patrick Lincoln. </author> <title> Formally verified algorithms for diagnosis of manifest, symmetric, link, and Byzantine faults. </title> <type> Technical Report SRI-CSL-95-14, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Numerous algorithms have been developed to perform these functions and, because of their criticality and subtlety, several of them have been subjected to detailed formal [15, 23, 43] and mechanically checked [2, 26-28, 34] verifications, as have their combination into larger functions such as diagnosis <ref> [25] </ref>, and their synthesis into a fault-tolerant architecture based on active (state-machine) replication [11, 35]. Formal, and especially mechanically-checked, verification of these algorithms is still something of a tour de force, however.
Reference: [26] <author> Patrick Lincoln and John Rushby. </author> <title> Formal verification of an algorithm for interactive consistency under a hybrid fault model. In Costas Courcoubetis, editor, Computer-Aided Verification, </title> <booktitle> CAV '93, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 292-304, </pages> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference: [27] <author> Patrick Lincoln and John Rushby. </author> <title> A formally verified algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In Fault Tolerant Computing Symposium 23, </booktitle> <pages> pages 402-411, </pages> <address> Toulouse, France, </address> <month> June </month> <year> 1993. </year> <booktitle> IEEE Computer Society. Reprinted in [18, </booktitle> <pages> pp. 438-447]. </pages>
Reference: [28] <author> Patrick Lincoln and John Rushby. </author> <title> Formal verification of an interactive consistency algorithm for the Draper FTP architecture under a hybrid fault model. </title> <booktitle> In COMPASS '94 (Proceedings of the Ninth Annual Conference on Computer Assurance), </booktitle> <pages> pages 107-120, </pages> <address> Gaithersburg, MD, </address> <month> June </month> <year> 1994. </year> <institution> IEEE Washington Section. </institution>
Reference-contexts: For example, both verifications of the Oral Messages algorithm mentioned above specify the algorithm as a functional program and the proofs are conventional inductions. Following this approach, the special case of a two-round algorithm (a variant of the algorithm known as OM (1)) is specified in <ref> [28] </ref> in a couple of lines and its verification is almost completely automatic. In contrast, the treatment of OM (1) in [23] is long and detailed and quite complicated.
Reference: [29] <author> Nancy A. Lynch. </author> <title> Distributed Algorithms. Morgan Kaufmann Series in Data Management Systems. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1996. </year>
Reference-contexts: In fact, most of the papers that introduce the algorithms concerned, and the standard textbook <ref> [29] </ref>, use a similarly abstract and time-free treatment. <p> Systematic Formal Verification for Time-Triggered Algorithms 5 2 Round-Based Algorithms In her textbook <ref> [29] </ref>, Nancy Lynch identifies algorithms for the synchronous system model with those that execute in a series of "rounds." Rounds have two phases: in the first, each processor 1 sends a message to some or all of the other processors (different messages may be sent to different processors; the messages will <p> This treatment has been formalized and mechanically checked using the PVS verification system|see Section 3.4. 3.1 Synchronous Systems For the untimed case, we use Nancy Lynch's formal model for synchronous systems <ref> [29, Chapter 2] </ref>, with some slight adjustments to the notation that make it easier to match up with the mechanically verified treatment. Definition 1 Untimed Synchronous Systems. We assume a set mess of messages that includes a distinguished value null, and a set proc of processors. <p> Usually, processor faults are distinguished from communication faults; the former can be modeled by perturbations to the transition functions trans p , and the latter by allowing the messages received along a channel to be changed from those sent. Following <ref> [29, page 20] </ref>, an execution of the system is then an infinite sequence of triples (S 0 ; M 0 ; N 0 ); (S 1 ; M 1 ; N 1 ); (S 2 ; M 2 ; N 2 ); : : : where S r is the global
Reference: [30] <author> Paul S. Miner and Steven D. Johnson. </author> <title> Verification of an optimized fault-tolerant clock synchronization circuit: A case study exploring the boundary between formal reasoning systems. </title> <editor> In Mary Sheeran and Satnam Singh, editors, </editor> <title> Designing Correct Circuits, </title> <booktitle> Electronic Workshops in Computing, </booktitle> <address> Bastad, Sweden, </address> <month> September </month> <year> 1996. </year> <note> Springer-Verlag. 22 </note>
Reference-contexts: Lamport and Melliar-Smith describe some solutions [22], and a particularly clever and economical technique for one particular algorithm is introduced by Torres-Pomales [40] and formally verified by Miner and Johnson <ref> [30] </ref>. Schmuck and Cristian [38] examine the general case and show that monotonicity can be achieved with no loss of precision. Assumption 2 Clock Drift Rate.
Reference: [31] <author> Michael J. Morgan. </author> <title> Integrated modular avionics for next-generation commercial airplanes. </title> <journal> IEEE Aerospace and Electronic Systems Magazine, </journal> <volume> 6(8) </volume> <pages> 9-12, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The Honeywell SAFEbus TM [1,17] that provides the safety-critical backplane for the Boeing 777 Airplane Information Management System (AIMS) <ref> [31, 39] </ref>, the control system for the Shinkansen (Japanese Bullet Train) [16], and the Time-Triggered Protocol (TTP) proposed for safety-critical automobile functions [21] all use this latter approach.
Reference: [32] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: which is an array of the messages sent to its outgoing channels; q's component of that array is msg p (gu (r)(p))(q). 16 3.4 Mechanized Verification The treatment of synchronous and time-triggered systems in Sections 3.1 and 3.2 has been formally specified in the language of the PVS verification system <ref> [32] </ref>, and the verification of Section 3.3 has been mechanically checked using PVS's theorem prover. The PVS language is a higher-order logic with subtyping, and formalization of the semiformal treatment in Sections 3.1 and 3.2 was quite straightforward. <p> The formal specification and verification are described in the Appendix; the specification files themselves are available at URL http://www.csl.sri.com/dcca97.html. While it is reassuring to know that the semiformal development withstands mechanical scrutiny, we have argued previously (for example, <ref> [32, 36] </ref>) that mechanized formal verification provides several benefits in addition to the "certification" of proofs. In particular, mechanization supports reliable and inexpensive exploration of alternative designs, assumptions, and constraints. <p> How this "gathering together" is represented will depend on the resources of the specification language and logic concerned: in the treatment using the Boyer-Moore logic, for example, it is represented by a list of values [2]. In a higher-order logic such as PVS <ref> [32] </ref>, however, it can be represented by a function, specified as a -abstraction: q : send (1; send (0; v; T; q); q; p) (i.e., a function that, when applied to q, returns the value that p received from q).
Reference: [33] <author> M. Pease, R. Shostak, and L. Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: A number of basic functions have been identified that provide important building blocks in the construction of fault-tolerant synchronous systems [8, 10]; these include consensus (also known as interactive consistency and Byzantine agreement) <ref> [33] </ref>, reliable and atomic broadcast [9], and group membership [7].
Reference: [34] <author> John Rushby. </author> <title> Formal verification of an Oral Messages algorithm for interactive consistency. </title> <type> Technical Report SRI-CSL-92-1, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> July </month> <year> 1992. </year> <note> Also available as NASA Contractor Report 189704, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: Numerous algorithms have been developed to perform these functions and, because of their criticality and subtlety, several of them have been subjected to detailed formal [15, 23, 43] and mechanically checked <ref> [2, 26-28, 34] </ref> verifications, as have their combination into larger functions such as diagnosis [25], and their synthesis into a fault-tolerant architecture based on active (state-machine) replication [11, 35]. Formal, and especially mechanically-checked, verification of these algorithms is still something of a tour de force, however. <p> Some of the differences can be attributed to the ways in which the problems are formalized or to the different resources of the formal specification languages and theorem provers employed. For example, Rushby <ref> [34] </ref> and Bevier and Young [2] describe mechanically checked formal verifications of the same "Oral Messages" algorithm [24] for the consensus problem that were performed using different verification systems. Young [42] argues that differences in the difficulty of these treatments (that of [34] is generally considered simpler and clearer than that <p> For example, Rushby <ref> [34] </ref> and Bevier and Young [2] describe mechanically checked formal verifications of the same "Oral Messages" algorithm [24] for the consensus problem that were performed using different verification systems. Young [42] argues that differences in the difficulty of these treatments (that of [34] is generally considered simpler and clearer than that of [2]) are due to different choices in the way things are formalized. We may assume that such differences will be reduced or eliminated as experience is gained and the better choices become more widely known.
Reference: [35] <author> John Rushby. </author> <title> A fault-masking and transient-recovery model for digital flight-control systems. </title> <editor> In Jan Vytopil, editor, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, Kluwer International Series in Engineering and Computer Science, chapter 5, </booktitle> <pages> pages 109-136. </pages> <publisher> Kluwer, </publisher> <address> Boston, Dordecht, London, </address> <year> 1993. </year> <note> An earlier version appeared in [41, pp. 237-257]. </note>
Reference-contexts: functions and, because of their criticality and subtlety, several of them have been subjected to detailed formal [15, 23, 43] and mechanically checked [2, 26-28, 34] verifications, as have their combination into larger functions such as diagnosis [25], and their synthesis into a fault-tolerant architecture based on active (state-machine) replication <ref> [11, 35] </ref>. Formal, and especially mechanically-checked, verification of these algorithms is still something of a tour de force, however. To have real impact on practice, we need to reduce the difficulty of formal verification in this domain to a routine and largely automated process.
Reference: [36] <author> John Rushby. </author> <title> A formally verified algorithm for clock synchronization under a hybrid fault model. </title> <booktitle> In Thirteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 304-313, </pages> <address> Los Angeles, CA, </address> <month> August </month> <year> 1994. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: The formal specification and verification are described in the Appendix; the specification files themselves are available at URL http://www.csl.sri.com/dcca97.html. While it is reassuring to know that the semiformal development withstands mechanical scrutiny, we have argued previously (for example, <ref> [32, 36] </ref>) that mechanized formal verification provides several benefits in addition to the "certification" of proofs. In particular, mechanization supports reliable and inexpensive exploration of alternative designs, assumptions, and constraints.
Reference: [37] <author> John Rushby and David W. J. Stringer-Calvert. </author> <title> A less elementary tutorial for the PVS specification and verification system. </title> <type> Technical Report SRI-CSL-95-10, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> June </month> <year> 1995. </year> <note> Revised, </note> <month> July </month> <year> 1996. </year> <title> Available, with specification files, </title> <note> at http://www.csl.sri.com/ csl-95-10.html. </note>
Reference: [38] <author> Frank Schmuck and Flaviu Cristian. </author> <title> Continuous clock amortization need not affect the precision of a clock synchronization algorithm. </title> <booktitle> In Ninth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 133-143, </pages> <address> Quebec City, Quebec, Canada, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Lamport and Melliar-Smith describe some solutions [22], and a particularly clever and economical technique for one particular algorithm is introduced by Torres-Pomales [40] and formally verified by Miner and Johnson [30]. Schmuck and Cristian <ref> [38] </ref> examine the general case and show that monotonicity can be achieved with no loss of precision. Assumption 2 Clock Drift Rate.
Reference: [39] <author> William Sweet and Dave Dooling. </author> <title> Boeing's seventh wonder. </title> <journal> IEEE Spectrum, </journal> <volume> 32(10) </volume> <pages> 20-23, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: The Honeywell SAFEbus TM [1,17] that provides the safety-critical backplane for the Boeing 777 Airplane Information Management System (AIMS) <ref> [31, 39] </ref>, the control system for the Shinkansen (Japanese Bullet Train) [16], and the Time-Triggered Protocol (TTP) proposed for safety-critical automobile functions [21] all use this latter approach.
Reference: [40] <author> Wilfredo Torres-Pomales. </author> <title> An optimized implementation of a fault-tolerant clock synchronization circuit. </title> <type> NASA Technical Memorandum 109176, </type> <institution> NASA Langley Research Center, Hampton, VA, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: Lamport and Melliar-Smith describe some solutions [22], and a particularly clever and economical technique for one particular algorithm is introduced by Torres-Pomales <ref> [40] </ref> and formally verified by Miner and Johnson [30]. Schmuck and Cristian [38] examine the general case and show that monotonicity can be achieved with no loss of precision. Assumption 2 Clock Drift Rate.
Reference: [41] <editor> J. Vytopil, editor. </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 571 of Lecture Notes in Computer Science, </booktitle> <address> Nijmegen, The Netherlands, </address> <month> January </month> <year> 1992. </year> <title> Springer-Verlag. Systematic Formal Verification for Time-Triggered Algorithms 23 </title>
Reference: [42] <author> William D. Young. </author> <title> Comparing verification systems: Interactive Consistency in ACL2. </title> <booktitle> In COMPASS '96 (Proceedings of the Eleventh Annual Conference on Computer Assurance), </booktitle> <pages> pages 35-45, </pages> <address> Gaithersburg, MD, </address> <month> June </month> <year> 1996. </year> <institution> IEEE Washington Section. </institution>
Reference-contexts: For example, Rushby [34] and Bevier and Young [2] describe mechanically checked formal verifications of the same "Oral Messages" algorithm [24] for the consensus problem that were performed using different verification systems. Young <ref> [42] </ref> argues that differences in the difficulty of these treatments (that of [34] is generally considered simpler and clearer than that of [2]) are due to different choices in the way things are formalized.
Reference: [43] <author> Ping Zhou and Jozef Hooman. </author> <title> Formal specification and compositional verification of an atomic broadcast protocol. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 9(2) </volume> <pages> 119-145, </pages> <year> 1995. </year> <title> The views and conclusions contained herein are those of the author and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Air Force Office of Scientific Research or the U.S. Government. 24 Appendices In these appendices I present mechanically-checked formal specifications and verifications of the developments in Sections 3 and 4 using the PVS verification system [32]. The corresponding PVS specification and proof files are available from URL http://www.csl.sri.com/dcca97.html. </title>
Reference-contexts: Numerous algorithms have been developed to perform these functions and, because of their criticality and subtlety, several of them have been subjected to detailed formal <ref> [15, 23, 43] </ref> and mechanically checked [2, 26-28, 34] verifications, as have their combination into larger functions such as diagnosis [25], and their synthesis into a fault-tolerant architecture based on active (state-machine) replication [11, 35].
References-found: 43

