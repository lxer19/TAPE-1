URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/136.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Email: gyl@cs.cmu.edu thomas.gross@cs.cmu.edu  
Phone: (412) 268 3077 +41 1 632 7342  
Title: Global Register Allocation Based on Region-Unioning  
Author: Guei-Yuan Lueh Thomas Gross ; and Ali-Reza Adl-Tabatabai Thomas Gross 
Note: Contact: Guei-Yuan Lueh or  Extended Abstract  
Address: Pittsburgh, PA 15213 CH 8092 Zurich Pittsburgh, PA 15213  
Affiliation: 1 School of Computer Science 2 Institut fur Computer Systeme 3 ECE Department Carnegie Mellon University ETH Zurich Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. Bernstein, D. Q. Goldin, M. C. Golumbic, H. Krawczyk, Y. Mansour, I. Nahshon, and R. Y. Pinter. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 258-263. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Several approaches are based on this algorithm <ref> [5, 1, 3] </ref>. When an interference graph cannot be colored, however, this approach makes spilling decisions that are all-or-nothing: all definitions and uses of a spilled live range go through memory. There are situations where splitting produces better results [2]. <p> And if M N &gt; T , we must spill some non-transparent live ranges, which are selected by a heuristic based on spill cost, area, and the degrees in the interference graph <ref> [1] </ref>. We now describe in more detail the delayed spilling technique used to handle the case where M N &lt; T . Since all transparent live ranges conflict with each other, these live ranges form a clique in a region's interference graph.
Reference: [2] <author> P. Briggs. </author> <title> Register Allocation via Graph Coloring. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Several approaches are based on this algorithm [5, 1, 3]. When an interference graph cannot be colored, however, this approach makes spilling decisions that are all-or-nothing: all definitions and uses of a spilled live range go through memory. There are situations where splitting produces better results <ref> [2] </ref>. Several recent approaches have tried to fit live range splitting into Chaitin's coloring framework by splitting live ranges prior to coloring. Briggs [2] uses the Static Single Assignment (SSA) representation of a program 2 to determine split points. <p> There are situations where splitting produces better results <ref> [2] </ref>. Several recent approaches have tried to fit live range splitting into Chaitin's coloring framework by splitting live ranges prior to coloring. Briggs [2] uses the Static Single Assignment (SSA) representation of a program 2 to determine split points. Kolte and Harrold [12] partition a live range at a finer granularity by considering the ranges of instructions between loads and stores of a virtual register. <p> These approaches to live range splitting make splitting decisions prematurely, potentially resulting in unnecessary splits and a consequent performance degradation due to unnecessary shuffle code <ref> [2] </ref>. Furthermore, these approaches cannot easily use execution probabilities to determine the most profitable points to split live ranges. The priority-based coloring approach [7] assigns registers to live ranges in an order determined by a priority function, and splits a live range if it cannot be assigned a color. <p> While a general partial redundancy elimination algorithm could be used to optimize the shuffle code, a simple technique is effective in practice, details of which are deferred to the final paper. There exist further opportunities for improving the code in this phase: biased coloring <ref> [2] </ref> may eliminate shuffle code, optimistic coloring [3] may assign registers to live ranges that have been spilled by simplification, and if we notice that a live range gets a caller-saved register in a region with high call frequency, then the register assigner may decide to spill this live range nevertheless.
Reference: [3] <author> P. Briggs, K. D. Cooper, K. Kennedy, and L. Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: This process blocks when either all vertices have degree greater than N (the number of registers) [5] or when no legal color exists for a node <ref> [7, 3] </ref>. When coloring blocks, the compiler must somehow lower the maximum degree of the vertices in the interference graph to allow coloring to proceed. <p> Several approaches are based on this algorithm <ref> [5, 1, 3] </ref>. When an interference graph cannot be colored, however, this approach makes spilling decisions that are all-or-nothing: all definitions and uses of a spilled live range go through memory. There are situations where splitting produces better results [2]. <p> There exist further opportunities for improving the code in this phase: biased coloring [2] may eliminate shuffle code, optimistic coloring <ref> [3] </ref> may assign registers to live ranges that have been spilled by simplification, and if we notice that a live range gets a caller-saved register in a region with high call frequency, then the register assigner may decide to spill this live range nevertheless. 4 lr 2 (x) lr 1 (x)
Reference: [4] <author> D. Callahan and B. Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proc. SIGPLAN'91 on Programming Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <address> Toronto, </address> <month> June </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: This framework allows us to model a number of different approaches to register allocation <ref> [4, 9, 14] </ref>, including the classical Chaitin-style register allocation [5] if a region is a function. The key idea is to incrementally build up the interference graph. <p> A problem with the above coloring based approaches is that the interference graph does not contain control-flow information and thus spilling and splitting decisions are not sensitive to program structure. The approaches taken by Tera <ref> [4] </ref>, Multiflow [9], and RAP [14] attempt to make spilling and splitting decisions that are sensitive to program structure. <p> In the region formation phase, regions are formed using any number of possible techniques. For example, a region can be a single basic block, a trace [13], a superblock [11], a region as defined in [10], the blocks at a particular static loop nesting level <ref> [4] </ref>, or the blocks within a PDG region node [14]. Control flow edges that lie outside of regions are then ordered according to some priority function consistent with the region formation approach, e.g., edges entering innermost loop regions are ordered before those entering outermost loop regions.
Reference: [5] <author> G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins, and P. W. Markstein. </author> <title> Register allocation by coloring. </title> <type> Research Report 8395, </type> <institution> IBM Watson Research Center, </institution> <year> 1981. </year> <title> 10 (a) All available registers (26 int, 16 double). (b) Smaller number of registers (14 int, 14 double). (c) Impact of call cost optimization (CRO). </title> <type> 11 </type>
Reference-contexts: All functions called by the main loop of this program are inlined. On the left, we see the number of data movement operations for an enhanced Chaitin-style register allocator <ref> [5] </ref>. In the middle, we see the results for the approach described in this paper which removes about 50 % of the data movement operations compared to a Chaitin-style register allocator. <p> This framework allows us to model a number of different approaches to register allocation [4, 9, 14], including the classical Chaitin-style register allocation <ref> [5] </ref> if a region is a function. The key idea is to incrementally build up the interference graph. <p> This process blocks when either all vertices have degree greater than N (the number of registers) <ref> [5] </ref> or when no legal color exists for a node [7, 3]. When coloring blocks, the compiler must somehow lower the maximum degree of the vertices in the interference graph to allow coloring to proceed. <p> Several approaches are based on this algorithm <ref> [5, 1, 3] </ref>. When an interference graph cannot be colored, however, this approach makes spilling decisions that are all-or-nothing: all definitions and uses of a spilled live range go through memory. There are situations where splitting produces better results [2]. <p> The objective of the graph simplification phase is to determine how many live ranges must be spilled within each region. Simplification <ref> [5] </ref> is based on the observation that if a vertex V has degree &lt; N , then V can be trivially colored since no matter what colors are assigned to V 's neighbors, a legal color will remain for V .
Reference: [6] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter, and W. W. Hwu. </author> <title> Impact: An architectural framework for multiple--instruction-issue processors. </title> <booktitle> In Proc. 18th Intl. Symp. on Computer Architecture, </booktitle> <pages> pages 266-275. </pages> <address> ACM/IEEE, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Regions can be individual basic blocks, traces [13], superblocks [11], or any other grouping used in the compiler (e.g., the loop structure). This framework fits nicely into code generators that take a similar approach to instruction scheduling <ref> [13, 6] </ref>: the register allocator now uses the same units of compilation and the same execution probability estimates as the instruction scheduler.
Reference: [7] <author> F. C. Chow and J. L. Hennessy. </author> <title> A priority-based coloring approach to register allocation. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12 </volume> <pages> 501-535, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: This process blocks when either all vertices have degree greater than N (the number of registers) [5] or when no legal color exists for a node <ref> [7, 3] </ref>. When coloring blocks, the compiler must somehow lower the maximum degree of the vertices in the interference graph to allow coloring to proceed. <p> These approaches to live range splitting make splitting decisions prematurely, potentially resulting in unnecessary splits and a consequent performance degradation due to unnecessary shuffle code [2]. Furthermore, these approaches cannot easily use execution probabilities to determine the most profitable points to split live ranges. The priority-based coloring approach <ref> [7] </ref> assigns registers to live ranges in an order determined by a priority function, and splits a live range if it cannot be assigned a color. <p> The priority function captures the savings in memory accesses from assigning a register to a live range rather than keeping the live range in memory. The split heuristic described in <ref> [7] </ref> provides no guarantee that splitting occurs at infrequently executed points; shuffle code may end up, e.g., on a loop back arc. <p> One particularly attractive priority function is the use of execution probabilities. These can be derived either from profile information [8, 15], from static estimates such as loop nesting depth <ref> [7] </ref>, or from static branch estimates [13].
Reference: [8] <author> J. A. Fisher and S. M. Freudenberger. </author> <title> Predicting conditional branch direction from previous runs of a program. </title> <booktitle> In Proc. Fifth Intl. Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS V), </booktitle> <pages> pages 85-97. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: One particularly attractive priority function is the use of execution probabilities. These can be derived either from profile information <ref> [8, 15] </ref>, from static estimates such as loop nesting depth [7], or from static branch estimates [13].
Reference: [9] <author> S. Freudenberger and J. Ruttenberg. </author> <title> Phase ordering of register allocation and instruction scheduling. </title> <editor> In R. Giegerich and S. L. Graham, editors, </editor> <title> Code Generation Concepts, </title> <booktitle> Tools, Techniques, </booktitle> <pages> pages 146-170. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This framework allows us to model a number of different approaches to register allocation <ref> [4, 9, 14] </ref>, including the classical Chaitin-style register allocation [5] if a region is a function. The key idea is to incrementally build up the interference graph. <p> A problem with the above coloring based approaches is that the interference graph does not contain control-flow information and thus spilling and splitting decisions are not sensitive to program structure. The approaches taken by Tera [4], Multiflow <ref> [9] </ref>, and RAP [14] attempt to make spilling and splitting decisions that are sensitive to program structure.
Reference: [10] <author> R. Hank, W. Hwu, and B. Rau. </author> <title> Region-based compilation: An introduction and motivation. </title> <booktitle> In Proc. 28th Annual ACM/IEEE Intl. Symposium on Microarchitecture, page (to appear), </booktitle> <address> Ann Arbor, </address> <month> Nov </month> <year> 1995. </year> <month> ACM/IEEE. </month>
Reference-contexts: A simple enhancement, based on the observation that using caller-saved or callee-saved registers implies different costs, improves the results further and reduces the data movement overhead by 80%, as shown on the right. The framework presented in this paper is region-based <ref> [10] </ref>: the register allocator operates on groups of basic blocks formed using either profile information or static analysis. The register allocator does not dictate how these regions are formed and thus provides a general and flexible approach to register allocation; form and priorities of regions are parameters to our algorithm. <p> In the region formation phase, regions are formed using any number of possible techniques. For example, a region can be a single basic block, a trace [13], a superblock [11], a region as defined in <ref> [10] </ref>, the blocks at a particular static loop nesting level [4], or the blocks within a PDG region node [14].
Reference: [11] <author> W. W. Hwu, S. A. Mahlke, W. Y. Chen, P. P. Chang, N. J. Warter, R. A. Bringmann, R. O. Ouellette, R. E. Hank, T. Kiyohara, G. E. Haab, J. G. Holm, and D. M. Lavery. </author> <title> The superblock: An effective technique for vliw and superscalar compilation. </title> <journal> Journal of Supercomputing, </journal> <volume> 7(1,2):229-248, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: The register allocator does not dictate how these regions are formed and thus provides a general and flexible approach to register allocation; form and priorities of regions are parameters to our algorithm. Regions can be individual basic blocks, traces [13], superblocks <ref> [11] </ref>, or any other grouping used in the compiler (e.g., the loop structure). This framework fits nicely into code generators that take a similar approach to instruction scheduling [13, 6]: the register allocator now uses the same units of compilation and the same execution probability estimates as the instruction scheduler. <p> There are four phases in this framework: region formation, graph simplification, graph merging, and register assignment. In the region formation phase, regions are formed using any number of possible techniques. For example, a region can be a single basic block, a trace [13], a superblock <ref> [11] </ref>, a region as defined in [10], the blocks at a particular static loop nesting level [4], or the blocks within a PDG region node [14].
Reference: [12] <author> P. Kolte and M. J. Harrold. </author> <title> Load/store range analysis for global register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 268-277. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Several recent approaches have tried to fit live range splitting into Chaitin's coloring framework by splitting live ranges prior to coloring. Briggs [2] uses the Static Single Assignment (SSA) representation of a program 2 to determine split points. Kolte and Harrold <ref> [12] </ref> partition a live range at a finer granularity by considering the ranges of instructions between loads and stores of a virtual register. These approaches to live range splitting make splitting decisions prematurely, potentially resulting in unnecessary splits and a consequent performance degradation due to unnecessary shuffle code [2].
Reference: [13] <author> P. G. Lowney, S. M. Freudenberger, T. J. Karzes, W. D. Lichtenstein, R. P. Nix, J. O'Donnell, and J. C. Ruttenberg. </author> <title> The multiflow trace scheduling compiler. </title> <journal> Journal of Supercomputing, </journal> <volume> 7(1,2):51-142, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: The register allocator does not dictate how these regions are formed and thus provides a general and flexible approach to register allocation; form and priorities of regions are parameters to our algorithm. Regions can be individual basic blocks, traces <ref> [13] </ref>, superblocks [11], or any other grouping used in the compiler (e.g., the loop structure). <p> Regions can be individual basic blocks, traces [13], superblocks [11], or any other grouping used in the compiler (e.g., the loop structure). This framework fits nicely into code generators that take a similar approach to instruction scheduling <ref> [13, 6] </ref>: the register allocator now uses the same units of compilation and the same execution probability estimates as the instruction scheduler. <p> There are four phases in this framework: region formation, graph simplification, graph merging, and register assignment. In the region formation phase, regions are formed using any number of possible techniques. For example, a region can be a single basic block, a trace <ref> [13] </ref>, a superblock [11], a region as defined in [10], the blocks at a particular static loop nesting level [4], or the blocks within a PDG region node [14]. <p> One particularly attractive priority function is the use of execution probabilities. These can be derived either from profile information [8, 15], from static estimates such as loop nesting depth [7], or from static branch estimates <ref> [13] </ref>.
Reference: [14] <author> C. Norris and L. L. Pollock. </author> <title> Register allocation over the program dependence graph. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 266-277. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: This framework allows us to model a number of different approaches to register allocation <ref> [4, 9, 14] </ref>, including the classical Chaitin-style register allocation [5] if a region is a function. The key idea is to incrementally build up the interference graph. <p> A problem with the above coloring based approaches is that the interference graph does not contain control-flow information and thus spilling and splitting decisions are not sensitive to program structure. The approaches taken by Tera [4], Multiflow [9], and RAP <ref> [14] </ref> attempt to make spilling and splitting decisions that are sensitive to program structure. <p> For example, a region can be a single basic block, a trace [13], a superblock [11], a region as defined in [10], the blocks at a particular static loop nesting level [4], or the blocks within a PDG region node <ref> [14] </ref>. Control flow edges that lie outside of regions are then ordered according to some priority function consistent with the region formation approach, e.g., edges entering innermost loop regions are ordered before those entering outermost loop regions. One particularly attractive priority function is the use of execution probabilities.
Reference: [15] <author> D. Wall. </author> <title> Predicting program behavior using real or estimated profiles. </title> <booktitle> In Proc. ACM SIGPLAN '91 Symposium on Compiler Construction, </booktitle> <pages> pages 59-70. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year> <month> 12 </month>
Reference-contexts: One particularly attractive priority function is the use of execution probabilities. These can be derived either from profile information <ref> [8, 15] </ref>, from static estimates such as loop nesting depth [7], or from static branch estimates [13].
References-found: 15

