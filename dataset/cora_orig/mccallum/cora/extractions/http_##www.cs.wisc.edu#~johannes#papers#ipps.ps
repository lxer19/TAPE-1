URL: http://www.cs.wisc.edu/~johannes/papers/ipps.ps
Refering-URL: http://www.cs.wisc.edu/~johannes/publications.html
Root-URL: 
Title: Fast Scheduling of Periodic Tasks on Multiple Resources  
Author: Sanjoy K. Baruah Johannes E. Gehrke C. Greg Plaxton 
Abstract: Given n periodic tasks, each characterized by an execution requirement and a period, and m identical copies of a resource, the periodic scheduling problem is concerned with generating a schedule for the n tasks on the m resources. We present an algorithm that schedules every feasible instance of the periodic scheduling problem, and runs in O(minfm lg n; ng) time per slot scheduled. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. K. Baruah, N. K. Cohen, C. G. Plaxton, and D. A. Varvel. </author> <title> Proportionate progress: A notion of fairness in resource allocation. </title> <journal> Algorithmica, </journal> <volume> 15 </volume> <pages> 600-625, </pages> <year> 1996. </year>
Reference-contexts: One might expect that it would be relatively straightforward to "patch up" the Earliest Deadline algorithm to take care of such difficulties. However, this turns out to be a non-trivial problem. In fact, prior to the recent work of Baruah et al. <ref> [1] </ref>, no polynomial time algorithm of any kind was known for the periodic scheduling problem. In [1], an algorithm is presented for the periodic scheduling problem with a running time that is linear in the size of the input in bits, that is, O X dlg (x:p + 1)e : (1) <p> However, this turns out to be a non-trivial problem. In fact, prior to the recent work of Baruah et al. <ref> [1] </ref>, no polynomial time algorithm of any kind was known for the periodic scheduling problem. In [1], an algorithm is presented for the periodic scheduling problem with a running time that is linear in the size of the input in bits, that is, O X dlg (x:p + 1)e : (1) (Note that the preceding sum is at least n, since there are n tasks and the <p> This requirement is called proportionate fairness or P-fairness. P-fairness is a strictly stronger condition than periodic scheduling, in that any P-fair schedule is periodic while the converse does not hold. It has been shown, however, that every feasible instance of the periodic scheduling problem has a P-fair schedule <ref> [1] </ref>. Although Algorithm PF and the Earliest Deadline algorithm bear little obvious resemblance to one another (e.g., they tend to produce radically different schedules even in the case m = 1), there is in fact an interesting relationship between these two algorithms. <p> Like Algorithm PF, Algorithm PD solves the periodic scheduling problem by generating a P-fair schedule for every feasible instance. (To the best of our knowledge, no previously known algorithm generates P-fair schedules even in the case of a single resource.) Our work builds on that of <ref> [1] </ref> by making use of the correctness of Algorithm PF to exhibit a constant-time tie-breaking procedure that is sufficient to maintain P-fairness. In essence, our approach is to limit the tie-breaking procedure to look only a constant number of pseudo-deadlines into the future. <p> We find that the deviation is sufficiently small to guarantee that Algorithm PD maintains P-fairness as long as Algorithm PF does. The correctness of Algorithm PD then follows from the fact that Algorithm PF is known to maintain P-fairness <ref> [1] </ref>. The remainder of this paper is organized as follows. In Section 2, we review the basic definitions associated with P-fairness. In Section 3, we review Algorithm PF of [1]. <p> The correctness of Algorithm PD then follows from the fact that Algorithm PF is known to maintain P-fairness <ref> [1] </ref>. The remainder of this paper is organized as follows. In Section 2, we review the basic definitions associated with P-fairness. In Section 3, we review Algorithm PF of [1]. In Section 4, we present our new algorithm for the periodic scheduling problem, Algorithm PD, along with an outline of the proof of correctness. The full proof of correctness appears in [2]. <p> There remain, however, several other important multiple resource scheduling problems for which no efficient solutions are known; in Section 5, we conclude with a general plan for attacking such problems. 2 P-Fairness In this section we review some concepts introduced in <ref> [1] </ref>. We start with some conventions: * Scheduling decisions occur at integral values of time, numbered from 0. <p> 1: * A schedule S is defined to be P-fair at time t if there exists a P-fair schedule S 0 such that 8x : x 2 : lag (S; x; t) = lag (S 0 ; x; t): Every instance of the periodic scheduling problem has a P-fair schedule <ref> [1, Theorem 1] </ref>. 3 A P-Fair Scheduling Algorithm We now review Algorithm PF, the algorithm defined in [1] that produces a P-fair schedule for any feasible instance of the periodic scheduling problem. <p> P-fair schedule S 0 such that 8x : x 2 : lag (S; x; t) = lag (S 0 ; x; t): Every instance of the periodic scheduling problem has a P-fair schedule [1, Theorem 1]. 3 A P-Fair Scheduling Algorithm We now review Algorithm PF, the algorithm defined in <ref> [1] </ref> that produces a P-fair schedule for any feasible instance of the periodic scheduling problem. <p> Algorithm PF determines which m-subset of the n tasks to schedule in each slot t. As argued in <ref> [1] </ref>, every urgent (resp., tnegru) task must (resp., must not) be scheduled in the current slot in order to preserve P-fairness. <p> Schedule all urgent tasks. 2. Allocate the remaining resources to the highest-priority contending tasks according to the total order -. Let S PF denote the schedule produced by Algorithm PF on a given instance of the periodic scheduling problem. Schedule S PF is known to be P-fair <ref> [1, Theorem 2] </ref>. An implementation of the characteristic substring comparison function required by Algorithm PF was presented in [1] and proven to execute in time linear in the size of the binary representation of minfx:p; y:pg. <p> Let S PF denote the schedule produced by Algorithm PF on a given instance of the periodic scheduling problem. Schedule S PF is known to be P-fair [1, Theorem 2]. An implementation of the characteristic substring comparison function required by Algorithm PF was presented in <ref> [1] </ref> and proven to execute in time linear in the size of the binary representation of minfx:p; y:pg. <p> A heap-based implementation that runs in O (m log n) time is described in Appendix A. 5 Conclusions The techniques presented in this paper build on the results established in <ref> [1] </ref>. As argued in the introduction, the tie-breaking procedure of [1] may be viewed as a natural generalization of an "earliest deadline" strategy. <p> A heap-based implementation that runs in O (m log n) time is described in Appendix A. 5 Conclusions The techniques presented in this paper build on the results established in <ref> [1] </ref>. As argued in the introduction, the tie-breaking procedure of [1] may be viewed as a natural generalization of an "earliest deadline" strategy. As the earliest deadline paradigm has proven to be useful for solving a large number of scheduling problems, especially problems involving a single resource (such as uniprocessor scheduling problems), it seems likely that the P-fairness-based approach of [1] <p> <ref> [1] </ref> may be viewed as a natural generalization of an "earliest deadline" strategy. As the earliest deadline paradigm has proven to be useful for solving a large number of scheduling problems, especially problems involving a single resource (such as uniprocessor scheduling problems), it seems likely that the P-fairness-based approach of [1] will be useful for solving an even larger class of scheduling problems, especially problems involving multiple resources. The importance of the work in the present paper is that it demonstrates an approach for obtaining highly efficient scheduling algorithms based on P-fairness. <p> More specifically, our work suggests the following general plan for attacking a given scheduling problem: 1. Prove that a P-fair solution exists for the problem in question. In the case of the periodic scheduling problem, this step was accomplished using a network flow argument <ref> [1, Theorem 1] </ref>. 2. Find the "canonical" P-fair algorithm for solving the problem. In the case of the periodic scheduling problem, this is Algorithm PF of [1]. <p> In the case of the periodic scheduling problem, this step was accomplished using a network flow argument [1, Theorem 1]. 2. Find the "canonical" P-fair algorithm for solving the problem. In the case of the periodic scheduling problem, this is Algorithm PF of <ref> [1] </ref>. Informally, we view Algorithm PF as the canonical P-fair scheduling algorithm for the periodic scheduling problem because every scheduling decision that it makes is "locally optimal" with respect to preserving P-fairness. This local optimality is achieved by looking arbitrarily far into the future when making current scheduling decisions. 3.
Reference: [2] <author> S. K. Baruah, J. E. Gehrke, and C. G. Plax--ton. </author> <title> Fast scheduling of periodic tasks on multiple resources. </title> <type> Technical Report TR-95-02, </type> <institution> Department of Computer Science, University of Texas at Austin, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: In Section 3, we review Algorithm PF of [1]. In Section 4, we present our new algorithm for the periodic scheduling problem, Algorithm PD, along with an outline of the proof of correctness. The full proof of correctness appears in <ref> [2] </ref>. A straightforward implementation of Algorithm PD has a running time of O (n), which already represents a significant improvement over the performance of Algorithm PF. In Appendix A, we outline a binomial-heap-based implementation of Algorithm PD with a running time of O (m lg n). <p> In the following, we refer to an arbitrary schedule drawn from this set as S PD . Theorem 1 Schedule S PD is P-fair. In the remainder of this section, we sketch the proof of Theorem 1. A complete proof appears in <ref> [2] </ref>. Note that Algorithm PD determines the priority between contending tasks on the basis of the next pseudo-deadlines. In contrast, Algorithm PF takes into account a potentially exponential number of pseudo-deadlines in order to resolve priority.
Reference: [3] <author> S. K. Baruah, R. R. Howell, and L. E. Rosier. </author> <title> Algorithms and complexity concerning the preemptive scheduling of periodic, real-time tasks on one processor. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 2 </volume> <pages> 301-324, </pages> <year> 1990. </year>
Reference-contexts: Constraint 2: No task may be allocated more than one copy of the resource in any single slot. The problem of constructing periodic schedules for such task systems was discussed by Liu in 1969 [6], and is called the (multiple resource) periodic scheduling problem. It has been shown <ref> [3, 5] </ref> that an instance of the periodic scheduling problem is feasible (i.e., has a periodic schedule) if and only if ( P Given a feasible instance of the periodic scheduling problem, a schedule generation algorithm performs a (possibly empty) pre-processing phase followed by an infinite execution phase.
Reference: [4] <author> M. Blum, R. W. Floyd, V. R. Pratt, R. L. Rivest, and R. E. Tarjan. </author> <title> Time bounds for selection. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 7 </volume> <pages> 448-461, </pages> <year> 1973. </year>
Reference-contexts: Theorem 2 Algorithm PD can be implemented in O (min (n; m log n)) time. Proof: In conjunction with any linear-comparison selection algorithm (e.g., <ref> [4] </ref>), the constant time priority comparison algorithm described in this section provides an O (n) time implementation of Algorithm PD.
Reference: [5] <author> W. A. Horn. </author> <title> Some simple scheduling algorithms. </title> <journal> Naval Research Logistics Quarterly, </journal> <volume> 21 </volume> <pages> 177-185, </pages> <year> 1974. </year>
Reference-contexts: Constraint 2: No task may be allocated more than one copy of the resource in any single slot. The problem of constructing periodic schedules for such task systems was discussed by Liu in 1969 [6], and is called the (multiple resource) periodic scheduling problem. It has been shown <ref> [3, 5] </ref> that an instance of the periodic scheduling problem is feasible (i.e., has a periodic schedule) if and only if ( P Given a feasible instance of the periodic scheduling problem, a schedule generation algorithm performs a (possibly empty) pre-processing phase followed by an infinite execution phase.
Reference: [6] <author> C. L. Liu. </author> <title> Scheduling algorithms for multiprocessors in a hard-real-time environment. JPL Space Programs Summary 37-60, vol. II, </title> <institution> Jet Propulsion Laboratory, California Institute of Technology, Pasadena, </institution> <address> CA, </address> <pages> pages 28-37, </pages> <month> November </month> <year> 1969. </year>
Reference-contexts: Constraint 2: No task may be allocated more than one copy of the resource in any single slot. The problem of constructing periodic schedules for such task systems was discussed by Liu in 1969 <ref> [6] </ref>, and is called the (multiple resource) periodic scheduling problem.
Reference: [7] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> JACM, </journal> <volume> 20 </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference-contexts: A simple yet powerful idea for solving many scheduling problems involving deadlines is to give priority to the task with the earliest associated deadline, breaking ties arbitrarily. For example, the Earliest Deadline algorithm of Liu and Layland <ref> [7] </ref> schedules any feasible instance of the single resource (i.e., m = 1) periodic scheduling problem. The same algorithm can also be used to solve a relaxed version of the (multiple resource) periodic scheduling problem in which Constraint 2 is eliminated.
Reference: [8] <author> J. Vuillemin. </author> <title> A data structure for manipulating priority queues. </title> <journal> Communications of the ACM, </journal> <volume> 21 </volume> <pages> 309-315, </pages> <year> 1978. </year>
References-found: 8

