URL: http://www.win.tue.nl/inf/onderzoek/csr/abs/96.05.ps
Refering-URL: http://www.win.tue.nl/inf/onderzoek/publicaties.html
Root-URL: http://www.win.tue.nl
Email: email: ftbasten,wsinwag@win.tue.nl  
Title: A Process-Algebraic Approach to Life-Cycle Inheritance Inheritance D Encapsulation C Abstraction  
Author: T. Basten and W.M.P. van der Aalst 
Keyword: object orientation inheritance- object life cycle process algebra dynamic behavior  
Address: Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology, The  
Abstract: One of the key issues of object-oriented modeling is inheritance. It allows for the definition of subclasses that inherit features of some superclass. Inheritance is well defined for static properties of classes such as attributes and methods. However, there is no general agreement on the meaning of inheritance when considering the dynamic behavior of objects, determined by their life cycles. This paper studies the latter in the context of a simple process algebra. Process algebra is chosen, because it concentrates on dynamic behavior, while abstracting from the internal states of processes. Inheritance can be expressed in terms of encapsulation and abstraction. The combination captures all basic operators for constructing life cycles of subclasses from life cycles of superclasses, namely choice, sequential composition, and parallel composition. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> W.M.P. van der Aalst and T. Basten. </author> <title> Life-Cycle Inheritance: A Petri-Net-Based Approach. </title> <institution> Computing Science Report 96/06, Eindhoven University of Technology, Department of Mathematics and Computing Science, </institution> <address> Eind-hoven, The Netherlands, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: These two concepts are well investigated in the field of process algebra, in particular the process algebra ACP [5]. We hope to get a clear understanding of the meaning of life-cycle inheritance in terms of a simple algebraic theory. In another paper <ref> [1] </ref>, we turn to Petri nets which is a graphical formalism with a solid theoretical basis, but much closer to existing object-oriented techniques such as OMT and OOD. <p> In case it is possible to specify recursive behavior, a nice variant of PP is a rule in which the behavior b r is iterated arbitrary many times before continuing with q. An example of such a rule with iteration can be found in <ref> [1] </ref>. Property 4.6. <p> The algebraic theory does not include recursion and it has no explicit representation of internal states. Moreover, it is not straightforward to add these features and still maintain a framework as simple and clear as the theory in this paper. Therefore, in another paper <ref> [1] </ref>, we turn to Petri nets, which is a graphical formalism, much closer to the state diagrams used in existing techniques as OMT and OOD. Petri nets inherently allow recursion and they have an explicit representation of states, two features that are essential to a successful object-oriented methodology. <p> Petri nets inherently allow recursion and they have an explicit representation of states, two features that are essential to a successful object-oriented methodology. The translation of the concepts developed in this paper to Petri nets in <ref> [1] </ref> is illustrative for translations to other state-based formalisms.
Reference: 2. <author> G. Agha et al. </author> <title> Panel discussion at the workshop on Object-Oriented Programming and Models of Concurrency. </title> <booktitle> 16th. International Conference on the Application and Theory of Petri Nets, </booktitle> <address> Torino, Italy, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Methodologies as OMT and OOD do not specify the meaning of inheritance of life cycles. In general, there seems to be no agreement on what exactly inheritance of dynamic behavior is (See for example <ref> [2] </ref>). That is, it is not clear when some object class inherits the life cycle of some other class. Techniques as OMT and OOD use state-transition diagrams for specifying the life cycles of objects belonging to some class.
Reference: 3. <author> J.C.M. Baeten, J.A. Bergstra, and J.W. Klop. </author> <title> Conditional Axioms and ff/fi-calculus in Process Algebra. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Proceedings of the IFIP Conference on Formal Description of Programming Concepts - III, </booktitle> <pages> pages 53-75, </pages> <address> Ebberup, Denmark, 1986. </address> <publisher> North-Holland, </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1987. </year> <month> 14 </month>
Reference-contexts: The above definition of the alphabet operator is taken from <ref> [3] </ref>. In that paper, it is shown that the alphabet operator is a congruence for the operators of PA o ffiae . That is, if two PA o ffiae terms are derivably equal, then they have the same alphabet.
Reference: 4. <author> J.C.M. Baeten and C. Verhoef. </author> <title> Concrete Process Algebra. </title> <editor> In S. Abramsky, Dov M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, volume 4, Semantic Modelling, </booktitle> <pages> pages 149-268. </pages> <publisher> Oxford University Press, Oxford, </publisher> <address> UK, </address> <year> 1995. </year>
Reference-contexts: In particular, we do not formalize recursion. Recursion would unnecessarily complicate the theory and distract the readers attention from the important concepts. For a detailed treatment of recursion in ACP, the interested reader is referred to <ref> [5, 4] </ref>. For modeling object life cycles, assume that we have a set L of labels denoting methods. Label o is used to denote internal methods. <p> Proof. It is straightforward to prove the property using the axioms of Table 1 excluding A1 and A2 as rewrite rules from left to right. For a description of some standard term-rewriting techniques used in process algebra, see <ref> [4] </ref>. 2 It is straightforward to give an operational semantics for PA o ffiae (See for example [5]). It is a standard result in process algebra that the equational theory PA o ffiae is a sound and complete axiomatization of an equivalence called rooted branching bisimulation. <p> Rooted branching bisimulation is not used explicitly in this paper. Techniques for proving soundness and completeness of equational theories and many basic results can be found in <ref> [4] </ref> and [5]. Although the soundness and completeness of PA o ffiae is not proven in either of these references, it is a fairly straightforward consequence of some results in [5] and the proof techniques of [4]. <p> soundness and completeness of equational theories and many basic results can be found in <ref> [4] </ref> and [5]. Although the soundness and completeness of PA o ffiae is not proven in either of these references, it is a fairly straightforward consequence of some results in [5] and the proof techniques of [4].
Reference: 5. <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra, </title> <booktitle> volume 18 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1990. </year>
Reference-contexts: Process algebra is particularly well suited to describe process behavior without explicitly referring to process states. In addition, we believe that life-cycle inheritance corresponds to abstraction and encapsulation of methods. These two concepts are well investigated in the field of process algebra, in particular the process algebra ACP <ref> [5] </ref>. We hope to get a clear understanding of the meaning of life-cycle inheritance in terms of a simple algebraic theory. <p> In particular, we do not formalize recursion. Recursion would unnecessarily complicate the theory and distract the readers attention from the important concepts. For a detailed treatment of recursion in ACP, the interested reader is referred to <ref> [5, 4] </ref>. For modeling object life cycles, assume that we have a set L of labels denoting methods. Label o is used to denote internal methods. <p> For a description of some standard term-rewriting techniques used in process algebra, see [4]. 2 It is straightforward to give an operational semantics for PA o ffiae (See for example <ref> [5] </ref>). It is a standard result in process algebra that the equational theory PA o ffiae is a sound and complete axiomatization of an equivalence called rooted branching bisimulation. Branching bisimulation and rooted branching bisimulation were originally introduced by Van Glabbeek and Weijland in [8]. <p> Rooted branching bisimulation is not used explicitly in this paper. Techniques for proving soundness and completeness of equational theories and many basic results can be found in [4] and <ref> [5] </ref>. Although the soundness and completeness of PA o ffiae is not proven in either of these references, it is a fairly straightforward consequence of some results in [5] and the proof techniques of [4]. <p> Techniques for proving soundness and completeness of equational theories and many basic results can be found in [4] and <ref> [5] </ref>. Although the soundness and completeness of PA o ffiae is not proven in either of these references, it is a fairly straightforward consequence of some results in [5] and the proof techniques of [4]. <p> of o I .Y 1 / cannot be removed, nor can the two o -actions in the context of a choice in process o I .Y 2 / (although the first o in o I .Y 2 / can be eliminated if some kind of fairness principle is used, see <ref> [5] </ref>). The first problem can be solved easily. Observe that in the framework of this paper X and Y 1 do not denote object life cycles.
Reference: 6. <author> G. Booch. </author> <title> Object-Oriented Analysis and Design: With Applications. </title> <address> Benjamin/Cummings, Redwood City, CA, USA, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction In software-engineering practice, the popularity of object-oriented modeling and design is increasing rapidly. Two methodologies are in common use: OMT [9] and OOD <ref> [6] </ref>. One of the key issues in any object-oriented methodology is inheritance. The inheritance mechanism allows the user to specify a subclass that inherits features of some other class, its superclass.
Reference: 7. <author> R.J. van Glabbeek. </author> <title> What is Branching Time Semantics and Why to Use It? In Bulletin of the EATCS, </title> <booktitle> number 53, </booktitle> <pages> pages 191-198. </pages> <institution> European Association for Theoretical Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: The root condition is necessary to guarantee that the equivalence is a congruence for the algebraic choice operator. For object life cycles, which always start with the object-creation action, rooted branching bisimulation and branching bisimulation coincide. In <ref> [7] </ref>, Van Glabbeek shows that branching bisimulation is exactly the equivalence that distinguishes processes with different moments of choice and in which processes with possibly different internal behavior but with the same observable behavior are equal.
Reference: 8. <author> R.J. van Glabbeek and W.P. Weijland. </author> <title> Branching Time and Abstraction in Bisimulation Semantics (extended abstract). </title> <editor> In G.X. Ritter, editor, </editor> <booktitle> Information Processing 89: Proceedings of the IFIP 11th. World Computer Congress, </booktitle> <pages> pages 613-618, </pages> <address> San Fransisco, CA, USA, August/September 1989. </address> <publisher> Elsevier Science Publishers B.V., North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: It is a standard result in process algebra that the equational theory PA o ffiae is a sound and complete axiomatization of an equivalence called rooted branching bisimulation. Branching bisimulation and rooted branching bisimulation were originally introduced by Van Glabbeek and Weijland in <ref> [8] </ref>. The latter is a restriction of the former by means of an additional root condition. The root condition is necessary to guarantee that the equivalence is a congruence for the algebraic choice operator.
Reference: 9. <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, USA, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction In software-engineering practice, the popularity of object-oriented modeling and design is increasing rapidly. Two methodologies are in common use: OMT <ref> [9] </ref> and OOD [6]. One of the key issues in any object-oriented methodology is inheritance. The inheritance mechanism allows the user to specify a subclass that inherits features of some other class, its superclass.
Reference: 10. <author> R.J. Wieringa. </author> <title> Algebraic Foundations for Dynamic Conceptual Models. </title> <type> PhD thesis, </type> <institution> Free University, </institution> <address> Amsterdam, The Netherlands, </address> <year> 1990. </year> <month> 15 </month>
Reference-contexts: It is not difficult to see that there is no relation between the first person and the second person under any of the other inheritance relations. Projection inheritance is also suggested by Wieringa in <ref> [10] </ref>. However, based on an example similar to the last one above, Wieringa concludes that projection inheritance is not a proper definition for inheritance of dynamic behavior. We agree that, in general, projection inheritance is too restricted. <p> This result follows from the context rule of Property 3.14 iv/ and rule LC2. Example 4.8. The following example is taken from <ref> [10] </ref>, where it is used to illustrate the shortcomings of projection inheritance in isolation. Although we have not formalized recursion in this paper, it should be clear that the following calculations are correct. <p> Although we have not formalized recursion in this paper, it should be clear that the following calculations are correct. Assume we have the following equations: X D a X Y 2 D .b 2 C a/ Y 2 C b 3 In <ref> [10] </ref>, X is the life cycle of a person and Y the life cycle of an employee. Action a denotes a change of address; b 1 is the hiring of an employee; b 2 is a promotion and b 3 denotes the employee leaving the job. <p> Second, by applying rule PT twice, it follows that Y 2 lc X . The context property of the previous section implies that .5 b 1 / Y 2 lc X 0 . As before, it follows that Y 0 lc X 0 . As Wieringa already observes in <ref> [10] </ref>, abstraction is a useful notion for describing life-cycle-inheritance relations, but it does not always appear to be sufficient. In that case, the combination of abstraction and encapsulation seems to be a solution. 5 Concluding Remarks This paper presents a characterization of life-cycle inheritance in a simple process-algebraic setting.
References-found: 10

