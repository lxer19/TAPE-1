URL: http://www.cs.umn.edu/research/shashi-group/paper_ps/tse93.dynora.ps
Refering-URL: http://www.cs.umn.edu/Research/shashi-group/abstract/tse93.dynora.abs.html
Root-URL: http://www.cs.umn.edu
Title: Specification and Analysis of Real-time Problem Solvers  
Author: Babak Hamidzadeh Shashi Shekhar 
Keyword: Index Terms: Real-time, Problem Solving, Search.  
Address: Minneapolis, MN 55455  
Affiliation: Computer Science Dept. University of Minnesota  
Abstract: There has been a recent rise in research on real-time problem solving algorithms in artificial intelligence (AI). A real-time AI problem solver performs a task or a set of tasks in two phases. During the first phase, the problem solver searches for a solution that, once executed, will satisfy the requirements of the task. We refer to this phase as the planning phase or the search phase. During the next phase, the problem solver executes the planned solution to achieve the desired results of the task. This phase is referred to as the execution phase. Under time constraints, a real-time AI problem solver must balance planning and execution to minimize total response times and to comply with deadlines. This paper provides a methodology for the specification of real-time AI problem solvers. Using this methodology, we provide a formal specification of a real-time problem. In addition, the paper presents a methodology for analyzing real-time AI problem solvers. This methodology is demonstrated via a case study of two real-time problem solvers, namely DYNORAII and RTA*[ 1], for the real-time path planning problem. We provide new results on worst-case and average-case complexity of the problem, and of the algorithms that solve it. We also provide experimental evaluation of DYNORAII and RTA* for deadline compliance and response-time minimization. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R.E. Korf, </author> <title> RealTime Heuristic Search First Results, </title> <booktitle> Proc. AAAI Conference, </booktitle> <year> (1987). </year>
Reference-contexts: The longer the time it takes to plan a solution, the more obsolete the solution becomes at the time of execution. A real-time planning system in such a situation may deviate from the ``plan completely before execution'' paradigm to the ``sequence of partial planning followed by execution'' paradigm <ref> [1] </ref> to avoid obsolescence of the plans. In the ``sequence of partial planning followed by execution'' paradigm, the planner plans for a limited time to calculate a partial plan. The planner then executes a move in the plan to advance to the next state. <p> These algorithms will search for a complete execution plan, using the state of the world at the beginning of the planning process, before making their first move towards execution. In a dynamic situation, actions must be committed before their ultimate consequences are known <ref> [1] </ref>. The amount of planning allowed before each move is limited by the resources available and by the changes that occur in the environment. g On-line situations are those in which the world changes rapidly and unexpectedly during planning. Events in these situations necessitate major revisions of solutions during planning. <p> As each successor node is created, its estimated distance from the goal (i.e. h), the cost from the current node (i.e. g), and the sum of h and g (i.e. f) are calculated. The euclidean distance formula is used to calculate the h values. This heuristic formula is monotonic <ref> [1] </ref> and is guaranteed to produce optimal solutions in A*. In the case of RTA*, this heuristic formula allows substantial pruning of frontier nodes without loss of valuable information in reaching a partial solution. <p> This is accomplished by penalizing cyclic and dead-end paths, and by leaving the h value of the second best path at each decision point <ref> [1] </ref>. This algorithm has been shown to be correct and complete in static worlds [1]. - 16 - 5.2.2. DYnamic Near Optimal Response-time Algorithm II (DYNORAII) DYNORAII performs planning and execution cycles repeatedly until a goal node is reached, assuming that the graph has a solution. <p> This is accomplished by penalizing cyclic and dead-end paths, and by leaving the h value of the second best path at each decision point <ref> [1] </ref>. This algorithm has been shown to be correct and complete in static worlds [1]. - 16 - 5.2.2. DYnamic Near Optimal Response-time Algorithm II (DYNORAII) DYNORAII performs planning and execution cycles repeatedly until a goal node is reached, assuming that the graph has a solution. <p> RTA* <ref> [1] </ref> uses a fixed look-ahead, specifying a static bound for the look-ahead search. When this look-ahead bound is reached, RTA* stops the look-ahead search regardless of the quality of the solution found and regardless of the amount of search done. <p> It also is able to get out of local minima and graph cycles. This is accomplished by penalizing cyclic and dead-end paths, and by leaving the h value of the second-best path at each decision point <ref> [1] </ref>. Next, we will present some formal results regarding the algorithm and its performance. Empirical results based on performance comparison experiments will follow. Theorem 2: If DYNORAII, given a problem, terminates claiming a solution, the answer it produces does in fact solve the given problem.
Reference: 2. <author> N. J. Nilsson, </author> <booktitle> Principles of Artificial Intelligence, </booktitle> <publisher> Tioga Press, </publisher> <address> Palo Alto, CA (1980). </address>
Reference-contexts: 1. Introduction A problem solver in AI consists of three main components, namely a global data base, a set of transition rules and a control system <ref> [2] </ref>. The global data base contains statements and data that reflect the state of the world at each point in time. The transition rules operate on the global data base.
Reference: 3. <author> P. H. Winston, </author> <booktitle> Artificial Intelligence, </booktitle> <publisher> Addison Wesley (1984). </publisher>
Reference-contexts: An example state space for the farmer, cat, chicken and grain problem is shown in figure 1. In this problem, a farmer has to take his cat, chicken and grain safely across a river <ref> [3] </ref>. The river is represented by the line across a node in the state space graph. The farmer can neither leave the chicken and the grain nor the cat and the chicken at one end by themselves, as one will eat the other.
Reference: 4. <author> C. L. Liu and J. W. Layland, </author> <title> Scheduling Algorithms for Multiprogramming in a Hard Real-time Environment, </title> <journal> Journal of the Association for Computing Machinery, </journal> <pages> pp. </pages> <month> 46-61 (February, </month> <year> 1973). </year>
Reference-contexts: Ideally, the problem solver seeks to produce a response in less time than that allowed by the deadline, in order to buy time for more complicated decision problems to come. Real-time AI problem solvers differ from conventional real-time systems. Conventional real-time systems <ref> [4, 5, 6] </ref> are mainly concerned with static tasks in which much of the information about the task is known a priori. These systems have mainly addressed the problem of meeting fixed deadlines. <p> Conventional real-time systems [4, 5, 6] are mainly concerned with static tasks in which much of the information about the task is known a priori. These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks <ref> [4, 6, 5, 7, 7] </ref>, interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis [12, 13, 14, 15, 16, 17]. <p> In a dynamic scenario, the world may have changed by the time a plan is generated, making the plan obsolete at the time of execution. These search techniques are also incapable of handling on-line problems. Hard real-time systems <ref> [4, 5, 10, 25] </ref> address the problem of fixed deadlines. These systems are expected to produce the same results (possibly optimal) within a given amount of time, over and over again. Many such systems use hard-wired techniques that are tailored to the task at hand, leading to special-purpose solutions.
Reference: 5. <author> M. R. Garey and D. S. Johnson, </author> <title> Complexity Results for Multiprocessor Scheduling Under Resource Constraints, </title> <journal> SIAM Journal of Computing, </journal> <pages> pp. </pages> <month> 397-411 </month> <year> (1975). </year>
Reference-contexts: Ideally, the problem solver seeks to produce a response in less time than that allowed by the deadline, in order to buy time for more complicated decision problems to come. Real-time AI problem solvers differ from conventional real-time systems. Conventional real-time systems <ref> [4, 5, 6] </ref> are mainly concerned with static tasks in which much of the information about the task is known a priori. These systems have mainly addressed the problem of meeting fixed deadlines. <p> Conventional real-time systems [4, 5, 6] are mainly concerned with static tasks in which much of the information about the task is known a priori. These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks <ref> [4, 6, 5, 7, 7] </ref>, interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis [12, 13, 14, 15, 16, 17]. <p> In a dynamic scenario, the world may have changed by the time a plan is generated, making the plan obsolete at the time of execution. These search techniques are also incapable of handling on-line problems. Hard real-time systems <ref> [4, 5, 10, 25] </ref> address the problem of fixed deadlines. These systems are expected to produce the same results (possibly optimal) within a given amount of time, over and over again. Many such systems use hard-wired techniques that are tailored to the task at hand, leading to special-purpose solutions.
Reference: 6. <author> E. A. Lee and D. G. Messerschmitt, </author> <title> Static Scheduling of Synchronous Data Flow Programs for Digital Signal Processing, </title> <journal> IEEE Transaction on Computers, </journal> <pages> pp. </pages> <month> 24-35 (January, </month> <year> 1987). </year>
Reference-contexts: Ideally, the problem solver seeks to produce a response in less time than that allowed by the deadline, in order to buy time for more complicated decision problems to come. Real-time AI problem solvers differ from conventional real-time systems. Conventional real-time systems <ref> [4, 5, 6] </ref> are mainly concerned with static tasks in which much of the information about the task is known a priori. These systems have mainly addressed the problem of meeting fixed deadlines. <p> Conventional real-time systems [4, 5, 6] are mainly concerned with static tasks in which much of the information about the task is known a priori. These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks <ref> [4, 6, 5, 7, 7] </ref>, interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis [12, 13, 14, 15, 16, 17].
Reference: 7. <author> J. A. Bannister and K. S. Trivedi, </author> <title> Task Allocation in Fault-Tolerant Distributed Systems, </title> <journal> Acta Informatica, </journal> <pages> pp. </pages> <month> 261-281 </month> <year> (1983). </year> <month> - 32 </month> - 
Reference-contexts: Conventional real-time systems [4, 5, 6] are mainly concerned with static tasks in which much of the information about the task is known a priori. These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks <ref> [4, 6, 5, 7, 7] </ref>, interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis [12, 13, 14, 15, 16, 17].
Reference: 8. <author> C. M. Krishna and K. G. Shin, </author> <title> On Scheduling Tasks with a Quick Recovery from Failure, </title> <journal> IEEE Transactions on Computers, </journal> <pages> pp. </pages> <month> 448-455 (May, </month> <year> 1986). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling <ref> [8] </ref>, communication requirements [9, 10, 11] and system design and analysis [12, 13, 14, 15, 16, 17].
Reference: 9. <author> J. F. Kurose, M. Schwartz, and Y. Yemini, </author> <title> Multiple-Access Protocols and Time-Constrained Communication, </title> <booktitle> Computing Survey, </booktitle> <pages> pp. </pages> <month> 43-70 (March, </month> <year> 1984). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements <ref> [9, 10, 11] </ref> and system design and analysis [12, 13, 14, 15, 16, 17].
Reference: 10. <author> W. Zhao and K. Ramamritham, </author> <title> Virtual Time CSMA Protocols for Hard Real-Time Communication, </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. </pages> <month> 938-952 (August, </month> <year> 1987). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements <ref> [9, 10, 11] </ref> and system design and analysis [12, 13, 14, 15, 16, 17]. <p> In a dynamic scenario, the world may have changed by the time a plan is generated, making the plan obsolete at the time of execution. These search techniques are also incapable of handling on-line problems. Hard real-time systems <ref> [4, 5, 10, 25] </ref> address the problem of fixed deadlines. These systems are expected to produce the same results (possibly optimal) within a given amount of time, over and over again. Many such systems use hard-wired techniques that are tailored to the task at hand, leading to special-purpose solutions.
Reference: 11. <author> I. Lee and S. B. Davidson, </author> <title> Adding Time to Synchronous Process Communications, </title> <journal> IEEE Transactions on Computers, </journal> <pages> pp. </pages> <month> 941-948 (August, </month> <year> 1987). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements <ref> [9, 10, 11] </ref> and system design and analysis [12, 13, 14, 15, 16, 17].
Reference: 12. <author> B. Dasarathy, </author> <title> Timing Constraints of Real-Time Systems: Construcsts for Expressing Them, Methods of Validating Them, </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. </pages> <month> 80-86 (January, </month> <year> 1985). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis <ref> [12, 13, 14, 15, 16, 17] </ref>. In addition to the above issues, real-time AI problem solvers aim at handling other constraints in the environment, such as uncertainty and lack of complete knowledge about the environment, dynamicity in the world, bounded validity time of information and other resource constraints.
Reference: 13. <author> V. H. Hasse, </author> <title> Real-Time Behavior of Programs, </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. </pages> <month> 494-501 (September, </month> <year> 1981). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis <ref> [12, 13, 14, 15, 16, 17] </ref>. In addition to the above issues, real-time AI problem solvers aim at handling other constraints in the environment, such as uncertainty and lack of complete knowledge about the environment, dynamicity in the world, bounded validity time of information and other resource constraints.
Reference: 14. <author> D. W. Leinbaugh and M. R. Yamini, </author> <title> Guaranteed Response Times in a Distributed Hard Real-Time Environment, </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. </pages> <month> 1139-1144 (December, </month> <year> 1986). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis <ref> [12, 13, 14, 15, 16, 17] </ref>. In addition to the above issues, real-time AI problem solvers aim at handling other constraints in the environment, such as uncertainty and lack of complete knowledge about the environment, dynamicity in the world, bounded validity time of information and other resource constraints.
Reference: 15. <author> F. Jahanian and A. K. Mok, </author> <title> Safety Analysis of Timing Properties in Real-Time Systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. </pages> <month> 890-904 (September, </month> <year> 1986). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis <ref> [12, 13, 14, 15, 16, 17] </ref>. In addition to the above issues, real-time AI problem solvers aim at handling other constraints in the environment, such as uncertainty and lack of complete knowledge about the environment, dynamicity in the world, bounded validity time of information and other resource constraints.
Reference: 16. <author> J. E. Coolahan and N. Roussopoulus, </author> <title> Timing Requirements for Time-Drivern Systems Using Augmented Petri Nets, </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. </pages> <month> 603-616 (September, </month> <year> 1983). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis <ref> [12, 13, 14, 15, 16, 17] </ref>. In addition to the above issues, real-time AI problem solvers aim at handling other constraints in the environment, such as uncertainty and lack of complete knowledge about the environment, dynamicity in the world, bounded validity time of information and other resource constraints.
Reference: 17. <author> N. G. Leveson and J. L. Stolzy, </author> <title> Safety Analysis Using Petri Nets, </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. </pages> <month> 386-397 (March, </month> <year> 1987). </year>
Reference-contexts: These systems have mainly addressed the problem of meeting fixed deadlines. These conventional systems have focused on issues related to scheduling of tasks [4, 6, 5, 7, 7], interrupt and error handling [8], communication requirements [9, 10, 11] and system design and analysis <ref> [12, 13, 14, 15, 16, 17] </ref>. In addition to the above issues, real-time AI problem solvers aim at handling other constraints in the environment, such as uncertainty and lack of complete knowledge about the environment, dynamicity in the world, bounded validity time of information and other resource constraints.
Reference: 18. <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability, </title> <publisher> W.H.Freeman and Company, </publisher> <address> New York (1979). </address>
Reference-contexts: Deadline situations allow only a certain amount of time within which the system can plan and execute a solution. The deadlines may be fixed, or they may vary from case to case. Finding an optimal solution within arbitrary deadlines is hard and often NP-complete <ref> [18] </ref>. Another class of response-time constraint problems imposes optimality constraints on the total response-time of the system. The total response time is the sum of the time spent on planning a solution and the time it takes to execute the solution. <p> Problem size, n, needs to span a wide range of values, including large n, in order to reveal the asymptotic behavior of the algorithms. The average-case complexity is different from the traditional worst-case time complexity notion <ref> [18] </ref>. Worst-case time complexity of an algorithm represents the largest amount of time taken by the algorithm over all possible instances on problem size n.
Reference: 19. <author> S. Shekhar and S. Dutta, </author> <title> Minimizing Response Times In Real Time Planning And Search, </title> <booktitle> Proceedings of 11th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pp. 238-242 IJCAI, </pages> <year> (1989). </year>
Reference-contexts: The optimal total response-time is not achieved by planning for solutions with optimal execution costs, since planning for such solutions may incur very large planning costs. A trade-off between planning time and solution quality may be needed to optimize total response time <ref> [19] </ref>. - 4 - g Dynamic situations are those in which the world changes slowly during planning. The longer the time it takes to plan a solution, the more obsolete the solution becomes at the time of execution. <p> A greedy approach is used to order the multiple evaluation functions. Negative local benefit from a planning step terminates the search in that direction. The algorithm may be terminated at any time, and it will produce a solution at that time. NORA <ref> [19] </ref> uses hierarchical planning to improve the solution at hand via a set of semantic information for database query planning. Like anytime algorithms, NORA improves the solution quality, given a longer time. The algorithm may be terminated at any time, and it will yield a solution. <p> A distribution graph, representing the number of jobs that were able to meet a given deadline, provides a representation of deadline compliance ability. Response-time minimization, on the other hand, is seldom infeasible <ref> [19] </ref>. We can evaluate real-time problem solvers in terms of their total response time of finding and executing a solution for a sample set of graphs. <p> The best case for RTA* occurs when n= 1 for all possible integral values of n. The best case for DYNORAII occurs when a = 1 for all possible real values of a as shown in <ref> [19] </ref>. The worst case for RTA* occurs at n = 4, from among the values of n used in our experiments. The worst case for DYNORAII occurs at a = 0.1, from among the values of a used in our experiments.
Reference: 20. <author> L. P. Kaelbling, </author> <title> An Architecture for Intelligent Reactive System, Reasoning about actions and plans: </title> <booktitle> Proc. 1986 Workshop, </booktitle> <pages> pp. </pages> <publisher> 395-410 Morgan Kauffman, </publisher> <year> (1987). </year>
Reference-contexts: Events in these situations necessitate major revisions of solutions during planning. A real-time system may use reactive components <ref> [20] </ref> and non-monotonic reasoning [21] to cope with the frequent changes. There is a need to address software engineering issues of specification, design and analysis of real-time AI problem solvers. Issues of specification and analysis are very important in validation and verification of real-time systems. <p> On-line problems have been addressed by a number of algorithms which mainly employ one of two approaches. One of these approaches is the ``reactive behavior'' paradigm as defined by Brooks <ref> [30, 31, 32, 20] </ref>. This paradigm addresses time-constrained problems only as far as assuming that there is no time to plan [31]. Predefined actions, in this approach, are selected via association with the situation at hand.
Reference: 21. <author> R. Reiter, </author> <title> Nonmonotonic Reasoning, In Exploring artificial intelligence (Ed. </title> <editor> H. E. </editor> <publisher> Shrobe and AAAI), Morgan Kauffman, </publisher> <year> (1988). </year>
Reference-contexts: Events in these situations necessitate major revisions of solutions during planning. A real-time system may use reactive components [20] and non-monotonic reasoning <ref> [21] </ref> to cope with the frequent changes. There is a need to address software engineering issues of specification, design and analysis of real-time AI problem solvers. Issues of specification and analysis are very important in validation and verification of real-time systems.
Reference: 22. <author> R. E. Korf, </author> <title> Search: a survey of recent results, Exploring artificial intelligence ( Ed. </title> <editor> H. Shrobe), </editor> <publisher> Morgan Kauffman, </publisher> <year> (1988). </year>
Reference-contexts: Section 6 provides conclusions and a summary of the paper. 2. Survey of Real-Time AI Systems and Our Contributions Simple blind-search algorithms like depth-first search, breadth-first search and depth-first iterative deepening <ref> [22] </ref> are useful for problem solving in small search spaces and in situations where tight deadlines are non-existent. Most real-world applications, however, face very large search spaces and, often times, constraints on response time.
Reference: 23. <author> P. E. Hart, N. J. Nilsson, and B. Raphael, </author> <title> A Formal Basis For the Heuristic Determination of Minimum Cost Paths, </title> <journal> IEEE Transactions on Systems Science and Cybernetics SSC-4(2) pp. </journal> <month> 100-107 </month> <year> (1968). </year>
Reference-contexts: Most real-world applications, however, face very large search spaces and, often times, constraints on response time. Classical search algorithms such as A* <ref> [23] </ref> and IDA* [24], which guarantee optimal solutions in terms of execution times, do not guarantee meeting any constraints on response time. Furthermore, such algorithms, due to the fact that they devise a complete solution plan before executing their first move, are not suitable for operation in dynamic environments.
Reference: 24. <author> R. E. Korf, </author> <title> Depth-First Iterative Deepening : An Optimal Admissible Tree Search, </title> <journal> Artificial Intelligence 27 pp. </journal> <pages> 97-109 North-Holland, </pages> <year> (1985). </year> <month> - 33 </month> - 
Reference-contexts: Most real-world applications, however, face very large search spaces and, often times, constraints on response time. Classical search algorithms such as A* [23] and IDA* <ref> [24] </ref>, which guarantee optimal solutions in terms of execution times, do not guarantee meeting any constraints on response time. Furthermore, such algorithms, due to the fact that they devise a complete solution plan before executing their first move, are not suitable for operation in dynamic environments.
Reference: 25. <author> K. Ramamritham, </author> <title> Channel Characteristics in Local Area Hard Real-Time Systems, </title> <booktitle> Computer Networks and ISDN Systems, </booktitle> <pages> pp. </pages> <month> 3-13 </month> <year> (1987). </year>
Reference-contexts: In a dynamic scenario, the world may have changed by the time a plan is generated, making the plan obsolete at the time of execution. These search techniques are also incapable of handling on-line problems. Hard real-time systems <ref> [4, 5, 10, 25] </ref> address the problem of fixed deadlines. These systems are expected to produce the same results (possibly optimal) within a given amount of time, over and over again. Many such systems use hard-wired techniques that are tailored to the task at hand, leading to special-purpose solutions.
Reference: 26. <author> T. Dean and M. Boddy, </author> <title> An Analysis of Time Dependent Planning, </title> <booktitle> Proc. AAAI, </booktitle> <pages> pp. </pages> <month> 49-54 </month> <year> (1988). </year>
Reference-contexts: Hard real-time systems are the most common type of real-time systems currently being used in applications such as avionics, undersea exploration, and process control. - 6 - Anytime algorithms characterize the requirements of decision procedures capable of meeting deadline constraints on planning time <ref> [26] </ref>. The utility of solutions planned via these algorithms increases over time. These algorithms can be terminated at any time and will return some answer at the time of termination.
Reference: 27. <author> S. Russell and E. H. Wefald, </author> <title> Decision Theoretic Control of Reasoning: General Theory and an Algorithm to Game Playing, </title> <note> Report No. UCB/CSD 88/435, p. </note> <institution> Computer Science Division, </institution> <month> U.C.Berkeley </month> <year> (1988). </year>
Reference-contexts: These algorithms can be terminated at any time and will return some answer at the time of termination. These algorithms lend themselves well to preemptive scheduling characteristic of deadline constraints on response time, and are particularly useful in the case of variable deadlines and on-line problems. The Meta-Greedy algorithm <ref> [27] </ref> is an anytime algorithm. It uses a sequence of evaluation functions to assess the promise of a node during search. A greedy approach is used to order the multiple evaluation functions. Negative local benefit from a planning step terminates the search in that direction. <p> The research in real-time search algorithms has not provided adequate validation of the performance of the proposed algorithms. Determining the next move in board games is often used as a benchmark for the evaluation of algorithms <ref> [34, 27] </ref>. Board games, however, do not share many of the characteristics of real-time applications. For example, the execution cost of a move in a board game is negligible compared to the planning cost. A trivial solution for making the next move can be found with negligible planning.
Reference: 28. <author> E. J. Horvitz, G. F. Cooper, and D. E. Heckerman, </author> <title> Reflection and Action Under Scarce Resources: Theoretical Principles and Empirical Study, </title> <booktitle> Proceedings of 11th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pp. 1121-1127 IJCAI, </pages> <year> (1989). </year>
Reference-contexts: Empirical data from experiments on a query optimization problem are given that are further evidence of the formal results. A framework to address the more general problem of resource constraints may be built around utility theory <ref> [28, 29] </ref>. This model calculates utility and disutility values of certain meta-level actions. It then uses these values to consider whether to continue planning or to proceed with an action. The utility values and probability distributions are learned through experience.
Reference: 29. <author> M. Boddy, </author> <title> Anytime Problem Solving Using Dynamic Programming, </title> <booktitle> Proc. Ninth National Conference on Artificial Intelligence, AAAI, </booktitle> <year> (1991). </year>
Reference-contexts: Empirical data from experiments on a query optimization problem are given that are further evidence of the formal results. A framework to address the more general problem of resource constraints may be built around utility theory <ref> [28, 29] </ref>. This model calculates utility and disutility values of certain meta-level actions. It then uses these values to consider whether to continue planning or to proceed with an action. The utility values and probability distributions are learned through experience.
Reference: 30. <author> R. A. Brooks, </author> <title> A Robust Layered Control System for a Mobile Robot, </title> <journal> IEEE Journal of Robotics and Automation RA-2(1) pp. </journal> <month> 14-23 (March, </month> <year> 1986). </year>
Reference-contexts: On-line problems have been addressed by a number of algorithms which mainly employ one of two approaches. One of these approaches is the ``reactive behavior'' paradigm as defined by Brooks <ref> [30, 31, 32, 20] </ref>. This paradigm addresses time-constrained problems only as far as assuming that there is no time to plan [31]. Predefined actions, in this approach, are selected via association with the situation at hand.
Reference: 31. <author> R. A. Brooks, </author> <title> Planning is Just a Way of Avoiding Figuring Out What to Do Next, </title> <type> Working Paper 303, </type> <institution> Massachusetts Institute of Technology, Artificial Intelligence Laboratory, (Sep-tember, </institution> <year> 1987). </year>
Reference-contexts: On-line problems have been addressed by a number of algorithms which mainly employ one of two approaches. One of these approaches is the ``reactive behavior'' paradigm as defined by Brooks <ref> [30, 31, 32, 20] </ref>. This paradigm addresses time-constrained problems only as far as assuming that there is no time to plan [31]. Predefined actions, in this approach, are selected via association with the situation at hand. <p> One of these approaches is the ``reactive behavior'' paradigm as defined by Brooks [30, 31, 32, 20]. This paradigm addresses time-constrained problems only as far as assuming that there is no time to plan <ref> [31] </ref>. Predefined actions, in this approach, are selected via association with the situation at hand. In this approach, a small amount of computation is performed to realize a coarse configuration of the environment, with very few features.
Reference: 32. <author> D. W. Payton, J. K. Rosenblatt, and D. M. Keirsey, </author> <title> Plan Guided Reaction, </title> <journal> IEEE Transaction on Systems, Man, and Cybernetics 20(6)(November/December 1990). </journal>
Reference-contexts: On-line problems have been addressed by a number of algorithms which mainly employ one of two approaches. One of these approaches is the ``reactive behavior'' paradigm as defined by Brooks <ref> [30, 31, 32, 20] </ref>. This paradigm addresses time-constrained problems only as far as assuming that there is no time to plan [31]. Predefined actions, in this approach, are selected via association with the situation at hand.
Reference: 33. <author> J. McCarthy and P. J. Hayes, </author> <title> Some Philosophic Problems from the Standpoint of Artificial Intelligence, </title> <booktitle> in Machine Intelligence 4, </booktitle> <editor> B. Meltzer and D. Michie (Eds., pp. </editor> <publisher> 463-502 Edin-burgh University Press, </publisher> <year> (1969). </year>
Reference-contexts: However, undertaking this approach is not sufficient in situations in which the system has some time to plan a partial sequence of actions and to come up with a solution of reasonable quality. The other approach to on-line problems is non-monotonic reasoning <ref> [33] </ref>. In this approach, in the presence of incomplete knowledge, and with a lack of time to acquire and reflect upon additional knowledge, the system makes plausible inferences based on a set of assumptions.
Reference: 34. <author> R.E. Korf, </author> <title> RealTime Heuristic Search New Results, </title> <booktitle> Proc. AAAI Conference, </booktitle> <year> (1988). </year>
Reference-contexts: The research in real-time search algorithms has not provided adequate validation of the performance of the proposed algorithms. Determining the next move in board games is often used as a benchmark for the evaluation of algorithms <ref> [34, 27] </ref>. Board games, however, do not share many of the characteristics of real-time applications. For example, the execution cost of a move in a board game is negligible compared to the planning cost. A trivial solution for making the next move can be found with negligible planning.
Reference: 35. <author> C. E. Shannon, </author> <title> Programming a Computer For Playing Chess, </title> <journal> Philosophical Magazine 41 pp. </journal> <month> 256-275 </month> <year> (1950). </year>
Reference-contexts: The complete plan to reach the goal is not worked out, if planning takes a long time. The agent executes a partial plan without exploring all the consequences of this commitment. RTA* uses a variation of the minmax search <ref> [ 35] </ref>, called minmin look-ahead search, for partial planning. The minmin search looks forward from the current state to a fixed-depth horizon and applies the heuristic evaluation function (f=g+h) of A* to the nodes at the depth frontier. The best f value is then sent back to the current node.
Reference: 36. <author> B. Hamidzadeh and S. Shekhar, DYNORA: </author> <title> A Real-Time Planning Algorithm to Meet Response Time Constraints in Dynamic Environments, </title> <booktitle> Proc. Tools for Artificial Intelligence Conference , TAI, </booktitle> <year> (1991). </year>
Reference: 37. <author> B. Bollobas, </author> <title> Random Graphs, </title> <publisher> Academic Press (1985). </publisher>
Reference-contexts: In the case where P=1, the graph is completely connected; namely every node is directly connected to all other nodes with single edges. P=0 signifies a graph with no edges. The choice of P influences the likelihood of the number of solution paths with certain lengths <ref> [37] </ref>. The constraints on the total response time of the planning and execution processes of real-time problem solvers can be specified as follows. Total response times are characterized by the sum of the time it takes to plan a solution and the time it takes to execute that solution.
Reference: 38. <author> A. Aleliunas, R. M. Karp, R. J. Lipton, L. Lovasz, and C. Rackott, </author> <title> Random walks, universal traversal sequences and the complexity of maze problems, </title> <booktitle> 20th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pp. </pages> <month> 218-223 </month> <year> (1979). </year>
Reference-contexts: For example, a pair of path planners can be analyzed to find the path planner producing smaller response times over a large number of graphs. Average-case time complexity is used to represent response-time minimization ability of real-time problem solvers. Average-case time complexity <ref> [38] </ref> of an algorithm represents the dependence of average execution time of the algorithm, on problem size n.
Reference: 39. <author> M. R. Garey and D. S. Johnson, </author> <title> Complexity Results for Multiprocessor Scheduling Under Resource Constraints, </title> <journal> SIAM Journal of Computing, </journal> <pages> pp. </pages> <month> 397-411 </month> <year> (1975). </year>
Reference-contexts: C p SORTS + C e is minimum). It can be shown that the SORTS problem is NP-hard. We will provide a proof by using the method of polynomial reduction <ref> [39] </ref>. Using this method, we first formulate our problem as a decision problem. Such problems only have two possible solutions, either "yes" or "no". We then prove that our problem is NP-complete in the size of an instance by: 1) Showing that our problem P1 is in NP. <p> Next, we select an NP-complete problem that we can reduce to the SORTS problem in polynomial time. The NP-complete problem that we have selected to reduce to the SORTS problem is the "Shortest Weight-Constrained path" (SWCP) problem <ref> [39] </ref>.
Reference: 40. <author> B. Hamidzadeh and S. Shekhar, </author> <title> Can Real-Time Search Algorithms Meet Deadlines?, </title> <booktitle> Proc. AAAI Conference , AAAI, </booktitle> <year> (1992). </year>
Reference-contexts: Specification of Real-time Path Planners In this section, we will specify two real-time problem solvers as search algorithms on a graph. The problem solvers are RTA*[1] and DYNORAII <ref> [40] </ref>. Both of these algorithms work in cycles of partial search followed by execution. The paradigm of partial search followed by execution helps these algorithms to cope with changes in the environment. Both algorithms use an evaluation function to guide the partial search, like A*[23].
References-found: 40

