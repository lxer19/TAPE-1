URL: ftp://theory.lcs.mit.edu/pub/cilk/spbags.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~cilk/abstracts/spbags.html
Root-URL: 
Email: fengmd@iscs.nus.sg  
Title: Efficient Detection of Determinacy Races in Cilk Programs  
Author: Mingdong Feng Charles E. Leiserson 
Address: 10 Lower Kent Ridge Road Republic of Singapore 119260  545 Technology Square Cambridge, MA 02139 USA  
Affiliation: Department of ISCS National University of Singapore  MIT Laboratory for Computer Science  
Abstract: A parallel multithreaded program that is ostensibly deterministic may nevertheless behave nondeterministically due to bugs in the code. These bugs are called determinacy races, and they result when one thread updates a location in shared memory while another thread is concurrently accessing the location. We have implemented a provably efficient determinacy-race detector for Cilk, an algorithmic multithreaded programming language. If a Cilk program run on a given input data set has a determinacy race, our debugging tool, which we call the Nondeterminator, guarantees to detect and localize the race. The core of the Nondeterminator is an asymptotically efficient serial algorithm (inspired by Tarjan's nearly linear-time least-common-ancestors algorithm) for detecting determinacy races in series-parallel directed acyclic graphs. For a Cilk program that runs in T time on one processor and uses v shared-memory locations, the Nondeterminator runs in O(T a(v; v)) time, where a is Tarjan's functional inverse of Ackermann's function, a very slowly growing function which, for all practical purposes, is bounded above by 4. The Nondeterminator uses at most a constant factor more space than does the original program. On a variety of Cilk program benchmarks, the Nondeterminator exhibits a slowdown of less than 12 compared with the serial execution time of the original optimized code, which we contend is an acceptable slowdown for debugging purposes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> On finding lowest common ancestor in trees. </title> <journal> SIAM Journal on Computing, </journal> <volume> 5(1) </volume> <pages> 115-132, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: The attraction of Tarjan's algorithm, as opposed to existing linear-time algorithms and the seminal algorithm given by Aho, Hopcroft, and Ullman <ref> [1] </ref>, is that it operates, in Mellor-Crummey's words [12], on the fly. That is, the least common ancestors can be queried during a simple tree walk without ever requiring the entire tree to be expanded at any time.
Reference: [2] <author> T. R. Allen and D. A. Padua. </author> <title> Debugging Fortran on a shared memory machine. </title> <booktitle> In Proceedings of the 1987 International Conference on Parallel Processing, </booktitle> <pages> pages 721-727, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Static analysis of parallel programs to uncover nondeterminacy has been studied extensively, for example, in [9, 13]. Various systems have been developed for determinacy-race detection that do not allow nested parallelism, as for example <ref> [2] </ref>. We now review related work on determinacy-race detection for programs with nested parallelism.
Reference: [3] <author> A. J. Bernstein. </author> <title> Analysis of programs for parallel processing. </title> <journal> IEEE Transactions on Electronic Computers, </journal> <volume> EC-15(5):757-763, </volume> <month> October </month> <year> 1966. </year>
Reference-contexts: A comparison of the asymptotic time and space requirements of the Nondetermina-tor with work in the literature was presented in Figure 6. Bernstein <ref> [3] </ref> identifies determinacy races as a cause of nondeterministic behavior. Netzer and Miller [15] present a formal model for understanding race conditions in parallel programs, distinguishing determinacy races from atomicity races. They reference several algorithms for atomicity-race detection, but we do not discuss this type of race detection here.
Reference: [4] <author> Robert D. Blumofe, Matteo Frigo, Chrisopher F. Joerg, Charles E. Leiserson, and Keith H. Randall. </author> <title> An analysis of dag-consistent distributed shared-memory algorithms. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <pages> pages 297-308, </pages> <address> Padua, Italy, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: We have started investigating a parallel scheme in which each of several processors executing the program uses the SP-bags algorithm locally, but when a remote child procedure returns, it reconciles its shadow spaces in a manner similar to the BACKER algorithm <ref> [4] </ref> for maintaining dag consistency. Such a result may be mostly of theoretical interest, however, since debugging is usually done in the development phase of a program using small data sets, and thus typically, the performance of the debugger is not a crucial concern.
Reference: [5] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In Proceedings of the Fifth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 207-216, </pages> <address> Santa Barbara, California, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Cilk <ref> [5, 20] </ref> is an algorithmic multithreaded programming language whose threads can concurrently access (read or write) shared memory without blocking. Many Cilk programs are intended to be deterministic, in that a given program produces the same behavior no matter how its threads are scheduled.
Reference: [6] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press and McGraw-Hill Book Company, </publisher> <year> 1990. </year>
Reference-contexts: Like Tarjan's algorithm, the SP-bags algorithm uses an efficient data structure <ref> [6, Chapter 22] </ref> to manage disjoint sets of elements. Figure 6 compares the asymptotic time and space for the SP-bags algorithm with other race-detection algorithms in the literature. The remainder of this paper is organized as follows. Section 2 presents the SP-bags algorithm that underlies the Nondeterminator's runtime system. <p> In addition, every procedure F belongs to its own S-bag. The SP-bags algorithm uses the fast disjoint-set data structure <ref> [6, Chapter 22] </ref> analyzed by Tarjan [21]. The data structure maintains a dynamic collection S of disjoint sets and provides three elementary operations: Make-Set (x): S S [ ffxgg. Union (X ;Y): S S fX ;Y g [ fX [ Yg. The sets X and Y are de stroyed. <p> Such a canonical parse tree is shown in Figure 12 for the Cilk dag in Figure 3. The canonical parse tree satisfies an interesting property with respect to a serial, depth-first execution of the Cilk program. Specifically, an ordinary depth-first tree walk (see <ref> [6, p. 245] </ref>) of the parse tree visits the threads of the computation in the same order as the threads are encountered when the Cilk program is executed in a depth-first (C-like) fashion on a single processor.
Reference: [7] <author> Anne Dinning and Edith Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles & Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 1-10. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: This paper describes a system we call the Nondeterminator to detect deter-minacy races in Cilk programs. Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies <ref> [7] </ref>, data races [12], race conditions [19], or harmful shared-memory accesses [16]. <p> For comparison, the slowdown of an ordinary debugging version (gcc -g) of each benchmark is shown as a light bar. Time Algorithm Thread Per Space creation & access termination English-Hebrew labeling [16] O (p) O (pt) O (vt + min (np; vt p)) Task recycling <ref> [7] </ref> O (t) O (t) O (vt + t 2 ) Offset-span labeling [12] O (p) O (p) O (v + min (np; vp)) SP-bags algorithm O (a (v; v)) O (a (v; v)) O (v) p = maximum depth of nested parallelism t = maximum number of logical concurrent threads <p> To determine whether two threads operate logically in parallel, a comparison of the labels of two threads suffices. Dinning and Schonberg <ref> [7] </ref> improve the performance of the English-Hebrew labeling algorithm by task recycling, but at the cost of failing to detect some determinacy races. Each thread (task) has a unique task identifier, and a version number.
Reference: [8] <author> R. J. Duffin. </author> <title> Topology of series-parallel networks. </title> <journal> Journal of Mathematical Analysis and Applications, </journal> <volume> 10 </volume> <pages> 303-318, </pages> <year> 1965. </year>
Reference-contexts: Also, the worst-case bounds can easily be improved if they are expressed using more detailed parameters than T and v. 3 Series-parallel dags Series-parallel dags [23] are a straightforward extension of the notion of series-parallel graphs <ref> [8, 11, 17] </ref>. In this section, we review basic properties of series-parallel dags and show how a Cilk program execution corresponds to a series-parallel dag. These properties will be used in Section 4 to prove the correctness of the SP-bags algorithm. We first define various relationships among Cilk threads.
Reference: [9] <author> Perry A. Emrath and Davis A. Padua. </author> <title> Automatic detection of nonde-terminacy in parallel programs. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 89-99, </pages> <address> Madison, Wiscon-sin, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: Emrath and Padua <ref> [9] </ref> call a deterministic program internally deterministic if the program execution on the given input exhibits no determinacy race and externally deterministic if the program has determinacy races but its output is deterministic because of the commutative and associative operations performed on the shared locations. <p> If the operators used to augment the accumulated variable are commutativethey are all += or -=, for examplewe would like the concurrent accessing of the updates not to be viewed as races, because the order of accumulation does not affect the external determinacy <ref> [9] </ref> of the computation. That is, the behavior of the program is deterministic, even though different executions may cause some variables to pass through different intermediate states. <p> They reference several algorithms for atomicity-race detection, but we do not discuss this type of race detection here. Static analysis of parallel programs to uncover nondeterminacy has been studied extensively, for example, in <ref> [9, 13] </ref>. Various systems have been developed for determinacy-race detection that do not allow nested parallelism, as for example [2]. We now review related work on determinacy-race detection for programs with nested parallelism.
Reference: [10] <author> Dov Harel and Robert Endre Tarjan. </author> <title> Fast algorithms for finding nearest common ancestors. </title> <journal> SIAM Journal on Computing, </journal> 13(2) 338-355,May 1984. 
Reference-contexts: Such a result may be mostly of theoretical interest, however, since debugging is usually done in the development phase of a program using small data sets, and thus typically, the performance of the debugger is not a crucial concern. Linear-time algorithms for the least-common-ancestors algorithm exist in the literature <ref> [10, 18] </ref>, and it is natural to wonder whether a determinacy-race detector exists that operates in linear time, instead of the almost-linear-time performance of the SP-bags algorithm.
Reference: [11] <author> P. A. MacMahon. </author> <title> The combination of resistances. </title> <booktitle> The Electrician, </booktitle> <month> April 1892. </month>
Reference-contexts: Also, the worst-case bounds can easily be improved if they are expressed using more detailed parameters than T and v. 3 Series-parallel dags Series-parallel dags [23] are a straightforward extension of the notion of series-parallel graphs <ref> [8, 11, 17] </ref>. In this section, we review basic properties of series-parallel dags and show how a Cilk program execution corresponds to a series-parallel dag. These properties will be used in Section 4 to prove the correctness of the SP-bags algorithm. We first define various relationships among Cilk threads.
Reference: [12] <author> John Mellor-Crummey. </author> <title> On-the-fly detection of data races for programs with nested fork-join parallelism. </title> <booktitle> In Proceedings of Supercomputing'91, </booktitle> <pages> pages 24-33. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: This paper describes a system we call the Nondeterminator to detect deter-minacy races in Cilk programs. Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies [7], data races <ref> [12] </ref>, race conditions [19], or harmful shared-memory accesses [16]. <p> Time Algorithm Thread Per Space creation & access termination English-Hebrew labeling [16] O (p) O (pt) O (vt + min (np; vt p)) Task recycling [7] O (t) O (t) O (vt + t 2 ) Offset-span labeling <ref> [12] </ref> O (p) O (p) O (v + min (np; vp)) SP-bags algorithm O (a (v; v)) O (a (v; v)) O (v) p = maximum depth of nested parallelism t = maximum number of logical concurrent threads v = number of shared locations being monitored n = number of threads <p> Dinning and Schonberg give performance data indicating a slowdown of between 3 and 11 to check between 50 and 80 percent of potential determinacy races. Mellor-Crummey <ref> [12] </ref> proposes a scheme called offset-span labeling in programs with nested fork-join parallelism, a model that exhibits only series-parallel dependences. The idea of his scheme is to store a list of labels for each executing thread. <p> The attraction of Tarjan's algorithm, as opposed to existing linear-time algorithms and the seminal algorithm given by Aho, Hopcroft, and Ullman [1], is that it operates, in Mellor-Crummey's words <ref> [12] </ref>, on the fly. That is, the least common ancestors can be queried during a simple tree walk without ever requiring the entire tree to be expanded at any time. We expect that the discovery of a linear-time on-the-fly least-common-ancestors algorithm would have direct application to determinacy-race detection.
Reference: [13] <author> John Mellor-Crummey. </author> <title> Compile-time support for efficient data race detection in shared-memory parallel programs. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 129-139, </pages> <address> San Diego, California, May 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: They reference several algorithms for atomicity-race detection, but we do not discuss this type of race detection here. Static analysis of parallel programs to uncover nondeterminacy has been studied extensively, for example, in <ref> [9, 13] </ref>. Various systems have been developed for determinacy-race detection that do not allow nested parallelism, as for example [2]. We now review related work on determinacy-race detection for programs with nested parallelism.
Reference: [14] <author> Sang Lyul Min and Jong-Deok Choi. </author> <title> An efficient cache-based access anomaly detection scheme. </title> <booktitle> In Proceedings of the Fourth International Conferenceon Architectural Support for Programming Languagesand Operating Systems (ASPLOS), </booktitle> <pages> pages 235-244, </pages> <address> Palo Alto, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: This strategy avoids a problem in the English-Hebrew labeling algorithm whereby the length of a label might grow in proportion to the number of spawn operations encountered in the execution path. Min and Choi <ref> [14] </ref> propose a determinacy-race detection algorithm that piggybacks on a protocol for distributed shared-memory. The idea is that a determinacy race occurs when a processor accesses memory that was previously accessed by another processor.
Reference: [15] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> What are race conditions? ACM Letters on Programming Languages and Systems, </title> <booktitle> 1(1) </booktitle> <pages> 74-88, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies [7], data races [12], race conditions [19], or harmful shared-memory accesses [16]. Netzer and Miller <ref> [15] </ref> clarify different types of races and define a general race or determinacy race to be a race that causes a supposedly deterministic program to behave nondeter-ministically. (They also define a data race or atomicity race to be a race in a nondeterministic program involving nonatomic accesses to critical regions.) We <p> A comparison of the asymptotic time and space requirements of the Nondetermina-tor with work in the literature was presented in Figure 6. Bernstein [3] identifies determinacy races as a cause of nondeterministic behavior. Netzer and Miller <ref> [15] </ref> present a formal model for understanding race conditions in parallel programs, distinguishing determinacy races from atomicity races. They reference several algorithms for atomicity-race detection, but we do not discuss this type of race detection here.
Reference: [16] <author> Itzhak Nudler and Larry Rudolph. </author> <title> Tools for the efficient development of efficient parallel programs. </title> <booktitle> In Proceedings of the First Israeli Conference on Computer Systems Engineering, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: This paper describes a system we call the Nondeterminator to detect deter-minacy races in Cilk programs. Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies [7], data races [12], race conditions [19], or harmful shared-memory accesses <ref> [16] </ref>. <p> For comparison, the slowdown of an ordinary debugging version (gcc -g) of each benchmark is shown as a light bar. Time Algorithm Thread Per Space creation & access termination English-Hebrew labeling <ref> [16] </ref> O (p) O (pt) O (vt + min (np; vt p)) Task recycling [7] O (t) O (t) O (vt + t 2 ) Offset-span labeling [12] O (p) O (p) O (v + min (np; vp)) SP-bags algorithm O (a (v; v)) O (a (v; v)) O (v) p <p> Various systems have been developed for determinacy-race detection that do not allow nested parallelism, as for example [2]. We now review related work on determinacy-race detection for programs with nested parallelism. Nudler and Rudolph <ref> [16] </ref> give an English-Hebrew labeling algorithm that detects determinacy races in programs with series-parallel dependences, but their model also allows messages between threads, which produces a richer and more difficult class of programs to check.
Reference: [17] <author> John Riordan and C. E. Shannon. </author> <title> The number of two-terminal series-parallel networks. </title> <journal> Journal of Mathematics and Physics, </journal> <volume> 21 </volume> <pages> 83-93, </pages> <year> 1942. </year>
Reference-contexts: Also, the worst-case bounds can easily be improved if they are expressed using more detailed parameters than T and v. 3 Series-parallel dags Series-parallel dags [23] are a straightforward extension of the notion of series-parallel graphs <ref> [8, 11, 17] </ref>. In this section, we review basic properties of series-parallel dags and show how a Cilk program execution corresponds to a series-parallel dag. These properties will be used in Section 4 to prove the correctness of the SP-bags algorithm. We first define various relationships among Cilk threads.
Reference: [18] <author> Baruch Schieber and Uzi Vishkin. </author> <title> On finding lowest common ancestors: Simplification and parallelization. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(6) </volume> <pages> 1253-1262, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Such a result may be mostly of theoretical interest, however, since debugging is usually done in the development phase of a program using small data sets, and thus typically, the performance of the debugger is not a crucial concern. Linear-time algorithms for the least-common-ancestors algorithm exist in the literature <ref> [10, 18] </ref>, and it is natural to wonder whether a determinacy-race detector exists that operates in linear time, instead of the almost-linear-time performance of the SP-bags algorithm.
Reference: [19] <author> Guy L. Steele Jr. </author> <title> Making asynchronous parallelism safe for the world. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of ProgrammingLanguages (POPL), </booktitle> <publisher> pages 218-231.ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: This paper describes a system we call the Nondeterminator to detect deter-minacy races in Cilk programs. Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies [7], data races [12], race conditions <ref> [19] </ref>, or harmful shared-memory accesses [16]. <p> This reduced overhead is achieved at the cost of additionally storing the history of accesses of each shared location, however. Moreover, the length of the history is proportional to the depth of nested parallelism. Steele <ref> [19] </ref> proposes a scheme to detect determinacy races in a programming model with asynchronous threads of control. His scheme requires each location to maintain state information recording the sequence of threads that have accessed the location as well as the type of access performed.
Reference: [20] <institution> Supercomputing Technology Group, Massachusetts Institute of Technology, 545 Technology Square, </institution> <address> Cambridge, Massachusetts 02139. </address> <note> Cilk-5.0 (Beta 1) Reference Manual, </note> <month> March </month> <year> 1997. </year> <note> Available on the World Wide Web at URL http://theory.lcs.mit.edu/~cilk. </note>
Reference-contexts: 1 Introduction Cilk <ref> [5, 20] </ref> is an algorithmic multithreaded programming language whose threads can concurrently access (read or write) shared memory without blocking. Many Cilk programs are intended to be deterministic, in that a given program produces the same behavior no matter how its threads are scheduled. <p> The SP-bags algorithm only considers pure Cilk programs that contain spawn and sync statements, but none of Cilk's more advanced constructs that allow nondeterministic programming. (For a complete specification of the Cilk language, see <ref> [20] </ref>.) Section 5 shows how to extend the SP-bags algorithm to detect determinacy races in more general Cilk programs containing atomic accumulations, where a variable can be updated when a spawned procedure returns. <p> Thus, it is not clear what is guaranteed when such a program passes the Nondeterminator test. Nevertheless, turning off the monitoring of certain locations seems to be a useful strategy. The Nondeterminator has been included in the latest Cilk release <ref> [20] </ref>. The Nondeterminator in the release runs about 25 percent slower than the one in this paper. We traded off some performance for usability and simplicity.
Reference: [21] <author> Robert Endre Tarjan. </author> <title> Efficiency of a good but not linear set union algorithm. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 22(2) </volume> <pages> 215-225, </pages> <month> April </month> <year> 1975. </year>
Reference-contexts: for the SP-bags algorithm is an amortized bound. we prove that the running time of the algorithm is O (T a (v; v)) when run on a Cilk program that takes time T on one processor and uses v shared-memory locations, where a is Tarjan's functional inverse of Ackermann's function <ref> [21] </ref>. The SP-bags algorithm is a serial algorithm. It uses the fact that any Cilk program can be executed on one processor in a depth-first (C-like) fashion and conforms to the semantics of the C program that results when all spawn and sync keywords are removed. <p> In addition, every procedure F belongs to its own S-bag. The SP-bags algorithm uses the fast disjoint-set data structure [6, Chapter 22] analyzed by Tarjan <ref> [21] </ref>. The data structure maintains a dynamic collection S of disjoint sets and provides three elementary operations: Make-Set (x): S S [ ffxgg. Union (X ;Y): S S fX ;Y g [ fX [ Yg. The sets X and Y are de stroyed.
Reference: [22] <author> Robert Endre Tarjan. </author> <title> Applications of path compression on balanced trees. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 26(4) </volume> <pages> 690-715, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: x read and printed by thread e 3 can differ depending on how the instructions in the two instances F 1 and F 2 of the foo () procedure are scheduled. rithm for determinacy-race detection that we call the SP-bags algorithm, which was inspired by Tarjan's nearly linear-time least-common-ancestors algorithm <ref> [22] </ref>. Like Tarjan's algorithm, the SP-bags algorithm uses an efficient data structure [6, Chapter 22] to manage disjoint sets of elements. Figure 6 compares the asymptotic time and space for the SP-bags algorithm with other race-detection algorithms in the literature. The remainder of this paper is organized as follows. <p> We first review the disjoint-set data structure used in the algorithm, and then we present the algorithm itself, which is inspired by Tarjan's least-common-ancestors algorithm <ref> [22] </ref>. Finally, 0 1 2 3 4 5 6 7 8 9 10 11 12 knapsack multisort fft heat hutch sparsky lu mmult the Nondeterminator. The slowdown, shown as a dark bar, is the ratio of the Nondeterminator runtime to the original optimized runtime (gcc -O3) of the benchmark.
Reference: [23] <author> Jacobo Valdes. </author> <title> Parsing Flowcharts and Series-Parallel Graphs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> December </month> <year> 1978. </year> <month> STAN-CS-78-682. </month>
Reference-contexts: In practice, it is probably not worthwhile to implement the garbage collection, and the Nondeterminator does not implement it. Also, the worst-case bounds can easily be improved if they are expressed using more detailed parameters than T and v. 3 Series-parallel dags Series-parallel dags <ref> [23] </ref> are a straightforward extension of the notion of series-parallel graphs [8, 11, 17]. In this section, we review basic properties of series-parallel dags and show how a Cilk program execution corresponds to a series-parallel dag.
References-found: 23

