URL: http://www.cs.washington.edu/homes/amir/CodeWeb/tech1.ps
Refering-URL: http://www.cs.washington.edu/homes/amir/CodeWeb/tech1-abs.html
Root-URL: 
Email: famir,notking@cs.washington.edu  
Title: Using Relaxed Class Diagram Intersection to Ease Object-Oriented Library Selection  
Author: Amir Michail and David Notkin 
Web: http://www.cs.washington.edu/homes/amir/CodeWeb  
Address: Box 352350 Seattle, WA 98195-2350  
Affiliation: Dept. of Computer Science and Engineering University of Washington,  
Pubnum: Technical Report UW-CSE-98-05-02  
Abstract: In this paper, we present a tool-based approach in which a complete collection of candidate libraries are simultaneously compared and contrasted. Specifically, we (1) extract a relaxed class diagram from each library, capturing key structures and also standardizing class and member names, (2) compute a relaxed intersection for each subset of the relaxed class diagrams to capture essential similarities and differences among the libraries, and (3) compute a lattice over the collection of relaxed intersections. By browsing this lattice, developers can begin assessing the libraries in combination immediately rather than after analyzing each library independently. Our approach can facilitate the assessment process by (1) guiding the developer towards important functional and non-functional properties; (2) helping the developer compare and contrast these properties across libraries; and (3) providing access to the relevant source code in each library for further inspection. All aspects of our approach are supported by CodeWeb, a tool we have built for assessing C++ and Java libraries.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. J. Biggerstaff. </author> <title> Design Recovery for Mainte nance and Reuse. </title> <journal> Computer, </journal> <volume> 22(7) </volume> <pages> 36-49, </pages> <year> 1989. </year>
Reference-contexts: Either way, the developer manually inspects each library, reads the documentation, examines the architecture, considers subjective scenarios, and other available information. Tool support for candidate selection has been lacking. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc. <ref> [1, 6, 8, 11] </ref>, we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library.
Reference: [2] <author> C. Carpineto and G. Romano. </author> <title> A Lattice Conceptual Clustering System and Its Application to Browsing Retrieval. </title> <journal> Machine Learning, </journal> <volume> 24(2) </volume> <pages> 95-122, </pages> <year> 1996. </year>
Reference-contexts: We then place the relaxed intersections in a lattice which users can browse to identify similarities and differences among any subset of libraries in X <ref> [2] </ref>.
Reference: [3] <author> P. Chen, R. Hennicker, and M. Jarke. </author> <title> On the Re trieval of Reusable Software Components. </title> <booktitle> In 2nd International Workshop on Software Reusability), </booktitle> <pages> pages 99-108. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Selecting from among a set of candidates is an important step in software reuse [7]. There are a number of approaches for selecting from among relatively small reuse candidates such as individual methods or classes <ref> [3, 4, 9, 12] </ref>. These approaches are generally query-based, which usually works well in part because there are often a reasonably large number of candidates. <p> In contrast, there are numerous reuse tools that help a developer select a fine-grained component (such as a function or class) in a particular library. These include tools that use free-text indexing [4], facets [9], signature matching [12], and formal specifications <ref> [3] </ref>.
Reference: [4] <author> W. B. Frakes and B. A. Nejmeh. </author> <title> Software Reuse through Information Retrieval. </title> <booktitle> In 20th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 530-535. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Selecting from among a set of candidates is an important step in software reuse [7]. There are a number of approaches for selecting from among relatively small reuse candidates such as individual methods or classes <ref> [3, 4, 9, 12] </ref>. These approaches are generally query-based, which usually works well in part because there are often a reasonably large number of candidates. <p> With existing tools, the user must manually integrate the knowledge learned about each library. In contrast, there are numerous reuse tools that help a developer select a fine-grained component (such as a function or class) in a particular library. These include tools that use free-text indexing <ref> [4] </ref>, facets [9], signature matching [12], and formal specifications [3].
Reference: [5] <author> R. Kazman, L. Bass, G. Abowd, and M. Webb. SAAM: </author> <title> A Method for Analyzing the Properties of Software Architectures. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 81-90. </pages> <publisher> IEEE, </publisher> <year> 1994. </year>
Reference-contexts: This may take the form of informal tips for selecting frameworks [10] or a complete analysis method, such as SAAM <ref> [5] </ref>. Either way, the developer manually inspects each library, reads the documentation, examines the architecture, considers subjective scenarios, and other available information. Tool support for candidate selection has been lacking.
Reference: [6] <author> R. Kazman and S. J. Carriere. </author> <title> View Extraction and View Fusion in Architectural Understanding. </title> <booktitle> In 5th International Conference on Software Reuse. IEEE, </booktitle> <year> 1998. </year>
Reference-contexts: Either way, the developer manually inspects each library, reads the documentation, examines the architecture, considers subjective scenarios, and other available information. Tool support for candidate selection has been lacking. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc. <ref> [1, 6, 8, 11] </ref>, we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library.
Reference: [7] <author> C. W. Krueger. </author> <title> Software Reuse. </title> <journal> ACM Comput ing Surveys, </journal> <volume> 24(2) </volume> <pages> 131-183, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Selecting from among a set of candidates is an important step in software reuse <ref> [7] </ref>. There are a number of approaches for selecting from among relatively small reuse candidates such as individual methods or classes [3, 4, 9, 12]. These approaches are generally query-based, which usually works well in part because there are often a reasonably large number of candidates.
Reference: [8] <author> G. C. Murphy, D. Notkin, and K. Sullivan. </author> <title> Soft ware Reflexion Models: Bridging the Gap between Source and High-Level Models. </title> <booktitle> In 3rd ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 18-28, </pages> <year> 1995. </year>
Reference-contexts: Either way, the developer manually inspects each library, reads the documentation, examines the architecture, considers subjective scenarios, and other available information. Tool support for candidate selection has been lacking. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc. <ref> [1, 6, 8, 11] </ref>, we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library.
Reference: [9] <author> R. Prieto-Diaz and P. Freeman. </author> <title> Classifying Soft ware for Reusability. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 6-16, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Selecting from among a set of candidates is an important step in software reuse [7]. There are a number of approaches for selecting from among relatively small reuse candidates such as individual methods or classes <ref> [3, 4, 9, 12] </ref>. These approaches are generally query-based, which usually works well in part because there are often a reasonably large number of candidates. <p> With existing tools, the user must manually integrate the knowledge learned about each library. In contrast, there are numerous reuse tools that help a developer select a fine-grained component (such as a function or class) in a particular library. These include tools that use free-text indexing [4], facets <ref> [9] </ref>, signature matching [12], and formal specifications [3].
Reference: [10] <author> S. Sparks, K. Benner, and C. Faris. </author> <title> Managing Object-Oriented Framework Reuse. </title> <journal> Computer, </journal> <volume> 29(9) </volume> <pages> 52-61, </pages> <year> 1996. </year>
Reference-contexts: These approaches are generally query-based, which usually works well in part because there are often a reasonably large number of candidates. But selecting among larger candidates | such as selecting a thread library or a user-interface framework| is difficult and potentially very expensive <ref> [10] </ref>. 1 Indeed, Sparks, Benner and Faris give this advice for framework selection: "Budget adequately to support frameworks. <p> Expect the evaluation and selection of a framework to take up to six staff-months per new framework." <ref> [10, p. 54] </ref> The selection among larger candidates introduces a different set of problems than those for small reuse candidates. First, non-functional properties | extensibility, flexibility, understandability, testability, etc. | are increasingly important. <p> Section 7 summarizes the work, concluding with a number of open questions. 2 Related Work The current state of the art in selecting among library candidates relies on qualitative assessment. This may take the form of informal tips for selecting frameworks <ref> [10] </ref> or a complete analysis method, such as SAAM [5]. Either way, the developer manually inspects each library, reads the documentation, examines the architecture, considers subjective scenarios, and other available information. Tool support for candidate selection has been lacking.
Reference: [11] <author> A. S. Yeh, D. R. Harris, and M. P. Chase. </author> <title> Manip ulating Recovered Software Architecture Views. </title> <booktitle> In Proceedings of the International Conference on Software Engineering, </booktitle> <pages> pages 184-194, </pages> <year> 1997. </year>
Reference-contexts: Either way, the developer manually inspects each library, reads the documentation, examines the architecture, considers subjective scenarios, and other available information. Tool support for candidate selection has been lacking. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc. <ref> [1, 6, 8, 11] </ref>, we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library.
Reference: [12] <author> A. M. Zaremski and J. M. Wing. </author> <title> Signature Matching: A Tool for Using Software Libraries. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 4(2) </volume> <pages> 146-170, </pages> <year> 1995. </year> <month> 11 </month>
Reference-contexts: 1 Introduction Selecting from among a set of candidates is an important step in software reuse [7]. There are a number of approaches for selecting from among relatively small reuse candidates such as individual methods or classes <ref> [3, 4, 9, 12] </ref>. These approaches are generally query-based, which usually works well in part because there are often a reasonably large number of candidates. <p> In contrast, there are numerous reuse tools that help a developer select a fine-grained component (such as a function or class) in a particular library. These include tools that use free-text indexing [4], facets [9], signature matching <ref> [12] </ref>, and formal specifications [3].
References-found: 12

