URL: ftp://theory.lcs.mit.edu/pub/tds/TM-499.ps.Z
Refering-URL: http://theory.lcs.mit.edu/tds/reflist.html
Root-URL: 
Title: A Comparison of Simulation Techniques and Algebraic Techniques for Verifying Concurrent Systems  
Author: Nancy Lynch and Roberto Segala 
Affiliation: MIT- Laboratory for Computer Science  
Abstract: Simulation-based assertional techniques and process algebraic techniques are two of the major methods that have been proposed for the verification of concurrent and distributed systems. It is shown how each of these techniques can be applied to the task of verifying systems described as input/output automata; both safety and liveness properties are considered. A small but typical circuit is verified in both of these ways, first using forward simulations, an execution correspondence lemma, and a simple fairness argument, and second using deductions within the process algebra DIOA for I/O automata. An extended evaluation and comparison of the two methods is given.
Abstract-found: 1
Intro-found: 1
Reference: [Bae90] <author> J.C.M. Baeten. </author> <title> Applications of Process Algebra. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 18, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Indeed, the two methods have been developed by largely disjoint research communities, using different semantic models. The literature contains many examples of proofs using the two methods: some typical examples of simulation proofs appear in [LT87, SLL93a, SLL93b], while examples of algebraic proofs appear in <ref> [Bae90, Jos92, OP92] </ref>. In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. <p> Moreover, the pure DIOA calculus does not provide tools to deal with structured states. A standard technique to deal with structured states within process algebras makes use of parameterized process variables <ref> [Hoa85, Mil89, Bae90] </ref>. <p> counter can be represented by a process variable X parameterized over a natural number n in the following way: def X n = down : X n1 + up : X n+1 if n &gt; 0: Such a technique is generally used when the size of a system is large <ref> [Bae90, OP92] </ref> since a specification would become unreadable otherwise. Our example, although small, makes use of parameters. <p> Our proof steps were essentially repeated applications of the expansion axiom followed by some simplifications based on the given specification. This heuristic is generally applicable when dealing with (finite state) circuit descriptions. It is also applied in [Jos92, Seg92, OP92] and in several of the examples of <ref> [Bae90] </ref>. In these cases, algebraic manipulators like those of [MV91, Lin91] can be used. <p> The assertional methods based on I/O automata have been successfully used for the verification of very complex systems [LT87, WLL88, LP92, SLL93b] while the algebraic techniques of process algebras [Mil89] have generally been used for relatively small examples <ref> [Bae90, Jos92] </ref>. We have verified the correctness of the implementation of a Muller C element taken from [Jos92] both in the assertional framework and in the process algebraic framework. The algebraic proof is based on DIOA [Seg92], a process algebra for I/O automata.
Reference: [DH84] <author> R. De Nicola and M. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference-contexts: Note that the arguments of this subsection only hold for fairness sensitive semantics such as the semantics of I/O automata. If the semantics is not based on a fairness sensitive relation, then the problems of this subsection disappear. Examples of non fairness sensitive relations are bisimulation [Mil89] and testing <ref> [DH84, Hen88] </ref>. 6.3 Representation of Automata The two different proof methods typically use very different ways of representing automata, each best suited for carrying out the corresponding type of proof.
Reference: [DS92] <author> R. De Nicola and R. Segala. </author> <title> A process algebraic view of I/O automata. </title> <type> Technical Report SI-92/05, </type> <institution> Dipartimento di Scienze dell'Informazione, Universita degli studi di Roma La Sapienza, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: This framework has been used extensively for the verification of complex algorithms and pieces of distributed systems [WLL88, LS92, LP92, SLL93b], and has already been given a process algebraic characterization <ref> [Vaa91, Seg92, DS92] </ref>. We show how each of these techniques can be applied to the common task of verifying both safety and liveness properties of systems described as I/O automata. <p> The above mapping is also a backward simulation from X 0 to X, therefore also backward simulation is incomparable with DIOA deduction. All the examples above also work for the simple trace preorder. The reader is referred to <ref> [DS92] </ref> for its axiomatization. 6.2 Treatment of Fairness In the given example, a separate argument about fairness is made in the simulation proof, whereas no such argument is needed in the algebraic proof.
Reference: [GSSL93] <author> R. Gawlick, R. Segala, J.F. Stgaard-Andersen, and N. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <type> Technical Report MIT/LCS/TR-587, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: The two proofs proceed very differently. First, the simulation proof uses a forward simulation [LV91] from the implementation to the specification, then invokes an execution correspondence lemma <ref> [GSSL93] </ref> to obtain a correspondence between executions of the implementation and the specification. Then a simple argument about fairness is made, based on the correspondence between executions; this fairness argument uses the convenient notion of a forcing condition for an I/O automaton fairness class. <p> However, since we would like to base our proof of fair trace inclusion on our proof of trace inclusion, it is useful to have a stronger consequence of the existence of a forward simulation. This lemma is proved in <ref> [GSSL93] </ref>. 2 2 In [GSSL93], it is also shown that a similar lemma holds for other types of simulation relations such as backward simulations. 11 Lemma 4.3 (Execution correspondence) Let f be a forward simulation from an I/O au-tomaton A to an I/O automaton B. <p> However, since we would like to base our proof of fair trace inclusion on our proof of trace inclusion, it is useful to have a stronger consequence of the existence of a forward simulation. This lemma is proved in <ref> [GSSL93] </ref>. 2 2 In [GSSL93], it is also shown that a similar lemma holds for other types of simulation relations such as backward simulations. 11 Lemma 4.3 (Execution correspondence) Let f be a forward simulation from an I/O au-tomaton A to an I/O automaton B.
Reference: [Hen88] <author> M. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Note that the arguments of this subsection only hold for fairness sensitive semantics such as the semantics of I/O automata. If the semantics is not based on a fairness sensitive relation, then the problems of this subsection disappear. Examples of non fairness sensitive relations are bisimulation [Mil89] and testing <ref> [DH84, Hen88] </ref>. 6.3 Representation of Automata The two different proof methods typically use very different ways of representing automata, each best suited for carrying out the corresponding type of proof.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1985. </year>
Reference-contexts: Moreover, the pure DIOA calculus does not provide tools to deal with structured states. A standard technique to deal with structured states within process algebras makes use of parameterized process variables <ref> [Hoa85, Mil89, Bae90] </ref>.
Reference: [Jos92] <author> M.B. Josephs. </author> <title> Receptive process theory. </title> <journal> Acta Informatica, </journal> <volume> 29 </volume> <pages> 17-31, </pages> <year> 1992. </year>
Reference-contexts: Indeed, the two methods have been developed by largely disjoint research communities, using different semantic models. The literature contains many examples of proofs using the two methods: some typical examples of simulation proofs appear in [LT87, SLL93a, SLL93b], while examples of algebraic proofs appear in <ref> [Bae90, Jos92, OP92] </ref>. In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. <p> We then use each technique fl Supported by NSF grant CCR-89-15206, by DARPA contracts N00014-89-J-1988 and N00014-92-J-4033, and by ONR contract N00014-91-J-1046. 1 to verify a small but typical delay insensitive circuit taken from <ref> [Jos92] </ref>: a Muller C element [MB59] implemented in terms of a majority element and a wire. Both the implementation and the specification are described as I/O automata, and the verification consists of showing that the fair preorder relation (i.e., fair trace inclusion) holds between the implementation and the specification automata. <p> This problem is that of verifying the correctness of a particular circuit implementation. We begin with an informal description, then present the formal version in several pieces. 3.1 Informal Description The example consists of a simple delay insensitive circuit, taken from <ref> [Jos92] </ref>, called the Muller C element [MB59]. Its interface is shown in Figure 1. A Muller C element has two input ports a; b and one output port c. <p> Our proof steps were essentially repeated applications of the expansion axiom followed by some simplifications based on the given specification. This heuristic is generally applicable when dealing with (finite state) circuit descriptions. It is also applied in <ref> [Jos92, Seg92, OP92] </ref> and in several of the examples of [Bae90]. In these cases, algebraic manipulators like those of [MV91, Lin91] can be used. <p> The assertional methods based on I/O automata have been successfully used for the verification of very complex systems [LT87, WLL88, LP92, SLL93b] while the algebraic techniques of process algebras [Mil89] have generally been used for relatively small examples <ref> [Bae90, Jos92] </ref>. We have verified the correctness of the implementation of a Muller C element taken from [Jos92] both in the assertional framework and in the process algebraic framework. The algebraic proof is based on DIOA [Seg92], a process algebra for I/O automata. <p> We have verified the correctness of the implementation of a Muller C element taken from <ref> [Jos92] </ref> both in the assertional framework and in the process algebraic framework. The algebraic proof is based on DIOA [Seg92], a process algebra for I/O automata.
Reference: [Lin91] <author> H. Lin. PAM: </author> <title> A Process Algebra Manipulator. </title> <booktitle> In Larsen and Skou [LS91], </booktitle> <pages> pages 136-146. </pages>
Reference-contexts: This heuristic is generally applicable when dealing with (finite state) circuit descriptions. It is also applied in [Jos92, Seg92, OP92] and in several of the examples of [Bae90]. In these cases, algebraic manipulators like those of <ref> [MV91, Lin91] </ref> can be used.
Reference: [LP92] <author> N. Lynch and B. Patt-Shamir. </author> <title> Distributed Algorithms. </title> <booktitle> Fall 1992 Lecture Notes for 6.852. MIT/LCS/RSS 16, </booktitle> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. This framework has been used extensively for the verification of complex algorithms and pieces of distributed systems <ref> [WLL88, LS92, LP92, SLL93b] </ref>, and has already been given a process algebraic characterization [Vaa91, Seg92, DS92]. We show how each of these techniques can be applied to the common task of verifying both safety and liveness properties of systems described as I/O automata. <p> machine, the remarks at the end of Section 6.3 show that some form of simulation has to be defined even for an algebraic proof, therefore the difficulties involved in the mechanization of simulation and algebraic proofs are comparable. 6.5 Additional Benefits Obtained from the Proof Experience with large simulation-based verifications <ref> [WLL88, LP92, SLL93b] </ref> has shown that the formal description of the simulation relation in a simulation proof constitutes an important 36 piece of documentation of the key ideas of the implementation, in much the same way that an invariant assertion does; invariants and simulations typically express the key intuitions that make <p> The assertional methods based on I/O automata have been successfully used for the verification of very complex systems <ref> [LT87, WLL88, LP92, SLL93b] </ref> while the algebraic techniques of process algebras [Mil89] have generally been used for relatively small examples [Bae90, Jos92]. We have verified the correctness of the implementation of a Muller C element taken from [Jos92] both in the assertional framework and in the process algebraic framework.
Reference: [LS91] <editor> K.G. Larsen and A. Skou, editors. </editor> <booktitle> Proceedings of the third international workshop on Computer Aided Verification, volume 575 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [LS92] <author> N. Lynch and I. Saias. </author> <title> Distributed Algorithms. </title> <booktitle> Fall 1990 Lecture Notes for 6.852. MIT/LCS/RSS 16, </booktitle> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. This framework has been used extensively for the verification of complex algorithms and pieces of distributed systems <ref> [WLL88, LS92, LP92, SLL93b] </ref>, and has already been given a process algebraic characterization [Vaa91, Seg92, DS92]. We show how each of these techniques can be applied to the common task of verifying both safety and liveness properties of systems described as I/O automata. <p> The generality of our approach to fairness in the simulation proof also remains to be considered; however, in this case there is already good evidence that this approach works well in practice <ref> [LS92, SLL93b] </ref>.
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. 38 </note>
Reference-contexts: Indeed, the two methods have been developed by largely disjoint research communities, using different semantic models. The literature contains many examples of proofs using the two methods: some typical examples of simulation proofs appear in <ref> [LT87, SLL93a, SLL93b] </ref>, while examples of algebraic proofs appear in [Bae90, Jos92, OP92]. In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. <p> In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle <ref> [LT87] </ref>. This framework has been used extensively for the verification of complex algorithms and pieces of distributed systems [WLL88, LS92, LP92, SLL93b], and has already been given a process algebraic characterization [Vaa91, Seg92, DS92]. <p> For a complete account, we refer the reader to <ref> [LT87] </ref>. Definition 2.1 (Notation for sequences) Given an alphabet A, let A fl be the set of finite length sequences made of elements of A and let A ! be the set of infinite length sequences made of elements of A. <p> Each of the two methods, however, has its own characteristic language for describing system components. In this section, we represent each element of Section 3.2 using a variant of the precondition-effect language of <ref> [LT87] </ref> that is suitable for describing forcing I/O automata. We also relate the new specifications to the neutral ones. In our precondition-effect language a forcing I/O automaton is described by means of its action signature, its states, its initial states, its transition relation, and its classes with forcing sets. <p> The assertional methods based on I/O automata have been successfully used for the verification of very complex systems <ref> [LT87, WLL88, LP92, SLL93b] </ref> while the algebraic techniques of process algebras [Mil89] have generally been used for relatively small examples [Bae90, Jos92]. We have verified the correctness of the implementation of a Muller C element taken from [Jos92] both in the assertional framework and in the process algebraic framework.
Reference: [LV91] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings of the REX Workshop "Real-Time: Theory in Practice", volume 600 of Lecture Notes in Computer Science, </booktitle> <pages> pages 397-446. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Both the implementation and the specification are described as I/O automata, and the verification consists of showing that the fair preorder relation (i.e., fair trace inclusion) holds between the implementation and the specification automata. The two proofs proceed very differently. First, the simulation proof uses a forward simulation <ref> [LV91] </ref> from the implementation to the specification, then invokes an execution correspondence lemma [GSSL93] to obtain a correspondence between executions of the implementation and the specification. <p> Below, we define forward simulations, state the Execution Correspondence Lemma, and give the needed definitions are results for forcing I/O automata. 4.1.1 Forward Simulations and the Execution Correspondence Lemma The notion of forward simulation that we use is taken from the comprehensive paper by Lynch and Vaandrager <ref> [LV91] </ref>. Definition 4.1 (Forward simulation) A forward simulation from an I/O automaton A to an I/O automaton B is a relation f over states (A) and states (B) that satisfies: 1. If q 2 start (A) then f [q] " start (B) 6= ;. 2. <p> Definition 5.5 (Finite internal nondeterminism) An I/O automaton A has finite inter <p>- nal nondeterminism (FIN) if 8 h2acts fl (A) fq j 9 q 0 2start (A) q 0 h =) qg is finite. The above definition of FIN is weaker than the definition given in <ref> [LV91] </ref>. The definition of [LV91] requires, for every trace h, the set of reachable states with h to be finite. <p> The above definition of FIN is weaker than the definition given in <ref> [LV91] </ref>. The definition of [LV91] requires, for every trace h, the set of reachable states with h to be finite. <p> A forward simulation between two processes A and B exists only if B does not decide before A. Y can be proved to implement X by using a different simulation technique based on a notion of backward simulation <ref> [LV91] </ref>. However, there are also examples that can be proved using DIOA deductions but not by backward simulations. One example is X = a : c : X + b : Z Z = c : X def = c : Y where a; b and c are output actions.
Reference: [MB59] <author> D.E. Muller and W.S. Bartky. </author> <title> A theory of asynchronous circuits. </title> <journal> Annals of the Computation Laboratory of Harvard University. </journal> <volume> Volume XXIX: </volume> <booktitle> Proceedings of an International Symposium on the Theory of Switching, Part I, </booktitle> <pages> pages 204-243, </pages> <year> 1959. </year>
Reference-contexts: We then use each technique fl Supported by NSF grant CCR-89-15206, by DARPA contracts N00014-89-J-1988 and N00014-92-J-4033, and by ONR contract N00014-91-J-1046. 1 to verify a small but typical delay insensitive circuit taken from [Jos92]: a Muller C element <ref> [MB59] </ref> implemented in terms of a majority element and a wire. Both the implementation and the specification are described as I/O automata, and the verification consists of showing that the fair preorder relation (i.e., fair trace inclusion) holds between the implementation and the specification automata. <p> This problem is that of verifying the correctness of a particular circuit implementation. We begin with an informal description, then present the formal version in several pieces. 3.1 Informal Description The example consists of a simple delay insensitive circuit, taken from [Jos92], called the Muller C element <ref> [MB59] </ref>. Its interface is shown in Figure 1. A Muller C element has two input ports a; b and one output port c. <p> Examples of systems satisfying the condition of Proposition 5.8 are the monotone I/O automata of [Sta90], which can model a large class of dataflow networks, and the semi-modular, speed-independent circuits of <ref> [MB59] </ref>. Our problem is based on delay insensitive circuits. 5.1.2 The Calculus of Demonic I/O Automata The calculus of Demonic I/O Automata (DIOA) is a process algebra for I/O automata [Seg92]. Each I/O automaton is an expression which is obtained by applying operators to basic automata.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1989. </year>
Reference-contexts: This assumption is necessary to model some of the operators. Table 1 contains all the operators of DIOA and Table 2 contains their operational semantics in terms of transition systems. The operators of DIOA recall the standard operators of CCS <ref> [Mil89] </ref>; however they are different in the sense that they also guarantee input enabling by moving an automaton to the state whenever some unexpected input is provided. The expression nil models a quiescent automaton that moves to for any input. <p> Note that the arguments of this subsection only hold for fairness sensitive semantics such as the semantics of I/O automata. If the semantics is not based on a fairness sensitive relation, then the problems of this subsection disappear. Examples of non fairness sensitive relations are bisimulation <ref> [Mil89] </ref> and testing [DH84, Hen88]. 6.3 Representation of Automata The two different proof methods typically use very different ways of representing automata, each best suited for carrying out the corresponding type of proof. <p> Moreover, the pure DIOA calculus does not provide tools to deal with structured states. A standard technique to deal with structured states within process algebras makes use of parameterized process variables <ref> [Hoa85, Mil89, Bae90] </ref>. <p> The assertional methods based on I/O automata have been successfully used for the verification of very complex systems [LT87, WLL88, LP92, SLL93b] while the algebraic techniques of process algebras <ref> [Mil89] </ref> have generally been used for relatively small examples [Bae90, Jos92]. We have verified the correctness of the implementation of a Muller C element taken from [Jos92] both in the assertional framework and in the process algebraic framework.
Reference: [MV91] <author> S. Mauw and G.J. Veltink. </author> <title> A proof assistant for PSF. </title> <booktitle> In Larsen and Skou [LS91], </booktitle> <pages> pages 158-168. </pages>
Reference-contexts: This heuristic is generally applicable when dealing with (finite state) circuit descriptions. It is also applied in [Jos92, Seg92, OP92] and in several of the examples of [Bae90]. In these cases, algebraic manipulators like those of <ref> [MV91, Lin91] </ref> can be used.
Reference: [Nip89] <author> T. Nipkow. </author> <title> Formal verification of data type refinement theory and practice. </title> <editor> In J.W. de Bakker, , W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings of the REX Workshop "Stepwise Refinement of Distributed Systems", volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 561-591. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: As described in [SGG + 93], the Larch prover has been successfully used for this purpose. Also the theorem prover Isabelle was used for the same purpose in <ref> [Nip89] </ref>. The work on mechanical simulation-based verifications is still under development, and [Nip89, SGG + 93] are just the first attempts at solving the problem. It seems unlikely that an automatic prover will be of much help in defining the simulation relation in a simulation proof. <p> As described in [SGG + 93], the Larch prover has been successfully used for this purpose. Also the theorem prover Isabelle was used for the same purpose in [Nip89]. The work on mechanical simulation-based verifications is still under development, and <ref> [Nip89, SGG + 93] </ref> are just the first attempts at solving the problem. It seems unlikely that an automatic prover will be of much help in defining the simulation relation in a simulation proof.
Reference: [OP92] <author> F. Orava and J. Parrow. </author> <title> An algebraic verification of a mobile network. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4 </volume> <pages> 497-593, </pages> <year> 1992. </year>
Reference-contexts: Indeed, the two methods have been developed by largely disjoint research communities, using different semantic models. The literature contains many examples of proofs using the two methods: some typical examples of simulation proofs appear in [LT87, SLL93a, SLL93b], while examples of algebraic proofs appear in <ref> [Bae90, Jos92, OP92] </ref>. In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. <p> counter can be represented by a process variable X parameterized over a natural number n in the following way: def X n = down : X n1 + up : X n+1 if n &gt; 0: Such a technique is generally used when the size of a system is large <ref> [Bae90, OP92] </ref> since a specification would become unreadable otherwise. Our example, although small, makes use of parameters. <p> Our proof steps were essentially repeated applications of the expansion axiom followed by some simplifications based on the given specification. This heuristic is generally applicable when dealing with (finite state) circuit descriptions. It is also applied in <ref> [Jos92, Seg92, OP92] </ref> and in several of the examples of [Bae90]. In these cases, algebraic manipulators like those of [MV91, Lin91] can be used.
Reference: [Seg92] <author> R. Segala. </author> <title> A process algebraic view of I/O automata. </title> <type> Technical Memo MIT/LCS/TR-557, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA 02139, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: This framework has been used extensively for the verification of complex algorithms and pieces of distributed systems [WLL88, LS92, LP92, SLL93b], and has already been given a process algebraic characterization <ref> [Vaa91, Seg92, DS92] </ref>. We show how each of these techniques can be applied to the common task of verifying both safety and liveness properties of systems described as I/O automata. <p> The fairness argument could easily be formalized using a temporal logic of states and actions [Sta84, SLL93b], although we do not do this in this paper. The algebraic proof uses deductions within the process algebra DIOA <ref> [Seg92] </ref> for I/O automata. This process algebra contains a collection of axioms (i.e., sound proof rules) asserting that the quiescent preorder relation holds for a pair of I/O automata. The quiescent preorder is defined in [Vaa91] and consists of trace inclusion and quiescent trace inclusion. <p> Below, we define quiescence and relate it to fairness. We then define DIOA ("Demonic I/O Automata"), a process algebra for proving quiescent trace inclusion relationships between I/O automata. 3 3 The adjective "demonic" is used suggestively in <ref> [Seg92] </ref> to emphasize the fact that demonic I/O automata behave catastrophically in the presence of unexpected inputs. It is in contrast with the approach of [Vaa91] which is called "angelic" in [Seg92]. 20 5.1.1 From the Quiescent Preorder to the Fair Preorder Definition 5.1 (Quiescent executions and traces) A quiescent execution <p> algebra for proving quiescent trace inclusion relationships between I/O automata. 3 3 The adjective "demonic" is used suggestively in <ref> [Seg92] </ref> to emphasize the fact that demonic I/O automata behave catastrophically in the presence of unexpected inputs. It is in contrast with the approach of [Vaa91] which is called "angelic" in [Seg92]. 20 5.1.1 From the Quiescent Preorder to the Fair Preorder Definition 5.1 (Quiescent executions and traces) A quiescent execution of an I/O automaton A is a finite fair execution of A. A quiescent trace is the trace of a quiescent execution. <p> As pointed out through some examples in <ref> [Seg92] </ref>, the quiescent preorder is not an intuitively reasonable notion of implementation in general, however [Seg93] gives some sufficient conditions for the quiescent preorder to coincide with the fair preorder. Below we present some of the results of [Seg93]. We start with some definitions. <p> Our problem is based on delay insensitive circuits. 5.1.2 The Calculus of Demonic I/O Automata The calculus of Demonic I/O Automata (DIOA) is a process algebra for I/O automata <ref> [Seg92] </ref>. Each I/O automaton is an expression which is obtained by applying operators to basic automata. Each expression is sorted and each sort represents an external action signature. Each DIOA expression has a unique internal action t . <p> Function si allows us to define an unparameterized choice operator by writing e + f for e si (e) + si (f) f , where function si is defined in Table 3. The interested reader is referred to <ref> [Seg92] </ref> for a more detailed description of si and its generalization to all DIOA expressions. Given a DIOA expression, there is a natural way of associating an I/O automaton with it. 23 Name Op. <p> Table 4 contains some axioms for the quiescent preorder over DIOA. The axioms we present are just a some of those of <ref> [Seg92] </ref>, however they are sufficient for our examples. They are sound in the sense that they state true properties of the I/O automata associated with the expressions. <p> Let a; b; c be output actions and consider the processes X = a : b : X + a : c : X def It is easy to prove that Y v Q a : b : Y + a : c : Y by using the axioms of <ref> [Seg92] </ref> and the recursive substitutivity rule; however there is no forward simulation from the transition system associated with Y and that associated with X. State Y , in fact, would be mapped to X. <p> For systems in which these properties fail, it is unclear how to use the algebraic approach to reason about fair trace inclusion. It is worth remarking that all the DIOA axioms presented in <ref> [Seg92] </ref> except for the recursive substitutivity rule are sound for the fair preorder as well as the quiescent preorder. (The recursive substitutivity rule is sound for all I/O automata satisfying the conditions of Theorem 5.7.) So if we deal with non-recursive definitions, the axioms for DIOA provide a method for directly <p> Our proof steps were essentially repeated applications of the expansion axiom followed by some simplifications based on the given specification. This heuristic is generally applicable when dealing with (finite state) circuit descriptions. It is also applied in <ref> [Jos92, Seg92, OP92] </ref> and in several of the examples of [Bae90]. In these cases, algebraic manipulators like those of [MV91, Lin91] can be used. <p> We have verified the correctness of the implementation of a Muller C element taken from [Jos92] both in the assertional framework and in the process algebraic framework. The algebraic proof is based on DIOA <ref> [Seg92] </ref>, a process algebra for I/O automata. The example we have used is one of the typical examples of the process algebraic community; therefore, it should not be surprising that the process algebraic analysis looks shorter than the simulation-based one.
Reference: [Seg93] <author> R. Segala. </author> <title> Quiescence, fairness, testing and the notion of implementation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings CONCUR 93, Hildesheim, Germany, volume 715 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: It is an approximation, based on finite traces only, of the fair preorder. The reason for the use of the quiescent preorder rather than the fair preorder is that quiescence fits nicely into a process algebraic theory containing recursion whereas fairness does not. We state conditions (proved in <ref> [Seg93] </ref>) giving some circumstances under which the quiescent preorder is equivalent to the fair preorder. Since these circumstances hold in our example, the DIOA deductions that prove quiescent trace inclusion are also sufficient to prove the needed fair trace inclusion. <p> As pointed out through some examples in [Seg92], the quiescent preorder is not an intuitively reasonable notion of implementation in general, however <ref> [Seg93] </ref> gives some sufficient conditions for the quiescent preorder to coincide with the fair preorder. Below we present some of the results of [Seg93]. We start with some definitions. <p> As pointed out through some examples in [Seg92], the quiescent preorder is not an intuitively reasonable notion of implementation in general, however <ref> [Seg93] </ref> gives some sufficient conditions for the quiescent preorder to coincide with the fair preorder. Below we present some of the results of [Seg93]. We start with some definitions. Definition 5.3 (Quiescent detectability) An I/O automaton A is quiescent detectable if each finite fair trace of A is also a quiescent trace of A. Quiescence detectability requires each divergence to be detected through a quiescent trace. <p> Note, in fact, that systems without any infinite internal computation are quiescent detectable. Also quiescent continuity is generally true. In <ref> [Seg93] </ref> it is shown that, if an I/O automaton has FIN and is input deterministic (for each state q and each input action a there exists a unique state q 0 such that q a =) q 0 ), then it is quiescent continuous.
Reference: [SGG + 93] <author> J.F. Stgaard-Andersen, S.J. Garland, J.V. Guttag, N.A. Lynch, and A. Pogosyants. </author> <title> Computer-assisted simulation proofs. </title> <booktitle> In Proceedings of the Conference on Computer-Aided Verification, </booktitle> <address> Heraklion, Crete, Greece, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Once this information is provided, an automatic prover can be used to help in filling in enough details to verify that the simulation is correct. As described in <ref> [SGG + 93] </ref>, the Larch prover has been successfully used for this purpose. Also the theorem prover Isabelle was used for the same purpose in [Nip89]. The work on mechanical simulation-based verifications is still under development, and [Nip89, SGG + 93] are just the first attempts at solving the problem. <p> As described in [SGG + 93], the Larch prover has been successfully used for this purpose. Also the theorem prover Isabelle was used for the same purpose in [Nip89]. The work on mechanical simulation-based verifications is still under development, and <ref> [Nip89, SGG + 93] </ref> are just the first attempts at solving the problem. It seems unlikely that an automatic prover will be of much help in defining the simulation relation in a simulation proof.
Reference: [SLL93a] <author> J.F. Stgaard-Andersen, B. Lampson, and N.A. Lynch. </author> <title> Correctness of at-most-once message delivery protocols. </title> <booktitle> In FORTE '93 Sixth International Conference on Formal Description Techniques, </booktitle> <year> 1993. </year>
Reference-contexts: Indeed, the two methods have been developed by largely disjoint research communities, using different semantic models. The literature contains many examples of proofs using the two methods: some typical examples of simulation proofs appear in <ref> [LT87, SLL93a, SLL93b] </ref>, while examples of algebraic proofs appear in [Bae90, Jos92, OP92]. In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87].
Reference: [SLL93b] <author> J.F. Stgaard-Andersen, N.A. Lynch, and B.W. Lampson. </author> <title> Correctness of communication protocols. a case study. </title> <type> Technical Report MIT/LCS/TR-589, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Indeed, the two methods have been developed by largely disjoint research communities, using different semantic models. The literature contains many examples of proofs using the two methods: some typical examples of simulation proofs appear in <ref> [LT87, SLL93a, SLL93b] </ref>, while examples of algebraic proofs appear in [Bae90, Jos92, OP92]. In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. <p> In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. This framework has been used extensively for the verification of complex algorithms and pieces of distributed systems <ref> [WLL88, LS92, LP92, SLL93b] </ref>, and has already been given a process algebraic characterization [Vaa91, Seg92, DS92]. We show how each of these techniques can be applied to the common task of verifying both safety and liveness properties of systems described as I/O automata. <p> Then a simple argument about fairness is made, based on the correspondence between executions; this fairness argument uses the convenient notion of a forcing condition for an I/O automaton fairness class. The fairness argument could easily be formalized using a temporal logic of states and actions <ref> [Sta84, SLL93b] </ref>, although we do not do this in this paper. The algebraic proof uses deductions within the process algebra DIOA [Seg92] for I/O automata. This process algebra contains a collection of axioms (i.e., sound proof rules) asserting that the quiescent preorder relation holds for a pair of I/O automata. <p> This is the general strategy we will follow in our proof. 4.1.2 Forcing I/O Automata In carrying out the proof of fairness, it turns out to be notationally convenient to use a slight generalization of I/O automata that we call forcing I/O automata <ref> [SLL93b] </ref>. The generalization consists of associating a set of states called a forcing set with each class of part (A). <p> Note that the fairness part of the proof above is done somewhat less formally than the simulation part; the fairness part can be formalized using a temporal logic of states and actions <ref> [Sta84, SLL93b] </ref>. Now we can give the main result: Theorem 4.14 Hide fmg (A (M N ) k A (W N )) v F A (C N ). Proof. <p> The generality of our approach to fairness in the simulation proof also remains to be considered; however, in this case there is already good evidence that this approach works well in practice <ref> [LS92, SLL93b] </ref>. <p> The choice of which representation is better will vary among different automata, depending upon whether the automaton table is most easily described by columns or by rows. Our experience shows that, for complex systems, the action-based description is usually the better one <ref> [SLL93b] </ref>. There is one main reason for this. The states of a complex automaton can usually be described in terms of a small number of state variables or data objects, which permits a description to be parameterized by the values of those objects. <p> machine, the remarks at the end of Section 6.3 show that some form of simulation has to be defined even for an algebraic proof, therefore the difficulties involved in the mechanization of simulation and algebraic proofs are comparable. 6.5 Additional Benefits Obtained from the Proof Experience with large simulation-based verifications <ref> [WLL88, LP92, SLL93b] </ref> has shown that the formal description of the simulation relation in a simulation proof constitutes an important 36 piece of documentation of the key ideas of the implementation, in much the same way that an invariant assertion does; invariants and simulations typically express the key intuitions that make <p> In our experience simulation proofs are flexible in the sense that a given proof can usually be modified fairly easily in order to verify new properties of an implementation. A typical verification task, for example the one in <ref> [SLL93b] </ref>, involves the definition of specification and implementation automata and the proof that the implementation meets the specification. Dur- ing the proof some errors might be discovered and the involved automata might need to be modified. <p> The assertional methods based on I/O automata have been successfully used for the verification of very complex systems <ref> [LT87, WLL88, LP92, SLL93b] </ref> while the algebraic techniques of process algebras [Mil89] have generally been used for relatively small examples [Bae90, Jos92]. We have verified the correctness of the implementation of a Muller C element taken from [Jos92] both in the assertional framework and in the process algebraic framework.
Reference: [Sta84] <author> E.W. Stark. </author> <title> Foundations of a theory of specification for Distributed Systems. </title> <type> PhD the-sis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> August </month> <year> 1984. </year> <note> Available as Technical Report MIT/LCS/TR-342. </note>
Reference-contexts: Then a simple argument about fairness is made, based on the correspondence between executions; this fairness argument uses the convenient notion of a forcing condition for an I/O automaton fairness class. The fairness argument could easily be formalized using a temporal logic of states and actions <ref> [Sta84, SLL93b] </ref>, although we do not do this in this paper. The algebraic proof uses deductions within the process algebra DIOA [Seg92] for I/O automata. This process algebra contains a collection of axioms (i.e., sound proof rules) asserting that the quiescent preorder relation holds for a pair of I/O automata. <p> Note that the fairness part of the proof above is done somewhat less formally than the simulation part; the fairness part can be formalized using a temporal logic of states and actions <ref> [Sta84, SLL93b] </ref>. Now we can give the main result: Theorem 4.14 Hide fmg (A (M N ) k A (W N )) v F A (C N ). Proof.
Reference: [Sta90] <author> E.W. Stark. </author> <title> On the relations computable by a class of concurrent automata. </title> <booktitle> In Proceedings of the 1990 SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: Examples of systems satisfying the condition of Proposition 5.8 are the monotone I/O automata of <ref> [Sta90] </ref>, which can model a large class of dataflow networks, and the semi-modular, speed-independent circuits of [MB59]. Our problem is based on delay insensitive circuits. 5.1.2 The Calculus of Demonic I/O Automata The calculus of Demonic I/O Automata (DIOA) is a process algebra for I/O automata [Seg92].
Reference: [Vaa91] <author> F.W. Vaandrager. </author> <title> On the relationship between process algebra and Input/Output automata. </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Logic in Computer Science, </booktitle> <year> 1991. </year>
Reference-contexts: This framework has been used extensively for the verification of complex algorithms and pieces of distributed systems [WLL88, LS92, LP92, SLL93b], and has already been given a process algebraic characterization <ref> [Vaa91, Seg92, DS92] </ref>. We show how each of these techniques can be applied to the common task of verifying both safety and liveness properties of systems described as I/O automata. <p> The algebraic proof uses deductions within the process algebra DIOA [Seg92] for I/O automata. This process algebra contains a collection of axioms (i.e., sound proof rules) asserting that the quiescent preorder relation holds for a pair of I/O automata. The quiescent preorder is defined in <ref> [Vaa91] </ref> and consists of trace inclusion and quiescent trace inclusion. It is an approximation, based on finite traces only, of the fair preorder. <p> It is in contrast with the approach of <ref> [Vaa91] </ref> which is called "angelic" in [Seg92]. 20 5.1.1 From the Quiescent Preorder to the Fair Preorder Definition 5.1 (Quiescent executions and traces) A quiescent execution of an I/O automaton A is a finite fair execution of A. A quiescent trace is the trace of a quiescent execution. <p> Definition 5.2 (Quiescent preorder) Given two I/O automata A and B with the same external action signature, the quiescent preorder is defined as A v Q B iff traces fl (A) traces fl (B) and qtraces (A) qtraces (B): The quiescent preorder was first introduced in <ref> [Vaa91] </ref> and is an attempt at approximating the fair preorder by only looking at the finite executions of an I/O automaton.
Reference: [WLL88] <author> J.L. Welch, L. Lamport, and N. Lynch. </author> <title> A lattice-structured proof technique applied to a minimum spanning tree algorithm. </title> <type> Technical Report MIT/LCS/TM-361, </type> <institution> Laboratory for Computer Science, MIT, </institution> <month> June </month> <year> 1988. </year> <month> 39 </month>
Reference-contexts: In this paper, we unify, evaluate and compare the simulation-based and process algebraic verification techniques in terms of the Input/Output automaton (I/O automaton) model of Lynch and Tuttle [LT87]. This framework has been used extensively for the verification of complex algorithms and pieces of distributed systems <ref> [WLL88, LS92, LP92, SLL93b] </ref>, and has already been given a process algebraic characterization [Vaa91, Seg92, DS92]. We show how each of these techniques can be applied to the common task of verifying both safety and liveness properties of systems described as I/O automata. <p> machine, the remarks at the end of Section 6.3 show that some form of simulation has to be defined even for an algebraic proof, therefore the difficulties involved in the mechanization of simulation and algebraic proofs are comparable. 6.5 Additional Benefits Obtained from the Proof Experience with large simulation-based verifications <ref> [WLL88, LP92, SLL93b] </ref> has shown that the formal description of the simulation relation in a simulation proof constitutes an important 36 piece of documentation of the key ideas of the implementation, in much the same way that an invariant assertion does; invariants and simulations typically express the key intuitions that make <p> The assertional methods based on I/O automata have been successfully used for the verification of very complex systems <ref> [LT87, WLL88, LP92, SLL93b] </ref> while the algebraic techniques of process algebras [Mil89] have generally been used for relatively small examples [Bae90, Jos92]. We have verified the correctness of the implementation of a Muller C element taken from [Jos92] both in the assertional framework and in the process algebraic framework.
References-found: 27

