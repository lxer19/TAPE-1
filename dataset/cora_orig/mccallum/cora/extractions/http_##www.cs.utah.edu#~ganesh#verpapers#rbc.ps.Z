URL: http://www.cs.utah.edu/~ganesh/verpapers/rbc.ps.Z
Refering-URL: http://www.cs.utah.edu/~ganesh/verpapers.html
Root-URL: 
Title: Design and Verification of the Rollback Chip using HOP: A Case Study of Formal Methods
Author: Ganesh Gopalakrishnan Richard Fujimoto 
Date: April 1, 1993  
Address: Salt Lake City, Utah 84112 Atlanta, GA 30332  
Affiliation: University of Utah College of Computing Dept. of Computer Science Georgia Institute of Technology  
Abstract: The use of formal methods in hardware design improves the quality of designs in many ways: it promotes better understanding of the design; it permits systematic design refinement through the discovery of invariants; and it allows design verification (informal or formal). In this paper we illustrate the use of formal methods in the design of a custom hardware system called the `Rollback Chip' (RBC), conducted using a simple hardware design description language called `HOP'. An informal specification of the requirements of the RBC is first given, followed by a behavioral description of the RBC stating its desired behavior. The behavioral description is refined into progressively more efficient designs, terminating in a structural description. Key refinement steps are based on system invariants that are discovered during the design, and proved correct during design verification. The first step in design verification is to apply a program called PARCOMP to derive a behavioral description from the structural description of the RBC. The derived behavior is then compared against the desired behavior using equational verification techniques. This work demonstrates that formal methods can be fruitfully applied to a non-trivial hardware design. It also illustrates the particular advantages of our approach based on HOP and PARCOMP. Last, but not the least, it formally verifies the RBC mechanism itself. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Richard M. Fujimoto, J. -J. Tsai, and Ganesh Gopalakrishnan. </author> <title> Design and evaluation of the rollback chip: Special purpose hardware for time warp. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(1) </volume> <pages> 68-82, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: The final design representation (in whatever form it is|e.g., HDL, netlist, VLSI mask) can then be verified against an abstract specification of the system. We have completed such a design exercise on a real hardware design called the Roll Back Chip <ref> [1, 2] </ref>. The Roll Back Chip (RBC) is a custom architecture that helps speed up the state-saving and roll-back portions of parallel discrete event simulations using Time Warp [3]. The design of the RBC evolved side by side with a description for it. <p> For example, if the last write operation at address 55 was performed within snapshot 17, then the RBC instruction read (RBC; 55) translates into read (M EM; h17; 55i). To date, several designs of the rollback chip have been studied. Extensive simulation studies have been completed <ref> [1] </ref>. A commercial version of the RBC is under development, and an initial prototype using off-the-shelf components has been realized [2]. VLSI layouts for portions of the RBC have also been developed. More recently, the RBC has been specified in the language HOP. <p> A caching mechanism was developed to eliminate written bit searches for most read operations, <ref> [1] </ref>; however, this model is beyond the scope of the present discussion. The above mentioned linear search for each read is actually implemented more efficiently, as follows. Written bits are actually stored packed in words of nframes bits. These words can be read in one cycle. <p> It is discovered that RBH [11] is not modified, so there is no need to check the remainder of the stack. Here, we will assume the RBH stack is allowed to grow without bound. A mechanism has been developed to "forget" old RBH elements, as described in <ref> [1] </ref>, but is beyond the scope of the present discussion. The RBC state at this level is modeled using type rm12 type. <p> These refinement steps pertained to performance issues, and the gain in performance was evaluated through simulation studies <ref> [1] </ref>. The final implementation of the RBC used in [2] is very close to the final design specification in HOP that was verified against a high-level specification of the RBC. Verification is greatly aided by the ability of PARCOMP to deduce behavioral descriptions from structural descriptions. <p> Our initial design involved an on-chip written bits memory. This design was simulated in C. We concluded that this scheme would involve the use of large amounts of silicon area. Hence we developed a version of the RBC based on a special purpose cache memory <ref> [1] </ref>. This required about three man-months. Following the commercial development of the RBC [2], we decided to attempt to verify this version. Since the HOP effort was also going side-by-side, "teething troubles" forced us to take nearly six man-months to develop HOP specifications, and run them through PARCOMP.
Reference: [2] <author> C. A. Buzzell, M. J. Robb, and R. M. Fujimoto. </author> <title> Modular VME rollback hardware for Time Warp. </title> <booktitle> Proceedings of the SCS Multiconference on Distributed Simulation, </booktitle> <volume> 22(1) </volume> <pages> 153-156, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The final design representation (in whatever form it is|e.g., HDL, netlist, VLSI mask) can then be verified against an abstract specification of the system. We have completed such a design exercise on a real hardware design called the Roll Back Chip <ref> [1, 2] </ref>. The Roll Back Chip (RBC) is a custom architecture that helps speed up the state-saving and roll-back portions of parallel discrete event simulations using Time Warp [3]. The design of the RBC evolved side by side with a description for it. <p> The final version of the RBC that was implemented (see <ref> [2] </ref>) is essentially the final design description in HOP that is verified in this paper. Our Design Methodology Our design methodology is one of performance directed design refinement with validation based on formal verification. <p> To date, several designs of the rollback chip have been studied. Extensive simulation studies have been completed [1]. A commercial version of the RBC is under development, and an initial prototype using off-the-shelf components has been realized <ref> [2] </ref>. VLSI layouts for portions of the RBC have also been developed. More recently, the RBC has been specified in the language HOP. <p> These refinement steps pertained to performance issues, and the gain in performance was evaluated through simulation studies [1]. The final implementation of the RBC used in <ref> [2] </ref> is very close to the final design specification in HOP that was verified against a high-level specification of the RBC. Verification is greatly aided by the ability of PARCOMP to deduce behavioral descriptions from structural descriptions. <p> This design was simulated in C. We concluded that this scheme would involve the use of large amounts of silicon area. Hence we developed a version of the RBC based on a special purpose cache memory [1]. This required about three man-months. Following the commercial development of the RBC <ref> [2] </ref>, we decided to attempt to verify this version. Since the HOP effort was also going side-by-side, "teething troubles" forced us to take nearly six man-months to develop HOP specifications, and run them through PARCOMP.
Reference: [3] <author> D. R. Jefferson. </author> <title> Virtual time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: We have completed such a design exercise on a real hardware design called the Roll Back Chip [1, 2]. The Roll Back Chip (RBC) is a custom architecture that helps speed up the state-saving and roll-back portions of parallel discrete event simulations using Time Warp <ref> [3] </ref>. The design of the RBC evolved side by side with a description for it. Descriptions were written in our hardware description language HOP. <p> In optimistic synchronization, one detects synchronization errors at runtime, and invokes a rollback mechanism to recover. This is in contrast to more traditional conservative synchronization techniques that utilize blocking to avoid synchronization errors. The Time Warp mechanism is perhaps the most well known optimistic protocol <ref> [3] </ref>. Some successes have been reported in using Time Warp to parallelize discrete event simulation problems, e.g., see [19, 20]. In Time Warp, the parallel computation consists of some number of processes that communicate by exchanging time-stamped messages. <p> This optimization is not used here. The mechanism for determining when it is safe to garbage collect snapshots is beyond the scope of the present discussion, but is discussed in <ref> [3] </ref>. * Finally the reset operation initializes the system, essentially by discarding all existing snapshots, and beginning afresh at snapshot 0. It also initializes the internal state of the RBC as described later. The architectural context of the rollback chip is shown in Figure 1.
Reference: [4] <author> John V. Guttag, Ellis Horowitz, and David R. Musser. </author> <title> Abstract data types and software validation. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 1048-1064, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: Demonstration of this methodology in a specific hardware design is perhaps the single most important contribution of our paper. Our design methodology is now briefly outlined. We express the initial specification of the system as a data type <ref> [4] </ref> supporting a collection of operations. We do not associate any timing requirements (for example, the number of clock cycles that each operation should take) with the operations. This data type is then refined into a concrete representation, where the representation is chosen based on performance considerations. <p> In our work, we specify hardware systems essentially as abstract data types, as in <ref> [4] </ref>. It is well known that data type axioms can be very easily obtained from such specifications, and used both for 4 formal verification and test vector generation. <p> Since all possible states of the RBC can be created only through its operations write, mark, rollback, and advance, observable equivalence can be established through generator induction <ref> [4] </ref>, i.e., induction over sequences of state changing operations.
Reference: [5] <author> Boyer and Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: These mappings are then compared against the initial specification using equational verification techniques. The proof of correctness can in principle, be automated using systems such as the Boyer-Moore prover <ref> [5] </ref>, HOL prover [6], or the CLIO prover [7]. At present, however, only a manual proof has been completed. Although we do not verify that timing requirements are met, our verification procedure is capable of detecting all errors in the cycle-level timing of the sub-modules.
Reference: [6] <author> Michael Gordon. </author> <title> HOL: A proof generating system for Higher Order Logic. </title> <editor> In Graham Birtwistle and P.A.Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 73-128. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1988. </year> <month> ISBN-0-89838-246-7. </month>
Reference-contexts: These mappings are then compared against the initial specification using equational verification techniques. The proof of correctness can in principle, be automated using systems such as the Boyer-Moore prover [5], HOL prover <ref> [6] </ref>, or the CLIO prover [7]. At present, however, only a manual proof has been completed. Although we do not verify that timing requirements are met, our verification procedure is capable of detecting all errors in the cycle-level timing of the sub-modules.
Reference: [7] <author> Mandayam Srivas and Mark Bickford. </author> <title> Formal verification of a pipelined microprocessor. </title> <journal> IEEE Software, </journal> <volume> (9), </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: These mappings are then compared against the initial specification using equational verification techniques. The proof of correctness can in principle, be automated using systems such as the Boyer-Moore prover [5], HOL prover [6], or the CLIO prover <ref> [7] </ref>. At present, however, only a manual proof has been completed. Although we do not verify that timing requirements are met, our verification procedure is capable of detecting all errors in the cycle-level timing of the sub-modules. <p> Another important fact to note is that since the RBC operations do not overlap in time (as can happen, for example, in pipelined systems), each operation can be separately verified. Verification in the presence of pipelined operations requires more elaborate procedures <ref> [7, 8] </ref>. Related Work Formal verification of software and hardware systems has been proposed as an alternative to simulation and testing as early as the 1960s. Much work has concentrated on software system verification [9, 10]. <p> Among work that fall into this category, most examples deal with the verification of simple microprocessors [16, 17]. The microprocessors that were verified were not built with the design objective of high performance. A notable exception in this area is the work of <ref> [7] </ref> which considers the verification of a pipelined microprocessor. In that work, however, the pipelined design was not obtained through a process of top-down refinement that was geared towards obtaining a high-performance design.
Reference: [8] <author> Ganesh C. Gopalakrishnan. </author> <title> Specification and verification of pipelined hardware in HOP. </title> <booktitle> In Proc. Ninth International Symposium on Computer Hardware Description Languages, </booktitle> <pages> pages 117-131, </pages> <year> 1989. </year>
Reference-contexts: Another important fact to note is that since the RBC operations do not overlap in time (as can happen, for example, in pipelined systems), each operation can be separately verified. Verification in the presence of pipelined operations requires more elaborate procedures <ref> [7, 8] </ref>. Related Work Formal verification of software and hardware systems has been proposed as an alternative to simulation and testing as early as the 1960s. Much work has concentrated on software system verification [9, 10].
Reference: [9] <author> W. Richards Adrion, Martha A. Branstad, and John C. Cherniavsky. </author> <title> Validation, Verification, and Testing of Computer Software. </title> <journal> Computing Surveys, </journal> <volume> 14(2) </volume> <pages> 159-192, </pages> <month> June </month> <year> 1982. </year> <month> 30 </month>
Reference-contexts: Verification in the presence of pipelined operations requires more elaborate procedures [7, 8]. Related Work Formal verification of software and hardware systems has been proposed as an alternative to simulation and testing as early as the 1960s. Much work has concentrated on software system verification <ref> [9, 10] </ref>. One of the early proposals for hardware verification came in the early 1970s and 3 has since been followed by a large body of work [11]. There has been an extensive growth both in variety of techniques, examples, and verification tools [12, 13].
Reference: [10] <author> Krzysztof R. Apt and Ernst-Rudiger Olderog. </author> <title> Verification of Sequential and Concurrent Programs. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> ISBN 0-387-97532-2. </note>
Reference-contexts: Verification in the presence of pipelined operations requires more elaborate procedures [7, 8]. Related Work Formal verification of software and hardware systems has been proposed as an alternative to simulation and testing as early as the 1960s. Much work has concentrated on software system verification <ref> [9, 10] </ref>. One of the early proposals for hardware verification came in the early 1970s and 3 has since been followed by a large body of work [11]. There has been an extensive growth both in variety of techniques, examples, and verification tools [12, 13]. <p> Rather than explicitly clearing the written bits, we instead remember that a rollback to frame 5 has since occurred, and bits 6 and 7 now ought to be zero. We do this by storing a mask vector equal to 11111100 into RBH <ref> [10] </ref> (the leftmost bit refers to frame 0, the rightmost to frame 7). In general, zero bits of the mask vector correspond to discarded frames, and one bits indicate frames that remain in the stack. <p> In general, zero bits of the mask vector correspond to discarded frames, and one bits indicate frames that remain in the stack. When the written bits (01101011) are later read, we also: (i) read the tag (10), (ii) read the corresponding RBH entry (RBH <ref> [10] </ref> = 11111100), and (ii) perform a bitwise logic AND on the written bits and RBH value (yielding the desired value, 01101000). Notice that in Figure 4b, an additional entry has been added to the RBH stack. This is for the following reason. <p> The rollback to frame 2 will push a new vector of 1's onto the RBH, clear three additional bits of RBH <ref> [10] </ref> (corresponding to the three additional frames that were discarded), and clear bits 3 through 7 of RBH [11], leaving the RBH in the state shown in figure 4c. The subsequent marks and rollback operation (to frame 3) leave the RBH stack in the state shown in figure 4d.
Reference: [11] <author> Paolo Camurati and Paolo Prinetto. </author> <title> Formal Verification of Hardware Correctness: Introduction and Survey of Current Research. </title> <journal> IEEE Computer, </journal> <volume> 21(7) </volume> <pages> 8-20, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Much work has concentrated on software system verification [9, 10]. One of the early proposals for hardware verification came in the early 1970s and 3 has since been followed by a large body of work <ref> [11] </ref>. There has been an extensive growth both in variety of techniques, examples, and verification tools [12, 13]. In hardware verification, much work has centered around showing the functional correctness of proposed implementations of hardware systems against their behavioral specifications. <p> RBH [i] is defined for every i in the range 0 to the current roll-back count (the CRBI register value). This implies that a new element must be pushed onto the RBH stack after each rollback. This explains the new entry at RBH <ref> [11] </ref> in figure 4b. The new element always contains a mask of all one bits because no rollbacks have occurred since the current one (obviously!). This is the additional entry added to the RBH stack in Figure 4b, Each rollback operation requires that the following operations be performed: 1. <p> The rollback to frame 2 will push a new vector of 1's onto the RBH, clear three additional bits of RBH [10] (corresponding to the three additional frames that were discarded), and clear bits 3 through 7 of RBH <ref> [11] </ref>, leaving the RBH in the state shown in figure 4c. The subsequent marks and rollback operation (to frame 3) leave the RBH stack in the state shown in figure 4d. This last rollback creates a new entry RBH [13] and updates RBH [12]. It is discovered that RBH [11] is <p> RBH <ref> [11] </ref>, leaving the RBH in the state shown in figure 4c. The subsequent marks and rollback operation (to frame 3) leave the RBH stack in the state shown in figure 4d. This last rollback creates a new entry RBH [13] and updates RBH [12]. It is discovered that RBH [11] is not modified, so there is no need to check the remainder of the stack. Here, we will assume the RBH stack is allowed to grow without bound.
Reference: [12] <editor> G.Birtwistle and P.A.Subrahmanyam, editors. </editor> <title> Current Trends in Hardware Verification and Automated Theorem Proving. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: One of the early proposals for hardware verification came in the early 1970s and 3 has since been followed by a large body of work [11]. There has been an extensive growth both in variety of techniques, examples, and verification tools <ref> [12, 13] </ref>. In hardware verification, much work has centered around showing the functional correctness of proposed implementations of hardware systems against their behavioral specifications. <p> The subsequent marks and rollback operation (to frame 3) leave the RBH stack in the state shown in figure 4d. This last rollback creates a new entry RBH [13] and updates RBH <ref> [12] </ref>. It is discovered that RBH [11] is not modified, so there is no need to check the remainder of the stack. Here, we will assume the RBH stack is allowed to grow without bound.
Reference: [13] <editor> Luc Claesen, editor. </editor> <booktitle> Proceedings of the IMEC-IFIP Workshop on Applied Formal Methods for Correct VLSI Design, </booktitle> <address> Leuven, Belgium. </address> <publisher> North Holland, </publisher> <month> November </month> <year> 1989. </year>
Reference-contexts: One of the early proposals for hardware verification came in the early 1970s and 3 has since been followed by a large body of work [11]. There has been an extensive growth both in variety of techniques, examples, and verification tools <ref> [12, 13] </ref>. In hardware verification, much work has centered around showing the functional correctness of proposed implementations of hardware systems against their behavioral specifications. <p> The subsequent marks and rollback operation (to frame 3) leave the RBH stack in the state shown in figure 4d. This last rollback creates a new entry RBH <ref> [13] </ref> and updates RBH [12]. It is discovered that RBH [11] is not modified, so there is no need to check the remainder of the stack. Here, we will assume the RBH stack is allowed to grow without bound.
Reference: [14] <author> Daniel Weise. </author> <title> Automatic Formal Verification of Synchronous MOS VLSI Designs. </title> <type> PhD thesis, </type> <institution> Dept. of EE and CS, MIT, </institution> <year> 1986. </year>
Reference-contexts: There has been an extensive growth both in variety of techniques, examples, and verification tools [12, 13]. In hardware verification, much work has centered around showing the functional correctness of proposed implementations of hardware systems against their behavioral specifications. Though in many cases, verification of detailed timing behavior <ref> [14] </ref> as well as circuit behavior [15] has been included, these efforts have been restricted to small designs. In this paper, we address the task of showing functional correctness of designs.
Reference: [15] <author> Randal E. Bryant. </author> <title> Formal verification of memory circuits by switch-level simulation. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 94-102, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In hardware verification, much work has centered around showing the functional correctness of proposed implementations of hardware systems against their behavioral specifications. Though in many cases, verification of detailed timing behavior [14] as well as circuit behavior <ref> [15] </ref> has been included, these efforts have been restricted to small designs. In this paper, we address the task of showing functional correctness of designs. More specifically, we address the task of showing that the input output mappings of the actual implementation agree with that of the specification.
Reference: [16] <author> Avra Cohn. </author> <title> Correctness properties of the Viper block model: The second level. </title> <editor> In G.Birtwistle and P.A.Subrahmanyam, editors, </editor> <title> Current Trends in Hardware Verification and Automated Theorem Proving, </title> <booktitle> chapter 1, </booktitle> <pages> pages 1-91. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: The detailed cycle-level timing information contained in the implementation is simplified to an extent that only the causal orderings are retained; details of the exact number of cycles, etc., are ignored. Among work that fall into this category, most examples deal with the verification of simple microprocessors <ref> [16, 17] </ref>. The microprocessors that were verified were not built with the design objective of high performance. A notable exception in this area is the work of [7] which considers the verification of a pipelined microprocessor.
Reference: [17] <author> Warren A. Hunt Jr. </author> <title> The mechanical verification of a microprocessor design. </title> <editor> In D. Borrione, editor, </editor> <title> From HDL Descriptions to Guaranted Correct Circuit Designs. </title> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <year> 1987. </year> <booktitle> (Proc of the IFIP WG 10.2 Working Conference with the same title.). </booktitle>
Reference-contexts: The detailed cycle-level timing information contained in the implementation is simplified to an extent that only the causal orderings are retained; details of the exact number of cycles, etc., are ignored. Among work that fall into this category, most examples deal with the verification of simple microprocessors <ref> [16, 17] </ref>. The microprocessors that were verified were not built with the design objective of high performance. A notable exception in this area is the work of [7] which considers the verification of a pipelined microprocessor.
Reference: [18] <author> David A. Wood, Garth A. Gibson, and Randy H. Katz. </author> <title> Verifying a multiprocessor cache controller using random test generation. </title> <booktitle> IEEE Design & Test of Computers, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: In addition, new examples shed light on how verification techniques can be made practically usable. Less formal (rigorous) approaches than formal verification are commonly used in the validation of real-world hardware systems. In <ref> [18] </ref>, the `verification' (through random, and non-exhaustive tests) of a very complex cache controller has been discussed. The highest level specification of the protocol was written only in English. The cache controller was exercised using test-stubs that randomly generated a large number of possible multiprocessor interaction sequences.
Reference: [19] <author> R. M. Fujimoto. </author> <title> Time Warp on a shared memory multiprocessor. </title> <journal> Transactions of the Society for Computer Simulation, </journal> <volume> 6(3) </volume> <pages> 211-239, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: This is in contrast to more traditional conservative synchronization techniques that utilize blocking to avoid synchronization errors. The Time Warp mechanism is perhaps the most well known optimistic protocol [3]. Some successes have been reported in using Time Warp to parallelize discrete event simulation problems, e.g., see <ref> [19, 20] </ref>. In Time Warp, the parallel computation consists of some number of processes that communicate by exchanging time-stamped messages. The parallel computer is assumed to be a collection of processors, each with local memory, that communicate by exchanging messages. <p> Because optimistic synchronization methods rely on rollback, one must periodically save the state of each process. It has been observed that this is a serious overhead for processes containing a significant amount of state <ref> [19] </ref>. The rollback chip is a component that has been developed to 5 provide hardware support for the following capabilities: * It must be possible to take a snapshot of a process's data segment at any instant of time.
Reference: [20] <author> R. M. Fujimoto. </author> <title> Parallel discrete event simulation. </title> <journal> Communications of the ACM, </journal> <volume> 33(10) </volume> <pages> 30-53, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: This is in contrast to more traditional conservative synchronization techniques that utilize blocking to avoid synchronization errors. The Time Warp mechanism is perhaps the most well known optimistic protocol [3]. Some successes have been reported in using Time Warp to parallelize discrete event simulation problems, e.g., see <ref> [19, 20] </ref>. In Time Warp, the parallel computation consists of some number of processes that communicate by exchanging time-stamped messages. The parallel computer is assumed to be a collection of processors, each with local memory, that communicate by exchanging messages.
Reference: [21] <author> Paul Hudak. </author> <title> Conception, evolution, and application of functional programming languages. </title> <journal> ACM Computing Surveys, </journal> (3):359-411, September 1989. 
Reference-contexts: In later sections, we present the stepwise refinement of the RM1 model through levels RM11 and RM12 (see Figure 2). These models specify only the functionality of the RBC operations, and not their timing requirements. We shall use a purely functional <ref> [21] </ref> notation to specify the desired state- and output mappings of the operations. We select the functional programming language Miranda 1 to write our descrip 6 tions for convenience, and because the notation employed for specifying computations in HOP is also functional in nature.
Reference: [22] <author> Ganesh C. Gopalakrishnan and Richard Fujimoto. </author> <title> Design and Verification of the Rollback Chip using HOP: A Case Study of Formal Methods Applied to Hardware Design. </title> <type> Technical Report UUCS-91-015, </type> <institution> Dept. of Computer Science, University of Utah, </institution> <address> Salt Lake City, UT 84112, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Type array is introduced as an abstract data type in Miranda (detailed in <ref> [22] </ref>). Operations supported by array are now briefly described. * Function cv is the "create" function for the array type. For example, "cv 3 factorial" returns an array with location i (0i3) initialized to (factorial i). <p> This corresponds to the archive frame, whose purpose will be explained shortly. The left-half of Figure 3 shows how mrv is calculated if cmf is greater than omf. The right-half of in <ref> [22] </ref>. Now we proceed to define the RBC operations for level RM11. 12 4.2 Operations at Level RM11 The reset operation at level RM11, reset11, creates an uninitialized memory mem, as with operation reset1. <p> This invariant is maintained during the advance operation by updating MEM in such a way that for every address addr, if WB [OMF][addr] is set, data is moved from MEM [OMF][addr] into MEM [af rameaddr][addr]. This is accomplished by the archive function, whose description may be found in <ref> [22] </ref>. <p> Function clearedmrv simulates the process of clearing the written bits read off the wbarray using information contained in the RBH, and then obtaining the most recent version, as explained in Figure 4. We skip a formal definition of clearedmrv to conserve space, and refer the reader to <ref> [22] </ref> for details. read12::(rm12_type,addr_type) -&gt; word_type read12 ((mem',cmf,omf,wb,ts,rbh),addr) = ind (ind mem (clearedmrv wb ts rbh cmf omf addr)) addr clearedmrv::wbstore_type -&gt; tag_type -&gt; rbh_type -&gt; cmf_type -&gt; omf_type -&gt; addr_type -&gt; version_type Operation write12 fixes stale written bits in the wbarray (as indicated by the RBH stack) and also sets <p> Basically, archiving is performed if, after clearing the stale written bits, the written bit at position OMF is (still) found set. The details of archive2 are provided in <ref> [22] </ref>. advance12::rm12_type -&gt; rm12_type advance12 (mem',cmf,omf,wb,ts,rbh) = (archive2 mem' wb omf cmf rbh ts, cmf, (omf+1) mod nframes, wb, ts, rbh), if cmf ~= omf = error"Advance: OMF overflows & equals CMF", otherwise 6 Structural Specification The final realization of RM2 is shown in figure 5. <p> Before discarding this frame, however, it may be the case that there are addresses for which only this frame (that is about to be discarded) has the most recent version of data. These data items are archived as before, using archive2, detailed in <ref> [22] </ref>. advance2::rm2_type -&gt; rm2_type advance2 (mem,cmf,omf,wb,ts,rbh,i,ac) = (archive2 mem wb omf cmf rbh ts, cmf,(omf+1) mod nframes,wb,ts,rbh,i,0), if cmf ~= omf = error"Advance: OMF overflows & equals CMF", otherwise 8 Verification of RM2 Against RM1 The goals of formally verifying level RM2 description of the RBC against level RM1 description of <p> This is proved by referring to the internal organization of the circular priority encoder function. Details not presented here may be found in <ref> [22] </ref>. 9 Concluding Remarks The design of the Roll Back Chip (RBC), a custom architecture that helps speed up state-saving and rollback of distributed discrete event simulation using Time Warp, was presented. Specifications for the RBC system were written in our hardware description language HOP.
Reference: [23] <author> Randal E. Bryant, Derek L. Beatty, and Carl-Johan H. Seger. </author> <title> Formal hardware verification by symbolic ternary trajectory evaluation. </title> <booktitle> In Proc. ACM/IEEE 28rd Design Automation Conference, </booktitle> <pages> pages 397-402, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The proof of RM2 against RM1 that we are going to outline does not, by itself, guarantee that the RBC design would function correctly when timing details, or electrical factors (such as fanout) are considered. However, it is a necessary step before a more detailed verification (e.g. <ref> [23, 24, 25] </ref>) is conducted. As far as the external world is concerned, both RM1 and RM2 are systems whose internal states are observable only through the read operation.
Reference: [24] <author> Randal E. Bryant. </author> <title> Formal verification of memory circuits by switch-level simulation. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 94-102, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The proof of RM2 against RM1 that we are going to outline does not, by itself, guarantee that the RBC design would function correctly when timing details, or electrical factors (such as fanout) are considered. However, it is a necessary step before a more detailed verification (e.g. <ref> [23, 24, 25] </ref>) is conducted. As far as the external world is concerned, both RM1 and RM2 are systems whose internal states are observable only through the read operation.
Reference: [25] <author> Prabhat Jain and Ganesh Gopalakrishnan. </author> <title> Some techniques for efficient symbolic simulation based verification. </title> <booktitle> In International Conference on Computer Design (ICCD), </booktitle> <year> 1992. </year>
Reference-contexts: The proof of RM2 against RM1 that we are going to outline does not, by itself, guarantee that the RBC design would function correctly when timing details, or electrical factors (such as fanout) are considered. However, it is a necessary step before a more detailed verification (e.g. <ref> [23, 24, 25] </ref>) is conducted. As far as the external world is concerned, both RM1 and RM2 are systems whose internal states are observable only through the read operation.
Reference: [26] <author> Anthony Hall. </author> <title> Seven myths of formal methods. </title> <journal> IEEE Software, </journal> <volume> (9), </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: Of course, this also requires one to use a formal notation right from the beginning, and note invariants for use in proofs later on. 29 Formal methods do have certain limitations <ref> [26] </ref>. <p> However, despite these limitations, formal methods have resulted in measurable increases in designer productivity <ref> [26] </ref>, and also the quality of the final product. Many of the above limitations are also gradually being overcome through ongoing research efforts in this area. Our concrete plans regarding future efforts in this area include the following.
Reference: [27] <author> Ganesh Gopalakrishnan. HOP: </author> <title> A Formal Model for Synchronous Circuits using Communicating Fundamental Mode Symbolic Automata. </title> <type> Technical Report UU-CS-92-009, </type> <institution> Dept of Computer Science, University of Utah, </institution> <year> 1992. </year>
Reference-contexts: Many of the above limitations are also gradually being overcome through ongoing research efforts in this area. Our concrete plans regarding future efforts in this area include the following. A design system centered around HOP is currently being re-implemented based on the semantics presented in <ref> [27] </ref>. This system will incorporate an expression simplifier as part of PARCOMP, and help carry out many simplifications of the inferred behavior. The RBC system offers many possibilities for the overlapped execution of its operations. In the current design, these possibilities have not been fully exploited.
Reference: [28] <author> Venkatesh Akella and Ganesh Gopalakrishnan. SHILPA: </author> <title> A High-Level Synthesis System for Self-Timed Circuits. </title> <booktitle> In International Conference on Computer-aided Design, </booktitle> <volume> ICCAD 92, </volume> <pages> pages 587-591, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: This language, hopCP (HOP for Concurrent Processes) can very faithfully model control- and communication-intensive behaviors. An efficient simulator, a version of PARCOMP, as well as a high level synthesis system have been developed for hopCP by the first author's group <ref> [28, 29] </ref>. Plans are in place to specify the RBC in hopCP, conduct its formal verification, and develop an asynchronous version of the RBC. Acknowledgements: We thank the referees, especially referee A, for their valuable feedback. This work was supported in part by NSF Awards MIP-8902558 and CCR-8902362.
Reference: [29] <author> Venkatesh Akella. </author> <title> An Integrated Framework for High-Level Synthesis of Self-timed Circuits. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Utah, </institution> <year> 1992. </year> <month> 31 </month>
Reference-contexts: This language, hopCP (HOP for Concurrent Processes) can very faithfully model control- and communication-intensive behaviors. An efficient simulator, a version of PARCOMP, as well as a high level synthesis system have been developed for hopCP by the first author's group <ref> [28, 29] </ref>. Plans are in place to specify the RBC in hopCP, conduct its formal verification, and develop an asynchronous version of the RBC. Acknowledgements: We thank the referees, especially referee A, for their valuable feedback. This work was supported in part by NSF Awards MIP-8902558 and CCR-8902362.
References-found: 29

