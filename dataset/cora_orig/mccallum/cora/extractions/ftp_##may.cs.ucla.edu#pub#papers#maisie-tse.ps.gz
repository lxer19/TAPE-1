URL: ftp://may.cs.ucla.edu/pub/papers/maisie-tse.ps.gz
Refering-URL: http://may.cs.ucla.edu/papers/
Root-URL: http://www.cs.ucla.edu
Title: Maisie: A Language for the Design of Efficient Discrete-event Simulations  
Author: Rajive L. Bagrodia Wen-Toh Liao 
Address: Los Angeles Los Angeles, CA 90024  
Affiliation: Computer Science Department University of California at  
Abstract: Maisie is a C-based discrete-event simulation language that was designed to cleanly separate a simulation model from the underlying algorithm (sequential or parallel) used for the execution of the model. With few modifications, a Maisie program may be executed using a sequential simulation algorithm, a parallel conservative algorithm or a parallel optimistic algorithm. The language constructs allow the runtime system to implement optimizations that reduce recomputation and state saving overheads for optimistic simulations and synchronization overheads for conservative implementations. This paper presents the Maisie simulation language, describes a set of optimizations and illustrates the use of the language in the design of efficient parallel simulations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Marc Abrams. </author> <title> The object library for parallel simulation (OLPS). </title> <booktitle> In Proceedings of the 1988 Winter Simulation Conference, </booktitle> <pages> pages 210-219, </pages> <address> San Diego, California, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: Furthermore, Maisie is the first language that provides user-transparent and programmer-specified facilities to reduce the runtime overheads for parallel implementations using conservative or optimistic simulation techniques. Other languages/systems that support multiple parallel simulation algorithms include OLPS <ref> [1] </ref>, Yaddes [28], SPECTRUM [30], and SPEEDES [34]. Yaddes is a specification language for event-driven simulation that resembles Yacc and Lex. A Yaddes program is translated into a C program which is later compiled and linked with the runtime support library.
Reference: [2] <author> G.R. Andrews. </author> <title> Synchronizing resources. </title> <journal> ACM TOPLAS, </journal> <volume> 3(4) </volume> <pages> 405-430, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: State-saving and rollback overheads for optimistic simulations may be reduced transparently by incorporating a rollback chip [15] in the simulation engine. 3 Simulation Language Maisie is a C-based derivative of MAY [5] and has been influenced in varying degrees by distributed programming languages like CSP and SR <ref> [2] </ref> among others. This section is a brief description of 3 the Maisie simulation constructs. The Maisie manual [8] contains a complete description of the language. Maisie adopts the process interaction approach to discrete-event simulation.
Reference: [3] <author> Dirk Baezner, Greg Lomow, and Brian W. Unger. </author> <title> Sim++: The transition to distributed simulation. </title> <booktitle> In Proceedings of 1990 SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 211-218, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1990. </year>
Reference: [4] <author> R.L. Bagrodia, K.M. Chandy, and W. Liao. </author> <title> A unifying framework for distributed simulations. </title> <booktitle> ACM Transactions on Modeling and Computer Simulation, </booktitle> <pages> pages 348-385, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The simulation algorithms currently supported by Maisie include a sequential algorithm, parallel conservative algorithms based on null messages [25] and conditional events [10], a new conservative protocol that combines null messages with conditional events [23], and a parallel optimistic algorithm <ref> [11, 4] </ref>. The initial Maisie model is typically executed using a sequential algorithm. If the completion time of the sequential program is not acceptable, parallel implementations may be explored by the analyst. <p> Maisie implementations using conservative algorithms are described in [23]; optimistic implementations are described in <ref> [4] </ref>. 4.1 Null-Message Algorithm A Maisie program can be executed using either lazy or demand-driven variations for the null - message algorithm [25]. <p> Rollback is implemented automatically by tracking the timestamps on the messages delivered to each entity and the algorithm for detecting simulation convergence [11] can easily be made transparent to the Maisie programmer. A detailed description of the optimistic implementation has been provided in <ref> [4] </ref>. Optimistic executions may also require runtime support to deal with abnormal termination of a model due to errors caused by optimistic execution of an entity.
Reference: [5] <author> R.L. Bagrodia, K.M. Chandy, and J. Misra. </author> <title> A message-based approach to discrete-event simulation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(6):654-665, </volume> <month> June </month> <year> 1987. </year> <month> 25 </month>
Reference-contexts: Section 7 addresses implementation issues, particularly the implementation of Maisie constructs that support interrogative simulation. Section 8 is the conclusion. 2 Related Work A large number of sequential simulation languages have been designed including Simula, GASP, GPSS, Simscript, MAY <ref> [5] </ref>, CSIM [32] and many others. In contrast, design of parallel simulation languages (PSL) is a relatively new area of research. <p> State-saving and rollback overheads for optimistic simulations may be reduced transparently by incorporating a rollback chip [15] in the simulation engine. 3 Simulation Language Maisie is a C-based derivative of MAY <ref> [5] </ref> and has been influenced in varying degrees by distributed programming languages like CSP and SR [2] among others. This section is a brief description of 3 the Maisie simulation constructs. The Maisie manual [8] contains a complete description of the language.
Reference: [6] <author> R.L. Bagrodia and Wen-Toh Liao. Maisie: </author> <title> A language and optimizing environment for dis-tributed simulation. </title> <booktitle> In Proceedings of 1990 SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 205-210, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: In this paper we use interrogative simulation constructs [13] to design a simulation language that supports efficient execution of sequential and parallel simulation models. Although we present our ideas in the context of a C-based language called Maisie <ref> [6] </ref>, they can be incorporated in most environments for discrete-event simulation, regardless of their choice of a base language. <p> In contrast, design of parallel simulation languages (PSL) is a relatively new area of research. PSLs typically adopt one of two approaches: 2 (a) enhance sequential simulation languages with primitives or library functions to specify parallel execution; examples include Yaddes [28], Maisie <ref> [6] </ref>, SIMA [29], Modsim [35] and Sim++[3] among others, and (b) add simulation constructs to existing parallel languages as typified by Ada-based simulation environments like SCE [19]. The goal of Maisie was to design a simulation language that could be used to develop efficient sequential and parallel simulations.
Reference: [7] <author> R.L. Bagrodia and Wen-Toh Liao. </author> <title> Transparent optimizations of overheads in optimistic simulations. </title> <booktitle> In Proceedings of the 1992 Winter Simulation Conference, </booktitle> <pages> pages 637-645, </pages> <address> Arlington, Virginia, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: A detailed discussion of the implementation of the optimizations together with experimental measurements of their utility in reducing the completion time of optimistic simulations of stochastic benchmarks may be found in <ref> [7] </ref>. 0 4 8 12 Speed up optimized 3 3 3 non-optimized + + + + 5.2 User-specified Optimizations The optimizations described in the previous subsections are useful in identifying semantic rollbacks when a message is deposited in the message buffer of an entity in an incorrect order.
Reference: [8] <author> R.L. Bagrodia and Wen-Toh Liao. </author> <title> Maisie user manual. </title> <type> Technical report, </type> <institution> Computer Science Department, UCLA, </institution> <address> Los Angeles, CA 90024, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: This section is a brief description of 3 the Maisie simulation constructs. The Maisie manual <ref> [8] </ref> contains a complete description of the language. Maisie adopts the process interaction approach to discrete-event simulation. An object (also referred to as a PP for physical process) or set of objects in the physical system is represented by a logical process or LP [25, 9].
Reference: [9] <author> Randal E. Bryant. </author> <title> Simulation of packet communication architecture computer systems. </title> <type> Technical Report MIT-LCS-TR-188, </type> <institution> MIT, </institution> <year> 1977. </year>
Reference-contexts: The Maisie manual [8] contains a complete description of the language. Maisie adopts the process interaction approach to discrete-event simulation. An object (also referred to as a PP for physical process) or set of objects in the physical system is represented by a logical process or LP <ref> [25, 9] </ref>. Interactions among PPs (events) are modeled by message exchanges among the corresponding LPs. We first describe the process representation and communication primitives of Maisie and subsequently indicate how they are used to describe events. 3.1 Entities A Maisie program is a collection of entity definitions and C functions. <p> This constraint may introduce deadlocks, which are typically handled by incorporating deadlock detection [25] or deadlock avoidance <ref> [25, 9, 10] </ref> mechanism into the simulation algorithm. Optimistic algorithms [21, 11] allow an LP to process messages out of order; causality errors are corrected by using rollbacks and recomputations.
Reference: [10] <author> K.M. Chandy and R. Sherman. </author> <title> The conditional event approach to distributed simulation. </title> <booktitle> In Proceedings of the 1989 SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 93-99, </pages> <address> Tampa, Florida, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Distributed (or parallel) simulation refers to the execution of a simulation program on parallel computers. A number of algorithms <ref> [25, 10, 11, 21, 20] </ref> have been suggested for distributed simulation and many experimental studies have been conducted to evaluate the speedups that may be obtained from these algorithms and their variants. <p> The simulation algorithms currently supported by Maisie include a sequential algorithm, parallel conservative algorithms based on null messages [25] and conditional events <ref> [10] </ref>, a new conservative protocol that combines null messages with conditional events [23], and a parallel optimistic algorithm [11, 4]. The initial Maisie model is typically executed using a sequential algorithm. If the completion time of the sequential program is not acceptable, parallel implementations may be explored by the analyst. <p> As the data structures used to implement the external message buffer are not under programmer control, in general it is less efficient to find an enabling message (s). 3.5 Example We develop a complete Maisie model for a simple closed queueing network benchmark <ref> [10] </ref>, henceforth referred to as CQNF. The network consists of N fully connected switches. Each switch contains Q FIFO servers connected in tandem. <p> This constraint may introduce deadlocks, which are typically handled by incorporating deadlock detection [25] or deadlock avoidance <ref> [25, 9, 10] </ref> mechanism into the simulation algorithm. Optimistic algorithms [21, 11] allow an LP to process messages out of order; causality errors are corrected by using rollbacks and recomputations. <p> Other than the system calls required to maintain the source-set information for an entity, the simulation algorithm is completely transparent to the Maisie programmer. 4.2 Conditional Event Simulation Chandy and Sherman <ref> [10] </ref> have described a conservative simulation algorithm that does not rely on null messages to guarantee progress. Instead the algorithm distinguishes between definite and conditional events in a simulation.
Reference: [11] <author> K.M. Chandy and R. Sherman. </author> <title> Space-Time and Simulation. </title> <booktitle> In Proceedings of the 1989 SCS Multiconference on Distributed Simulation Conference, </booktitle> <pages> pages 53-57, </pages> <address> Miami, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Distributed (or parallel) simulation refers to the execution of a simulation program on parallel computers. A number of algorithms <ref> [25, 10, 11, 21, 20] </ref> have been suggested for distributed simulation and many experimental studies have been conducted to evaluate the speedups that may be obtained from these algorithms and their variants. <p> The simulation algorithms currently supported by Maisie include a sequential algorithm, parallel conservative algorithms based on null messages [25] and conditional events [10], a new conservative protocol that combines null messages with conditional events [23], and a parallel optimistic algorithm <ref> [11, 4] </ref>. The initial Maisie model is typically executed using a sequential algorithm. If the completion time of the sequential program is not acceptable, parallel implementations may be explored by the analyst. <p> This constraint may introduce deadlocks, which are typically handled by incorporating deadlock detection [25] or deadlock avoidance [25, 9, 10] mechanism into the simulation algorithm. Optimistic algorithms <ref> [21, 11] </ref> allow an LP to process messages out of order; causality errors are corrected by using rollbacks and recomputations. Implementations of optimistic algorithms are usually more difficult because they require complex mechanisms for detection and handling of causality errors, termination detection, exception handling, and memory management. <p> Functionally, checkpointing is transparent to the programmer; an entity changes its state on receipt of a message, and the old state is saved in a timestamped queue. Rollback is implemented automatically by tracking the timestamps on the messages delivered to each entity and the algorithm for detecting simulation convergence <ref> [11] </ref> can easily be made transparent to the Maisie programmer. A detailed description of the optimistic implementation has been provided in [4]. Optimistic executions may also require runtime support to deal with abnormal termination of a model due to errors caused by optimistic execution of an entity.
Reference: [12] <author> B.A. Cota and R.G. Sargent. </author> <title> Automatic lookahead computation for conservative distributed simulation. Technical Report CASE Center No. </title> <type> 8916, </type> <institution> Simulation Research Group and CASE Center, Syracuse University, </institution> <address> New York, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: When an entity schedules a definite future event, the runtime system automatically updates this variable to reflect the lookahead time for the entity. In addition, an entity may explicitly compute its lookahead and store it in this variable before executing a wait statement. The control graph model described in <ref> [12] </ref> uses a similar feature to permit automatic extraction of lookahead. Figure 10 illustrates lookahead computation for a priority server.
Reference: [13] <author> Ole-Johan Dahl. </author> <title> Discrete event simulation languages. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 348-395. </pages> <publisher> Academic Press, </publisher> <year> 1968. </year>
Reference-contexts: Subsequent refinements to the model may be used to improve its efficiency with respect to a specific simulation algorithm. In this paper we use interrogative simulation constructs <ref> [13] </ref> to design a simulation language that supports efficient execution of sequential and parallel simulation models. Although we present our ideas in the context of a C-based language called Maisie [6], they can be incorporated in most environments for discrete-event simulation, regardless of their choice of a base language.
Reference: [14] <author> R. Fujimoto. </author> <title> Lookahead in parallel discrete event simulation. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: Of course, if the entity also includes a warp section, the dead states must nevertheless be saved to allow the warp condition to be tested exhaustively. 6 Optimizations for Conservative Algorithms The performance of conservative algorithms is influenced significantly by the lookahead properties of the LPs in the model <ref> [14] </ref>. Lookahead is defined as follows: assume that the simulation interval for the model is [0,H].
Reference: [15] <author> R. Fujimoto, G. Gopalakrishnan, and J.J. Tsai. </author> <title> The roll back chip: Hardware support for distributed simulation using Time Warp. </title> <booktitle> In Proceedings of the 1988 SCS Simulation Multi-conference on Distributed Simulation, </booktitle> <address> San Diego, California, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: For instance, synchronization overheads in both conservative and optimistic imple mentations may be reduced by using reduction networks [31]. State-saving and rollback overheads for optimistic simulations may be reduced transparently by incorporating a rollback chip <ref> [15] </ref> in the simulation engine. 3 Simulation Language Maisie is a C-based derivative of MAY [5] and has been influenced in varying degrees by distributed programming languages like CSP and SR [2] among others. This section is a brief description of 3 the Maisie simulation constructs.
Reference: [16] <author> Richard Fujimoto. </author> <title> Parallel discrete event simulation. </title> <journal> Communications of the ACM, </journal> <volume> 33(10) </volume> <pages> 30-53, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Implementations of optimistic algorithms are usually more difficult because they require complex mechanisms for detection and handling of causality errors, termination detection, exception handling, and memory management. A comprehensive discussion of parallel discrete-event simulations may be found in <ref> [16, 25] </ref>. A sequential Maisie implementation may be refined to a parallel implementation simply by allocating the entities among available processors, and executing the program in the parallel environment.
Reference: [17] <author> Anat Gafni. </author> <title> Rollback mechanisms for optimistic distributed simulation systems. </title> <booktitle> In Proceedings of the 1988 SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 61-67, </pages> <address> San Diego, California, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: The term semantic rollback refers to a rollback whose rollback distance can be made smaller than the distance determined by the timestamp of the straggler message that initiates it. The semantic rollback optimizations differ from those implied by lazy message cancellation <ref> [17] </ref>. Lazy cancellation prevents cascading rollbacks by not canceling messages that are regenerated after a rollback. A semantic rollback directly reduces the rollback distance for the LP that receives a straggler message.
Reference: [18] <author> Al Geist, Adam Beguelin, and Jack Dongarra et al. </author> <title> PVM 3.0 user's guide and reference manual. </title> <type> Technical Report ORNL/TM-12187, </type> <institution> Oak Ridge National Laboratory, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: The runtime system for the parallel environment has two major responsibilities: providing interprocess communication (IPC) facilities and implementing the distributed simulation algorithm. The Maisie IPC facilities have been designed to operate in conjunction with existing IPC packages like UNIX Sockets, PVM <ref> [18] </ref>, and the Cosmic Environment [33]. They can be easily modified to work on top of other distributed operating system kernels. The distributed simulation algorithm is implemented via a set of routines that are essentially transparent to the Maisie programmer.
Reference: [19] <author> D.H. Gill, </author> <title> F.X. Maginnis, S.R. Rainier, and T.P. Reagan. An interface for programming parallel simulations. </title> <booktitle> In Proceedings of the 1989 SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 151-154, </pages> <address> Tampa, Florida, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: one of two approaches: 2 (a) enhance sequential simulation languages with primitives or library functions to specify parallel execution; examples include Yaddes [28], Maisie [6], SIMA [29], Modsim [35] and Sim++[3] among others, and (b) add simulation constructs to existing parallel languages as typified by Ada-based simulation environments like SCE <ref> [19] </ref>. The goal of Maisie was to design a simulation language that could be used to develop efficient sequential and parallel simulations. It is among the few languages that support both conservative and optimistic algorithms for its parallel implementations.
Reference: [20] <author> I. Greenberg, A.G. Mitrani and B. Lubachevsky. </author> <title> Unbounded parallel simulations via recurrence relations. </title> <booktitle> In 1990 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 1-12, </pages> <year> 1990. </year> <month> 26 </month>
Reference-contexts: 1 Introduction Distributed (or parallel) simulation refers to the execution of a simulation program on parallel computers. A number of algorithms <ref> [25, 10, 11, 21, 20] </ref> have been suggested for distributed simulation and many experimental studies have been conducted to evaluate the speedups that may be obtained from these algorithms and their variants.
Reference: [21] <author> D. Jefferson. </author> <title> Virtual Time. </title> <journal> ACM TOPLAS, </journal> <volume> 7(3) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Distributed (or parallel) simulation refers to the execution of a simulation program on parallel computers. A number of algorithms <ref> [25, 10, 11, 21, 20] </ref> have been suggested for distributed simulation and many experimental studies have been conducted to evaluate the speedups that may be obtained from these algorithms and their variants. <p> This constraint may introduce deadlocks, which are typically handled by incorporating deadlock detection [25] or deadlock avoidance [25, 9, 10] mechanism into the simulation algorithm. Optimistic algorithms <ref> [21, 11] </ref> allow an LP to process messages out of order; causality errors are corrected by using rollbacks and recomputations. Implementations of optimistic algorithms are usually more difficult because they require complex mechanisms for detection and handling of causality errors, termination detection, exception handling, and memory management.
Reference: [22] <author> D. Jefferson, B. Beckman, and F. Wieland et al. </author> <title> Distributed simulation and the time warp operating system. </title> <booktitle> In Symposium on Operating Systems Principles, </booktitle> <address> Austin, Texas, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: Let (m w , t w ) represent the earliest straggler message in r 2 . In a typical optimistic implementation like TWOS <ref> [22] </ref>, delivery of sequence r 2 rather than r 1 would cause recomputation of LP a from a state with a timestamp smaller than t w , in each of the four cases.
Reference: [23] <author> Vikas Jha and R.L. Bagrodia. </author> <title> Transparent implementation of conservative algorithms in parallel simulation languages. </title> <booktitle> In Proceedings of the 1993 Winter Simulation Conference, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: The simulation algorithms currently supported by Maisie include a sequential algorithm, parallel conservative algorithms based on null messages [25] and conditional events [10], a new conservative protocol that combines null messages with conditional events <ref> [23] </ref>, and a parallel optimistic algorithm [11, 4]. The initial Maisie model is typically executed using a sequential algorithm. If the completion time of the sequential program is not acceptable, parallel implementations may be explored by the analyst. <p> Maisie implementations using conservative algorithms are described in <ref> [23] </ref>; optimistic implementations are described in [4]. 4.1 Null-Message Algorithm A Maisie program can be executed using either lazy or demand-driven variations for the null - message algorithm [25]. <p> In the second case, an entity that sends the identifier LP d to say entity LP s must first execute a system call which updates the source-set of LP d to include LP s <ref> [23] </ref>. The runtime system can detect violations of the above rule and take appropriate action including abnormal termination of the simulation. On termination of an entity, the system automatically removes the name of the terminated entity from all source-sets and dest-sets. <p> The server uses a hold statement to service a high message, where its lookahead can be computed automatically by the runtime system (line 20). A detailed description of the optimizations with conservative implementations may be found in <ref> [23] </ref>. 7 Implementation Issues Maisie has been implemented on both sequential and parallel architectures. For sequential simulation, the splay-tree data structure is used to implement the global event-list. <p> For sequential simulation, the splay-tree data structure is used to implement the global event-list. For conservative simulations, the algorithms described in sections 4.1 and 4.2 as well as the optimizations discussed in section 6 have been implemented <ref> [23] </ref>. For the optimistic implementation using the space-time algorithm, the current implementation supports the transparent optimization discussed in section 5.1; the implementation of user-specified optimizations is in progress.
Reference: [24] <author> Yi-Bing Lin and Edward D. Lazowska. </author> <title> Exploiting lookahead in parallel simulation. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(4) </volume> <pages> 457-469, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: For some entities, it may be possible to extract the lookahead only using application-specific information. For instance, presampling of random numbers may be used to generate lookahead for a server whose service time is sampled from random distributions <ref> [26, 24] </ref>. Every Maisie entity includes a compiler-defined local variable called lookahead. When an entity schedules a definite future event, the runtime system automatically updates this variable to reflect the lookahead time for the entity.
Reference: [25] <author> J. Misra. </author> <title> Distributed discrete-event simulation. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(1) </volume> <pages> 39-65, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Distributed (or parallel) simulation refers to the execution of a simulation program on parallel computers. A number of algorithms <ref> [25, 10, 11, 21, 20] </ref> have been suggested for distributed simulation and many experimental studies have been conducted to evaluate the speedups that may be obtained from these algorithms and their variants. <p> The simulation algorithms currently supported by Maisie include a sequential algorithm, parallel conservative algorithms based on null messages <ref> [25] </ref> and conditional events [10], a new conservative protocol that combines null messages with conditional events [23], and a parallel optimistic algorithm [11, 4]. The initial Maisie model is typically executed using a sequential algorithm. <p> The Maisie manual [8] contains a complete description of the language. Maisie adopts the process interaction approach to discrete-event simulation. An object (also referred to as a PP for physical process) or set of objects in the physical system is represented by a logical process or LP <ref> [25, 9] </ref>. Interactions among PPs (events) are modeled by message exchanges among the corresponding LPs. We first describe the process representation and communication primitives of Maisie and subsequently indicate how they are used to describe events. 3.1 Entities A Maisie program is a collection of entity definitions and C functions. <p> Conservative algorithms do not permit any causality error: a simulation object (also called an LP) cannot process a message until the system can guarantee that it will not subsequently receive a message with an earlier timestamp. This constraint may introduce deadlocks, which are typically handled by incorporating deadlock detection <ref> [25] </ref> or deadlock avoidance [25, 9, 10] mechanism into the simulation algorithm. Optimistic algorithms [21, 11] allow an LP to process messages out of order; causality errors are corrected by using rollbacks and recomputations. <p> This constraint may introduce deadlocks, which are typically handled by incorporating deadlock detection [25] or deadlock avoidance <ref> [25, 9, 10] </ref> mechanism into the simulation algorithm. Optimistic algorithms [21, 11] allow an LP to process messages out of order; causality errors are corrected by using rollbacks and recomputations. <p> Implementations of optimistic algorithms are usually more difficult because they require complex mechanisms for detection and handling of causality errors, termination detection, exception handling, and memory management. A comprehensive discussion of parallel discrete-event simulations may be found in <ref> [16, 25] </ref>. A sequential Maisie implementation may be refined to a parallel implementation simply by allocating the entities among available processors, and executing the program in the parallel environment. <p> In the interest of brevity, we do not describe the respective protocols, but 3 For simplicity, we assume that all timestamps are unique; if not, alternative criteria must be used as suggested in <ref> [25] </ref> to select the next message. 12 simply indicate how the information required by each algorithm may be extracted from the Maisie program. <p> Maisie implementations using conservative algorithms are described in [23]; optimistic implementations are described in [4]. 4.1 Null-Message Algorithm A Maisie program can be executed using either lazy or demand-driven variations for the null - message algorithm <ref> [25] </ref>. In order to implement any null -message scheme, each LP must be aware of the set of its source and/or destination LPs. (In the absence of this information, null messages may have to be broadcast, making the implementation inefficient for simulation of a sparsely connected physical system). <p> As long as every cycle of entities in the model has at least one lookahead process, progress is guaranteed <ref> [25] </ref>. The basic scheme outlined above may perform poorly for many applications. The performance can be improved if lookahead for the various entities is exploited aggressively.
Reference: [26] <author> D.M. Nicol. </author> <title> Parallel discrete event simulation of FCFS stochastic queueing networks. In Parallel Programming: Experience with Applications, </title> <booktitle> Languages and Systems, </booktitle> <pages> pages 124-137. </pages> <booktitle> ACM SIGPLAN, </booktitle> <month> July </month> <year> 1988. </year>
Reference-contexts: For some entities, it may be possible to extract the lookahead only using application-specific information. For instance, presampling of random numbers may be used to generate lookahead for a server whose service time is sampled from random distributions <ref> [26, 24] </ref>. Every Maisie entity includes a compiler-defined local variable called lookahead. When an entity schedules a definite future event, the runtime system automatically updates this variable to reflect the lookahead time for the entity.
Reference: [27] <author> Kristen Nygaard and Ole-Johan Dahl. </author> <title> The development of the Simula language. </title> <editor> In Richard Wexelblat, editor, </editor> <booktitle> History of Programming Languages, </booktitle> <pages> pages 439-493. </pages> <publisher> Academic Press, </publisher> <year> 1981. </year>
Reference-contexts: However, interrogative algorithms may be less efficient because the cost of selecting an enabling message (which is not necessarily the message with the earliest timestamp) may be higher than for an imperative algorithm <ref> [27] </ref>. We examine the factors that contribute to this cost and discuss techniques that reduce it. Let lbuffer refer to the number of messages that must be inspected from the entity's buffer before an enabling message is identified.
Reference: [28] <author> Bruno R. Preiss. </author> <title> The Yaddes distributed discrete event simulation specification language and execution environments. </title> <booktitle> In Proceedings of the 1989 SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 139-144, </pages> <address> Tampa, Florida, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: In contrast, design of parallel simulation languages (PSL) is a relatively new area of research. PSLs typically adopt one of two approaches: 2 (a) enhance sequential simulation languages with primitives or library functions to specify parallel execution; examples include Yaddes <ref> [28] </ref>, Maisie [6], SIMA [29], Modsim [35] and Sim++[3] among others, and (b) add simulation constructs to existing parallel languages as typified by Ada-based simulation environments like SCE [19]. The goal of Maisie was to design a simulation language that could be used to develop efficient sequential and parallel simulations. <p> Furthermore, Maisie is the first language that provides user-transparent and programmer-specified facilities to reduce the runtime overheads for parallel implementations using conservative or optimistic simulation techniques. Other languages/systems that support multiple parallel simulation algorithms include OLPS [1], Yaddes <ref> [28] </ref>, SPECTRUM [30], and SPEEDES [34]. Yaddes is a specification language for event-driven simulation that resembles Yacc and Lex. A Yaddes program is translated into a C program which is later compiled and linked with the runtime support library.
Reference: [29] <author> Hassan Rajaei. SIMA: </author> <title> An environment for parallel discrete-event simulation. </title> <booktitle> In The 25th Annual Simulation Symposium, </booktitle> <pages> pages 147-149, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In contrast, design of parallel simulation languages (PSL) is a relatively new area of research. PSLs typically adopt one of two approaches: 2 (a) enhance sequential simulation languages with primitives or library functions to specify parallel execution; examples include Yaddes [28], Maisie [6], SIMA <ref> [29] </ref>, Modsim [35] and Sim++[3] among others, and (b) add simulation constructs to existing parallel languages as typified by Ada-based simulation environments like SCE [19]. The goal of Maisie was to design a simulation language that could be used to develop efficient sequential and parallel simulations.
Reference: [30] <author> Paul Reynolds. </author> <title> A spectrum of options for parallel simulation. </title> <booktitle> In Proceedings of the 1988 Winter Simulation Conference, </booktitle> <pages> pages 325-332, </pages> <address> San Diego, California, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: Furthermore, Maisie is the first language that provides user-transparent and programmer-specified facilities to reduce the runtime overheads for parallel implementations using conservative or optimistic simulation techniques. Other languages/systems that support multiple parallel simulation algorithms include OLPS [1], Yaddes [28], SPECTRUM <ref> [30] </ref>, and SPEEDES [34]. Yaddes is a specification language for event-driven simulation that resembles Yacc and Lex. A Yaddes program is translated into a C program which is later compiled and linked with the runtime support library. <p> Also, OLPS uses heavyweight UNIX processes that are created at runtime, which may potentially increase its runtime overhead. SPEEDES is a C++ based simulation environment which supports sequential algorithm, time-driven algorithm, Time-Warp algorithm, and the SPEEDES algorithm (a combination of the time-bucket and the Time-Warp algorithm). Reynolds <ref> [30] </ref> described nine design variables (partitioning, adaptability, aggressiveness, accuracy, risk, knowledge embedding, knowledge dissemination, knowledge acquisition, and synchrony) for designing a distributed simulation algorithm. SPECTRUM provides a library of application and support routines to evaluate algorithms that result from different combination of these design alternatives.
Reference: [31] <author> Paul F. Reynolds. </author> <title> An efficient framework for parallel simulations. </title> <editor> In V. Madisetti, D. Nicol, and R. Fujimoto, editors, </editor> <booktitle> Proceedings of the 1991 SCS Multiconference on Advances in Parallel and Distributed Simulation, volume 23:1, </booktitle> <pages> pages 167-174. </pages> <publisher> SCS, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: A number of hardware techniques have been suggested to improve the performance of parallel simulations. For instance, synchronization overheads in both conservative and optimistic imple mentations may be reduced by using reduction networks <ref> [31] </ref>.
Reference: [32] <author> H. Schwetman. CSIM: </author> <title> A C-based, process-oriented simulation language. </title> <booktitle> In Proceedings of the 1986 Winter Simulation Conference, </booktitle> <pages> pages 387-396, </pages> <address> Washington, DC, </address> <month> December </month> <year> 1986. </year>
Reference-contexts: Section 7 addresses implementation issues, particularly the implementation of Maisie constructs that support interrogative simulation. Section 8 is the conclusion. 2 Related Work A large number of sequential simulation languages have been designed including Simula, GASP, GPSS, Simscript, MAY [5], CSIM <ref> [32] </ref> and many others. In contrast, design of parallel simulation languages (PSL) is a relatively new area of research.
Reference: [33] <author> C.L. Seitz. </author> <title> The cosmic cube. </title> <journal> CACM, </journal> <volume> 28(1) </volume> <pages> 22-33, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: The runtime system for the parallel environment has two major responsibilities: providing interprocess communication (IPC) facilities and implementing the distributed simulation algorithm. The Maisie IPC facilities have been designed to operate in conjunction with existing IPC packages like UNIX Sockets, PVM [18], and the Cosmic Environment <ref> [33] </ref>. They can be easily modified to work on top of other distributed operating system kernels. The distributed simulation algorithm is implemented via a set of routines that are essentially transparent to the Maisie programmer.
Reference: [34] <author> Jeff Steinman. SPEEDES: </author> <title> Synchrnous parallel environment for emulation and discrete event simulation. </title> <booktitle> In Proceedings of the 1991 SCS Multiconference on Advances in Parallel and Distributed Simulation, </booktitle> <pages> pages 95-103, </pages> <address> Anaheim, California, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: Furthermore, Maisie is the first language that provides user-transparent and programmer-specified facilities to reduce the runtime overheads for parallel implementations using conservative or optimistic simulation techniques. Other languages/systems that support multiple parallel simulation algorithms include OLPS [1], Yaddes [28], SPECTRUM [30], and SPEEDES <ref> [34] </ref>. Yaddes is a specification language for event-driven simulation that resembles Yacc and Lex. A Yaddes program is translated into a C program which is later compiled and linked with the runtime support library. Different simulation environments are provided by specifying the appropriate runtime library at link time.
Reference: [35] <author> Joel West and Alasdar Mullarney. ModSim: </author> <title> A language for distributed simulation. </title> <booktitle> In Proceedings of the 1988 SCS Multiconference on Distributed Simulation, </booktitle> <pages> pages 155-159, </pages> <address> San Diego, California, </address> <month> February </month> <year> 1988. </year> <month> 27 </month>
Reference-contexts: In contrast, design of parallel simulation languages (PSL) is a relatively new area of research. PSLs typically adopt one of two approaches: 2 (a) enhance sequential simulation languages with primitives or library functions to specify parallel execution; examples include Yaddes [28], Maisie [6], SIMA [29], Modsim <ref> [35] </ref> and Sim++[3] among others, and (b) add simulation constructs to existing parallel languages as typified by Ada-based simulation environments like SCE [19]. The goal of Maisie was to design a simulation language that could be used to develop efficient sequential and parallel simulations.
References-found: 35

