URL: http://theory.lcs.mit.edu/tds/papers/Pogosyants/WDAG97.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/Pogosyants/WDAG97.html
Root-URL: 
Title: Verification of the Randomized Consensus Algorithm of Aspnes and Herlihy: a Case Study  
Author: Anna Pogosyants Roberto Segala Nancy Lynch 
Affiliation: 1 Laboratory for Computer Science, MIT 2 Dipartimento di Scienze dell'Informazione, Universita di Bologna  
Abstract: The Probabilistic I/O Automaton model of [11] is used as the basis for a formal presentation and proof of the randomized consensus algorithm of Aspnes and Herlihy. The algorithm is highly nontrivial and guarantees termination within expected polynomial time. The task of carrying out this proof has led us to develop several general proof techniques for probabilistic I/O automata. These include ways to combine expectations for different complexity measures, to compose expected complexity properties, to convert probabilistic claims to deterministic claims, to use abstraction mappings to prove probabilistic properties, and to apply random walk theory in a dis tributed computational setting.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Aggarwal. </author> <title> Time optimal self-stabilizing spanning tree algorithms. </title> <type> Technical Report MIT/LCS/TR-632, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1994. </year> <type> Master's thesis. </type>
Reference-contexts: Previous work on verification of randomized distributed algorithms includes [8], where the randomized dining philosophers algorithm of [5] is shown to guarantee progress with probability 1, [6, 9], where the algorithm of [5] is shown to guarantee progress within expected constant time, and <ref> [1] </ref>, where the randomized self-stabilizing minimum spanning tree algorithm of [2] is shown to guarantee stabilization within an expected time proportional to the diameter of a network. <p> The analysis of [8] is based on converting a probabilistic property into a property of some of the computations of an algorithm (extreme fair computations); the analysis of <ref> [6, 9, 1] </ref> is based on part of the methodology used in this paper. The paper is organized as follows. <p> I/O Automata A probability space P is a triplet (; F; P ) where is a set, F is a collection of subsets of that is closed under complement and countable union and such that 2 F , also called a field, and P is a function from F to <ref> [0; 1] </ref> such that P [] = 1 and such that for any collection fC i g i of at most countably many pairwise disjoint elements of F, P [[ i C i ] = P i P [C i ].
Reference: 2. <author> S. Aggarwal and S. Kutten. </author> <title> Time optimal self stabilizing spanning tree algorithms. In R.K. Shyamasundar, editor, </title> <booktitle> 13th International Conference on Foundations of Software Technology and Theoretical Computer Science, volume 761 of Lecture Notes in Computer Science, </booktitle> <pages> pages 400-410, </pages> <address> Bombay, India., </address> <month> December </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: verification of randomized distributed algorithms includes [8], where the randomized dining philosophers algorithm of [5] is shown to guarantee progress with probability 1, [6, 9], where the algorithm of [5] is shown to guarantee progress within expected constant time, and [1], where the randomized self-stabilizing minimum spanning tree algorithm of <ref> [2] </ref> is shown to guarantee stabilization within an expected time proportional to the diameter of a network.
Reference: 3. <author> J. Aspnes and M.P. Herlihy. </author> <title> Fast randomized consensus using shared memory. </title> <journal> Journal of Algorithms, </journal> <volume> 15(1) </volume> <pages> 441-460, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The types of modularity we are looking for include parallel composition and abstraction mappings, but also anything else that decomposes the math analysis. We develop our tools by analyzing complex algorithms of independent interest. In this paper we analyze the randomized consensus algorithm of Aspnes and Herlihy <ref> [3] </ref>, which guarantees termination within expected polynomial time. The Aspnes-Herlihy algorithm is a rather complex algorithm. Processes move through a succession of asynchronous rounds, attempting to agree at each round. At each round, the agreement attempt involves a distributed random walk. <p> Furthermore, by Theorem 6, P H [Top [(K 1)n; (K + 1)n; 0](H)] (K 1)=2K. 5.4 Implementation of the Shared Counter It is possible to build a distributed implementation of CT that preserves C1 and C2. The implementation, which we denote by DCT (Distributed CounTer), is pre sented in <ref> [3] </ref>. In the full paper we verify that DCT implements CT by exhibiting a refinement mapping [7] from DCT to CT . This part of the proof is simple and does not involve probability. <p> Thus, by Theorem 13 and Lemma 19, E t [H; fi] = O (Rn 3 ). 7 Concluding Remarks In the full paper [10] the length of the analysis of the Aspnes-Herlihy algorithm is double the length of the original proof of Aspnes and Herlihy <ref> [3] </ref>. This shows that it is possible to prove formally and rigorously the correctness of a randomized distributed algorithm without using too much space.
Reference: 4. <author> W. Feller. </author> <title> An Introduction to Probability Theory and its Applications. Volume 1. </title> <publisher> Jokn Wiley & Sons, Inc., </publisher> <year> 1950. </year>
Reference-contexts: Coin lemmas are essentially a way of reducing the analysis of a probabilistic property to the analysis of an ordinary nondeterministic property. 2.4 Symmetric Random Walks for Probabilistic Automata The correctness of the protocol of Aspnes and Herlihy is based on the theory of random walks <ref> [4] </ref>. That is, some parts of the protocol behave like a probabilistic process called random walk. The problem is to make sure that the protocol indeed behaves like a random walk.
Reference: 5. <author> D. Lehmann and M. Rabin. </author> <title> On the advantage of free choice: a symmetric and fully distributed solution to the dining philosophers problem. </title> <booktitle> In Proceedings of the 8 th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-138, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Previous work on verification of randomized distributed algorithms includes [8], where the randomized dining philosophers algorithm of <ref> [5] </ref> is shown to guarantee progress with probability 1, [6, 9], where the algorithm of [5] is shown to guarantee progress within expected constant time, and [1], where the randomized self-stabilizing minimum spanning tree algorithm of [2] is shown to guarantee stabilization within an expected time proportional to the diameter of <p> Previous work on verification of randomized distributed algorithms includes [8], where the randomized dining philosophers algorithm of <ref> [5] </ref> is shown to guarantee progress with probability 1, [6, 9], where the algorithm of [5] is shown to guarantee progress within expected constant time, and [1], where the randomized self-stabilizing minimum spanning tree algorithm of [2] is shown to guarantee stabilization within an expected time proportional to the diameter of a network.
Reference: 6. <author> N.A. Lynch, I. Saias, and R. Segala. </author> <title> Proving time bounds for randomized distributed algorithms. </title> <booktitle> In Proceedings of the 13 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Los Angeles, CA, </address> <pages> pages 314-323, </pages> <year> 1994. </year>
Reference-contexts: Previous work on verification of randomized distributed algorithms includes [8], where the randomized dining philosophers algorithm of [5] is shown to guarantee progress with probability 1, <ref> [6, 9] </ref>, where the algorithm of [5] is shown to guarantee progress within expected constant time, and [1], where the randomized self-stabilizing minimum spanning tree algorithm of [2] is shown to guarantee stabilization within an expected time proportional to the diameter of a network. <p> The analysis of [8] is based on converting a probabilistic property into a property of some of the computations of an algorithm (extreme fair computations); the analysis of <ref> [6, 9, 1] </ref> is based on part of the methodology used in this paper. The paper is organized as follows. <p> The first two steps can be carried out using the so-called coin lemmas <ref> [6, 9, 11] </ref>, which provide rules to map a stochastic process onto a probabilistic execution and lower bounds on the probability of the mapped events based on the properties of the given stochastic process; the third step concerns non-probabilistic properties and can be carried out by means of any known technique
Reference: 7. <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations Part II: </title> <journal> Timing-based systems. Information and Computation, </journal> <volume> 121(2) </volume> <pages> 214-233, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: The implementation, which we denote by DCT (Distributed CounTer), is pre sented in [3]. In the full paper we verify that DCT implements CT by exhibiting a refinement mapping <ref> [7] </ref> from DCT to CT . This part of the proof is simple and does not involve probability.
Reference: 8. <author> A. Pnueli and L. Zuck. </author> <title> Verification of multiprocess probabilistic protocols. </title> <journal> Distributed Computing, </journal> <volume> 1(1) </volume> <pages> 53-72, </pages> <year> 1986. </year>
Reference-contexts: Previous work on verification of randomized distributed algorithms includes <ref> [8] </ref>, where the randomized dining philosophers algorithm of [5] is shown to guarantee progress with probability 1, [6, 9], where the algorithm of [5] is shown to guarantee progress within expected constant time, and [1], where the randomized self-stabilizing minimum spanning tree algorithm of [2] is shown to guarantee stabilization within <p> The analysis of <ref> [8] </ref> is based on converting a probabilistic property into a property of some of the computations of an algorithm (extreme fair computations); the analysis of [6, 9, 1] is based on part of the methodology used in this paper. The paper is organized as follows.
Reference: 9. <author> A. Pogosyants and R. Segala. </author> <title> Formal verification of timed properties of randomized distributed algorithms. </title> <booktitle> In Proceedings of the 14 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Ottawa, Ontario, Canada, </address> <pages> pages 174-183, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Previous work on verification of randomized distributed algorithms includes [8], where the randomized dining philosophers algorithm of [5] is shown to guarantee progress with probability 1, <ref> [6, 9] </ref>, where the algorithm of [5] is shown to guarantee progress within expected constant time, and [1], where the randomized self-stabilizing minimum spanning tree algorithm of [2] is shown to guarantee stabilization within an expected time proportional to the diameter of a network. <p> The analysis of [8] is based on converting a probabilistic property into a property of some of the computations of an algorithm (extreme fair computations); the analysis of <ref> [6, 9, 1] </ref> is based on part of the methodology used in this paper. The paper is organized as follows. <p> Then, for each probabilistic execution fragment H of M and each full cut fi of H, E [H; fi] c. 2.3 Probabilistic Complexity Statements A probabilistic complexity statement <ref> [9, 11] </ref> is a predicate that states whether all the fair probabilistic executions of a probabilistic automaton guarantee some reachability property within some complexity c with some minimum probability p. Probabilistic complexity statements essentially express partial progress properties of a probabilis-tic system. <p> Suppose also that U c p U 0 and U ) U unlessU 0 . Then, E [H; fi U 0 (H)] (c + 1)=p. A useful technique to prove the validity of a probabilistic complexity statement U ! U 0 for a probabilistic automaton M is the following <ref> [9] </ref>: 1) choose a set of random draws that may occur within a probabilistic execution of M , and choose some of the possible outcomes; 2) show that, no matter how the nondeterminism is resolved, the chosen random draws give the chosen outcomes with some minimum probability p; 3) show that <p> The first two steps can be carried out using the so-called coin lemmas <ref> [6, 9, 11] </ref>, which provide rules to map a stochastic process onto a probabilistic execution and lower bounds on the probability of the mapped events based on the properties of the given stochastic process; the third step concerns non-probabilistic properties and can be carried out by means of any known technique
Reference: 10. <author> A. Pogosyants, R. Segala, and N. Lynch. </author> <title> Verification of the randomized consensus algorithm of Aspnes and Herlihy: a case study. </title> <type> Technical Memo MIT/LCS/TM-555, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1997. </year>
Reference-contexts: A similar construction is possible on probabilistic execution fragments. Here we just claim that HdM i is a probabilistic execution fragment of M i and that the probability space associated with HdM i is the image space under projection of the probability space associated with H. Proposition 1 <ref> [10] </ref>. Let M be M 1 k M 2 , and let H be a probabilistic execution fragment of M . Let i 2 f1; 2g. <p> Thus, by Theorem 13 and Lemma 19, E t [H; fi] = O (Rn 3 ). 7 Concluding Remarks In the full paper <ref> [10] </ref> the length of the analysis of the Aspnes-Herlihy algorithm is double the length of the original proof of Aspnes and Herlihy [3]. This shows that it is possible to prove formally and rigorously the correctness of a randomized distributed algorithm without using too much space.
Reference: 11. <author> R. Segala. </author> <title> Modeling and Verification of Randomized Distributed Real-Time Systems. </title> <type> PhD thesis, </type> <institution> MIT, Dept. of Electrical Engineering and Computer Science, </institution> <year> 1995. </year> <note> Also appears as technical report MIT/LCS/TR-676. </note>
Reference-contexts: We formalize the Aspnes-Herlihy algorithm using probabilistic I/O automata <ref> [11] </ref>. In doing so, we decompose it formally into three subprotocols: one to carry out the agreement attempts, one to conduct the random walks, and one to implement a shared counter needed by the random walks. <p> Then, for each probabilistic execution fragment H of M and each full cut fi of H, E [H; fi] c. 2.3 Probabilistic Complexity Statements A probabilistic complexity statement <ref> [9, 11] </ref> is a predicate that states whether all the fair probabilistic executions of a probabilistic automaton guarantee some reachability property within some complexity c with some minimum probability p. Probabilistic complexity statements essentially express partial progress properties of a probabilis-tic system. <p> For each probabilistic execution fragment H of M , let fi U 0 (H) denote the set of minimal states of H where a state from U 0 is reached. The following theorem provides a way of computing the expected for reaching U 0 . Proposition 5 <ref> [11] </ref>. Let M be a probabilistic automaton and be a complexity measure. Suppose that for each execution fragment of M of the form sas 0 , (sas 0 ) 1, that is, each transition of M increases by at most 1. <p> The first two steps can be carried out using the so-called coin lemmas <ref> [6, 9, 11] </ref>, which provide rules to map a stochastic process onto a probabilistic execution and lower bounds on the probability of the mapped events based on the properties of the given stochastic process; the third step concerns non-probabilistic properties and can be carried out by means of any known technique <p> In the full paper we verify that DCT implements CT by exhibiting a refinement mapping [7] from DCT to CT . This part of the proof is simple and does not involve probability. Then we use the compositionality results of <ref> [11] </ref> to show that DCT can replace CT in AH . 5.5 Summing Up In this section we paste together the results of the previous sections to derive an upper bound on the expected number of rounds for termination.
References-found: 11

