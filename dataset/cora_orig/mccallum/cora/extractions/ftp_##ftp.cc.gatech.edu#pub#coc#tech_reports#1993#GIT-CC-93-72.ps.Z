URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1993/GIT-CC-93-72.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.93.html
Root-URL: 
Title: Multi-Model Fault-Tolerant Programming in Distributed Object-Based Systems  
Author: Muthusamy Chelliah Mustaque Ahamad 
Keyword: Key Words: Objects, Transaction Models, Computation Replication Schemes, Distributed Operating Systems, Programming Support.  
Address: Atlanta, Georgia 30332-0280 USA  
Affiliation: College of Computing Georgia Institute of Technology  
Email: (chelliah,mustaq@cc.gatech.edu)  
Phone: Phone: (404)-894-2593  
Web: GIT-CC-93/72  
Abstract: Extended and replicated transaction models provide consistency and forward progress guarantees for distributed applications that manipulate persistent, shared data. In our earlier work, we developed OS mechanisms that can implement the various transaction models as policies at the user level. The mechanisms facilitate efficiency and flexibility, but programming using the primitive OS mechanisms could be complex. To simplify the programmer's task, in this paper, we develop higher level abstractions. These abstractions can be implemented using the underlying system mechanisms, as part of a language run-time system and library routines. We informally argue the flexibility of our approach for programming transaction models that facilitate nested and colored actions, and Parallel Execution Threads (PET). We quantify the costs of fault tolerance through a prototype implementation of multiple transaction models on the Clouds distributed system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ahamad, P. Dasgupta, and R. Leblanc Jr. </author> <title> Fault-tolerant Computations in Object-based Distributed Systems. </title> <journal> Distributed Computing, </journal> <volume> 4(2) </volume> <pages> 69-80, </pages> <year> 1990. </year> <month> 19 </month>
Reference-contexts: On completion, locks and data versions created by the action are propagated atomically to the parent on its committal or discarded on its abortion. Parallel Execution Threads (PET) is a scheme proposed to facilitate forward progress using computation replication <ref> [1] </ref>. In this scheme, a coordinator action spawns multiple cohorts each of which executes the same action code at different nodes in parallel, unaware of the existence of others. The target action can be completed if one of the cohorts reports successful completion and its changes can be committed.
Reference: [2] <author> H. Bal and A. Tanenbaum. </author> <title> Programming Languages for Distributed Computing Systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 3(1) </volume> <pages> 91-124, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: The goal of this paper is to develop a programming support module that simplifies the use of the low-level system mechanisms. A wide spectrum of distributed systems based on language-level support for fault tolerance have been proposed <ref> [2] </ref>. Object-oriented programming systems, like Arjuna [17] and Avalon [8], provide predefined super classes for recovery and concurrency control from which applications inherit methods for robust programming. FT-SR [16] is a system that extends an existing language, 1 for supporting multiple paradigms that guarantee forward progress.
Reference: [3] <author> M. Chelliah and M. Ahamad. </author> <title> System Mechanisms for Distributed Object-Based Fault-Tolerant Computing. </title> <type> Technical Report GIT-CC-92/23, </type> <institution> Georgia Tech., </institution> <year> 1992. </year>
Reference-contexts: However, there is no one transaction model which can meet the needs of all types of applications [7]. We advocate that an OS should not implement transaction models that correspond to policies for fault tolerance. Hence, we developed earlier <ref> [3] </ref> OS primitives that can be used to build multiple transaction models efficiently at the user level. The flexibility offered by parameterized system calls facilitates software reuse of the basic functionality for realizing the different transaction models. <p> Also, actions should be able to transfer the locks among themselves. In short, an action can obtain data versions and locks from one action and on committal entrust them to another action. We now revisit the system mechanisms, developed by us earlier <ref> [3] </ref>, that satisfy these requirements. 3 2.2 Programming Paradigm and an Implementation Objects provide an attractive structuring paradigm in a distributed environment [4]. We predicate our OS mechanisms and language-level abstractions on this popular methodology. <p> The system mechanisms themselves satisfy the flexibility claim of our system support <ref> [3] </ref>. However, the identification of data versions and related actions holding the synchronization variables to be manipulated by a certain action, possibly spanning multiple nodes, is still complex. <p> We had to modify each of these components for fault tolerance support, some times very minimally. We described the changes to the Clouds operating system for adding low-level mechanisms to support fault tolerance in an earlier publication <ref> [3] </ref>. Here, we concentrate on user-level fault-tolerant programming. Distributed C++ has library routines which form the gateway into the OS through system calls. The run-time library was enhanced to accommodate the system calls we had modified, e.g., synchronization and action monitoring calls. <p> Reliable network transmission cost is the major overhead in the implementation of the system mechanisms (null roundtrip of 3.5 ms contributing to approximate costs of 5 ms for synchronization, 15 ms for clone, and 20 ms for delegate of a segment with one 8K page) <ref> [3] </ref>. We have shown in Table 3 the costs (in milliseconds) of different phases of the nested action and PET scheme implementations. 5.2 Cost of Fault Tolerance We now analyze our experimental results by investigating how fault tolerance increases the cost of executing a computation.
Reference: [4] <author> R. Chin and S. Chanson. </author> <title> Distributed Object-based Programming Systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 3(1) </volume> <pages> 91-124, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: We now revisit the system mechanisms, developed by us earlier [3], that satisfy these requirements. 3 2.2 Programming Paradigm and an Implementation Objects provide an attractive structuring paradigm in a distributed environment <ref> [4] </ref>. We predicate our OS mechanisms and language-level abstractions on this popular methodology. We chose the passive object paradigm due to the availability of the object-based system Clouds [6] for experimentation, and lack of efficient and flexible support for fault tolerance in similar systems.
Reference: [5] <author> E. Cooper. </author> <title> Replicated Distributed Programs. </title> <booktitle> In Proceedings of Tenth Symposium On Operating System Principles. ACM, </booktitle> <year> 1985. </year>
Reference-contexts: As evident from Table 3, we have a subaction cost of 133.1 ms (spawning, computation and termination). Circus is a replicated procedure call facility implemented as part of the Unix 4.2BSD system <ref> [5] </ref>. Replicated procedure call with a degree of replication 2 costs 58 msec (real time) and increases linearly with the degree of replication. This cost does not include the creation of a heavy-weight computation at the remote site.
Reference: [6] <author> P. Dasgupta et al. </author> <title> The Clouds Distributed Operating System. </title> <booktitle> IEEE Computer, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: In such an environment, comprehensive fault-tolerant programming should address robustness that preserves data consistency and forward progress which guarantees eventual completion of computations. The atomic transaction model [10] provides robustness for traditional database applications. Computation replication schemes like Parallel Execution Threads (PET) <ref> [6] </ref> ensure forward progress of atomic (trans)actions. However, the atomic transaction model is considered restrictive for application domains like collaborative work (CSCW) and engineering (CAD and software development) databases. <p> We predicate our OS mechanisms and language-level abstractions on this popular methodology. We chose the passive object paradigm due to the availability of the object-based system Clouds <ref> [6] </ref> for experimentation, and lack of efficient and flexible support for fault tolerance in similar systems. In our system, actions model the active entity in a program control, and passive objects encapsulate data and code. An action manipulates object data only when it invokes an operation defined by the object. <p> The higher level abstractions ease the programmer's task without sacrificing the flexibility and efficiency offered by the underlying OS. 5 Prototype Implementation We use the Clouds distributed operating system <ref> [6] </ref> as the test bed for our prototype implementation. We have demonstrated nested actions and Parallel Execution Threads, both on the same software platform.
Reference: [7] <author> A. Elmagarmid. </author> <title> Database Transaction Models for Advanced Applications. </title> <address> Morg.-Kauf., </address> <year> 1992. </year>
Reference-contexts: The Camelot transactional facility thus implemented nested actions on top of the the Mach microkernel [8]. However, there is no one transaction model which can meet the needs of all types of applications <ref> [7] </ref>. We advocate that an OS should not implement transaction models that correspond to policies for fault tolerance. Hence, we developed earlier [3] OS primitives that can be used to build multiple transaction models efficiently at the user level.
Reference: [8] <author> J. Eppinger, L. Mummert, and A. Spector. Camelot and Avalon: </author> <title> A Distributed Transaction Facility. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: The Argus system [11] implemented nested actions at the language level. Alternatively, operating system (OS) support for virtual memory (VM) management, especially a single-level storage abstraction, can be exploited to implement transactions efficiently. The Camelot transactional facility thus implemented nested actions on top of the the Mach microkernel <ref> [8] </ref>. However, there is no one transaction model which can meet the needs of all types of applications [7]. We advocate that an OS should not implement transaction models that correspond to policies for fault tolerance. <p> The goal of this paper is to develop a programming support module that simplifies the use of the low-level system mechanisms. A wide spectrum of distributed systems based on language-level support for fault tolerance have been proposed [2]. Object-oriented programming systems, like Arjuna [17] and Avalon <ref> [8] </ref>, provide predefined super classes for recovery and concurrency control from which applications inherit methods for robust programming. FT-SR [16] is a system that extends an existing language, 1 for supporting multiple paradigms that guarantee forward progress. <p> The object programmer just needs to annotate the object specification appropriately for automatic insertion of the primitives. 4.3 Power of the Abstractions We now emphasize the virtue of our approach by comparing the recovery control functionality provided by our system with that of the Camelot/Avalon transactional facility <ref> [8] </ref>.
Reference: [9] <author> H. Garcia-Molina. </author> <title> Using Semantic Knowledge for Transaction Processing Databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(2) </volume> <pages> 186-213, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: However, the atomic transaction model is considered restrictive for application domains like collaborative work (CSCW) and engineering (CAD and software development) databases. Hence a variety of extended transaction models, that promote more flexible computations like nested [12], colored [18], split [15] and cooperating <ref> [9] </ref> actions, have been proposed. We are currently investigating the system support required to build extended and replicated transactions as tools for user-level fault-tolerant programming. The Argus system [11] implemented nested actions at the language level.
Reference: [10] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <address> Morg.-Kauf., </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Distributed systems have nodes that fail independently. In such an environment, comprehensive fault-tolerant programming should address robustness that preserves data consistency and forward progress which guarantees eventual completion of computations. The atomic transaction model <ref> [10] </ref> provides robustness for traditional database applications. Computation replication schemes like Parallel Execution Threads (PET) [6] ensure forward progress of atomic (trans)actions. However, the atomic transaction model is considered restrictive for application domains like collaborative work (CSCW) and engineering (CAD and software development) databases.
Reference: [11] <author> B. Liskov et al. </author> <title> Implementation of Argus. </title> <booktitle> In Proceedings of 11th ACM Symposium On Operating Systems Principles, </booktitle> <pages> pages 111-22. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: Hence a variety of extended transaction models, that promote more flexible computations like nested [12], colored [18], split [15] and cooperating [9] actions, have been proposed. We are currently investigating the system support required to build extended and replicated transactions as tools for user-level fault-tolerant programming. The Argus system <ref> [11] </ref> implemented nested actions at the language level. Alternatively, operating system (OS) support for virtual memory (VM) management, especially a single-level storage abstraction, can be exploited to implement transactions efficiently. The Camelot transactional facility thus implemented nested actions on top of the the Mach microkernel [8].
Reference: [12] <author> E. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <institution> Laboratory for Computer Science, </institution> <type> Ph.D Thesis , 1981. </type>
Reference-contexts: However, the atomic transaction model is considered restrictive for application domains like collaborative work (CSCW) and engineering (CAD and software development) databases. Hence a variety of extended transaction models, that promote more flexible computations like nested <ref> [12] </ref>, colored [18], split [15] and cooperating [9] actions, have been proposed. We are currently investigating the system support required to build extended and replicated transactions as tools for user-level fault-tolerant programming. The Argus system [11] implemented nested actions at the language level.
Reference: [13] <author> A. Nanjia and D. Finkel. </author> <title> Transaction Based Fault-tolerant Computing in Mach. </title> <booktitle> In Proceedings of the Workshop On Fault-tolerant Parallel and Distributed Systems. IEEE, </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: Rose [14] implemented on a platform consisting of Sun-2 wokstations incurs 162.7 ms for committing two large objects each of 4K size. A recent fault-tolerant adaptation of Mach reports 5 transactions per second on a network of Sun 3/60 workstations <ref> [13] </ref>. As evident from Table 3, we have a subaction cost of 133.1 ms (spawning, computation and termination). Circus is a replicated procedure call facility implemented as part of the Unix 4.2BSD system [5].
Reference: [14] <author> T.P. Ng. </author> <title> The Design and Implementation of A Reliable Distributed Operating System ROSE. </title> <booktitle> In Ninth IEEE Symposium On Reliable Distributed Systems, </booktitle> <year> 1990. </year>
Reference-contexts: We give numbers for two kinds of systems, those supporting robust computations, and schemes for replicated computations. 18 The Arjuna system reports 59.6 msec as a nested subaction cost when the object size is 1K [17]. Rose <ref> [14] </ref> implemented on a platform consisting of Sun-2 wokstations incurs 162.7 ms for committing two large objects each of 4K size. A recent fault-tolerant adaptation of Mach reports 5 transactions per second on a network of Sun 3/60 workstations [13].
Reference: [15] <author> C. Pu and E. Kaiser. </author> <title> Split-Transactions for Open-Ended Activities. </title> <booktitle> In Proceedings of the 14th Intl. Conf. on VLDB, </booktitle> <month> September </month> <year> 1988. </year>
Reference-contexts: However, the atomic transaction model is considered restrictive for application domains like collaborative work (CSCW) and engineering (CAD and software development) databases. Hence a variety of extended transaction models, that promote more flexible computations like nested [12], colored [18], split <ref> [15] </ref> and cooperating [9] actions, have been proposed. We are currently investigating the system support required to build extended and replicated transactions as tools for user-level fault-tolerant programming. The Argus system [11] implemented nested actions at the language level.
Reference: [16] <author> R. Schlichting and V. Thomas. </author> <title> A Multi-Paradigm Programming Language for Constructing Fault-tolerant, </title> <booktitle> Distributed Systems. In Proceedings of the 11th SRDS, </booktitle> <year> 1991. </year> <month> 20 </month>
Reference-contexts: A wide spectrum of distributed systems based on language-level support for fault tolerance have been proposed [2]. Object-oriented programming systems, like Arjuna [17] and Avalon [8], provide predefined super classes for recovery and concurrency control from which applications inherit methods for robust programming. FT-SR <ref> [16] </ref> is a system that extends an existing language, 1 for supporting multiple paradigms that guarantee forward progress. All these systems employ the nested transaction model as the primary consistency mechanism and hence do not explore abstractions for programming multiple transaction models which can be easily implemented using low-level mechanisms.
Reference: [17] <author> S. Shrivastava, G. Dixon, and G. Parrington. </author> <title> An Overview of The Arjuna Distributed Pro--gramming System. </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: The goal of this paper is to develop a programming support module that simplifies the use of the low-level system mechanisms. A wide spectrum of distributed systems based on language-level support for fault tolerance have been proposed [2]. Object-oriented programming systems, like Arjuna <ref> [17] </ref> and Avalon [8], provide predefined super classes for recovery and concurrency control from which applications inherit methods for robust programming. FT-SR [16] is a system that extends an existing language, 1 for supporting multiple paradigms that guarantee forward progress. <p> We give numbers for two kinds of systems, those supporting robust computations, and schemes for replicated computations. 18 The Arjuna system reports 59.6 msec as a nested subaction cost when the object size is 1K <ref> [17] </ref>. Rose [14] implemented on a platform consisting of Sun-2 wokstations incurs 162.7 ms for committing two large objects each of 4K size. A recent fault-tolerant adaptation of Mach reports 5 transactions per second on a network of Sun 3/60 workstations [13].
Reference: [18] <author> S. Shrivastava and S. Wheater. </author> <title> Implementing Fault-tolerant Distributed Applications Using Objects and Multi-coloured Actions. </title> <booktitle> In Proceedings of the 10th ICDCS, </booktitle> <year> 1990. </year>
Reference-contexts: However, the atomic transaction model is considered restrictive for application domains like collaborative work (CSCW) and engineering (CAD and software development) databases. Hence a variety of extended transaction models, that promote more flexible computations like nested [12], colored <ref> [18] </ref>, split [15] and cooperating [9] actions, have been proposed. We are currently investigating the system support required to build extended and replicated transactions as tools for user-level fault-tolerant programming. The Argus system [11] implemented nested actions at the language level.
Reference: [19] <author> K.S. Yap, P. Jalote, and S. Tripathi. </author> <title> Fault Tolerant Remote Procedure Call. </title> <booktitle> In Eighth International Conference On Distributed Computing Systems. IEEE, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: This cost does not include the creation of a heavy-weight computation at the remote site. This scheme was implemented on a network of VAX-11 workstations connected by ethernet. Fault-tolerant RPC, another replication scheme, incurs an extra overhead of 291 msec per replica <ref> [19] </ref>. For a 2-replica computation, the cost reported is 593 msec. Sun 3/52M workstations were used as the compute servers.
References-found: 19

