URL: http://www.cs.panam.edu/~meng/unix-home/Research/Multip/GIT-CC-93-18.ps.gz
Refering-URL: http://www.cs.panam.edu/~meng/unix-home/Research/Multip/
Root-URL: http://www.cs.panam.edu
Email: (bodhi@cc.gatech.edu)  (schwan@cc.gatech.edu)  (kaushik@cc.gatech.edu)  
Title: A Survey of Real-Time Operating Systems Preliminary Draft  
Author: Bodhisattwa Mukherjee Karsten Schwan Kaushik Ghosh 
Note: Readers' comments and suggestions for improvement are solicited. Please direct them to kaushik@cc.gatech.edu.  
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Date: March 1, 1993  
Pubnum: GIT-CC-93/18  
Abstract: This paper describes current research in real time operating systems. We present relevant results in real-time task scheduling, summarize research in real-time synchronization, and follow up with a discussion of the structures and primitives offered by selected real-time operating system kernels. 
Abstract-found: 1
Intro-found: 1
Reference: [Agr90] <author> A. Agrawala. </author> <title> Systems engineering approach to time-driven systems. </title> <booktitle> In CompEuro 90, </booktitle> <year> 1990. </year>
Reference-contexts: This results in somewhat inflexible process scheduling because prematurely finishing processes cannot relinquish their extra execution time to other processes [SZ92]. 4.3.3 The Maruti Distributed Real-Time Operating System The main focus of the Maruti project <ref> [GMAT90, Agr90, AL87, MA90, YA89, LA90] </ref> at the University of Maryland is to examine the constructs of future distributed, hard real-time, fault tolerant, secure operating systems. Maruti is an object-based system, with encapsulation of services.
Reference: [AL87] <author> A. Agrawala and S. Levi. </author> <title> Objects architecture for real-time, distributed, fault tolerant operating systems. </title> <booktitle> In IEEE Workshop on Real-Time Operating Systems, </booktitle> <month> July </month> <year> 1987. </year> <month> 35 </month>
Reference-contexts: This results in somewhat inflexible process scheduling because prematurely finishing processes cannot relinquish their extra execution time to other processes [SZ92]. 4.3.3 The Maruti Distributed Real-Time Operating System The main focus of the Maruti project <ref> [GMAT90, Agr90, AL87, MA90, YA89, LA90] </ref> at the University of Maryland is to examine the constructs of future distributed, hard real-time, fault tolerant, secure operating systems. Maruti is an object-based system, with encapsulation of services.
Reference: [And90] <author> T. E. Anderson. </author> <title> The perfomance of spin lock alternatives for shared-memory mul-tiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: As a result, the application program or higher-level operating system software can deal with such failures in a timely manner, by acquisition of alternative resources, by execution of exception handling code, etc. Anderson <ref> [And90] </ref> and Mellor-Crummey and Scott [MCS91] derived spin lock implementations that service lock requests in FIFO order and may be useful for real time systems. In [Mar91], the author defines a synchronization mechanism, called a priority spin lock, and sug 12 gests implementations of such locks with local spinning.
Reference: [ATW + 89] <author> D. Anderson, S. Tzou, R. Wahbe, R. Govindan, and M. Andrews. </author> <title> Support for continuous media in the dash system. </title> <type> Technical report, </type> <institution> University of California, Berkeley, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: For asynchronous applications like interactive video/teleconferencing, end-to-end delay has to be bounded and observable jitter should be avoided [TTCM92]. Because of these temporal and spatial constraints, continuous media communication requires special resource management <ref> [ATW + 89] </ref>. In order to overcome such spatial and temporal constraints of continuous communication media, a few transport protocols such as ST-II (Stream Protocol II)[ea90], SRP (Session Reservation Protocol)[ATW + 89], XTP (Express Transport Protocol)[CA90], VMTP (Versatile Message Transport Protocol)[Che87], and fast lightweight transport protocols have been proposed.
Reference: [Bak87] <author> T. Baker. </author> <title> A corset for ada. </title> <type> Technical Report 86-09-07, </type> <institution> Department of Computer Science, University of Washington, </institution> <year> 1987. </year>
Reference-contexts: Ada 9X is a revision to the Ada programming language standard [Wel92]. The reports [Inc92, QD92, Sof92] present some results of real-time implementation studies of Ada. In <ref> [BJ87, Bak87, BJ86] </ref>, the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems. Corset and Lace [BJ87, Bak87, BJ86] are runtime environment interfaces. <p> In <ref> [BJ87, Bak87, BJ86] </ref>, the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems. Corset and Lace [BJ87, Bak87, BJ86] are runtime environment interfaces. Corset is an interface specification for a compact runtime support environment for tasking for Ada. Lace is an interface specification for a low level adaptable common executive that implements a model of real-time, lightweight tasks.
Reference: [Bak90] <author> T. P. Baker. </author> <title> A stack-based resource allocation policy for real-time processes. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: Hence, YARTOS need not provide any special locking facilities for shared resources. Since tasks execute to completion in YARTOS, all tasks are executed on a single run-time stack. This improves memory utilization and reduces context switching overhead <ref> [Bak90] </ref>. 4.3.5 The ARTS Distributed Operating System ARTS [TML90, TM89a, MT90, TK88, TNR90a] is a distributed real time operating system developed in the ART (Advanced Real-time Technology) project at Carnegie Mellon University.
Reference: [BBH84] <author> F. Baccelli, P. Boyer, and G. Hebuterne. </author> <title> Single server queues with impatient customers. </title> <booktitle> Advances in Applied Probability, </booktitle> <volume> 16 </volume> <pages> 887-905, </pages> <year> 1984. </year>
Reference-contexts: The earliest work in this area was presented by Gnedenko and Kovalenko in [GK68]. They present analytic results for the ratio of rejected tasks arriving to a multiprocessor system with Poisson arrivals and tasks with known exponential computation and laxity requirements. In <ref> [BBH84] </ref>, the authors present transform solution results for tasks with arbitrary computation, laxity and arrival distributions where FCFS service is used and all task parameters are known on arrival to the queue.
Reference: [BG92] <author> T. E. Bihari and P. Gopinath. </author> <title> Object-oriented real-time systems: Concepts and examples. </title> <journal> IEEE Computer, </journal> <volume> 25(12) </volume> <pages> 25-32, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer. While the systems are not intended for commercial use, offshoots are being used in commercial robotics applications <ref> [BG92] </ref>. 4.3.10 The CTRON Operating System Framework CTRON [OWK87, WOK + 87, KOOH87, Sak89] is a part of the TRON 1 [Sak87c] platform for real-time operating systems. The general TRON project is designed for network nodes consisting of different kinds of computers.
Reference: [BJ86] <author> T. Baker and K. Jeffay. </author> <title> A lace for ada's corset. </title> <type> Technical Report 86-09-06, </type> <institution> Department of Computer Science, University of Washington, </institution> <year> 1986. </year>
Reference-contexts: Ada 9X is a revision to the Ada programming language standard [Wel92]. The reports [Inc92, QD92, Sof92] present some results of real-time implementation studies of Ada. In <ref> [BJ87, Bak87, BJ86] </ref>, the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems. Corset and Lace [BJ87, Bak87, BJ86] are runtime environment interfaces. <p> In <ref> [BJ87, Bak87, BJ86] </ref>, the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems. Corset and Lace [BJ87, Bak87, BJ86] are runtime environment interfaces. Corset is an interface specification for a compact runtime support environment for tasking for Ada. Lace is an interface specification for a low level adaptable common executive that implements a model of real-time, lightweight tasks.
Reference: [BJ87] <author> T. Baker and K. Jeffay. Corset and lace: </author> <title> Adapting ada runtime support to real-time systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1987. </year>
Reference-contexts: Ada 9X is a revision to the Ada programming language standard [Wel92]. The reports [Inc92, QD92, Sof92] present some results of real-time implementation studies of Ada. In <ref> [BJ87, Bak87, BJ86] </ref>, the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems. Corset and Lace [BJ87, Bak87, BJ86] are runtime environment interfaces. <p> In <ref> [BJ87, Bak87, BJ86] </ref>, the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems. Corset and Lace [BJ87, Bak87, BJ86] are runtime environment interfaces. Corset is an interface specification for a compact runtime support environment for tasking for Ada. Lace is an interface specification for a low level adaptable common executive that implements a model of real-time, lightweight tasks. <p> Therefore, it is easy to construct hybrid systems. Execution timing remains under control of the Lace dispatcher. Lace does not provide directly for intertask communication or memory management. Such services are provided separately, possibly using the Lace operations. In <ref> [BJ87] </ref>, the authors discuss the Corset interface and the Lace interface in detail. 4.3 The Predictable Execution of Real-time Programs Predictability includes eliminating the effects that cause variance in performance in a system.
Reference: [BKLL93] <author> Joseph Boykin, David Kirschen, Alan Langerman, and Susan LoVerso. </author> <title> Programming Under Mach. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: The initial implementation of Maruti on a network of SUN Unix workstations was followed by a partial native kernel implementation on DecStations, and is now being replaced by an implementation based on Mach <ref> [BKLL93] </ref>. 4.3.4 The YARTOS Kernel YARTOS (Yet Another Real-Time Operating System) is an operating system kernel that supports the construction of efficient, predictable, real-time systems [JSP91, Jef89b, Jef89a, Jef92]. The programming model supported by YARTOS is an extension of Wirth's discipline of real time programming [Wir77].
Reference: [Bla90] <author> David L. Black. </author> <title> Scheduling support for concurrency and parallelism in the mach operating system. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 35-43, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: RT-Mach uses an Integrated Time-Driven Scheduler (ITDS), which was developed for ARTS, and extended for RT-Mach. Mach provides processor sets (which are collections of processors available to an application), with run queues specific to processor sets <ref> [Bla90] </ref>. The ITDS scheduler extends this approach by allowing five different policies (Rate Monotonic, Fixed Priority, Round Robin, Round Robin with Deferrable Server and Round Robin with Sporadic Server) on each processor set in RT-Mach, with primitives to get and set the scheduling policy.
Reference: [BP91] <author> T. Baker and O. Pazy. </author> <title> Real-time features for ada 9x. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: In <ref> [BP91] </ref>, the authors present a brief description of some of the Ada 9X proposals that are intended to address hard real-time requirements. Ada 9X is a revision to the Ada programming language standard [Wel92]. The reports [Inc92, QD92, Sof92] present some results of real-time implementation studies of Ada.
Reference: [Bri92] <author> L. Briand. </author> <title> Time management for ada real-time systems. </title> <journal> Ada Letters, </journal> <volume> 12(5), </volume> <month> Septem-ber </month> <year> 1992. </year>
Reference-contexts: Ada 9X is a revision to the Ada programming language standard [Wel92]. The reports [Inc92, QD92, Sof92] present some results of real-time implementation studies of Ada. In [BJ87, Bak87, BJ86], the authors present the interface of a run-time environment for real-time Ada. In <ref> [Bri92] </ref>, the author deals with different possible time representations and their utilization in real-time Ada systems. Corset and Lace [BJ87, Bak87, BJ86] are runtime environment interfaces. Corset is an interface specification for a compact runtime support environment for tasking for Ada.
Reference: [BS88] <author> T. Bihari and K. Schwan. </author> <title> A comparison of four adaptation algorithms for increasing the reliability of real-time software. </title> <booktitle> In Ninth Real-Time Systems Symposium, </booktitle> <address> Huntsville, AL, </address> <pages> pages 232-241. </pages> <publisher> IEEE, </publisher> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: The adaptations specifically supported by CHAOS arc constructs are those that may be implemented as reactions to external events termed reactive adaptations, as opposed to adaptations that anticipate changes in the operating environment termed preventive adaptations <ref> [BS88, SBWT87, SGB87, GS89c] </ref>. However, programming and monitoring system support is implemented for CHAOS arc so that preventive adaptations may be performed as well. 30 On-line monitoring. Another issue addressed by the CHAOS researchers is the application--specific, on-line monitoring of running real-time programs.
Reference: [BS91a] <author> T. Bihari and K. Schwan. </author> <title> Dynamic adaptation of real-time software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 143-174, </pages> <month> May </month> <year> 1991. </year> <note> Older version available from the Department of Computer and Information Science, </note> <institution> The Ohio State University, OSU-CISRC-5/88-TR, </institution> <note> newer version available from College of Computing, </note> <institution> Georgia Institute of Technology, </institution> <address> Atlanta GA, GTRC-TR-90/67. </address>
Reference-contexts: As with earlier research in autonomous robotics, researchers instead assume the existence of alternative tasks or task sets (e.g., exception handling tasks) to be used when the deadlines of the original tasks cannot be met <ref> [BS91a, GS93] </ref>. Effects of Cycle-Stealing on Scheduling Algorithms. In [RSL87], the authors discuss the effects of cycle stealing on scheduling algorithms in a hard real-time environment. An I/O device can transfer data by direct memory access (DMA) and steal cycles from the processor and therefore from the executing task.
Reference: [BS91b] <author> Ben Blake and Karsten Schwan. </author> <title> Experimental evaluation of a real-time scheduler for a multiprocessor system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 34-44, </pages> <month> Jan. </month> <year> 1991. </year> <month> 36 </month>
Reference-contexts: Recent work in real-time scheduling addresses uniprocessor and multiprocessor systems, where scheduling must be performed on-line for both sporadic and periodic arrivals. One of the few on-line multiprocessor algorithms in the literature is an any fit algorithm proposed by Blake and Schwan <ref> [BS91b] </ref>, which offers a distributed implementation consisting of global schedulers performing the assignment of tasks to processors in cooperation with processor-local sched-ulers that carry out deadline scheduling. This algorithm is similar to algorithms developed for distributed systems, such as bidding algorithms [RS84]. This work is extended further in [ZSA91].
Reference: [CA90] <author> Protocol Engines Inc. </author> <title> CA. Xtp protocol definitions, revision 3.5. </title> <type> Technical Report PEI-90-120, </type> <month> September </month> <year> 1990. </year>
Reference: [Can91] <author> Ben J. Cantanzaro, </author> <title> editor. The SPARC Technical Papers. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Incorrect branch-prediction may result in flushing of pipelines (RISC processors often have several pipelines, each with several stages). This leads to delays due to the instruction cache being refilled. Further, register-conflicts may occur if identical resources are required by instructions close together in a pipeline <ref> [L.M90, Can91] </ref>. Similarly, while register windows speed up subroutine invocation, saving all of the windows at a context switch makes them extremely time-consuming. <p> The other windows are restored at the appropriate returns-from-subroutine later (the window-underflow trap causes the contents to be restored). VxWorks also allows the register windows (typically there are several such windows in Sparc implementations <ref> [Can91] </ref>) to be used as `register-caches', whereby a window is saved during a context switch only if loading the new context requires so.
Reference: [Che87] <author> D. R. Cheriton. Vmtp: </author> <title> Versatile message transaction protocol. </title> <type> Technical report, </type> <institution> Computer Science Department, Stanford University, </institution> <month> January </month> <year> 1987. </year>
Reference: [CL86] <author> H. Y. Chang and M. Livny. </author> <title> Scheduling under deadline costraints: A comparison of sender-initiated and receiver-initiated approaches. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1986. </year>
Reference-contexts: Most distributed scheduling algorithms have two common features [WC87]: (1) a global task sharing strategy between nodes and (2) a local scheduling policy for individual nodes. The local scheduling policy is often based on heuristics that efficiently determine which task to accept and which task to reject. In <ref> [CL86] </ref>, the authors compare a few distributed scheduling algorithms based on the means utilized to share information (i.e., the global part). In [RS84], the authors propose a heuristic for local scheduling in a distributed system called the "guarantee" routine.
Reference: [CL90] <author> Min-Ih Chen and Kwei-Jay Lin. </author> <title> Dynamic priority ceilings: A concurrency control protocol for real-time systems. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 2 </volume> <pages> 325-346, </pages> <year> 1990. </year>
Reference-contexts: He shows that optimal synchronization and scheduling disciplines exist for restricted patterns of resource usage. Predictable synchronization on multiprocessor real-time systems offers a new challenge compared to existing work on uniprocessor synchronization and scheduling <ref> [Jef89b, SRL90, CL90] </ref>. 11 In [MSZ90], Molesky, Shen and Zlokapa describe predictable algorithms for semaphores with linear waiting. Although their proposed algorithms are predictable, they do not take into account the priorities of the processes that want to acquire the semaphore.
Reference: [CL91] <author> M. Chen and K. Lin. </author> <title> A priority ceiling protocol for multiple-instance resources. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1991. </year>
Reference: [CSR88] <author> Sheng-Chang Cheng, John A. Stankovic, and Krithi Ramamritham. </author> <title> Scheduling algorithms for hard real-time systems a brief survey. </title> <booktitle> In Tutorial Hard Real-Time Systems, </booktitle> <pages> pages 150-173. </pages> <publisher> IEEE, </publisher> <year> 1988. </year>
Reference-contexts: We begin with a brief review of static scheduling, followed by a discussion of dynamic scheduling. For a more extensive review of research in static real-time scheduling, the reader may refer to <ref> [Law83, CSR88, SR93] </ref>.
Reference: [DM89] <author> Michael L. Dertouzos and Aloysius K. Mok. </author> <title> Multiprocessor on-line scheduling of hard-real-time tasks. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(12) </volume> <pages> 1497-1506, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Chen et. al.[CL91] study a priority ceiling protocol for multiple-instance resources. They present an optimal resource-allocation algorithm which can be used to improve the schedulability of a real-time system. In contrast, the Earliest Deadline First (EDF) scheduling algorithm can be used for dynamic as well as static scheduling <ref> [ZRS87b, DM89, SZ92] </ref>. This algorithm uses the deadline of a task as its priority. The task with the earliest deadline has the highest priority. Since priorities are dynamic, the periods of tasks can be changed at any time.
Reference: [ea90] <author> Topolcic et al. </author> <title> Experimental internet stream protocol, </title> <note> version 2 (st-ii). </note> <year> 1990. </year>
Reference: [FSW90] <author> Jerry Fiddler, Eric Stromberg, and David N. Wilner. </author> <title> Software considerations for real-time risc. </title> <booktitle> COMPCON Spring 1990: Thirty-Fifth IEEE Computer Society International Conference, </booktitle> <pages> pages 274-277, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: VxWorks <ref> [FSW91, FSW90, Ing91] </ref> takes the approach of saving only the register windows (on a Sparc) which are actually in use (as determined by the window invalid mask (WIM) bit of the particular window on a Sparc) by a task during a context switch.
Reference: [FSW91] <author> Jerry Fiddler, Eric Stromberg, and David N. Wilner. </author> <title> Software considerations for real-time risc. </title> <booktitle> The SPARC Technical Papers, </booktitle> <pages> pages 305-313, </pages> <year> 1991. </year>
Reference-contexts: VxWorks <ref> [FSW91, FSW90, Ing91] </ref> takes the approach of saving only the register windows (on a Sparc) which are actually in use (as determined by the window invalid mask (WIM) bit of the particular window on a Sparc) by a task during a context switch.
Reference: [FV90] <author> D. Ferrari and D. C. Verma. </author> <title> A scheme for real-time channel establishment in wide-area networks. </title> <journal> IEEE Journal on Selected Areas in Communication, </journal> <volume> 8(3), </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: The ST-II, and SRP protocols reserve system resources such as processor execution time, buffers, and network bandwidth before transmitting any data. A similar resource reservation model, a real-time channel, has been proposed for a wide area network environment <ref> [FV90] </ref>. Such reservation of resources requires significant operating system support. On the other hand, VMTP and XTP transfer data on a best-effort basis and without any resource reservation.
Reference: [Gal91] <author> D. L. Gall. </author> <title> Mpeg: A video compression standard for multimedia applications. </title> <journal> Communications of the ACM, </journal> <volume> 34(4), </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: A running continuous media application, such as full motion video, can occupy significant bandwidth of the computer resource. Although some compression schemes such as JPEG [Wal91], MPEG <ref> [Gal91] </ref>, and px64 [Lio91] have been suggested to reduce data size, high quality video frames are usually too large for a conventional local area network [TTCM92]. For asynchronous applications like interactive video/teleconferencing, end-to-end delay has to be bounded and observable jitter should be avoided [TTCM92].
Reference: [GBSG89] <author> Prabha Gopinath, Tom Bihari, Karsten Schwan, and Ahmed Gheith. </author> <title> Operating system constructs for managing real-time software complexity. </title> <booktitle> In Proceedings of 1989 Workshop on Operating Systems for Mission Critical Computing, ONR, </booktitle> <editor> Mary-land, pages U1-U9. ONR et al, </editor> <month> Sept. </month> <year> 1989. </year> <note> Also available as Philips Technical Note TN-89-110 and published by IOS Press, </note> <author> Netherlands, </author> <title> as `Mission Critical Operating Systems, Studies in Computer and Communication Systems, </title> <type> Vol.1'. </type>
Reference: [GFS93] <author> Kaushik Ghosh, Richard M. Fujimoto, and Karsten Schwan. </author> <title> A testbed for optimistic execution of real-time simulations. </title> <booktitle> Proceedings of the IEEE Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <month> April </month> <year> 1993. </year> <month> 37 </month>
Reference-contexts: Future Work Current and future work in real-time scheduling must address the highly dynamic, complex environments of large-scale real-time systems, such as national networks carrying time-constrained communications (e.g., multi-media applications like real-time video transmission [TTCM92] or collaboration systems [HK88]), or large-scale theater battle management systems [MS93], or large-scale real-time simulations <ref> [GFS93] </ref>. As a result, researchers are now primarily addressing on-line scheduling, scheduling for parallel and distributed systems [ZSA91, SZG91], and the semantics of timing constraints to be enforced in such future systems (e.g., hard deadlines are simply neither needed nor feasible as a formulation of timing constraints in multi-media applications).
Reference: [GGSW88] <author> Ahmed Gheith, Prabha Gopinath, Karsten Schwan, and Peter Wiley. </author> <title> Chaos and chaos-art: Extensions to an object-based kernel. </title> <booktitle> In IEEE Computer Society Fifth Workshop on Real-Time Operating Systems, </booktitle> <address> Washington, D.C. </address> <publisher> IEEE, </publisher> <month> April </month> <year> 1988. </year>
Reference: [GJ77] <author> M. R. Garey and D. S. Johnson. </author> <title> Two-processor scheduling with start-times and deadlines. </title> <journal> SIAM Journal of Computing, </journal> <volume> 6(3), </volume> <year> 1977. </year>
Reference-contexts: It is also shown that an optimal scheduler cannot be found for multiprocessors unless a priori knowledge exists of the deadlines, computation times and arrival times of all the tasks. In <ref> [GJ77] </ref>, the authors show that even for a single processor, constructing a schedule with arbitrary arrival, computation and laxity requirements is an NP-complete problem. 2 In a hard real-time environment, a task which expires while in the queue is discarded and not considered for service, whereas in a soft real time
Reference: [GK68] <author> B. V. Gnedeko and L. N. Kovalenko. </author> <title> Elements of queueing theory. </title> <booktitle> In Israel Program for Scientific Research, </booktitle> <year> 1968. </year>
Reference-contexts: For tasks with hard real-time deadlines, results are limited to FCFS service. The earliest work in this area was presented by Gnedenko and Kovalenko in <ref> [GK68] </ref>. They present analytic results for the ratio of rejected tasks arriving to a multiprocessor system with Poisson arrivals and tasks with known exponential computation and laxity requirements.
Reference: [GMAT90] <author> O. Gudmundsson, D. Mosse, A. Agrawala, and S. Tripathi. Maruti: </author> <title> A hard real-time operating system. </title> <booktitle> In Second IEEE Workshop on Experimantal Distributed Systems, </booktitle> <pages> pages 29-34, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: This results in somewhat inflexible process scheduling because prematurely finishing processes cannot relinquish their extra execution time to other processes [SZ92]. 4.3.3 The Maruti Distributed Real-Time Operating System The main focus of the Maruti project <ref> [GMAT90, Agr90, AL87, MA90, YA89, LA90] </ref> at the University of Maryland is to examine the constructs of future distributed, hard real-time, fault tolerant, secure operating systems. Maruti is an object-based system, with encapsulation of services.
Reference: [Gop88] <author> Prabha Gopinath. </author> <title> Programming and Execution of Object-Based, Parallel, Hard Real-Time Applications. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Sciences, The Ohio State University, </institution> <month> June </month> <year> 1988. </year>
Reference: [GS89a] <author> Ahmed Gheith and Karsten Schwan. Chaos-art: </author> <title> Kernel support for atomic transactions in real-time applications. </title> <booktitle> In Nineteenth International Symposium on Fault-Tolerant Computing, </booktitle> <address> Chicago, </address> <publisher> ILL, </publisher> <pages> pages 462-469, </pages> <month> June </month> <year> 1989. </year> <note> Also see GIT-ICS-90/06, </note> <institution> College of Computing, Georgia Tech, </institution> <address> Atlanta, GA 30332. </address>
Reference-contexts: complete within well-defined timing constraints typically captured by execution deadlines, and (2) programs must exhibit predictable behavior in the presence of uncertain operating environments. (2) is achieved by provision of operating system constructs that may be used to guarantee desired performance and functionality levels of selected computations in real-time applications <ref> [GS89a] </ref> termed atomic,real-time computations. These constructs implemented by the CHAOS arc object-based operating system kernel provides constructs that deal with uncertainty by allowing programs to be adaptable (i.e., changeable at run-time) in performance and functionality to varying operating conditions.
Reference: [GS89b] <author> Ahmed Gheith and Karsten Schwan. Chaosart: </author> <title> A predictable real-time kernel. In Butterfly Users Group Meeting, BBN Advanced Computers INc., </title> <address> Rochester, NY, </address> <month> April </month> <year> 1989. </year> <note> Talk abstracts do not appear in proceedings. </note>
Reference: [GS89c] <author> Prabha Gopinath and Karsten Schwan. </author> <title> Chaos: Why one cannot have only an operating system for real-time applications. </title> <journal> SIGOPS Notices, </journal> <pages> pages 106-125, </pages> <month> July </month> <year> 1989. </year> <note> Also available as Philips Technical Note TN-89-006. </note>
Reference-contexts: The adaptations specifically supported by CHAOS arc constructs are those that may be implemented as reactions to external events termed reactive adaptations, as opposed to adaptations that anticipate changes in the operating environment termed preventive adaptations <ref> [BS88, SBWT87, SGB87, GS89c] </ref>. However, programming and monitoring system support is implemented for CHAOS arc so that preventive adaptations may be performed as well. 30 On-line monitoring. Another issue addressed by the CHAOS researchers is the application--specific, on-line monitoring of running real-time programs.
Reference: [GS93] <author> Ahmed Gheith and Karsten Schwan. </author> <title> Chaos-arc kernel support for multi-weight objects, invocations, and atomicity in real-time applications. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(1) </volume> <pages> 33-72, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: As with earlier research in autonomous robotics, researchers instead assume the existence of alternative tasks or task sets (e.g., exception handling tasks) to be used when the deadlines of the original tasks cannot be met <ref> [BS91a, GS93] </ref>. Effects of Cycle-Stealing on Scheduling Algorithms. In [RSL87], the authors discuss the effects of cycle stealing on scheduling algorithms in a hard real-time environment. An I/O device can transfer data by direct memory access (DMA) and steal cycles from the processor and therefore from the executing task. <p> Our work is best summarized as `research addressing the configurability and adaptability of operating system kernels'. Our initial work addressed the process and then object levels of real-time software (the CHAOS systems <ref> [SGB87, GS93] </ref>), whereas our current work is addressing configurability and adaptability at the threads level. 13 4.2 Ada-supporting Runtime Systems A continuing, DoD-induced thrust in current research on real-time systems is to design and build run-time support for real-time Ada. <p> Objects in ARTS are much like those developed earlier in the CHAOS systems <ref> [SGB87, GS93] </ref>; they can be passive or active. An active object contains one or more user defined threads. In the active object, the designer of the object is responsible for providing concurrency control among co-executing operations.
Reference: [HFC76] <author> A. Habermann, L. Flon, and L. Cooprider. </author> <title> Modularization and hierarchy in a family of operating systems. </title> <journal> Communications of the ACM, </journal> <volume> 19 </volume> <pages> 266-72, </pages> <year> 1976. </year>
Reference-contexts: Extensibility and customizability of the family are attained by use of the object model for description of the operating system's interface <ref> [SGB87, HFC76] </ref> and for operating system and user program implementation. Each application program is composed of a number of user objects, which use system-defined objects to access operating system services. <p> However, as opposed to other object-based operating system kernels [SGB87] and in order to attain extensibility and customizability, family members do not describe their system interfaces by exporting some system objects (i.e., their classes <ref> [HFC76] </ref>). Instead, the exported object classes are refined a novel abstraction supported by CHAOS min : attributes. CHAOS min is the lowest-level object-based member of the kernel family. Attributes are abstract properties that can be associated with classes, objects, object states, operations, and invocations.
Reference: [HK88] <author> Scott E. Hudson and Roger King. </author> <title> The cactis project: Database support for software environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(6) </volume> <pages> 705-719, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: presented to demonstrate the effectiveness and practicality of the proposed algorithms. 2.3 Future Work Current and future work in real-time scheduling must address the highly dynamic, complex environments of large-scale real-time systems, such as national networks carrying time-constrained communications (e.g., multi-media applications like real-time video transmission [TTCM92] or collaboration systems <ref> [HK88] </ref>), or large-scale theater battle management systems [MS93], or large-scale real-time simulations [GFS93].
Reference: [HKL91] <author> M. Harbour, M. Klein, and J. Lehoczky. </author> <title> Fixed priority scheduling of periodic tasks with varying execution priority. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: Among the problems with RM algorithms is their lack of support for dynamically changing periods, and that their schedulable bound 1 is less than 100%, which are being addressed [SSL89, SLS88]. In <ref> [HKL91] </ref>, the authors consider the problem of fixed priority scheduling of periodic tasks where each task's execution priority may vary. A method for determining the schedulability of each task is presented.
Reference: [HS91] <author> C. Hou and K. Shin. </author> <title> Load sharing with consideration of future task arrivals in heterogenous distributed real-time systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1991. </year> <month> 38 </month>
Reference-contexts: CPU utilization appears to be similar for the LLF, EDD, GM and MM algorithms and for the FCFS and SJF algorithms. In <ref> [HS91] </ref>, Hou, Shin, et. al. propose a load sharing algorithm for real-time applications which takes into account the effect of future task arrivals on locating the best receiver for each un-guaranteed task in a heterogeneous distributed environment. <p> While the OS offers fairly standard primitives, its novel attributes are its support for special communication protocols addressing multi-media applications and its rigorous study of on-line scheduling for distributed memory machines (e.g., sets of workstations), including machines used in manufacturing environments <ref> [HS91, HS92] </ref>. 4.3.8 The Alpha Operating System Alpha [JN90a, JN90b, NCS + 90] is a non-proprietary operating system for large, complex, distributed real-time systems. Alpha arose from the Archons Project at Carnegie Mellon University, which offered a partially implemented prototype operational in 1987.
Reference: [HS92] <author> Chao-Ju Hou and Kang G. Shin. </author> <title> Allocation of periodic task modules with prece-dence and deadline constraints in distributed real-time systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: In [HS91], Hou, Shin, et. al. propose a load sharing algorithm for real-time applications which takes into account the effect of future task arrivals on locating the best receiver for each un-guaranteed task in a heterogeneous distributed environment. This work is extended in <ref> [HS92] </ref>, where the authors address the problem of allocating (assigning and scheduling) periodic task modules to processing nodes (PNs) in distributed real-time systems subject to 9 task precedence and timing constraints. <p> While the OS offers fairly standard primitives, its novel attributes are its support for special communication protocols addressing multi-media applications and its rigorous study of on-line scheduling for distributed memory machines (e.g., sets of workstations), including machines used in manufacturing environments <ref> [HS91, HS92] </ref>. 4.3.8 The Alpha Operating System Alpha [JN90a, JN90b, NCS + 90] is a non-proprietary operating system for large, complex, distributed real-time systems. Alpha arose from the Archons Project at Carnegie Mellon University, which offered a partially implemented prototype operational in 1987.
Reference: [Inc92] <author> Tartan Inc. </author> <title> Evaluation of the implementation of multi-way select and the asynchronous transfer of control constructs. Technical Report LSN-039-UI, Ada 9X Language Study Note, </title> <month> March </month> <year> 1992. </year>
Reference-contexts: In [BP91], the authors present a brief description of some of the Ada 9X proposals that are intended to address hard real-time requirements. Ada 9X is a revision to the Ada programming language standard [Wel92]. The reports <ref> [Inc92, QD92, Sof92] </ref> present some results of real-time implementation studies of Ada. In [BJ87, Bak87, BJ86], the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems.
Reference: [Ing91] <author> Kim Ingram. </author> <title> Sparc for real-time applications. </title> <booktitle> The SPARC Technical Papers, </booktitle> <pages> pages 313-321, </pages> <year> 1991. </year>
Reference-contexts: VxWorks <ref> [FSW91, FSW90, Ing91] </ref> takes the approach of saving only the register windows (on a Sparc) which are actually in use (as determined by the window invalid mask (WIM) bit of the particular window on a Sparc) by a task during a context switch.
Reference: [ITM92] <author> Y. Ishikawa, H. Tokuda, and C. Mercer. </author> <title> An object-oriented real-time programming language. </title> <journal> IEEE Computer, </journal> <volume> 25(10) </volume> <pages> 66-73, </pages> <month> October </month> <year> 1992. </year>
Reference: [Jef89a] <author> K. Jeffay. </author> <title> Analysis of a synchronization and scheduling discipline for real-time tasks with preemption constraints. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 295-305, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: of SUN Unix workstations was followed by a partial native kernel implementation on DecStations, and is now being replaced by an implementation based on Mach [BKLL93]. 4.3.4 The YARTOS Kernel YARTOS (Yet Another Real-Time Operating System) is an operating system kernel that supports the construction of efficient, predictable, real-time systems <ref> [JSP91, Jef89b, Jef89a, Jef92] </ref>. The programming model supported by YARTOS is an extension of Wirth's discipline of real time programming [Wir77]. It is a message passing system with a semantics of inter-process communication that specifies the real-time response that an operating system must provide to a message receiver.
Reference: [Jef89b] <author> K. Jeffay. </author> <title> The Real-Time Producer/Consumer Paradigm: Towards Verifiable Real-Time Computations. </title> <type> PhD thesis, </type> <institution> University of Washington, Department of Computer Science, </institution> <year> 1989. </year>
Reference-contexts: However, the priority ceiling protocol cannot be directly used when priorities are dynamic. This is addressed by the recent work of M. Chen et al.[CL90] who have extended the original priority ceiling protocol to one which is able to handle dynamic priorities. For uniprocessor systems, Jeffay <ref> [Jef89b] </ref> develops schedulability conditions for a set of sporadic tasks that each consist of a sequence of phases each of which may require access to at most one shared resource. In his analysis, tasks' timing constraints as well as resource requirements are assumed to be known beforehand. <p> He shows that optimal synchronization and scheduling disciplines exist for restricted patterns of resource usage. Predictable synchronization on multiprocessor real-time systems offers a new challenge compared to existing work on uniprocessor synchronization and scheduling <ref> [Jef89b, SRL90, CL90] </ref>. 11 In [MSZ90], Molesky, Shen and Zlokapa describe predictable algorithms for semaphores with linear waiting. Although their proposed algorithms are predictable, they do not take into account the priorities of the processes that want to acquire the semaphore. <p> of SUN Unix workstations was followed by a partial native kernel implementation on DecStations, and is now being replaced by an implementation based on Mach [BKLL93]. 4.3.4 The YARTOS Kernel YARTOS (Yet Another Real-Time Operating System) is an operating system kernel that supports the construction of efficient, predictable, real-time systems <ref> [JSP91, Jef89b, Jef89a, Jef92] </ref>. The programming model supported by YARTOS is an extension of Wirth's discipline of real time programming [Wir77]. It is a message passing system with a semantics of inter-process communication that specifies the real-time response that an operating system must provide to a message receiver. <p> These semantics provide a framework both for expressing processor-time dependent computations and for reasoning about the real-time behavior of programs. The YARTOS programming model is described in detail in <ref> [Jef89b] </ref>. YARTOS supports two basic abstractions: tasks and resources. A task is an independent thread of control that is invoked at sporadic intervals. The invocation intervals and deadlines for a task are derived from constructs in the higher level programming model. During execution, a task accesses a number of resources.
Reference: [Jef92] <author> Kevin Jeffay. </author> <title> Scheduling sporadic tasks with shared resources in hard-real-time systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <year> 1992. </year> <note> Also as Technical Report TR90-038, </note> <institution> Department of Computer Science,University of North Carolina at Chapel Hill. </institution>
Reference-contexts: The other fixed priority, called user priority, has lower precedence than the task's dynamic priority. The idea is to use user-specified notions of `priority' to help on-line algorithms distinguish more important from less important tasks. In <ref> [Jef92] </ref> an optimal algorithm is presented for scheduling a set of sporadic tasks that share a set of serially reusable, single unit resources such that tasks complete executions before a deadline and resources are accessed sequentially. The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. <p> of SUN Unix workstations was followed by a partial native kernel implementation on DecStations, and is now being replaced by an implementation based on Mach [BKLL93]. 4.3.4 The YARTOS Kernel YARTOS (Yet Another Real-Time Operating System) is an operating system kernel that supports the construction of efficient, predictable, real-time systems <ref> [JSP91, Jef89b, Jef89a, Jef92] </ref>. The programming model supported by YARTOS is an extension of Wirth's discipline of real time programming [Wir77]. It is a message passing system with a semantics of inter-process communication that specifies the real-time response that an operating system must provide to a message receiver.
Reference: [JLT85] <author> E. D. Jansen, C. D. Locke, and H. Tokuda. </author> <title> A time-driven scheduling model for real-time operating systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1985. </year>
Reference-contexts: an NP-complete problem. 2 In a hard real-time environment, a task which expires while in the queue is discarded and not considered for service, whereas in a soft real time environment, such a task is retained in the queue and is still eligible for service. 5 The performance study in <ref> [JLT85] </ref> of various classical scheduling algorithms also considers situations where computation times are not exactly known at the time of task arrival, but have some given, known distributions. The study then introduces the notion of value function that specifies the value of completing a task at any time after arrival.
Reference: [JN90a] <author> E. Jensen and J. Northcutt. </author> <title> Alpha: A non-proprietary os for large, complex, distributed real-time systems. </title> <booktitle> In Second IEEE Workshop on Experimental Distributed Systems, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: While the OS offers fairly standard primitives, its novel attributes are its support for special communication protocols addressing multi-media applications and its rigorous study of on-line scheduling for distributed memory machines (e.g., sets of workstations), including machines used in manufacturing environments [HS91, HS92]. 4.3.8 The Alpha Operating System Alpha <ref> [JN90a, JN90b, NCS + 90] </ref> is a non-proprietary operating system for large, complex, distributed real-time systems. Alpha arose from the Archons Project at Carnegie Mellon University, which offered a partially implemented prototype operational in 1987. Versions now run on Sun, Concurrent, and SGI hardware.
Reference: [JN90b] <author> E. Jensen and J. Northcutt. </author> <title> Alpha: An open operating system for mission-critical real-time distributed systems an overview. </title> <booktitle> In Proceedings of the 1989 Workshop on Operating Systems for Mission-Critical Computing, </booktitle> <year> 1990. </year>
Reference-contexts: While the OS offers fairly standard primitives, its novel attributes are its support for special communication protocols addressing multi-media applications and its rigorous study of on-line scheduling for distributed memory machines (e.g., sets of workstations), including machines used in manufacturing environments [HS91, HS92]. 4.3.8 The Alpha Operating System Alpha <ref> [JN90a, JN90b, NCS + 90] </ref> is a non-proprietary operating system for large, complex, distributed real-time systems. Alpha arose from the Archons Project at Carnegie Mellon University, which offered a partially implemented prototype operational in 1987. Versions now run on Sun, Concurrent, and SGI hardware.
Reference: [JSP91] <author> K. Jeffay, D. Stone, and D. Poirier. Yartos: </author> <title> Kernel support for efficient, predictable real-time systems. </title> <booktitle> In Eighth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 8-12, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: of SUN Unix workstations was followed by a partial native kernel implementation on DecStations, and is now being replaced by an implementation based on Mach [BKLL93]. 4.3.4 The YARTOS Kernel YARTOS (Yet Another Real-Time Operating System) is an operating system kernel that supports the construction of efficient, predictable, real-time systems <ref> [JSP91, Jef89b, Jef89a, Jef92] </ref>. The programming model supported by YARTOS is an extension of Wirth's discipline of real time programming [Wir77]. It is a message passing system with a semantics of inter-process communication that specifies the real-time response that an operating system must provide to a message receiver.
Reference: [KM92] <author> Tei-Wei Kuo and Aloysius K. Mok. </author> <title> Application semantics and concurrency control of real-time data-intensive applications. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: With 8 banks near-optimal performance is obtained. In [KS92], the authors present an optimal on-line scheduling algorithm for overloaded systems. In <ref> [KM92] </ref>, the semantics of data-intensive real-time applications are discussed. By examining the semantics of these applications, the concept of similarity is formed, which has been used on an ad hoc basis by application engineers to provide more flexibility in concurrency control.
Reference: [KMTD86] <author> Korein, Maier, Taylor, and Durfee. </author> <title> A configurable system for automation programming and control. </title> <booktitle> In IEEE International Conference on Robotics and Automation, </booktitle> <address> San Francisco, CA, </address> <pages> pages 1871-1877. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1986. </year> <month> 39 </month>
Reference-contexts: The operating system appears to focus on support for on-line scheduling, in part targeting applications in autonomous robot control <ref> [KMTD86] </ref> and for multi-media applications. Its implementation is being performed on SUN 3 processor using the X-kernel communication software from the Univ. of Arizona [PHOA89].
Reference: [KNT92] <author> Takuro Kitayama, , Tatsuo Nakajima, and Hideyuki Tokuda. Rt-ipc: </author> <title> An ipc exten-sion for real-time mach. </title> <booktitle> Proceedings of the USENIX Symposium on Micro-Kernel and Other Kernel Architectures, </booktitle> <pages> pages 91-104, </pages> <year> 1992. </year>
Reference-contexts: Essentially a fallout of the ARTS work, RT-Mach chiefly addresses the real-time aspects of threads [TNR90b], synchronization [TN91], interpro-cess communication (IPC) <ref> [KNT92] </ref>, a real-time toolset for system design and analysis, and some other mechanisms to allow greater predictability, as mentioned at the beginning of section 4.3. In addition, Nakajima et. al. [NYM92] address extensions to Mach for multimedia applications. <p> there must exist primitives to propagate priorities from the sender of a message to the receiver and mechanisms to inherit priorities from the sender to the receiver of a message (otherwise, the processing of a message, or the receiving of a message by a server, might be interrupted or delayed <ref> [KNT92] </ref>). Further, since there may be multiple receivers in a server, a decision has to be made about which recipient thread should process an incoming message. Message buffers in RT-Mach are allocated before communication is initiated. This reduces unpredictable buffer allocation delays.
Reference: [KOOH87] <author> I. Kogiku, T. Ohrui, T. Ohkuba, and Y. </author> <title> Hamada. A real-time portable operating system common to switching and information processing applications. </title> <booktitle> In Proc. International Switching Symposium, </booktitle> <pages> pages 308-312, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer. While the systems are not intended for commercial use, offshoots are being used in commercial robotics applications [BG92]. 4.3.10 The CTRON Operating System Framework CTRON <ref> [OWK87, WOK + 87, KOOH87, Sak89] </ref> is a part of the TRON 1 [Sak87c] platform for real-time operating systems. The general TRON project is designed for network nodes consisting of different kinds of computers.
Reference: [KS91] <author> Carol Kilpatrick and Karsten Schwan. </author> <title> Chaosmon - application-specific monitoring and display of performance information for parallel and distributed systems. </title> <booktitle> In ACM Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 57-67. </pages> <booktitle> ACM SIG-PLAN Notices, </booktitle> <volume> Vol. 26, No. 12, </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: Another issue addressed by the CHAOS researchers is the application--specific, on-line monitoring of running real-time programs. The purpose of such monitoring is to use monitor data to adapt running programs in performance and functionality to changing external execution environments. The ideas presented in <ref> [KSO90, KS91, OSS90] </ref> are now being integrated into the lowest layers of CHAOS, thereby permitting implementors of specific abstractions at the threads or object levels [Muk91]. The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer.
Reference: [KS92] <author> G. Koren and D. Shasah. D-over: </author> <title> an optimal on-line scheduling algorithm for overloaded real-time systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: When both I/O in the DMA controller and computation tasks in the processor are schedulable, the provision of only 4 banks of low-bit interleaved memory can lead to significant improvement in performance. With 8 banks near-optimal performance is obtained. In <ref> [KS92] </ref>, the authors present an optimal on-line scheduling algorithm for overloaded systems. In [KM92], the semantics of data-intensive real-time applications are discussed.
Reference: [KSC86] <author> J. F. Kurose, S. Singh, and R. Chipalkatti. </author> <title> A study of quasi-dynamic load sharing in soft real-time distributed computer systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1986. </year>
Reference-contexts: In [BBH84], the authors present transform solution results for tasks with arbitrary computation, laxity and arrival distributions where FCFS service is used and all task parameters are known on arrival to the queue. The authors in <ref> [KSC86] </ref> extend analytic results for an elementary load sharing algorithm with tasks of fixed laxity and a fixed delay in node sharing, again assuming a FCFS local scheduling algorithm.
Reference: [KSO90] <author> Carol Kilpatrick, Karsten Schwan, and David Ogle. </author> <title> Using languages for describing capture, analysis, and display of performance information for parallel and distributed applications. </title> <booktitle> In International Conference on Computer Languages `90, </booktitle> <address> New Orleans, </address> <pages> pages 180-189. </pages> <publisher> IEEE, </publisher> <month> March </month> <year> 1990. </year>
Reference-contexts: Another issue addressed by the CHAOS researchers is the application--specific, on-line monitoring of running real-time programs. The purpose of such monitoring is to use monitor data to adapt running programs in performance and functionality to changing external execution environments. The ideas presented in <ref> [KSO90, KS91, OSS90] </ref> are now being integrated into the lowest layers of CHAOS, thereby permitting implementors of specific abstractions at the threads or object levels [Muk91]. The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer.
Reference: [KTKS87] <author> M. Kobayashi, S. Takenouchi, Y. Kushiki, and K. Sakamura. </author> <title> The software structure of extended nucleus based on btron specification. </title> <booktitle> In Proc. Fall Joint Computer Conference on Exploring Technology:Today and Tomorrow, </booktitle> <month> October </month> <year> 1987. </year>
Reference-contexts: To accommodate such varied requirements, the operating system interface is divided into two 1 This project studies the operating system interfaces/requirements for real-time processing. This project consists of several sub-projects, including ITRON [Mon87] for industrial embedded systems, BTRON <ref> [Sak87b, KTKS87] </ref> for business workstations, TRON CHIP [Sak87a] for a microprocessor used in the ITRON and BTRON, etc. 31 classes: (1) interfaces that can be used for all applications and (2) interfaces that are used selectively for specific applications.
Reference: [LA87] <author> S. Levi and A. Agrawala. </author> <title> Temporal relations and structures in real-time operating systems. </title> <type> Technical Report CS-TR-1954, </type> <institution> Department of Computer Science, University of Maryland, </institution> <year> 1987. </year>
Reference-contexts: In Maruti, each application is described in terms of a computation graph, which is a rooted directed acyclic graph. The vertices represent services and the arcs depict timing and data precedence between two vertices <ref> [LA87] </ref>. Objects communicate with one another by semantic links. Such links perform range and type checking of the information. Objects that reside in different sites needs agents as representatives on remote sites. Maruti is organized in three distinct levels: the kernel, the supervisor, and the application level.
Reference: [LA90] <author> Shem-Tov Levi and Ashok K. Agrawala. </author> <title> Real Time System Design. </title> <publisher> McGraw Hill, </publisher> <year> 1990. </year>
Reference-contexts: This results in somewhat inflexible process scheduling because prematurely finishing processes cannot relinquish their extra execution time to other processes [SZ92]. 4.3.3 The Maruti Distributed Real-Time Operating System The main focus of the Maruti project <ref> [GMAT90, Agr90, AL87, MA90, YA89, LA90] </ref> at the University of Maryland is to examine the constructs of future distributed, hard real-time, fault tolerant, secure operating systems. Maruti is an object-based system, with encapsulation of services.
Reference: [Law81] <author> E. Lawler. </author> <title> Scheduling periodically occuring tasks on multiprocessors. </title> <journal> Information Processing Letters, </journal> <volume> 12(1) </volume> <pages> 9-12, </pages> <month> February </month> <year> 1981. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive <ref> [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] </ref> and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems.
Reference: [Law83] <author> E. L. Lawler. </author> <title> Recent results in the theory of machine scheduling. </title> <editor> In A. Bachem et. al., editor, </editor> <booktitle> Mathematical Programming: The Staet of the Art, </booktitle> <pages> pages 202-233. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: We begin with a brief review of static scheduling, followed by a discussion of dynamic scheduling. For a more extensive review of research in static real-time scheduling, the reader may refer to <ref> [Law83, CSR88, SR93] </ref>.
Reference: [Lei80] <author> D. W. Leinbaugh. </author> <title> Guaranteed response time in a hard real-time environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January </month> <year> 1980. </year>
Reference-contexts: A scheduling algorithm jointly schedules all periodic and sporadic tasks so that the timing requirements (such as deadlines, execution rates, etc.) for both sets of tasks are met. Most popular among static algorithms are the cyclic schedulers, and more recently, the Rate Monotonic (RM) algorithms <ref> [Lei80] </ref>, in part because they are easily mapped to priority 3 based low-level task schedulers. The basic idea of the rate monotonic algorithm is to assign fixed priorities to tasks with different execution rates, highest priority being assigned to the highest frequency tasks, lowest priority to the lowest frequency task. <p> The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] and non-preemptive <ref> [Lei80, LY82, ZRS87a] </ref> scheduling algorithms extensively in the context of real-time systems. In [LL73], the authors show that the rate-monotonic and earliest deadline scheduling algorithms are optimal static priority and dynamic priority scheduling algorithms respectively, in a uni-processor preemptive scheduling environment.
Reference: [Lio91] <author> M. Liou. </author> <title> Overview of the px64 kbit/s video coding standard. </title> <journal> Communications of the ACM, </journal> <volume> 34(4), </volume> <month> April </month> <year> 1991. </year> <month> 40 </month>
Reference-contexts: A running continuous media application, such as full motion video, can occupy significant bandwidth of the computer resource. Although some compression schemes such as JPEG [Wal91], MPEG [Gal91], and px64 <ref> [Lio91] </ref> have been suggested to reduce data size, high quality video frames are usually too large for a conventional local area network [TTCM92]. For asynchronous applications like interactive video/teleconferencing, end-to-end delay has to be bounded and observable jitter should be avoided [TTCM92].
Reference: [LL73] <author> C. W. Liu and J.W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard real time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive <ref> [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] </ref> and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. <p> Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. In <ref> [LL73] </ref>, the authors show that the rate-monotonic and earliest deadline scheduling algorithms are optimal static priority and dynamic priority scheduling algorithms respectively, in a uni-processor preemptive scheduling environment. In [Mok83], the author proves that the slack-time algorithm is optimal, as well. <p> The sequencing algorithm for tasks is a variation of the well-known earliest deadline first (EDF) scheduling algorithm; a preemptive priority driven scheduling algorithm with dynamic priority assignment <ref> [LL73] </ref>. The novel feature of the algorithm is its dynamic manipulation of the deadlines task invocations to ensure that the tasks maintain exclusive access to whatever shared resources they might be accessing. This manipulation of deadlines ensures that there will exist no contention for shared resources at run-time.
Reference: [LLN87] <author> J. Liu, K. Lin, and S. Natarajan. </author> <title> Scheduling real-time, periodic jobs using imprecise results. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 252-260, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: When time is limited, one can terminate the process before it completes a sufficient number of iterations. The result produced by a prematurely terminated process may be not as precise as desired, but it may still be acceptable, and therefore, can be used by the application. In <ref> [LLN87] </ref>, the authors discuss a formulation of this problem taking into the account the quality of the overall result. A few scheduling algorithms for such computations are also presented in the paper.
Reference: [LM80] <author> J. Y. Leung and M. L. Merrill. </author> <title> A note on preemptive scheduling of periodic, real time tasks. </title> <journal> Information Processing Letters, </journal> <volume> 11(3) </volume> <pages> 115-118, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive <ref> [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] </ref> and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems.
Reference: [L.M90] <author> L.M.Thompson. </author> <title> Using psos+ for embedded real-time computing. </title> <booktitle> COMPCON Spring 1990: Thirty-Fifth IEEE Computer Society International Conference, </booktitle> <pages> pages 282-288, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Incorrect branch-prediction may result in flushing of pipelines (RISC processors often have several pipelines, each with several stages). This leads to delays due to the instruction cache being refilled. Further, register-conflicts may occur if identical resources are required by instructions close together in a pipeline <ref> [L.M90, Can91] </ref>. Similarly, while register windows speed up subroutine invocation, saving all of the windows at a context switch makes them extremely time-consuming. <p> circumstances, interrupts need not restore any register window to switch in the interrupt-handler's context, unless the level of nesting of interrupts gets too large. pSOS, on the other hand, takes the approach of building `standard' building blocks for real-time operating systems (e.g., kernels, debuggers, monitors etc.) on several hardware platforms <ref> [L.M90] </ref>. It was intended as a `plug-in operating system' that could be readily used by real-time software implementors. pSOS is position-independent binary in which `system software' is accessed through traps.
Reference: [LY82] <author> D. W. Leinbaugh and M. Yamini. </author> <title> Guaranteed response time in a distributed hard real-time environment. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1982. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] and non-preemptive <ref> [Lei80, LY82, ZRS87a] </ref> scheduling algorithms extensively in the context of real-time systems. In [LL73], the authors show that the rate-monotonic and earliest deadline scheduling algorithms are optimal static priority and dynamic priority scheduling algorithms respectively, in a uni-processor preemptive scheduling environment.
Reference: [MA90] <author> D. Mosse and A. Agrawala. </author> <title> On fault tolerance in real-time environments. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Maryland, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: This results in somewhat inflexible process scheduling because prematurely finishing processes cannot relinquish their extra execution time to other processes [SZ92]. 4.3.3 The Maruti Distributed Real-Time Operating System The main focus of the Maruti project <ref> [GMAT90, Agr90, AL87, MA90, YA89, LA90] </ref> at the University of Maryland is to examine the constructs of future distributed, hard real-time, fault tolerant, secure operating systems. Maruti is an object-based system, with encapsulation of services.
Reference: [Mar91] <author> E. P. Markatos. </author> <title> Multiprocessor synchronization primitives with priorities. </title> <booktitle> In Eighth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 1-7, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Anderson [And90] and Mellor-Crummey and Scott [MCS91] derived spin lock implementations that service lock requests in FIFO order and may be useful for real time systems. In <ref> [Mar91] </ref>, the author defines a synchronization mechanism, called a priority spin lock, and sug 12 gests implementations of such locks with local spinning. A priority spin lock has a priority ordering property.
Reference: [MCS91] <author> J. Mellor-Crummey and M. Scott. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(1) </volume> <pages> 21-65, </pages> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: As a result, the application program or higher-level operating system software can deal with such failures in a timely manner, by acquisition of alternative resources, by execution of exception handling code, etc. Anderson [And90] and Mellor-Crummey and Scott <ref> [MCS91] </ref> derived spin lock implementations that service lock requests in FIFO order and may be useful for real time systems. In [Mar91], the author defines a synchronization mechanism, called a priority spin lock, and sug 12 gests implementations of such locks with local spinning.
Reference: [MD78] <author> A. K. Mok and M. L. Dertouzos. </author> <title> Multiprocessor scheduling in a hard real-time environment. </title> <booktitle> In Proceeding of The Seventh Texas Conference on Computer Systems, </booktitle> <month> November </month> <year> 1978. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive <ref> [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] </ref> and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. <p> In [LL73], the authors show that the rate-monotonic and earliest deadline scheduling algorithms are optimal static priority and dynamic priority scheduling algorithms respectively, in a uni-processor preemptive scheduling environment. In [Mok83], the author proves that the slack-time algorithm is optimal, as well. In <ref> [MD78] </ref>, the authors define an optimal runtime scheduler for the hard real-time environment 2 as one which is able to meet all task deadlines, provided that such an algorithm exists.
Reference: [Mok83] <author> A. K. Mok. </author> <title> Fundamental Design Problems of Distributed Systems for the Hard Real Time Environment. </title> <type> PhD thesis, </type> <institution> M.I.T., </institution> <year> 1983. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive <ref> [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] </ref> and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. <p> In [LL73], the authors show that the rate-monotonic and earliest deadline scheduling algorithms are optimal static priority and dynamic priority scheduling algorithms respectively, in a uni-processor preemptive scheduling environment. In <ref> [Mok83] </ref>, the author proves that the slack-time algorithm is optimal, as well. In [MD78], the authors define an optimal runtime scheduler for the hard real-time environment 2 as one which is able to meet all task deadlines, provided that such an algorithm exists. <p> An important problem that arises in this context is the effect of blocking caused by the need for synchronization among tasks that require exclusive access to shared logical or physical resources. Mok <ref> [Mok83] </ref> showed that the addition of mutual exclusion requirements in real-time programs makes the general scheduling problem an NP-hard problem. For uniprocessor systems running periodic tasks, two recent protocols provide effective solutions to the scheduling problem with resource sharing. They are the kernelized monitor protocol [Mok83] and the priority ceiling protocol <p> Mok <ref> [Mok83] </ref> showed that the addition of mutual exclusion requirements in real-time programs makes the general scheduling problem an NP-hard problem. For uniprocessor systems running periodic tasks, two recent protocols provide effective solutions to the scheduling problem with resource sharing. They are the kernelized monitor protocol [Mok83] and the priority ceiling protocol [SRL90]. In the kernelized monitor protocol, the earliest deadline first scheduling policy is used for task scheduling. All executions in critical sections are nonpreemptable.
Reference: [Mon87] <author> H. Monden. </author> <title> Introduction to itron, </title> <booktitle> the industry-oriented operating system. IEEE Micro, </booktitle> <pages> pages 53-65, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: To accommodate such varied requirements, the operating system interface is divided into two 1 This project studies the operating system interfaces/requirements for real-time processing. This project consists of several sub-projects, including ITRON <ref> [Mon87] </ref> for industrial embedded systems, BTRON [Sak87b, KTKS87] for business workstations, TRON CHIP [Sak87a] for a microprocessor used in the ITRON and BTRON, etc. 31 classes: (1) interfaces that can be used for all applications and (2) interfaces that are used selectively for specific applications.
Reference: [Moo68] <author> J. M. Moore. </author> <title> Sequencing n jobs on one machine to minimize the number of late jobs. </title> <journal> Management Science, </journal> <volume> 17(1), </volume> <year> 1968. </year>
Reference-contexts: The policies compared are the standard sequencing methods of FCFS, SJF (sequencing by shortest computation time first), LLF, EDD, the local "guarantee" routine (GM), and a run-time selection algorithm (called MM algorithm) based on the Moore ordering rule <ref> [Moo68] </ref>. The criteria considered for selection of a local scheduling algorithm for hard real-time systems is that of minimum rejection ratio, maximum number of rejected tasks with positive laxity and greatest task laxity at rejection for tasks with positive laxity.
Reference: [MS93] <author> Jim McDonald and Karsten Schwan. </author> <title> Ada dynamic load control mechanisms for distributed embedded battle management systems. </title> <booktitle> In First Workshop on Real-time Applications, </booktitle> <address> New York, </address> <pages> pages 156-160. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1993. </year>
Reference-contexts: of the proposed algorithms. 2.3 Future Work Current and future work in real-time scheduling must address the highly dynamic, complex environments of large-scale real-time systems, such as national networks carrying time-constrained communications (e.g., multi-media applications like real-time video transmission [TTCM92] or collaboration systems [HK88]), or large-scale theater battle management systems <ref> [MS93] </ref>, or large-scale real-time simulations [GFS93]. <p> Furthermore, recent research is becoming more concerned with the provision of some platform on which diverse real-time systems may be constructed (e.g., real-time, configurable threads and micro-kernels). Commercial systems, on the other hand, have typically provided either Ada support (e.g., environments supported by Honeywell or TRW <ref> [MS93] </ref>), or some fixed set of primitives (i.e., micro-kernels) at the process level (e.g., pSOS), or they have focussed on building real-time extensions to or alterations of Unix, the latter now resulting in the POSIX real-time standards for Unix (which basically state that the low-level scheduler in Unix shall be priority
Reference: [MST89] <author> T. Marchok, J. Strosnider, and H. Tokuda. </author> <title> Token-ring adapter-chipset architectural considerations for real-time systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: This allows the system to integrate message and processor scheduling with a uniform priority management policy. In [Str], the author develops an algorithmic scheduling model for an IEEE 802.5 Token Ring Network and proposes a modification to the control algorithm of the token-ring adapter chip-set <ref> [MST89] </ref>. ARTS implements a communication structure which is intended to serve as a test-bed for new communication algorithms and protocols as well as new real-time hardware [TML90]. Protocols 22 such as VMTP have been successfully implemented on the ARTS kernel.
Reference: [MSZ90] <author> L. D. Molesky, C. Shen, and G. Zlokapa. </author> <title> Predictable synchronization mechanisms for multiprocessor real-time systems. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 3(2), </volume> <year> 1990. </year> <month> 41 </month>
Reference-contexts: He shows that optimal synchronization and scheduling disciplines exist for restricted patterns of resource usage. Predictable synchronization on multiprocessor real-time systems offers a new challenge compared to existing work on uniprocessor synchronization and scheduling [Jef89b, SRL90, CL90]. 11 In <ref> [MSZ90] </ref>, Molesky, Shen and Zlokapa describe predictable algorithms for semaphores with linear waiting. Although their proposed algorithms are predictable, they do not take into account the priorities of the processes that want to acquire the semaphore. In [RSL88a], the authors present a multiprocessor extension of the priority ceiling protocol [RSL89].
Reference: [MT90] <author> C. Mercer and H. Tokuda. </author> <title> The arts real-time object model. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 2-10, </pages> <year> 1990. </year>
Reference-contexts: Hence, YARTOS need not provide any special locking facilities for shared resources. Since tasks execute to completion in YARTOS, all tasks are executed on a single run-time stack. This improves memory utilization and reduces context switching overhead [Bak90]. 4.3.5 The ARTS Distributed Operating System ARTS <ref> [TML90, TM89a, MT90, TK88, TNR90a] </ref> is a distributed real time operating system developed in the ART (Advanced Real-time Technology) project at Carnegie Mellon University.
Reference: [MT92] <author> Clifford W. Mercer and Hideyuki Tokuda. </author> <booktitle> Preemptability in real-time operating systems. In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: A method for determining the schedulability of each task is presented. A second problem with RM scheduling is priority inversion, which arises when a high priority job must wait for a lower priority job to execute. In <ref> [MT92] </ref>, the authors consider the nature of the non-preemptable critical regions which give rise to such priority inversions in the context of a soft real-time operating system, where average response time for different priority classes is the primary performance metric.
Reference: [Muk91] <author> Bodhisattwa Mukherjee. </author> <title> A portable and reconfigurable threads package. </title> <booktitle> In Proceedings of the Sun User Group Technical Conference, </booktitle> <pages> pages 101-112, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The ideas presented in [KSO90, KS91, OSS90] are now being integrated into the lowest layers of CHAOS, thereby permitting implementors of specific abstractions at the threads or object levels <ref> [Muk91] </ref>. The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer.
Reference: [NCS + 90] <author> J. Northcutt, R. Clark, S. Shipman, D. Maynard, E. Jensen, F. Reynolds, and B. Dasarathy. </author> <title> Threads: A programming construct for reliable real-time distributed programming. </title> <booktitle> In Proc. International Conf. on Parallel and Distributed Computing and Systems, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: While the OS offers fairly standard primitives, its novel attributes are its support for special communication protocols addressing multi-media applications and its rigorous study of on-line scheduling for distributed memory machines (e.g., sets of workstations), including machines used in manufacturing environments [HS91, HS92]. 4.3.8 The Alpha Operating System Alpha <ref> [JN90a, JN90b, NCS + 90] </ref> is a non-proprietary operating system for large, complex, distributed real-time systems. Alpha arose from the Archons Project at Carnegie Mellon University, which offered a partially implemented prototype operational in 1987. Versions now run on Sun, Concurrent, and SGI hardware. <p> Objects are named by capabilities that are protected by the kernel and not directly accessible by applications. Alpha's kernel offers atomic transaction-controlled updates to an object's permanent representation. Alpha threads are the units of schedulability, and they are fully preemptable. A thread is the locus of control point <ref> [NCS + 90] </ref> movement among objects via operation invocation. It is 27 a distributed computation which transparently and reliably spans physical nodes. A thread carries parameters and other attributes related to the nature, state, and service requirements of the computation it represents.
Reference: [NNS91] <author> Douglas Niehaus, Erich Nahum, and John A. Stankovic. </author> <title> Predictable real-time caching in the spring kernel. </title> <booktitle> In Proceedings of the Joint IEEE Workshop on Real-Time Operating Systems and Software and IFAC Workshop on Real-Time Programming, </booktitle> <address> Atlanta, GA. </address> <publisher> IEEE, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Unfortunately, several optimization techniques that enhance performance in non-real-time systems, add to variation in performance, and are left out of several of today's real-time systems [Rea90]. Thus, caching and virtual memory are used restrictively or sparingly <ref> [NNS91] </ref>, while lazy evaluation, lazy copying, FIFO-queueing, instruction-pipelining and delays associated with 14 locks are either eliminated or treated as `special cases' [TNR90b].
Reference: [NP91] <author> V. Nirkhe and W. Pugh. </author> <title> A partial evaluator for the maruti hard real-time system. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: Scheduling algorithm research in conjunction with Maruti is described in <ref> [NP91] </ref>, where the notion of partial evaluation of program constructs is applied to real-time systems.
Reference: [NYM92] <author> Jun Nakajima, Masatomo Yazaki, and Hitoshi Matsumoto. </author> <title> Multimedia/realtime extemsions for mach 3.0. </title> <booktitle> Proceedings of the USENIX Workshop on Micro-Kernel and Other Kernel Architectures, </booktitle> <pages> pages 161-175, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: In addition, Nakajima et. al. <ref> [NYM92] </ref> address extensions to Mach for multimedia applications. Their work includes extensions for real-time scheduling, user-mode device drivers, and a temporal paging system. Traditionally, threads are defined for non-real-time activity. RT-Mach augments the model of a thread with timing attributes. <p> The other effort at enhancing Mach for real-time and multimedia applications has a slightly different concept of real-time threads. Nakajima et. al. <ref> [NYM92] </ref> use deadline-driven and event-driven threads for appropriate types of multimedia devices. Deadline-driven threads are 25 used for devices where the media does not deteriorate if operations to the device complete be-fore a deadline.
Reference: [OSS90] <author> David M. Ogle, Karsten Schwan, and Richard Snodgrass. </author> <title> The dynamic monitoring of real-time distributed and parallel systems. </title> <type> Technical report, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <address> ICS-GIT-90/23, Atlanta, GA 30332, </address> <month> May </month> <year> 1990. </year> <note> Also in IEEE TPDS July 1993. </note>
Reference-contexts: Another issue addressed by the CHAOS researchers is the application--specific, on-line monitoring of running real-time programs. The purpose of such monitoring is to use monitor data to adapt running programs in performance and functionality to changing external execution environments. The ideas presented in <ref> [KSO90, KS91, OSS90] </ref> are now being integrated into the lowest layers of CHAOS, thereby permitting implementors of specific abstractions at the threads or object levels [Muk91]. The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer.
Reference: [OWK87] <author> T. Ohkubo, T. Wasano, and I. Kogiku. </author> <title> Configuration of the ctron kernel. </title> <booktitle> IEEE MICRO, </booktitle> <month> april </month> <year> 1987. </year>
Reference-contexts: The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer. While the systems are not intended for commercial use, offshoots are being used in commercial robotics applications [BG92]. 4.3.10 The CTRON Operating System Framework CTRON <ref> [OWK87, WOK + 87, KOOH87, Sak89] </ref> is a part of the TRON 1 [Sak87c] platform for real-time operating systems. The general TRON project is designed for network nodes consisting of different kinds of computers. <p> However, this presents an obstacle to software portability. CTRON defines a black box model for this purpose. It defines only system call names in the black box model; it does not define input and output conditions, error conditions, or side effects. In <ref> [OWK87] </ref>, the authors discuss this model in detail. 33 Brief Evaluation: While TRON and CTRON are superior to other, specific operating sys-tems for real-time control offered in the U.S. due to their attempt to construct a portable platform for use in different applications on different target machines, there remain issues regarding
Reference: [PHOA89] <author> L. Peterson, N. Hutchinson, S. O'Malley, and M. </author> <title> Abbot. Rpc in the x-kernel. </title> <booktitle> In Twelfth ACM Symposium on Operating Systems, </booktitle> <pages> pages 91-101. </pages> <publisher> ACM, </publisher> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: The operating system appears to focus on support for on-line scheduling, in part targeting applications in autonomous robot control [KMTD86] and for multi-media applications. Its implementation is being performed on SUN 3 processor using the X-kernel communication software from the Univ. of Arizona <ref> [PHOA89] </ref>.
Reference: [QD92] <author> T. Quiggle and G. Dismukes. </author> <title> An analysis of the implementation and execution-time impact of ada 9x real-time features. Technical Report LSN-040-UI, Ada 9X Language Study Note, </title> <month> March </month> <year> 1992. </year>
Reference-contexts: In [BP91], the authors present a brief description of some of the Ada 9X proposals that are intended to address hard real-time requirements. Ada 9X is a revision to the Ada programming language standard [Wel92]. The reports <ref> [Inc92, QD92, Sof92] </ref> present some results of real-time implementation studies of Ada. In [BJ87, Bak87, BJ86], the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems.
Reference: [Rea90] <author> James F. </author> <title> Ready. Os kernel design considerations for real-time systems. </title> <booktitle> COMPCON Spring 1990: Thirty-Fifth IEEE Computer Society International Conference, </booktitle> <pages> pages 278-281, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Unfortunately, several optimization techniques that enhance performance in non-real-time systems, add to variation in performance, and are left out of several of today's real-time systems <ref> [Rea90] </ref>. Thus, caching and virtual memory are used restrictively or sparingly [NNS91], while lazy evaluation, lazy copying, FIFO-queueing, instruction-pipelining and delays associated with 14 locks are either eliminated or treated as `special cases' [TNR90b].
Reference: [RS84] <author> K. Ramamritham and J.A. Stankovic. </author> <title> Dynamic task scheduling in hard real-time distributed systems. </title> <journal> IEEE Software, </journal> <volume> 1(3) </volume> <pages> 65-75, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive <ref> [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] </ref> and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. <p> This algorithm is similar to algorithms developed for distributed systems, such as bidding algorithms <ref> [RS84] </ref>. This work is extended further in [ZSA91]. <p> The local scheduling policy is often based on heuristics that efficiently determine which task to accept and which task to reject. In [CL86], the authors compare a few distributed scheduling algorithms based on the means utilized to share information (i.e., the global part). In <ref> [RS84] </ref>, the authors propose a heuristic for local scheduling in a distributed system called the "guarantee" routine. Here, an arriving task is inserted into the queue if it is possible to guarantee that both the arriving task and all other tasks currently in the queue do not miss their deadlines. <p> The final module is a Meta Level Controller, which can adapt various parameters by noticing significant changes in the environment, and it can serve as the system's user interface. In <ref> [RS84, SRC85, ZRS87a] </ref>, the authors present and analyze the details of their scheduling algorithms. Memory Management: In the Spring kernel, the OS is core-resident.
Reference: [RSL87] <author> R. Rajkumar, L. Sha, and J. P. Lehoczky. </author> <title> On countering the effects of cycle-stealing in a hard real-time environment. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 2-11, </pages> <month> December </month> <year> 1987. </year> <month> 42 </month>
Reference-contexts: As with earlier research in autonomous robotics, researchers instead assume the existence of alternative tasks or task sets (e.g., exception handling tasks) to be used when the deadlines of the original tasks cannot be met [BS91a, GS93]. Effects of Cycle-Stealing on Scheduling Algorithms. In <ref> [RSL87] </ref>, the authors discuss the effects of cycle stealing on scheduling algorithms in a hard real-time environment. An I/O device can transfer data by direct memory access (DMA) and steal cycles from the processor and therefore from the executing task. <p> Often, I/O devices are designed in such a way that FIFO is the only possible way to schedule I/O activity. The benefits gained by an intelligent algorithm to schedule the processor can be negated by such an I/O scheduling algorithm [SLR86]. In <ref> [RSL87] </ref>, the authors address the issues raised by integration of the scheduling of processor and I/O devices. They propose remedies to the problem in two steps first, the I/O devices should be more intelligent so that they can be scheduled just as the CPU.
Reference: [RSL88a] <author> R. Rajkumar, L. Sha, and J. Lehoczky. </author> <title> Real-time synchronization protocols for multiprocessors. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 159-169, </pages> <year> 1988. </year>
Reference-contexts: Although their proposed algorithms are predictable, they do not take into account the priorities of the processes that want to acquire the semaphore. In <ref> [RSL88a] </ref>, the authors present a multiprocessor extension of the priority ceiling protocol [RSL89]. The priority ceiling protocol minimizes priority inversion for a set of periodic real-time processes that access exclusively some shared data.
Reference: [RSL88b] <author> R. Rajkumar, Lui Sha, and John P. Lehoczky. </author> <title> Real-time synchronization protocols for multiprocessors. </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <address> Huntsville, AL, </address> <pages> pages 259-269. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1988. </year>
Reference-contexts: The algorithms used for real-time synchronization in RT-Mach have been used elsewhere earlier <ref> [SRL90, RSL88b] </ref>. Essentially, these are various queue-ordering approaches to alleviate blocking problems known to exist in real-time synchronization. RT-Mach allows various synchronization policies to be used with locks and conditions, which are well-known entities used for synchronization when programming with threads.
Reference: [RSL89] <author> R. Rajkumar, L. Sha, and J. Lehocsky. </author> <title> An experimental investigation of synchronization protocols. </title> <booktitle> In Proceedings of 6th IEEE Workshop on Real-time Operating Systems and Software, </booktitle> <pages> pages 11-17, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Although their proposed algorithms are predictable, they do not take into account the priorities of the processes that want to acquire the semaphore. In [RSL88a], the authors present a multiprocessor extension of the priority ceiling protocol <ref> [RSL89] </ref>. The priority ceiling protocol minimizes priority inversion for a set of periodic real-time processes that access exclusively some shared data. The multiprocessor priority ceiling protocol generalizes the uniprocessor priority ceiling protocol by executing all critical regions associated with a semaphore on a particular processor called the synchronization processor.
Reference: [Sak87a] <author> K. Sakamura. </author> <title> Architecture of the tron vlsi cpu. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 17-31, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: To accommodate such varied requirements, the operating system interface is divided into two 1 This project studies the operating system interfaces/requirements for real-time processing. This project consists of several sub-projects, including ITRON [Mon87] for industrial embedded systems, BTRON [Sak87b, KTKS87] for business workstations, TRON CHIP <ref> [Sak87a] </ref> for a microprocessor used in the ITRON and BTRON, etc. 31 classes: (1) interfaces that can be used for all applications and (2) interfaces that are used selectively for specific applications.
Reference: [Sak87b] <author> K. Sakamura. Btron: </author> <title> The business-oriented operating system. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 53-65, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: To accommodate such varied requirements, the operating system interface is divided into two 1 This project studies the operating system interfaces/requirements for real-time processing. This project consists of several sub-projects, including ITRON [Mon87] for industrial embedded systems, BTRON <ref> [Sak87b, KTKS87] </ref> for business workstations, TRON CHIP [Sak87a] for a microprocessor used in the ITRON and BTRON, etc. 31 classes: (1) interfaces that can be used for all applications and (2) interfaces that are used selectively for specific applications.
Reference: [Sak87c] <author> K. Sakamura. </author> <title> The tron project. </title> <booktitle> IEEE MIcro, </booktitle> <pages> pages 8-14, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: While the systems are not intended for commercial use, offshoots are being used in commercial robotics applications [BG92]. 4.3.10 The CTRON Operating System Framework CTRON [OWK87, WOK + 87, KOOH87, Sak89] is a part of the TRON 1 <ref> [Sak87c] </ref> platform for real-time operating systems. The general TRON project is designed for network nodes consisting of different kinds of computers.
Reference: [Sak89] <editor> TRON ASSOCIATION (Supervisor: Dr. K. Sakamura), editor. </editor> <title> Outline of CTRON. Original Ctron Specification Series. </title> <publisher> Ohmsha, </publisher> <year> 1989. </year>
Reference-contexts: The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer. While the systems are not intended for commercial use, offshoots are being used in commercial robotics applications [BG92]. 4.3.10 The CTRON Operating System Framework CTRON <ref> [OWK87, WOK + 87, KOOH87, Sak89] </ref> is a part of the TRON 1 [Sak87c] platform for real-time operating systems. The general TRON project is designed for network nodes consisting of different kinds of computers.
Reference: [SB87] <author> Karsten Schwan and Ben Blake. </author> <title> Experimental evaluation of a real-time scheduler for a multiprocessor system. </title> <type> Technical report, </type> <institution> Computer and Information Science, The Ohio State University, OSU-CISRC-5/87-TR16, </institution> <month> Sept. </month> <year> 1987. </year> <note> Also in IEEE TSE, </note> <month> Jan. </month> <year> 1991. </year>
Reference: [SBWT87] <author> Karsten Schwan, Tom Bihari, Bruce W. Weide, and Gregor Taulbee. </author> <title> High-performance operating system primitives for robotics and real-time control systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(3) </volume> <pages> 189-231, </pages> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: The adaptations specifically supported by CHAOS arc constructs are those that may be implemented as reactions to external events termed reactive adaptations, as opposed to adaptations that anticipate changes in the operating environment termed preventive adaptations <ref> [BS88, SBWT87, SGB87, GS89c] </ref>. However, programming and monitoring system support is implemented for CHAOS arc so that preventive adaptations may be performed as well. 30 On-line monitoring. Another issue addressed by the CHAOS researchers is the application--specific, on-line monitoring of running real-time programs.
Reference: [Sch88] <author> Karsten Schwan. </author> <title> Developing high-performance, parallel software for real-time applications. Information and Software Technology, </title> <publisher> Butterworths Scientific Limited, </publisher> <pages> pages 218-227, </pages> <month> May </month> <year> 1988. </year>
Reference: [SFG + 91] <author> Karsten Schwan, Harold Forbes, Ahmed Gheith, Bodhisattwa Mukherjee, and Yian-nis Samiotakis. </author> <title> A cthread library for multiprocessors. </title> <type> Technical Report GIT-ICS-91/02, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: This is useful because it facilitates changes to an operating system for uses with different target architectures or application domains. The family is portable in that its implementation is based on the now widely accepted Mach cthreads standard <ref> [SFG + 91] </ref> as a base layer for uniprocessors and parallel architectures called the CHAOS base member of the kernel family. 3 A Concurrent, Hierarchical, Adaptable Operating System supporting atomic, real-time computations. 28 However, upwardly compatible modifications have been made to the cthread interface in order to accommodate real-time applications [ZS91].
Reference: [SGB87] <author> Karsten Schwan, Prabha Gopinath, </author> <title> and Win Bo. Chaos kernel support for objects in the real-time domain. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(8):904-916, </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: Our work is best summarized as `research addressing the configurability and adaptability of operating system kernels'. Our initial work addressed the process and then object levels of real-time software (the CHAOS systems <ref> [SGB87, GS93] </ref>), whereas our current work is addressing configurability and adaptability at the threads level. 13 4.2 Ada-supporting Runtime Systems A continuing, DoD-induced thrust in current research on real-time systems is to design and build run-time support for real-time Ada. <p> Objects in ARTS are much like those developed earlier in the CHAOS systems <ref> [SGB87, GS93] </ref>; they can be passive or active. An active object contains one or more user defined threads. In the active object, the designer of the object is responsible for providing concurrency control among co-executing operations. <p> When the operation is invoked from a real-time thread, the operation is executed if there is enough remaining computation time allocated 21 to the calling thread to complete the operation. Otherwise, the invocation is aborted and an exception is raised. Real-Time Threads: Like CHAOS <ref> [SGB87] </ref>, ARTS also provides real-time threads to users [TNR90b]. Each thread has an associated procedure name and a stack descriptor which specifies the size and address of the thread's stack. A real-time thread can be a hard real-time or a soft real-time thread. <p> Extensibility and customizability of the family are attained by use of the object model for description of the operating system's interface <ref> [SGB87, HFC76] </ref> and for operating system and user program implementation. Each application program is composed of a number of user objects, which use system-defined objects to access operating system services. <p> Each application program is composed of a number of user objects, which use system-defined objects to access operating system services. However, as opposed to other object-based operating system kernels <ref> [SGB87] </ref> and in order to attain extensibility and customizability, family members do not describe their system interfaces by exporting some system objects (i.e., their classes [HFC76]). Instead, the exported object classes are refined a novel abstraction supported by CHAOS min : attributes. <p> It supports the following built-in object flavors: ADT, Monitor, TADT, and Task. A primitive object of flavor ADT (abstract 4 All threads created by a single user process share the process' address space yet have their own execution states. 29 data type) is passive <ref> [SGB87] </ref> and has well-defined internal state. Its operations are executed in the address space and by the execution thread of the invoker (caller). An object of type monitor is a passive object that allows exactly one execution thread at a time to execute its operations. <p> The adaptations specifically supported by CHAOS arc constructs are those that may be implemented as reactions to external events termed reactive adaptations, as opposed to adaptations that anticipate changes in the operating environment termed preventive adaptations <ref> [BS88, SBWT87, SGB87, GS89c] </ref>. However, programming and monitoring system support is implemented for CHAOS arc so that preventive adaptations may be performed as well. 30 On-line monitoring. Another issue addressed by the CHAOS researchers is the application--specific, on-line monitoring of running real-time programs.
Reference: [SGZ90a] <author> K. Schwan, A. Gheith, and H. Zhou. Chaos-arc: </author> <title> A kernel for predictable programs in dynamic real-time systems. </title> <booktitle> In Seventh IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <institution> Univ. of Virginia, </institution> <address> Charlottesville, </address> <pages> pages 11-19, </pages> <month> May </month> <year> 1990. </year>
Reference: [SGZ90b] <author> Karsten Schwan, Ahmed Gheith, and Hongyi Zhou. </author> <title> From chaos-min to chaos-arc: A family of real-time multiprocessor kernels. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <address> Orlando, Florida, </address> <pages> pages 82-92. </pages> <publisher> IEEE, </publisher> <month> Dec. </month> <year> 1990. </year> <month> 43 </month>
Reference: [SK91] <author> D. B. Stewart and P. K. Khosla. </author> <title> Real-time scheduling of sensor-based control systems. </title> <booktitle> In Eighth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Essentially, laxity is a measure of the flexibility available for scheduling a task. The main difference between MLF and EDF is that unlike EDF, MLF takes into consideration the execution time of a task <ref> [SK91] </ref>. 1 The schedulable bound of a task set is defined as the maximum CPU utilization for which the set of tasks can be guaranteed to meet their deadlines. 4 While EDF is superior to RM in the sense that its schedulable bound is 100% for all task sets, a problem <p> This has resulted in another variant of EDF scheduling, called the Maximum-Urgency-First (MUF) algorithm <ref> [SK91] </ref>, where each task is given an explicit description of urgency. This urgency is defined as a combination of two fixed priorities, and a dynamic priority, which is inversely proportional to the task's laxity. One of the fixed priorities, called task criticality, has precedence over the task's dynamic priority.
Reference: [SL92] <author> Wei-Kuan Shih and Jane W. S. Liu. </author> <title> On-line scheduling of imprecise computations to minimize error. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: In [LLN87], the authors discuss a formulation of this problem taking into the account the quality of the overall result. A few scheduling algorithms for such computations are also presented in the paper. In <ref> [SL92] </ref>, the authors describe three algorithms for scheduling preemptive, imprecise tasks on a processor to minimize the total error. Each imprecise task consists of a mandatory task followed by an optimal task. Some of the tasks arrive after the processor begins execution.
Reference: [SLJ88] <author> L. Sha, J. P. Lehoczky, and E. D. Jensen. </author> <title> Modular concurrency control and failure recovery. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(2), </volume> <year> 1988. </year>
Reference: [SLR86] <author> L. Sha, J. P. Lehoczky, and R. Rajkumar. </author> <title> Solutions for some practical problems in prioritized preemptive scheduling. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <year> 1986. </year>
Reference-contexts: At any time, the low-level scheduler simply chooses to execute the highest priority task. By specifying the period and maximum computation time of each task, the behavior of the system can be categorized a priori <ref> [SLR86] </ref>. Among the problems with RM algorithms is their lack of support for dynamically changing periods, and that their schedulable bound 1 is less than 100%, which are being addressed [SSL89, SLS88]. <p> The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive <ref> [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] </ref> and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. <p> Often, I/O devices are designed in such a way that FIFO is the only possible way to schedule I/O activity. The benefits gained by an intelligent algorithm to schedule the processor can be negated by such an I/O scheduling algorithm <ref> [SLR86] </ref>. In [RSL87], the authors address the issues raised by integration of the scheduling of processor and I/O devices. They propose remedies to the problem in two steps first, the I/O devices should be more intelligent so that they can be scheduled just as the CPU.
Reference: [SLS88] <author> B. Sprunt, John P. Lehoczky, and Lui Sha. </author> <title> Expoiting unused periodic time for aperiodic service using the extended priority exchange algorithm. </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <address> Huntsville, AL, </address> <pages> pages 251-258. </pages> <publisher> IEEE, </publisher> <year> 1988. </year>
Reference-contexts: Among the problems with RM algorithms is their lack of support for dynamically changing periods, and that their schedulable bound 1 is less than 100%, which are being addressed <ref> [SSL89, SLS88] </ref>. In [HKL91], the authors consider the problem of fixed priority scheduling of periodic tasks where each task's execution priority may vary. A method for determining the schedulability of each task is presented.
Reference: [Sof92] <author> RR Software. </author> <title> Runtime implementation strategies for protected records, multiway entry cal, and asynchronous transfer of control. Technical Report LSN-041-UI, Ada 9X Language Study Note, </title> <month> March </month> <year> 1992. </year>
Reference-contexts: In [BP91], the authors present a brief description of some of the Ada 9X proposals that are intended to address hard real-time requirements. Ada 9X is a revision to the Ada programming language standard [Wel92]. The reports <ref> [Inc92, QD92, Sof92] </ref> present some results of real-time implementation studies of Ada. In [BJ87, Bak87, BJ86], the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems.
Reference: [SR87] <author> J. Stankovic and K. Ramamritham. </author> <title> The design of the spring kernel. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 146-157, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: As a result, real-time operating systems should support multiple models of time-critical task communication. The general characteristics of a real-time kernel <ref> [SR87] </ref> include a size that may be adjusted to each application's needs, multitasking with low overhead for task context switches, fast response 1 to external interrupts, no or limited use of virtual memory, support for time-constraints in task such as priority scheduling, support for real-time clocks, special alarms and time outs, <p> Two types of KIs are currently supported: one based on shared-memory communication between processors, and the other based on TCP/IP. 4.3.2 The Spring Kernel: Exploring System Predictability The goals of the Spring project at the University of Massachusetts <ref> [SR87] </ref> include: the development of dynamic, distributed, online real-time scheduling algorithms, the development and implementation of Spring kernel which supports a network of multiprocessors, the development of multiprocessor nodes in order to directly support the kernel and the scheduling algorithm, and the development of real-time tools. <p> The goals of using segmentation in hard real-time systems are to develop well defined units of each resource, to increase understandability, and to permit on-line algorithms to explicitly combine these units such that predictability is achieved with respect to timing constraints <ref> [SR87] </ref>. Scheduling: Schedulers in Spring are run by the system processors. Spring's schedulers are composed of four modules. As in most operating systems, the lowest level module is a processor-resident dispatcher, which simply removes the next task from a global system task table (STT) containing all guaranteed tasks.
Reference: [SR91] <author> John A. Stankovic and Krithi Ramamritham. </author> <title> Editorial: What is predictability for real-time systems? Real-Time Systems, </title> <booktitle> 2(4) </booktitle> <pages> 247-254, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Depending upon the environment that the kernel was designed for, predictability can imply different subtleties in different real-time kernels: if it is possible to demonstrate that system specifications are met (subject to assumptions regarding operating conditions), the real-time system is said to be predictable. Thus, Stankovic and Ramamritham <ref> [SR91] </ref> point out five dimensions under which real-time systems can be categorized: * granularity of deadlines and task laxities * strictness of deadlines * reliability requirements of the system * size of system and degree of interaction among components, and * characteristics of the operating environment Granularity and laxity together determine <p> Thus, caching and virtual memory are used restrictively or sparingly [NNS91], while lazy evaluation, lazy copying, FIFO-queueing, instruction-pipelining and delays associated with 14 locks are either eliminated or treated as `special cases' [TNR90b]. These techniques can be put together using the layer-by-layer approach or the top-layer approach <ref> [SR91] </ref> 1 The layer-by-layer approach assumes that a `higher layer' is predictable if all its lower layers are predictable.
Reference: [SR93] <author> John. A. Stankovic and Krithi Ramamritham. </author> <title> Scheduling. </title> <booktitle> In Advances In Real-Time Systems, </booktitle> <pages> pages 47-52. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: We begin with a brief review of static scheduling, followed by a discussion of dynamic scheduling. For a more extensive review of research in static real-time scheduling, the reader may refer to <ref> [Law83, CSR88, SR93] </ref>.
Reference: [SRC85] <author> J. Stankovic, K. Ramamritham, and S. Cheng. </author> <title> Evaluation of a bidding algorithm for hard real-time distributed systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-34(12), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: The final module is a Meta Level Controller, which can adapt various parameters by noticing significant changes in the environment, and it can serve as the system's user interface. In <ref> [RS84, SRC85, ZRS87a] </ref>, the authors present and analyze the details of their scheduling algorithms. Memory Management: In the Spring kernel, the OS is core-resident.
Reference: [SRL90] <author> L. Sha, R. Rajkumar, and J. P. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: For uniprocessor systems running periodic tasks, two recent protocols provide effective solutions to the scheduling problem with resource sharing. They are the kernelized monitor protocol [Mok83] and the priority ceiling protocol <ref> [SRL90] </ref>. In the kernelized monitor protocol, the earliest deadline first scheduling policy is used for task scheduling. All executions in critical sections are nonpreemptable. However, schedulability analysis performed in this protocol requires the use of upper bounds on the execution times of all critical sections appearing in tasks. <p> He shows that optimal synchronization and scheduling disciplines exist for restricted patterns of resource usage. Predictable synchronization on multiprocessor real-time systems offers a new challenge compared to existing work on uniprocessor synchronization and scheduling <ref> [Jef89b, SRL90, CL90] </ref>. 11 In [MSZ90], Molesky, Shen and Zlokapa describe predictable algorithms for semaphores with linear waiting. Although their proposed algorithms are predictable, they do not take into account the priorities of the processes that want to acquire the semaphore. <p> The algorithms used for real-time synchronization in RT-Mach have been used elsewhere earlier <ref> [SRL90, RSL88b] </ref>. Essentially, these are various queue-ordering approaches to alleviate blocking problems known to exist in real-time synchronization. RT-Mach allows various synchronization policies to be used with locks and conditions, which are well-known entities used for synchronization when programming with threads.
Reference: [SS87] <author> J. Stankovic and L. Sha. </author> <title> The principle of segmentation. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Massachusetts, </institution> <year> 1987. </year>
Reference-contexts: The I/O subsystem can be controlled by some other real-time kernel. The design of the Spring kernel is based on the principle of segmentation as applied to hard real time systems <ref> [SS87] </ref>. Segmentation is the process of dividing resources of the systems into units where the size of the unit is based on various criteria particular to the resource under consideration and to the application requirements.
Reference: [SSL89] <author> Brinkley Sprunt, Lui Sha, and John Lehoczky. </author> <title> Aperiodic task scheduling for hard-real-time systems. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 1 </volume> <pages> 27-60, </pages> <year> 1989. </year>
Reference-contexts: Among the problems with RM algorithms is their lack of support for dynamically changing periods, and that their schedulable bound 1 is less than 100%, which are being addressed <ref> [SSL89, SLS88] </ref>. In [HKL91], the authors consider the problem of fixed priority scheduling of periodic tasks where each task's execution priority may vary. A method for determining the schedulability of each task is presented. <p> Other relevant research at CMU (not strictly connected to the ARTS project) includes research on real-time transactions by Sha et. al.[SLJ88] and work on rate-based scheduling by Lehoczky et. al. <ref> [SSL89] </ref>. 4.3.6 Real-Time Mach The Real-Time Mach (RT-Mach) effort was initiated at CMU to develop a version of the Mach kernel for real-time systems [TNR90b].
Reference: [Str] <author> J. Strosnider. </author> <title> Real-Time Communication. </title> <type> PhD thesis, </type> <institution> Department of ECE, Carnegie Mellon University. </institution>
Reference-contexts: Communication Scheduling: In the ARTS project, an extended rate monotonic scheduling paradigm is used for communication scheduling [TMIM89]. This allows the system to integrate message and processor scheduling with a uniform priority management policy. In <ref> [Str] </ref>, the author develops an algorithmic scheduling model for an IEEE 802.5 Token Ring Network and proposes a modification to the control algorithm of the token-ring adapter chip-set [MST89].
Reference: [SZ92] <author> Karsten Schwan and Hongyi Zhou. </author> <title> Dynamic scheduling of hard real-time tasks and real-time threads. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(8) </volume> <pages> 736-748, </pages> <month> Aug. </month> <year> 1992. </year> <month> 44 </month>
Reference-contexts: Chen et. al.[CL91] study a priority ceiling protocol for multiple-instance resources. They present an optimal resource-allocation algorithm which can be used to improve the schedulability of a real-time system. In contrast, the Earliest Deadline First (EDF) scheduling algorithm can be used for dynamic as well as static scheduling <ref> [ZRS87b, DM89, SZ92] </ref>. This algorithm uses the deadline of a task as its priority. The task with the earliest deadline has the highest priority. Since priorities are dynamic, the periods of tasks can be changed at any time. <p> Researchers are also addressing the actual overheads experienced by on-line scheduling algorithms <ref> [ZSG92, SZ92] </ref>. This is resulting in more attention paid to scheduling algorithm and scheduler implementation rather than considerations of algorithm optimality and complexity (the latter only captures worst case performance, whereas we are often interested in average case performance in actual systems). <p> Mailboxes are memory objects. The Spring kernel avoids the need for semaphores by implementing mutual exclusion directly as part of the task schedule. This results in somewhat inflexible process scheduling because prematurely finishing processes cannot relinquish their extra execution time to other processes <ref> [SZ92] </ref>. 4.3.3 The Maruti Distributed Real-Time Operating System The main focus of the Maruti project [GMAT90, Agr90, AL87, MA90, YA89, LA90] at the University of Maryland is to examine the constructs of future distributed, hard real-time, fault tolerant, secure operating systems. Maruti is an object-based system, with encapsulation of services.
Reference: [SZG91] <author> Karsten Schwan, Hongyi Zhou, and Ahmed Gheith. </author> <title> Multiprocessor real-time threads. </title> <journal> Operating Systems Review, </journal> <volume> 25(4) </volume> <pages> 35-46, </pages> <month> Oct. </month> <year> 1991. </year> <note> Also appears in the Jan. 1992 issue of Operating Systems Review. </note>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in <ref> [SZG91, ZSG92] </ref>. Evaluation and Algorithm Improvements. Researchers have studied both preemptive [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. <p> This algorithm is similar to algorithms developed for distributed systems, such as bidding algorithms [RS84]. This work is extended further in [ZSA91]. In <ref> [SZG91] </ref>, the authors address an important problem regarding a large distributed memory multiprocessor which is best stated by the following two questions: (1) how are the latency and the quality of scheduling affected by different degrees of completeness in the information shared among multiple, potentially concurrent schedulers? and (2) how can <p> As a result, researchers are now primarily addressing on-line scheduling, scheduling for parallel and distributed systems <ref> [ZSA91, SZG91] </ref>, and the semantics of timing constraints to be enforced in such future systems (e.g., hard deadlines are simply neither needed nor feasible as a formulation of timing constraints in multi-media applications). Researchers are also addressing the actual overheads experienced by on-line scheduling algorithms [ZSG92, SZ92].
Reference: [TK88] <author> H. Tokuda and M. Kotera. </author> <title> A real-time tool set for the arts kernel. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: Hence, YARTOS need not provide any special locking facilities for shared resources. Since tasks execute to completion in YARTOS, all tasks are executed on a single run-time stack. This improves memory utilization and reduces context switching overhead [Bak90]. 4.3.5 The ARTS Distributed Operating System ARTS <ref> [TML90, TM89a, MT90, TK88, TNR90a] </ref> is a distributed real time operating system developed in the ART (Advanced Real-time Technology) project at Carnegie Mellon University.
Reference: [TM89a] <author> H. Tokuda and C. Mercer. </author> <title> Arts: A distributed real-time kernel. </title> <journal> Operating Systems Review, </journal> <volume> 23(3) </volume> <pages> 29-53, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Hence, YARTOS need not provide any special locking facilities for shared resources. Since tasks execute to completion in YARTOS, all tasks are executed on a single run-time stack. This improves memory utilization and reduces context switching overhead [Bak90]. 4.3.5 The ARTS Distributed Operating System ARTS <ref> [TML90, TM89a, MT90, TK88, TNR90a] </ref> is a distributed real time operating system developed in the ART (Advanced Real-time Technology) project at Carnegie Mellon University.
Reference: [TM89b] <author> Hideyuki Tokuda and Clifford W. Mercer. </author> <title> Arts: A distributed real-time kernel. </title> <journal> ACM Operating Systems Review, </journal> <volume> 23(3) </volume> <pages> 29-53, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The novel aspects of ARTS are its initial focus on distributed real-time applications <ref> [TM89b] </ref>, its integrated support of monitoring tools used for timing evaluation and display [Tok88], and its later support of real-time communication protocols addressing live video transmission [TTCM92]. Objects in ARTS are much like those developed earlier in the CHAOS systems [SGB87, GS93]; they can be passive or active.
Reference: [TMIM89] <author> H. Tokuda, C. Mercer, Y. Ishikawa, and T. Marchok. </author> <title> Priority inversions in real-time communication. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: Each instantiation of the scheduler may have a different scheduling policy governing the behavior of the object, with only one instantiation being active at a given time. Communication Scheduling: In the ARTS project, an extended rate monotonic scheduling paradigm is used for communication scheduling <ref> [TMIM89] </ref>. This allows the system to integrate message and processor scheduling with a uniform priority management policy. In [Str], the author develops an algorithmic scheduling model for an IEEE 802.5 Token Ring Network and proposes a modification to the control algorithm of the token-ring adapter chip-set [MST89].
Reference: [TML90] <author> H. Tokuda, C. Mercer, and J. Lehoczky. </author> <title> Scheduling theory and practice in arts. </title> <type> Technical report, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Hence, YARTOS need not provide any special locking facilities for shared resources. Since tasks execute to completion in YARTOS, all tasks are executed on a single run-time stack. This improves memory utilization and reduces context switching overhead [Bak90]. 4.3.5 The ARTS Distributed Operating System ARTS <ref> [TML90, TM89a, MT90, TK88, TNR90a] </ref> is a distributed real time operating system developed in the ART (Advanced Real-time Technology) project at Carnegie Mellon University. <p> ARTS implements a communication structure which is intended to serve as a test-bed for new communication algorithms and protocols as well as new real-time hardware <ref> [TML90] </ref>. Protocols 22 such as VMTP have been successfully implemented on the ARTS kernel. Furthermore, a Real--time Transfer Protocol (RTP) is developed to explore real-time communication issues. RTP features prioritized messages and a time fence mechanism.
Reference: [TN91] <author> Hideyuki Tokuda and Tatsuo Nakajima. </author> <title> Evaluation of real-time synchronization in real-time mach. </title> <booktitle> Proceedings of the USENIX 1991 Mach Workshop, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Essentially a fallout of the ARTS work, RT-Mach chiefly addresses the real-time aspects of threads [TNR90b], synchronization <ref> [TN91] </ref>, interpro-cess communication (IPC) [KNT92], a real-time toolset for system design and analysis, and some other mechanisms to allow greater predictability, as mentioned at the beginning of section 4.3. In addition, Nakajima et. al. [NYM92] address extensions to Mach for multimedia applications.
Reference: [TNR90a] <author> H. Tokuda, T. Nakajima, and P. Rao. </author> <title> Real-time mach: Toward a predictable real-time system. </title> <booktitle> In Proceedings of USENIX Mach Workshop, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Hence, YARTOS need not provide any special locking facilities for shared resources. Since tasks execute to completion in YARTOS, all tasks are executed on a single run-time stack. This improves memory utilization and reduces context switching overhead [Bak90]. 4.3.5 The ARTS Distributed Operating System ARTS <ref> [TML90, TM89a, MT90, TK88, TNR90a] </ref> is a distributed real time operating system developed in the ART (Advanced Real-time Technology) project at Carnegie Mellon University.
Reference: [TNR90b] <author> Hideyuki Tokuda, Tatsuo Nakajima, and Prithvi Rao. </author> <title> Real-time mach: Towards predictable real-time systems. </title> <booktitle> Proceedings of the USENIX 1990 Mach Workshop, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Thus, caching and virtual memory are used restrictively or sparingly [NNS91], while lazy evaluation, lazy copying, FIFO-queueing, instruction-pipelining and delays associated with 14 locks are either eliminated or treated as `special cases' <ref> [TNR90b] </ref>. These techniques can be put together using the layer-by-layer approach or the top-layer approach [SR91] 1 The layer-by-layer approach assumes that a `higher layer' is predictable if all its lower layers are predictable. <p> Otherwise, the invocation is aborted and an exception is raised. Real-Time Threads: Like CHAOS [SGB87], ARTS also provides real-time threads to users <ref> [TNR90b] </ref>. Each thread has an associated procedure name and a stack descriptor which specifies the size and address of the thread's stack. A real-time thread can be a hard real-time or a soft real-time thread. <p> CMU (not strictly connected to the ARTS project) includes research on real-time transactions by Sha et. al.[SLJ88] and work on rate-based scheduling by Lehoczky et. al. [SSL89]. 4.3.6 Real-Time Mach The Real-Time Mach (RT-Mach) effort was initiated at CMU to develop a version of the Mach kernel for real-time systems <ref> [TNR90b] </ref>. Essentially a fallout of the ARTS work, RT-Mach chiefly addresses the real-time aspects of threads [TNR90b], synchronization [TN91], interpro-cess communication (IPC) [KNT92], a real-time toolset for system design and analysis, and some other mechanisms to allow greater predictability, as mentioned at the beginning of section 4.3. <p> al.[SLJ88] and work on rate-based scheduling by Lehoczky et. al. [SSL89]. 4.3.6 Real-Time Mach The Real-Time Mach (RT-Mach) effort was initiated at CMU to develop a version of the Mach kernel for real-time systems <ref> [TNR90b] </ref>. Essentially a fallout of the ARTS work, RT-Mach chiefly addresses the real-time aspects of threads [TNR90b], synchronization [TN91], interpro-cess communication (IPC) [KNT92], a real-time toolset for system design and analysis, and some other mechanisms to allow greater predictability, as mentioned at the beginning of section 4.3. In addition, Nakajima et. al. [NYM92] address extensions to Mach for multimedia applications.
Reference: [Tok88] <author> Hideyuki Tokuda. </author> <title> A real-time tool set for the arts kernel. </title> <booktitle> In Real-Time Systems Symposium, </booktitle> <address> Huntsville, Alabama, </address> <pages> pages 289-299. </pages> <publisher> IEEE, </publisher> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: The novel aspects of ARTS are its initial focus on distributed real-time applications [TM89b], its integrated support of monitoring tools used for timing evaluation and display <ref> [Tok88] </ref>, and its later support of real-time communication protocols addressing live video transmission [TTCM92]. Objects in ARTS are much like those developed earlier in the CHAOS systems [SGB87, GS93]; they can be passive or active. An active object contains one or more user defined threads.
Reference: [TTCM92] <author> H. Tokuda, Y. Tobe, S. Chou, and J. Moura. </author> <title> Continuous media communication with dynamic qos control using arts with an fddi network. </title> <type> Personal Communication, </type> <month> October </month> <year> 1992. </year>
Reference-contexts: Several numerical examples are presented to demonstrate the effectiveness and practicality of the proposed algorithms. 2.3 Future Work Current and future work in real-time scheduling must address the highly dynamic, complex environments of large-scale real-time systems, such as national networks carrying time-constrained communications (e.g., multi-media applications like real-time video transmission <ref> [TTCM92] </ref> or collaboration systems [HK88]), or large-scale theater battle management systems [MS93], or large-scale real-time simulations [GFS93]. <p> The novel aspects of ARTS are its initial focus on distributed real-time applications [TM89b], its integrated support of monitoring tools used for timing evaluation and display [Tok88], and its later support of real-time communication protocols addressing live video transmission <ref> [TTCM92] </ref>. Objects in ARTS are much like those developed earlier in the CHAOS systems [SGB87, GS93]; they can be passive or active. An active object contains one or more user defined threads. In the active object, the designer of the object is responsible for providing concurrency control among co-executing operations. <p> Furthermore, a Real--time Transfer Protocol (RTP) is developed to explore real-time communication issues. RTP features prioritized messages and a time fence mechanism. The RTP manager implements the RTP protocol and, thus, forms a single point through which remote communications must pass. In <ref> [TTCM92] </ref>, the Capacity-Based Session Reservation Protocol (CBSRP) is extended in order to realize predictable real-time communications. The extension of CBSRP is evaluated on a Fiber Distributed Data Interface (FDDI) in ARTS. <p> Although some compression schemes such as JPEG [Wal91], MPEG [Gal91], and px64 [Lio91] have been suggested to reduce data size, high quality video frames are usually too large for a conventional local area network <ref> [TTCM92] </ref>. For asynchronous applications like interactive video/teleconferencing, end-to-end delay has to be bounded and observable jitter should be avoided [TTCM92]. Because of these temporal and spatial constraints, continuous media communication requires special resource management [ATW + 89]. <p> schemes such as JPEG [Wal91], MPEG [Gal91], and px64 [Lio91] have been suggested to reduce data size, high quality video frames are usually too large for a conventional local area network <ref> [TTCM92] </ref>. For asynchronous applications like interactive video/teleconferencing, end-to-end delay has to be bounded and observable jitter should be avoided [TTCM92]. Because of these temporal and spatial constraints, continuous media communication requires special resource management [ATW + 89]. <p> These protocols can be divided into two classes: reservation and non-reservation based protocol <ref> [TTCM92] </ref>. The ST-II, and SRP protocols reserve system resources such as processor execution time, buffers, and network bandwidth before transmitting any data. A similar resource reservation model, a real-time channel, has been proposed for a wide area network environment [FV90]. Such reservation of resources requires significant operating system support. <p> Such reservation of resources requires significant operating system support. On the other hand, VMTP and XTP transfer data on a best-effort basis and without any resource reservation. However, they do not guarantee on the end-to-end delay or jitter bound for a session <ref> [TTCM92] </ref>. 34 The best known research efforts in this area are performed by Ferrari at UC Berkeley. Their recent research has resulted in the construction of a real-time IP protocol, called RTIP [Zha91]. Many other results regarding real-time communication are available from that group. In [TTCM92], Tokuda et al. present a <p> jitter bound for a session <ref> [TTCM92] </ref>. 34 The best known research efforts in this area are performed by Ferrari at UC Berkeley. Their recent research has resulted in the construction of a real-time IP protocol, called RTIP [Zha91]. Many other results regarding real-time communication are available from that group. In [TTCM92], Tokuda et al. present a Capacity-Based Session Reservation protocol (CBSRP) in order to provide guaranteed end-to-end delivery of data through resource reservation in a local area network environment.
Reference: [Wal91] <author> G. Wallace. </author> <title> The jpeg still picture compression standard. </title> <journal> Communications of the ACM, </journal> <volume> 34(4), </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: A running continuous media application, such as full motion video, can occupy significant bandwidth of the computer resource. Although some compression schemes such as JPEG <ref> [Wal91] </ref>, MPEG [Gal91], and px64 [Lio91] have been suggested to reduce data size, high quality video frames are usually too large for a conventional local area network [TTCM92]. For asynchronous applications like interactive video/teleconferencing, end-to-end delay has to be bounded and observable jitter should be avoided [TTCM92].
Reference: [WC87] <author> C. M. Woodside and D. W. Craig. </author> <title> Local non-preemptive scheduling policies for hard real-time distributed systems. </title> <booktitle> In Proceedings of IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 12-16, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: They then show that the sharing of incomplete (vs. complete) information can lead to increased performance regarding scheduling latency with few or no losses in scheduling quality. Most distributed scheduling algorithms have two common features <ref> [WC87] </ref>: (1) a global task sharing strategy between nodes and (2) a local scheduling policy for individual nodes. The local scheduling policy is often based on heuristics that efficiently determine which task to accept and which task to reject. <p> The authors in [KSC86] extend analytic results for an elementary load sharing algorithm with tasks of fixed laxity and a fixed delay in node sharing, again assuming a FCFS local scheduling algorithm. In <ref> [WC87] </ref>, the commonly used local non-preemptive algorithms are examined, and their performance is compared with regard to rejection ratio and expected task laxity at rejection.
Reference: [Wel92] <author> A. Wellings. </author> <title> Ada run-time environment working group meeting summary. </title> <journal> Ada Letters, </journal> <volume> 12(5) </volume> <pages> 30-35, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: In [BP91], the authors present a brief description of some of the Ada 9X proposals that are intended to address hard real-time requirements. Ada 9X is a revision to the Ada programming language standard <ref> [Wel92] </ref>. The reports [Inc92, QD92, Sof92] present some results of real-time implementation studies of Ada. In [BJ87, Bak87, BJ86], the authors present the interface of a run-time environment for real-time Ada. In [Bri92], the author deals with different possible time representations and their utilization in real-time Ada systems.
Reference: [Wir77] <author> N. Wirth. </author> <title> Toward a discipline of real-time programming. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 577-583, </pages> <month> August </month> <year> 1977. </year> <month> 45 </month>
Reference-contexts: The programming model supported by YARTOS is an extension of Wirth's discipline of real time programming <ref> [Wir77] </ref>. It is a message passing system with a semantics of inter-process communication that specifies the real-time response that an operating system must provide to a message receiver. These semantics provide a framework both for expressing processor-time dependent computations and for reasoning about the real-time behavior of programs.
Reference: [WOK + 87] <author> T. Wasano, M. Ohminami, Y. Kobayashi, T. Ohkubo, and K. Sakamura. </author> <booktitle> Design principles and configurations of ctron. In Proceedings of Fall Joint Computer Conference on Exploring Technology: Today and Tomorrow, </booktitle> <pages> pages 159-166, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: The CHAOS system is portable to multiple platforms due to its use of real-time threads as a lower layer. While the systems are not intended for commercial use, offshoots are being used in commercial robotics applications [BG92]. 4.3.10 The CTRON Operating System Framework CTRON <ref> [OWK87, WOK + 87, KOOH87, Sak89] </ref> is a part of the TRON 1 [Sak87c] platform for real-time operating systems. The general TRON project is designed for network nodes consisting of different kinds of computers.
Reference: [YA89] <author> X. Yuan and A. Agrawala. </author> <title> A decomposition approach to nonpreemptive real-time scheduling. </title> <type> Technical Report CS-TR-2345, </type> <institution> Department of Computer Science, University of Maryland, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: This results in somewhat inflexible process scheduling because prematurely finishing processes cannot relinquish their extra execution time to other processes [SZ92]. 4.3.3 The Maruti Distributed Real-Time Operating System The main focus of the Maruti project <ref> [GMAT90, Agr90, AL87, MA90, YA89, LA90] </ref> at the University of Maryland is to examine the constructs of future distributed, hard real-time, fault tolerant, secure operating systems. Maruti is an object-based system, with encapsulation of services.
Reference: [Zha91] <author> L. Zhang. </author> <title> Virtual clock: A new traffic control algorithm for packet-switched networks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 101-124, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: However, they do not guarantee on the end-to-end delay or jitter bound for a session [TTCM92]. 34 The best known research efforts in this area are performed by Ferrari at UC Berkeley. Their recent research has resulted in the construction of a real-time IP protocol, called RTIP <ref> [Zha91] </ref>. Many other results regarding real-time communication are available from that group. In [TTCM92], Tokuda et al. present a Capacity-Based Session Reservation protocol (CBSRP) in order to provide guaranteed end-to-end delivery of data through resource reservation in a local area network environment.
Reference: [ZRS87a] <author> W. Zhao, K. Ramamritham, and J. Stankovic. </author> <title> Scheduling tasks with resource requirements in hard real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> May </month> <year> 1987. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] and non-preemptive <ref> [Lei80, LY82, ZRS87a] </ref> scheduling algorithms extensively in the context of real-time systems. In [LL73], the authors show that the rate-monotonic and earliest deadline scheduling algorithms are optimal static priority and dynamic priority scheduling algorithms respectively, in a uni-processor preemptive scheduling environment. <p> The final module is a Meta Level Controller, which can adapt various parameters by noticing significant changes in the environment, and it can serve as the system's user interface. In <ref> [RS84, SRC85, ZRS87a] </ref>, the authors present and analyze the details of their scheduling algorithms. Memory Management: In the Spring kernel, the OS is core-resident.
Reference: [ZRS87b] <author> Wei Zhao, Krithi Ramamritham, and J. A. Stankovic. </author> <title> Preemptive scheduling under time and resource constraints. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(8):949-960, </volume> <month> August </month> <year> 1987. </year>
Reference-contexts: Chen et. al.[CL91] study a priority ceiling protocol for multiple-instance resources. They present an optimal resource-allocation algorithm which can be used to improve the schedulability of a real-time system. In contrast, the Earliest Deadline First (EDF) scheduling algorithm can be used for dynamic as well as static scheduling <ref> [ZRS87b, DM89, SZ92] </ref>. This algorithm uses the deadline of a task as its priority. The task with the earliest deadline has the highest priority. Since priorities are dynamic, the periods of tasks can be changed at any time.
Reference: [ZS91] <author> Hongyi Zhou and Karsten Schwan. </author> <title> Dynamic scheduling for hard real-time systems: Toward real-time threads. </title> <booktitle> In Proceedings of the Joint IEEE Workshop on Real-Time Operating Systems and Software and IFAC Workshop on Real-Time Programming, </booktitle> <address> Atlanta, GA. </address> <publisher> IEEE, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in [SZG91, ZSG92]. Evaluation and Algorithm Improvements. Researchers have studied both preemptive <ref> [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] </ref> and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. <p> [SFG + 91] as a base layer for uniprocessors and parallel architectures called the CHAOS base member of the kernel family. 3 A Concurrent, Hierarchical, Adaptable Operating System supporting atomic, real-time computations. 28 However, upwardly compatible modifications have been made to the cthread interface in order to accommodate real-time applications <ref> [ZS91] </ref>. Extensibility and customizability of the family are attained by use of the object model for description of the operating system's interface [SGB87, HFC76] and for operating system and user program implementation. <p> The resulting structure of the kernel family consists of three components: (1) the nugget implementing CHAOS base , which is a real-time cthreads package 4 <ref> [ZS91] </ref>, (2) the vanilla layer implementing CHAOS min , and (3) the policies or application implementing certain CHAOS arc flavors and attributes.
Reference: [ZSA91] <author> Hongyi Zhou, Karsten Schwan, and Ian Akyildiz. </author> <title> Performance effects of information sharing in a distributed multiprocessor real-time scheduler. </title> <type> Technical report, </type> <institution> College of Computing, Georgia Tech, GIT-CC-91/40, </institution> <month> Sept. </month> <year> 1991. </year> <note> Abbreviated version in 1992 IEEE Real-Time Systems Symposium, Phoenix. </note>
Reference-contexts: This algorithm is similar to algorithms developed for distributed systems, such as bidding algorithms [RS84]. This work is extended further in <ref> [ZSA91] </ref>. <p> As a result, researchers are now primarily addressing on-line scheduling, scheduling for parallel and distributed systems <ref> [ZSA91, SZG91] </ref>, and the semantics of timing constraints to be enforced in such future systems (e.g., hard deadlines are simply neither needed nor feasible as a formulation of timing constraints in multi-media applications). Researchers are also addressing the actual overheads experienced by on-line scheduling algorithms [ZSG92, SZ92].
Reference: [ZSG92] <author> Hongyi Zhou, Karsten Schwan, and Ahmed Gheith. </author> <title> The dynamic synchronization of real-time threads for multiprocessor systems. In Symposium on Experiences with Distributed and Multiprocessor Systems, </title> <address> Newport Beach, </address> <pages> pages 93-107. </pages> <publisher> Usenix, ACM, </publisher> <month> March. </month> <year> 1992. </year> <month> 46 </month>
Reference-contexts: The algorithm combines EDF scheduling with a synchronization scheme for access to shared resources. Synchronization is also addressed in <ref> [SZG91, ZSG92] </ref>. Evaluation and Algorithm Improvements. Researchers have studied both preemptive [LL73, MD78, LM80, Law81, Mok83, RS84, SLR86, ZS91] and non-preemptive [Lei80, LY82, ZRS87a] scheduling algorithms extensively in the context of real-time systems. <p> Researchers are also addressing the actual overheads experienced by on-line scheduling algorithms <ref> [ZSG92, SZ92] </ref>. This is resulting in more attention paid to scheduling algorithm and scheduler implementation rather than considerations of algorithm optimality and complexity (the latter only captures worst case performance, whereas we are often interested in average case performance in actual systems). <p> As a result, the critical regions in a programs are replaced by an invocation to a remote synchronization server. Unfortunately, a single centralized synchronization server will limit the scalability of the solution, and it will needlessly increase the cost of executing fine grain real-time applications. In <ref> [ZSG92] </ref>, the authors study mutual exclusion and synchronization for dynamic hard real-time multiprocessor applications.
References-found: 152

