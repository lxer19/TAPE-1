URL: http://www.cs.indiana.edu/database/Coral/manual.ps
Refering-URL: http://www.cs.indiana.edu/database/Coral/Coral.html
Root-URL: http://www.cs.indiana.edu
Email: fraghu,praveeng@cs.wisc.edu; divesh,sudarsha@research.att.com.  
Title: THE CORAL USER MANUAL A Tutorial Introduction to CORAL  
Author: Raghu Ramakrishnan Praveen Seshadri Divesh Srivastava S. Sudarshan 
Note: The authors' e-mail addresses are  
Address: WI 53706, U.S.A.  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison,  
Abstract-found: 0
Intro-found: 0
Reference: [BR87] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: The built-in predicate cputime (X) returns the current time. (Timing commands are also discussed in Section 12.) 9.1 Program Transformation Several program transformations are supported in CORAL. These include Magic Templates [Ram88], Supplementary Magic Templates <ref> [BR87] </ref>, Supplementary Magic with Indexing [RS91], Factoring [NRSU89, KRS90] and Existential Query Optimization [RBK88]. 9.1.1 Basic Rewriting Techniques Supplementary Magic Templates is chosen as the default rewriting technique.
Reference: [Bra90] <author> I. Bratko. </author> <title> Prolog Programming for Artificial Intelligence. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: We refer the reader to Bratko's book <ref> [Bra90] </ref>, from where this example was taken, for a detailed discussion. When parsing, it is common to identify a structure (e.g. noun-phrase) before all its "slots" (e.g. the noun-phrase matches the identifier john in some input sentence) are filled in.
Reference: [Bry89] <author> Francois Bry. </author> <title> Logic programming as constructivism: A formalization and its application to databases. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGART-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 34-50, </pages> <address> Philadelphia, Penn-sylvania, </address> <month> March </month> <year> 1989. </year>
Reference: [CDRS86] <author> Michael Carey, David DeWitt, Joel Richardson, and Eugene Shekita. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: A summary of these points is presented in 15. Relevant Sections 8, 9, 15 Disk-Resident Relations: Disk-resident persistent relations are supported using the EXODUS storage manager <ref> [CDRS86] </ref>. Relevant Sections 12 Multiple Workspaces: A workspace is a collection of relations, each defined by an explicit collection of facts or by a collection of rules. A user can simultaneously maintain several workspaces and switch between them. All queries are evaluated against the current workspace.
Reference: [KRS90] <author> D. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> left-, and multi-linear rule transformations that maintain context information. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 380-391, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: The built-in predicate cputime (X) returns the current time. (Timing commands are also discussed in Section 12.) 9.1 Program Transformation Several program transformations are supported in CORAL. These include Magic Templates [Ram88], Supplementary Magic Templates [BR87], Supplementary Magic with Indexing [RS91], Factoring <ref> [NRSU89, KRS90] </ref> and Existential Query Optimization [RBK88]. 9.1.1 Basic Rewriting Techniques Supplementary Magic Templates is chosen as the default rewriting technique. <p> It is useful when programs involve complex data structures, expecially non-ground structures. 9 The version of Factoring used in CORAL is the one described in <ref> [KRS90] </ref>. 76 export anc (bf). @no_rewriting. % No program transformation is done ... anc_bf (X,Y) :- anc (X,Y). % ... so this rule must be added to define anc_bf anc (X,Y) :- m_anc_bf (X), % The fact m_anc_bf (5) is automatically parent (X,Y). % added when computing answers to % ?anc
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: We refer the reader to introductory logic programming texts such as <ref> [Llo87] </ref>, for a detailed presentation of logic programs. The following examples illustrate these concepts informally (and briefly!). 4.1 Facts Assume that we have executed the command coral from the UNIX prompt. At the CORAL prompt n :&gt;, we can enter facts: n :&gt;employee (john, "Toys for Tots", 3, 35.5).
Reference: [NRSU89] <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Argument reduction through factoring. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <pages> pages 173-182, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: The built-in predicate cputime (X) returns the current time. (Timing commands are also discussed in Section 12.) 9.1 Program Transformation Several program transformations are supported in CORAL. These include Magic Templates [Ram88], Supplementary Magic Templates [BR87], Supplementary Magic with Indexing [RS91], Factoring <ref> [NRSU89, KRS90] </ref> and Existential Query Optimization [RBK88]. 9.1.1 Basic Rewriting Techniques Supplementary Magic Templates is chosen as the default rewriting technique.
Reference: [Ram88] <author> Raghu Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The built-in predicate cputime (X) returns the current time. (Timing commands are also discussed in Section 12.) 9.1 Program Transformation Several program transformations are supported in CORAL. These include Magic Templates <ref> [Ram88] </ref>, Supplementary Magic Templates [BR87], Supplementary Magic with Indexing [RS91], Factoring [NRSU89, KRS90] and Existential Query Optimization [RBK88]. 9.1.1 Basic Rewriting Techniques Supplementary Magic Templates is chosen as the default rewriting technique.
Reference: [RBK88] <author> Raghu Ramakrishnan, Catriel Beeri, and Ravi Krishnamurthy. </author> <title> Optimizing existential Datalog queries. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 89-102, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: The built-in predicate cputime (X) returns the current time. (Timing commands are also discussed in Section 12.) 9.1 Program Transformation Several program transformations are supported in CORAL. These include Magic Templates [Ram88], Supplementary Magic Templates [BR87], Supplementary Magic with Indexing [RS91], Factoring [NRSU89, KRS90] and Existential Query Optimization <ref> [RBK88] </ref>. 9.1.1 Basic Rewriting Techniques Supplementary Magic Templates is chosen as the default rewriting technique.
Reference: [Ros90] <author> Kenneth Ross. </author> <title> Modular Stratification and Magic Sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year>
Reference: [RS91] <author> Raghu Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1991. </year> <month> 122 </month>
Reference-contexts: The built-in predicate cputime (X) returns the current time. (Timing commands are also discussed in Section 12.) 9.1 Program Transformation Several program transformations are supported in CORAL. These include Magic Templates [Ram88], Supplementary Magic Templates [BR87], Supplementary Magic with Indexing <ref> [RS91] </ref>, Factoring [NRSU89, KRS90] and Existential Query Optimization [RBK88]. 9.1.1 Basic Rewriting Techniques Supplementary Magic Templates is chosen as the default rewriting technique.
Reference: [RS92] <author> Kenneth Ross and Yehoshua Sagiv. </author> <title> Monotonic aggregation in deductive databases. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 114-126, </pages> <year> 1992. </year>
Reference-contexts: A technique for getting around this problem is presented in Section 10. 7.5 Monotonic Programs Monotonic programs are a class of programs with aggregation and grouping that have an intuitive semantics, even though they are not even modularly stratified. They have been examined in <ref> [RS92, Van92] </ref>. We have already seen a monotonic program in the second version of the program for shortest path (in declad6.P). Since the aggregation operator was min, we were able to write the program using an aggregate selection.
Reference: [RSS90] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: The sccs are evaluated one at a time, beginning with those sccs at the "leaves" of the scc structure. Within each SCC, fixpoint evaluation is used. Predicate-wise Seminaive is a variant in which tuples generated within an iteration are made available for use before the end of the iteration <ref> [RSS90] </ref>. This results in a smaller number of iterations, each of which produces more facts (relative to corresponding iterations in BSN), in the presence of sccs with multiple recursive predicates. 9.2.1 Intelligent Backtracking CORAL also implements intra-rule intelligent backtracking (IB) in conjunction with both pipelined 10 and materialized execution.
Reference: [RSS92a] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: The next example illustrates non-stratified negation, which is supported in CORAL through the use of the Ordered Search algorithm <ref> [RSS92a] </ref>. Let us suppose that we have a complex mechanism constructed out of a number of components that may themselves be constructed from smaller components. Let the component-of relationship be expressed in the relation part. <p> Indeed, this similarity is not accidental; in both cases, the generation of a tuple requires us to be certain that we have already generated all tuples that could affect the contents of the tuple being generated. Thus, it is natural to expect that the Ordered Search technique <ref> [RSS92a] </ref> used to evaluate programs with negation can also be used to evaluate programs with grouping. <p> 58 query, this results in answers being available at the end of each iteration. 8.3 Negation, Grouping and Module Structure CORAL provides several alternative ways to deal with programs containing negation. (Everything that we say here holds for multiset-grouping as well.) First, CORAL provides an evaluation mechanism called Ordered Search <ref> [RSS92a] </ref> that evaluates programs with left-to-right modularly stratified negation. By default, a program with negation or grouping is evaluated using this method. (See Sections 5 and 6.) Second, a module can be evaluated using pipelining. This can be done by adding the annotation @pipelining to the module.
Reference: [RSS92b] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: In file declad1.P, we have: module declad_eg1. export dappend (bbf). % appends the two given lists; lists must be in difference-list form. % sample query: ?dappend (dlist ([1|[2|[3|X]]],X),dlist ([4|[5|Y]],Y),Z). 5 Aggregate selections in CORAL are general enough to subsume the choice operator that is described in <ref> [RSS92b] </ref>. dappend (dlist (X,Y), dlist (Y,V), dlist (X,V)). end_module. As the sample input illustrates, the lists are in difference-list form. A difference list is essentially a list represented as the difference of two lists, where the second list is just a variable. <p> This implies that, for a given root R, a spanning tree is constructed by choosing an X,C pair for each Y; that is, by choosing exactly one incoming edge for each node. (We note that the choice annotation that is described in <ref> [RSSS93, RSS92b] </ref> is just a special case of aggregate selections using any.) A minimum cost spanning tree can be constructed by ensuring that least-cost edges are chosen to extend the spanning tree, subject to the requirement that the "tree" property be preserved.
Reference: [RSSS92] <author> Raghu Ramakrishnan, Divesh Srivastava, S. Sudarshan, and Praveen Seshadri. </author> <title> Implementation of the CORAL deductive database system. </title> <note> Submitted, </note> <year> 1992. </year>
Reference-contexts: The overview complements this tutorial introduction by elaborating upon issues introduced and illustrated here, and the two documents are intended to be used in conjunction. In addition, there is an on-line help command. See "Implementation of the CORAL Deductive Database System" <ref> [RSSS92] </ref> for a description of how CORAL is implemented. 4 3 A First Session The example programs used in this chapter are quite simple, and are introduced informally.
Reference: [RSSS93] <author> Raghu Ramakrishnan, Praveen Seshadri, Divesh Srivastava, and S. Sudarshan. </author> <title> An overview of coral. </title> <note> Manuscript (full version of [RSS92b], which appeared in VLDB92)., </note> <year> 1993. </year>
Reference-contexts: Relevant Sections 13 and 14 Extensibility: CORAL is extensible in many ways: new data types as well as new relation and index implementations can be added. Relevant Sections 14 2.2 Other Documentation The reader is referred to "An Overview of CORAL" <ref> [RSSS93] </ref> for an overview. The overview complements this tutorial introduction by elaborating upon issues introduced and illustrated here, and the two documents are intended to be used in conjunction. In addition, there is an on-line help command. <p> The help command lets you find out many things that you need to know to use CORAL, but it does not discuss several language features that are described in this tutorial or the overview <ref> [RSSS93] </ref>. If you can't find a specific help topic that addresses your question, it is likely that you will find the information in this tutorial or its companion document, the overview. <p> The issue of efficiency is addressed in many of the subsequent chapters, and Section 15 contains a summary of the points to keep in mind. 14 4 Declarative Language Features: Basics In Section "Declarative Language Features: Basics" of <ref> [RSSS93] </ref>, the concepts of constants, variables, terms, facts and rules in CORAL are introduced. We refer the reader to introductory logic programming texts such as [Llo87], for a detailed presentation of logic programs. <p> Although the semantics of using this operation is in general non-deterministic, it is deterministic in many cases. A more detailed discussion of head updates is presented in the overview paper <ref> [RSSS93] </ref>. 7.3 Prioritization Sometimes, it is useful to be able to control the order in which the tuples in a relation get used in making derivations. The prioritize annotation gives a user such control. <p> This implies that, for a given root R, a spanning tree is constructed by choosing an X,C pair for each Y; that is, by choosing exactly one incoming edge for each node. (We note that the choice annotation that is described in <ref> [RSSS93, RSS92b] </ref> is just a special case of aggregate selections using any.) A minimum cost spanning tree can be constructed by ensuring that least-cost edges are chosen to extend the spanning tree, subject to the requirement that the "tree" property be preserved. <p> The @check subsumption annotation is illustrated in the second program in declac5.P. For more on the syntax of annotations for duplicate checks, we refer the reader to the overview document <ref> [RSSS93] </ref>. 9.2.4 Lazy Evaluation By default, any answers generated at the end of an iteration are returned, and CORAL waits to be prompted for more answers before continuing with further iterations. A similar interface exists for inter-module calls. <p> Some important guidelines for using arithmetic predicates are discussed in Section 3. 11.2 Multiset Operators A number of operators are provided for manipulating multiset values. These are discussed in Section 6 and in the overview <ref> [RSSS93] </ref>. We list these operators here for convenience: member, unionsum, unionmax, inter, difference, subset, make set, create set, add elem, count, sum, avg, min, max, prod. We note that an arithmetic expression cannot be listed as an element of a set. <p> We refer the reader to the overview document <ref> [RSSS93] </ref> for more details on extensibility in CORAL. 14.1 Arrays As a case study, we consider the addition of an array data type to CORAL. The first two steps in defining the array data type are best understood by carefully examining the file array:C, which is included in Appendix D.
Reference: [Van92] <author> A. Van Gelder. </author> <title> The well-founded semantics of aggregation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: A technique for getting around this problem is presented in Section 10. 7.5 Monotonic Programs Monotonic programs are a class of programs with aggregation and grouping that have an intuitive semantics, even though they are not even modularly stratified. They have been examined in <ref> [RS92, Van92] </ref>. We have already seen a monotonic program in the second version of the program for shortest path (in declad6.P). Since the aggregation operator was min, we were able to write the program using an aggregate selection.
Reference: [VRS91] <author> A. Van Gelder, K. Ross, and J. S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year> <month> 123 </month>
Reference-contexts: The examples discussed above are available in the file declne6.P. In summary, CORAL supports the well-founded model semantics <ref> [VRS91] </ref> for programs with negation that are non-floundering and left-to-right modularly stratified. For a more detailed discussion of modularly stratified programs, we refer the reader to the CORAL overview. 5.3 Negation in Pipelined Modules CORAL provides a mode of evaluation called "pipelining" that closely mimics Prolog-style evaluation.
References-found: 19

