URL: http://www-aig.jpl.nasa.gov/public/home/fukunaga/publications/compile-camera.ps
Refering-URL: http://www.cs.bham.ac.uk/~wbl/biblio/gp-bibliography.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: alex.fukunaga@jpl.nasa.gov, andre.stechert@jpl.nasa.gov, darren.mutz@jpl.nasa.gov  
Title: A Genome Compiler for High Performance Genetic Programming  
Author: Alex Fukunaga, Andre Stechert and Darren Mutz 
Address: 4800 Oak Grove Dr., M/S 126-347 Pasadena, CA 91109-8099  
Affiliation: Jet Propulsion Laboratory California Institute of Technology  
Abstract: Genetic Programming is very computationally expensive. For most applications, the vast majority of time is spent evaluating candidate solutions, so it is desirable to make individual evaluation as efficient as possible. We describe a genome compiler which compiles s-expressions to machine code, resulting in significant speedup of individual evaluations over standard GP systems. Based on performance results with symbolic regression, we show that the execution of the genome compiler system is comparable to the fastest alternative GP systems. We also demonstrate the utility of compilation on a real-world problem, lossless image compression. A somewhat surprising result is that in our test domains, the overhead of compilation is negligible. 
Abstract-found: 1
Intro-found: 1
Reference: [Bru97] <author> W.S. Bruce. </author> <title> The lawnmower problem revisited: Stack-based genetic programming and automatically defined functions. </title> <booktitle> In Proceedings of the Genetic Programming Conference, </booktitle> <pages> pages 52-57, </pages> <year> 1997. </year>
Reference-contexts: The relative merits of s-expression based GP vs. alternatives such as stack-based GP and CGPS is still an open research problem with respect to search effort, s-expression based GP seems to do better on some problems, while stack-based approaches do better on others (c.f., <ref> [Per94, Bru97] </ref>). Likewise, the dynamics of CGPS in comparison to traditional GP and stack-based GP are not well understood yet. Previous work had shown that alternative approaches such as stack-based GP and CGPS are capable of significantly faster execution of s-expressions than traditional s-expression GP.
Reference: [FS98] <author> A. Fukunaga and A. Stechert. </author> <title> Evolving nonlinear predictive models for lossless image compression with genetic programming. </title> <booktitle> In Proceedings of the Genetic Programming Conference, </booktitle> <year> 1998. </year>
Reference-contexts: We briefly describe the application below. Our compression system is detailed in another paper <ref> [FS98] </ref>. See [MW96, MW97] for more details on predictive coding based image compression. Predictive coding is an image compression technique which uses a compact model of an image to predict pixel values of an image based on the values of neighboring pixels. <p> the overhead of compilation can be negligible, so that the speed benefits of compilation can be significant even when the number of times individuals are repeatedly evaluated is small. 8 6 The compression ratios obtained by this system are promising, but are beyond the scope of the present paper (see <ref> [FS98] </ref>). 7 [FS98] describes a faster implementation which removes much of the overhead of the entropy coding. 8 Figure 7 shows that significant speed benefits can be obtained for symbolic regression even when only 5-10 test cases are used. <p> of compilation can be negligible, so that the speed benefits of compilation can be significant even when the number of times individuals are repeatedly evaluated is small. 8 6 The compression ratios obtained by this system are promising, but are beyond the scope of the present paper (see <ref> [FS98] </ref>). 7 [FS98] describes a faster implementation which removes much of the overhead of the entropy coding. 8 Figure 7 shows that significant speed benefits can be obtained for symbolic regression even when only 5-10 test cases are used.
Reference: [JP96] <author> H. Juille and J.B. Pollack. </author> <title> Massively parallel genetic programming. </title> <editor> In P. Angeline and K. Kinnear, editors, </editor> <booktitle> Advances in Genetic Programming 2. </booktitle> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: While the previous stack-based approaches used a linear representation internally, Juille and Pollack implemented a system which applies genetic operators to s-expressions, but previous to execution, compiles them into a linear representation for execution on a stack-based virtual machine <ref> [JP96] </ref>. Note that in this scheme, there is no problem of handling possible stack underflow during execution, because the linear programs are directly translated from s-expressions that guarantee that the arity of the functions is correct. <p> However, HiGP performs evolution at this level, using a string-based genetic algorithms approach. Our system acts instead as a means of speeding up the execution of standard tree-based GP systems. Our method is perhaps most similar to <ref> [JP96] </ref> in that population members are "pre-compiled" down to a stack-executable form; the genome compiler takes that approach one step further and compiles the stack-executable instructions down to the machine code level. 4 Empirical Evaluation We evaluated the performance improvements obtained using the genome compiler on two tasks, symbolic regression and
Reference: [KM94] <author> M.J. Keith and M.C. Martin. </author> <title> Genetic programming in C++: Implementation issues. </title> <editor> In K. Kinnear, editor, </editor> <booktitle> Advances in Genetic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: This problem is not unique to lil-gp: Keith and Martin <ref> [KM94] </ref> observed that function call overhead 1 can overwhelm the time actually required to eval-uate nodes, even with a very efficient, linear (non-recursive) s-expression representation. <p> We conclude in Section 5 with a discussion of results and directions for future work. 2 Related Work A number of researchers have addressed the problem of highly efficient implementations of genetic programming. Keith and Martin <ref> [KM94] </ref> observed that the re 1 As far as we know, this term was coined by Keith and Martin in [KM94]. cursive evaluation of the standard tree representation of s-expressions and used in GP systems widely used by the GP research community such as SGPC [TC93] lil-gp [PZ96] was inefficient because <p> Keith and Martin <ref> [KM94] </ref> observed that the re 1 As far as we know, this term was coined by Keith and Martin in [KM94]. cursive evaluation of the standard tree representation of s-expressions and used in GP systems widely used by the GP research community such as SGPC [TC93] lil-gp [PZ96] was inefficient because much time is used parsing the type token for each node in the tree.
Reference: [Koz92] <author> J. Koza. </author> <title> Genetic Programming: On the Programming of Computers by Means of Natural Selection. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Genetic programming <ref> [Koz92] </ref> (Figure 1) is a very computationally intensive task. It is well-known that in many applications to which genetic programming is applied, the vast majority of computational resources is used by the evaluate step in respect to an objective function. <p> In s-expression based genetic programming, the genetic operators assure that the arity of all functions is correct. This was cited as an advantage of using Lisp s-expressions as the program representation by Koza <ref> [Koz92] </ref>. <p> We used the test function f target (x) = x 9 . The genome compiler and standard lil-gp systems were configured as follows: population=500, generations=30, function set = f+; ; fl; %g (where % is the protected division operator <ref> [Koz92] </ref>), terminal set=X, tournament selection (size=5), 90% crossover, 10% reproduction, no mutation, depth limit 5). <p> The terminals and functions used were: * values of the four neighboring pixels Image [x-1,y-1], Image [x,y-1], Image [x+1,y-1], Image [x 1,y]. * selected constant values: 1, 5, 10, 100. * arithmetic functions +,-,*,% (protected divi sion <ref> [Koz92] </ref>) * the conditional operator (IFLTE arg1 arg2 ret1 ret2) which returns the value of ret1 if arg1 arg2, and the value of ret2 otherwise. * (MIN a b) and (MAX a b) functions which return the minimum and maximum values of their two arguments, respectively. <p> Further details will be provided in a future paper. Finally, another interesting direction in which to extend the genome compiler would be to imple-ment compiler optimizations which use editing operations <ref> [Koz92] </ref> or standard compiler optimization techniques to collapse instructions together, remove redundant operations, reorder operations, etc., to further speed up execution. Although this would add additional compilation overhead, the benefits may be worthwhile for applications such as image compression in which the individual is evaluated many times.
Reference: [MW96] <author> N. Memon and X. Wu. </author> <title> Lossless compression. In CRC Handbook of Communication. </title> <publisher> CRC Press, </publisher> <year> 1996. </year>
Reference-contexts: We briefly describe the application below. Our compression system is detailed in another paper [FS98]. See <ref> [MW96, MW97] </ref> for more details on predictive coding based image compression. Predictive coding is an image compression technique which uses a compact model of an image to predict pixel values of an image based on the values of neighboring pixels.
Reference: [MW97] <author> N. Memon and X. Wu. </author> <title> Recent progress in lossless image coding. </title> <journal> The Computer Journal, </journal> <volume> 40 </volume> <pages> 127-36, </pages> <year> 1997. </year>
Reference-contexts: We briefly describe the application below. Our compression system is detailed in another paper [FS98]. See <ref> [MW96, MW97] </ref> for more details on predictive coding based image compression. Predictive coding is an image compression technique which uses a compact model of an image to predict pixel values of an image based on the values of neighboring pixels.
Reference: [NB95] <author> P. Nordin and W. Banzhaf. </author> <title> Evolving Turing-complete programs for a register machine with self-modifying code. </title> <booktitle> In Proceedings of the International Conference on Genetic Algorithms. </booktitle> <publisher> Morgan Kauf-mann, </publisher> <year> 1995. </year>
Reference-contexts: Note that in this scheme, there is no problem of handling possible stack underflow during execution, because the linear programs are directly translated from s-expressions that guarantee that the arity of the functions is correct. Nordin developed the Compiling Genetic Programming System (CGPS) <ref> [Nor94, NB95] </ref>, which manipulates linear arrays of SPARC machine language instructions. Crossover and mutation are applied at the instruction boundaries, to ensure that the machine code resulting from the operations are valid. <p> A key point to note is that the C programming language provides the necessary flexibility here: it allows the programmer to create jumps to code that is generated at runtime by casting an integer array to a function pointer <ref> [NB95] </ref>. This eliminates the the overhead of invoking an external compiler. The computational complexity of compiling each s-expression down to machine executable code is lin 4 Note that not all function primitives in the individuals generated by the GP can be executed in a single instruction. <p> The arity four primitive ifgte is defined such that if its four arguments are a, b, c, and d it returns c if a b and d otherwise. The genome compiler approach is similar to <ref> [NB95] </ref> only in that both methods involve runtime machine code generation and execution; in our approach individuals are not manipulated at the machine code level. <p> Because of the use of machine language instructions, the CGPS system of Nordin and Banzhaf <ref> [NB95] </ref> is expected to be closest to our genome 5 Note that Stoffel and Spector stopped the lil-gp runs when the optimal solution was found, while in our experiments, the GP was run a full 30 generations. compiler with respect to genome evaluation speed. <p> The genome compiler performs roughly 50-60 times faster than SGPC running on the same machine, which is comparable to the execution speeds for CGPS reported by Nordin and Banzhaf <ref> [NB95] </ref>. 4.2 Lossless Image Compression The impetus for the development of the genome compiler was the need to perform efficient s-expression execution for the task of lossless image compression using a nonlinear predictive coding algorithm for which the nonlinear model was automatically generated using a genetic programming system.
Reference: [Nor94] <author> P. Nordin. </author> <title> A compiling genetic programming system that directly manipulates the machine-code. </title> <editor> In K. Kinnear, editor, </editor> <booktitle> Advances in Genetic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Note that in this scheme, there is no problem of handling possible stack underflow during execution, because the linear programs are directly translated from s-expressions that guarantee that the arity of the functions is correct. Nordin developed the Compiling Genetic Programming System (CGPS) <ref> [Nor94, NB95] </ref>, which manipulates linear arrays of SPARC machine language instructions. Crossover and mutation are applied at the instruction boundaries, to ensure that the machine code resulting from the operations are valid.
Reference: [Per94] <author> T. Perkis. </author> <title> Stack-based genetic programming. </title> <booktitle> In Proc. IEEE International Conference on Evolutionary Computation, </booktitle> <year> 1994. </year>
Reference-contexts: However, they observed that even with the efficient linear representation, function calls still posed a significant overhead, and suggested that the implementation of a genome compiler would be an interesting direction for future research. Perkis <ref> [Per94] </ref> first demonstrated the use of genetic operators (crossover and mutation) on a linear individual representation using a stack-based virtual machine (as opposed to the standard s-expression representation). 2 The idea of directly evolving stack-based linear programs was also used in HiGP, a high performance, parallel GP system developed by Stoffel <p> In s-expression based genetic programming, the genetic operators assure that the arity of all functions is correct. This was cited as an advantage of using Lisp s-expressions as the program representation by Koza [Koz92]. Given the good performance behavior reported for stack-based GP <ref> [Per94, SS96] </ref> in comparative experiments with standard s-expression based GP, it is now unclear whether there is any advantage to the ease of maintaining the closure property that the s-expression based approaches offer. 2 In contrast, Keith and Martin used a linear representation as a representation of s-expressions, and their genetic <p> The relative merits of s-expression based GP vs. alternatives such as stack-based GP and CGPS is still an open research problem with respect to search effort, s-expression based GP seems to do better on some problems, while stack-based approaches do better on others (c.f., <ref> [Per94, Bru97] </ref>). Likewise, the dynamics of CGPS in comparison to traditional GP and stack-based GP are not well understood yet. Previous work had shown that alternative approaches such as stack-based GP and CGPS are capable of significantly faster execution of s-expressions than traditional s-expression GP.
Reference: [PZ96] <author> B. Punch and D. Zonker. </author> <note> lil-gp genetic programming system version 1.1 beta version. </note> <institution> Michigan State University, </institution> <note> http://GARAGe.cps.msu.edu/software/lil-gp/index.html, 1996. </note>
Reference-contexts: We were made acutely aware of the need for an efficient individual evaluation process when we attempted to apply GP to image compression (see Section 4.2). Initially, we implemented the application using lil-gp <ref> [PZ96] </ref>, a standard GP system used by numerous researchers, and found that it was prohibitively slow to study genetic programming-based image compression. We therefore sought to significantly improve the speed of execution of the GP system. <p> Keith and Martin [KM94] observed that the re 1 As far as we know, this term was coined by Keith and Martin in [KM94]. cursive evaluation of the standard tree representation of s-expressions and used in GP systems widely used by the GP research community such as SGPC [TC93] lil-gp <ref> [PZ96] </ref> was inefficient because much time is used parsing the type token for each node in the tree. They showed that a linear, stack-based internal representation of s-expressions resulted in significant speed improvement over a tree representation.
Reference: [SS96] <author> K. Stoffel and L. Spector. </author> <title> High-performance, </title> <booktitle> paralle, stack-based genetic programming. In Proceedings of the Genetic Programming Conference, </booktitle> <pages> pages 224-229. </pages> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: the use of genetic operators (crossover and mutation) on a linear individual representation using a stack-based virtual machine (as opposed to the standard s-expression representation). 2 The idea of directly evolving stack-based linear programs was also used in HiGP, a high performance, parallel GP system developed by Stoffel and Spector <ref> [SS96] </ref>, which, like Perkis' system, works directly on a population of linear programs for a virtual stack machine. An interesting contrast between s-expression based approaches and stack-based approaches is in the enforcement of closure property (i.e., that guarantees all programs generated are valid and executable by the interpreter). <p> In s-expression based genetic programming, the genetic operators assure that the arity of all functions is correct. This was cited as an advantage of using Lisp s-expressions as the program representation by Koza [Koz92]. Given the good performance behavior reported for stack-based GP <ref> [Per94, SS96] </ref> in comparative experiments with standard s-expression based GP, it is now unclear whether there is any advantage to the ease of maintaining the closure property that the s-expression based approaches offer. 2 In contrast, Keith and Martin used a linear representation as a representation of s-expressions, and their genetic <p> The genome compiler approach is similar to [NB95] only in that both methods involve runtime machine code generation and execution; in our approach individuals are not manipulated at the machine code level. Like our compiler, The HiGP system described in <ref> [SS96] </ref> takes the approach of converting s-expressions into stack machine instructions, incorporating an extremely space efficient memory representation of individuals as well. However, HiGP performs evolution at this level, using a string-based genetic algorithms approach. <p> They compared the average time per generation of the two systems, and found that the maximum speedup (t lilgp =t HiGP ) measured was approximately 5, when the depth limit for lil-gp was set to 17 <ref> [SS96] </ref>. 5 The genome compiler, due to its use of machine code, achieves about an order of magnitude speedup over HiGP.
Reference: [TC93] <author> W. Tackett and A. Carmi. sgpc: </author> <title> simple genetic programming in C. </title> <address> ftp://ftp.io.com/pub/genetic-programming, </address> <year> 1993. </year>
Reference-contexts: Keith and Martin [KM94] observed that the re 1 As far as we know, this term was coined by Keith and Martin in [KM94]. cursive evaluation of the standard tree representation of s-expressions and used in GP systems widely used by the GP research community such as SGPC <ref> [TC93] </ref> lil-gp [PZ96] was inefficient because much time is used parsing the type token for each node in the tree. They showed that a linear, stack-based internal representation of s-expressions resulted in significant speed improvement over a tree representation. <p> Nordin reported that on a polynomial symbolic regression task, CGPS ran on average 60 times faster on symbolic regression than SGPC, a standard recursive tree evaluator based GP system written by Tackett and Carmi <ref> [TC93] </ref>, where both CGPS and SGPC was running on a SPARC IPX.
Reference: [WG94] <author> D. Weaver and T. </author> <title> Germond. The SPARC Architecture Manual, Version 9. </title> <publisher> PTR Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: This observation led us to conclude that translating the s-expressions evolved by the GP into a more terse machine language equivalent would greatly improve performance. Before each individual s-expression is evaluated, the genome compiler compiles it (at run-time) to SPARC machine language <ref> [WG94] </ref> code as described below. The method of generating machine executable code proceeds naturally from the standard recursive evaluation procedure.
References-found: 14

