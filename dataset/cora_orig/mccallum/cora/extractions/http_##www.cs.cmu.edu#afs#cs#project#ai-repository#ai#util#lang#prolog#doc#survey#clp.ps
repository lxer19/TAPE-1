URL: http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/util/lang/prolog/doc/survey/clp.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/util/lang/prolog/doc/survey/
Root-URL: http://www.cs.cmu.edu
Title: Constraint Logic Programming: A Survey Constraint Logic Programming (CLP) is a merger of two declarative
Author: Joxan Jaffar and Michael J. Maher 
Note: J. LOGIC PROGRAMMING: to appear 1  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> M. Abadi & Z. Manna, </author> <title> Temporal Logic Programming, </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8, </volume> <pages> 277-295, </pages> <year> 1989. </year>
Reference-contexts: Currently it is not clear whether the alternatives agree on other constraint operations. 12 FD is x 2 <ref> [1; 5] </ref> ^ y 2 [0; 7] ^ x 6= 3 ^ x + 2y 5 ^ x + y 9. The domain of x is f1; 2; 4; 5g. There are several other constraint domains of interest that we cannot exemplify here, for lack of space. <p> Operationally, it allows constraints on either the index X or element T of the list to be reflected by constraints on the other. For example, if X is constrained so that X 2 f1; 3; 5g then element (X; <ref> [1; 1; 2; 3; 5; 8] </ref>; T ) can constrain T so that T 2 f1; 2; 5g and, similarly, if T is constrained so that T 2 f1; 3; 5g then X is constrained so that X 2 f1; 2; 4; 5g. <p> Temporal logic adds to standard first-order logic such constructs as next (meaning, roughly, "in the next time instant" 40 ), always (meaning "in every future time instant"), and sometime (meaning "in some future time instant"). The language Templog <ref> [1] </ref> was designed based on a Horn-like subset of temporal logic in which the meaning of function symbols does not vary with time, but the meaning of predicate symbols does.
Reference: 2. <author> A. Aggoun & N. Beldiceanu, </author> <title> Extending CHIP to Solve Complex Scheduling and Packing Problems, In Journees Francophones De Programmation Logique, </title> <address> Lille, France, </address> <year> 1992. </year>
Reference-contexts: Execution of language constructs such as the cardinality operator [112], "constructive disjunction" [116] and special-purpose constructs (for example, in <ref> [77, 2] </ref>) can also be understood as ! i transitions, where these constructs are viewed as part of the language of constraints. Generally, the active constraints are determined syntactically. <p> Falling into the first category are some implementations of constraint disjunction [116, 72] (sometimes called "constructive disjunction") and the cardinality operator [112]. Into the second category fall the element constraint [77], and the cumulative constraint of <ref> [2] </ref>, among others. These constraints are already accounted for in the operational semantics of Section 5, since they can be considered passive constraints in L. However, it also can be useful to view them as additions to a better-known constraint domain (indeed, this is how they arose). <p> Operationally, it allows constraints on either the index X or element T of the list to be reflected by constraints on the other. For example, if X is constrained so that X 2 f1; 3; 5g then element (X; <ref> [1; 1; 2; 3; 5; 8] </ref>; T ) can constrain T so that T 2 f1; 2; 5g and, similarly, if T is constrained so that T 2 f1; 3; 5g then X is constrained so that X 2 f1; 2; 4; 5g. <p> Declaratively, the cumulative constraint of <ref> [2] </ref> expresses a collection of linear inequalities on its arguments. Several problems that can be expressed as integer programming problems can be expressed with cumulative. Operationally, it behaves somewhat differently from the way CHIP would usually treat the inequalities. 9.3. <p> Section 5.4.2 of [107] and section 2 of [78], on which this presentation is based, further discuss the problem and how particular features of CHIP can be useful. Another CHIP approach, but this time to a specific and practical scheduling problem is reported in [50]. In <ref> [2] </ref>, the focus is on a new feature of CHIP and how it can be used to obtain an optimal solution to a particular 10 jobs and 10 machine problem, which remained open until recently. Real scheduling problems can involve more kinds of constraints than just those mentioned above.
Reference: 3. <author> A. Aggoun & N. Beldiceanu, </author> <title> Overview of the CHIP Compiler System, in: Constraint Logic Programming: Selected Research, </title> <editor> F. Benhamou and A. Colmerauer (Eds.), </editor> <publisher> MIT Press, </publisher> <pages> 421-435, </pages> <year> 1993. </year>
Reference-contexts: Operationally, it allows constraints on either the index X or element T of the list to be reflected by constraints on the other. For example, if X is constrained so that X 2 f1; 3; 5g then element (X; <ref> [1; 1; 2; 3; 5; 8] </ref>; T ) can constrain T so that T 2 f1; 2; 5g and, similarly, if T is constrained so that T 2 f1; 3; 5g then X is constrained so that X 2 f1; 2; 4; 5g. <p> Some elements of the runtime structure will also be mentioned. In general, the essential features of the parts of an abstract machine dealing with constraints will differ greatly over CLP languages using different constraint domains. This is exemplified in the literature on CLP (R) [135], CHIP <ref> [3] </ref>, and CLP (FD) [75]. The following presentation, though based on one work [135], contains material that is relevant to abstract machines for many CLP languages. We begin by arguing that an abstract machine is the right approach in the first place.
Reference: 4. <author> A. Aiba, K. Sakai, Y. Sato, D. Hawley & R. Hasegawa, </author> <title> Constraint Logic Programming Language CAL, </title> <booktitle> Proc. International Conference on Fifth Generation Computer Systems 1988, </booktitle> <pages> 263-276, </pages> <year> 1988. </year>
Reference-contexts: Trilogy [256, 257] computes over strings, integers and real numbers. Although its syntax is closer to that of C, 2LP [170] can be considered to be a CLP language permitting only a subset of Horn clauses. It computes with linear constraints over integers and real numbers. CAL <ref> [4] </ref> computes over two domains: the real numbers, where constraints are equations between polynomials and a Boolean algebra with symbolic values, where equality between Boolean formulas expresses equivalence in the algebra. Instead of delaying non-linear constraints, CAL makes partial use of these constraints during computation. <p> We now present some example constraint domains. In practice, these are not always fully implemented, but we leave discussion of that until later. Most general purpose CLP languages incorporate some arithmetic domain, including BNR-Prolog [198], CAL <ref> [4] </ref>, CHIP [76], CLP (R) [133], Prolog III [64], RISC-CLP (Real) [120]. Example 2.1. Let contain the constants 0 and 1, the binary function symbols + and fl, and the binary predicate symbols =, &lt; and . <p> Then WE = (D; L) is the constraint domain of equations on strings, sometimes called the domain of word equations. An example constraint is x:a = b:x. The constraint domain of Boolean values and functions is used in BNR-Prolog [198], CAL <ref> [4] </ref>, CHIP [76] and Prolog III [64]. CAL and CHIP employ a more general constraint domain, which includes symbolic Boolean values. Example 2.6. Let contain the constants 0 and 1, the unary function symbol :, the binary function symbols ^; _; ; ), and the binary predicate symbol =. <p> However systems may employ a conservative but incomplete (or partial) test: if D j= ~ 9 C then consistent (C) holds, but sometimes consistent (C) holds although D j= : ~ 9 C. One example of such a system is CAL <ref> [4] </ref> which computes over the domain of real numbers, but tests consistency over the domain of complex numbers. The function inf er (C; S) computes from the current sets of constraints a new set of active constraints C 0 and passive constraints S 0 .
Reference: 5. <author> H. At-Kaci, </author> <title> An Algebraic Semantics Approach to the Effective Resolution of Type Equations, </title> <booktitle> Theoretical Computer Science 45, </booktitle> <pages> 293-351, </pages> <year> 1986. </year>
Reference-contexts: It can be viewed as the restriction of domains over which LOGIN [7] and LIFE [9] compute when all sorts are disjoint. The close relationship between the constraints and -terms <ref> [5] </ref> is emphasized by a syntactic sugaring of the constraints. Example 2.4. Let = f=g [ S [ F where S is a set of unary predicate symbols (sorts) and F is a set of binary predicate symbols (features). <p> Currently it is not clear whether the alternatives agree on other constraint operations. 12 FD is x 2 <ref> [1; 5] </ref> ^ y 2 [0; 7] ^ x 6= 3 ^ x + 2y 5 ^ x + y 9. The domain of x is f1; 2; 4; 5g. There are several other constraint domains of interest that we cannot exemplify here, for lack of space. <p> Operationally, it allows constraints on either the index X or element T of the list to be reflected by constraints on the other. For example, if X is constrained so that X 2 f1; 3; 5g then element (X; <ref> [1; 1; 2; 3; 5; 8] </ref>; T ) can constrain T so that T 2 f1; 2; 5g and, similarly, if T is constrained so that T 2 f1; 3; 5g then X is constrained so that X 2 f1; 2; 4; 5g.
Reference: 6. <author> H. At-Kaci, </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction, </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In Prolog, constraints are equations between terms, represented internally as bindings of variables. Since variables are implemented as pointers to their bound values 31 , backtracking can be facilitated by the simple mechanism of an untagged trail <ref> [261, 6] </ref>. This identifies the set of variables which have been bound since the last choice point. Upon backtracking, these variables are simply reset to become unbound. Thus in Prolog, the only information to be trailed is which variables have just become bound, and untrailing simply unbinds these variables. <p> In doing so they can often be used to express programs in exactly the right form for tackling the efficiency issues of a source language. For example, the Warren Abstract Machine <ref> [261, 6] </ref> revolutionized the execution of Prolog, since translating programs 51 to the WAM exposed many opportunities for optimization that were not apparent at the source level.
Reference: 7. <author> H. At-Kaci & R. Nasr, </author> <title> LOGIN: A Logic Programming Language with Built-in Inheritance, </title> <journal> Journal of Logic Programming 3, </journal> <pages> 185-215, </pages> <year> 1986. </year>
Reference-contexts: Prolog III also computes over a domain of strings. There are now several languages which compute over finite domains in the manner of CHIP, including clp (FD)[75], Echidna [103] and Flang [181]. cc (FD) [116] is essentially a second-generation CHIP system. LOGIN <ref> [7] </ref>, and LIFE [9] compute over an order-sorted domain of feature trees. This domain provides a limited notion of object (in the object-oriented sense). The languages support a term syntax which is not first-order, although every term can be interpreted through first-order constraints. <p> The next domain contains objects similar to the previous domains, but has a different signature and constraint language [12] 8 , which results in slightly different expressive power. It can be viewed as the restriction of domains over which LOGIN <ref> [7] </ref> and LIFE [9] compute when all sorts are disjoint. The close relationship between the constraints and -terms [5] is emphasized by a syntactic sugaring of the constraints. Example 2.4. <p> Currently it is not clear whether the alternatives agree on other constraint operations. 12 FD is x 2 [1; 5] ^ y 2 <ref> [0; 7] </ref> ^ x 6= 3 ^ x + 2y 5 ^ x + y 9. The domain of x is f1; 2; 4; 5g. There are several other constraint domains of interest that we cannot exemplify here, for lack of space.
Reference: 8. <author> H. At-Kaci, P. Lincoln & R. Nasr, </author> <title> Le Fun: Logic Equations and Functions, </title> <booktitle> Proc. Symposium on Logic Programming, </booktitle> <pages> 17-23, </pages> <year> 1987. </year>
Reference-contexts: These languages are not based on Horn clauses (they include a universal quantifier) and were not originally described as CLP languages. However it is argued in [187] that their operational behavior is best understood as the behavior of a CLP language. An earlier language, Le Fun <ref> [8] </ref>, also computed over this domain, and can be viewed as a CLP language with a weak constraint solver. 1.4. Synopsis The remainder of this paper is organized into three main parts. In part one we provide a formal framework for CLP. <p> They include pseudo-Boolean constraints (for example, [26]), which are intermediate between Boolean and integer constraints, order-sorted feature algebras [10], domains consisting of regular sets of strings [258], domains of finite sets [79], domains of CLP (Fun (D)) which employ a function variable [117], domains of functions expressed by -expressions <ref> [190, 8, 189, 200, 187] </ref>, etc. It is also possible to form a constraint domain directly from objects and operations in an application, instead of more general-purpose domains such as those above. <p> Operationally, it allows constraints on either the index X or element T of the list to be reflected by constraints on the other. For example, if X is constrained so that X 2 f1; 3; 5g then element (X; <ref> [1; 1; 2; 3; 5; 8] </ref>; T ) can constrain T so that T 2 f1; 2; 5g and, similarly, if T is constrained so that T 2 f1; 3; 5g then X is constrained so that X 2 f1; 2; 4; 5g.
Reference: 9. <author> H. At-Kaci & A. </author> <title> Podelski, Towards a Meaning of LIFE, </title> <journal> Journal of Logic Programming, </journal> <volume> 16, </volume> <pages> 195-234, </pages> <year> 1993. </year>
Reference-contexts: Prolog III also computes over a domain of strings. There are now several languages which compute over finite domains in the manner of CHIP, including clp (FD)[75], Echidna [103] and Flang [181]. cc (FD) [116] is essentially a second-generation CHIP system. LOGIN [7], and LIFE <ref> [9] </ref> compute over an order-sorted domain of feature trees. This domain provides a limited notion of object (in the object-oriented sense). The languages support a term syntax which is not first-order, although every term can be interpreted through first-order constraints. <p> The next domain contains objects similar to the previous domains, but has a different signature and constraint language [12] 8 , which results in slightly different expressive power. It can be viewed as the restriction of domains over which LOGIN [7] and LIFE <ref> [9] </ref> compute when all sorts are disjoint. The close relationship between the constraints and -terms [5] is emphasized by a syntactic sugaring of the constraints. Example 2.4.
Reference: 10. <author> H. At-Kaci & A. </author> <title> Podelski, Entailment and Disentailment of Order-Sorted Feature Constraints, </title> <type> manuscript, </type> <year> 1993. </year>
Reference-contexts: The domain of x is f1; 2; 4; 5g. There are several other constraint domains of interest that we cannot exemplify here, for lack of space. They include pseudo-Boolean constraints (for example, [26]), which are intermediate between Boolean and integer constraints, order-sorted feature algebras <ref> [10] </ref>, domains consisting of regular sets of strings [258], domains of finite sets [79], domains of CLP (Fun (D)) which employ a function variable [117], domains of functions expressed by -expressions [190, 8, 189, 200, 187], etc.
Reference: 11. <author> H. At-Kaci & A. </author> <title> Podelski, A General Residuation Framework, </title> <type> manuscript, </type> <year> 1993. </year>
Reference-contexts: The former introduces a committed-choice aspect into the language, whereas the latter is a variant of the second approach. All these approaches originated for conventional logic programs, but the ideas lift to constraint logic programs, and there are now several proposals based on these ideas <ref> [137, 234, 11, 113, 116] </ref>. One potential problem with using guarded rules is that the completeness of the operational semantics with respect to the logical semantics of the program can be lost.
Reference: 12. <author> H. At-Kaci, A. Podelski & G. Smolka, </author> <title> A Feature-based Constraint System for Logic Programming with Entailment, </title> <note> Theoretical Computer Science, to appear. Also in: </note> <editor> Proc. </editor> <booktitle> International Conference on Fifth Generation Computer Systems 1992, </booktitle> <volume> Vol. 2, </volume> <year> 1992, </year> <pages> 1012-1021. </pages>
Reference-contexts: The next domain contains objects similar to the previous domains, but has a different signature and constraint language <ref> [12] </ref> 8 , which results in slightly different expressive power. It can be viewed as the restriction of domains over which LOGIN [7] and LIFE [9] compute when all sorts are disjoint. The close relationship between the constraints and -terms [5] is emphasized by a syntactic sugaring of the constraints. <p> The property has been shown to hold for several classes of constraints including equations on finite, rational and infinite trees [161, 160, 174], linear real arithmetic constraints (where only equations may be negated) [162], sort and feature constraints on feature trees <ref> [12] </ref>, and infinite Boolean algebras with positive constraints [106], among others [163]. We consider a restricted form of independence of negative constraints [177]. Definition 2.3. <p> However there are still several useful constraint domains known to have this property, including the algebras of finite, rational and infinite trees with equational constraints, when there are infinitely many function symbols [161, 174], feature trees with infinitely many sorts and features <ref> [12] </ref>, linear arithmetic equations over the rational or real numbers, and infinite Boolean algebras with positive constraints [106]. Example 2.9. <p> The satisfiability problem for feature trees is essentially the same as the satisfi-ability problem for rational trees, provided that the number of features that may occur is bounded by a known constant <ref> [12] </ref>. (Generally this bounding constant can be determined at compile-time.) Two different sort constraints on the same variable clash in the same way that different function symbols on terms in RT clash. <p> Enumeration algorithms have the same behavior: they exhibit a solution, and may retain some further information, but they do not compute a solved form. In the domain of feature trees FE AT equations occur only between variables. Thus Algorithm 1 does not address the whole problem. Existing algorithms <ref> [12, 235] </ref> employ a solved form in which all implied equations between variables are explicit and there are no clashes of sort. Such solved forms are, in fact, solution forms. <p> Four recent works have addressed this problem, all in the context of a CLP system, but with slightly differing constraint domains. We will discuss them all in terms of RT . With some modifications, these works can also apply to FT . In <ref> [235, 12] </ref> a theoretical foundation is built. [235] then proposes a concrete algorithm, very roughly as follows: the to-be-entailed constraint c is added to the constraint store C. The satisfiability tester has the capability of detecting whether c is entailed by or inconsistent with C.
Reference: 13. <author> L. Albert, R. Casas & F. Fages, </author> <title> Average-case Analysis of Unification Algorithms, </title> <booktitle> Theoretical Computer Science 113, </booktitle> <pages> 3-34, </pages> <year> 1993. </year>
Reference-contexts: The reason for this choice (of algorithms which are quadratic time or slower in the worst case) is the belief that these algorithms are faster on average <ref> [13] </ref>. For the arithmetic domain of &lt; LinEqn , the most straightforward algorithm is based on Gaussian elimination, and this has quadratic worst-case complexity. For the more general domain &lt; Lin , polynomial time algorithms are also known [141], but these algorithms are not used in practical CLP systems.
Reference: 14. <author> K. Apt, H. Blair & A. Walker, </author> <title> Towards a Theory of Declarative Knowledge, in: Foundations of Deductive Databases and Logic Programming, </title> <editor> J. Minker (Ed), </editor> <publisher> Morgan Kaufmann, </publisher> <pages> 89-148, </pages> <year> 1988. </year>
Reference-contexts: Negation Treatments of negation in logic programming lift readily to constraint logic programming, with only minor adjustments necessary. Indeed many of the semantics for programs with negation are essentially propositional, being based upon the collection of ground instances of program rules. The perfect model <ref> [203, 14, 100] </ref>, well-founded model [101], stable model [102] and Fitting fixedpoint semantics [90], to name but a few, fall into this category.
Reference: 15. <author> C. Atay, </author> <title> A Parallelization of the Constraint Logic Programming Language 2LP, </title> <type> Ph.D. thesis, </type> <institution> City University of New York, </institution> <year> 1992. </year>
Reference-contexts: The first work in this area [108] was an experimental implementation of an or-parallel for a CLP language with domain F D. That approach has been pursued with the development of the ElipSys system [254], which is the most developed of the parallel implementations of CLP languages. Atay <ref> [15, 16] </ref> presents the or-parallelization of 2LP, a language that computes with linear inequalities over reals and integers, but in which rules do not have local variables 37 . Another work deals with the or-parallel implementation of a CLP language over F D on massively parallel SIMD computers [252].
Reference: 16. <author> C. Atay, K. McAloon & C. Tretkoff, 2LP: </author> <title> A Highly Parallel Constraint Logic Programming Language, </title> <booktitle> Proc. 6th. SIAM Conf. on Parallel Processing for Scientific Computing, </booktitle> <year> 1993. </year>
Reference-contexts: The first work in this area [108] was an experimental implementation of an or-parallel for a CLP language with domain F D. That approach has been pursued with the development of the ElipSys system [254], which is the most developed of the parallel implementations of CLP languages. Atay <ref> [15, 16] </ref> presents the or-parallelization of 2LP, a language that computes with linear inequalities over reals and integers, but in which rules do not have local variables 37 . Another work deals with the or-parallel implementation of a CLP language over F D on massively parallel SIMD computers [252].
Reference: 17. <author> R. Barbuti, M. Codish, R. Giacobazzi & M.J. Maher, </author> <title> Oracle Semantics for Pro-log, </title> <booktitle> Proc. 3rd Conference on Algebraic and Logic Programming, </booktitle> <volume> LNCS 632, </volume> <pages> 100-115, </pages> <year> 1992. </year>
Reference-contexts: Since depth-first search is incomplete on infinite trees, not all answers are computed. The depth-first search can be incorporated in the semantics in the same way as is done for Prolog (see, for example, <ref> [18, 17] </ref>), but we will not go into details here.
Reference: 18. <author> M. Baudinet, </author> <title> Proving Termination Properties of Prolog: A Semantic Approach, </title> <booktitle> Proc. 3rd. Symp. Logic in Computer Science, </booktitle> <pages> 334-347, </pages> <year> 1988. </year> <month> 73 </month>
Reference-contexts: Since depth-first search is incomplete on infinite trees, not all answers are computed. The depth-first search can be incorporated in the semantics in the same way as is done for Prolog (see, for example, <ref> [18, 17] </ref>), but we will not go into details here.
Reference: 19. <author> M. Baudinet, J. Chomicki & P. Wolper, </author> <title> Temporal Deductive Databases, in Temporal Databases: Theory, Design and Implementation, </title> <editor> A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev and R. Snodgrass (Eds), Benjamin/Cummings, </editor> <year> 1993. </year>
Reference-contexts: Simple domains have been considered because of over-riding requirements for quick and terminating execution of queries, as discussed in section 7. Furthermore, often the restriction is made that only one or two arguments in a tuple are time-valued, with the other arguments taking constant values. <ref> [19] </ref> surveys work in this area using an integer model of time. 13. Combinatorial Search Problems CLP offers an easy realization of enumeration algorithms for the solving of combinatorial problems.
Reference: 20. <editor> F. Benhamou & A. Colmerauer (Eds.), </editor> <booktitle> Constraint Logic Programming: Selected Research, </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Appropriate background can be obtained from [168] for LP and [223] for logic. For introductory papers on constraint logic programming and CLP languages we refer the reader to [63, 65, 156, 94]. For further reading on CLP we suggest other surveys [58, 109, 110], some collections of papers <ref> [20, 143, 111] </ref>, and some books [107, 214]. More generally, papers on CLP appear in various journals and conference proceedings devoted to computational logic, constraint processing or symbolic computation. 7 1.5. Notation and Terminology This paper will (hopefully) keep to the following conventions.
Reference: 21. <author> F. </author> <title> Benhamou, Boolean Algorithms in PROLOG III, in: Constraint Logic Programming: Selected Research, </title> <editor> F. Benhamou and A. Colmerauer (Eds.), </editor> <publisher> MIT Press, </publisher> <pages> 307-325, </pages> <year> 1993. </year>
Reference-contexts: A related technique is based on enumeration and propagation. The constraints are expressed as a conjunction of simple constraints and then local propagation simplifies the conjunction after each enumeration step. See [56], for example. The method used in Prolog III <ref> [21] </ref> is a modification of SL-resolution whose main element is the elimination of redundant expressions. Another technique comes from Operations Research. Here the boolean formula is restated in arithmetic form, with variables constrained to be 0 and 1. Then standard techniques for integer programming, for example cutting-planes, can be used.
Reference: 22. <author> F. </author> <title> Benhamou & J-L. Massat, Boolean Pseudo-equations in Constraint Logic Programming, </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <pages> 517-531, </pages> <year> 1993. </year>
Reference-contexts: In Section 10 we will discuss problems and techniques which arise when implementing these operations in a CLP system. However, we point out here that some implementations of these operators in particular, the test for satisfiability are incomplete. In some cases it has been argued <ref> [67, 66, 22] </ref> that although an algorithm is incomplete with respect to the desired constraint domain, it is complete with respect to another (artificially constructed) constraint domain. We now turn to some properties of constraint domains which will be used later.
Reference: 23. <author> F. Berthier, </author> <title> A Financial Model using Qualitative and Quantitative Knowledge, </title> <booktitle> Proceeedings of the International Symposium on Computational Intelligence 89, Milano, </booktitle> <pages> 1-9, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: In general, engineering applications such as these use CLP to specify a hierarchical composition of complex systems and for rule-based reasoning. Another important application area for CLP is finance. We mentioned the OTAS work above. Some further work is [119] which also deals with option valuations, and <ref> [23, 24, 37] </ref> which deal with financial planning. These financial applications have tended to take the form of expert systems involving sophisticated mathematical models.
Reference: 24. <author> F. Berthier, </author> <title> Solving Financial Decision Problems with CHIP, </title> <booktitle> Proceeedings of the 2nd Conference on Economics and Artificial Intelligence - CECIOA 2, Paris, </booktitle> <pages> 233-238, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In general, engineering applications such as these use CLP to specify a hierarchical composition of complex systems and for rule-based reasoning. Another important application area for CLP is finance. We mentioned the OTAS work above. Some further work is [119] which also deals with option valuations, and <ref> [23, 24, 37] </ref> which deal with financial planning. These financial applications have tended to take the form of expert systems involving sophisticated mathematical models.
Reference: 25. <author> R. Bisdorff & S. Laurent, </author> <title> Industrial Disposing Problem Solved in CHIP, </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <volume> 831, </volume> <year> 1993. </year>
Reference-contexts: Finally, we mention work on applying CLP languages to: music [251], car sequencing [109], aircraft traffic control [57], building visual language parsers [105], a warehousing problem <ref> [25] </ref>, safety analysis [68], frequency assignment for cellular telephones [47], timetabling [31], floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment [49], interest rate risk management in banking [97], failure mode and effect analysis of complex systems [97], development of digitally controlled analog systems [197], testing of
Reference: 26. <author> A. Bockmayr, </author> <title> Logic Programming with Pseudo-Boolean Constraints, in: Constraint Logic Programming: Selected Research, </title> <editor> F. Benhamou and A. Colmerauer (Eds.), </editor> <publisher> MIT Press, </publisher> <pages> 327-350, </pages> <year> 1993. </year>
Reference-contexts: The domain of x is f1; 2; 4; 5g. There are several other constraint domains of interest that we cannot exemplify here, for lack of space. They include pseudo-Boolean constraints (for example, <ref> [26] </ref>), which are intermediate between Boolean and integer constraints, order-sorted feature algebras [10], domains consisting of regular sets of strings [258], domains of finite sets [79], domains of CLP (Fun (D)) which employ a function variable [117], domains of functions expressed by -expressions [190, 8, 189, 200, 187], etc.
Reference: 27. <author> F. de Boer, J. Kok, C. Palamidessi & J. Rutten, </author> <title> Non-monotonic Concurrent Constraint Programming, </title> <booktitle> Proc. International Logic Programming Symposium, </booktitle> <pages> 315-334, </pages> <year> 1993. </year>
Reference-contexts: It is interesting to note that a notion of global failure (as represented in Section 5 by the state fail) destroys stability. Of course, there are also pragmatic reasons for wanting to avoid this notion in a concurrent language. A framework which permits non-monotonic CCLP languages is discussed in <ref> [27] </ref>. A program is determinate if every reachable state is determinate, where a state is determinate if every selected atom gives rise to at most one ! r transition. Consequently, for every initial state, every fair derivation rewrites the same atoms with the same rules, or every derivation fails.
Reference: 28. <author> F.S. de Boer & C. Palamidessi, </author> <title> A Fully Abstract Model for Concurrent Constraint Programming, </title> <booktitle> Proc. of TAPSOFT/CAAP, </booktitle> <volume> LNCS 493, </volume> <pages> 296-319, </pages> <year> 1991. </year>
Reference-contexts: This semantics is extended in [217] to a compositional and fully abstract semantics of arbitrary programs. A semantics based on traces is given in <ref> [28] </ref>. For determinate programs we also have a clean application of the classical logical semantics of a program [173].
Reference: 29. <author> F.S. de Boer & C. Palamidessi, </author> <title> Embedding as a Tool for Language Comparison, </title> <journal> Information and Computation, </journal> <note> to appear. </note>
Reference-contexts: Roughly speaking, a transition can occur with such a rule provided the accumulated constraints imply the ask constraint and do not contradict the tell constraint. Some languages use only the ask constraint for synchronization. It is shown in <ref> [29] </ref> that such languages are strictly less expressive than ask-tell languages. An operational semantics such as the above is not completely faithful to a real execution of the language, since it is possible for two atoms to be rewritten simultaneously in an execution environment with concurrency.
Reference: 30. <author> F.S. de Boer & C. Palamidessi, </author> <title> From Concurrent Logic Programming to Concurrent Constraint Programming, </title> <booktitle> in: Advances in Logic Programming Theory, </booktitle> <institution> Oxford University Press, </institution> <note> to appear. </note>
Reference-contexts: We further restrict our attention to languages with only committed-choice nondeterminism (sometimes called don't-care nondeterminism); more general languages will be discussed in Section 9. For more details of CCLP languages, see <ref> [218, 30] </ref>. Just as Prolog can be viewed as a kind of CLP language, obtained by a particular choice of constraint domain, so most concurrent logic languages can be viewed as concurrent CLP languages 15 .
Reference: 31. <author> P. Boizumault, Y. Delon & L. Peridy, </author> <title> Solving a real life exams problem using CHIP, </title> <booktitle> Proc. International Logic Programming Symposium, </booktitle> <volume> 661, </volume> <year> 1993. </year>
Reference-contexts: Finally, we mention work on applying CLP languages to: music [251], car sequencing [109], aircraft traffic control [57], building visual language parsers [105], a warehousing problem [25], safety analysis [68], frequency assignment for cellular telephones [47], timetabling <ref> [31] </ref>, floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment [49], interest rate risk management in banking [97], failure mode and effect analysis of complex systems [97], development of digitally controlled analog systems [197], testing of telecommunication protocols [154], causal graph management [209], factory scheduling [85], etc.
Reference: 32. <author> A. Borning, </author> <title> The Programming Language Aspects of ThingLab, a Constraint-Oriented Simulation Laboratory, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4), </volume> <pages> 252-387, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: The 3 constraints are static, and were solved by local propagation and relaxation techniques. (See chapter 2 in [165] for an introduction to these and related techniques.) Subsequent related work was THINGLAB <ref> [32] </ref> whose language took an object-oriented flavor. While local propagation and relaxation were also used to deal with the essentially static constraints, the system considered constraint solving in two different phases.
Reference: 33. <author> A. Borning, M.J. Maher, A. Martindale & M. Wilson, </author> <title> Constraint Hierarchies and Logic Programming, </title> <booktitle> Proc. 6th International Conference on Logic Programming, </booktitle> <pages> 149-164, </pages> <year> 1989. </year> <note> Fuller version as Technical Report 88-11-10, </note> <institution> Computer Science Department, University of Washington, </institution> <year> 1988. </year>
Reference-contexts: A second approach is to admit constraints which are not required to be satisfied by a solution, but express a preference for solutions which do satisfy them. Such constraints are sometimes called soft constraints. The most developed use of this approach is in hierarchical constraint logic programming (HCLP) <ref> [33, 263] </ref>. In HCLP, soft constraints have different strengths and the constraints accumulated during a derivation form a constraint hierarchy based on these strengths. There are many possible ways to compare solutions using these constraint hierarchies [33, 178, 263], different methods being suitable for different problems. <p> In HCLP, soft constraints have different strengths and the constraints accumulated during a derivation form a constraint hierarchy based on these strengths. There are many possible ways to compare solutions using these constraint hierarchies <ref> [33, 178, 263] </ref>, different methods being suitable for different problems. The hierarchy dictates that any number of weak constraints can be over-ruled by a stronger constraint.
Reference: 34. <author> A. Bossi, M. Gabbrielli, G. Levi & M.C. Meo, </author> <title> Contributions to the Semantics of Open Logic Programs, </title> <booktitle> Proc. Int. Conf. on Fifth Generation Computer Systems, </booktitle> <pages> 570-580, </pages> <year> 1992. </year>
Reference-contexts: Consequently [lf p (S D P )] D = P ). lf p (S D P ) corresponds to the s-semantics [87] for languages with constraints [95]. Fixedpoint semantics based on sets of clauses <ref> [34] </ref> also extend easily to CLP languages.
Reference: 35. <author> A. Brodsky & Y. Sagiv, </author> <title> Inference of Inequality Constraints in Logic Programs, </title> <booktitle> Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Other techniques [146, 193, 237, 147] attempt to further limit execution by placing constraints at appropriate points in the program. Analyses can be used to check that execution of the resulting program terminates <ref> [151, 211, 35] </ref>, although most work has ignored the capability of using constraints in the answers.
Reference: 36. <author> A. Brodsky, J. Jaffar & M. Maher, </author> <title> Toward Practical Constraint Databases, </title> <booktitle> Proc. 19th International Conference on Very Large Data Bases, </booktitle> <pages> 567-580, </pages> <year> 1993. </year>
Reference-contexts: Several different data structures, originally developed for spatial databases or computational geometry, have been proposed as appropriate for indexing <ref> [144, 236, 36] </ref>. A new data structure was presented in [145] which minimizes accesses to secondary storage. A sort-join algorithm for joins on constrained variables is given in [36]. <p> Several different data structures, originally developed for spatial databases or computational geometry, have been proposed as appropriate for indexing [144, 236, 36]. A new data structure was presented in [145] which minimizes accesses to secondary storage. A sort-join algorithm for joins on constrained variables is given in <ref> [36] </ref>. That paper also provides a query optimization methodology for conjunctive queries that can balance the cost of constraint manipulation against the cost of traditional database operations. 8.
Reference: 37. <author> J.M. Broek & H.A.M. Daniels, </author> <title> Application of CLP to Asset and Liability Management in Banks, </title> <booktitle> Computer Science in Economics and Management, </booktitle> <volume> 4(2), </volume> <pages> 107-116, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In general, engineering applications such as these use CLP to specify a hierarchical composition of complex systems and for rule-based reasoning. Another important application area for CLP is finance. We mentioned the OTAS work above. Some further work is [119] which also deals with option valuations, and <ref> [23, 24, 37] </ref> which deal with financial planning. These financial applications have tended to take the form of expert systems involving sophisticated mathematical models.
Reference: 38. <author> R. Bryant, </author> <title> Graph Based Algorithms for Boolean Function Manipulation, </title> <journal> IEEE Transactions on Computers 35, </journal> <pages> 677-691, </pages> <year> 1986. </year> <month> 74 </month>
Reference-contexts: The essential idea reduces a normal form representation into two smaller problems, each with one less variable. Binary decision diagrams <ref> [38] </ref> provide an efficient representation. One of the two Boolean solvers of CHIP, for example, uses variable elimination and these diagrams. A related technique is based on enumeration and propagation.
Reference: 39. <author> C. Brzoska, </author> <title> Temporal Logic Programming and its Relation to Constraint Logic Programming, </title> <booktitle> Proc. International Logic Programming Symposium, </booktitle> <pages> 661-677, </pages> <year> 1991. </year>
Reference-contexts: The language Templog [1] was designed based on a Horn-like subset of temporal logic in which the meaning of function symbols does not vary with time, but the meaning of predicate symbols does. It was shown in <ref> [39] </ref> that the operational behavior of Templog could be mimicked by a CLP language via the following natural translation: every predicate receives another argument, representing time.
Reference: 40. <author> C. Brzoska, </author> <title> Temporal Logic Programming with Bounded Universal Modality Goals, </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <pages> 239-256, </pages> <year> 1993. </year>
Reference-contexts: Then, at time t, next is represented by t 0 = t + 1, and the future (for always and sometime) is represented by t 0 t. In later work <ref> [40] </ref>, Brzoska has presented a more powerful temporal logic language which also can be viewed as, and implemented through, a CLP language. Often we wish to manipulate the time parameter more directly than is possible in conventional temporal logic.
Reference: 41. <author> J. Burg, C. Hughes, J. Moshell & S.D. Lang, </author> <title> Constraint-based Programming: A Survey, </title> <type> Technical Report IST-TR-90-16, </type> <institution> Dept. of Computer Science, University of Central Florida, </institution> <year> 1990. </year>
Reference-contexts: This work had a significant influence on the later development of the CLP language CHIP. We refer the reader to [253] for an introduction to the basic techniques and results concerning CSPs. Finally, we mention the survey <ref> [41] </ref> which deals not just with constraint programming languages, but constraint-based programming techniques. 1.2. Logic Programming Next we consider conventional logic programming (LP), and argue by example that the power of CLP cannot be obtained by making simple changes to LP systems.
Reference: 42. <author> J. </author> <title> Burg, Parallel Execution Models and Algorithms for Constraint Logic Programming over a Real-number Domain, </title> <type> Ph.D. thesis, </type> <institution> Dept. of Computer Science, University of Central Florida, </institution> <year> 1992. </year>
Reference-contexts: He presents distributed solvers for finite domains, the Boolean domain and linear inequalities over the reals. The finite domain solver is based on [108], the solver for the reals parallelizes the Simplex algorithm, and the Boolean solver parallelizes the unification algorithm of [45]. Finally, <ref> [43, 42] </ref> reports the design and initial implementation of CLP (R) with an execution model in which the inference engine and constraint solver compute concurrently and asynchronously.
Reference: 43. <author> J. Burg, C. Hughes & S.D. Lang, </author> <title> Parallel Execution of CLP-&lt; Programs, </title> <type> Technical Report TR-CS-92-20, </type> <institution> University of Central Florida, </institution> <year> 1992. </year>
Reference-contexts: He presents distributed solvers for finite domains, the Boolean domain and linear inequalities over the reals. The finite domain solver is based on [108], the solver for the reals parallelizes the Simplex algorithm, and the Boolean solver parallelizes the unification algorithm of [45]. Finally, <ref> [43, 42] </ref> reports the design and initial implementation of CLP (R) with an execution model in which the inference engine and constraint solver compute concurrently and asynchronously.
Reference: 44. <author> H-J. Burckert, </author> <title> A Resolution Principle for Clauses with Constraints, </title> <journal> Proc. CADE-10, </journal> <volume> LNCS 449, </volume> <pages> 178-192, </pages> <year> 1990. </year>
Reference-contexts: This domain provides a limited notion of object (in the object-oriented sense). The languages support a term syntax which is not first-order, although every term can be interpreted through first-order constraints. Unlike other CLP languages/domains, 1 We note, however, some work combining constraints and resolution in first-order automated theorem-proving <ref> [242, 44] </ref>. 2 The language Absys [82], which was very similar to Prolog, used equations explicitly, making it more obviously a CLP language. 6 Prolog-like trees are essentially part of this domain, instead of being built on top of the domain.
Reference: 45. <author> W. Buttner & H. Simonis, </author> <title> Embedding Boolean Expressions into Logic Programming, </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4, </volume> <pages> 191-205, </pages> <year> 1987. </year>
Reference-contexts: Despite this, and the fact that Boole's work dates far back, this method is still used, for example in CHIP <ref> [45] </ref>. Another unification algorithm is due to Lowenhein, and we adapt the presentation of [185] here. Let f (x 1 ; ; x n ) = 0 be the equation considered. Let ~a denote a solution. <p> He presents distributed solvers for finite domains, the Boolean domain and linear inequalities over the reals. The finite domain solver is based on [108], the solver for the reals parallelizes the Simplex algorithm, and the Boolean solver parallelizes the unification algorithm of <ref> [45] </ref>. Finally, [43, 42] reports the design and initial implementation of CLP (R) with an execution model in which the inference engine and constraint solver compute concurrently and asynchronously.
Reference: 46. <author> M. Carlsson, </author> <title> Freeze, Indexing and other Implementation Issues in the WAM, </title> <booktitle> Proc. 4th International Conference on Logic Programming, </booktitle> <pages> 40-58, </pages> <year> 1987. </year>
Reference-contexts: Add to a standard implementation of a unification algorithm an index structure mapping variables x to just those guard constraints in G which involve x. (See <ref> [46] </ref> for a detailed description.) Now add to the process of constructing a solved form a check for groundness when variables are bound (and this is easily detectable).
Reference: 47. <author> M. Carlsson & M. Grindal, </author> <title> Automatic Frequency Assignment for Cellular Telephones Using Constraint Satisfaction Techniques, </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <pages> 647-665, </pages> <year> 1993. </year>
Reference-contexts: Finally, we mention work on applying CLP languages to: music [251], car sequencing [109], aircraft traffic control [57], building visual language parsers [105], a warehousing problem [25], safety analysis [68], frequency assignment for cellular telephones <ref> [47] </ref>, timetabling [31], floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment [49], interest rate risk management in banking [97], failure mode and effect analysis of complex systems [97], development of digitally controlled analog systems [197], testing of telecommunication protocols [154], causal graph management [209], factory scheduling
Reference: 48. <author> S.N. Cernikov, </author> <title> Contraction of Finite Systems of Linear Inequalities (In Russ-ian), </title> <journal> Doklady Akademiia Nauk SSSR, </journal> <volume> Vol. 152, No. 5, </volume> <pages> 1075-1078, </pages> <year> 1963. </year> <journal> (English translation in Soviet Mathematics Doklady, </journal> <volume> Vol. 4, No. 5, </volume> <pages> 1520-1524, </pages> <year> 1963.) </year>
Reference-contexts: In practice, however, the Fourier step generates many redundant constraints 30 . See [159] for discussion on such redundancy. Work by Cernikov <ref> [48] </ref> proposed tests on the generated constraints to detect and eliminate some redundant constraints.
Reference: 49. <author> R. Chadra, O. Cockings & S. Narain, </author> <title> Interoperability Analysis by Symbolic Simulation, </title> <booktitle> Proc. JICSLP Workshop on Constraint Logic Programming, </booktitle> <pages> 55-58, </pages> <year> 1992. </year>
Reference-contexts: we mention work on applying CLP languages to: music [251], car sequencing [109], aircraft traffic control [57], building visual language parsers [105], a warehousing problem [25], safety analysis [68], frequency assignment for cellular telephones [47], timetabling [31], floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment <ref> [49] </ref>, interest rate risk management in banking [97], failure mode and effect analysis of complex systems [97], development of digitally controlled analog systems [197], testing of telecommunication protocols [154], causal graph management [209], factory scheduling [85], etc.
Reference: 50. <author> A. Chamard, F. Deces & A. Fischler, </author> <title> Applying CHIP to a Complex Scheduling Problem, </title> <type> draft manuscript, </type> <institution> Dassualt Aviation, Department of Artificial Intelligence, </institution> <year> 1992. </year>
Reference-contexts: Section 5.4.2 of [107] and section 2 of [78], on which this presentation is based, further discuss the problem and how particular features of CHIP can be useful. Another CHIP approach, but this time to a specific and practical scheduling problem is reported in <ref> [50] </ref>. In [2], the focus is on a new feature of CHIP and how it can be used to obtain an optimal solution to a particular 10 jobs and 10 machine problem, which remained open until recently.
Reference: 51. <author> D. Chan, </author> <title> Constructive Negation based on Completed Database, </title> <booktitle> Proc. 5th International Conference on Logic Programming, </booktitle> <pages> 111-125, </pages> <year> 1988. </year>
Reference-contexts: With these modifications, various soundness and completeness results for SLDNF-resolution and comp (P ) extend easily to ideal CLP systems. An alternative implementation of negation, constructive negation <ref> [51] </ref>, has been expanded and applied to CLP programs by Stuckey [244], who gave the first completeness result for this method. 18 This approach has been called a "glass-box" approach. 19 For example, the extension to allow arbitrary first-order formulas in the bodies of rules [169]. 30 9.5.
Reference: 52. <author> V. Chandru, </author> <title> Variable Elimination in Linear Constraints, </title> <journal> The Computer Journal, </journal> <volume> 36(5), </volume> <pages> 463-472, </pages> <year> 1993. </year>
Reference-contexts: The survey <ref> [52] </ref> contains further perspectives on the Fourier variable elimination techique. It also contains a discussion on how the essential technique of Fourier can be adapted to perform projection in other domains such as linear integer constraints and the boolean domain.
Reference: 53. <author> V. Chandru & J.N. Hooker, </author> <title> Extended Horn Sets in Propositional Logic, </title> <journal> Journal of the ACM, </journal> <volume> 38, </volume> <pages> 205-221, </pages> <year> 1991. </year>
Reference-contexts: Another technique comes from Operations Research. Here the boolean formula is restated in arithmetic form, with variables constrained to be 0 and 1. Then standard techniques for integer programming, for example cutting-planes, can be used. See <ref> [53] </ref> for a further discussion of this technique. This technique has not been used in CLP systems. A more recent development is the adaptation of Buchberger's Groebner basis algorithm to Boolean algebras [210], which is used in CAL.
Reference: 54. <author> V. Chv^atal, </author> <title> Linear Programming, W.H. </title> <publisher> Freeman and Co., </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: For the more general domain &lt; Lin , polynomial time algorithms are also known [141], but these algorithms are not used in practical CLP systems. Instead, the Simplex algorithm (see eg. <ref> [54] </ref>), despite its exponential time worst case complexity [148], is used as a basis for the algorithm. However, since the Simplex algorithm works over non-negative numbers and non-strict inequalities, it must be extended for use in CLP systems.
Reference: 55. <author> K.L. Clark, </author> <title> Negation as Failure, in Logic and Databases, </title> <editor> H. Gallaire and J. Minker (Eds.), </editor> <publisher> Plenum Press, </publisher> <address> New York, 293-322, </address> <year> 1978. </year>
Reference-contexts: Thus, for example, the theory of the real closed fields [247] corresponds and is satisfaction complete with respect to &lt; since the domain is a model of this theory and the theory is complete. Clark's axiomatization of unification <ref> [55] </ref> defines a satisfaction complete theory with respect to FT which is not complete when there are only finitely many function symbols [174]. The notion of independence of negative constraints plays a significant role in constraint logic programming 10 . <p> Other declarative semantics, based on Clark's completion P fl of the program, also extend to CLP 19 . The counterpart of comp (P ) <ref> [55, 168] </ref> is T ; P fl , where T is satisfaction complete.
Reference: 56. <author> P. Codognet & D. Diaz, </author> <title> Boolean Constraint Solving using clp(FD), </title> <booktitle> Proc. International Logic Programming Symposium, </booktitle> <pages> 525-539, </pages> <year> 1993. </year>
Reference-contexts: A discussion of an implementation of indexical constraints is given in [75]. (One application of this work is a constraint solver for Boolean constraints <ref> [56] </ref>; we describe this application in Section 13.5.) 9.4. Negation Treatments of negation in logic programming lift readily to constraint logic programming, with only minor adjustments necessary. Indeed many of the semantics for programs with negation are essentially propositional, being based upon the collection of ground instances of program rules. <p> One of the two Boolean solvers of CHIP, for example, uses variable elimination and these diagrams. A related technique is based on enumeration and propagation. The constraints are expressed as a conjunction of simple constraints and then local propagation simplifies the conjunction after each enumeration step. See <ref> [56] </ref>, for example. The method used in Prolog III [21] is a modification of SL-resolution whose main element is the elimination of redundant expressions. Another technique comes from Operations Research. Here the boolean formula is restated in arithmetic form, with variables constrained to be 0 and 1. <p> Propositional Solver As mentioned above in the discussion about the boolean constraint domain, one approach to solving boolean equations is to use clp (FD), representing the input formulas in a straightforward way using variables constrained to be 0 or 1. See section 3.3.2 of [225] and <ref> [56] </ref> for example. What follows is from [56]. <p> See section 3.3.2 of [225] and <ref> [56] </ref> for example. What follows is from [56].
Reference: 57. <author> P. Codognet, F. Fages, J. Jourdan, R. Lissajoux & T. Sola, </author> <title> On the Design of Meta(F) and its Applications in Air Traffic Control, </title> <booktitle> Proc. JICSLP Workshop on Constraint Logic Programming, </booktitle> <pages> 28-35, </pages> <year> 1992. </year>
Reference-contexts: The Applause Project [167] has developed applications that use the ElipSys system a parallel implementation of a CLP language for manufacturing planning, tourist advice, molecular biology, and environment monitoring and control. Finally, we mention work on applying CLP languages to: music [251], car sequencing [109], aircraft traffic control <ref> [57] </ref>, building visual language parsers [105], a warehousing problem [25], safety analysis [68], frequency assignment for cellular telephones [47], timetabling [31], floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment [49], interest rate risk management in banking [97], failure mode and effect analysis of complex systems [97],
Reference: 58. <author> J. Cohen, </author> <title> Constraint Logic Programming Languages, </title> <journal> CACM, </journal> <volume> 33, </volume> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Appropriate background can be obtained from [168] for LP and [223] for logic. For introductory papers on constraint logic programming and CLP languages we refer the reader to [63, 65, 156, 94]. For further reading on CLP we suggest other surveys <ref> [58, 109, 110] </ref>, some collections of papers [20, 143, 111], and some books [107, 214]. More generally, papers on CLP appear in various journals and conference proceedings devoted to computational logic, constraint processing or symbolic computation. 7 1.5. Notation and Terminology This paper will (hopefully) keep to the following conventions.
Reference: 59. <author> A. Colmerauer, Prolog-II Manuel de Reference et Modele Theorique, Groupe Intelligence Artificelle, U. d'Aix-Marseille II, </author> <year> 1982. </year>
Reference-contexts: The equations are implicit in the use of unification 2 . Almost every language we discuss incorporates Prolog-like terms in addition to other terms and constraints, so we will not discuss this aspect further. Prolog II <ref> [59] </ref> employs equations and disequations (6=) over rational trees (an extension of the finite trees of Prolog to cyclic structures). It was the first logic language explicitly described as using constraints [61]. CLP (R) [133] has linear arithmetic constraints and computes over the real numbers. <p> This approach was pioneered in Prolog II <ref> [59] </ref> and MU-Prolog [195]. The automatic annotation of programs [194] brings this approach closer to the first. A third approach is to introduce constructs from concurrent logic programming into the language. There are basically two varieties of this approach: guarded rules and guarded atoms.
Reference: 60. <author> A. Colmerauer, </author> <title> Prolog and Infinite Trees, in Logic Programming, K.L. </title> <editor> Clark and S-A. Tarnlund (Eds), </editor> <publisher> Academic Press, </publisher> <address> New York, 231-251, </address> <year> 1982. </year>
Reference-contexts: Typical constraints are x = g (y) and 9z x = f (z; z) ^ y = g (z). (It is unnecessary to write a quantifier in Prolog programs because all variables that appear only in constraints are implicitly existentially quantified.) It was pointed out in <ref> [60] </ref> that complete (i.e. always terminating) unification which omits the occurs check solves equations over the rational trees. Example 2.3. We take and L as in example 2. <p> In general, however, the beliefs above hold in practice, and the algorithm behaves incrementally. We next consider the domain RT whose universally used solved form (due to <ref> [60] </ref>) is like that of FT with one important change: constraints are represented in the form x 1 = t 1 ; ; x n = t n where each t i is an arbitrary term structure. <p> A straightforward satisfiability algorithm <ref> [60] </ref> is roughly as follows. Let x stand for a variable, and s and t stand for non-variable terms. <p> Termination needs to be argued, but we will leave the details to <ref> [60] </ref>. We now discuss algorithms which do not fit exactly with Algorithm 1, but which employ a solved form. Consider first the Simplex algorithm for the domain &lt; Lin . The basic step of one pivoting operation within this algorithm is essentially the same as Algorithm 1. <p> For example, the equation x = f (f (x; x); f (x; x)) is best presented as x = f (x; x). In general, the problem of finding the most compact representation is roughly equivalent to the problem of minimizing states in a finite state automaton <ref> [60] </ref>. For &lt; LinEqn the problem is only slightly more complicated. Recall that equations are maintained in parametric form, with eliminable and parametric variables. A relatively simple algorithm can be obtained by using a form of Gaussian elimination, and is informally described in Figure 1.
Reference: 61. <author> A. Colmerauer, </author> <title> Prolog in 10 Figures, </title> <booktitle> Proc. 8th International Joint Conference 75 on Artificial Intelligence, </booktitle> <pages> 487-499, </pages> <year> 1983. </year>
Reference-contexts: Prolog II [59] employs equations and disequations (6=) over rational trees (an extension of the finite trees of Prolog to cyclic structures). It was the first logic language explicitly described as using constraints <ref> [61] </ref>. CLP (R) [133] has linear arithmetic constraints and computes over the real numbers. Nonlinear constraints are ignored (delayed) until they become effectively linear. CHIP [76] and Prolog III [64] compute over several domains.
Reference: 62. <author> A. Colmerauer, </author> <title> Equations and Inequations on Finite and Infinite Trees, </title> <booktitle> Proc. 2nd. Int. Conf. on Fifth Generation Computer Systems, Tokyo, </booktitle> <pages> 85-99, </pages> <year> 1984. </year>
Reference-contexts: Clark's axiomatization of unification [55] defines a satisfaction complete theory with respect to FT which is not complete when there are only finitely many function symbols [174]. The notion of independence of negative constraints plays a significant role in constraint logic programming 10 . In <ref> [62] </ref>, Colmerauer used independence of inequations to simplify the test for satisfiability of equations and inequations on the rational 10 It is also closely related to the model-theoretic properties that led to an interest in Horn formulas [172, 121]. 14 trees. (The independence of inequations states: if a conjunction of positive
Reference: 63. <author> A. Colmerauer, </author> <title> Opening the Prolog III Universe, </title> <journal> BYTE Magazine, </journal> <month> August </month> <year> 1987. </year>
Reference-contexts: We assume the reader is somewhat familiar with LP and basic first-order logic. Appropriate background can be obtained from [168] for LP and [223] for logic. For introductory papers on constraint logic programming and CLP languages we refer the reader to <ref> [63, 65, 156, 94] </ref>. For further reading on CLP we suggest other surveys [58, 109, 110], some collections of papers [20, 143, 111], and some books [107, 214].
Reference: 64. <author> A. Colmerauer, </author> <title> Prolog III Reference and Users Manual, </title> <note> Version 1.1, PrologIA, Marseilles, </note> <year> 1990. </year>
Reference-contexts: It was the first logic language explicitly described as using constraints [61]. CLP (R) [133] has linear arithmetic constraints and computes over the real numbers. Nonlinear constraints are ignored (delayed) until they become effectively linear. CHIP [76] and Prolog III <ref> [64] </ref> compute over several domains. Both compute over Boolean domains: Prolog III over the well-known 2-valued Boolean algebra and CHIP over a larger Boolean algebra that contains symbolic values. Both CHIP and Prolog III perform linear arithmetic over the rational numbers. <p> We now present some example constraint domains. In practice, these are not always fully implemented, but we leave discussion of that until later. Most general purpose CLP languages incorporate some arithmetic domain, including BNR-Prolog [198], CAL [4], CHIP [76], CLP (R) [133], Prolog III <ref> [64] </ref>, RISC-CLP (Real) [120]. Example 2.1. Let contain the constants 0 and 1, the binary function symbols + and fl, and the binary predicate symbols =, &lt; and . <p> The next constraint domain takes strings as the basic objects. It is used in Prolog III <ref> [64] </ref>. Example 2.5. Let contain the binary predicate symbol =, the binary function symbol ., a constant , and a number of other constants. D is the set of finite strings of the constants. <p> Then WE = (D; L) is the constraint domain of equations on strings, sometimes called the domain of word equations. An example constraint is x:a = b:x. The constraint domain of Boolean values and functions is used in BNR-Prolog [198], CAL [4], CHIP [76] and Prolog III <ref> [64] </ref>. CAL and CHIP employ a more general constraint domain, which includes symbolic Boolean values. Example 2.6. Let contain the constants 0 and 1, the unary function symbol :, the binary function symbols ^; _; ; ), and the binary predicate symbol =.
Reference: 65. <author> A. Colmerauer, </author> <title> An Introduction to Prolog III, </title> <journal> CACM, </journal> <volume> 33, </volume> <pages> 69-90, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: We assume the reader is somewhat familiar with LP and basic first-order logic. Appropriate background can be obtained from [168] for LP and [223] for logic. For introductory papers on constraint logic programming and CLP languages we refer the reader to <ref> [63, 65, 156, 94] </ref>. For further reading on CLP we suggest other surveys [58, 109, 110], some collections of papers [20, 143, 111], and some books [107, 214].
Reference: 66. <author> A. Colmerauer, </author> <title> Naive Solving of Non-linear Constraints, in: Constraint Logic Programming: Selected Research, </title> <editor> F. Benhamou and A. Colmerauer (Eds.), </editor> <publisher> MIT Press, </publisher> <pages> 89-112, </pages> <year> 1993. </year>
Reference-contexts: In Section 10 we will discuss problems and techniques which arise when implementing these operations in a CLP system. However, we point out here that some implementations of these operators in particular, the test for satisfiability are incomplete. In some cases it has been argued <ref> [67, 66, 22] </ref> that although an algorithm is incomplete with respect to the desired constraint domain, it is complete with respect to another (artificially constructed) constraint domain. We now turn to some properties of constraint domains which will be used later.
Reference: 67. <author> A. Colmerauer, </author> <booktitle> invited talk at Workshop on the Principles & Practice of Constraint Programming, </booktitle> <address> Newport, RI, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: In Section 10 we will discuss problems and techniques which arise when implementing these operations in a CLP system. However, we point out here that some implementations of these operators in particular, the test for satisfiability are incomplete. In some cases it has been argued <ref> [67, 66, 22] </ref> that although an algorithm is incomplete with respect to the desired constraint domain, it is complete with respect to another (artificially constructed) constraint domain. We now turn to some properties of constraint domains which will be used later.
Reference: 68. <author> M-M. </author> <title> Corsini & A Rauzy, Safety Analysis by means of Fault Trees: an Application for Open Boolean Solvers, </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <volume> 834, </volume> <year> 1993. </year>
Reference-contexts: Finally, we mention work on applying CLP languages to: music [251], car sequencing [109], aircraft traffic control [57], building visual language parsers [105], a warehousing problem [25], safety analysis <ref> [68] </ref>, frequency assignment for cellular telephones [47], timetabling [31], floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment [49], interest rate risk management in banking [97], failure mode and effect analysis of complex systems [97], development of digitally controlled analog systems [197], testing of telecommunication protocols [154],
Reference: 69. <author> B. Courcelle, </author> <title> Fundamental Properties of Infinite Trees, </title> <journal> Theoretical Computer Science, </journal> <volume> 25(2), </volume> <pages> 95-169, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: Example 2.3. We take and L as in example 2. D is the set of rational trees (see <ref> [69] </ref> for a definition) and the function symbols are interpreted as tree constructors, as before. Then RT = (D; L) is the constraint domain of rational trees.
Reference: 70. <author> J. Darlington and Y-K. Guo, </author> <title> A New Perspective on Integrating Functions and Logic Languages, </title> <booktitle> Proceedings of the 3rd International Conference on Fifth Generation Computer Systems, Tokyo, </booktitle> <pages> 682-693, </pages> <year> 1992. </year>
Reference-contexts: Such assignments are treatable as constraints of the form x i = x i+1 + 1. Finally, we mention Constraint Functional Programming <ref> [70] </ref> whose goal is the amalgamation of the ideas of functional programming found in the HOPE language with constraints. There is work on languages and systems which are not generally regarded as constraint languages, but are nevertheless related to CLP languages.
Reference: 71. <author> B. De Backer & H. Beringer, </author> <title> Intelligent Backtracking for CLP Languages, An Application to CLP(R), </title> <booktitle> Proc. International Logic Programming Symposium, </booktitle> <pages> 405-419, </pages> <year> 1991. </year>
Reference-contexts: The problem of finding answers to a query can be seen as the problem of searching a computation tree. Most CLP languages employ a depth-first search with chronological backtracking, as in Prolog (although there have been suggestions to use dependency-directed backtracking <ref> [71] </ref>). Since depth-first search is incomplete on infinite trees, not all answers are computed. The depth-first search can be incorporated in the semantics in the same way as is done for Prolog (see, for example, [18, 17]), but we will not go into details here.
Reference: 72. <author> B. De Backer & H. Beringer, </author> <title> A CLP Language Handling Disjunctions of Linear Constraints, </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <pages> 550-563, </pages> <year> 1993. </year>
Reference-contexts: We can classify them as follows: those which implement Boolean combinations of (generally simple) constraints and those which describe an ad hoc, often application-specific, relation. Falling into the first category are some implementations of constraint disjunction <ref> [116, 72] </ref> (sometimes called "constructive disjunction") and the cardinality operator [112]. Into the second category fall the element constraint [77], and the cumulative constraint of [2], among others. These constraints are already accounted for in the operational semantics of Section 5, since they can be considered passive constraints in L. <p> The disjunctions of these approximations is easily expressed as an active constraint. For linear arithmetic <ref> [72] </ref> suggests the use of the convex hull of the regions defined by the two constraints as the approximation. Note that the constructive disjunction behavior could be obtained from the clauses for p using the methods of [202].
Reference: 73. <author> S. K. Debray, </author> <title> Static Inference of Modes and Data Dependencies in Logic Programs, </title> <booktitle> ACM Transactions on Programming Languages and Systems 11 (3), </booktitle> <pages> 418-450, </pages> <year> 1989. </year>
Reference-contexts: We now address this issue. 11.2.2. Techniques for CLP Program Analysis The kinds of program analysis required to utilize the specialized instructions include those techniques developed for Prolog, most prominently, detecting special cases of unification and deterministic predicates. Algorithms for such analysis have become familiar; see <ref> [73, 74] </ref> for example. See [98], for example, for a description of how to extend the general techniques of abstract interpretation applicable in LP to CLP. Our considerations above, however, require rather specific kinds of analyses.
Reference: 74. <author> S. K. Debray & D.S. Warren, </author> <title> Functional Computations in Logic Programs, </title> <booktitle> ACM Transactions on Programming Languages and Systems 11 (3), </booktitle> <pages> 451-481, </pages> <year> 1989. </year>
Reference-contexts: We now address this issue. 11.2.2. Techniques for CLP Program Analysis The kinds of program analysis required to utilize the specialized instructions include those techniques developed for Prolog, most prominently, detecting special cases of unification and deterministic predicates. Algorithms for such analysis have become familiar; see <ref> [73, 74] </ref> for example. See [98], for example, for a description of how to extend the general techniques of abstract interpretation applicable in LP to CLP. Our considerations above, however, require rather specific kinds of analyses.
Reference: 75. <author> D. Diaz & P. Codognet, </author> <title> A Minimal Extension of the WAM for clp(FD), </title> <booktitle> Proc. 10th International Conference on Logic Programming, </booktitle> <pages> 774-790, </pages> <year> 1993. </year>
Reference-contexts: A discussion of an implementation of indexical constraints is given in <ref> [75] </ref>. (One application of this work is a constraint solver for Boolean constraints [56]; we describe this application in Section 13.5.) 9.4. Negation Treatments of negation in logic programming lift readily to constraint logic programming, with only minor adjustments necessary. <p> In general, the essential features of the parts of an abstract machine dealing with constraints will differ greatly over CLP languages using different constraint domains. This is exemplified in the literature on CLP (R) [135], CHIP [3], and CLP (FD) <ref> [75] </ref>. The following presentation, though based on one work [135], contains material that is relevant to abstract machines for many CLP languages. We begin by arguing that an abstract machine is the right approach in the first place. Abstract machines have been used for implementing programming languages for many reasons.
Reference: 76. <author> M. Dincbas, P. Van Hentenryck, H. Simonis, & A. Aggoun, </author> <title> The Constraint Logic Programming Language CHIP, </title> <booktitle> Proceedings of the 2nd. International Conference on Fifth Generation Computer Systems, </booktitle> <pages> 249-264, </pages> <year> 1988. </year>
Reference-contexts: It was the first logic language explicitly described as using constraints [61]. CLP (R) [133] has linear arithmetic constraints and computes over the real numbers. Nonlinear constraints are ignored (delayed) until they become effectively linear. CHIP <ref> [76] </ref> and Prolog III [64] compute over several domains. Both compute over Boolean domains: Prolog III over the well-known 2-valued Boolean algebra and CHIP over a larger Boolean algebra that contains symbolic values. Both CHIP and Prolog III perform linear arithmetic over the rational numbers. <p> We now present some example constraint domains. In practice, these are not always fully implemented, but we leave discussion of that until later. Most general purpose CLP languages incorporate some arithmetic domain, including BNR-Prolog [198], CAL [4], CHIP <ref> [76] </ref>, CLP (R) [133], Prolog III [64], RISC-CLP (Real) [120]. Example 2.1. Let contain the constants 0 and 1, the binary function symbols + and fl, and the binary predicate symbols =, &lt; and . <p> Then WE = (D; L) is the constraint domain of equations on strings, sometimes called the domain of word equations. An example constraint is x:a = b:x. The constraint domain of Boolean values and functions is used in BNR-Prolog [198], CAL [4], CHIP <ref> [76] </ref> and Prolog III [64]. CAL and CHIP employ a more general constraint domain, which includes symbolic Boolean values. Example 2.6. Let contain the constants 0 and 1, the unary function symbol :, the binary function symbols ^; _; ; ), and the binary predicate symbol =.
Reference: 77. <author> M. Dincbas, H. Simonis & P. van Hentenryck, </author> <title> Solving a Cutting-stock Problem in CLP, </title> <booktitle> Proceedings 5 th International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: This possibility has only been pursued in a limited form, where a general-purpose domain is extended by the ad hoc addition of primitive constraints. For example, in some uses of CHIP the finite domain is extended with a predicate symbol element <ref> [77] </ref>. The relation element (x; l; t) expresses that t is the x'th element in the list l. <p> Execution of language constructs such as the cardinality operator [112], "constructive disjunction" [116] and special-purpose constructs (for example, in <ref> [77, 2] </ref>) can also be understood as ! i transitions, where these constructs are viewed as part of the language of constraints. Generally, the active constraints are determined syntactically. <p> Falling into the first category are some implementations of constraint disjunction [116, 72] (sometimes called "constructive disjunction") and the cardinality operator [112]. Into the second category fall the element constraint <ref> [77] </ref>, and the cumulative constraint of [2], among others. These constraints are already accounted for in the operational semantics of Section 5, since they can be considered passive constraints in L. <p> In each subsection below, unless otherwise specified, we shall assume that the underlying constraint system is based on the integers. 13.1. Cutting Stock The following describes a two-dimensional cutting stock problem pertaining to furniture manufacturing, an early application of CHIP <ref> [77] </ref>. We are given a sawing machine which cuts a board of wood into a number of different sized shelves. The machine is able to cut in several configurations, each of which determines the number of each kind of shelf, and some amount of wood wasted. <p> Let R i , 1 i N denote the number of shelves i required. The problem now can be stated as finding the configurations such that the required number of shelves are obtained and the wastage minimized. In <ref> [77] </ref>, there were 6 kinds of shelves, 72 configurations, and the number of boards to be cut was fixed at 4. Two solutions were then presented, which we now paraphrase. Let X i , 1 i 72, denote the number of boards cut according to configuration i. <p> The second program has advantages over the first. Apart from a smaller search space (approximately 10 7 in comparison with 10 43 ), it was able to avoid encountering symmetrical solutions. The timings given in <ref> [77] </ref> showed that the second program ran much faster. This comparison exemplifies the abovementioned fact that the way a problem is modelled can greatly affect efficiency. 13.2. DNA Sequencing We consider a simplified version of the problem of restriction site mapping (RSM).
Reference: 78. <author> M. Dincbas, H. Simonis & P. Van Hentenryck, </author> <title> Solving Large Combinatorial Problems in Logic Programming, </title> <journal> Journal of Logic Programming 8 (1&2), </journal> <pages> 75-93, </pages> <year> 1990. </year>
Reference-contexts: Thus the program would be independent of the number of jobs or the pattern in which tasks are assigned to machines. Similar comments apply to other programs in this section. There are variations and specializations of CLP approaches to this problem. Section 5.4.2 of [107] and section 2 of <ref> [78] </ref>, on which this presentation is based, further discuss the problem and how particular features of CHIP can be useful. Another CHIP approach, but this time to a specific and practical scheduling problem is reported in [50].
Reference: 79. <author> A. Dovier & G. Rossi, </author> <title> Embedding Extensional Finite Sets in CLP, </title> <booktitle> Proc. International Logic Programming Symposium, </booktitle> <pages> 540-556, </pages> <year> 1993. </year>
Reference-contexts: There are several other constraint domains of interest that we cannot exemplify here, for lack of space. They include pseudo-Boolean constraints (for example, [26]), which are intermediate between Boolean and integer constraints, order-sorted feature algebras [10], domains consisting of regular sets of strings [258], domains of finite sets <ref> [79] </ref>, domains of CLP (Fun (D)) which employ a function variable [117], domains of functions expressed by -expressions [190, 8, 189, 200, 187], etc. It is also possible to form a constraint domain directly from objects and operations in an application, instead of more general-purpose domains such as those above.
Reference: 80. <author> R. </author> <title> Duisburg, Constraint-based Animation: Temporal Constraints in the Animus System, </title> <type> Technical Report CR-86-37, </type> <institution> Tektronix Laboratories, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: When a graphical object is manipulated, a plan was generated for quickly re-solving the appropriate constraints for changed part of the object. This plan was then repeatedly executed while the manipulation continued. Works following the THINGLAB tradition included the Filters Project [81] and Animus <ref> [80] </ref>. Another graphical system, this one focusing on geometrical layout, was JUNO [196]. The constraints were constructed, as in THINGLAB, by text or graphical primitives, and the geometric object could be manipulated. A difference from the abovementioned works is that constraint solving was performed numerically using a Newton-Raphson solver.
Reference: 81. <author> R. Ege, D. Maier & A. Borning, </author> <title> The Filter Browser: Defining Interfaces Graphically, </title> <booktitle> Proc. of the European Conf. on Object-Oriented Programming, Paris, </booktitle> <pages> 155-165, </pages> <year> 1987. </year>
Reference-contexts: When a graphical object is manipulated, a plan was generated for quickly re-solving the appropriate constraints for changed part of the object. This plan was then repeatedly executed while the manipulation continued. Works following the THINGLAB tradition included the Filters Project <ref> [81] </ref> and Animus [80]. Another graphical system, this one focusing on geometrical layout, was JUNO [196]. The constraints were constructed, as in THINGLAB, by text or graphical primitives, and the geometric object could be manipulated.
Reference: 82. <author> E. Elcock, Absys: </author> <title> The First Logic Programming Language A Retrospective and Commentary, </title> <journal> Journal of Logic Programming, </journal> <volume> 9, </volume> <pages> 1-17, </pages> <year> 1990. </year>
Reference-contexts: The languages support a term syntax which is not first-order, although every term can be interpreted through first-order constraints. Unlike other CLP languages/domains, 1 We note, however, some work combining constraints and resolution in first-order automated theorem-proving [242, 44]. 2 The language Absys <ref> [82] </ref>, which was very similar to Prolog, used equations explicitly, making it more obviously a CLP language. 6 Prolog-like trees are essentially part of this domain, instead of being built on top of the domain. CIL [192] computes over a domain similar to feature trees.
Reference: 83. <author> M. van Emden, </author> <title> Quantitative Deduction and its Fixpoint Theory, </title> <journal> Journal of Logic Programming, </journal> <pages> 37-53, </pages> <year> 1986. </year> <month> 76 </month>
Reference-contexts: These financial applications have tended to take the form of expert systems involving sophisticated mathematical models. There have been various proposals for including certainty measures and probabilities in logic programs to provide some built-in evidential reasoning that can be useful when writing expert systems. Original proposals <ref> [222, 83] </ref> intended Prolog as the underlying language, but it is clear that CLP languages provide for more flexible execution of such expert systems.
Reference: 84. <author> E. Emerson, </author> <title> Temporal and Modal Logic, </title> <booktitle> in: Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, Chapter 16, </volume> <pages> 995-1072, </pages> <year> 1990. </year>
Reference-contexts: In this brief discussion we assume that time is linearly ordered, although this is not a universally accepted choice <ref> [84] </ref>. Temporal logic [84] is often used as a language for expressing time-related concepts. Temporal logic adds to standard first-order logic such constructs as next (meaning, roughly, "in the next time instant" 40 ), always (meaning "in every future time instant"), and sometime (meaning "in some future time instant"). <p> In this brief discussion we assume that time is linearly ordered, although this is not a universally accepted choice <ref> [84] </ref>. Temporal logic [84] is often used as a language for expressing time-related concepts. Temporal logic adds to standard first-order logic such constructs as next (meaning, roughly, "in the next time instant" 40 ), always (meaning "in every future time instant"), and sometime (meaning "in some future time instant").
Reference: 85. <author> O. Evans, </author> <title> Factory Scheduling using Finite Domains, in: Logic Programming in Action, </title> <publisher> LNCS 636, Springer-Verlag, </publisher> <pages> 45-53, </pages> <year> 1992. </year>
Reference-contexts: timetabling [31], floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment [49], interest rate risk management in banking [97], failure mode and effect analysis of complex systems [97], development of digitally controlled analog systems [197], testing of telecommunication protocols [154], causal graph management [209], factory scheduling <ref> [85] </ref>, etc. The Applause Project [167] has developed applications that use the ElipSys system for manufacturing planning, tourist advice, molecular biology, and environment monitoring and control. 72 Acknowledgements We would like to thank the following people for their comments on drafts of this paper and/or help in other ways: M.
Reference: 86. <author> F. Fages, </author> <title> On the Semantics of Optimization Predicates in CLP Languages, </title> <booktitle> Proc. 13th Conf. on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: An optimization primitive is added to the language to compute the optimal value of the objective function 20 . CHIP and cc (FD) have such primitives, but they have a non-logical behavior. Two recent papers <ref> [86, 183] </ref> discuss optimization primitives based upon the following logical characterization: m is the minimum value of f (~x) such that G (~x) holds iff 9~x (G (~x) ^ f (~x) = m) ^ :9~y (G (~y) ^ f (~y) &lt; m) Optimization primitives can be implemented by a branch and <p> A similar behavior can be obtained through constructive negation, using the above logical formulation <ref> [86, 183] </ref>, although a special-purpose implementation is more efficient. [183] gives a completeness result for such an implementation, based on Kunen's semantics for negation.
Reference: 87. <author> M. Falaschi, G. Levi, M. Martelli & C. Palamidessi, </author> <title> Declarative Modelling of the Operational Behavior of Logic Languages, </title> <booktitle> Theoretical Computer Science 69, </booktitle> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: The two functions involved are related in the following way: [S D P (I)] D = T D P ([I] D ). Consequently [lf p (S D P )] D = P ). lf p (S D P ) corresponds to the s-semantics <ref> [87] </ref> for languages with constraints [95]. Fixedpoint semantics based on sets of clauses [34] also extend easily to CLP languages.
Reference: 88. <author> T. Filkorn, R. Schmid, E. Tiden & P. Warkentin, </author> <title> Experiences from a Large Industrial Circuit Design Application, </title> <booktitle> Proc. International Logic Programming Symposium, </booktitle> <pages> 581-595, </pages> <year> 1991. </year>
Reference-contexts: A considerable amount of work has also been done on digital circuits, in particular, on verification [226, 228, 231, 232], diagnosis [229], synthesis [230] and test-pattern generation [227]. Much of these works used the CHIP system. See also <ref> [88] </ref> for a description of a large application. In civil engineering, [155] used CLP (R) for the analysis and partial synthesis of truss structures. As with electrical circuits, the constraints implement physical modelling and are used to verify truss and support components, as well as to generate spatial configurations.
Reference: 89. <author> R.E. Fikes, REF-ARF: </author> <title> A system for solving problems stated as procedures, </title> <booktitle> Artificial Intelligence 1, </booktitle> <pages> 27-120, </pages> <year> 1970. </year>
Reference-contexts: Some other related systems, EL/ARS [238] and SYN [142], used the constraint solver MACSYMA [186] to avoid the restrictions of local propagation. It was noted at this period [241] that there was a conceptual correspondence between the constraint techniques and logic programming. The REF-ARF system <ref> [89] </ref> was also designed for problem solving. One component, REF, was essentially a procedural language, but with nondeterminism because of constraints used in conditional statements. The constraints are static. They are in fact linear integer constraints, and all variables are bounded above and below. The constraint solver ARF used backtracking.
Reference: 90. <author> M. </author> <title> Fitting, A Kripke-Kleene Semantics for Logic Programs, </title> <journal> Journal of Logic Programming, </journal> <volume> 4, </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: Indeed many of the semantics for programs with negation are essentially propositional, being based upon the collection of ground instances of program rules. The perfect model [203, 14, 100], well-founded model [101], stable model [102] and Fitting fixedpoint semantics <ref> [90] </ref>, to name but a few, fall into this category.
Reference: 91. <author> J-B.J. </author> <title> Fourier. Reported in: </title> <institution> Analyse des travaux de l'Acadamie Royale des Sciences, pendant l'annee 1824, Partie mathematique, Histoire de l'Academie Royale des Sciences de l'Institut de France, </institution> <note> Vol. 7, xlvii-lv, 1827. (Partial English translation in: </note> <author> D.A. Kohler. </author> <title> Translation of a Report by Fourier on his work on Linear Inequalities. </title> <journal> Opsearch, </journal> <volume> Vol. 10, </volume> <pages> 38-42, </pages> <year> 1973) </year>
Reference-contexts: Let C + x (C x ) denote the subset of constraints C in which x has only positive (negative) coefficients. Let C 0 x denote those inequalities in C not containing x at all. We can now describe an algorithm, due to Fourier <ref> [91] </ref>, which eliminates a variable x from a given C.
Reference: 92. <author> B.N. Freeman-Benson, </author> <title> Constraint Imperative Programming, </title> <type> PhD thesis, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <year> 1991. </year>
Reference-contexts: The subsequent work ILOG, which is also commercial, is a library of constraint algorithms designed to work with C++ programs. Using a procedural language as a basis, <ref> [92] </ref> introduced Constraint Imperative Programming which has explicit constraints in the usual way, and also a new kind of constraints obtained by considering variable assignments such as x = x + 1 as time-stamped. Such assignments are treatable as constraints of the form x i = x i+1 + 1.
Reference: 93. <author> T. Fruwirth, </author> <title> Constraint Simplification Rules, </title> <type> Technical Report ECRC-92-18, </type> <institution> ECRC, </institution> <year> 1992. </year>
Reference-contexts: We give an example of this use in Section 11.1, and [212] has other examples. Some more general forms of propagation can also be expressed with guarded clauses. The work <ref> [93] </ref> can be seen as an extension of this method. The new constraints occur as predicates, and guarded rules (called constraint simplification rules) are used to simplify the new constraints. However, the guarded rules may have two (or more) atoms in the head.
Reference: 94. <author> T. Fruwirth, A. Herold, V. Kuchenhoff, T. Le Provost, P. Lim, M. Wallace, </author> <title> Constraint Logic Programming An Informal Introduction, in: Logic Programming in Action, </title> <publisher> LNCS 636, Springer-Verlag, </publisher> <pages> 3-35, </pages> <year> 1992. </year>
Reference-contexts: We assume the reader is somewhat familiar with LP and basic first-order logic. Appropriate background can be obtained from [168] for LP and [223] for logic. For introductory papers on constraint logic programming and CLP languages we refer the reader to <ref> [63, 65, 156, 94] </ref>. For further reading on CLP we suggest other surveys [58, 109, 110], some collections of papers [20, 143, 111], and some books [107, 214].
Reference: 95. <author> M. Gabbrielli & G. Levi, </author> <title> Modeling Answer Constraints in Constraint Logic Programs, </title> <booktitle> Proc. 8th International Conference on Logic Programming, </booktitle> <pages> 238-252, </pages> <year> 1991. </year>
Reference-contexts: The two functions involved are related in the following way: [S D P (I)] D = T D P ([I] D ). Consequently [lf p (S D P )] D = P ). lf p (S D P ) corresponds to the s-semantics [87] for languages with constraints <ref> [95] </ref>. Fixedpoint semantics based on sets of clauses [34] also extend easily to CLP languages. <p> Suppose (D; L) is solution compact. P is (D; L)-canonical iff [F F (P )] D = [fh c j P fl ; D j= :(h ^ c)g] D . Most of these results are from [128, 129], but there are also some from <ref> [95, 173, 177] </ref>. Results 8 and 9 of the above theorem (which are equivalent) are the only results, of those listed above, which require solution compactness.
Reference: 96. <author> H. Gaifman, M.J. Maher & E. Shapiro, </author> <title> Replay, Recovery, Replication and Snapshots of Nondeterministic Concurrent Programs, </title> <booktitle> Proc. 10th. ACM Symposium on Principles of Distributed Computation, </booktitle> <year> 1991. </year>
Reference-contexts: The above semantics only allows rewritings to be interleaved. A "true concurrency" semantics, based on graph-rewriting, is given in [191]. All ask-tell CCLP programs have the following monotonicity [216] or stability <ref> [96] </ref> property: If hA; Ci ! r hA 0 ; C 0 i and D j= C 00 ! C 0 then hA; C 00 i ! r hA 0 ; C 00 i. This property provides for simple solutions to some problems in distributed computing related to reliability. <p> This property provides for simple solutions to some problems in distributed computing related to reliability. When looked at in a more general framework <ref> [96] </ref>, stability seems to be one advantage of CCLP languages over other languages; most programs in conventional languages for concurrency are not stable. It is interesting to note that a notion of global failure (as represented in Section 5 by the state fail) destroys stability.
Reference: 97. <author> P-J. Gailly, W. Krautter, C. Bisiere & S. Bescos, </author> <title> The Prince project and its Applications, in: Logic Programming in Action, </title> <publisher> LNCS 636, Springer-Verlag, </publisher> <pages> 54-63, </pages> <year> 1992. </year>
Reference-contexts: to: music [251], car sequencing [109], aircraft traffic control [57], building visual language parsers [105], a warehousing problem [25], safety analysis [68], frequency assignment for cellular telephones [47], timetabling [31], floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment [49], interest rate risk management in banking <ref> [97] </ref>, failure mode and effect analysis of complex systems [97], development of digitally controlled analog systems [197], testing of telecommunication protocols [154], causal graph management [209], factory scheduling [85], etc. <p> [57], building visual language parsers [105], a warehousing problem [25], safety analysis [68], frequency assignment for cellular telephones [47], timetabling [31], floor planning [140], spacecraft attitude control [233], interoperability of fibre optic communications equipment [49], interest rate risk management in banking <ref> [97] </ref>, failure mode and effect analysis of complex systems [97], development of digitally controlled analog systems [197], testing of telecommunication protocols [154], causal graph management [209], factory scheduling [85], etc.
Reference: 98. <author> M. Garca de la Banda & M. Hermenegildo, </author> <title> A Practical Approach to the Global Analysis of Constraint Logic Programs, </title> <booktitle> Proc. International Logic Programming Symposium, </booktitle> <pages> 437-455, </pages> <year> 1993. </year>
Reference-contexts: Techniques for CLP Program Analysis The kinds of program analysis required to utilize the specialized instructions include those techniques developed for Prolog, most prominently, detecting special cases of unification and deterministic predicates. Algorithms for such analysis have become familiar; see [73, 74] for example. See <ref> [98] </ref>, for example, for a description of how to extend the general techniques of abstract interpretation applicable in LP to CLP. Our considerations above, however, require rather specific kinds of analyses. Detecting redundant variables and future redundant constraints can in fact be done without dataflow analysis.

References-found: 98

