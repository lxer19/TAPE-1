URL: http://www.cs.brandeis.edu/~suresh/Papers/MIMD.ps
Refering-URL: http://www.cs.brandeis.edu/~suresh/Papers/
Root-URL: http://www.cs.brandeis.edu
Email: E-Mail: fjc, sureshg@cs.brandeis.edu  
Title: A Parallel Interval-Based Constraint Language: Implementation and Performance Analysis  
Author: Jacques Cohen Suresh Kalathur 
Note: Supported by NSF Grant CCR-94 0342762394. Corresponding author.  
Date: December 6, 1995  
Address: Waltham, MA 02254  
Affiliation: Computer Science Department Brandeis University  
Abstract-found: 0
Intro-found: 1
Reference: [ApCo 91] <author> D. Applegate, and W. Cook, </author> <title> A Computational Study of the Job-Shop Scheduling Problem, </title> <journal> ORSA Journal on Computing, </journal> <volume> vol. 3, no. 2, </volume> <month> Spring, </month> <year> 1991, </year> <pages> pp. 149-156. </pages>
Reference-contexts: The constraint solver is run on an SGI-Onyx with 16 processors. The problems i4 and combustion are from [HeMK 95]. The data for the Job-Shop problems is taken from <ref> [ApCo 91] </ref>. 5 Final Remarks Our main result is that one can obtain linear speed-ups on MIMD processing of a parallel language when the execution tree contains a substantial number of nodes.
Reference: [BeMcHe 94] <author> F. Benhamou, D. McAllester, and P. V. Hentenryck, </author> <title> CLP(Intervals) Revisited, </title> <type> Technical Report No. </type> <institution> CS-94-18, Department of Computer Science, Brown University. </institution>
Reference-contexts: It would not be difficult to design other front ends based on CLP like languages. CLP (BNR) extends Prolog with interval constraints [OlVe 93]. The CLP language Newton <ref> [BeMcHe 94, HeMK 95] </ref> deals with interval constraints in their entirety instead of breaking them up into primitive constraints as done in CLP (BNR). The Newton approach appears to be more efficient than the BNR method.
Reference: [COHE 79] <author> J. Cohen, </author> <title> Non-Deterministic Algorithms, </title> <journal> Computing Surveys, </journal> <volume> vol. 11, no. 2, </volume> <month> June, </month> <year> 1979, </year> <pages> pp. 79-94. </pages>
Reference: [CoKa 95] <author> J. Cohen, and S. Kalathur, </author> <title> Data-Parallel Design of an Interval-Based Constraint Language: Analysis of Speed-Ups, </title> <booktitle> International Conference on Parallel and Distributed Processing Techniques and Applications, </booktitle> <month> November, </month> <year> 1995. </year>
Reference: [FLAJ 87] <author> P. Flajolet, </author> <title> Mathematical Tools for Automatic Program Analysis, </title> <type> Research Report 603, </type> <institution> INRIA, </institution> <year> 1987. </year>
Reference-contexts: The average execution time is P m E i m . When n is small, all the strings of length n can be generated by using DCG's. However, for large n, there are techniques that do not require the generation of all the strings. These techniques developed by <ref> [HiCo 88, FLAJ 87] </ref> just generate the so called uniformly random strings.
Reference: [HeMK 95] <author> P. V. Hentenryck, D. McAllester, and D. Kapur, </author> <title> Solving Polynomial Systems Using a Branch and Prune Approach, </title> <type> Technical Report No. </type> <institution> CS-95-01, Department of Computer Science, Brown University. </institution>
Reference-contexts: It would not be difficult to design other front ends based on CLP like languages. CLP (BNR) extends Prolog with interval constraints [OlVe 93]. The CLP language Newton <ref> [BeMcHe 94, HeMK 95] </ref> deals with interval constraints in their entirety instead of breaking them up into primitive constraints as done in CLP (BNR). The Newton approach appears to be more efficient than the BNR method. <p> The constraint solver is run on an SGI-Onyx with 16 processors. The problems i4 and combustion are from <ref> [HeMK 95] </ref>. The data for the Job-Shop problems is taken from [ApCo 91]. 5 Final Remarks Our main result is that one can obtain linear speed-ups on MIMD processing of a parallel language when the execution tree contains a substantial number of nodes.
Reference: [HiCo 88] <author> T. J. Hickey, and J. Cohen, </author> <title> Automating Program Analysis, </title> <journal> Journal of the ACM, </journal> <volume> vol. 35, no. 1, </volume> <year> 1988, </year> <pages> pp. 185-220. </pages>
Reference-contexts: The average execution time is P m E i m . When n is small, all the strings of length n can be generated by using DCG's. However, for large n, there are techniques that do not require the generation of all the strings. These techniques developed by <ref> [HiCo 88, FLAJ 87] </ref> just generate the so called uniformly random strings.
Reference: [MOOR 66] <author> R. E. Moore, </author> <title> Interval Analysis, </title> <publisher> Prentice Hall, </publisher> <year> 1966. </year>
Reference: [OlVe 93] <author> W. J. Older, and A. Vellino, </author> <title> Constraint Arithmetic on Real Intervals, Constraint Logic Programming: Selected Research, edited by F. </title> <editor> Benhamou and A. </editor> <publisher> Colmerauer , MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: It would not be difficult to design other front ends based on CLP like languages. CLP (BNR) extends Prolog with interval constraints <ref> [OlVe 93] </ref>. The CLP language Newton [BeMcHe 94, HeMK 95] deals with interval constraints in their entirety instead of breaking them up into primitive constraints as done in CLP (BNR). The Newton approach appears to be more efficient than the BNR method.
Reference: [SHUB 95] <author> G. Shubina, </author> <title> A Study of Speed-Up of Parallel Programs using Context-Free Grammars, </title> <type> Technical Report, </type> <institution> Computer Science Dept., Brandeis University, </institution> <year> 1995. </year>
Reference-contexts: The context-free grammar is used in generating random strings of arbitrary length [ZIMM 92]. The speed-up achieved with varying the number of processors can be analytically calculated <ref> [SHUB 95] </ref>. The program shown in Figure 10 labels the given execution tree. Constant (unit) time assumptions are made for choice, split, narrow, and enumerate.
Reference: [ZIMM 92] <author> P. Zimmerman, </author> <title> Gaia: A Package for the Random Generation of Combinatorial Structures, </title> <institution> INRIA, France. </institution> <month> 19 </month>
Reference-contexts: The table in Figure 9 shows the number of time steps needed with varying the number of processors for the execution tree in Figure 3. The context-free grammar is used in generating random strings of arbitrary length <ref> [ZIMM 92] </ref>. The speed-up achieved with varying the number of processors can be analytically calculated [SHUB 95]. The program shown in Figure 10 labels the given execution tree. Constant (unit) time assumptions are made for choice, split, narrow, and enumerate.
References-found: 11

