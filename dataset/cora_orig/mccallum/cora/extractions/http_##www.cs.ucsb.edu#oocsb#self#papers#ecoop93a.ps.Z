URL: http://www.cs.ucsb.edu/oocsb/self/papers/ecoop93a.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/type-inference.html
Root-URL: http://www.cs.ucsb.edu
Title: Type Inference of SELF Analysis of Objects with Dynamic and Multiple Inheritance  
Author: Ole Agesen ? Jens Palsberg Michael I. Schwartzbach ?? 
Keyword: Languages and their implementation, tools and environments.  
Address: Stanford, CA 94305, USA,  Ny Munkegade, DK-8000 -Arhus C, Denmark,  
Affiliation: 1 Dept. of Computer Science, Stanford University,  Computer Science Dept., Aarhus University,  
Note: To appear in ECOOP '93 Proceedings, Springer Verlag Lecture Notes on Computer Science.  
Email: agesen@self.stanford.edu  fpalsberg,misg@daimi.aau.dk  
Phone: 2  
Abstract: We have designed and implemented a type inference algorithm for the full Self language. The algorithm can guarantee the safety and disambiguity of message sends, and provide useful information for browsers and optimizing compilers. Self features objects with dynamic inheritance. This construct has until now been considered incompatible with type inference because it allows the inheritance graph to change dynamically. Our algorithm handles this by deriving and solving type constraints that simultaneously define su-persets of both the possible values of expressions and of the possible inheritance graphs. The apparent circularity is resolved by computing a global fixed-point, in polynomial time. The algorithm has been implemented and can successfully handle the Self benchmark programs, which exist in the "standard Self world" of more than 40,000 lines of code. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ole Agesen, Lars Bak, Craig Chambers, Bay-Wei Chang, Urs Holzle, John Mal-oney, Randall B. Smith, and David Ungar. </author> <title> The SELF programmer's reference manual, version 2.0. </title> <type> Technical report, </type> <institution> Sun Microsystems, Inc, </institution> <address> 2550 Garcia Avenue, Mountain View, CA 94043, USA, </address> <year> 1992. </year> <note> SMLI document 93-0056. Available by anonymous ftp from self.stanford.edu. </note>
Reference-contexts: This has already been verified in practice since parent priorities were recently eliminated from Self. The code in Figure 3, though, applies to the old semantics of Self as found in release 2.0.1 <ref> [1] </ref>. For simplicity, the code in inheritance graphs). Block method invocation. Block methods are different from normal methods in two major aspects. First, instead of a self parent they have an anonymous parent that refers to the lexically enclosing method. Second, they may have a non-local return.
Reference: 2. <author> Alan H. Borning. </author> <title> Classes versus prototypes in object-oriented languages. </title> <booktitle> In ACM/IEEE Fall Joint Computer Conference, </booktitle> <pages> pages 36-40, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction The choice between static and dynamic typing involves a choice between safety and flexibility. The flexibility offered by dynamically typed object-oriented languages is useful in exploratory programming but may also be a hindrance to safety checking and optimization when delivering products. Henry Lieberman [8] and Alan Borning <ref> [2] </ref> developed the notion of object-oriented languages based on prototypes.
Reference: 3. <author> Craig Chambers and David Ungar. </author> <title> Making pure object-oriented languages practical. </title> <booktitle> In Proc. OOPSLA'91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 1-15, </pages> <year> 1991. </year>
Reference-contexts: The program itself has a long history. Originally, it was written in Pascal and included in the "Stanford Integer Benchmarks" suite collected by John Hennessy. Later the benchmarks were translated to Self and used to characterize the run-time performance of the Self system <ref> [3] </ref>. Now we use the towers oo program to illustrate how a browser may combine program text with inferred types, to make program understanding easier. <p> The intuition behind this hash function has two parts. The last component, , ensures that each new receiver type will get its own duplicate, resulting in a duplication strategy akin to customization <ref> [3] </ref>. The 18 first two components of the hash function refines this strategy to ensure that sends that are different in the original program will invoke different duplicates, even if the sends have the same receiver. This is useful because different sends often supply arguments of different types.
Reference: 4. <author> Craig Chambers, David Ungar, Bay-Wei Chang, and Urs Holzle. </author> <title> Parents are Shared Parts of Objects: Inheritance and Encapsulation in Self. </title> <booktitle> In Lisp and 20 Symbolic Computation 4(3), </booktitle> <pages> pages 207-222, </pages> <publisher> Kluwer Acadamic Publishers, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: It is both a simple and a complex language. Simple, e.g., because it does not have classes and meta-classes, but complex, e.g., because it has complicated inheritance rules <ref> [4] </ref>. The type inference work has focused attention on many of the complexities, providing input to an ongoing attempt to further simplify Self. One example is the recent elimination of parent priorities.
Reference: 5. <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80|The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: In Section 3 we present example runs of our implementation, and in Section 4 we discuss details of our algorithm and implementation. Finally, in Section 5 we summarize our results and conclusions. 2 Type Constraints Self [13] resembles Smalltalk <ref> [5] </ref> on the surface. However, there are major differences that make Self a particularly interesting language to analyze: Self has no classes, instantiation is object cloning, inheritance is between objects having independent state and identity, and the inheritance may be both dynamic and multiple.
Reference: 6. <author> Justin O. Graver and Ralph E. Johnson. </author> <title> A type system for Smalltalk. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 136-150. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: The apparent circularity is resolved by computing a global fixed-point, in polynomial time. In most other type inference algorithms for object-oriented languages, for example that of Graver and Johnson <ref> [7, 6] </ref> and our own [10, 9], inheritance is expanded away rather than dealt with directly. Using prototypes, however, expansion is impossible, since a parent may have an independent state. This paper demonstrates how to handle inheritance without expansion. It also shows how to handle blocks with non-local return.
Reference: 7. <author> Justin Owen Graver. </author> <title> Type-Checking and Type-Inference for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> August </month> <year> 1989. </year> <month> UIUCD-R-89-1539. </month>
Reference-contexts: The apparent circularity is resolved by computing a global fixed-point, in polynomial time. In most other type inference algorithms for object-oriented languages, for example that of Graver and Johnson <ref> [7, 6] </ref> and our own [10, 9], inheritance is expanded away rather than dealt with directly. Using prototypes, however, expansion is impossible, since a parent may have an independent state. This paper demonstrates how to handle inheritance without expansion. It also shows how to handle blocks with non-local return.
Reference: 8. <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object-oriented systems. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 214-223. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> Novem-ber </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The choice between static and dynamic typing involves a choice between safety and flexibility. The flexibility offered by dynamically typed object-oriented languages is useful in exploratory programming but may also be a hindrance to safety checking and optimization when delivering products. Henry Lieberman <ref> [8] </ref> and Alan Borning [2] developed the notion of object-oriented languages based on prototypes.
Reference: 9. <author> Nicholas Oxhtj, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Making type inference practical. </title> <booktitle> In Proc. ECOOP'92, Sixth European Conference on Object-Oriented Programming, </booktitle> <pages> pages 329-349. </pages> <publisher> Springer-Verlag (LNCS 615), </publisher> <address> Utrecht, The Nether-lands, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Although we focus on Self our work applies to other languages as well. Our approach to type inference is based on constraints, like in our previous papers on an idealized subset of Smalltalk. In [10] we defined the basic type inference framework, and in <ref> [9] </ref> we demonstrated an efficient implementation. Dynamic inheritance has until now been considered incompatible with type inference because it allows the inheritance graph to change dynamically. <p> The apparent circularity is resolved by computing a global fixed-point, in polynomial time. In most other type inference algorithms for object-oriented languages, for example that of Graver and Johnson [7, 6] and our own <ref> [10, 9] </ref>, inheritance is expanded away rather than dealt with directly. Using prototypes, however, expansion is impossible, since a parent may have an independent state. This paper demonstrates how to handle inheritance without expansion. It also shows how to handle blocks with non-local return. <p> The main idea in constraint-based analysis [15, 12, 11] is as follows. First, define type variables for the unknown type information. Second, derive constraints on these variables from the given program. Third, solve the resulting constraints to obtain the desired information. The algorithms in <ref> [10, 9] </ref> had safety checking as an integral part of the type constraints. As a result, type information could not be inferred for incorrect programs that could provoke a msgNotUnderstood error. The approach in this paper is more liberal, so type information can be computed for all programs. <p> The auxiliary type variables are needed to handle non-local returns. All type variables range over sets of tokens. 2.3 Constraints for Self From the syntax of the given program we generate and solve a finite collection of constraints. These constraints, which are presented by means of a trace graph <ref> [10, 9] </ref>, are all conditional set inclusions. Using the trace graph technique, we need only define constraints for local situations; the corresponding global constraints will then automatically be derived, as described below. 3 We have a trace graph node for each object and method in the program. <p> Such a global constraint means intuitively that if this trace is possible during execution, then these constraints must hold. For further details about the trace graph technique and how to derive global constraints, see <ref> [10, 9] </ref>. The circularity between conditions and constraints is fairly simple for a language like Smalltalk, which has dynamic dispatch but static inheritance. When we include dynamic and multiple inheritance, several further complications arise. <p> One such is shown in Figure 6: the result of a block method, block , with non-local return can become the result of the enclosing normal method object, normal . 8 2.4 Code Duplication As suggested in <ref> [10, 9] </ref>, it is often necessary to duplicate code to obtain sufficiently precise types. The idea is for each method to make individual copies for every syntactic invocation. These copies can then be separately analyzed, so that unwanted "cross-constraints" can be avoided. <p> In Section 4 we describe how to obtain an efficient, polynomial-time algorithm for solving monotonic type constraints. It is similar to the one presented in <ref> [9] </ref>, in using a lazy, incremental strategy; however, the new algorithm is a drastic improvement. <p> Analyzing a 200 line program of which 100 lines implement a unary representation of natural numbers is not as interesting, or challenging, as analyzing 200 lines of code that just assume and use a fully developed implementation of numbers, collection classes, and other data structures. Previous articles <ref> [10, 9] </ref> have listed small programs, the derived constraints, and their minimal solution as found by a particular constraint solving algorithm. <p> In <ref> [9] </ref> this was remedied by an incremental computation of both the trace graph and its minimal solution. Starting with the main node, the general situation would be that a connected part of the graph had been constructed and its solution computed. <p> If we always duplicated, then the type inference algorithm might never terminate since, for example, a recursive method would result in an infinite number of duplicates being produced during the analysis. In <ref> [9] </ref> we created one duplicate for every syntactic message send with selector id: in the original program. In the Self algorithm we apply a "hash function" and create a duplicate if none already exists with the same hash value.
Reference: 10. <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proc. OOPSLA'91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161, </pages> <address> Phoenix, Ari-zona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Although we focus on Self our work applies to other languages as well. Our approach to type inference is based on constraints, like in our previous papers on an idealized subset of Smalltalk. In <ref> [10] </ref> we defined the basic type inference framework, and in [9] we demonstrated an efficient implementation. Dynamic inheritance has until now been considered incompatible with type inference because it allows the inheritance graph to change dynamically. <p> The apparent circularity is resolved by computing a global fixed-point, in polynomial time. In most other type inference algorithms for object-oriented languages, for example that of Graver and Johnson [7, 6] and our own <ref> [10, 9] </ref>, inheritance is expanded away rather than dealt with directly. Using prototypes, however, expansion is impossible, since a parent may have an independent state. This paper demonstrates how to handle inheritance without expansion. It also shows how to handle blocks with non-local return. <p> The main idea in constraint-based analysis [15, 12, 11] is as follows. First, define type variables for the unknown type information. Second, derive constraints on these variables from the given program. Third, solve the resulting constraints to obtain the desired information. The algorithms in <ref> [10, 9] </ref> had safety checking as an integral part of the type constraints. As a result, type information could not be inferred for incorrect programs that could provoke a msgNotUnderstood error. The approach in this paper is more liberal, so type information can be computed for all programs. <p> The auxiliary type variables are needed to handle non-local returns. All type variables range over sets of tokens. 2.3 Constraints for Self From the syntax of the given program we generate and solve a finite collection of constraints. These constraints, which are presented by means of a trace graph <ref> [10, 9] </ref>, are all conditional set inclusions. Using the trace graph technique, we need only define constraints for local situations; the corresponding global constraints will then automatically be derived, as described below. 3 We have a trace graph node for each object and method in the program. <p> Such a global constraint means intuitively that if this trace is possible during execution, then these constraints must hold. For further details about the trace graph technique and how to derive global constraints, see <ref> [10, 9] </ref>. The circularity between conditions and constraints is fairly simple for a language like Smalltalk, which has dynamic dispatch but static inheritance. When we include dynamic and multiple inheritance, several further complications arise. <p> One such is shown in Figure 6: the result of a block method, block , with non-local return can become the result of the enclosing normal method object, normal . 8 2.4 Code Duplication As suggested in <ref> [10, 9] </ref>, it is often necessary to duplicate code to obtain sufficiently precise types. The idea is for each method to make individual copies for every syntactic invocation. These copies can then be separately analyzed, so that unwanted "cross-constraints" can be avoided. <p> Monotonicity of a condition simply means that it can never be true for a particular assignment of types to variables and false for a strictly larger one. In our case, assignments are ordered by variable-wise set inclusion. In <ref> [10] </ref> it is shown that if the type constraints are monotonic, they have a unique minimal solution, which is also computable. <p> Analyzing a 200 line program of which 100 lines implement a unary representation of natural numbers is not as interesting, or challenging, as analyzing 200 lines of code that just assume and use a fully developed implementation of numbers, collection classes, and other data structures. Previous articles <ref> [10, 9] </ref> have listed small programs, the derived constraints, and their minimal solution as found by a particular constraint solving algorithm.
Reference: 11. <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <volume> 43 </volume> <pages> 175-180, </pages> <year> 1992. </year>
Reference-contexts: Below we describe our approach to type inference for Self. We will use the Self-terminology without explanation. 2 2.1 Constraint-Based Analysis Our approach to type inference is based on constraints, like in our previous papers on an idealized subset of Smalltalk. The main idea in constraint-based analysis <ref> [15, 12, 11] </ref> is as follows. First, define type variables for the unknown type information. Second, derive constraints on these variables from the given program. Third, solve the resulting constraints to obtain the desired information.
Reference: 12. <author> Michael I. Schwartzbach. </author> <title> Type inference with inequalities. </title> <booktitle> In Proc. TAPSOFT'91, </booktitle> <pages> pages 441-455. </pages> <publisher> Springer-Verlag (LNCS 493), </publisher> <year> 1991. </year>
Reference-contexts: Below we describe our approach to type inference for Self. We will use the Self-terminology without explanation. 2 2.1 Constraint-Based Analysis Our approach to type inference is based on constraints, like in our previous papers on an idealized subset of Smalltalk. The main idea in constraint-based analysis <ref> [15, 12, 11] </ref> is as follows. First, define type variables for the unknown type information. Second, derive constraints on these variables from the given program. Third, solve the resulting constraints to obtain the desired information.
Reference: 13. <author> David Ungar and Randall B. Smith. </author> <title> SELF: The power of simplicity. </title> <booktitle> In Proc. OOPSLA'87, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 227-241, </pages> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Acadamic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: These language constructs, however, make safety checking more difficult than for class-based languages. This paper presents a type inference algorithm for the Self language <ref> [13] </ref>. Self is a prototype-based dynamically typed object-oriented language featuring dynamic and multiple inheritance. Our algorithm can guarantee the safety and disambiguity of message sends, and provide useful information for tools such as browsers and optimizing compilers. Although we focus on Self our work applies to other languages as well. <p> In the following Section we give an overview of the required type constraints. In Section 3 we present example runs of our implementation, and in Section 4 we discuss details of our algorithm and implementation. Finally, in Section 5 we summarize our results and conclusions. 2 Type Constraints Self <ref> [13] </ref> resembles Smalltalk [5] on the surface. However, there are major differences that make Self a particularly interesting language to analyze: Self has no classes, instantiation is object cloning, inheritance is between objects having independent state and identity, and the inheritance may be both dynamic and multiple.
Reference: 14. <author> Jan Vitek, R. Nigel Horspool, and James S. Uhl. </author> <title> Compile-time analysis of object-oriented programs. </title> <booktitle> In Proc. CC'92, 4th International Conference on Compiler Construction, Paderborn, Germany, </booktitle> <pages> pages 236-250. </pages> <publisher> Springer-Verlag (LNCS 641), </publisher> <year> 1992. </year>
Reference-contexts: The type of the send includes nil because movesdone is not initialized (see line 3 of the program): by combining type inference with data flow analysis, types can be improved in such situations <ref> [14] </ref>. The fact that nil shows up in the type could alternatively be attributed to "bad" programming style: prototype objects should have their slots initialized with proper prototypical objects, else they are not prototypical. In the specific case this means that movesdone should be initialized with an integer object.
Reference: 15. <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamentae Informaticae, </journal> <volume> X:115-122, </volume> <year> 1987. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 21 </title>
Reference-contexts: Below we describe our approach to type inference for Self. We will use the Self-terminology without explanation. 2 2.1 Constraint-Based Analysis Our approach to type inference is based on constraints, like in our previous papers on an idealized subset of Smalltalk. The main idea in constraint-based analysis <ref> [15, 12, 11] </ref> is as follows. First, define type variables for the unknown type information. Second, derive constraints on these variables from the given program. Third, solve the resulting constraints to obtain the desired information.
References-found: 15

