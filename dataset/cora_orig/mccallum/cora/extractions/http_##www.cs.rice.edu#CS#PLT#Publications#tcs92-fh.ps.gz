URL: http://www.cs.rice.edu/CS/PLT/Publications/tcs92-fh.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Syntactic Theories of Sequential Control and State  
Author: Matthias Felleisen Robert Hieb 
Address: Houston, TX 77251-1892  Bloomington, IN 47405  
Affiliation: Department of Computer Science Rice University  Computer Science Department Indiana University  
Abstract: The Revised Report Rice University Technical Report # 100-89 to appear in: Theoretical Computer Science 1991 on the
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abadi, M., L. Cardelli, P.-L. Curien, and J.-J. L evy. </author> <title> Explicit substitution. </title> <booktitle> In Proc. 17th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990, </year> <pages> 31-46. </pages>
Reference-contexts: It also follows from the above Lemma that every theorem e 1 = e 2 in v -S . for e 1 ; e 2 2 fl S implies the existence of a theorem 1 :e 0 2 3 Recently, Abadi et al. <ref> [1] </ref> proposed and studied a variant of the -calculus that incorporates explicit substitutions. Our -applications correspond to their closures: in the notation of Abadi et al. :e would be the term e [] for a non-recursive .
Reference: 2. <author> Barendregt, </author> <title> H.P. The Lambda Calculus: Its Syntax and Semantics. Revised Edition. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: The fifth section describes the merger of the two theories. Finally we discuss related work and some implications of our work for an alternative denotational semantics for extended functional languages. 2 2 The -value-calculus The expression language fl of the -calculus and the v -calculus <ref> [2, 3, 18] </ref> is the union of a set of values and expression juxtapositions: e ::= v j (e e): The set of values is the collection of basic constants (b 2 BConsts) and functional constants (f 2 FConsts), variables (x 2 Vars) and -abstractions: v ::= b j f j <p> Expression juxtaposition denotes function application. The only binding construct in the programming language is -abstraction. The set of closed expressions, fl 0 , is the set of all expressions with no free variables; Values 0 is the set of closed values. We adopt Barendregt's <ref> [2] </ref> conventions on bound variables and abstractions: * Bound variables are always distinct from free variables in the various expressions of mathematical definitions and claims. * Abstractions that only differ by a renaming of bound variables are identified, e.g., x:x y:y: The expression e [x e 1 ] is the result
Reference: 3. <author> Church, A. </author> <title> Introduction to Mathematical Logic. </title> <publisher> Princeton University Press, </publisher> <address> Prince-ton, New Jersey, </address> <year> 1956. </year>
Reference-contexts: The fifth section describes the merger of the two theories. Finally we discuss related work and some implications of our work for an alternative denotational semantics for extended functional languages. 2 2 The -value-calculus The expression language fl of the -calculus and the v -calculus <ref> [2, 3, 18] </ref> is the union of a set of values and expression juxtapositions: e ::= v j (e e): The set of values is the collection of basic constants (b 2 BConsts) and functional constants (f 2 FConsts), variables (x 2 Vars) and -abstractions: v ::= b j f j <p> that implements a partial function from programs to answers, where the former are closed expressions and the latter are closed values: eval SECD : fl 0 ! Values 0 : The use of fl as a programming language with an operational semantics and as the term language for Church's -calculus <ref> [3] </ref> raises the natural question of how the two concepts correspond to each other.
Reference: 4. <author> Demers, A. and J. Donahue. </author> <title> Making variables abstract: an equational theory for Russell. </title> <booktitle> In Proc. 10th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983, </year> <pages> 59-72. </pages>
Reference-contexts: An early effort in the direction of equational theories for proving the correctness of higher-order imperative programs is due to Demers and Donahue <ref> [4] </ref>. The focus of their research is Russell, an extension of the higher-order typed -calculus with cells and destructive cell operations; their major result is a proof system for Russell with several dozen axioms, quite unlike our reductions or the Mason-Talcott axioms.
Reference: 5. <author> Felleisen, M. </author> <title> The Calculi of Lambda-v-CS-Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming Languages. </title> <type> Ph.D. dissertation, </type> <institution> Indiana University, </institution> <year> 1987. </year>
Reference-contexts: (x:v)]] ( Y ) if x is not assignable in e, v , and and where Y df A restricted version of fi v can be derived from Y . 5 Unified theories of control and state The original theories of control and state are completely orthogonal to each other <ref> [5] </ref>. The sum of the extended notions of reduction yields a theory for a language with facilities for both control and state manipulation; indeed, the shape of the reduction relations as pattern-matching rules stays the same.
Reference: 6. <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 180-190. </pages>
Reference-contexts: For example, we recently showed that by adding a control delimiter facility to the -calculus extended with control operators, we can simplify the calculus and get a more elegant relationship between the language and its calculus <ref> [6] </ref>. But, although this proposal provides a good example of how calculus design can influence and improve language design, it does not alleviate the need for better techniques for reasoning about existing languages.
Reference: 7. <author> Felleisen, M. and D.P. Friedman. </author> <title> Control operators, the SECD-machine, and the -calculus. In Formal Description of Programming Concepts III , edited by M. Wirsing. </title> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <address> Amsterdam, </address> <year> 1986, </year> <pages> 193-217. </pages>
Reference-contexts: The final subsection presents two interesting extensions of the equational theory. 3.1 A syntactic theory of control abstractions Originally we derived the syntactic theory of control from an abstract operational semantics based on Landin's SECD-machine <ref> [7] </ref>. Eliminating all non-program text components from the machine shows that the concept of "current continuation" is equivalent to the notion of evaluation context.
Reference: 8. <author> Felleisen, M. and D.P. Friedman. </author> <title> A syntactic theory of sequential state. </title> <journal> Theor. Comput. Sci. </journal> <volume> 69(3), </volume> <year> 1989, </year> <month> 243-287. </month> <title> Preliminary version in: </title> <booktitle> Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1987, </year> <pages> 314-325. </pages>
Reference-contexts: Typical examples are ML [16], Scheme [19], and Common Lisp [20]. While these additions add expressive power and increase the efficiency of programs, they also appear to invalidate the simple reduction rules and equational reasoning of the -calculus that make functional programming so appealing. In two previous papers <ref> [8, 9] </ref>, we have shown that there are conservative extensions of Plotkin's v -calculus [18] for such programming languages, and that it is possible to reason about programs in extended functional languages in an equational style. <p> The notions of substitution, contexts and evaluation contexts are adapted appropriately. The latter definition has the same shape as in the v and the v -C-calculus framework, but denotes a subset of contexts over fl . In the following subsection, we introduce the calculus of procedural abstraction and state <ref> [8] </ref>. Like the original calculus of control, the state calculus requires two kinds of term relations and, moreover, relies on further extensions of the language fl . We show in the second subsection that both program-level term relations as well as additional language extensions are superfluous. <p> The traditional solution is to maintain an addi-tional function that maps a parameter name to a value: a store. In our earlier report <ref> [8] </ref>, we demonstrated that the store and its management can be incorporated into the term structure of the program. The key is to keep track of the substituted values via a unique label that is attached to the value before substitution.
Reference: 9. <author> Felleisen, M., D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theor. Comput. Sci. </journal> <volume> 52(3), </volume> <year> 1987, </year> <pages> 205-237. </pages> <note> Preliminary version in: Proc. Symposium on Logic in Computer Science, </note> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: Typical examples are ML [16], Scheme [19], and Common Lisp [20]. While these additions add expressive power and increase the efficiency of programs, they also appear to invalidate the simple reduction rules and equational reasoning of the -calculus that make functional programming so appealing. In two previous papers <ref> [8, 9] </ref>, we have shown that there are conservative extensions of Plotkin's v -calculus [18] for such programming languages, and that it is possible to reason about programs in extended functional languages in an equational style. <p> The following subsection briefly presents our original theory of control abstractions with an emphasis on the set of safe equations; for a more complete description, we refer the reader to the earlier report <ref> [9] </ref>. The second subsection contains the development of a finite axiomatization of the theory of safe equations. The Plotkin-style correspondence theorem relies on a proof of equivalence between the two calculi and on the idea that the old calculus is an acceptable specification of the semantics of fl c . <p> Second, we show in several steps that the new system is Church-Rosser. The proof for c 0 = ffi [ fi [ C 0 lift is a simple adaptation of the Church-Rosser proof for c <ref> [9] </ref>. It is also straightforward to prove that C 0 idem , C top and C 0 top each directly satisfy the diamond property, and that they are therefore Church-Rosser. Next we combine the relations and use the Hindley-Rossen method [2:64-66] for proving the Church-Rosser property of the larger relations.
Reference: 10. <author> Griffin, T. </author> <title> A formulae-as-types notion of control. </title> <booktitle> In Proc. 17th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990, </year> <pages> 47-58. 33 </pages>
Reference-contexts: Indeed, the entire system of c-reduction, C idem , and C top suffices for simulating 1 Tim Griffin independently and simultaneously discovered another solution while studying the connection between a typed variant of the control calculus and classical logic <ref> [10] </ref>. He proposes to restrict the set of programs to expressions of the form C (k:ke) and to use C idem as a replacement for C T . 10 a complete evaluation.
Reference: 11. <author> Landin, P.J. </author> <title> The next 700 programming languages. </title> <journal> Commun. ACM 9(3), </journal> <year> 1966, </year> <pages> 157-166. </pages>
Reference-contexts: Following Plotkin [18], we assume that the behavior of constants is specified by a partial function from functional and basic constants to closed values: ffi : FConsts fi BConsts ! Values 0 : In the mid-60's, Landin <ref> [11, 12] </ref> illustrated in a series of papers that fl is an interesting and powerful programming language. Most importantly, he showed how a simple stack-based calculator for algebraic expressions could be extended to the abstract SECD-machine for evaluating complete fl-programs. <p> . x n :(x 1 . . . x n :e 00 )u 1 . . . u n )(x:x) . . .(x:x); which proves the proposition. 2 In order to simplify the presentation of terms like e 0 in the preceding lemma, we introduce a simplified version of Landin's <ref> [11] </ref> letrec-abbreviation: the -application. 3 A -application is a combination of a finite function from assignable variables to values, represented as a set = f (x 1 ; v 1 ); . . . ; (x n ; v n )g, and an expression e; it expands according to the construction
Reference: 12. <author> Landin, P.J. </author> <title> The mechanical evaluation of expressions. </title> <journal> Comput. J. </journal> <volume> 6(4), </volume> <year> 1964, </year> <pages> 308-320. </pages>
Reference-contexts: Following Plotkin [18], we assume that the behavior of constants is specified by a partial function from functional and basic constants to closed values: ffi : FConsts fi BConsts ! Values 0 : In the mid-60's, Landin <ref> [11, 12] </ref> illustrated in a series of papers that fl is an interesting and powerful programming language. Most importantly, he showed how a simple stack-based calculator for algebraic expressions could be extended to the abstract SECD-machine for evaluating complete fl-programs.
Reference: 13. <author> Mason, </author> <title> I.A. Equivalences of first-order Lisp programs. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1986, </year> <pages> 105-117. </pages>
Reference-contexts: Over the past few years, they have developed equational theories for a first-order version of Lisp with destructive cell operations <ref> [13] </ref>, for a fl C - like language on control [22, 23], and, most recently, for a higher-order imperative version of Lisp without control abstractions [14].
Reference: 14. <author> Mason, I.A. and C. Talcott. </author> <title> Programming, transforming, and proving with function abstractions and memories. </title> <booktitle> In Proc. International Conference on Automata, Languages and Programming. Springer Lecture Notes in Computer Science, </booktitle> <address> Berlin, </address> <year> 1989, </year> <pages> 574-588. </pages>
Reference-contexts: Over the past few years, they have developed equational theories for a first-order version of Lisp with destructive cell operations [13], for a fl C - like language on control [22, 23], and, most recently, for a higher-order imperative version of Lisp without control abstractions <ref> [14] </ref>. For a fragment of first-order destructive Lisp without arithmetic and recursion, they have also shown that it is possible to obtain a complete theory [15]. Mason and Talcott's equational proof systems are essentially ad hoc approximations to the operational equivalences of the respective languages. <p> The development of a good proof system will require the development of an induction principle and other mathematical tools in order to strengthen the power of the system. One possible solution is to work with the underlying operational approximation relation and to axiomatize its use <ref> [14] </ref>. The more popular direction relies on the ideas of denotational semantics. Currently, however, denotational semantics provides different models for different languages, especially in the realm of the imperative, higher-order language family. It is consequently difficult to relate results on a language to results on its extensions.
Reference: 15. <author> Mason, I.A. and C. Talcott. </author> <title> A sound and complete axiomatization of operational equivalence between programs with memory. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> 284-293. </pages>
Reference-contexts: For a fragment of first-order destructive Lisp without arithmetic and recursion, they have also shown that it is possible to obtain a complete theory <ref> [15] </ref>. Mason and Talcott's equational proof systems are essentially ad hoc approximations to the operational equivalences of the respective languages. They find the axioms of these theories by extracting and generalizing frequently used laws from example correctness proofs of programs.
Reference: 16. <author> Milner, R., M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts and London, England, </address> <year> 1990. </year>
Reference-contexts: 1 The syntactic theories of control and state Most -calculus-based programming languages provide imperative programming facilities such as assignment statements, exceptions, and continuations. Typical examples are ML <ref> [16] </ref>, Scheme [19], and Common Lisp [20]. While these additions add expressive power and increase the efficiency of programs, they also appear to invalidate the simple reduction rules and equational reasoning of the -calculus that make functional programming so appealing.
Reference: 17. <author> Moggi, E. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> 14-23. </pages>
Reference-contexts: The advantage of this approach is that results on evaluation and proof systems automatically lift to richer languages; the disadvantage is a certain weakness of the proof systems. We believe that recent work by Moggi <ref> [17] </ref> on the computational -calculus|motivated by similar concerns|and our own work are the correct starting point for developing modular proof systems for large, powerful languages.
Reference: 18. <author> Plotkin, G.D. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theor. Comput. Sci. </journal> <volume> 1, </volume> <year> 1975, </year> <pages> 125-159. </pages>
Reference-contexts: In two previous papers [8, 9], we have shown that there are conservative extensions of Plotkin's v -calculus <ref> [18] </ref> for such programming languages, and that it is possible to reason about programs in extended functional languages in an equational style. The main difference between the simple lambda-calculi and its extended versions is a distinction between two classes of equations: equations for ordinary expressions and equations for whole programs. <p> Still, the calculi satisfy relatively simple variants of the Church-Rosser and Standardization properties. Most importantly, they satisfy most of Plotkin's <ref> [18] </ref> criteria for a correspondence between a programming language and a reduction-based calculus: (1) the standard derivations of the calculi yield the same value for a program as the operational semantics, and (2) a subset of the calculi equations for ordinary expressions are operationally sound. <p> The fifth section describes the merger of the two theories. Finally we discuss related work and some implications of our work for an alternative denotational semantics for extended functional languages. 2 2 The -value-calculus The expression language fl of the -calculus and the v -calculus <ref> [2, 3, 18] </ref> is the union of a set of values and expression juxtapositions: e ::= v j (e e): The set of values is the collection of basic constants (b 2 BConsts) and functional constants (f 2 FConsts), variables (x 2 Vars) and -abstractions: v ::= b j f j <p> An important parameter of the language definition is the set of constants and its interpretation. Following Plotkin <ref> [18] </ref>, we assume that the behavior of constants is specified by a partial function from functional and basic constants to closed values: ffi : FConsts fi BConsts ! Values 0 : In the mid-60's, Landin [11, 12] illustrated in a series of papers that fl is an interesting and powerful programming <p> Plotkin <ref> [18] </ref> provided the answer by defining the v -calculus, which matches the evaluation function eval SCED , and by providing a modified SECD-machine, which implements the -calculus correctly in the above sense of a Landin-style 3 interpreter. <p> Plotkin <ref> [18] </ref> showed that the v -calculus is sound with respect to operational equivalence. Theorem 2.8 (Plotkin) If v ` e = e 0 then e ' v e 0 . The inverse direction does not hold.
Reference: 19. <editor> Rees, J. and W. Clinger (Eds.). </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices 21(12), </journal> <year> 1986, </year> <pages> 37-79. </pages>
Reference-contexts: 1 The syntactic theories of control and state Most -calculus-based programming languages provide imperative programming facilities such as assignment statements, exceptions, and continuations. Typical examples are ML [16], Scheme <ref> [19] </ref>, and Common Lisp [20]. While these additions add expressive power and increase the efficiency of programs, they also appear to invalidate the simple reduction rules and equational reasoning of the -calculus that make functional programming so appealing. <p> A continuation has the same first-class status as a -abstraction; upon invocation, 6 it discards the control context of the application and resumes the abstracted control context with its argument. This notion of control abstraction is derived from the treatment of continuations in the programming language Scheme <ref> [19] </ref>. However, although the continuation created by a C-application acts just like a continuation created by the Scheme continuation constructor call/cc, a C-application differs from a call/cc application in that the former aborts the current control context, whereas the latter leaves the current control context intact. <p> It can evaluate programs (4.8); it is consistent (4.9); it has standard reduction sequences whose standard reduction relation is an evaluation mechanism (4.12); and it is sound (4.13). Finally, it also extends the old theory (4.5). 26 Note: The nature of variables From Scheme's <ref> [19, 21] </ref> practical point of view, the new theory only contains one disturbing element, namely, the partitioning of the variable set into binding and assignable variables. The reason for this separation is the desire to use variables as values as in v .
Reference: 20. <author> Steele, G.L., Jr. </author> <title> Common Lisp|The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: 1 The syntactic theories of control and state Most -calculus-based programming languages provide imperative programming facilities such as assignment statements, exceptions, and continuations. Typical examples are ML [16], Scheme [19], and Common Lisp <ref> [20] </ref>. While these additions add expressive power and increase the efficiency of programs, they also appear to invalidate the simple reduction rules and equational reasoning of the -calculus that make functional programming so appealing.
Reference: 21. <author> Sussman, G.J. and G.L. Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Memo 349, </type> <institution> MIT AI Lab, </institution> <year> 1975. </year>
Reference-contexts: It can evaluate programs (4.8); it is consistent (4.9); it has standard reduction sequences whose standard reduction relation is an evaluation mechanism (4.12); and it is sound (4.13). Finally, it also extends the old theory (4.5). 26 Note: The nature of variables From Scheme's <ref> [19, 21] </ref> practical point of view, the new theory only contains one disturbing element, namely, the partitioning of the variable set into binding and assignable variables. The reason for this separation is the desire to use variables as values as in v .
Reference: 22. <author> Talcott, C. Rum: </author> <title> An intensional theory function and control abstractions. </title> <booktitle> In Proc. 1987 Workshop on Foundations of Logic and Functional Programming. Springer Lecture Notes 306, </booktitle> <year> 1988. </year>
Reference-contexts: Over the past few years, they have developed equational theories for a first-order version of Lisp with destructive cell operations [13], for a fl C - like language on control <ref> [22, 23] </ref>, and, most recently, for a higher-order imperative version of Lisp without control abstractions [14]. For a fragment of first-order destructive Lisp without arithmetic and recursion, they have also shown that it is possible to obtain a complete theory [15].
Reference: 23. <author> Talcott, C. </author> <title> The Essence of Rum|A Theory of the Intensional and Extensional Aspects of Lisp-type Computation. </title> <type> Ph.D. dissertation, </type> <institution> Stanford University, </institution> <year> 1985. </year> <month> 34 </month>
Reference-contexts: Over the past few years, they have developed equational theories for a first-order version of Lisp with destructive cell operations [13], for a fl C - like language on control <ref> [22, 23] </ref>, and, most recently, for a higher-order imperative version of Lisp without control abstractions [14]. For a fragment of first-order destructive Lisp without arithmetic and recursion, they have also shown that it is possible to obtain a complete theory [15].
References-found: 23

