URL: ftp://ftp.cse.unsw.edu.au/pub/doc/papers/UNSW/9302.ps.Z
Refering-URL: http://www.cse.unsw.edu.au/school/research/tr.html
Root-URL: http://www.cse.unsw.edu.au
Title: Distributed Single Address-Space Operating System Supporting Persistence  
Author: Gernot Heiser, Kevin Elphinstone, Stephen Russell, Graham R. Hellestrand 
Affiliation: SCHOOL OF COMPUTER SCIENCE AND ENGINEERING THE UNIVERSITY OF NEW SOUTH WALES  
Note: A  
Abstract: SCS&E Report 9302 March, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Atkinson, P. Bailey, K. Chisholm, P. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26 </volume> <pages> 360-5, </pages> <year> 1983. </year>
Reference-contexts: This is due to the persistent system (PS) relieving the application programmer from the burden of having to flatten data structures for permanent storage which, besides the overhead it introduces, eliminates all the protection normally provided by types <ref> [1] </ref>. The major drawback of persistence is that it is hard to integrate into traditional operating systems (OS). The main reason for this is the fact that persistent objects in a traditional OS tend to change their address during their lifetime.
Reference: [2] <author> R. Morrison, A. L. Brown, R. Conner, and A. Dearle. </author> <title> Napier88 reference manual. Persistent Programming Research Report PPRR-77-89, </title> <institution> Universities of Glasgow and St. Andrews, </institution> <year> 1989. </year>
Reference-contexts: The alternative solution requires imposing restrictions on the structure of (persistent) objects, so that the system is able to find and traverse all inter-object references (as in Napier88 <ref> [2] </ref>). While it is possible in such a PS to free the application program from the need to flatten file structures before storing them on disk, the flattening still needs to be done, but now by the (run time) system.
Reference: [3] <institution> MIPS Computer Systems, Inc., Sunnyvale, CA. </institution> <note> MIPS R4000 Microprocessor User's Manual, 1st edition, </note> <year> 1991. </year>
Reference-contexts: Until about two years ago, standard computer architectures were limited to 32-bit addresses. This was hardly enough for the memory requirements of single processes. To accommodate multiple processes, each process had to be given its own private address-space. The recent advent of 64-bit architectures (MIPS R4000 <ref> [3] </ref>, DEC Alpha [4]) has completely changed the situation.
Reference: [4] <institution> Digital Equipment Corp., Maynard, MA. Alpha Architecture Handbook, </institution> <year> 1992. </year> <month> 12 </month>
Reference-contexts: Until about two years ago, standard computer architectures were limited to 32-bit addresses. This was hardly enough for the memory requirements of single processes. To accommodate multiple processes, each process had to be given its own private address-space. The recent advent of 64-bit architectures (MIPS R4000 [3], DEC Alpha <ref> [4] </ref>) has completely changed the situation.
Reference: [5] <author> S. Russell, A. Skea, K. Elphinstone, G. Heiser, K. Burston, I. Gorton, and G. Hellestrand. </author> <title> Distribution + persistence = global virtual memory. </title> <editor> In L.-F. Cabrera and E. Jul, editors, </editor> <booktitle> International Workshop on Object Orientation in Operating Systems, </booktitle> <volume> volume 2, </volume> <pages> pages 96-99, </pages> <address> Dourdan, France, 1992. </address> <publisher> IEEE. </publisher>
Reference-contexts: In a SAOS it becomes possible to provide persistence in a clean and elegant way: the requirement of flattening data structures, including the associated overheads in code size and redundant copying, vanishes completely <ref> [5] </ref>. In this paper we present a global virtual memory system (GVMS) featuring a flat, all-encompassing single address-space in which all objects are persistent and potentially visible to all processes. There are no system-enforced limits to sharing, which happens simply by passing around addresses.
Reference: [6] <author> J. Rosenberg and D. Abramson. </author> <title> MONADS-PCa capability-based workstation to support software engineering. </title> <booktitle> In Proceedings of the Hawaii International Conference on System Sciences, </booktitle> <volume> volume 18, </volume> <pages> pages 222-31. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: The system is (almost) purely a software approach, as it will run on standard hardware, possibly augmented by some add-on components to enhance efficiency. 1 The advantage of combining persistence with a single address-space was recognised a number of years ago by the MONADS group <ref> [6, 7] </ref>. MONADS features a special architecture designed to support a large address-space. Virtual memory in MONADS is structured to provide hardware support for modularisation and data encapsulation. Sharing is supported by making all modules globally visible, and system protected capabilities are used to provide protection.
Reference: [7] <author> J. Rosenberg and J. L. Keedy. </author> <title> Object management and addressing in the MONADS architecture. </title> <booktitle> In International Workshop on Persistent Object Systems, </booktitle> <volume> volume 2, </volume> <pages> Appin, </pages> <address> Scotland, 1987. </address> <publisher> IEEE. </publisher>
Reference-contexts: The system is (almost) purely a software approach, as it will run on standard hardware, possibly augmented by some add-on components to enhance efficiency. 1 The advantage of combining persistence with a single address-space was recognised a number of years ago by the MONADS group <ref> [6, 7] </ref>. MONADS features a special architecture designed to support a large address-space. Virtual memory in MONADS is structured to provide hardware support for modularisation and data encapsulation. Sharing is supported by making all modules globally visible, and system protected capabilities are used to provide protection.
Reference: [8] <author> J. S. Chase, H. M. Levy, M. Baker-Harvey, and E. D. Lazowska. Opal: </author> <title> A single address space system for 64-bit architectures. </title> <booktitle> In Workshop on Workstation Operating Systems [25], </booktitle> <pages> pages 80-85. </pages>
Reference-contexts: However, MONADS' dependence on specialised hardware has made it very difficult to let it profit from the rapid advances in computer architecture, as adapting MONADS to state-of-the-art microprocessors is an expensive and time-consuming task. More recently, Chase et al. <ref> [8] </ref> have also recognised the advantages of a large, single address-space. Their approach is similar to ours.
Reference: [9] <author> J. B. Carter, A. L. Cox, D. B. Johnson, and W. Zwaenepoel. </author> <title> Distributed operating systems based on a protected global virtual address space. </title> <booktitle> In Workshop on Workstation Operating Systems [25], </booktitle> <pages> pages 75-9. </pages>
Reference-contexts: It is not clear how far these issues have been researched at all. Another SAOS has been proposed by Carter et al. <ref> [9] </ref>. That project is also still in a conceptual stage and too little detail has been published to contrast their approach from ours. However, these projects show that the recent progress in computer architecture is leading to a new approach in operating systems design.
Reference: [10] <author> M. Anderson, R. Pose, and C. Wallace. </author> <title> A password-capability system. </title> <journal> The Computer Journal, </journal> <volume> 29(1) </volume> <pages> 1-8, </pages> <year> 1986. </year>
Reference-contexts: It is, of course, important to provide protection of objects against access by unauthorised processes. The protection system is based on password capabilities <ref> [10] </ref>, which allows user processes to deal with capabilities as with simple addresses. On the first attempt to use an object, the system validates the process' permission to access the object by comparing the object's password (s) against capabilities possessed by the process.
Reference: [11] <author> J. Vochteloo, S. Russell, and G. Heiser. </author> <title> Capability based protection in a persistent global virtual memory system. </title> <institution> School of Computer Science and Engineering Report 9303, University of NSW, Kensington, NSW, Australia, </institution> <year> 2033, </year> <month> March </month> <year> 1993. </year>
Reference-contexts: Implicit presentation of capabilities is facilitated by a system-maintained data structure containing capabilities. The capabilities themselves are, however, not system objects and can be passed around freely. Mechanisms for temporarily changing the protection domain (similar to UNIX set-uid) are provided. Details of the protection system are presented in <ref> [11] </ref>. <p> MONADS never reuses memory, which has the advantage that object addresses are truly unique identifiers for all times. A 64-bit address space is large enough to make this scheme possible. However, our password capability scheme <ref> [11] </ref> removes the need for strict uniqueness, because new passwords are assigned each time a virtual address is reused. Furthermore, simulations show that reusing memory leads to significantly smaller page tables [18]. These results make reuse of deallocated memory attractive. <p> As every object must start on a page boundary, this would result in poor memory use. An excess of small objects will also have a negative impact on the performance of the protection system <ref> [11] </ref>. This will produce a performance penalty for processes using many such objects, which will hopefully discourage their use. In particular it would be very unwise to create a separate object for each item that would traditionally be malloced on the process' heap.
Reference: [12] <author> S. Zhou, M. Stumm, K. Li, and D. Wortman. </author> <title> Heterogeneous distributed shared memory. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3 </volume> <pages> 540-54, </pages> <year> 1992. </year>
Reference-contexts: Currently we do not plan to support heterogenous processing nodes as we do not consider heterogeneity support as essential to demonstrate the utility of our design. However, we believe that models of heterogeneity developed for related problems <ref> [12] </ref> can be adapted to work in the GVMS. Furthermore, our system is not meant to support parallel programming and hence is oriented towards different applications than the distributed shared memory projects [13].
Reference: [13] <author> B. Nitzberg and V. Lo. </author> <title> Distributed shared memory: A survey of issues and algorithms. </title> <journal> Computer, </journal> <volume> 24(8) </volume> <pages> 52-60, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: However, we believe that models of heterogeneity developed for related problems [12] can be adapted to work in the GVMS. Furthermore, our system is not meant to support parallel programming and hence is oriented towards different applications than the distributed shared memory projects <ref> [13] </ref>. We instead aim to support a workstation-like environment of laboratory to building scale (hundreds to thousands of processing nodes).
Reference: [14] <author> J. Ousterhout. </author> <title> Why aren't operating systems getting faster as fast as hardware? In USENIX Conference, </title> <address> pages 247-56, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The translation information in the TLB no longer needs to be invalidated each time processes are switched. Similarly, the contents of a virtual cache can also be retained. These changes should significantly reduce process switching costs, which are a serious bottleneck in traditional operating systems <ref> [14, 15, 16] </ref>. Recent work on hardware support for protection in object-oriented systems [17] indicates that a device like the PLB might be possible. 3.5 Page Location If access to a page of unknown location is attempted, the kernel sends a broadcast message to all nodes on the network.
Reference: [15] <author> J. C. Mogul and A. Borg. </author> <title> The effect of context switches on cache performance. </title> <booktitle> In Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <volume> volume 4, </volume> <pages> pages 75-84, </pages> <year> 1991. </year>
Reference-contexts: The translation information in the TLB no longer needs to be invalidated each time processes are switched. Similarly, the contents of a virtual cache can also be retained. These changes should significantly reduce process switching costs, which are a serious bottleneck in traditional operating systems <ref> [14, 15, 16] </ref>. Recent work on hardware support for protection in object-oriented systems [17] indicates that a device like the PLB might be possible. 3.5 Page Location If access to a page of unknown location is attempted, the kernel sends a broadcast message to all nodes on the network.
Reference: [16] <author> T. E. Anderson, H. M. Levy, B. N. Bershad, and E. D. Lazowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <volume> volume 4, </volume> <pages> pages 108-21, </pages> <year> 1991. </year>
Reference-contexts: The translation information in the TLB no longer needs to be invalidated each time processes are switched. Similarly, the contents of a virtual cache can also be retained. These changes should significantly reduce process switching costs, which are a serious bottleneck in traditional operating systems <ref> [14, 15, 16] </ref>. Recent work on hardware support for protection in object-oriented systems [17] indicates that a device like the PLB might be possible. 3.5 Page Location If access to a page of unknown location is attempted, the kernel sends a broadcast message to all nodes on the network.
Reference: [17] <author> J. Kaiser and K. Czaja. ACOM: </author> <title> An access control monitor providing protection in persistent object-oriented systems. </title> <booktitle> In International Workshop on Persistent Object Systems, </booktitle> <volume> volume 5, </volume> <pages> pages 359-73, </pages> <address> Pisa, Italy, </address> <year> 1992. </year> <note> Morgan-Kauffman. 13 </note>
Reference-contexts: Similarly, the contents of a virtual cache can also be retained. These changes should significantly reduce process switching costs, which are a serious bottleneck in traditional operating systems [14, 15, 16]. Recent work on hardware support for protection in object-oriented systems <ref> [17] </ref> indicates that a device like the PLB might be possible. 3.5 Page Location If access to a page of unknown location is attempted, the kernel sends a broadcast message to all nodes on the network. If the page is allocated its owner will reply to that broadcast.
Reference: [18] <author> E. Kong. </author> <title> Name management and page table organisation for a distributed global vir-tual memory system. </title> <type> BSc (Hons) thesis, </type> <institution> School of Computer Science and Engineering, University of NSW, Kensington, NSW, Australia, </institution> <year> 2033, 1992. </year>
Reference-contexts: A 64-bit address space is large enough to make this scheme possible. However, our password capability scheme [11] removes the need for strict uniqueness, because new passwords are assigned each time a virtual address is reused. Furthermore, simulations show that reusing memory leads to significantly smaller page tables <ref> [18] </ref>. These results make reuse of deallocated memory attractive. The simulations also show that the multi-level page table scheme is feasible. Typically, of the order of 2% of allocated memory is used for page tables, which seems entirely reasonable.
Reference: [19] <author> J. Ousterhout, H. Da Costa, D. Harrison, J. Kunze, M. Kupfer, and J. Thompson. </author> <title> A trace-driven analysis of the UNIX 4.2 BSD file system. </title> <booktitle> In ACM Symposium on OS Principles, </booktitle> <volume> volume 10, </volume> <pages> pages 15-24, </pages> <year> 1985. </year>
Reference-contexts: It must be pointed out, however, that these simulations were based on trace-driven UNIX BSD4.2 file data <ref> [19] </ref>. Memory usage in a SAOS can be expected to differ somewhat from file usage in a traditional operating system. Hence one should not overestimate the predictive value of these simulations.
Reference: [20] <author> K. Elphinstone. </author> <title> Distributed systems and global naming. </title> <type> BE (Hons) thesis, </type> <institution> School of Electrical Engineering and Computer Science, University of NSW, Kensington, NSW, Australia, </institution> <year> 2033, 1990. </year>
Reference-contexts: Such a single node number could be 8 kept in the page table. Further study is required on this issue. Consistency of the page ownership information is essential for the operation of the system. We therefore use a reliable protocol <ref> [20] </ref>, based on two phase distributed commit [21], for transfer of page ownership. The protocol assures that page ownership cannot be lost or duplicated if messages are lost or duplicated due to an unreliable network or in the case of a node crash.
Reference: [21] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Such a single node number could be 8 kept in the page table. Further study is required on this issue. Consistency of the page ownership information is essential for the operation of the system. We therefore use a reliable protocol [20], based on two phase distributed commit <ref> [21] </ref>, for transfer of page ownership. The protocol assures that page ownership cannot be lost or duplicated if messages are lost or duplicated due to an unreliable network or in the case of a node crash. Error detection mechanisms in the network interface are expected to remove corrupted messages.
Reference: [22] <author> J. K. Bennett, J. B. Carter, and W. Zwaenepoel. Munin: </author> <title> Distributed shared memory based on type-specific memory coherence. </title> <booktitle> In Conference on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 168-176. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Some special kernel support for distributed semaphores is therefore likely to be required. For some applications, our coherency model is unnecessarily strict and introduces significant overhead. We will therefore investigate weaker consistency models based on typed objects <ref> [22] </ref>. 9 6 Persistent Object Management 6.1 Transient and Persistent Objects As every memory object created in the system has a globally unique address, which is independent of the process that created the object, every object is automatically persistent.
Reference: [23] <author> C. G. Gray and D. R. Cheriton. Leases: </author> <title> An efficient fault-tolerant mechanism for distributed file cache consistency. </title> <booktitle> In ACM Symposium on OS Principles, </booktitle> <volume> volume 12, </volume> <pages> pages 202-10, </pages> <year> 1989. </year>
Reference-contexts: Hence it makes sense to clean up backing store rather than virtual address-space. The precise method to use is still subject to further investigation, but will probably be based on leasing <ref> [23] </ref> or other economic models [24]. 6.4 Compilation Issues The switch to a single address-space will have several effects on the operation of language processors. If it is not possible to generate completely position-independent code, then it will be necessary to assemble the code in situ.
Reference: [24] <author> A. S. Tanenbaum and S. Mullender. </author> <title> The design of a capability-based distributed operating system. </title> <type> Technical Report IR-88, </type> <institution> Vrije Universiteit, </institution> <month> November </month> <year> 1984. </year>
Reference-contexts: Hence it makes sense to clean up backing store rather than virtual address-space. The precise method to use is still subject to further investigation, but will probably be based on leasing [23] or other economic models <ref> [24] </ref>. 6.4 Compilation Issues The switch to a single address-space will have several effects on the operation of language processors. If it is not possible to generate completely position-independent code, then it will be necessary to assemble the code in situ.
Reference: [25] <editor> IEEE. </editor> <booktitle> Workshop on Workstation Operating Systems, volume 3, </booktitle> <address> Key Biscayne, Florida, </address> <year> 1992. </year>
References-found: 25

