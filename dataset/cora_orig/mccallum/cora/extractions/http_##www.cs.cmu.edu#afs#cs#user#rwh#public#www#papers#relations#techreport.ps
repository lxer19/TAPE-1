URL: http://www.cs.cmu.edu/afs/cs/user/rwh/public/www/papers/relations/techreport.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/rwh/public/www/papers.html
Root-URL: 
Title: Relational Interpretations of Recursive Types in an Operational Setting  
Author: Lars Birkedal Robert Harper 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: April 24, 1998  
Pubnum: CMU-CS-98-125  
Abstract: Submitted for publication to Information and Computation. A sum mary of this paper appeared in TACS '97. This research was supported in part by the Isaac Newton Institute for Mathematical Sciences at Cambridge University. Robert Harper is supported by the National Science Foundation under Grant No. CCR-95-2674. Lars Birkedal is supported in part by the Danish National Research Council and in part by the National Science Foundation under Grant No. CCR-9409997. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <address> IV(3):1-55, July-Sep. </address> <year> 1991. </year>
Reference-contexts: Using our construction we further give a relational proof of correctness of cps conversion, generalizing Reynolds' proof to the typed setting. The proof of correctness for the cps transformation that we give here does not appear to extend easily to a language with control operators such as call/cc <ref> [1, 10] </ref>.
Reference: [2] <author> B. A. Davey and H. A. Priestley. </author> <title> Introduction to Lattices and Order. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Proof By a standard lattice-theory theorem (see, e.g., <ref> [2, Theorem 2.16 (ii)] </ref>) it suffices to show that the greatest lower bound, V S, exists for every subset of Radm t . Thus let S be an arbitrary subset of Radm t . Define V def T We then have to show 1. S 2 Radm t 2.
Reference: [3] <author> Andrzej Filinski. </author> <title> Controlling Effects. </title> <institution> CMU-CS-96-119, School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: The treatment of cps conversion given here invites generalization to an arbitrary syntactically-definable monad for the language. Filinski's dissertation <ref> [3] </ref> is a first step towards a general theory of representation of computational effects. Filinski's work suggests that one could give a fairly general correctness proof along the lines suggested here for a wide variety of definable effects.
Reference: [4] <author> Michael J. Fischer. </author> <title> Lambda-calculus schemata. </title> <journal> LISP and Symbolic Computation, </journal> 6(3/4):259-288, November 1993. 
Reference-contexts: We illustrate the use of logical equivalence with two small examples based on similar examples given by Pitts [16]. Second, we give a relational proof of correctness of the continuation-passing (cps) transform introduced by Fischer <ref> [4] </ref> and Plotkin [18] and studied by Reynolds [20]. The proof relies on the construction of a relational interpretation of L that establishes a correspondence between the evaluation of a program and its continuation-passing transform.
Reference: [5] <author> Peter Freyd. </author> <title> Algebraically complete categories. </title> <editor> In A. Carboni, M. C. Pedicchio, and G. Rosolini, editors, </editor> <booktitle> Category Theory. Proceedings, Como 1990, volume 1488 of Lecture Notes in Mathematics, </booktitle> <pages> pages 95-104. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The latter question was recently addressed by Pitts [17] who showed that Freyd's universal characterization of the solution of a domain equation by the minimal invariant property <ref> [6, 5, 7] </ref> is sufficient to validate the construction of a wide class of relational interpretations of recursive types.
Reference: [6] <author> Peter Freyd. </author> <title> Recursive types reduced to inductive types. </title> <booktitle> In Proceedings of the fifth IEEE Conference on Logic in Computer Science, </booktitle> <pages> pages 498-507, </pages> <year> 1990. </year>
Reference-contexts: The latter question was recently addressed by Pitts [17] who showed that Freyd's universal characterization of the solution of a domain equation by the minimal invariant property <ref> [6, 5, 7] </ref> is sufficient to validate the construction of a wide class of relational interpretations of recursive types.
Reference: [7] <author> Peter Freyd. </author> <title> Remarks on algebraically compact categories. </title> <editor> In M. P. Fourman, P.T. Johnstone, and A. M. Pitts, editors, </editor> <booktitle> Applications of Categories in Computer Science. Proceedings of the LMS Symposium, Durham 1991, volume 177 of London Mathematical Society Lecture Note Series, </booktitle> <pages> pages 95-106. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: The latter question was recently addressed by Pitts [17] who showed that Freyd's universal characterization of the solution of a domain equation by the minimal invariant property <ref> [6, 5, 7] </ref> is sufficient to validate the construction of a wide class of relational interpretations of recursive types.
Reference: [8] <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieure. </title> <type> PhD thesis, </type> <institution> Uni-versite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: In the case of impredicative polymorphism the method of candidates introduced by Girard <ref> [8] </ref> may be used to construct a relational interpretation. For recursive types the usual approach is to pass to a domain-theoretic model of the language and to exploit the structure of the model to build the required system of relations.
Reference: [9] <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages. Structures and Techniques. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: This is opposed to introducing new labelled expressions and new notions of reduction for labelled expressions as, e.g., done by Gunter <ref> [9] </ref>. We will only consider contexts involving parameters of type t 1 * t 2 . We write Cf ~ pg for such a context whose parameters are included in the list ~ p (note that we do not required that all the parameters in ~ p occur in C).
Reference: [10] <author> Robert Harper, Bruce Duba, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 465-484, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Using our construction we further give a relational proof of correctness of cps conversion, generalizing Reynolds' proof to the typed setting. The proof of correctness for the cps transformation that we give here does not appear to extend easily to a language with control operators such as call/cc <ref> [1, 10] </ref>.
Reference: [11] <author> Ian A. Mason, Scott F. Smith, and Carolyn L. Talcott. </author> <title> From operational semantics to domain theory. </title> <journal> Information and Computation, </journal> <note> 1995. To Appear. 71 </note>
Reference-contexts: This suggests that our approach may be seen as a particular instance of the standard construction. However, as Mason, Smith, and Talcott have shown <ref> [11] </ref>, the interpretation induced by taking contextual equivalence classes does not yield a domain in the conventional sense since, for example, not all chains have least upper bounds. Thus the operational approach to interpreting recursive types as relations differs fundamentally from the denotational method. <p> We make no restrictions on the occurrence of the recursively-defined type in its definition | both positive and negative occurrences are permitted. The proof of syntactic minimal invariance for L relies on a characterization of contextual equivalence given by Mason, Smith, and Talcott <ref> [11] </ref>, called experimental equivalence. The primary interest in this notion of equivalence is that it coincides with contextual equivalence and supports a relatively straightforward proof of syntactic minimal invariance. Other, equivalent, characterizations are also available, but these do not appear to significantly simplify the argument. <p> Then in Section 3 we define the notion of experimental equivalence, with which we shall be working in the remainder of the paper. The main result of this section is the proof of syntactic minimal invariance based on a technique introduced by Mason, Talcott, and Smith <ref> [11] </ref>. In Section 4 we define a universe of admissible relations over contextual equivalence classes of closed expressions. We also define relational operators corresponding to the type constructors of the language and show that they preserve admissibility. <p> This theorem (Theorem 3.34) is reminiscent of the CIU Theorem of Mason, Smith and Talcott <ref> [11] </ref>. <p> As explained by Mason, Smith, and Talcott <ref> [11] </ref> arbitrary chains of terms do not always have a least upper bound. This leads Mason, Smith, and Talcott to develop a notion of ordering between sets of terms, for which arbitrary chains do have a least upper bound, [11, Lemma 4.31]. <p> As explained by Mason, Smith, and Talcott [11] arbitrary chains of terms do not always have a least upper bound. This leads Mason, Smith, and Talcott to develop a notion of ordering between sets of terms, for which arbitrary chains do have a least upper bound, <ref> [11, Lemma 4.31] </ref>. Here, however, we shall only ever consider chains of the form CfF 0 g CfF 1 g CfF 2 g for some given closed fix-term F and thus the chains, which we shall consider, will always have a least upper bound. <p> Hence we do not need to develop more complicated notions of approximation a la the set ordering developed by Mason, Smith, and Talcott <ref> [11] </ref>. 24 3.2 Syntactic Projections In this section we introduce syntactic projection terms which are the syntactic counterpart of the semantic projection functions known from domain theory. These syntactic projections will be used in the construction of the desired relations in Section 5. Let be a variable. <p> We shall employ an idea of Mason, Smith, and Talcott <ref> [11] </ref>. We now proceed to show idempotency of 1 t and 1 . The strategy is to show lemmas for i t and i and then use compactness of evaluation to get the desired results. <p> The proof of syntactic minimal invariance is a generalization of methods used by Mason, Smith, and Talcott <ref> [11] </ref> to a typed language with a recursive type.
Reference: [12] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The target language, L fl , is the variant of L obtained by replacing the single recursive type by another recursive type fl obtained from by a transformation on types similar to that given by Meyer and Wand <ref> [12] </ref>. We let Type denote the set of type expressions of L , that is Type = Type. The set of target type expressions, denoted Type fl , is defined exactly as Type, but with fl for . <p> Several authors have considered the correctness of the cps transformation. Reynolds [20] gives a proof for an untyped functional language by working over a domain model given by an inverse limit construction. Meyer & Wand <ref> [12] </ref> give a somewhat different proof for the simply typed -calculus (without a recursive type).
Reference: [13] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: We study the construction of relational interpretations for an ML-like language, L, with recursive functions and one recursive type. The operational semantics of the language specifies a call-by-value, or "eager", evaluation strategy, as in Standard ML <ref> [13] </ref>. We make no restrictions on the occurrence of the recursively-defined type in its definition | both positive and negative occurrences are permitted. The proof of syntactic minimal invariance for L relies on a characterization of contextual equivalence given by Mason, Smith, and Talcott [11], called experimental equivalence.
Reference: [14] <author> John C. Mitchell. </author> <title> Type systems for programming languages. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. </volume> <editor> B, </editor> <title> Formal Models and Semantics, </title> <booktitle> chapter 8, </booktitle> <pages> pages 366-458. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction The interpretation of types by relations is a fundamental technique in the study of type systems (see, for example, Mitchell's survey <ref> [14] </ref> and monograph [15] for examples and references to the literature). The general idea is to associate to each type a relation over a suitable value space in such a way that well-typed terms are related appropriately by the interpretation.
Reference: [15] <author> John C. Mitchell. </author> <booktitle> Foundations for Programming Languages. Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction The interpretation of types by relations is a fundamental technique in the study of type systems (see, for example, Mitchell's survey [14] and monograph <ref> [15] </ref> for examples and references to the literature). The general idea is to associate to each type a relation over a suitable value space in such a way that well-typed terms are related appropriately by the interpretation.
Reference: [16] <author> Andrew M. Pitts. </author> <title> Operationally-based theories of program equivalence. </title> <booktitle> In In Proc. of Summer School on Semantics and Logics of Computation. </booktitle> <institution> ESPRIT CLiCS-II. University of Cambridge. Isaac Newton Institute for Mathematical Sciences., </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: First, we derive another characterization of contextual equivalence, called logical equivalence, that validates induction and coinduction principles for reasoning about values of the recursive type. We illustrate the use of logical equivalence with two small examples based on similar examples given by Pitts <ref> [16] </ref>. Second, we give a relational proof of correctness of the continuation-passing (cps) transform introduced by Fischer [4] and Plotkin [18] and studied by Reynolds [20]. <p> Finally, we show that to fill a context is a continous operation with respect to the approximation pre-order. We shall only be concerned with closed fix-terms, as this suffices for our purposes. Our development of compactness of evaluation follows the approach of Pitts <ref> [16, Section 5] </ref> quite closely but there are some technical differences due to the fact that we use a reduction semantics rather than a natural semantics as employed by Pitts. <p> For the finite unrollings of 1 , one proceeds as in the proofs of Lemmas 5.12 and 5.13. ut We now show how to specialize Theorem 6.6 to a coinduction principle and give some examples of how to use it. More examples of the kind found in <ref> [16] </ref> may also be treated this way. <p> Pitts <ref> [16] </ref> also derives a coinduction principle for infinite streams in his theory of program equivalence based on bisimulation. Pitts' coinduction principle corresponds closely to the one we have obtained here by specializing the recursive type to the type of streams. <p> Pitts has emphasized the importance of a characterization of contextual equivalence for a language with streams as a bisimulation relation constructed as the maximal fixed point of a monotone operator on relations <ref> [16] </ref>. To apply this framework to specific examples Pitts relies on a lemma characterizing contextual equivalence of values of stream type. In our setting this lemma arises as a simple consequence of the definition of logical equivalence relation for a recursive type, as outlined in Section 6. <p> Using this construction we give a relational characterization of experimental and contextual 69 equivalence and derive a coinduction principle for establishing contextual equivalence. Taking the recursive type to be the type of infinite streams, the coinduction principle specializes to a principle corresponding to the one used by Pitts <ref> [16] </ref> in his theory of program equivalence based on bisimula-tion. Using our construction we further give a relational proof of correctness of cps conversion, generalizing Reynolds' proof to the typed setting.
Reference: [17] <author> Andrew M. Pitts. </author> <title> Relational properties of domains. </title> <journal> Information and Computation, </journal> <volume> 127(2) </volume> <pages> 66-90, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: A disadvantage of this approach is that one must also prove the correctness (adequacy) of the denotational semantics of the language, which is itself often established using a relational interpretation of types <ref> [19, 17] </ref>! Moreover, since the construction is carried out for a specific model of the language, it is not clear a priori to what extent the specific model affects the result. <p> The latter question was recently addressed by Pitts <ref> [17] </ref> who showed that Freyd's universal characterization of the solution of a domain equation by the minimal invariant property [6, 5, 7] is sufficient to validate the construction of a wide class of relational interpretations of recursive types. <p> The 1 term corresponds to the least fixed point fix (ffi) of the continuous function ffi (e) = iF (e; e)i 1 in <ref> [17, Definition 3.2] </ref>. We shall show that 1 is experimentally equivalent to the identity function (more precisely, the term x::x); this corresponds to the minimal invariant property in [17, Definition 3.2]. Example Assume t = 1 + . <p> 1 term corresponds to the least fixed point fix (ffi) of the continuous function ffi (e) = iF (e; e)i 1 in <ref> [17, Definition 3.2] </ref>. We shall show that 1 is experimentally equivalent to the identity function (more precisely, the term x::x); this corresponds to the minimal invariant property in [17, Definition 3.2]. Example Assume t = 1 + . Intuitively, our recursive type then corre sponds to the type of natural numbers. <p> By Lemma 3.68, also jej 7! fl fl, as required. ut We are now in a position to establish the following theorem, which we re fer to as the syntactic minimal invariant property by analogy to the domain theoretic work of Pitts <ref> [17] </ref>. Theorem 3.70 (Syntactic Minimal Invariance) ` 1 x::x : * Proof By Lemmas 3.50, 3.69, and 3.3. ut 37 3.3 Summary In this section we have defined a notion of experimental approximation and experimental equivalence between terms and established some basic equivalences of terms. <p> In the following we shall show how to construct relations over equivalence classes of terms (with respect to the operational equivalence). The properties established in this section are crucial to this construction, in particular, the syntactial minimal invariant property plays a central role in adapting Pitts' method <ref> [17] </ref> to our operational setting. 4 Relations In this and the following section we shall show how to construct a relational interpretation of types over an operational semantics. <p> To interpret the different type constructors we, of course, make use of the corresponding relational constructors defined in the previous section. Our construction follows along the lines of Pitts <ref> [17] </ref>. <p> One can also derive an induction principle but we shall not go into that here. These principle are derived in a manner analogously to the way in which Pitts <ref> [17] </ref> derives such principles. For reasons of space, we shall be less formal in our presentation of these reasoning principles than we are elsewhere. <p> The critical ingredient in the construction is Pitts's observation <ref> [17] </ref> that the existence of a relational interpretation can be reduced to minimal invariance, combined with the observation that this criterion can be stated and proved at a purely operational level.
Reference: [18] <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value, and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: We illustrate the use of logical equivalence with two small examples based on similar examples given by Pitts [16]. Second, we give a relational proof of correctness of the continuation-passing (cps) transform introduced by Fischer [4] and Plotkin <ref> [18] </ref> and studied by Reynolds [20]. The proof relies on the construction of a relational interpretation of L that establishes a correspondence between the evaluation of a program and its continuation-passing transform.
Reference: [19] <author> Gordon Plotkin. </author> <title> Domains. </title> <institution> Department of Computer Science. University of Edinburgh, </institution> <year> 1983. </year>
Reference-contexts: A disadvantage of this approach is that one must also prove the correctness (adequacy) of the denotational semantics of the language, which is itself often established using a relational interpretation of types <ref> [19, 17] </ref>! Moreover, since the construction is carried out for a specific model of the language, it is not clear a priori to what extent the specific model affects the result.
Reference: [20] <author> John C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <editor> In J. Loeckx, editor, </editor> <booktitle> Proceedings of the Second Colloquium on Automata, Languages and Programming, Saarbrucken, volume 174 of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: The denotational approach has been successfully used for a number of problems, including Reynolds' proof of correctness of the continuation-passing transformation used in some compilers for functional languages <ref> [20] </ref>. <p> We illustrate the use of logical equivalence with two small examples based on similar examples given by Pitts [16]. Second, we give a relational proof of correctness of the continuation-passing (cps) transform introduced by Fischer [4] and Plotkin [18] and studied by Reynolds <ref> [20] </ref>. The proof relies on the construction of a relational interpretation of L that establishes a correspondence between the evaluation of a program and its continuation-passing transform. This generalizes Reynolds' result [20] to the case of a typed language with an arbitrary recursive type, while avoiding the need to consider a <p> proof of correctness of the continuation-passing (cps) transform introduced by Fischer [4] and Plotkin [18] and studied by Reynolds <ref> [20] </ref>. The proof relies on the construction of a relational interpretation of L that establishes a correspondence between the evaluation of a program and its continuation-passing transform. This generalizes Reynolds' result [20] to the case of a typed language with an arbitrary recursive type, while avoiding the need to consider a denotational semantics for L. This paper is organized as follows. <p> In our setting this lemma arises as a simple consequence of the definition of logical equivalence relation for a recursive type, as outlined in Section 6. Several authors have considered the correctness of the cps transformation. Reynolds <ref> [20] </ref> gives a proof for an untyped functional language by working over a domain model given by an inverse limit construction. Meyer & Wand [12] give a somewhat different proof for the simply typed -calculus (without a recursive type).
References-found: 20

