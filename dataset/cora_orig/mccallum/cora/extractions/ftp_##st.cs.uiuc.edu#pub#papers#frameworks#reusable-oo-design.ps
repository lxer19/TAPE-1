URL: ftp://st.cs.uiuc.edu/pub/papers/frameworks/reusable-oo-design.ps
Refering-URL: http://st-www.cs.uiuc.edu/users/johnson/professional.html
Root-URL: http://www.cs.uiuc.edu
Title: Reusing Object-Oriented Designs  
Author: Ralph E. Johnson Vincent F. Russo 
Date: May 13, 1991  
Abstract: Please send us your comments about the paper. In particular, tell us what bores you, what mystifies you, and what you think is wrong. If you want to reference this paper, it is University of Illinois tech report UIUCDCS 91-1696. Abstract Reusing the products of the software development process is an important way to reduce software costs and to make programmers and designers more efficient. Object-oriented programming permits the reuse of design as well as programs. This paper describes two techniques for reusing design and how these reusable designs are developed. Abstract classes are reusable designs for components, while frameworks are reusable designs for entire applications or subsystems. These two techniques are related since frameworks almost always contain abstract classes. Although the most widely used frameworks are for user interfaces, this paper draws its examples from a framework for the virtual memory subsystem of an operating system.
Abstract-found: 1
Intro-found: 1
Reference: [AEL88] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time concurrent collection on stock multiprocessors. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <year> 1988. </year>
Reference-contexts: These include proposals for using address translation hardware for garbage collection <ref> [AEL88, BDS91, Sha87] </ref> and for distributed programming [LH86]. If a feature is normally expensive because it requires checking some condition regularly, it can often be made inexpensive by translating the condition into a protection or validity check that can be performed by the address translation unit. <p> Appel, Ellis and Li proposed a real-time garbage collection algorithm that is fairly efficient, does not require special hardware, does not impose many restrictions on the mutator 3 , and works well with multiprocessors <ref> [AEL88] </ref>. Earlier real-time garbage collection algorithms were either much less efficient 3 The mutator is the application program allocating new cells and modifying existing ones. 26 or required special hardware support, so this algorithm has attracted a lot of interest.
Reference: [AL91] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96|107, </pages> <year> 1991. </year>
Reference-contexts: Techniques that use address translation hardware have prompted interest in making virtual memory management systems more customizable <ref> [AL91] </ref>. Section 5 showed how the virtual memory framework can be customized using memory objects. Section 6 discussed the details of how the virtual memory framework is put together and showed how AddressTranslation makes the system portable. This section will describe several advanced applications of the Choices virtual memory framework.
Reference: [Bat88] <author> D.S. Batory. </author> <title> Concepts for a database system compiler. </title> <booktitle> Principles of Database Systems, </booktitle> <year> 1988. </year>
Reference-contexts: They have been applied to VLSI routing algorithms [Gos90], to structured drawing editors [VL89, Vli90], code optimization [JM91], and psychophysiological experiments [Foo88]. Frameworks do not even require an object-oriented programming language. The Genesis database system compiler is a framework for database management systems <ref> [Bat88, BBR*89] </ref> as well as a tool for specifying how ensembles are configured in the framework [BB91]. Genesis does not use an object-oriented language but rather a macro processor and conditional compilation to implement an object-oriented design in C.
Reference: [BB91] <author> D.S. Batory and J.R. Barnett. DaTE: </author> <title> The Genesis DBMS Software Layout Editor. </title> <type> Technical Report, </type> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <year> 1991. </year>
Reference-contexts: Frameworks do not even require an object-oriented programming language. The Genesis database system compiler is a framework for database management systems [Bat88, BBR*89] as well as a tool for specifying how ensembles are configured in the framework <ref> [BB91] </ref>. Genesis does not use an object-oriented language but rather a macro processor and conditional compilation to implement an object-oriented design in C. The important classes in a framework, such as Model, View, and Controller of Model/View/Controller, are usually abstract.
Reference: [BBR*89] <author> D.S. Batory, J.R. Barnett, J. Roy, B.C. Twichell, and J. Garza. </author> <title> Construction of file management systems from software components. </title> <booktitle> In Proceedings of COMPSAC 1989, </booktitle> <year> 1989. </year>
Reference-contexts: They have been applied to VLSI routing algorithms [Gos90], to structured drawing editors [VL89, Vli90], code optimization [JM91], and psychophysiological experiments [Foo88]. Frameworks do not even require an object-oriented programming language. The Genesis database system compiler is a framework for database management systems <ref> [Bat88, BBR*89] </ref> as well as a tool for specifying how ensembles are configured in the framework [BB91]. Genesis does not use an object-oriented language but rather a macro processor and conditional compilation to implement an object-oriented design in C. <p> Batory et. al. emphasize that the development of their framework took much longer than expected and attributed this to the difficulty of domain analysis <ref> [BBR*89] </ref>. Our experience supports theirs. The question remains: Why is iteration necessary? Clearly, a design is iterated only because its authors did not know how to do it right the first time.
Reference: [BDS91] <author> H. Boehm, A. Demers, and S. Shenker. </author> <title> Mostly Parallel Garbage Collection. </title> <year> 1991. </year>
Reference-contexts: These include proposals for using address translation hardware for garbage collection <ref> [AEL88, BDS91, Sha87] </ref> and for distributed programming [LH86]. If a feature is normally expensive because it requires checking some condition regularly, it can often be made inexpensive by translating the condition into a protection or validity check that can be performed by the address translation unit.
Reference: [BR87] <author> Ted J. Biggerstaff and Charles Richter. </author> <title> Reusability framework, assessment, and directions. </title> <journal> IEEE Software, </journal> <volume> 4(2), </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Experienced programmers reuse design. Therefore, a popular goal of software engineering is to develop tools and techniques to assist design reuse. The central problem with reusing design information is how to capture and express it <ref> [BR87] </ref>. Any design notation supports an abstraction that ignores some details of a problem and emphasizes others. This paper describes design techniques that emphasize objects and the interfaces between them. <p> All of these are important, though in the long run it is probably the analysis and design reuse that provide the biggest payoff <ref> [BR87] </ref>. 2.3 Choices Choices is an operating system framework developed at the University of Illinois at Urbana-Champaign [CRJ87]. Choices was designed using the object-oriented paradigm and is implemented in an object-oriented language (C++).
Reference: [BS88] <editor> Lubomir Bic and Alan C. Shaw. </editor> <booktitle> The Logical Design of Operating Systems. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1988. </year>
Reference-contexts: For the reader unfamiliar with virtual memory, this section will give a quick overview. Others may wish to skip this section. Those wishing more detail should refer to a suitable operating systems text <ref> [PS85, BS88, Tan87] </ref>. Most computers support the distinction between the memory referenced by a program and the physical (real) memory of the computer. Each program is given a logical address space in which to execute.
Reference: [Che88] <author> David R. Cheriton. </author> <title> The V Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: The Choices virtual memory model is similiar in design to that of other 14 Memory Objects Domain Domain Processes Process modern operating systems including Mach [RTY*87], CHORUS [RAN88], and V <ref> [Che88] </ref>. Figure 4 shows an application programmer's view of the Choices virtual memory system. Each domain has one or more processes that execute within it. A memory object can belong to any number of domains.
Reference: [CRJ87] <author> Roy H. Campbell, Vincent F. Russo, and Gary M. Johnston. </author> <title> The design of a multiprocessor operating system. </title> <booktitle> In Proceedings of the USENIX C++ Workshop, </booktitle> <year> 1987. </year>
Reference-contexts: All of these are important, though in the long run it is probably the analysis and design reuse that provide the biggest payoff [BR87]. 2.3 Choices Choices is an operating system framework developed at the University of Illinois at Urbana-Champaign <ref> [CRJ87] </ref>. Choices was designed using the object-oriented paradigm and is implemented in an object-oriented language (C++). Choices is composed of interlocking frameworks for * process management [RJC88], * virtual memory management [RC89], * file systems [MLRC88, MCRL89], and * networking [ZJ90]. <p> The most complex abstract algorithm in the virtual memory framework is the one for responding to page faults. A page fault occurs whenever the computer accesses an address that is not mapped by the page table. The page fault handler (an Exception <ref> [CRJ87] </ref>) will perform a repairFault operation on the current domain.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Polymorphism makes programs more reusable and reduces the number of different interfaces. The kind of polymorphism provided by object-oriented languages leads naturally to a subtype relationship between types <ref> [CW85] </ref>. Most object-oriented languages provide class inheritance. Class inheritance lets one class, a subclass, inherit all the attributes (i.e., the operations and state) of another class, the superclass. Inheritance can have many uses|code reuse, type checking, and categorizing components.
Reference: [Deu87] <author> L. Peter Deutsch. </author> <title> Levels of reuse in the Smalltalk-80 programming system. </title> <editor> In Peter Freeman, editor, </editor> <booktitle> Tutorial: Software Reusability, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year> <month> 35 </month>
Reference-contexts: Thus, frameworks are larger scale designs than abstract classes. Peter Deutsch emphasizes that the most important part of a framework is the part that describes how a system is divided into its components <ref> [Deu87, Deu89] </ref>. Frameworks also reuse implementation, but that is less important than reuse of the internal interfaces of a system and the way that its functions are divided amoung its components.
Reference: [Deu89] <author> L. Peter Deutsch. </author> <title> Design reuse and frameworks in the Smalltalk-80 programming system. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> Vol II, </volume> <pages> pages 55-71, </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: An abstract class is a relatively small-scale design. A framework is a larger-scale design. It describes how a program is decomposed into a set of interacting objects. A framework is used to represent an entire application or subsystem <ref> [Deu89, WJ90] </ref>. Abstract classes are well-known inside the object-oriented programming community, but frameworks are not. Neither are yet understood in the wider software engineering community as an important way to reuse design. <p> Thus, frameworks are larger scale designs than abstract classes. Peter Deutsch emphasizes that the most important part of a framework is the part that describes how a system is divided into its components <ref> [Deu87, Deu89] </ref>. Frameworks also reuse implementation, but that is less important than reuse of the internal interfaces of a system and the way that its functions are divided amoung its components.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference: [Foo88] <author> Brian Foote. </author> <title> Designing to Facilitate Change with Object-Oriented Frameworks. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1988. </year>
Reference-contexts: Frameworks are not limited to user interfaces, but can be applied to any area of software design. They have been applied to VLSI routing algorithms [Gos90], to structured drawing editors [VL89, Vli90], code optimization [JM91], and psychophysiological experiments <ref> [Foo88] </ref>. Frameworks do not even require an object-oriented programming language. The Genesis database system compiler is a framework for database management systems [Bat88, BBR*89] as well as a tool for specifying how ensembles are configured in the framework [BB91].
Reference: [Foo91] <author> Brian Foote. </author> <title> The lifecycle of object-oriented frameworks: a fractal perspective. 1991. </title> <institution> University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: One model has the framework designers also design applications, but they divide their time into phases when they extend the framework by applying it and a phase when they revise the framework by consolidating earlier extensions <ref> [Foo91] </ref>. The other model is to have a separate group of framework designers. The framework designers test their framework by using it, but also rely on the main users of the framework for feedback.
Reference: [Gol84] <author> Adele Goldberg. </author> <title> Smalltalk-80: The Interactive Programming Environment. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: We will first define frameworks by example, and will finish this section with a more precise definition. The first widely used framework, developed around 1980, was the Smalltalk-80 user interface framework called Model/View/Controller (MVC) <ref> [Gol84, KP88, LP91] </ref>. MVC showed that object-oriented programming was well-suited for implementing graphical user interfaces. It divides a user interface into three kinds of components; models, views and controllers. These objects work in trios consisting of a view and controller interacting with a model.
Reference: [Gos90] <author> Sanjiv Gossain. </author> <title> Object-Oriented Development and Reuse. </title> <type> PhD thesis, </type> <institution> University of Essex, UK, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: Frameworks are not limited to user interfaces, but can be applied to any area of software design. They have been applied to VLSI routing algorithms <ref> [Gos90] </ref>, to structured drawing editors [VL89, Vli90], code optimization [JM91], and psychophysiological experiments [Foo88]. Frameworks do not even require an object-oriented programming language.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: An abstract class is an incompletely specified class that is designed to be a template for subclasses, rather than a template for objects <ref> [GR83, WJ90] </ref>. An abstract class is a relatively small-scale design. A framework is a larger-scale design. It describes how a program is decomposed into a set of interacting objects. A framework is used to represent an entire application or subsystem [Deu89, WJ90].
Reference: [Hal85] <author> Robert Halstead. </author> <title> Multilisp: a language for concurrent symbolic computation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(4) </volume> <pages> 501-538, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: There is an additional 170 lines of code and 80 lines of header file that is pure garbage collector, i.e., it could be used in a conventional copying collector. 7.3 Futures A future is a value in the process of being computed <ref> [Hal85] </ref>. It is a parallel programming construct that combines a process with a synchronization mechanism. A future can be assigned to a variable, passed as an argument to a procedure, and treated just like any other value. <p> Likewise, a new process that requests the value of the future need not block. Multilisp lets a program use futures anywhere it uses other kinds of values, and lets the programmer replace any value with a future <ref> [Hal85] </ref>. This makes futures easy to use but hard to implement efficiently. Each access of any object must determine whether the object is a future and, if so, whether its value has been computed. Thus, all object accesses are slow because of futures.
Reference: [HFC76] <author> A. N. Habermann, L. Flon, and L. Cooprider. </author> <title> Modularization and hierarchy in a family of operating systems. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 266-272, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: One solution to the problem of conflicting requirements is to provide a family of operating systems that can be reconfigured to meet nearly any requirement. The need for a family of operating systems has been known for a long time <ref> [HFC76] </ref>. Just as automobile companies offer a wide selection of car sizes, engines, and colors to choose from, a family of operating systems would provide a set of components that could be rearranged in many configurations.
Reference: [HHG90] <author> Richard Helm, Ian M. Holland, and Dipayan Gangopadhyay. </author> <title> Contracts: specifying behavioral compositions in object-oriented systems. </title> <booktitle> In Proceedings of OOPSLA `90, </booktitle> <pages> pages 169-180, </pages> <month> October </month> <year> 1990. </year> <journal> printed as SIGPLAN Notices, </journal> <volume> 25(10). </volume>
Reference-contexts: This would not only provide code reuse, but make it easier to learn how objects in the framework interact. Work is being done to develop ways of describing the constraints formally <ref> [HHG90] </ref>. In the meantime, frameworks are being successfully described informally. The description of the Choices virtual memory framework in this paper shows how a framework can be described informally. A framework reuses analysis, design, and code. <p> Statically typed languages can describe the static interfaces between objects, i.e., the set of operations that one can perform on the other, but not the dynamic interfaces, i.e., the order of these operations. One promising approach to describing dynamic interfaces is contracts <ref> [HHG90] </ref>. Since iteration is so important, framework design would be easier if it were easier to make iterative changes. Most of the changes to frameworks seem to fall into about a dozen categories [JF88, OJ90]. It seems feasible to provide tools to automate these kinds of changes.
Reference: [JC89] <author> Gary M. Johnston and Roy H. Campbell. </author> <title> An object-oriented implementation of distributed virtual memory. </title> <booktitle> In Proceedings of the Workshop on Experiences with Building Distributed and Multiprocessor Systems, </booktitle> <pages> pages 39-57, </pages> <address> Ft. Lauderdale, Florida, </address> <month> October </month> <year> 1989. </year> <month> 36 </month>
Reference-contexts: However, as soon as one machine attempts to write to the page, those copies must be invalidated and recopied from the newly written copy. Distributed shared memory is currently implemented in Choices by Dis-tributedMemoryObjectCache, a subclass of MemoryObjectCache, and by subclasses of PageRecord <ref> [JC89, SMC90] </ref>. A PageRecord is used to represent the state associated with a unit of a memory object, such as its current location, whether it is cached in physical memory, and whether it is being fetched from another processor.
Reference: [JF88] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <year> 1988. </year>
Reference-contexts: Thus, the Choices virtual memory framework will continue to improve as it is used. 8 The Process of Framework Design One of the most common observations about framework design is that iteration is essential <ref> [JF88, Wir90] </ref>. Batory et. al. emphasize that the development of their framework took much longer than expected and attributed this to the difficulty of domain analysis [BBR*89]. Our experience supports theirs. <p> One promising approach to describing dynamic interfaces is contracts [HHG90]. Since iteration is so important, framework design would be easier if it were easier to make iterative changes. Most of the changes to frameworks seem to fall into about a dozen categories <ref> [JF88, OJ90] </ref>. It seems feasible to provide tools to automate these kinds of changes. This would make it easier to change frameworks when weaknesses are discovered, but would not make it any easier to spot weaknesses or to decide how to fix them.
Reference: [JM91] <author> Ralph E. Johnson and Carl McConnell. </author> <title> The RTL System: A Framework for Code Optimization. </title> <type> Technical Report, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1991. </year>
Reference-contexts: Frameworks are not limited to user interfaces, but can be applied to any area of software design. They have been applied to VLSI routing algorithms [Gos90], to structured drawing editors [VL89, Vli90], code optimization <ref> [JM91] </ref>, and psychophysiological experiments [Foo88]. Frameworks do not even require an object-oriented programming language. The Genesis database system compiler is a framework for database management systems [Bat88, BBR*89] as well as a tool for specifying how ensembles are configured in the framework [BB91].
Reference: [Kou91] <author> Panagiotis Kougiouris. </author> <title> The I/O Subsystem of an Object-Oriented Operating System. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1991. </year>
Reference-contexts: Different kinds of hardware disk interfaces require different subclasses of Disk. Each subclass encapsulates the device controller, interrupt management mechanism, etc., for a particular computer that Choices is targeted to. A framework for constructing new Disk classes is currently being designed <ref> [Kou91] </ref>. 5.2 MemoryObjectView To be useful, large memory objects like disks must be partitioned into smaller memory objects like files. Class MemoryObjectView provides a view of a part of a larger memory object.
Reference: [KP88] <author> Glenn E. Krasner and Stephen T. Pope. </author> <title> A cookbook for using the model-view-controller user interface paradigm in Smalltalk-80. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(3) </volume> <pages> 26-49, </pages> <month> August/Spetember </month> <year> 1988. </year>
Reference-contexts: We will first define frameworks by example, and will finish this section with a more precise definition. The first widely used framework, developed around 1980, was the Smalltalk-80 user interface framework called Model/View/Controller (MVC) <ref> [Gol84, KP88, LP91] </ref>. MVC showed that object-oriented programming was well-suited for implementing graphical user interfaces. It divides a user interface into three kinds of components; models, views and controllers. These objects work in trios consisting of a view and controller interacting with a model.
Reference: [KRT89] <author> Shmuel Katz, Charles A. Richter, </author> <title> and Khe-Sing The. Paris: a system for reusing partially interpreted schemas. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> Vol I, </volume> <pages> pages 257-273, </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: This high-level design is the main intellectual content of software and is far more difficult to create or re-create than code. Frameworks are a way to reuse this high-level design. Frameworks are similar to other techniques for reusing high-level design, such as templates [VK89] or schemas <ref> [KRT89, LH87] </ref>. Like abstract classes, frameworks are expressed in a programming language, but the other ways of reusing high-level design usually depend on a special purpose design notation. As a result, these other techniques have the potential to be more flexible and powerful than frameworks.
Reference: [Lad89] <author> David A. Ladd. </author> <title> Supporting Futures With Virtual Memory. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference-contexts: The Choices virtual memory system makes it possible for futures to be used like any other kind of value and still be efficient <ref> [Lad89] </ref>. Futures are implemented by defining a subclass of MemoryObjectCache, FutureCache. A future cache contains a collection of futures, one for each page. Instead of filling the cache by reading from a memory object, a future cache fills itself by waiting for the future's process to finish.
Reference: [LH86] <author> Kai Li and Paul Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <booktitle> In Proceedings of the Fifth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 229-239, </pages> <year> 1986. </year>
Reference-contexts: These include proposals for using address translation hardware for garbage collection [AEL88, BDS91, Sha87] and for distributed programming <ref> [LH86] </ref>. If a feature is normally expensive because it requires checking some condition regularly, it can often be made inexpensive by translating the condition into a protection or validity check that can be performed by the address translation unit. <p> Two of these|distributed shared memory and garbage collection|are well-known, the third is new. 7.1 Distributed Shared Memory Distributed shared memory is a way to let programs designed for shared memory work in a distributed computing system by emulating the shared memory 25 across a network <ref> [LH86] </ref>. This is done by treating each page of data separately and automatically moving them from machine to machine as needed. When a process accesses a non-resident page, it causes a page fault.
Reference: [LH87] <author> Mitchell D. Lubars and Mehdi T. Harandi. </author> <title> Knowledge-based software design using design schemas. </title> <booktitle> In Proc. 9th Intl. Conf. on Software Engineering, </booktitle> <pages> pages 253-262, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: This high-level design is the main intellectual content of software and is far more difficult to create or re-create than code. Frameworks are a way to reuse this high-level design. Frameworks are similar to other techniques for reusing high-level design, such as templates [VK89] or schemas <ref> [KRT89, LH87] </ref>. Like abstract classes, frameworks are expressed in a programming language, but the other ways of reusing high-level design usually depend on a special purpose design notation. As a result, these other techniques have the potential to be more flexible and powerful than frameworks.
Reference: [LP91] <author> Wilf R. LaLonde and John R. Pugh. </author> <title> Inside Smalltalk, Volume II. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: We will first define frameworks by example, and will finish this section with a more precise definition. The first widely used framework, developed around 1980, was the Smalltalk-80 user interface framework called Model/View/Controller (MVC) <ref> [Gol84, KP88, LP91] </ref>. MVC showed that object-oriented programming was well-suited for implementing graphical user interfaces. It divides a user interface into three kinds of components; models, views and controllers. These objects work in trios consisting of a view and controller interacting with a model.
Reference: [LVC89] <author> Mark A. Linton, John M. Vlissides, and Paul R. Calder. </author> <title> Composing user interfaces with InterViews. </title> <journal> Computer, </journal> <volume> 22(2) </volume> <pages> 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Recently there have been several user interface frameworks from universities, such as the Andrew Toolkit from Carnegie Mellon University [PHK*88], InterViews from Stanford <ref> [LVC89] </ref>, and ET++ from the University of Zurich [WGM88, WGM89]. Each of these frameworks improves the state of the art in user interface framework design in some way, building on the lessons of earlier systems.
Reference: [MCRL89] <author> Peter W. Madany, Roy H. Campbell, Vincent F. Russo, and Douglas E. Leyens. </author> <title> A class hierarchy for building stream-oriented 37 file systems. </title> <editor> In Stephen Cook, editor, </editor> <booktitle> Proceedings of the 1989 Euro--pean Conference on Object-Oriented Programming, </booktitle> <pages> pages 311-328, </pages> <publisher> Cambridge University Press, </publisher> <address> Nottingham, UK, </address> <month> July </month> <year> 1989. </year>
Reference-contexts: Choices was designed using the object-oriented paradigm and is implemented in an object-oriented language (C++). Choices is composed of interlocking frameworks for * process management [RJC88], * virtual memory management [RC89], * file systems <ref> [MLRC88, MCRL89] </ref>, and * networking [ZJ90]. Over the last few decades, the number of computing environments has been growing rapidly. Often the needs of one class of system runs in direct 10 opposition to another. <p> It will often read several blocks from its memory object before it can find the data block to read or write. For a further discussion on how the Choices memory object hierarchy was used to implement several versions of the Unix file system, see <ref> [MCRL89] </ref>. 5.3 Customizability The simplest and most common way to customize the Choices virtual memory system is by creating new kinds of memory objects. Inheritance makes 18 programming new classes easier, but polymorphism avoids the creation of new classes by letting new memory object ensembles be built from existing classes.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: The abstract class provides a specification that all subclasses are to follow. Statically typed object-oriented programming languages check the syntactic part of the specifications, though a complete specification includes behavioral constraints like pre and postconditions and class invariants. Eiffel <ref> [Mey88] </ref> is the only commercial object-oriented language that provides any support for recording or checking the behavioral part of the specifications 1 , and dynamically typed languages like Smalltalk do not even check the syntactic part.
Reference: [MLRC88] <author> Peter Madany, Douglas Leyens, Vincent F. Russo, and Roy H. Campbell. </author> <title> A C++ class hierarchy for building UNIX-like file systems. </title> <booktitle> In Proceedings of the USENIX 1988 C++ Conference, </booktitle> <pages> pages 65-79, </pages> <address> Denver, Colorado, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Choices was designed using the object-oriented paradigm and is implemented in an object-oriented language (C++). Choices is composed of interlocking frameworks for * process management [RJC88], * virtual memory management [RC89], * file systems <ref> [MLRC88, MCRL89] </ref>, and * networking [ZJ90]. Over the last few decades, the number of computing environments has been growing rapidly. Often the needs of one class of system runs in direct 10 opposition to another.
Reference: [OJ90] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Refactoring: an aid in designing application frameworks and evolving object-oriented systems. </title> <editor> In James TenEyck, editor, </editor> <booktitle> Proceedings of Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <pages> pages 145-160, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: One promising approach to describing dynamic interfaces is contracts [HHG90]. Since iteration is so important, framework design would be easier if it were easier to make iterative changes. Most of the changes to frameworks seem to fall into about a dozen categories <ref> [JF88, OJ90] </ref>. It seems feasible to provide tools to automate these kinds of changes. This would make it easier to change frameworks when weaknesses are discovered, but would not make it any easier to spot weaknesses or to decide how to fix them.
Reference: [PHK*88] <author> A. J. Palay, W. J. Hansen, M.L. Kazar, M. Sherman, M.G. Wadlow, T.P. Neuendorffer, Z. Stern, M. Bader, and T. Petre. </author> <title> The Andrew Toolkit|an overview. </title> <booktitle> In USENIX Association Winter Conference, </booktitle> <address> Dallas, </address> <year> 1988. </year>
Reference-contexts: Recently there have been several user interface frameworks from universities, such as the Andrew Toolkit from Carnegie Mellon University <ref> [PHK*88] </ref>, InterViews from Stanford [LVC89], and ET++ from the University of Zurich [WGM88, WGM89]. Each of these frameworks improves the state of the art in user interface framework design in some way, building on the lessons of earlier systems.
Reference: [PS85] <author> James L. Peterson and Abraham Silberschatz. </author> <title> Operating System Concepts. </title> <publisher> Addison Wesley, </publisher> <year> 1985. </year>
Reference-contexts: For the reader unfamiliar with virtual memory, this section will give a quick overview. Others may wish to skip this section. Those wishing more detail should refer to a suitable operating systems text <ref> [PS85, BS88, Tan87] </ref>. Most computers support the distinction between the memory referenced by a program and the physical (real) memory of the computer. Each program is given a logical address space in which to execute.
Reference: [PS88] <author> Inc. </author> <title> ParcPlace Systems. Smalltalk-80 Reference Manual. </title> <year> 1988. </year>
Reference-contexts: Class Object provides a dependency mechanism that views can use to detect when the model's state changes. Thus, any object can be a model. Later versions of Smalltalk-80 have added a Model class that provides a more efficient version of the dependency mechanism <ref> [PS88] </ref>. The file tool is a typical Model/View/Controller application that does not need new subclasses of View or Controller. The ensemble that makes up its user interface consists entirely of objects from classes that are a standard part of the Smalltalk-80 class library.
Reference: [RAN88] <author> M. Rozier, V. Abrossimov, and W Neuhauser. </author> <title> CHORUS-V3 Kernel Specification and Interface, </title> <type> Draft. Technical Report CS/TN-87-25.10, </type> <institution> CHORUS Systems, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: The Choices virtual memory model is similiar in design to that of other 14 Memory Objects Domain Domain Processes Process modern operating systems including Mach [RTY*87], CHORUS <ref> [RAN88] </ref>, and V [Che88]. Figure 4 shows an application programmer's view of the Choices virtual memory system. Each domain has one or more processes that execute within it. A memory object can belong to any number of domains.
Reference: [RC89] <author> Vincent Russo and Roy H. Campbell. </author> <title> Virtual memory and backing storage management in multiprocessor operating systems using class hierarchical design. </title> <booktitle> In Proceedings of OOPSLA `89, </booktitle> <pages> pages 267-278, </pages> <address> New Orleans, Louisiana, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: Since frameworks codify design knowledge for a particular application domain, understanding a framework always requires understanding a little about its application domain. The main example of this paper is taken from the virtual memory system of the Choices operating system <ref> [RC89, Rus90] </ref>. Choices is a framework for operating system construction being developed at the University of Illinois. The rest of this paper is presented as follows. Section 2 defines abstract classes and frameworks. Section 3 gives some background on virtual memory. Sections 4-6 describe the Choices virtual memory framework. <p> Choices was designed using the object-oriented paradigm and is implemented in an object-oriented language (C++). Choices is composed of interlocking frameworks for * process management [RJC88], * virtual memory management <ref> [RC89] </ref>, * file systems [MLRC88, MCRL89], and * networking [ZJ90]. Over the last few decades, the number of computing environments has been growing rapidly. Often the needs of one class of system runs in direct 10 opposition to another.
Reference: [RJC88] <author> Vincent Russo, Gary Johnston, and Roy Campbell. </author> <title> Process management and exception handling in multiprocessor operating systems using object-oriented design techniques. </title> <booktitle> In Proceedings of OOPSLA `88, </booktitle> <pages> pages 248-258, </pages> <month> November </month> <year> 1988. </year> <journal> printed as SIGPLAN Notices, </journal> <volume> 23(11). </volume>
Reference-contexts: Choices was designed using the object-oriented paradigm and is implemented in an object-oriented language (C++). Choices is composed of interlocking frameworks for * process management <ref> [RJC88] </ref>, * virtual memory management [RC89], * file systems [MLRC88, MCRL89], and * networking [ZJ90]. Over the last few decades, the number of computing environments has been growing rapidly. Often the needs of one class of system runs in direct 10 opposition to another.
Reference: [RMC90] <author> Vincent F. Russo, Peter W. Madany, and Roy H. Campbell. </author> <title> C++ and operating systems performance: a case study. </title> <booktitle> In Proceedings 38 of the USENIX C++ Conference, </booktitle> <pages> pages 103-114, </pages> <address> San Francisco, California, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Instead, it offers an array of features that can be selected on a per-operating system or, in some cases, per-user basis. In spite of this flexibility, the performance of Choices is similar to that of comparable operating systems <ref> [RMC90] </ref>. This paper describes the virtual memory framework of Choices, and uses it as an example of how object-oriented programming permits the reuse of design. The virtual memory framework provides an abstract design of a virtual memory system that can be customized to make a particular concrete virtual memory system.
Reference: [RTY*87] <author> Richard Rashid, Avadis Tevanian, Michael Young, David Golub, Robert Baron, David Black, William Bolosky, and Jonathan Chew. </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures. </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systmes (ASPLOS II), </booktitle> <pages> pages 31-39, </pages> <year> 1987. </year>
Reference-contexts: They abstract page tables and physical memory management, hide the details of page faults, and ensure consistency of information about the location of data. The Choices virtual memory model is similiar in design to that of other 14 Memory Objects Domain Domain Processes Process modern operating systems including Mach <ref> [RTY*87] </ref>, CHORUS [RAN88], and V [Che88]. Figure 4 shows an application programmer's view of the Choices virtual memory system. Each domain has one or more processes that execute within it. A memory object can belong to any number of domains.
Reference: [Rus90] <author> Vincent F. Russo. </author> <title> An Object-Oriented Operating System. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: Since frameworks codify design knowledge for a particular application domain, understanding a framework always requires understanding a little about its application domain. The main example of this paper is taken from the virtual memory system of the Choices operating system <ref> [RC89, Rus90] </ref>. Choices is a framework for operating system construction being developed at the University of Illinois. The rest of this paper is presented as follows. Section 2 defines abstract classes and frameworks. Section 3 gives some background on virtual memory. Sections 4-6 describe the Choices virtual memory framework.
Reference: [Sch86] <author> Kurt J. Schmucker. </author> <title> Object-Oriented Programming for the Macintosh. </title> <publisher> Hayden Book Company, </publisher> <year> 1986. </year>
Reference-contexts: MacApp is a popular commercial user interface framework designed specifically 7 *.st File list lpb.st mini.st train.st ------------ StandardSystemView SelectionInListView TextView TextView !LiterateProgram methodsFor: 'user interface'! edit LiterateProgramBr owser openOn: self! Figure 2: Subview Hierarchy in File Tool for implementing Macintosh applications <ref> [Sch86] </ref>. Recently there have been several user interface frameworks from universities, such as the Andrew Toolkit from Carnegie Mellon University [PHK*88], InterViews from Stanford [LVC89], and ET++ from the University of Zurich [WGM88, WGM89].
Reference: [Sha87] <author> Robert A. Shaw. </author> <title> Improving Garbage Collector Performance in Virtual Memory. </title> <type> Technical Report CSL-TR-87-323, </type> <institution> Stanford University, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: These include proposals for using address translation hardware for garbage collection <ref> [AEL88, BDS91, Sha87] </ref> and for distributed programming [LH86]. If a feature is normally expensive because it requires checking some condition regularly, it can often be made inexpensive by translating the condition into a protection or validity check that can be performed by the address translation unit.
Reference: [Sha90] <author> Mary Shaw. </author> <title> Prospects for an engineering discipline of software. </title> <journal> IEEE Software, </journal> <volume> 7(6) </volume> <pages> 15-24, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: In a recent paper, Mary Shaw argues that "software engineering" will not be a true engineering discipline until it codifies a large body of design information and creates reference materials that engineers can use to solve routine design problems quickly and reliably <ref> [Sha90] </ref>. We believe that frameworks are one of the most promising approaches for making software engineering a reality. The purpose of this paper is to show how object-oriented frameworks can be used to codify design knowledge for a particular application domain.
Reference: [SMC90] <author> Aamod Sane, Ken MacGregor, and Roy Campbell. </author> <title> Distributed virtual memory consistency protocols: design and performance. </title> <booktitle> In IEEE Workshop on Experimental Distributed Systems, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: However, as soon as one machine attempts to write to the page, those copies must be invalidated and recopied from the newly written copy. Distributed shared memory is currently implemented in Choices by Dis-tributedMemoryObjectCache, a subclass of MemoryObjectCache, and by subclasses of PageRecord <ref> [JC89, SMC90] </ref>. A PageRecord is used to represent the state associated with a unit of a memory object, such as its current location, whether it is cached in physical memory, and whether it is being fetched from another processor.
Reference: [Tan87] <author> Andrew S. Tanenbaum. </author> <title> Operating Systems: Design and Implementation. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: For the reader unfamiliar with virtual memory, this section will give a quick overview. Others may wish to skip this section. Those wishing more detail should refer to a suitable operating systems text <ref> [PS85, BS88, Tan87] </ref>. Most computers support the distinction between the memory referenced by a program and the physical (real) memory of the computer. Each program is given a logical address space in which to execute.
Reference: [VK89] <author> Dennis M. Volpano and Richard B. Kieburtz. </author> <title> The templates approach to software reuse. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> Vol I, </volume> <pages> pages 247-255, </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: This high-level design is the main intellectual content of software and is far more difficult to create or re-create than code. Frameworks are a way to reuse this high-level design. Frameworks are similar to other techniques for reusing high-level design, such as templates <ref> [VK89] </ref> or schemas [KRT89, LH87]. Like abstract classes, frameworks are expressed in a programming language, but the other ways of reusing high-level design usually depend on a special purpose design notation. As a result, these other techniques have the potential to be more flexible and powerful than frameworks.
Reference: [VL89] <author> John M. Vlissides and Mark A. Linton. Unidraw: </author> <title> a framework for building domain-specific graphical editors. </title> <booktitle> In Proceedings of the ACM User Interface Software and Technologies '89 Conference, </booktitle> <pages> pages 81-94, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Frameworks are not limited to user interfaces, but can be applied to any area of software design. They have been applied to VLSI routing algorithms [Gos90], to structured drawing editors <ref> [VL89, Vli90] </ref>, code optimization [JM91], and psychophysiological experiments [Foo88]. Frameworks do not even require an object-oriented programming language. The Genesis database system compiler is a framework for database management systems [Bat88, BBR*89] as well as a tool for specifying how ensembles are configured in the framework [BB91].
Reference: [Vli90] <author> John M. Vlissides. </author> <title> Generalized Graphical Object Editing. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> June </month> <year> 1990. </year> <month> 39 </month>
Reference-contexts: Frameworks are not limited to user interfaces, but can be applied to any area of software design. They have been applied to VLSI routing algorithms [Gos90], to structured drawing editors <ref> [VL89, Vli90] </ref>, code optimization [JM91], and psychophysiological experiments [Foo88]. Frameworks do not even require an object-oriented programming language. The Genesis database system compiler is a framework for database management systems [Bat88, BBR*89] as well as a tool for specifying how ensembles are configured in the framework [BB91].
Reference: [WGM88] <author> A. Weinand, E. Gamma, and R. Marty. ET++: </author> <title> an object-oriented application framework in C++. </title> <booktitle> In Proceedings of OOPSLA `88, </booktitle> <pages> pages 46-57, </pages> <month> November </month> <year> 1988. </year> <journal> printed as SIGPLAN Notices, </journal> <volume> 23(11). </volume>
Reference-contexts: Recently there have been several user interface frameworks from universities, such as the Andrew Toolkit from Carnegie Mellon University [PHK*88], InterViews from Stanford [LVC89], and ET++ from the University of Zurich <ref> [WGM88, WGM89] </ref>. Each of these frameworks improves the state of the art in user interface framework design in some way, building on the lessons of earlier systems. Frameworks are not limited to user interfaces, but can be applied to any area of software design.
Reference: [WGM89] <author> A. Weinand, E. Gamma, and R. Marty. </author> <title> Design and implementation of ET++, a seamless object-oriented application framework. </title> <journal> Structured Programming, </journal> <volume> 10(2) </volume> <pages> 63-87, </pages> <year> 1989. </year>
Reference-contexts: Recently there have been several user interface frameworks from universities, such as the Andrew Toolkit from Carnegie Mellon University [PHK*88], InterViews from Stanford [LVC89], and ET++ from the University of Zurich <ref> [WGM88, WGM89] </ref>. Each of these frameworks improves the state of the art in user interface framework design in some way, building on the lessons of earlier systems. Frameworks are not limited to user interfaces, but can be applied to any area of software design.
Reference: [Wir90] <author> Allan Wirfs-Brock. </author> <title> Ecoop/oopsla'90 panel on designing reusable frameworks. </title> <month> October </month> <year> 1990. </year>
Reference-contexts: Thus, the Choices virtual memory framework will continue to improve as it is used. 8 The Process of Framework Design One of the most common observations about framework design is that iteration is essential <ref> [JF88, Wir90] </ref>. Batory et. al. emphasize that the development of their framework took much longer than expected and attributed this to the difficulty of domain analysis [BBR*89]. Our experience supports theirs.
Reference: [WJ90] <author> Rebecca J. Wirfs-Brock and Ralph E. Johnson. </author> <title> Surveying current research in object-oriented design. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 104-124, </pages> <year> 1990. </year>
Reference-contexts: An abstract class is an incompletely specified class that is designed to be a template for subclasses, rather than a template for objects <ref> [GR83, WJ90] </ref>. An abstract class is a relatively small-scale design. A framework is a larger-scale design. It describes how a program is decomposed into a set of interacting objects. A framework is used to represent an entire application or subsystem [Deu89, WJ90]. <p> An abstract class is a relatively small-scale design. A framework is a larger-scale design. It describes how a program is decomposed into a set of interacting objects. A framework is used to represent an entire application or subsystem <ref> [Deu89, WJ90] </ref>. Abstract classes are well-known inside the object-oriented programming community, but frameworks are not. Neither are yet understood in the wider software engineering community as an important way to reuse design.
Reference: [YT86] <author> Yasuhiko Yokote and Mario Tokoro. </author> <title> The design and implementation of concurrentsmalltalk. </title> <booktitle> In Proceedings of OOPSLA `86, </booktitle> <pages> pages 331-340, </pages> <month> November </month> <year> 1986. </year> <journal> printed as SIGPLAN Notices, </journal> <volume> 21(11). </volume>
Reference-contexts: Each access of any object must determine whether the object is a future and, if so, whether its value has been computed. Thus, all object accesses are slow because of futures. In contrast, a Concurrent Smalltalk future (called a cbox) is distinct from other values <ref> [YT86] </ref>. Its only operation is receive, which waits for its value to be computed and then returns the value.
Reference: [ZJ90] <author> Jonathan M. Zweig and Ralph E. Johnson. </author> <title> The conduit: a communication abstraction in C++. </title> <booktitle> In Proceedings of the Second Usenix C++ Conference, </booktitle> <month> April </month> <year> 1990. </year> <month> 40 </month>
Reference-contexts: Choices was designed using the object-oriented paradigm and is implemented in an object-oriented language (C++). Choices is composed of interlocking frameworks for * process management [RJC88], * virtual memory management [RC89], * file systems [MLRC88, MCRL89], and * networking <ref> [ZJ90] </ref>. Over the last few decades, the number of computing environments has been growing rapidly. Often the needs of one class of system runs in direct 10 opposition to another.
References-found: 60

