URL: http://www.cse.ogi.edu/~lingliu/CQ/98coopis.ps
Refering-URL: http://www.cse.ogi.edu/~lingliu/courses/cse583/reading.html
Root-URL: http://www.cse.ogi.edu
Email: flingliu,calton,wtangg@cse.ogi.edu  
Title: Conquer An Architecture for a Distributed Push-enabled Data Management System extending conventional DBMS components, providing
Author: Ling Liu, Calton Pu, Wei Tang 
Keyword: Distributed and Cooperative Information Systems, Interoperability, Distributed Object Management, Distributed Triggers and Event Monitoring.  
Note: reusing and  This research is partially supported by DARPA contract MDA972-97-1-0016, Intel, and Boeing.  
Address: P.O.Box 91000 Portland Oregon 97291-1000 USA  
Affiliation: Oregon Graduate Institute of Science and Technology Department of Computer Science and Engineering  
Abstract: Conquer is an extensible architecture designed for transforming a pull-based data management system (e.g., conventional DBMSs, web search engines and query systems) into a push-enabled data management systems. The key ideas of Conquer are the concept of continual queries; the mechanisms for efficient and scalable implementation of continual queries [20], including synchronous or asynchronous event monitoring, immediate or deferred execution coupling; and the three-tier architecture that provides data independence in both mediator level and wrapper level. The distinct features of the Conquer architecture include: This paper presents the design of Conquer and its initial implementation on top of the distributed interoperable information mediation system DIOM [17, 15]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Acharya, M. Franklin, and S. Zdonik. </author> <title> Balancing push and pull for data broadcast. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Tucson, Arizona, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: systems also in data delivery protocol and scope of a query: Most pull-based systems use Request/Response protocol where clients send their request to servers asking information of interest, servers respond to the request of clients by delivering the information requested; whereas push-based systems use either Publish/Subscribe protocol or Broadcast protocol <ref> [1, 8] </ref>. The former delivers information based on the principle that servers publish information online, and clients subscribe to the information of interest; whereas the latter delivers information to clients periodically. Clients who require access to a data item need to wait until the item appears.
Reference: [2] <author> R. Alonso, D. Barbara, and H. Garcia-Molina. </author> <title> Data caching issues in an information retrieval system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(3) </volume> <pages> 359-384, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data [26]. Other works on distributed environments include quasi-copies for replication <ref> [2] </ref> and update anomalies in data warehouses [31] Commercial database triggers Conceptually a database (built-in) trigger is an event-condition-action (ECA) rule in a restrictive form. Commercial DBMSs have been introducing support for database triggers at various levels, mainly due to the customers' need for better support for integrity constraints.
Reference: [3] <author> D. Barbara and R. Alonso. </author> <title> Processing continuous queries in general environments. </title> <type> Technical report, </type> <institution> Mat-sushita Information Technology Laboratory, Princeton, NJ, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Perhaps the most significant assumption is the limitation of database updates to append-only, disallowing deletions and modifications. Since this assumption is used in their query transformation algorithm, it has been difficult to relax it <ref> [3] </ref>, when following their definition of continuous queries. Second, the specification model for update monitoring is purely time-based. There is no clean separation of query and trigger condition in the specification. In addition, there has been considerable research done in the monitoring of information changes in databases.
Reference: [4] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 61-71, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: In contrast, incremental update algorithms are believed to carry lower execution cost if changes to the database are moderate [11, 13]. Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table <ref> [4] </ref>. The second defers the refresh until a query is issued against the view [24]. The third refreshes the view periodically [13]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. <p> The second defers the refresh until a query is issued against the view [24]. The third refreshes the view periodically [13]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref> [4, 11, 9] </ref> work in a centralized database environment, in which the materialized view and its base tables co-reside. The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data [26].
Reference: [5] <author> A. P. Buchmann, J. Zimmermann, J. Blakeley, and D.L.`Wells. </author> <title> Building an intergrated active oodbms: Requirements, architecture, and design decisions. </title> <booktitle> In Proceedings of the 11th International Conference on Data Engineering, </booktitle> <pages> pages 117-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: A walkthrough example to illustrate this process is provided in Section 4. 2.4 Continual Queries v.s. ECA Rules Continual queries, at the first glance, may seem to bear resemblance to ECA rules in active databases <ref> [5, 7, 6, 21] </ref>. One might view continual queries as a subset of ECA rules. However, they are quite different not only in functionality coverage and usage perspective but also in execution model and implementation architecture.
Reference: [6] <author> S. Chakravarthy. </author> <title> Architectures and monitoring techniques for active databases: An evaluation. </title> <note> In Technical Report TR-92-041, </note> <institution> University of Florida, </institution> <address> Gainesville, FL, </address> <year> 1992. </year>
Reference-contexts: A walkthrough example to illustrate this process is provided in Section 4. 2.4 Continual Queries v.s. ECA Rules Continual queries, at the first glance, may seem to bear resemblance to ECA rules in active databases <ref> [5, 7, 6, 21] </ref>. One might view continual queries as a subset of ECA rules. However, they are quite different not only in functionality coverage and usage perspective but also in execution model and implementation architecture. <p> information universe as the Internet, these assumptions no longer hold (see [14] for a summary of desired system properties in the Internet), and some of the techniques do not easily extend to scale up to the distributed interoperable environment. 21 Active Databases: Most of active database systems [30] provide facilities <ref> [6, 21, 25] </ref> that allow users to specify, in the form of rules, actions to be performed following changes of database state.
Reference: [7] <author> S. Chakravarthy, V. Krishnaprasad, E. Anwar, and S. Kim. </author> <title> Composite events for active databases: Semantics, contexs and detection. </title> <booktitle> In Proceedings of the 20th International Conference on Very Large Data Bases, </booktitle> <year> 1994. </year> <month> 23 </month>
Reference-contexts: A walkthrough example to illustrate this process is provided in Section 4. 2.4 Continual Queries v.s. ECA Rules Continual queries, at the first glance, may seem to bear resemblance to ECA rules in active databases <ref> [5, 7, 6, 21] </ref>. One might view continual queries as a subset of ECA rules. However, they are quite different not only in functionality coverage and usage perspective but also in execution model and implementation architecture.
Reference: [8] <author> M. Franklin and S. </author> <title> Zdonik. </title> <journal> Dissemination-based information systems. IEEE Bulletin of the Technical Committee on Data Engineering, </journal> <volume> 19(3) </volume> <pages> 20-30, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: systems also in data delivery protocol and scope of a query: Most pull-based systems use Request/Response protocol where clients send their request to servers asking information of interest, servers respond to the request of clients by delivering the information requested; whereas push-based systems use either Publish/Subscribe protocol or Broadcast protocol <ref> [1, 8] </ref>. The former delivers information based on the principle that servers publish information online, and clients subscribe to the information of interest; whereas the latter delivers information to clients periodically. Clients who require access to a data item need to wait until the item appears.
Reference: [9] <author> A. Gupta, I. Mumick, and V. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 157-166, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The second defers the refresh until a query is issued against the view [24]. The third refreshes the view periodically [13]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref> [4, 11, 9] </ref> work in a centralized database environment, in which the materialized view and its base tables co-reside. The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data [26].
Reference: [10] <author> L. Haasi, W. Chang, G. Lohman, J. McPherson, P.Wilms, G. Lapis, B. Lindsay, H. Pirahesh, M. Carey, and E. Shekita. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> pages 377-388, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: However, active queries heavily rely on the use of active tables as system built-in capability and a number of concrete extensions to a particular system IBM Starburst DBMS <ref> [10] </ref>. Materialized Views: Materialized views store a snapshot of selected database state. When a database is updated, the materialized view must be refreshed to reflect the updates. A naive solution is to rematerialize the view from the base data.
Reference: [11] <author> E. N. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 440-453, </pages> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: When a database is updated, the materialized view must be refreshed to reflect the updates. A naive solution is to rematerialize the view from the base data. In contrast, incremental update algorithms are believed to carry lower execution cost if changes to the database are moderate <ref> [11, 13] </ref>. Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table [4]. The second defers the refresh until a query is issued against the view [24]. The third refreshes the view periodically [13]. <p> The second defers the refresh until a query is issued against the view [24]. The third refreshes the view periodically [13]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature <ref> [4, 11, 9] </ref> work in a centralized database environment, in which the materialized view and its base tables co-reside. The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data [26].
Reference: [12] <institution> Informix Software, Inc. </institution> <note> Informix Guide to SQL: Syntax (Version 6.0), </note> <year> 1994. </year>
Reference-contexts: Despite their conceptual generality, rules have been so far supported in a fairly restrictive form in practical systems, for example, by built-in triggers <ref> [12] </ref> in relational database management systems such as Oracle, Sybase, and Informix (see a further discussion On Commercial database trigger below). Active queries, introduced in Alert [25], is yet another form of ECA rules.
Reference: [13] <author> B. Lindsay, L. Haas, and C. Mohan. </author> <title> A snapshot differential refresh algorithm. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 53-60, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: When a database is updated, the materialized view must be refreshed to reflect the updates. A naive solution is to rematerialize the view from the base data. In contrast, incremental update algorithms are believed to carry lower execution cost if changes to the database are moderate <ref> [11, 13] </ref>. Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table [4]. The second defers the refresh until a query is issued against the view [24]. The third refreshes the view periodically [13]. <p> Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table [4]. The second defers the refresh until a query is issued against the view [24]. The third refreshes the view periodically <ref> [13] </ref>. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it. Most of the algorithms in the literature [4, 11, 9] work in a centralized database environment, in which the materialized view and its base tables co-reside.
Reference: [14] <author> L. Liu and C. Pu. </author> <title> The distributed interoperable object model and its application to large-scale interop-erable database systems. </title> <booktitle> In ACM International Conference on Information and Knowledge Management (CIKM'95), </booktitle> <address> Baltimore, Maryland, USA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: The following discussion should not be seen as a critique of these techniques. Rather, these techniques have been proposed primarily for "data-centric" environments, where data is well organized and controlled. When applied to an open information universe as the Internet, these assumptions no longer hold (see <ref> [14] </ref> for a summary of desired system properties in the Internet), and some of the techniques do not easily extend to scale up to the distributed interoperable environment. 21 Active Databases: Most of active database systems [30] provide facilities [6, 21, 25] that allow users to specify, in the form of
Reference: [15] <author> L. Liu and C. Pu. </author> <title> An adaptive object-oriented approach to integration and access of heterogeneous information sources. DISTRIBUTED AND PARALLEL DATABASES: </title> <journal> An International Journal, </journal> <volume> 5(2), </volume> <year> 1997. </year>
Reference-contexts: It also provides a guard for the Stop condition to guarantee the semantic consistency of the continual query (Q, T cq , Stop). The key components of this query evaluator include: the query router [18, 16], the query planner <ref> [15, 17] </ref> and the query result assembler. The query router is a key technology that enables the Conquer continual query system to scale up in order to handle thousands of different information sources. <p> The first prototype of Conquer is built on top of the distributed interoperable information mediation system DIOM <ref> [17, 15] </ref>. The Conquer approach for reusing DBMS technology and adding event-driven data delivery elements paid-off handsomely in its initial implementation.
Reference: [16] <author> L. Liu and C. Pu. </author> <title> Dynamic query processing in diom. </title> <journal> IEEE Bulletin on Data Engineering, </journal> <volume> 20(3), </volume> <month> September </month> <year> 1997. </year>
Reference-contexts: It also provides a guard for the Stop condition to guarantee the semantic consistency of the continual query (Q, T cq , Stop). The key components of this query evaluator include: the query router <ref> [18, 16] </ref>, the query planner [15, 17] and the query result assembler. The query router is a key technology that enables the Conquer continual query system to scale up in order to handle thousands of different information sources.
Reference: [17] <author> L. Liu and C. Pu. </author> <title> A dynamic query scheduling framework for distributed and evolving information systems. </title> <booktitle> In IEEE Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, </address> <month> May 27-30 </month> <year> 1997. </year>
Reference-contexts: It also provides a guard for the Stop condition to guarantee the semantic consistency of the continual query (Q, T cq , Stop). The key components of this query evaluator include: the query router [18, 16], the query planner <ref> [15, 17] </ref> and the query result assembler. The query router is a key technology that enables the Conquer continual query system to scale up in order to handle thousands of different information sources. <p> The first prototype of Conquer is built on top of the distributed interoperable information mediation system DIOM <ref> [17, 15] </ref>. The Conquer approach for reusing DBMS technology and adding event-driven data delivery elements paid-off handsomely in its initial implementation.
Reference: [18] <author> L. Liu and C. Pu. </author> <title> A metadata approach to improving query responsiveness. </title> <booktitle> In Proceedings of the Second IEEE Metadata Conference, </booktitle> <address> Maryland, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: It also provides a guard for the Stop condition to guarantee the semantic consistency of the continual query (Q, T cq , Stop). The key components of this query evaluator include: the query router <ref> [18, 16] </ref>, the query planner [15, 17] and the query result assembler. The query router is a key technology that enables the Conquer continual query system to scale up in order to handle thousands of different information sources.
Reference: [19] <author> L. Liu and C. Pu. </author> <title> Complex event specification and event detection for continual queries. </title> <type> Technical report, </type> <address> OGI/CSE, Portland, OR, </address> <month> March </month> <year> 1998. </year>
Reference-contexts: Readers who are interested in further details may refer to our technical report <ref> [19] </ref>. 3.2 Specification Syntax Syntactically, continual queries are defined by specifying trigger condition components in the SQL-like FROM and WHERE clauses, by specifying Stop condition in temporal event expressions, and by specifying query components in the SQL-like SELECT-FROM-WHERE clauses. <p> Obviously, the richer set of event composition operators is used, the more sophisticated the event detection process will be. A complete description of event composition operators and their formal semantics is beyond the scope of this paper. Readers may refer to <ref> [19] </ref> for further details. 4.5 Issues on Efficient Condition Evaluation Users and application programs may define as many continual queries as they wish. Once these continual queries are installed, they run continually as long-running side-effect free transactions with checkpoints 1 .
Reference: [20] <author> L. Liu, C. Pu, R. Barga, and T. Zhou. </author> <title> Differential evaluation of continual queries. </title> <booktitle> In IEEE Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <address> Hong Kong, </address> <month> May 27-30 </month> <year> 1996. </year>
Reference-contexts: Incremental evaluation computes this symmetric difference directly from R+; R, and Q. Sometimes R is also needed when Q involves joins <ref> [20] </ref>.
Reference: [21] <author> D. McCarthy and U. Dayal. </author> <title> The architecture of an active database management system. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 215-224, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: A walkthrough example to illustrate this process is provided in Section 4. 2.4 Continual Queries v.s. ECA Rules Continual queries, at the first glance, may seem to bear resemblance to ECA rules in active databases <ref> [5, 7, 6, 21] </ref>. One might view continual queries as a subset of ECA rules. However, they are quite different not only in functionality coverage and usage perspective but also in execution model and implementation architecture. <p> information universe as the Internet, these assumptions no longer hold (see [14] for a summary of desired system properties in the Internet), and some of the techniques do not easily extend to scale up to the distributed interoperable environment. 21 Active Databases: Most of active database systems [30] provide facilities <ref> [6, 21, 25] </ref> that allow users to specify, in the form of rules, actions to be performed following changes of database state.
Reference: [22] <author> C. Pu, T. Autrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Operating Systems Principles, </booktitle> <address> Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Continual queries emphasize on effective and specialized support for personalized update monitoring. For readers who are familiar with the program specialization systems <ref> [29, 22] </ref>, popular in OS and PL communities, there is a close analogy between continual queries and program specialization.
Reference: [23] <author> A. Rosenthal and U. Chakarvarthy. </author> <title> Anatomy of a modular multiple query optimizer. </title> <booktitle> In The International Conference on Very Large Data Bases, </booktitle> <year> 1988. </year>
Reference-contexts: The key idea of multiple condition evaluation consists of identifying common subgraphs, and evaluating these subconditions once for a whole set of queries, instead of once for every query <ref> [23, 27] </ref>. For a continual query system, the common subconditions may be detected at the algebraic level due to the distribution and autonomy of data sources, whereas in a centralize data base system the common subconditions may also be detected at the lower level (e.g., use common access paths).
Reference: [24] <author> N. Roussopoulos and H. Kang. </author> <title> Preliminary design of adms+: A workstation-mainframe integrated architecture fopr database management systems. </title> <booktitle> In Proceedings of the 12th International Conference on Very Large Data Bases, </booktitle> <pages> pages 355-364, </pages> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year> <month> 24 </month>
Reference-contexts: Three approaches have been described previously. The first approach refreshes the view immediately after each update to the base table [4]. The second defers the refresh until a query is issued against the view <ref> [24] </ref>. The third refreshes the view periodically [13]. The main tradeoff in choosing among these approaches is the staleness of the view data vs. the cost of updating it.
Reference: [25] <author> U. Schreier, H. Pirahesh, R. Agrawal, and C. Mohan. Alert: </author> <title> An architecture for transforming a passive dbms into an active dbms. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 469-478, </pages> <address> Barcelona, Spain, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: information universe as the Internet, these assumptions no longer hold (see [14] for a summary of desired system properties in the Internet), and some of the techniques do not easily extend to scale up to the distributed interoperable environment. 21 Active Databases: Most of active database systems [30] provide facilities <ref> [6, 21, 25] </ref> that allow users to specify, in the form of rules, actions to be performed following changes of database state. <p> Despite their conceptual generality, rules have been so far supported in a fairly restrictive form in practical systems, for example, by built-in triggers [12] in relational database management systems such as Oracle, Sybase, and Informix (see a further discussion On Commercial database trigger below). Active queries, introduced in Alert <ref> [25] </ref>, is yet another form of ECA rules. Active queries are more sophisticated than database triggers, since they can be defined on multiple tables, on views, and can be nested within other active queries.
Reference: [26] <author> A. Segev and W. Fang. </author> <title> Currency-based updates to distributed materialized views. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 512-520, </pages> <address> Los Alamitos, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data <ref> [26] </ref>. Other works on distributed environments include quasi-copies for replication [2] and update anomalies in data warehouses [31] Commercial database triggers Conceptually a database (built-in) trigger is an event-condition-action (ECA) rule in a restrictive form.
Reference: [27] <author> T. Sellis. </author> <title> Multiple query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(3), </volume> <year> 1986. </year>
Reference-contexts: Several techniques have been identified as being useful for performance optimization of the condition evaluation: The first technique is Multiple Condition Optimization and also called multiple query optimization in the literature <ref> [27] </ref>. This technique represents conditions (and the events that signal the condition evaluation) by condition evaluation graphs, which resemble the query graphs commonly used in query processing. <p> The key idea of multiple condition evaluation consists of identifying common subgraphs, and evaluating these subconditions once for a whole set of queries, instead of once for every query <ref> [23, 27] </ref>. For a continual query system, the common subconditions may be detected at the algebraic level due to the distribution and autonomy of data sources, whereas in a centralize data base system the common subconditions may also be detected at the lower level (e.g., use common access paths).
Reference: [28] <author> D. Terry, D. Goldberg, D. Nichols, and B. </author> <title> Oki. Continuous queries over append-only databases. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 321-330, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: It was also inspired by the work on continuous queries by Terry et al <ref> [28] </ref> at the early stage of the development. Comparing with Terry et al [28]'s proposal, there are a number of functionality differences. First, their proposal made several assumptions that seriously restricted the applicability of their technique to the Internet.
Reference: [29] <author> E. N. Volanschi, C. Consel, G. Muller, and C. Cowan. </author> <title> Declarative specialization of object-oriented programs. </title> <booktitle> In Proceedings of the OOPSLA Conference, </booktitle> <year> 1996. </year>
Reference-contexts: Continual queries emphasize on effective and specialized support for personalized update monitoring. For readers who are familiar with the program specialization systems <ref> [29, 22] </ref>, popular in OS and PL communities, there is a close analogy between continual queries and program specialization.
Reference: [30] <author> J. Widom and S. Ceri. </author> <title> Active Datanase Systems. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Thirdly, although situation monitoring is one of the canonical applications of ECA rules, they are designed as building blocks for general purpose active database systems or production rule systems <ref> [30] </ref> in centralized data 6 management systems, whereas continual queries are specifically designed for update monitoring in distributed push-enabled data management systems. Continual queries emphasize on effective and specialized support for personalized update monitoring. <p> to an open information universe as the Internet, these assumptions no longer hold (see [14] for a summary of desired system properties in the Internet), and some of the techniques do not easily extend to scale up to the distributed interoperable environment. 21 Active Databases: Most of active database systems <ref> [30] </ref> provide facilities [6, 21, 25] that allow users to specify, in the form of rules, actions to be performed following changes of database state.
Reference: [31] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The study on distributed materialized view management has been primarily focused on determining the optimal refresh sources and timing for multiple views defined on the same base data [26]. Other works on distributed environments include quasi-copies for replication [2] and update anomalies in data warehouses <ref> [31] </ref> Commercial database triggers Conceptually a database (built-in) trigger is an event-condition-action (ECA) rule in a restrictive form. Commercial DBMSs have been introducing support for database triggers at various levels, mainly due to the customers' need for better support for integrity constraints.
References-found: 31

