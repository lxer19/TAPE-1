URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/hypotheticals/thesis.ps
Refering-URL: http://www.cs.toronto.edu/~bonner/papers.html
Root-URL: http://www.cs.toronto.edu
Title: HYPOTHETICAL REASONING IN DEDUCTIVE DATABASES  Written under the direction of  
Author: BY ANTHONY J. BONNER L. Thorne McCarty and Tomasz Imielinski 
Degree: A dissertation submitted to the Graduate School|New Brunswick  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  and approved by  
Date: October, 1991  
Note: Graduate Program in Computer Science  
Address: New Jersey  Brunswick, New Jersey  
Affiliation: Rutgers, The State University of  New  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> A Transaction Language Complete for Database Update Specification. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 260-268, </pages> <year> 1987. </year> <note> Published in expanded form as Rapports de Recherche no. 715, </note> <institution> INRIA, </institution> <address> 78153 Le Chesnay Cedex, France. </address>
Reference-contexts: The expressibility result for PSPACE is particularly interesting, because it establishes a strong connection between an important complexity class, polynomial space, and a well-known logic, intuitionistic logic. Other database languages have been developed that are expressively complete for PSPACE <ref> [1, 2] </ref>, but the language of hypothetical insertion is unique in being a declarative language based on a well-established logic. It is also unique in having a practical, top-down proof procedure based on unification, in the logic-programming tradition [38].
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <type> Technical Report 900, </type> <institution> Institut National de Recherche en Informatique et en Au-tomatique (INRIA), </institution> <address> Le Chesnay Cedex, France, </address> <year> 1988. </year>
Reference-contexts: The expressibility result for PSPACE is particularly interesting, because it establishes a strong connection between an important complexity class, polynomial space, and a well-known logic, intuitionistic logic. Other database languages have been developed that are expressively complete for PSPACE <ref> [1, 2] </ref>, but the language of hypothetical insertion is unique in being a declarative language based on a well-established logic. It is also unique in having a practical, top-down proof procedure based on unification, in the logic-programming tradition [38].
Reference: [3] <author> A.V. Aho and J.D. Ullman. </author> <title> Universality of Data Retrieval Languages. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages (POPL), </booktitle> <pages> pages 110-120, </pages> <address> San Antonio, TX, </address> <month> Jan. </month> <year> 1979. </year>
Reference: [4] <author> K.R. Apt, H.A. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 2, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Perhaps the best known of these classes is the stratified rulebases. These rulebases are layered, and within each layer, a negated premise refers only to rules found in the layers below <ref> [4] </ref>. In this way, recursion never occurs through a negated premise and the semantics of negation is always well-defined. This chapter extends the theory of stratified negation from Horn rules to hypothetical rules. First, the notion of a stratified hypothetical rulebase is defined. <p> This procedure also has a natural counterpart in the operational semantics of stratified Horn rulebases <ref> [4] </ref>. In both cases, the procedure constructs a preferred fixpoint. Indeed, it is not hard to see that if M = FIXPOINT (R), then M is a fixpoint of V R . In general, there may be many ways to stratify a rulebase R. <p> In particular, we show that the value of the procedure FIXPOINT depends only on the rulebase R and not on the particular stratification used. The development presented here is an adaptation of that given in <ref> [4] </ref> for the semantics of stratified Horn rulebases. First, we divide R into disjoint "clusters", that is, maximal sets of rules which are mutually recursive. Second, we show that any stratification of a rulebase is equivalent to a cluster stratification, in which each stratum consists of a single cluster. <p> Furthermore, if R 0 ; :::; R k is a stratification of R, then each cluster of R is contained in some stratum R i . Each stratum therefore consists of a disjoint union of clusters. Similar results were established for Horn rules in <ref> [4] </ref>. Clusters are a convenient device for hiding recursion from our theoretical development. There is no recursion between clusters; and because each cluster lies within a single stratum, there is no need to look within a cluster. Clusters thus serve as the "atomic units" of our analysis.
Reference: [5] <author> K.R. Apt and M.H. Van Emden. </author> <title> Contributions to the Theory of Logic Programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: In this way, just as Datalog provides a concise notation for describing large databases, Datalog with substitution provides a concise notation for describing large rulebases. This conciseness is achieved by reusing and modifying rule sets, possibly many times. As in the theory of Horn logic <ref> [48, 5] </ref>, we complement the model-theoretic semantics with a fixpoint semantics. We define a monotonic "T-operator" which can be applied to a rulebase in a bottom-up fashion, generating the minimal model (or least fixpoint) piece-by-piece. <p> For this reason, the minimal model is central to the model theory of predicate substitution, and it is the focus of this section. In Horn logic, a central feature of the fixpoint theory is a lattice of classical, first-order structures <ref> [48, 5] </ref>. Viewing first-order structures as a lattice simplifies the theoretical development, since the main results are a consequence of the lattice-theoretic properties of Horn rules.
Reference: [6] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An Amateur's Introduction to Recursive Query Processing Strategies. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 16-52, </pages> <address> Washington, D.C., </address> <month> May 28-30 </month> <year> 1986. </year>
Reference-contexts: Informally, a rule is linear iff recursion occurs through only one premise. In Horn-clause logic, "linear rules play an important role because, (i) there is a belief that most `real life' recursive rules are linear, and (ii) algorithms have been developed to handle them efficiently" <ref> [6] </ref>. The main result of this chapter is that linearity reduces the complexity of the logic of hypothetical additions from PSPACE to NP in the negation-free case. (The next chapter studies the interaction between linearity and negation.) In defining linear recursion for hypothetical rules, we generalize the definition given in [6] <p> <ref> [6] </ref>. The main result of this chapter is that linearity reduces the complexity of the logic of hypothetical additions from PSPACE to NP in the negation-free case. (The next chapter studies the interaction between linearity and negation.) In defining linear recursion for hypothetical rules, we generalize the definition given in [6] for Horn rules.
Reference: [7] <author> A.J. Bonner. </author> <title> A Logic for Hypothetical Reasoning. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <address> Saint Paul, Minnesota, </address> <month> August 21-26 </month> <year> 1988. </year> <booktitle> American Association for Artificial Intelligence (AAAI). </booktitle>
Reference: [8] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and Expressibility. </title> <booktitle> In Proceedings of the International Conference on Database Theory (ICDT), </booktitle> <pages> pages 144-160. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <note> Published as volume 326 of Lecture Notes in Computer Science. </note>
Reference-contexts: Conversely, he is eligible for a stipend only if it succeeds. 2 This example, taken from [12], is an improvement by McCarty on an example originally due to Bonner <ref> [8, 10] </ref>. 71 Note that this hypothetical test is vacuously true if grad (s) is true (as long as there exists a course somewhere in the database!). <p> This is assumption is sometimes used in the literature to achieve expressive completeness [29, 49, 17]. For hypothetical logics, however, if there 1 This chapter elaborates on material that originally appeared in <ref> [8] </ref> and [10]. 97 is no a-priori order on the domain, then an order can be generated by the rulebase and inserted into the database hypothetically. This technique is central to the expressibility results of this chapter.
Reference: [9] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Negation and Linear Recursion. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 286-300, </pages> <address> Philadelphia, PA, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: Note that mutual recursiveness is an equivalence relation. In Example 6.2, the predicates EVEN and ODD are mutually recursive. In Section 2.3.2, the predicates ZERO and ONE are mutually recursive. 1 This chapter elaborates on material that originally appeared in <ref> [9] </ref>. 2 It is worth comparing the definition of mutually recursive predicates given here to the definition of mutually recursive rules given in Section 5.3. 122 Definition 7.2 (Linearity) Let r be a rule in a rulebase R. (i) r is recursive iff it has at least one goal predicate Q <p> It is based on the idea of an oracle Turing-machine [26] and can be defined recursively as follows: * P 0 = P k+1 = NP P k = those languages accepted in non-deterministic polynomial time 1 This chapter elaborates on material that originally appeared in <ref> [9] </ref>. 133 by an oracle machine whose oracle is a language in P k . k+1 = P P k = those languages accepted in deterministic polynomial time by an oracle machine whose oracle is a language in P k . * PHIER = [ k P k It is well
Reference: [10] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and Expressibility. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year> <note> Special issue on the 2 nd International Conference on Database Theory (ICDT). Also appears, </note> <editor> in abridged form, </editor> <booktitle> in volume 326 of Lecture Notes in Computer Science, </booktitle> <pages> pages 144-160. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year> <month> 230 </month>
Reference-contexts: For instance, given the two rules A B and B A, it is unclear whether A is to be inferred, or B, or both, or neither. Because there is no consensus on how such rulebases should be 1 Much of this chapter originally appeared in <ref> [10] </ref>. 70 treated, classes of Horn rulebases have been identified in which such problems do not arise. Perhaps the best known of these classes is the stratified rulebases. These rulebases are layered, and within each layer, a negated premise refers only to rules found in the layers below [4]. <p> Conversely, he is eligible for a stipend only if it succeeds. 2 This example, taken from [12], is an improvement by McCarty on an example originally due to Bonner <ref> [8, 10] </ref>. 71 Note that this hypothetical test is vacuously true if grad (s) is true (as long as there exists a course somewhere in the database!). <p> This is assumption is sometimes used in the literature to achieve expressive completeness [29, 49, 17]. For hypothetical logics, however, if there 1 This chapter elaborates on material that originally appeared in [8] and <ref> [10] </ref>. 97 is no a-priori order on the domain, then an order can be generated by the rulebase and inserted into the database hypothetically. This technique is central to the expressibility results of this chapter.
Reference: [11] <author> A.J. Bonner and T. Imielinski. </author> <title> The Reuse and Modification of Rulebases by Predicate Substitution. </title> <booktitle> In Proceedings of the International Conference on Extending Database Technology (EDBT), </booktitle> <pages> pages 437-451, </pages> <address> Fondazione Cini, Venice, Italy, </address> <month> March 26-30 </month> <year> 1990. </year>
Reference-contexts: In this way, a user is forced to rewrite rulebases if he wants to apply them to different sets of data. 1 This chapter elaborates on material that originally appeared in <ref> [11] </ref>. 157 Predicate substitution carries out this rewriting automatically. For instance, to compute the transitive closure of S, the user specifies that S be substituted for R in the two rules above. <p> Second, in Section 9.5.2, we consider alternating string transformations. We illustrate the idea by encoding the computations of an alternating PSPACE machine in a Datalog rulebase with substitution. For another illustration of the power of predicate substitution, we refer the interested reader to <ref> [11] </ref>, where we use Datalog with substitution to solve the problem of propositional satisfiability. 182 9.5.1 Solving a PSPACE-complete Problem In this section, we show that Datalog with substitution can solve a PSPACE-complete problem. <p> Each application of the operator expands rules with substitution into equivalent Horn rules. If there is recursion through substitution, it may take infinitely many applications to generate all the Horn rules in the minimal 1 This chapter elaborates on material that originally appeared in <ref> [11] </ref>. 196 model. Because the operator is continuous, however, any particular Horn rule will be generated in a finite number of applications. In this way, the Horn rules represented by a rulebase with substitution can be materialized.
Reference: [12] <author> A.J. Bonner and L.T. McCarty. </author> <title> Adding Negation-as-Failure to Intuitionistic Logic Programming. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 681-703, </pages> <address> Austin, Texas, </address> <month> Oct 29-Nov 1 </month> <year> 1990. </year>
Reference-contexts: Conversely, he is eligible for a stipend only if it succeeds. 2 This example, taken from <ref> [12] </ref>, is an improvement by McCarty on an example originally due to Bonner [8, 10]. 71 Note that this hypothetical test is vacuously true if grad (s) is true (as long as there exists a course somewhere in the database!). <p> In particular, if a rulebase is divided into strata R 0 ; R 1 :::R k , it is not possible to decompose 3 For the restricted logic of hypothetical additions, the meaning of stratified rulebases can also be defined in terms of intuitionistic logic. See <ref> [12] </ref> for details. 73 T R into separate operators T R 0 ; T R 1 :::T R k . This section solves this problem for negation-free rulebases. The main idea is to introduce a new operator V R that is an inflationary version of T R .
Reference: [13] <author> A.J. Bonner, L.T. McCarty, and K. Vadaparty. </author> <title> Expressing Database Queries with Intuitionistic Logic. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 831-850, </pages> <address> Cleveland, Ohio, </address> <month> October 16-20 </month> <year> 1989. </year>
Reference: [14] <author> A.K. Chandra. </author> <title> Theory of Database Queries. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 1-9, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference: [15] <author> A.K. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: This section provides these definitions. It is then shown that hypothetical rulebases without constant symbols are guaranteed to express only generic queries. The first step is to give a precise definition of "relational database". The following 102 definition is due to Chandra and Harel <ref> [15, 16] </ref>. Definition 6.1 Let U be a countable set, called the universal data domain. <p> A renaming can be extended to tuples, relations and databases in the obvious way. In particular, if DB is a database, then f DB denotes the renamed database. With this in mind, we give the following definition, which is due to Chandra and Harel <ref> [15, 16] </ref>. Definition 6.2 A generic database query of type ff ! ff 0 is a partial function which takes a relational database DB of type ff and returns a relation (DB) over dom (DB ) of arity ff 0 .
Reference: [16] <author> A.K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <booktitle> In Proceedings of the Symposium on the Foundations of Computer Science (FOCS), </booktitle> <pages> pages 333-347, </pages> <year> 1980. </year>
Reference-contexts: Augmenting a logic with negation-as-failure gives it the power to express such queries. Example 6.1, for instance, shows that EVEN can be expressed as a stratified rulebase of hypothetical additions and deletions. (It is worthwhile noting that EVEN cannot be expressed in Datalog even when stratified negation is allowed <ref> [16, 17] </ref>.) The operation of this rulebase is best viewed as top-down. From this perspective, the first two rules select and remove elements one-by-one from the database relation D. <p> This section provides these definitions. It is then shown that hypothetical rulebases without constant symbols are guaranteed to express only generic queries. The first step is to give a precise definition of "relational database". The following 102 definition is due to Chandra and Harel <ref> [15, 16] </ref>. Definition 6.1 Let U be a countable set, called the universal data domain. <p> A renaming can be extended to tuples, relations and databases in the obvious way. In particular, if DB is a database, then f DB denotes the renamed database. With this in mind, we give the following definition, which is due to Chandra and Harel <ref> [15, 16] </ref>. Definition 6.2 A generic database query of type ff ! ff 0 is a partial function which takes a relational database DB of type ff and returns a relation (DB) over dom (DB ) of arity ff 0 . <p> Then, as part of the compound machine, each invocation of M i runs in non-deterministic time O [n (l i ++l k ) ], where n is the length of s. Thus, any invocation of any of the M i runs 3 See <ref> [16] </ref> for examples of such languages. 142 in non-deterministic time O (n l ), where l = l 1 + + l k .
Reference: [17] <author> A.K. Chandra and D. Harel. </author> <title> Horn Clauses and the Fixpoint Query Hierarchy. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 158-163, </pages> <year> 1982. </year>
Reference-contexts: It is worthwhile pointing out that these results are achieved without assuming a linear order on the data domain. This is assumption is sometimes used in the literature to achieve expressive completeness <ref> [29, 49, 17] </ref>. For hypothetical logics, however, if there 1 This chapter elaborates on material that originally appeared in [8] and [10]. 97 is no a-priori order on the domain, then an order can be generated by the rulebase and inserted into the database hypothetically. <p> Augmenting a logic with negation-as-failure gives it the power to express such queries. Example 6.1, for instance, shows that EVEN can be expressed as a stratified rulebase of hypothetical additions and deletions. (It is worthwhile noting that EVEN cannot be expressed in Datalog even when stratified negation is allowed <ref> [16, 17] </ref>.) The operation of this rulebase is best viewed as top-down. From this perspective, the first two rules select and remove elements one-by-one from the database relation D.
Reference: [18] <author> A.K. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generlizations. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 2(1) </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference: [19] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: Evidence suggests that alternation increases the power of a machine. For instance, alternation gives PSPACE machines the power of EXPTIME machines. That is, APSPACE = EXPTIME <ref> [19] </ref>. By encoding the computations of APSPACE machines, we can therefore solve EXPTIME-complete problems. We used alternating machines in Chapter 4 to establish lower bounds on the complexity of hypothetical insertion and deletion. <p> We can therefore represent the transition relation of a machine as two functions f 1 and f 2 . As before, these functions specify string transformations. Formally, a string a 1 :::a n 8 See <ref> [19] </ref> for examples of such languages. 191 has two successors b 1 1 :::b 1 1 :::b 2 n where b i b i b i Thus, as before, the end points of the string do not change, and the interior points are transformed by the functions f 1 and f
Reference: [20] <author> A.K. Chandra and L.J. Stockmeyer. </author> <title> Alternation. </title> <booktitle> In Proceedings of the Symposium on the Foundations of Computer Science (FOCS), </booktitle> <pages> pages 98-108, </pages> <year> 1976. </year>
Reference: [21] <author> B.F. Chellas. </author> <title> Modal Logic: an Introduction. </title> <publisher> Cambridge University Press, </publisher> <year> 1980. </year>
Reference: [22] <author> M.C. </author> <title> Fitting. Intuitionistic Logic, Model Theory and Forcing. </title> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference: [23] <author> The Committee for Advanced DBMS function. </author> <title> Third-Generation Database System Manifesto. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(3) </volume> <pages> 31-44, </pages> <month> September </month> <year> 1990. </year> <note> Also published as Memorandum No. </note> <institution> UCB/ERL M90/28, Electronics Research Laboratory, College of Engineering, University of California, Berkeley. </institution>
Reference: [24] <author> D.M. Gabbay. N-Prolog: </author> <title> an Extension of Prolog with Hypothetical Implications. II. Logical Foundations and Negation as Failure. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(4) </volume> <pages> 251-283, </pages> <year> 1985. </year>
Reference: [25] <editor> D.M. Gabbay and U. Reyle. N-Prolog: </editor> <title> an Extension of Prolog with Hypothetical Implications. I. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 1(4) </volume> <pages> 319-355, </pages> <year> 1984. </year> <month> 231 </month>
Reference: [26] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: introduction of the time variable t. The rest of this section describes these differences. 5 See <ref> [26] </ref> for examples of such languages. 65 4.4.1 The Database DB (s) and the Rulebase R (M ) Because time is now represented explicitly, the database can encode more than a single machine id. In fact, it can encode a sequence of id's, that is, a computation path. <p> This computation can be done in polynomial space. Thus, the entire computation, including guesses, runs in non-deterministic polynomial space. Inference for the logic of hypothetical additions is therefore in NPSPACE. Inference is therefore in PSPACE, since PSPACE = NPSPACE, by Savitch's Theorem <ref> [26] </ref>. 4 This was originally proved in Section 4.2. 132 Chapter 8 Negation and Linear Recursion Chapter 7 studied linear rulebases of hypothetical additions in the negation-free case. This chapter 1 studies the case with negation, i.e., stratified linear rulebases. <p> The polynomial-time hierarchy is a sequence of complexity classes between P and PSPACE. It is based on the idea of an oracle Turing-machine <ref> [26] </ref> and can be defined recursively as follows: * P 0 = P k+1 = NP P k = those languages accepted in non-deterministic polynomial time 1 This chapter elaborates on material that originally appeared in [9]. 133 by an oracle machine whose oracle is a language in P k . <p> We represent a configuration as a string in a standard way, and we represent the transition function of the machine as a string transformation. We choose this representation because it is easy to implement with Horn rules and predicate substitution. 6 See <ref> [26] </ref> for examples of such languages. 183 There are many ways to encode a machine configuration as a string. We describe a standard encoding that is convenient for the purpose of this section.
Reference: [27] <author> G.E. Hughes and M.J. Cresswell. </author> <title> An Introduction to Modal Logic. </title> <publisher> Methuen and Co. Ltd., </publisher> <address> London, </address> <year> 1968. </year>
Reference: [28] <author> Richard Hull and Jianwen Su. </author> <title> On the Expressive Power of Database Queries with Intermediate Types. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 39-51, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference: [29] <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <booktitle> In Proceedings of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 147-152, </pages> <year> 1982. </year>
Reference-contexts: It is worthwhile pointing out that these results are achieved without assuming a linear order on the data domain. This is assumption is sometimes used in the literature to achieve expressive completeness <ref> [29, 49, 17] </ref>. For hypothetical logics, however, if there 1 This chapter elaborates on material that originally appeared in [8] and [10]. 97 is no a-priori order on the domain, then an order can be generated by the rulebase and inserted into the database hypothetically. <p> The rest of this section proves Theorem 6.3. The proof relies on the Turing machine simulations developed in Section 4.4. In this respect, it is similar to other expressibility proofs in the literature (e.g., <ref> [29, 49] </ref>). One difference, however, is that the results presented here do not assume that the data domain is linearly ordered. Linear orders are typically used to simulate counters, which in turn, are used to simulate the movement of Turing-machine tape heads. <p> In fact, by using predicates of arity k, a counter from 0 to n k 1 can be constructed in a straightforward way. For this reason, the assumption of a linearly ordered domain is sometimes used in the literature <ref> [29, 49] </ref>, especially when expressibility results are established in terms of complexity classes, as in Lemma 6.5. With hypothetical rules, however, this assumption is unnecessary. This section provides a set of hypothetical rules which "guess" a linear order and hypothetically add it to the database.
Reference: [30] <author> N. Immerman. </author> <title> Languages that Capture Complexity Classes. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16(4) </volume> <pages> 760-778, </pages> <year> 1987. </year>
Reference-contexts: Using these results, we obtain an exact characterization of the database queries at each level in the hierarchy. Finally, using a well-known connection between the polynomial time hierarchy and second order logic <ref> [30] </ref>, we show that stratified linear rulebases without constant symbols express exactly the second-order definable queries. The polynomial-time hierarchy is a sequence of complexity classes between P and PSPACE. <p> Thus, stratified linear rulebases that are constant free express exactly the generic queries in PHIER. This gives an exact characterization of the database queries in PHIER. In addition, Immerman has shown that the generic queries in PHIER are exactly the queries definable in second-order logic <ref> [30] </ref>. Therefore, stratified linear rulebases without constant symbols express exactly the second-order definable queries. Besides characterizing the queries in PHIER, we also characterize the queries in P k . This characterization is based on the set R 3 k , defined at the beginning of this chapter. <p> Corollary 8.6 Linear rulebases of hypothetical additions that are constant free express exactly the typed generic queries in PHIER. Immerman has shown that the typed generic queries in PHIER are precisely the queries definable in second-order logic <ref> [30] </ref>. This gives us another characterization of the queries expressed by stratified linear rulebases. Corollary 8.7 Stratified linear rulebases of hypothetical additions that are constant free express exactly the second-order definable queries. 156 Chapter 9 Predicate Substitution This chapter 1 develops a method for reusing and modifying deductive databases.
Reference: [31] <editor> R.H. Sprague Jr. and H.J. Watson, editors. </editor> <title> Decisions Support Systems: Putting Theory into Practice. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference: [32] <author> R. Kowalski. </author> <title> Logic for Problem Solving. </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: The greater part of an id, however, remains unchanged by such transitions. Indeed, except for the tape cell under the tape head, the contents of all tape cells are unchanged. This is an instance of the frame axiom <ref> [32] </ref>, and we must write rules to encode it. Such rules are necessary only because we are representing time explicitly; i.e., the database represents a sequence of id's, and rules are needed to copy the unchanged portion of an id from one instant of time to the next. <p> The greater part of an id, however, remains unchanged by such transitions. Indeed, except for those cells under the tape heads, the contents of the machine tapes remain unchanged. This is an instance of the frame axiom <ref> [32] </ref>, and we must write rules to encode it. Such rules are necessary only because we are representing time explicitly; i.e., the database represents a sequence of id's, and rules are needed to copy the unchanged portion of an id from one instant of time to the next. <p> In Horn logic programming, negation-as-failure normally plays a central role in any encoding of the frame axiom <ref> [32] </ref>. We do not have this luxury however. The rulebase R (L) which we are constructing must have no more than k strata, and we have already created k of them, one for each oracle machine. Any attempt to use negation-as-failure will add new strata to the rulebase.
Reference: [33] <author> S. Kripke. </author> <title> Semantical Analysis of Intuitionistic Logic. </title> <editor> I. In J.N. Crossley and M.A.E. Dummett, editors, </editor> <booktitle> Formal Systems and Recursive Functions, </booktitle> <pages> pages 92-130. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1965. </year>
Reference: [34] <author> S. Manchanda and D.S. Warren. </author> <title> A Logic-based Language for Database Updates. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 10, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference: [35] <author> Sanjay Manchanda. </author> <title> A Dynamic Logic Programming Language for Relational Updates. </title> <type> PhD thesis, </type> <institution> The University of Arizona, Tuscon, Arizona 85721, </institution> <month> January </month> <year> 1988. </year>
Reference: [36] <author> J. McCarthy and P. Hayes. </author> <title> Some Philosophical Problems from the Standpoint of Artifical Intelligence. </title> <editor> In B. Meltzer and D. Mitchie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <note> Reprinted in "Readings in AI". </note>
Reference-contexts: Of course, during any step of a computation, most characters in a configuration do not change. Thus f (x; y; z) = y as long as x, y and z represent tape characters, not control states. This is an instance of the frame axiom <ref> [36] </ref>. In Chapters 4 and 8, we carefully encoded the frame axiom in the rulebase. That is unnecessary here since the frame axiom is encoded in the function f instead.
Reference: [37] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. I. Fixed-Point Semantics. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(1) </volume> <pages> 1-31, </pages> <year> 1988. </year>
Reference: [38] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. II. Tableau Proof Procedures. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(2) </volume> <pages> 93-132, </pages> <year> 1988. </year>
Reference-contexts: It is also unique in having a practical, top-down proof procedure based on unification, in the logic-programming tradition <ref> [38] </ref>.
Reference: [39] <author> L.T. McCarty and N.S. Sridharan. </author> <title> The Representation of an Evolving System of Legal Concepts. II. Prototypes and Deformations. </title> <booktitle> In Proceedings of the Seventh IJCAI, </booktitle> <pages> pages 246-253, </pages> <year> 1981. </year>
Reference-contexts: Such systems have a variety of applications, such as computer-based medical and legal consultation systems. Kowalski and Sergot, for instance, have encoded the British Nationality Act in Prolog, and McCarty and Sridharan have developed expert systems for reasoning about contract law and corporate tax law <ref> [39] </ref>. As laws are amended, such systems have to be updated. For instance, sections of the income tax act could be amended to treat residents as citizens. In this case, every occurrence of "citizen" could be replaced by a new predicate meaning "citizen or resident".
Reference: [40] <author> D. Miller. </author> <title> A Logical Analysis of Modules in Logic Programming. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 6 </volume> <pages> 79-108, </pages> <year> 1989. </year>
Reference: [41] <author> G. Nadathur and D. Miller. </author> <title> An Overview of Prolog. </title> <editor> In R.A. Kowalski and K.A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <pages> pages 810-827, </pages> <address> Cambridge, MA, 1988. </address> <publisher> MIT Press. </publisher> <pages> 232 </pages>
Reference: [42] <author> R.L. Olson and R.H. Sprague Jr. </author> <title> Financial Planning in Action. </title> <editor> In R.H. Sprague Jr. and H.J. Watson, editors, </editor> <booktitle> Decisions Support Systems: Putting Theory into Practice, </booktitle> <pages> pages 373-381. </pages> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference: [43] <editor> Editor: A.P. Seth. </editor> <booktitle> Database Research at Bellcore. SIGMOD Record, </booktitle> <volume> 19(3) </volume> <pages> 45-52, </pages> <month> September </month> <year> 1990. </year>
Reference: [44] <author> R. Statman. </author> <title> Intuitionistic Propositional Logic is Polynomial-Space Complete. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 9(1) </volume> <pages> 67-72, </pages> <year> 1979. </year>
Reference: [45] <author> M. Stonebraker. </author> <title> Hypothetical databases as views. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 224-229, </pages> <year> 1981. </year>
Reference: [46] <author> M. Stonebraker and K. Keller. </author> <title> Embedding expert knowledge and hypothetical databases into a data base system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 58-66, </pages> <address> Santa Monica, CA, </address> <year> 1980. </year>
Reference: [47] <author> A. Tarski. </author> <title> A Lattice-Theoretical Fixpoint Theorem and its Applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: Proof: A straightforward consequence of the monotonicity and continuity of T R (Lemmas 3.9 and 3.16). 2 V R thus has a least fixpoint, lfp (V R ), which is identical to the least fixpoint of T R . Furthermore, by the Tarski fixpoint theorem <ref> [47] </ref>, this least fixpoint can be computed in a bottom-up way. That is, lfp (V R ) = V fl R (I). The proof is parallel to that of Theo rem 3.18. Thus, the two bottom-up computations V fl R (I) and T fl R (I) produce identical results. <p> Two other important properties of this operator are its monotonicity and continuity. Once these two properties are established, the main results of this section can be proved by lattice theory, and in particular, by invoking Tarski's fixpoint theorem in the usual way <ref> [47] </ref>. The first main result is that a rulebase with substitution has a unique minimal model. As in Horn logic, the minimal model is canonical in that the formulas satisfied in the minimal model are exactly the formulas entailed by the rulebase. <p> Thus every rule in T S (R 1 ) is also in T S (R 2 ). 2 Since T S is a monotonic operator on a complete lattice, it has a unique minimal fixpoint. This result is due to Tarski <ref> [47] </ref>, whose proof we reproduce below. Theorem 10.18 The operator T S has a least fixpoint lfp (T S ). That is, lfp (T S ) R for all fixpoints R of T S . Proof: Let R be the set of fixpoints of T S . <p> The main result of this section is that this sequence converges to the least fixpoint of T S . This result follows from the monotonicity and continuity of the operator T S , as shown by Tarski <ref> [47] </ref>. Theorem 10.22 T fl S (fg) j lfp (T S ) Proof: The empty rulebase fg is the least element in the lattice of rulebases. Therefore fg lfp (T S ).
Reference: [48] <author> M.H. Van Emden and R.A. Kowalski. </author> <title> The Semantics of Predicate Logic as a Programming Language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: In this way, just as Datalog provides a concise notation for describing large databases, Datalog with substitution provides a concise notation for describing large rulebases. This conciseness is achieved by reusing and modifying rule sets, possibly many times. As in the theory of Horn logic <ref> [48, 5] </ref>, we complement the model-theoretic semantics with a fixpoint semantics. We define a monotonic "T-operator" which can be applied to a rulebase in a bottom-up fashion, generating the minimal model (or least fixpoint) piece-by-piece. <p> For this reason, the minimal model is central to the model theory of predicate substitution, and it is the focus of this section. In Horn logic, a central feature of the fixpoint theory is a lattice of classical, first-order structures <ref> [48, 5] </ref>. Viewing first-order structures as a lattice simplifies the theoretical development, since the main results are a consequence of the lattice-theoretic properties of Horn rules.
Reference: [49] <author> M. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference-contexts: It is worthwhile pointing out that these results are achieved without assuming a linear order on the data domain. This is assumption is sometimes used in the literature to achieve expressive completeness <ref> [29, 49, 17] </ref>. For hypothetical logics, however, if there 1 This chapter elaborates on material that originally appeared in [8] and [10]. 97 is no a-priori order on the domain, then an order can be generated by the rulebase and inserted into the database hypothetically. <p> The rest of this section proves Theorem 6.3. The proof relies on the Turing machine simulations developed in Section 4.4. In this respect, it is similar to other expressibility proofs in the literature (e.g., <ref> [29, 49] </ref>). One difference, however, is that the results presented here do not assume that the data domain is linearly ordered. Linear orders are typically used to simulate counters, which in turn, are used to simulate the movement of Turing-machine tape heads. <p> In fact, by using predicates of arity k, a counter from 0 to n k 1 can be constructed in a straightforward way. For this reason, the assumption of a linearly ordered domain is sometimes used in the literature <ref> [29, 49] </ref>, especially when expressibility results are established in terms of complexity classes, as in Lemma 6.5. With hypothetical rules, however, this assumption is unnecessary. This section provides a set of hypothetical rules which "guess" a linear order and hypothetically add it to the database.
Reference: [50] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> A Short Overview. </title> <booktitle> Presented at the AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <address> July 1990, Boston, USA. </address>
Reference: [51] <author> D.S. Warren. </author> <title> Database Updates in Pure Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244-253, </pages> <year> 1984. </year> <month> 233 </month>
References-found: 51

