URL: ftp://ftp.cs.columbia.edu/reports/reports-1994/cucs-010-94.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1994.html
Root-URL: http://www.cs.columbia.edu
Email: li@cs.columbia.edu kar@cs.columbia.edu  
Title: Better Semijoins Using Tuple Bit-Vectors  
Author: Zhe Li Kenneth A. Ross 
Address: New York, NY 10027 New York, NY 10027  
Affiliation: Computer Science Department Computer Science Department Columbia University Columbia University  
Abstract: Technical Report No. CUCS-010-94 April 10, 1994 Abstract This paper presents the idea of "tuple bit-vectors" for distributed query processing. Using tuple bit-vectors, a new two-way semijoin operator called 2SJ++ that enhances the semijoin with an essentially "free" backward reduction capability is proposed. We explore in detail the benefits and costs of 2SJ++ compared with other semijoin variants, and its effect on distributed query processing performance. We then focus on one particular distributed query processing algorithm, called the "one-shot" algorithm. We modify the one-shot algorithm by using 2SJ++ and demonstrate the improvements achieved in network transmission cost compared with the original one-shot technique. We use this improvement to demonstrate that equipped with the 2SJ++ technique, one can improve the performance of distributed query processing algorithms significantly without adding much complexity to the algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [AHY83] <author> P.M.G. Apers, A.R. Hevner, and S.B. Yao. </author> <title> Optimization algorithm for distributed queries. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-9:57-68, </volume> <year> 1983. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Semijoins are one possible step in a distributed query processing algorithm. Much work had been done on optimizing the cost of distributed query processing using various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most of them can be classified as semijoin based, and a distributed query is typically processed in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
Reference: [Bab79] <author> E. Babb. </author> <title> Implementing a relational database by means of specialized hardware. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(1) </volume> <pages> 1-29, </pages> <year> 1979. </year>
Reference-contexts: The cost of applying a hash function is negligible. * The network cost is measured as the number of bytes transmitted. 3 Tuple Bit Vectors In this section we describe several semijoin techniques and extend them using the tuple bit-vector idea. 4 3.1 Hash Filters Hash filters were introduced in <ref> [Blo70, Bab79] </ref> and promoted later in [Mul83, Mul90, Qad88]. A hash filter is a bit vector used to encode the joining relationship.
Reference: [BC81] <author> P.A. Bernstein and D.M. Chiu. </author> <title> Using semi-joins to solve relational queries. </title> <journal> J.ACM, </journal> <volume> 28(1) </volume> <pages> 25-40, </pages> <year> 1981. </year>
Reference-contexts: Thus, distributed query processing strategies should attempt to minimize the amount of data transmitted over the network. A popular technique for reducing network transmission volume is the use of semijoins. Semijoins were introduced in <ref> [BC81, BG81] </ref>. Suppose two relations R and S are stored at different sites.
Reference: [BG81] <author> P.A. Bernstein and N. Goodman. </author> <title> The power of natural joins. </title> <journal> SIAM J. Computi., </journal> <volume> 10 </volume> <pages> 751-771, </pages> <year> 1981. </year>
Reference-contexts: Thus, distributed query processing strategies should attempt to minimize the amount of data transmitted over the network. A popular technique for reducing network transmission volume is the use of semijoins. Semijoins were introduced in <ref> [BC81, BG81] </ref>. Suppose two relations R and S are stored at different sites.
Reference: [Blo70] <author> Burton H. Bloom. </author> <title> Space/time trade-offs in hash coding with allowable errors. </title> <journal> Communications of the ACM, </journal> <volume> 13(7) </volume> <pages> 422-426, </pages> <year> 1970. </year>
Reference-contexts: The cost of applying a hash function is negligible. * The network cost is measured as the number of bytes transmitted. 3 Tuple Bit Vectors In this section we describe several semijoin techniques and extend them using the tuple bit-vector idea. 4 3.1 Hash Filters Hash filters were introduced in <ref> [Blo70, Bab79] </ref> and promoted later in [Mul83, Mul90, Qad88]. A hash filter is a bit vector used to encode the joining relationship.
Reference: [CY93] <author> Ming-Syan Chen and Philip S. Yu. </author> <title> Combining join and semi-join operations for distributed query procesing. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(3) </volume> <pages> 534-542, </pages> <year> 1993. </year> <title> 1 Considering only the network cost. </title> <type> 12 </type>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Semijoins are one possible step in a distributed query processing algorithm. Much work had been done on optimizing the cost of distributed query processing using various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most of them can be classified as semijoin based, and a distributed query is typically processed in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
Reference: [Dan82] <author> D Daniels. </author> <title> Query compilation in a distributed database system. </title> <institution> IBM Res. </institution> <type> Rep. RJ 3423, </type> <institution> IBM, </institution> <year> 1982. </year>
Reference-contexts: If the hash filter can fit into the receiving site's memory, we need only scan the receiving relation once to perform hashing and produce the semijoin result. 3.2 Two-Way Semijoins The two-way semijoin (henceforth referred to as 2SJ) was introduced in <ref> [Dan82] </ref> and later promoted in [Seg86].
Reference: [ESW78] <author> R. Epstein, M. Stonebraker, and E. Wong. </author> <title> Distributed query processing in a relational database system. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 169-180, </pages> <year> 1978. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Semijoins are one possible step in a distributed query processing algorithm. Much work had been done on optimizing the cost of distributed query processing using various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most of them can be classified as semijoin based, and a distributed query is typically processed in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
Reference: [HY79] <author> A.R. Hevner and S.B. Yao. </author> <title> Query processing in distributed database system. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-5(3), </volume> <year> 1979. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Semijoins are one possible step in a distributed query processing algorithm. Much work had been done on optimizing the cost of distributed query processing using various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most of them can be classified as semijoin based, and a distributed query is typically processed in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2. <p> As opposed to the traditional sequential semijoin paradigm <ref> [HY79] </ref>, this method executes all applicable semijoins to the relations in parallel. That is, each relation will be reduced by a set of semijoins at one time, i.e, in "one shot," and the semijoin processing at all sites can be performed simultaneously.
Reference: [Mul83] <author> James K. Mullin. </author> <title> A second look at bloom filters. </title> <journal> Communications of the ACM, </journal> <volume> 26(8) </volume> <pages> 570-571, </pages> <year> 1983. </year>
Reference-contexts: function is negligible. * The network cost is measured as the number of bytes transmitted. 3 Tuple Bit Vectors In this section we describe several semijoin techniques and extend them using the tuple bit-vector idea. 4 3.1 Hash Filters Hash filters were introduced in [Blo70, Bab79] and promoted later in <ref> [Mul83, Mul90, Qad88] </ref>. A hash filter is a bit vector used to encode the joining relationship. When joining R i with R j , the join attribute values of R i are hashed to some addresses in the bit vector whose corresponding bits are then set to 1.
Reference: [Mul90] <author> James K. Mullin. </author> <title> Optimal semijoins for distributed database systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(5) </volume> <pages> 558-560, </pages> <year> 1990. </year>
Reference-contexts: function is negligible. * The network cost is measured as the number of bytes transmitted. 3 Tuple Bit Vectors In this section we describe several semijoin techniques and extend them using the tuple bit-vector idea. 4 3.1 Hash Filters Hash filters were introduced in [Blo70, Bab79] and promoted later in <ref> [Mul83, Mul90, Qad88] </ref>. A hash filter is a bit vector used to encode the joining relationship. When joining R i with R j , the join attribute values of R i are hashed to some addresses in the bit vector whose corresponding bits are then set to 1.
Reference: [Qad88] <author> Ghassan Z. Qadah. </author> <title> Filter-based join algorithms on uniprocessor and distributed-memory multiprocessor database machines. </title> <booktitle> In Lecture Notes in Compure Science 303, </booktitle> <pages> pages 388-413, </pages> <year> 1988. </year>
Reference-contexts: function is negligible. * The network cost is measured as the number of bytes transmitted. 3 Tuple Bit Vectors In this section we describe several semijoin techniques and extend them using the tuple bit-vector idea. 4 3.1 Hash Filters Hash filters were introduced in [Blo70, Bab79] and promoted later in <ref> [Mul83, Mul90, Qad88] </ref>. A hash filter is a bit vector used to encode the joining relationship. When joining R i with R j , the join attribute values of R i are hashed to some addresses in the bit vector whose corresponding bits are then set to 1. <p> is D i fl jR X i j=8 which is less than the difference above if 1 + 8 fl V jR X jR X which is likely unless R X i and R X j are extremely close in size. 3.6 Compression of Hash Tables and Tuple Bit-Vectors In <ref> [Qad88] </ref>, two compression techniques were proposed to further reduce the network cost of sending hash filters. <p> The set of code pages generated by the sending site is transmitted across the network to the receiving site. The receiving site then uses the received code words to set up the hash filter. 8 The experimental data obtained in <ref> [Qad88] </ref> suggests a substantial improvement in the performance of a hybrid-hash-join algorithm implemented using hash filters after taking advantage of these two compression schemes. In addition, scheme 1 is suggested to be the best choice.
Reference: [RK91] <author> Nick Roussopoulos and Hyunchul Kang. </author> <title> A pipeline n-way join algorithm based on the 2-way semijoin program. </title> <journal> IEEE Transactions on Knowledge And Data Engineering, </journal> <volume> 3(4) </volume> <pages> 486-495, </pages> <year> 1991. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Semijoins are one possible step in a distributed query processing algorithm. Much work had been done on optimizing the cost of distributed query processing using various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most of them can be classified as semijoin based, and a distributed query is typically processed in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2. <p> Two-way semijoins are particularly useful when both relations R and S need to be transmitted to a third site, either because that is where the answer is needed, or because a third joining relation is stored at a third site. The 2SJ technique has been extended in <ref> [RK91] </ref> to send back to R's site the smaller of P S 0 and P R P S 0 . We call this improved version 2SJ+. <p> In <ref> [RK91] </ref>, an improvement of 2SJ was proposed. We denote the new operator by "2SJ+". It is implemented by modifying step (c) above to send back the smaller of P X and R X j P X . <p> Clearly, the additional transmission cost of 2SJ+ over the semijoin is bounded by half of jR X j j. In contrast, 2SJ always sends jP X j tuples during the backward reduction phase. When jP X j &gt; jR X j j=2, 2SJ+ is more effective. Lemma 2 in <ref> [RK91] </ref> shows that if the original semijoin is cost-effective, in a formally defined sense, then the 2SJ+ is also cost-effective. Moreover, the backward reduction is always cost-effective. In other words, it always pays to do the backward reduction if the initial relation is going to be transmitted to another site. <p> In the next section we show how we can reduce the cost of the backward reduction even further. 3.3 Improving 2SJ+ with Tuple Bit-Vectors We present a further improvement of 2SJ+ <ref> [RK91] </ref>. Definition 3.1: Let R be a relation whose tuples are ordered in some fashion. A tuple bit vector V R of relation R is an array of jRj bits. <p> Note that 2SJ+ does not apply in this case. 3.5 Comparing 2SJ++ with 2SJ+ and Parallel Semijoins In the following discussion we measure the cost and benefit of a semijoin as the network cost, i.e., the number of bytes transmitted and reduced. In <ref> [RK91] </ref> it is proved that the backward reduction of 2SJ+ is always cost-effective, i.e., that its benefits outweigh the costs, when the original site's relation needs to be transmitted to another site. <p> We choose the smaller of these two costs. The cost of 2SJ+ is V fl M . The cost of 2SJ++ is at most SflM 8 . Thus 2SJ++ is cheaper if 8 fl V S, and the result is proved. When combined with results from <ref> [RK91] </ref>, Lemma 3.1 states that the extension of the semijoin to the 2SJ++ semijoin is always done in a cost-effective way if 8 fl V S.
Reference: [Seg86] <author> Arie Segev. </author> <title> Optimization of join operations in horizontally partitioned database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(1) </volume> <pages> 48-80, </pages> <year> 1986. </year>
Reference-contexts: If the hash filter can fit into the receiving site's memory, we need only scan the receiving relation once to perform hashing and produce the semijoin result. 3.2 Two-Way Semijoins The two-way semijoin (henceforth referred to as 2SJ) was introduced in [Dan82] and later promoted in <ref> [Seg86] </ref>.
Reference: [WCS92] <author> Chihping Wang, Arbee L.P. Chen, and Shiow-Chen Shyu. </author> <title> A parallel execution method for minimizing distributed query response time. </title> <journal> IEEE Transactions on Parallel And Distributed Systems, </journal> <volume> 3(3) </volume> <pages> 325-333, </pages> <year> 1992. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Semijoins are one possible step in a distributed query processing algorithm. Much work had been done on optimizing the cost of distributed query processing using various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most of them can be classified as semijoin based, and a distributed query is typically processed in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2. <p> In other words, the cost of the "backward" reduction is much smaller than the cost of the "forward" reduction. We explore in detail the pros and cons of 2SJ++ compared with other semijoin variants. We then use the "one-shot" parallel distributed query processing algorithm <ref> [WCS92] </ref> as an application of 2SJ++. We use 2SJ++ within the one-shot algorithm and demonstrate 3 the improvements achieved in the network transmission cost. <p> If there are N 1-bits in the table, we prefer to send addresses rather than the whole table if N fl dlog (H)e H, i.e., if N dlog (H)e 4 Overview of the "One-Shot" Algorithm The "one-shot" algorithm was proposed in <ref> [WCS92] </ref>. As opposed to the traditional sequential semijoin paradigm [HY79], this method executes all applicable semijoins to the relations in parallel. <p> The authors of <ref> [WCS92] </ref> made the following two observations to reduce the search space for optimal query processing strategies from exponential to polynomial: 1. If B j is optimal and i 2 B j , then fhjs j j i g B j . <p> For readers interested in the correctness of the cost model and the details of the optimization algorithm, we refer to <ref> [WCS92] </ref> for further details. One potential problem with the "one-shot" algorithm is that each participating relation is not always fully reduced by the semijoin program. <p> A new two-way semijoin operator called 2SJ++ is designed which enhances the semijoin with an essentially "free" backward reduction capability. We compare 2SJ++ with other semijoin variants, and analyze its effect on distributed query processing performance. Using the "one-shot" algorithm <ref> [WCS92] </ref> as an application, we show that 2SJ++ could be used to enhance the performance of distributed query processing strategies. These observations and ideas are, in principle, also applicable to other distributed query processing algorithms, and could be easily implemented within them.
Reference: [Won77] <author> E. Wong. </author> <title> Retrieving dispersed data from sdd-1: A system for distributed databases. </title> <booktitle> In Proceedings of the 2nd Berkeley Workshop on Distributed Data Management and Computer Networks, </booktitle> <year> 1977. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Semijoins are one possible step in a distributed query processing algorithm. Much work had been done on optimizing the cost of distributed query processing using various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most of them can be classified as semijoin based, and a distributed query is typically processed in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
Reference: [YC84] <author> C.T. Yu and C. C. Chang. </author> <title> Distributed query processing. </title> <booktitle> ACM Computing Surverys, </booktitle> <pages> pages 399-433, </pages> <year> 1984. </year> <month> 13 </month>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Semijoins are one possible step in a distributed query processing algorithm. Much work had been done on optimizing the cost of distributed query processing using various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most of them can be classified as semijoin based, and a distributed query is typically processed in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
References-found: 17

