URL: http://www.cs.cmu.edu/afs/cs/user/yachen/www/papers/fmcad96.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/yachen/www/publication.html
Root-URL: 
Title: Verification of All Circuits in a Floating-Point Unit Using Word-Level Model Checking  
Author: Yirng-An Chen Edmund Clarke Pei-Hsin Ho Yatin Hoskote Timothy Kam Manpreet Khaira John O'Leary Xudong Zhao 
Abstract: This paper presents the formal verification of all sub-circuits in a floating-point arithmetic unit (FPU) from an Intel microprocessor using a word-level model checker. This work represents the first large-scale application of word-level model checking techniques. The FPU can perform addition, subtraction, multiplication, square root, division, remainder, and rounding operations; verifying such a broad range of functionality required coupling the model checker with a number of other techniques, such as property decomposition, property specific model abstraction, and latch removal. We will illustrate the verification techniques used by us with respect to the design of the Weitek WTL3170/3171 Sparc floating point coprocessor. The principal contribution of this paper is a practical verification methodology explaining what techniques to apply (and where to apply them) when verifying floating-point arithmetic circuits. We have applied our methods to the floating-point unit of a state-of-the- art Intel microprocessor, which is capable of extended precision (64-bit mantissa) computation. The success of this effort demonstrates that word-level model checking, with the help of other verification techniques, can verify arithmetic circuits of the size and complexity found in industry. 
Abstract-found: 1
Intro-found: 1
Reference: [Atk68] <author> D. E. Atkins. </author> <title> Higher-radix division using estimates of the divisor and partial remainders. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-17(10):925-934, </volume> <month> October </month> <year> 1968. </year>
Reference-contexts: Weitek WTL3170/3171 uses a radix-4 SRT division algorithm. The similar algorithms can also be found in <ref> [Fri61, Atk68] </ref>. Since the SRT division algorithm is also iterative, the loop invariant verification technique introduced in the previous section also applies here. Several published papers [CKZ96, BC95] have also shown how to verify radix-4 SRT division circuits using model checking techniques and thus our description here is brief. <p> The algorithm terminates when enough quotient bits have been computed. Suppose that the quotient digits are within the range for some positive . Then a radix-4 SRT division algorithm is guaranteed to be correct if both of the following properties are true in each division loop <ref> [Atk68] </ref>: The loop invariant that we want to verify with our verifier is the conjunction of the two properties above. We want to verify that the invariant is true initially and also .
Reference: [BBDEL96] <author> R.E. I. Beer, S. Ben-David, C. Eisner, and Avner Landver. </author> <title> Rulebase: an industry--oriented formal verification tool. </title> <booktitle> In Proceedings of the 33rd Design Automation Conference. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: The property-specific model extraction is done by an automatic tool that was independently developed at Intel. The tool seems to be very similar to the per-function reduction in <ref> [BBDEL96] </ref>. Several of the arithmetic algorithms used in the FPU are inherently iterative.
Reference: [BC95] <author> R. E. Bryant and Y. A. Chen. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <booktitle> In Proceedings of the 32nd ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 535-541. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: However, BDDs are sometimes unable to represent the data path of circuits efficiently (e.g. multipliers and shifters), preventing their wide-spread use in the verification of arithmetic circuits. Recently, data structures that allow such an efficient representation have been derived from BDDs, such as binary moment diagrams (BMD) <ref> [BC95] </ref> and multi-terminal BDDs (MTBDD) [CMZ + 93]. These representations have further been combined to form hybrid decision diagrams (HDDs) [CFZ95]. 2.1 Hybrid Decision Diagrams A BDD is a directed acyclic graph with a total order on the occurrence of variables from root to leaf. <p> By using HDDs in this manner, this system is able to handle complex circuits containing both complex control logic and wide data paths. The reader is referred to <ref> [BC95, CMZ + 93, CFZ95] </ref> for detailed descriptions of BDDs, BMDs and HDDs. 2.2 Specifying Word-Level Properties The HDD-based verification system allows the expression of properties involving relationships among data variables. <p> Weitek WTL3170/3171 uses a radix-4 SRT division algorithm. The similar algorithms can also be found in [Fri61, Atk68]. Since the SRT division algorithm is also iterative, the loop invariant verification technique introduced in the previous section also applies here. Several published papers <ref> [CKZ96, BC95] </ref> have also shown how to verify radix-4 SRT division circuits using model checking techniques and thus our description here is brief.
Reference: [Bry91] <author> R. E. Bryant. </author> <title> On the complexity of vlsi implementations and graph representations of boolean functions with application to integer multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(2) </volume> <pages> 205-213, </pages> <year> 1991. </year>
Reference-contexts: We will report the results of verifying the FPU from an Intel microprocessor using these techniques in a separate section. Previous work in formally verifying arithmetic hardware has either used BDD-based algorithms <ref> [Bry91, Bry95] </ref>, or theorem proving techniques [VCM94], or a combination of both [KL93]. The first approach has the disadvantage that it requires extremely detailed, bit-level specifications that are difficult to formulate correctly. Moreover, the bit-level specifications of operations like multiplication can be exponentially complex.
Reference: [Bry95] <author> R.E. Bryant. </author> <title> Bit-level analysis of an srt divider circuit. </title> <type> Technical report, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year>
Reference-contexts: We will report the results of verifying the FPU from an Intel microprocessor using these techniques in a separate section. Previous work in formally verifying arithmetic hardware has either used BDD-based algorithms <ref> [Bry91, Bry95] </ref>, or theorem proving techniques [VCM94], or a combination of both [KL93]. The first approach has the disadvantage that it requires extremely detailed, bit-level specifications that are difficult to formulate correctly. Moreover, the bit-level specifications of operations like multiplication can be exponentially complex.
Reference: [BSC + 90] <author> M. Birman, A. Samuels, G. Chu, T. Chuk, L. Hu, J. McLeod, and J. Barnes. </author> <title> Developing the wtl3170/3171 sparc floating-point coprocessors. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 55-64, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: We illustrate our techniques with respect to the design of the Weitek WTL3170/3171 floating-point coprocessors. We chose the Weitek part because substantial detail has been published about its architecture and algorithms <ref> [BSC + 90] </ref>, though we think it is simpler than the Intel design we actually verified. However, we emphasize that the verification methodology we propose is very general and our techniques are applicable to other floating-point and integer arithmetic circuits as well. <p> The power of this extended system will be evident from the verification results presented in this paper. 3 Verifying a Floating-Point Arithmetic Unit 3.1 Weitek Floating-Point Coprocessor In this section we present a typical FPU, the Weitek WTL3170/3171 Sparc floating-point coprocessor <ref> [BSC + 90] </ref>, and the techniques we have found useful to verify each type of circuit found in the coprocessor. The verification methodology we use for floating-point arithmetic circuits is very general and our techniques are applicable to other arithmetic circuits as well. <p> The Weitek paper states that the square root and division operations share a common datapath, but it leaves the details of the square root operation for example, radix, unspecified <ref> [BSC + 90] </ref>. For illustration, we consider here a non-restoring, radix-2 algorithm that is commonly found in the literature [BV85, OLHA95], and is implemented on a separate datapath. The algorithm proceeds iteratively, as follows.
Reference: [BV85] <author> J. Bannur and A. Varma. </author> <title> The vlsi implementation of a square root algorithm. </title> <booktitle> In Proceedings of the 7th Symposium on Computer Arithmetic, </booktitle> <pages> pages 159-165. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1985. </year>
Reference-contexts: The Weitek paper states that the square root and division operations share a common datapath, but it leaves the details of the square root operation for example, radix, unspecified [BSC + 90]. For illustration, we consider here a non-restoring, radix-2 algorithm that is commonly found in the literature <ref> [BV85, OLHA95] </ref>, and is implemented on a separate datapath. The algorithm proceeds iteratively, as follows.
Reference: [CFZ95] <author> E. M. Clarke, M. Fujita, and X. Zhao. </author> <title> Hybrid decision diagrams overcoming the limitations of mtbdds and bmds. </title> <booktitle> In Proceedings of the 1995 Proceedings of the IEEE International Conference on Computer Aided Design, </booktitle> <pages> pages 159-163. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1995. </year>
Reference-contexts: Recently, data structures that allow such an efficient representation have been derived from BDDs, such as binary moment diagrams (BMD) [BC95] and multi-terminal BDDs (MTBDD) [CMZ + 93]. These representations have further been combined to form hybrid decision diagrams (HDDs) <ref> [CFZ95] </ref>. 2.1 Hybrid Decision Diagrams A BDD is a directed acyclic graph with a total order on the occurrence of variables from root to leaf. Multi-terminal BDDs have a similar structure. However, BDDs have Boolean leaves, while MTBDDs have integer leaves and therefore represent functions from Booleans to integers. <p> By using HDDs in this manner, this system is able to handle complex circuits containing both complex control logic and wide data paths. The reader is referred to <ref> [BC95, CMZ + 93, CFZ95] </ref> for detailed descriptions of BDDs, BMDs and HDDs. 2.2 Specifying Word-Level Properties The HDD-based verification system allows the expression of properties involving relationships among data variables.
Reference: [CKZ96] <author> E. M. Clarke, M. Khaira, and X. Zhao. </author> <title> Word level symbolic model checking anew approach for verifying arithmetic circuits. </title> <booktitle> In Proceedings of the 33rd ACM/IEEE Design Automation Conference. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: we found useful for various classes of circuits, rather than the details of the model checking algorithm itself which are ? Intel Development Labs, 5200 NE Elam Young Parkway, M/S JFT-102, Hillsboro, OR 97124 6497 USA ?? School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213 USA covered in <ref> [CKZ96] </ref>. We illustrate our techniques with respect to the design of the Weitek WTL3170/3171 floating-point coprocessors. We chose the Weitek part because substantial detail has been published about its architecture and algorithms [BSC + 90], though we think it is simpler than the Intel design we actually verified. <p> However, model checking algorithms cannot be used directly for verifying arithmetic circuits. Expressions that involve variables with integer values cannot be handled in a clean and efficient manner. Word-level model checking overcomes this problem by extending the original algorithms to evaluate arithmetic expressions using hybrid decision diagrams <ref> [CKZ96] </ref>. In word-level model checking, the transition relation and formulas not involving words are implemented using BDDs as in the original algorithm. HDDs are used only to compute word-level expressions. <p> Weitek WTL3170/3171 uses a radix-4 SRT division algorithm. The similar algorithms can also be found in [Fri61, Atk68]. Since the SRT division algorithm is also iterative, the loop invariant verification technique introduced in the previous section also applies here. Several published papers <ref> [CKZ96, BC95] </ref> have also shown how to verify radix-4 SRT division circuits using model checking techniques and thus our description here is brief.
Reference: [CMZ + 93] <author> E. M. Clarke, K. McMillan, X. Zhao, M. Fujita, and J. Yang. </author> <title> Spectral transforms for large boolean functions with applications to technology mapping. </title> <booktitle> In Proceedings of the 30th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 54-60. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Recently, data structures that allow such an efficient representation have been derived from BDDs, such as binary moment diagrams (BMD) [BC95] and multi-terminal BDDs (MTBDD) <ref> [CMZ + 93] </ref>. These representations have further been combined to form hybrid decision diagrams (HDDs) [CFZ95]. 2.1 Hybrid Decision Diagrams A BDD is a directed acyclic graph with a total order on the occurrence of variables from root to leaf. Multi-terminal BDDs have a similar structure. <p> By using HDDs in this manner, this system is able to handle complex circuits containing both complex control logic and wide data paths. The reader is referred to <ref> [BC95, CMZ + 93, CFZ95] </ref> for detailed descriptions of BDDs, BMDs and HDDs. 2.2 Specifying Word-Level Properties The HDD-based verification system allows the expression of properties involving relationships among data variables.
Reference: [Coe95] <author> T. </author> <title> Coe. Inside the pentium fdiv bug. </title> <journal> Dr. Dobbs Journal, </journal> <volume> 20(4) </volume> <pages> 129-135, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: 1 Introduction The floating-point division flaw <ref> [SB94, Coe95] </ref> in Intel Corp.'s Pentium underscores how hard the task of verifying a floating-point arithmetic unit is, and how high the cost of a floating-point arithmetic bug can be. About one trillion test vectors were used and none uncovered the bug.
Reference: [Fri61] <author> C. V. Frieman. </author> <title> Statistical analysis of certain arithmetic binary division algorithms. </title> <journal> IRE Transaction, </journal> <pages> pages 91-103, </pages> <month> January </month> <year> 1961. </year>
Reference-contexts: Weitek WTL3170/3171 uses a radix-4 SRT division algorithm. The similar algorithms can also be found in <ref> [Fri61, Atk68] </ref>. Since the SRT division algorithm is also iterative, the loop invariant verification technique introduced in the previous section also applies here. Several published papers [CKZ96, BC95] have also shown how to verify radix-4 SRT division circuits using model checking techniques and thus our description here is brief.
Reference: [HMY95] <author> K. Hamaguchi, A. Morita, and S. Yajima. </author> <title> Efficient construction of binary moment diagrams for verifying arithmetic circuits. </title> <booktitle> In Proceedings of the 1995 IEEE International Conference on Computer Aided Design, </booktitle> <pages> pages 78-82, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: This method unfortunately will not work on wide multipliers as there is no compact BDD representation of the output bits of a multiplier. This problem can be overcome by the following approach. Hamaguchi et. al in <ref> [HMY95] </ref> proposed a backward construction method for obtaining a *BMD function. A cut is first defined across the output (s) and is swept towards the inputs by iteratively moving one gate across the cut at a time.
Reference: [HP96] <author> J. L. Hennessy and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Lack of space precludes a more detailed description of the specifications (see page A-24 in <ref> [HP96] </ref> for an example of I bit calculation). It is possible that the implementation also computes a similar I bit to help in the rounding.
Reference: [KL93] <author> R. P. Kurshan and L. Lamport. </author> <title> Verification of a multiplier: 64 bits and beyond. </title> <editor> In C. Courcoubetis, editor, </editor> <booktitle> Proceedings of the Fifth Workshop on Computer-Aided Verification, </booktitle> <month> June/July </month> <year> 1993. </year>
Reference-contexts: We will report the results of verifying the FPU from an Intel microprocessor using these techniques in a separate section. Previous work in formally verifying arithmetic hardware has either used BDD-based algorithms [Bry91, Bry95], or theorem proving techniques [VCM94], or a combination of both <ref> [KL93] </ref>. The first approach has the disadvantage that it requires extremely detailed, bit-level specifications that are difficult to formulate correctly. Moreover, the bit-level specifications of operations like multiplication can be exponentially complex. The latter two approaches are relatively laborious and require users with substantial special training to guide the proof.
Reference: [McM93] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: In particular, we will discuss property decomposition, property-specific model extraction, latch removal, and verification by invariants. Section 4 presents results obtained in applying these techniques to a floating-point unit from an Intel microprocessor. 2 Word-Level Model Checking Symbolic model checking <ref> [McM93] </ref> is a very efficient technique for verifying the correctness of sequential circuits. It is based on binary decision diagrams (BDDs) and has been very successful in verifying the control logic of industrial circuits. <p> In symbolic model checking systems <ref> [McM93] </ref>, BDDs are used to represent the transition relations and sets of states. The model checking process is performed iteratively on these BDDs. Symbolic model checking has dramatically increased the size of circuits that can be formally verified. However, model checking algorithms cannot be used directly for verifying arithmetic circuits.
Reference: [OLHA95] <author> J. O'Leary, M. Leeser, J. Hickey, and M. Aagaard. </author> <title> Non-restoring integer square root: a case study in design by principled optimization. </title> <booktitle> In Proceedings of the Theorem Provers in Circuit Design '94, volume 901 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The Weitek paper states that the square root and division operations share a common datapath, but it leaves the details of the square root operation for example, radix, unspecified [BSC + 90]. For illustration, we consider here a non-restoring, radix-2 algorithm that is commonly found in the literature <ref> [BV85, OLHA95] </ref>, and is implemented on a separate datapath. The algorithm proceeds iteratively, as follows. <p> It can be proved mathematically that if the loop invariant is true at each iteration, when the algorithm termi nates, the result is correct <ref> [OLHA95] </ref>. We prove the invariant by induction on the number k M of iterations.
Reference: [Rud93] <author> R. Rudell. </author> <title> Dynamic variable ordering for ordered binary decision diagrams. </title> <booktitle> In Intl. Conf. on Computer Aided Design, </booktitle> <address> Santa Clara, Ca., </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Dynamic variable reordering is sometimes useful in verifying arithmetic circuits, especially for iterative circuits that contain a non-trivial control part. We have generalized Rudell's dynamic variable reordering algorithm <ref> [Rud93] </ref> to work on HDDs and incorporated it into our verification system.
Reference: [SB94] <author> H. P. Sharangpani and M. L. Barton. </author> <title> Statistical analysis of floating point flaw in the pentium processor(1994). </title> <type> Technical report, </type> <institution> Intel Corporation, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The floating-point division flaw <ref> [SB94, Coe95] </ref> in Intel Corp.'s Pentium underscores how hard the task of verifying a floating-point arithmetic unit is, and how high the cost of a floating-point arithmetic bug can be. About one trillion test vectors were used and none uncovered the bug.
Reference: [VCM94] <author> D. Verkest, L. Claesen, and H. De Man. </author> <title> A proof of the nonrestoring division algorithm and its implementation on an alu. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 4 </volume> <pages> 5-31, </pages> <month> January </month> <year> 1994. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: We will report the results of verifying the FPU from an Intel microprocessor using these techniques in a separate section. Previous work in formally verifying arithmetic hardware has either used BDD-based algorithms [Bry91, Bry95], or theorem proving techniques <ref> [VCM94] </ref>, or a combination of both [KL93]. The first approach has the disadvantage that it requires extremely detailed, bit-level specifications that are difficult to formulate correctly. Moreover, the bit-level specifications of operations like multiplication can be exponentially complex.
References-found: 20

