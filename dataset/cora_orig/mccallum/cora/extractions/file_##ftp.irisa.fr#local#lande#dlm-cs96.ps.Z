URL: file://ftp.irisa.fr/local/lande/dlm-cs96.ps.Z
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Structural Operational Semantics as a Basis for Static Program Analysis  
Author: Daniel Le Metayer and David Schmidt 
Abstract: A framework for static program analysis must rely on a formal semantics of the programming language to be analyzed. The best established, semantics-based, static analysis framework is abstract interpretation. Its central concept is that concrete values of the semantics of the language are replaced by abstract values that represent properties of the concrete values. The significance of abstract interpretation comes from the fact that its principles are very general and not linked to one specific style of semantics definition. In this paper, we argue that structural operational semantics (SOS) [7] is an appropriate style for the definition of static analyses because it is both structural and intensional. Another significant quality of the SOS framework is that it can accomodate various classes of languages, and thus forms an ideal basis for the design of a program analysis platform. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. L. Burn, C. L. Hankin and S. Abramsky, </author> <title> Strictness analysis for higher-order functions, </title> <booktitle> Science of Computer Programming, November 1986, </booktitle> <volume> Vol. 7, </volume> <pages> pp. 249-278. </pages>
Reference-contexts: A subsequent advance was the formulation of abstract interpretation in a compositional manner via denotational semantics definitions [5]: equationally represented flow-charts were replaced by structurally recursive equations, and abstract value sets were formalised as Scott-domains. These techniques were elegant, and they opened the door to analysis of higher-order programs <ref> [1] </ref>, but there was a price to be paid: properties that are inherently intensional fl Inria/Irisa, Campus Universitaire de Beaulieu, Rennes, France. Email: lemetayer@irisa.fr y Department of Computing and Information Sciences, Kansas State University, Manhattan, KS, USA.
Reference: [2] <author> G. Burn, D. Le Metayer, </author> <title> Proving the correctness of compiler optimisations based on a global analysis, </title> <journal> Journal of Functional Programming, </journal> <month> January </month> <year> 1996. </year>
Reference-contexts: In addition, the denotational semantics style sometimes moves the static analysis too far away from its intended application. As an illustration <ref> [2] </ref>, consider the use of continuations to prove the correctness of strictness-based optimisations. A continuation is basically a functional representation of the control flow that is otherwise left implicit in a denotational semantics.
Reference: [3] <author> P. Cousot and R. Cousot, </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints, </title> <booktitle> in Proceedings 4 th POPL, </booktitle> <year> 1977, </year> <pages> pp. 238-252. </pages>
Reference-contexts: 1 From Flow-charts to Denotational Semantics Abstract interpretation was defined originally in terms of flow-charts or dynamic discrete systems <ref> [3] </ref>. From the usual flow-chart operational semantics, a so-called static (or collecting) semantics is derived automatically by attaching to each program point (flow-chart arc) the set of contexts (states) that flow to that point during execution.
Reference: [4] <author> P. Cousot and R. Cousot, </author> <title> Inductive definitions, semantics and abstract interpretation, </title> <booktitle> in Proceedings 19 th POPL, </booktitle> <year> 1992, </year> <pages> pp. 83-94. </pages>
Reference-contexts: It has been shown that this limitation can be lifted <ref> [4, 8] </ref> using a combination of positive and negative inductive definitions. This leads to a specification method in which finite and infinite behaviours can be defined in a uniform way and the denotational semantics itself can then be seen as an abstraction of the structural operational semantics [4]. <p> This leads to a specification method in which finite and infinite behaviours can be defined in a uniform way and the denotational semantics itself can then be seen as an abstraction of the structural operational semantics <ref> [4] </ref>. The use of operational semantics as a basis for static analysis has been advocated recently in a number of papers [4, 8]. <p> The use of operational semantics as a basis for static analysis has been advocated recently in a number of papers <ref> [4, 8] </ref>. For instance, [8] specifies a functional language using a variation of SOS called natural semantics (or "big-step operational semantics," because it defines a relation between an expression and its normal form without considering intermediate steps, as opposed to "small-step SOS" [6]).
Reference: [5] <author> F. Nielson, </author> <title> A denotational framework for data flow analysis, </title> <journal> Acta Informat-ica 18, </journal> <year> 1982, </year> <pages> pp. 265-287. </pages>
Reference-contexts: A subsequent advance was the formulation of abstract interpretation in a compositional manner via denotational semantics definitions <ref> [5] </ref>: equationally represented flow-charts were replaced by structurally recursive equations, and abstract value sets were formalised as Scott-domains.
Reference: [6] <author> H. R. Nielson and F. Nielson, </author> <title> Semantics with applications, a formal introduction, </title> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: For instance, [8] specifies a functional language using a variation of SOS called natural semantics (or "big-step operational semantics," because it defines a relation between an expression and its normal form without considering intermediate steps, as opposed to "small-step SOS" <ref> [6] </ref>). Among the challenging problems for future research, let us mention: * The application of the methodology suggested in this paper to other programming styles (imperative programming, parallel programming, logic programming, : : : ). <p> definition of a static analysis because they are suited to proofs by structural induction on derivation trees (when small-step SOS lead to proofs by induction on the length of derivation sequences), but small-step SOS are more precise and they are required for a proper treatment of non-determinism, non-termination and parallelism <ref> [6] </ref>. 3 * The design of a platform supporting the development of new analysers from a specification of the SOS of the language and the property of interest. Several efforts have been reported for the design of generic analyses which are not based on operational semantics [9, 10].
Reference: [7] <author> G. D. Plotkin, </author> <title> Structural operational semantics, </title> <booktitle> Lecture notes, </booktitle> <institution> DAIMI FN-19, Aarhus University, </institution> <address> Denmark (1981). </address>
Reference-contexts: We have argued in the introduction that neither flowcharts nor denotational semantics are satisfactory with respect to the above criteria. As a result, we propose structural operational semantics for our framework. The main virtue of structural operational semantics (SOS), introduced in <ref> [7] </ref>, is that it is both structural (compositional) and intensional. <p> relationship between the concrete semantics and the abstract semantics can still be defined by a Galois connection (relating concrete derivation trees to abstract derivation trees), which makes it possible to rely on the fundamental results of abstract interpretation. 3 State of the Art and Perspectives The original definition of SOS <ref> [7] </ref> was limited to finite proof trees. It has been shown that this limitation can be lifted [4, 8] using a combination of positive and negative inductive definitions.
Reference: [8] <author> D. Schmidt, </author> <title> Natural-semantics based abstract interpretation (preliminary version), </title> <booktitle> in Proceedings of the Static Analysis Symposium, </booktitle> <address> Glasgow, Septem-ber 1995, </address> <publisher> Springer Verlag, LNCS. </publisher>
Reference-contexts: It has been shown that this limitation can be lifted <ref> [4, 8] </ref> using a combination of positive and negative inductive definitions. This leads to a specification method in which finite and infinite behaviours can be defined in a uniform way and the denotational semantics itself can then be seen as an abstraction of the structural operational semantics [4]. <p> The use of operational semantics as a basis for static analysis has been advocated recently in a number of papers <ref> [4, 8] </ref>. For instance, [8] specifies a functional language using a variation of SOS called natural semantics (or "big-step operational semantics," because it defines a relation between an expression and its normal form without considering intermediate steps, as opposed to "small-step SOS" [6]). <p> The use of operational semantics as a basis for static analysis has been advocated recently in a number of papers [4, 8]. For instance, <ref> [8] </ref> specifies a functional language using a variation of SOS called natural semantics (or "big-step operational semantics," because it defines a relation between an expression and its normal form without considering intermediate steps, as opposed to "small-step SOS" [6]). <p> A number of analyses proposed for imperative languages (data flow and control flow analyses, alias analyses) have been designed with efficiency considerations in mind and correctness issues have often been neglected. SOS-based analyses should help reconcile both ob jectives <ref> [8] </ref>. * The study of analyses based on small-step SOS and the relationship between small-step and big-step SOS with respect to static analysis.
Reference: [9] <author> G. A. Venkatesh, </author> <title> A framework for construction and evaluation of high-level specifications for program analysis techniques, </title> <booktitle> in Proceedings of the Sigplan'89 Conference on Programming Language Design and Implementation, Sigplan Notices, </booktitle> <volume> Vol. 24, No 7, </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: Several efforts have been reported for the design of generic analyses which are not based on operational semantics <ref> [9, 10] </ref>. Genericity is achieved by parameterising the abstract domains and choosing appropriate abstract functions.
Reference: [10] <author> K. Yi and W. L. Harrison III, </author> <title> Automatic generation and management of interprocedural program analyses, </title> <booktitle> in Proceedings of POPL'93, </booktitle> <pages> pp. 246-259, </pages> <publisher> ACM Press, </publisher> <year> 1993. </year> <month> 4 </month>
Reference-contexts: Several efforts have been reported for the design of generic analyses which are not based on operational semantics <ref> [9, 10] </ref>. Genericity is achieved by parameterising the abstract domains and choosing appropriate abstract functions.
References-found: 10

