URL: ftp://db.stanford.edu/pub/papers/view-short.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: e-mail: fwilburt,quass,adelbergg@cs.stanford.edu  
Title: Physical Database Design for Data Warehouses  
Author: Wilburt Juan Labio,Dallan Quass, Brad Adelberg 
Address: Stanford University  
Affiliation: Department of Computer Science  
Abstract: Data warehouses collect copies of information from remote sources into a single database. Since the remote data is cached at the warehouse, it appears as local relations to the users of the warehouse. To improve query response time, the warehouse administrator will often materialize views defined on the local relations to support common or complicated queries. Unfortunately, the requirement to keep the views consistent with the local relations creates additional overhead when the remote sources change. The warehouse is often kept only loosely consistent with the sources: it is periodically refreshed with changes sent from the source. When this happens, the warehouse is taken off-line until the local relations and materialized views can be updated. Clearly, the users would prefer as little down time as possible. Often the down time can be reduced by adding carefully selected materialized views or indexes to the physical schema. This paper studies how to select the sets of supporting views and of indexes to materialize to minimize the down time. We call this the view index selection (VIS) problem. We present an A* search based solution to the problem as well as rules of thumb. We also perform additional experiments to understand the space-time tradeoff as it applies to data warehouses. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Choenni, H. Blanken, and T. Chang. </author> <title> On the selection of secondary indices in relational databases. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 11 </volume> <pages> 207-33, </pages> <year> 1993. </year>
Reference: [2] <author> F. Fabret, M. Regnier, and E. Simon. </author> <title> An adaptive algo rithm for incremental evaluation of production rules in database. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 455-66, </pages> <year> 1993. </year>
Reference-contexts: Wang and Han-son [21] study how the production system algorithms Rete [4] and TREAT [11] perform in a database environment. An extension to TREAT called A-TREAT is considered in [7]. Fabret et al. <ref> [2] </ref> considered how to choose supporting views for the trigger condition view.
Reference: [3] <author> S. Finkelstein, M. Schkolnick, and P. Tiberio. </author> <title> Physical database design for relational databases. </title> <journal> ACM Transac tions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 91-128, </pages> <year> 1988. </year>
Reference-contexts: Thus, to consider all possible subsets of C, we need to evaluate roughly O (2 2 n ) different view states. 2.1.2 Choosing the indexes Now we must consider all possible subsets of the set of candidate indexes, I. Candidate indexes, as defined in Finkelstein et. al. <ref> [3] </ref>, are indexes on the following types of attributes: * attributes with selection or join predicates on them. * key attributes for base relations where changes to the base relation include deletions or updates. * attributes in GROUP BY or ORDER BY clauses. <p> This sensitive region 1 It also depends on how closely the VIS optimizer's cost model follows that of the dbms. This concept is discussed in <ref> [3] </ref>. 0 1 2 3 4 U U optimal I (R)+D (R) opt0 3 3 opt2 + + 2 opt4 fi fi to Insert/Delete Rates. corresponds to the point when the insertion-deletion rate to the base relations becomes large enough that it is no longer worthwhile to build indexes on their
Reference: [4] <author> C. L. Forgy. </author> <title> Rete: A fast algorithm for the many pat tern/many object pattern match problem. </title> <journal> Artificial Intel ligence, </journal> <volume> 19 </volume> <pages> 17-37, </pages> <year> 1982. </year>
Reference-contexts: Many authors have considered how to evaluate trigger conditions for rules. This can be considered a view maintenance problem where a rule is triggered whenever the view that satisfies its condition becomes non-empty. Wang and Han-son [21] study how the production system algorithms Rete <ref> [4] </ref> and TREAT [11] perform in a database environment. An extension to TREAT called A-TREAT is considered in [7]. Fabret et al. [2] considered how to choose supporting views for the trigger condition view.
Reference: [5] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <editor> In M. Carey and D. Schneider, ed itors, </editor> <booktitle> Proceedings of ACM SIGMOD 1995 International Conferenceon Management of Data, </booktitle> <pages> pages 328-339, </pages> <address> San Jose, CA, </address> <month> May 23-25 </month> <year> 1995. </year>
Reference-contexts: In order to make a materialized view consistent again with the base relations from which it is derived, the view may be recomputed from scratch, or incrementally maintained [6] by calculating just the effects of the deltas on the view. These effects are captured in view maintenance expressions <ref> [5] </ref>. For example, if view RST in Figure 1 is materialized, the maintenance expression calculating the tuples to insert into RST due to insertions into R is 4R1S1T , where 4R denotes the insertions into R.
Reference: [6] <author> A. Gupta, I. Mumick, and V. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proceedings of ACM SIGMOD 1993 International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <month> May 26-28 </month> <year> 1993. </year>
Reference-contexts: In order to make a materialized view consistent again with the base relations from which it is derived, the view may be recomputed from scratch, or incrementally maintained <ref> [6] </ref> by calculating just the effects of the deltas on the view. These effects are captured in view maintenance expressions [5].
Reference: [7] <author> E. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In Proceedings of 1992 ACM SIGMOD, </booktitle> <pages> pages 49-58, </pages> <year> 1992. </year>
Reference-contexts: Wang and Han-son [21] study how the production system algorithms Rete [4] and TREAT [11] perform in a database environment. An extension to TREAT called A-TREAT is considered in <ref> [7] </ref>. Fabret et al. [2] considered how to choose supporting views for the trigger condition view.
Reference: [8] <author> V. Harinarayan, A. Rajaraman, and J. Ullman. </author> <title> Imple menting data cubes efficiently. </title> <booktitle> In Proceedings of 1996 ACM SIGMOD, </booktitle> <year> 1996. </year>
Reference-contexts: Other work has looked at the initial problem of choosing a set of primary views such that the cost of (1) is minimized, while ensuring that the costs of (2) and (3) are not too high. [17] considers this problem in the case of distributed views. <ref> [8] </ref> has investigated this problem for the case of aggregate views. Tsatalos et al. [20] consider materializing views in place of the base relations in order to improve query response time. Rozen et al. [15] look at this problem as adding a set of features to the database.
Reference: [9] <author> W. Labio, D. Quass, and B. Adelberg. </author> <title> Physical database design for data warehouses the vis problem. </title> <type> Technical report, </type> <institution> Stanford University, </institution> <year> 1996. </year> <note> Available by anony mous ftp from db.stanford.edu in /pub/labio/1996. </note>
Reference-contexts: If m is an index, the function returns the cost of maintaining m for all insertions and deletions that will be propagated to the view that m is on. (The details of our cost model are found in <ref> [9] </ref>.) If m is a view, the function returns the cost of propagating onto m insertions to each of the base relations referenced in m, plus the cost of propagating onto m deletions and updates to each of the base relations referenced in m assuming the appropriate index exists. <p> These rules of thumb function similarly to the rule join small relations first in query optimization. These are not hard and fast rules but we have found that the rules apply in general. Due to space constraints, we just list the rules in this section. In <ref> [9] </ref>, we present a full justification of each rule of thumb through analysis and also through experimentation. <p> In addition, in the full version of the paper <ref> [9] </ref>, we also consider whether protected updates should be treated atomically or split into pairs of insertions and deletions.
Reference: [10] <author> A. Levy, A. Mendelzon, Y. Sagiv, and D. Srivastava. </author> <title> Answering queries using views. </title> <booktitle> In Proceedings of the Fourteenth Symposium on Principles of Database Sys tems (PODS), </booktitle> <pages> pages 95-104, </pages> <address> San Jose, CA, </address> <month> May 22-24 </month> <year> 1995. </year>
Reference-contexts: The query optimization itself is complicated by the presence of materialized views since the optimizer must also determine if it can use another materialized view in the query plan evaluating a maintenance expression. This problem is known as answering queries using views <ref> [10] </ref>. To complicate matters, one batch of changes can generate multiple maintenance expressions that need to be evaluated. This happens due to different types of changes to the base relations. The maintenance expressions must be optimized as a group because of possible common subexpressions [13].
Reference: [11] <author> D. P. Miranker. </author> <title> Treat: A better match algorithm for ai pro duction systems. </title> <booktitle> In Proceedings of AAII 87 Conference on Artificial Intelligence, </booktitle> <pages> pages 42-47, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Many authors have considered how to evaluate trigger conditions for rules. This can be considered a view maintenance problem where a rule is triggered whenever the view that satisfies its condition becomes non-empty. Wang and Han-son [21] study how the production system algorithms Rete [4] and TREAT <ref> [11] </ref> perform in a database environment. An extension to TREAT called A-TREAT is considered in [7]. Fabret et al. [2] considered how to choose supporting views for the trigger condition view.
Reference: [12] <author> N. Nilsson. </author> <title> Problem solving methods in artificial intelli gence. </title> <publisher> McGraw-Hill, </publisher> <year> 1971. </year>
Reference: [13] <author> K. Ross, D. Srivastava, and S. Sudarshan. </author> <title> Material ized view maintenance and integrity constraint checking: Trading space for time. </title> <booktitle> In Proceedings of 1996 ACM SIGMOD, </booktitle> <year> 1996. </year>
Reference-contexts: Moreover, in order to derive the total cost it is necessary to consider the view selection and index selection together. To find the optimal solution, then, we must solve the optimization problem globally. One approach, proposed in Ross et al. <ref> [13] </ref> (although this work does not consider indices), is to exhaustively search the solution space. Although exhaustive search is impractical for large problems, it illustrates the complexity of the problem and provides a basis of comparison for other solutions. <p> As proposed in <ref> [13] </ref>, we consider as candidate views all distinct nodes that appear in a query plan for the primary view. Since the primary view is already materialized, it is not included in the candidate view set. For example, given a view V = R1S1T , C = fRS; RT; ST g. <p> To complicate matters, one batch of changes can generate multiple maintenance expressions that need to be evaluated. This happens due to different types of changes to the base relations. The maintenance expressions must be optimized as a group because of possible common subexpressions <ref> [13] </ref>. This problem is known as the multiple-query optimization problem [19]. 2.2 Example Consider the following base relations and view. <p> In addition, indexes on V , the base relations, and the supporting views need to be considered. It is useful to think of the expression dag in Figure 2 when considering the different update paths <ref> [13] </ref> changes to base relations can take as they are propagated to the view. An update path corresponds to a specific query plan for evaluating a view maintenance expression. <p> We have shown in Section 6.1 that index selection has a significant impact on choosing which subviews to materialize. Relaxing either of the above two assumptions invalidates the use of the Roussopoloulos algorithm. Still, this is a very good first treatment of the subject. More recently, Ross et al. <ref> [13] </ref> examines the same problem. They describe an exhaustive search algorithm to solve the VIS problem but without considering indexes. They also propose heuristics for pruning the space to search. We have extended their work by considering indexes, developing rules of thumb, and presenting an improved optimal algorithm. <p> We described and implemented an optimal algorithm based on A* that vastly prunes the search space compared to previously proposed algorithms <ref> [13] </ref>. Since even the A* algorithm is impractical for many real world problems, we developed rules of thumb for the for view and index selection.
Reference: [14] <author> N. Roussopoulos. </author> <title> View indexing in relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2) </volume> <pages> 258-90, </pages> <year> 1982. </year>
Reference-contexts: We have assumed that the primary view is materialized, which minimizes the cost of (1), and focused on choosing supporting view and indices such that the cost of (2) is minimized. We have also considered constraining cost (3). This problem was first studied by Roussopoloulos <ref> [14] </ref>. The additional structures considered for materialization are view indices, rather than the views themselves, to save on storage.
Reference: [15] <author> S. Rozen and D. Shasha. </author> <title> A framework for automating physical database design. </title> <booktitle> In Proceedingsof International Conference on Very Large Data Bases, </booktitle> <pages> pages 401-11, </pages> <year> 1991. </year>
Reference-contexts: Tsatalos et al. [20] consider materializing views in place of the base relations in order to improve query response time. Rozen et al. <ref> [15] </ref> look at this problem as adding a set of features to the database. In particular, the index selection part of our VIS problem has been well-studied [3,1] in the context of physical database design. Choosing indexes for materialized views is a straightforward extension.
Reference: [16] <author> A. Segev and W. Fang. </author> <title> Optimal update policies for distribtued materialized views. </title> <journal> Management Science, </journal> <volume> 17(7) </volume> <pages> 851-70, </pages> <year> 1991. </year>
Reference: [17] <author> A. Segev and J. Park. </author> <title> Updating distributed materialized views. </title> <journal> IEEE Transactions on Knowledge and Data En gineering, </journal> <volume> 1(2) </volume> <pages> 173-184, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: We have implemented our algorithm and used it to generate experimental results. Other work has looked at the initial problem of choosing a set of primary views such that the cost of (1) is minimized, while ensuring that the costs of (2) and (3) are not too high. <ref> [17] </ref> considers this problem in the case of distributed views. [8] has investigated this problem for the case of aggregate views. Tsatalos et al. [20] consider materializing views in place of the base relations in order to improve query response time.
Reference: [18] <author> A. Segev and J. Zhao. </author> <title> Data management for large rule systems. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 297-307, </pages> <year> 1991. </year>
Reference: [19] <author> T. Sellis. </author> <title> Multiple-query optimization. </title> <journal> ACM Transac tions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <year> 1988. </year>
Reference-contexts: This happens due to different types of changes to the base relations. The maintenance expressions must be optimized as a group because of possible common subexpressions [13]. This problem is known as the multiple-query optimization problem <ref> [19] </ref>. 2.2 Example Consider the following base relations and view.
Reference: [20] <author> O. Tsatalos, M. Solomon, and Y. Ioannidis. </author> <title> The gmap: A versatile tool for physical data independence. </title> <booktitle> In Pro ceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 367-78, </pages> <year> 1994. </year>
Reference-contexts: Tsatalos et al. <ref> [20] </ref> consider materializing views in place of the base relations in order to improve query response time. Rozen et al. [15] look at this problem as adding a set of features to the database.
Reference: [21] <author> Y. Wang and E. Hanson. </author> <title> A performance comparison of the rete and treat algorithms for testing database rule conditions. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 88-97, </pages> <year> 1992. </year>
Reference-contexts: Many authors have considered how to evaluate trigger conditions for rules. This can be considered a view maintenance problem where a rule is triggered whenever the view that satisfies its condition becomes non-empty. Wang and Han-son <ref> [21] </ref> study how the production system algorithms Rete [4] and TREAT [11] perform in a database environment. An extension to TREAT called A-TREAT is considered in [7]. Fabret et al. [2] considered how to choose supporting views for the trigger condition view.
References-found: 21

