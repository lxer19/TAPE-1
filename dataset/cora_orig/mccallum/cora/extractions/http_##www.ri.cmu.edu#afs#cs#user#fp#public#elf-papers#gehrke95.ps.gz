URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/elf-papers/gehrke95.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/elf-papers/
Root-URL: 
Affiliation: RISC, Johannes Kepler University, Linz  
Date: May 1995  
Note: Wolfgang.Gehrke@risc.uni-linz.ac.at PhD thesis  
Abstract: Decidability Results For Categorical Notions Related To Monads By Rewriting Techniques 
Abstract-found: 1
Intro-found: 1
Reference: [AGM92] <editor> S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors. </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2. </volume> <publisher> Oxford Science Publications, </publisher> <year> 1992. </year>
Reference: [AHS90] <author> J. Adamek, H. Herrlich, and G.E. Strecker. </author> <title> Abstract and Concrete Categories. Wiley-Interscience Series in Pure and Applied Mathematics. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1990. </year>
Reference-contexts: Introduction Category theory can be seen from very different points of view. The main reference is still [ML71], other comprehensive books are <ref> [AHS90, HP91a, HS79] </ref>, an easy introduction for computer scientists can be found in [Pie91]. In fact it developed as generalization of various fields in mathematics.
Reference: [AL91] <author> A. Asperti and G. Longo. </author> <title> Categories, Types, and Structures An introduction to category theory for the working computer scientist. </title> <booktitle> Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The development of category theory was also heavily influenced by geometric concepts [MLM92]. It plays an important role in the study of semantical questions like for models in logic or semantics of programming languages <ref> [AL91, BW90] </ref>, or in the investigation of type systems [Cro93]. A general approach to semantical questions can be found in [Pfa95a] which is extended in [Pfa95b]. [LS86] presents logic in a categorical flavor. The basic ingredients of a category are objects and morphisms.
Reference: [Bac91] <author> L. Bachmair. </author> <title> Canonical Equational Proofs. </title> <booktitle> Progress in Theoretical Computer Science. </booktitle> <publisher> Birkhauser, </publisher> <year> 1991. </year>
Reference-contexts: Non-termination may be due to a successive generation of infinitely many critical pairs. Failure occurs when a remaining equation cannot be oriented into a rewrite rule with the help of the terminating function. The kind of presentation as an inference system is due to <ref> [Bac91] </ref>. 2.1.3 Rewriting for Categorical Notions We describe how we approach categorical notions with the help of term rewriting. Our attempts are assisted by the Larch Prover [GG91] and the logic programming language Elf [Pfe89, Pfe91, Pfe94].
Reference: [Bar84] <author> H.P. Barendregt. </author> <title> The Lambda Calculus Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <address> Elsevier Science Publisher, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: Details about lambda calculus or simply typed lambda calculus can 46 CHAPTER 6. RELATED TOPICS be found e.g. in the standard books <ref> [Bar84] </ref> or [HS86] and a more recent presentation of typed lambda calculus is [Bar92]. For the technical details we will follow [MN94]. <p> The set fl ! of all simply typed lambda terms over the signature is defined as: fl ! := 2T (B) Note. Following <ref> [Bar84] </ref> terms only differing in the naming of bound variables are identified (also known as ff-conversion). <p> Remark. We assume the usual ff, fi, conversions between -terms. Furthermore in the following we will only consider well-typed terms, i.e. terms from fl ! . 6.2. HIGHER-ORDER REWRITING 47 Theorem 25 (cf. <ref> [Bar84] </ref>) The following facts hold for the simply typed lambda calculus where R 2 f! fi ; ! ; ! fi; g is a relation on fl ! : 1. The relation R is confluent. 2. The relation R is terminating. 3.
Reference: [Bar92] <editor> H.P. Barendregt. </editor> <booktitle> Handbook of Logic in Computer Science, volume 2, chapter Lambda Calculi with Types, </booktitle> <pages> pages 117-309. </pages> <publisher> Oxford Science Publications, </publisher> <year> 1992. </year>
Reference-contexts: Details about lambda calculus or simply typed lambda calculus can 46 CHAPTER 6. RELATED TOPICS be found e.g. in the standard books [Bar84] or [HS86] and a more recent presentation of typed lambda calculus is <ref> [Bar92] </ref>. For the technical details we will follow [MN94]. Notion 23 (simple types, signature, simply typed terms) The set T (B) of simple types over a nonempty set B of base types is the smallest set with: 1.
Reference: [BG92] <author> S. Brookes and S. Geva. </author> <title> Computational Comonads and Intensional Semantics. In M.P. </title> <editor> Fourman and P.T. Johnstone and A.M. Pitts, editor, </editor> <booktitle> Categories in Computer Science, number 177 in London Mathematical Society Lecture Notes, </booktitle> <pages> pages 1-44. </pages> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Monads are the categorical generalization of monoids. They have been used: * to structure the extensional semantics of programming languages by Moggi [Mog89], * to study the intensional semantics of programming languages by Brookes and Geva <ref> [BG92] </ref>, * to structure purely functional programs to allow an easy incorporation of impure programming concepts by Wadler [Wad93]. After showing the problems which occur with the original presentation of monads we undertake the following steps: 1. We reduce the universal word problem of monads to adjunctions. 2. <p> The tests can be found in the Appendix C.3.2. Chapter 5 Computational Co-monads In this chapter we define the notion of a computational co-monad as it is used in <ref> [BG92] </ref> to study intensional semantics. For this notion we present a canonical system which is achieved by extending the system for co-monads in the representation with the help of the Kleisli category. Motivation. Similar to the work of Moggi later on Brookes and Geva in [BG92] studied intensional semantics of programming <p> as it is used in <ref> [BG92] </ref> to study intensional semantics. For this notion we present a canonical system which is achieved by extending the system for co-monads in the representation with the help of the Kleisli category. Motivation. Similar to the work of Moggi later on Brookes and Geva in [BG92] studied intensional semantics of programming languages. A central notion in their work is the "computational co-monad". In their paper several results about this notion had to be verified. With the help of a canonical system those were automated. 5.1 Definition Remark. <p> A central notion in their work is the "computational co-monad". In their paper several results about this notion had to be verified. With the help of a canonical system those were automated. 5.1 Definition Remark. Here the definition of a co-monad [BW85] and a computational co-monad <ref> [BG92] </ref> are given. Furthermore the notion of the Kleisli category for a co-monad is introduced. Again we assume that the morphisms between two objects form a set. Definition 19 (Co-Monad) Let C be a category. <p> The same way the Kleisli category helped for monads it helps for co-monads. Since the notions of monad and co-monad are dual to each other we do not give an example of a co-monad. Instead we proceed with the notion of a computational co-monad as it is used by <ref> [BG92] </ref> to study intensional semantics. Definition 21 (Computational Co-monad [BG92]) Let C be a category and CM = (T; *; ffi) be a co-monad on C. <p> Since the notions of monad and co-monad are dual to each other we do not give an example of a co-monad. Instead we proceed with the notion of a computational co-monad as it is used by <ref> [BG92] </ref> to study intensional semantics. Definition 21 (Computational Co-monad [BG92]) Let C be a category and CM = (T; *; ffi) be a co-monad on C. <p> A computational co-monad CCM = (T; *; ffi; fl) can be characterized by an equational specification with the further equations: T (f A!B ) ffi fl A = fl B ffi f (5.11) ffi A ffi fl A = fl T (A) ffi fl A (5.13) Remark. In <ref> [BG92] </ref> a co-monad is exploited by considering a program as a morphism from T (A) (the object of input computations of type A) to B (the object of output values of type B). <p> The introduction of the auxiliary ? was necessary to succeed. This example could be used to test rewrite tools which allow the extension of the signature as in [KZ89] such that one can see to which extent this may be automated. Application. As an applications we derive statements from <ref> [BG92] </ref> automatically. In that paper a pair of functors is defined relating the category C and the Kleisli category CK.
Reference: [Bir35] <author> G. Birkhoff. </author> <title> On the structure of abstract algebras. </title> <booktitle> Proceedings of the Cambridge Philosophical Society, </booktitle> <volume> 31 </volume> <pages> 433-454, </pages> <year> 1935. </year>
Reference-contexts: They can be found in e.g. [Ebb86]. 2.1. FACTS ABOUT REWRITING 9 Theorem 4 (Birkhoff 's Completeness Theorem) For any set of equations E and terms s; t 2 T over a signature holds: Mod (E) j= s ~ t iff E ` s = t. Remark. Birkhoff's theorem <ref> [Bir35] </ref> states the equivalence between syntactic and semantic proving. Although it is not possible to handle all models in a computer it is possible to do simple syntactic proofs. Problem.
Reference: [BO93] <author> R.V. Book and F. Otto. </author> <title> String-Rewriting Systems. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This can be seen from Fig. 2.2. This is an example of a reduction relation which is locally confluent but not con fluent (since a b ! fl d but a # d does not hold). Method. Noetherian induction (c.f. <ref> [BO93] </ref>) Let ! be a reduction relation on S.
Reference: [Buc87] <author> B. </author> <title> Buchberger. History and Basic Features of the Critical-Pair/Completion procedure. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3 </volume> <pages> 3-38, </pages> <year> 1987. </year>
Reference-contexts: The source reference is [KB70] whereas the full proof of the following lemma can be found in [Hue81]. A general review of this method is given in <ref> [Buc87] </ref>. Proposition 6 (Critical Pair Lemma) A term rewriting system is locally confluent iff all critical pairs converge. Remark. A critical overlap is shown in Fig. 2.4 leading to the critical pair consisting of the terms to the left and the right.
Reference: [Bur93] <author> A. Burroni. </author> <title> Higher Dimensional Word Problems. </title> <journal> Theoretical Computer Science, </journal> <volume> 115 </volume> <pages> 43-62, </pages> <year> 1993. </year> <note> 59 60 BIBLIOGRAPHY </note>
Reference-contexts: The visual presentation of equations for morphisms in the form of commutative diagrams is a very compact and intuitive encoding. [FS90] introduces a graphical language to present categorical definitions. Results about the past ing of diagrams are obtained in <ref> [Pow90a, Pow90b, Bur93] </ref>. A first relationship between diagrams and rewriting is established in [Laf92, Laf93]. Nevertheless in the thesis we take the algebraic point of view. Fokkinga even argues completely in favor of the algebraic presentation [Fok91]. Early work on a special case can be found in [WS82].
Reference: [BW85] <author> M. Barr and C. Wells. </author> <title> Toposes, Triples and Theories. Number 278 in Grundlehren der mathematischen Wissenschaften. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: This will also be our main technique. Main Technique: The equational specification of a notion has to be trans formed until it is accessible for rewriting, i.e. Knuth-Bendix completion. In the study of categorical concepts we focus on monads <ref> [BW85] </ref> and related notions. Monads are the categorical generalization of monoids. <p> To demonstrate our method we include the proof local confluence in the Appendix A.4.2. This system is also referred to in [Hue90a]. Chapter 4 Monads In this chapter we define the categorical notion of a monad. It is presented in great detail in <ref> [BW85] </ref>. First we solve the universal word problem for monads by a reduction to an associated adjunctions. Afterwards we derive an easier canonical system with the help of the Kleisli category of a monad. Motivation. <p> Furthermore the notion of a computational model as defined in this paper has to fulfill an extra equalizing requirement. 4.2 A Canonical System via Adjunctions Solution. One solution for the word problem of monads can be found with the help of the following two theorems from category theory <ref> [BW85] </ref> which allow to translate the problem to the level of an adjunction where a canonical system was given before. 32 CHAPTER 4. <p> Then (R ffi L; ; R (* L )) is a monad on C. Proof. cf. <ref> [BW85] </ref> The proof is done by verification of the monad laws. Theorem 17 Let M = (T; ; ) be a monad on C. Then there is a category D and an adjunction D C : L a R : D ! C such that: 1. <p> T = (R ffi L), 2. is the unit of the adjunction, 3. R (* L ) = where * is the co-unit of the adjunction. Proof. cf. <ref> [BW85] </ref> One possible proof is due to Kleisli with the following construction of the category D (also called "Kleisli category"): objects same objects as C morphisms Hom D (A; B) = Hom C (A; T (B)) identity of object A A composition of f 2 Hom D (A2; A3) and g <p> A central notion in their work is the "computational co-monad". In their paper several results about this notion had to be verified. With the help of a canonical system those were automated. 5.1 Definition Remark. Here the definition of a co-monad <ref> [BW85] </ref> and a computational co-monad [BG92] are given. Furthermore the notion of the Kleisli category for a co-monad is introduced. Again we assume that the morphisms between two objects form a set. Definition 19 (Co-Monad) Let C be a category.
Reference: [BW90] <author> M. Barr and C. Wells. </author> <booktitle> Category Theory for Computing Science. International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: The development of category theory was also heavily influenced by geometric concepts [MLM92]. It plays an important role in the study of semantical questions like for models in logic or semantics of programming languages <ref> [AL91, BW90] </ref>, or in the investigation of type systems [Cro93]. A general approach to semantical questions can be found in [Pfa95a] which is extended in [Pfa95b]. [LS86] presents logic in a categorical flavor. The basic ingredients of a category are objects and morphisms. <p> Proof. cf. <ref> [BW90] </ref> )) ii) * X = 1 (id R (X) ) and ~g = (g) () (show that id R (X) behaves like * X ) ii) 1 (g) = * B 0 ffi 0 L (g) and (f) = R (f ) ffi ~ id L (Y ) (show that
Reference: [Cro93] <author> R.L. Crole. </author> <title> Categories for Types. </title> <publisher> Cambridge Mathematical Textbooks. Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: The development of category theory was also heavily influenced by geometric concepts [MLM92]. It plays an important role in the study of semantical questions like for models in logic or semantics of programming languages [AL91, BW90], or in the investigation of type systems <ref> [Cro93] </ref>. A general approach to semantical questions can be found in [Pfa95a] which is extended in [Pfa95b]. [LS86] presents logic in a categorical flavor. The basic ingredients of a category are objects and morphisms. The emphasis is put mainly on properties of the morphisms.
Reference: [Cur93] <author> P.-L. Curien. </author> <title> Categorical Combinators, Sequential Algorithms, </title> <booktitle> and Functional Programming. Progress in Theoretical Computer Science. Birkhauser, second edition, </booktitle> <year> 1993. </year>
Reference-contexts: Furthermore the last two equations could be reversed resulting in another canonical system where the in terpretations of F and G have to be swapped. Chapter 3 Adjunctions In this chapter we define the categorical notion of an adjunction. In a book by Curien <ref> [Cur93] </ref> a canonical system for adjunctions was given without a proof. We verify this system and prove termination with a special technique adapted from the one used by Hardin/Laville to prove the termination of system SUBST [HL86]. This system is related to a special adjunction between products and exponentiation. Motivation. <p> Lemma 13 An adjunction can be completely characterized by (id; id 0 ; "; L; ; ffi; ffi 0 ) on the level of morphisms assuming it is known how R acts on objects. Proof. cf. <ref> [Cur93] </ref> The missing components can be expressed as: R (f ) := (f ffi 0 " A 0 ) where f 2 Hom C 0 (A 0 ; B 0 ) and g 2 Hom C (A; R (B 0 )). 2 Remark. <p> Note. Assuming it is known how R : C 0 ! C acts on objects there is the following rewriting system (ADJ) for an adjunction L a R with L : C ! C 0 <ref> [Cur93] </ref>: f A!B ffi id A ! f (3.2) id 0 A 0 !B 0 ! f 0 (3.4) A 0 !B 0 ffi 0 id 0 (f 0 A2 0 !A3 0 ) ffi 0 h 0 L (id A ) ! id 0 L (f A2!A3 ) ffi 0
Reference: [Der87] <author> N. Dershowitz. </author> <title> Termination of Rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1 </volume> & 2):69-116, 1987. 
Reference-contexts: From the body of research about term rewriting systems we mainly need the critical pair lemma by Knuth and Bendix [KB70]. Termination is shown by interpretation <ref> [Der87] </ref> which implies that local confluence and confluence coincide. A confluent and terminating system is called canonical and can be used as a decision procedure. This approach to the problem has been already chosen by Huet [Hue90a] who mainly focused on categorical notions towards Cartesian closed categories. <p> Remark. With the help of this criterion several methods for proving termination can be justified. More details can be found in <ref> [Der87, pages 77-78] </ref> or [Lan75]. Here only one of those is presented: the method of polynomial interpretations (see also [Lan79]). Method.
Reference: [DJ90] <editor> N. Dershowitz and J.-P. Jouannaud. </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter Rewrite Systems, </booktitle> <pages> pages 243-320. </pages> <publisher> Elsevier, MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: ABOUT REWRITING 7 a local R b 1 confluence b 2 fl fl R fl fl R fl R fl fl fl R 2.1.2 Term Rewriting Systems For all the details about syntax and semantics of term rewriting systems the reader is pointed to the literature e.g. the overview in <ref> [DJ90] </ref>. In the following only the essential facts are sketched. <p> Remark. 0-ary function symbols are called constants. Sometimes the existence of at least one constant is assumed <ref> [DJ90, page 249] </ref>. Notion 5 (Terms) The set of terms T over a signature = (V; F ; ar) is the smallest set with: 1.
Reference: [Ebb86] <author> H. Ebbinghaus. </author> <title> Einfuhrung in die mathematische Logik. </title> <address> Wis-senschaftliche Buchgesellschaft Darmstadt, </address> <year> 1986. </year>
Reference-contexts: Remark. In the following theorem Mod (E) j= s ~ t means that the semantical equivalence s ~ t is valid in all models of E. Since we will concentrate on the syntactic side we do not give the details of semantics. They can be found in e.g. <ref> [Ebb86] </ref>. 2.1. FACTS ABOUT REWRITING 9 Theorem 4 (Birkhoff 's Completeness Theorem) For any set of equations E and terms s; t 2 T over a signature holds: Mod (E) j= s ~ t iff E ` s = t. Remark.
Reference: [Fel92] <author> A. Felty. </author> <title> A logic programming approach to implementing higher-order rewrite term rewriting. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, volume 596 of Lecture Notes in Computer Science, </booktitle> <pages> pages 135-161. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Note. Elf was already suitable to express higher-order rewriting since the necessary unification is built into the language by a constraint solving algorithm. A similar approach can be found in <ref> [Fel92] </ref>. In Elf it is even possible to generate critical pairs by a program as can be seen in Appendix C.1.
Reference: [Fil94] <author> A. Filinski. </author> <title> Representing Monads. </title> <booktitle> In Proceedings of the 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: Motivation. Once the monadic laws can be turned into a canonical higher-order rewrite system it can be used to provide an automated tool for reasoning about monadic functional programs or about the monadic functional programming style as e.g. considered by Filinski in <ref> [Fil94] </ref>. 6.1 Monadic Functional Style 6.1.1 Examples By means of examples taken from [Wad93] we will demonstrate the monadic style to structure purely functional programs. The examples are a variation on the theme of a simple evaluator. Example. <p> The calls of these functions will remain the same. Note that this concept requires a polymorphic type system. 6.1.2 Monadic Laws Here the notion of the "monadic laws" for functional programming is made formal. Definition 22 (monadic laws cf. <ref> [Fil94] </ref>) A monad M as in functional programming is a triple M = (T; -; ? ) where T is a type constructor and and? are polymorphic functions - : ! T and ? : ( ! T ) ! T ! T fulfilling the monadic laws: (Ml1) -? = id
Reference: [Fok91] <author> M.M. Fokkinga. </author> <title> Calculate categorically. </title> <type> Technical Report CS-R9132, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1991. </year>
Reference-contexts: Results about the past ing of diagrams are obtained in [Pow90a, Pow90b, Bur93]. A first relationship between diagrams and rewriting is established in [Laf92, Laf93]. Nevertheless in the thesis we take the algebraic point of view. Fokkinga even argues completely in favor of the algebraic presentation <ref> [Fok91] </ref>. Early work on a special case can be found in [WS82]. Starting point and motivation of our thesis work was the general problem of checking the commutativity of diagrams in "every-days" technical work dealing with arrows (morphisms) and arrow diagrams.
Reference: [FS90] <author> P.J. Freyd and A. Scedrov. </author> <title> Categories, </title> <publisher> Allegories. Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: The visual presentation of equations for morphisms in the form of commutative diagrams is a very compact and intuitive encoding. <ref> [FS90] </ref> introduces a graphical language to present categorical definitions. Results about the past ing of diagrams are obtained in [Pow90a, Pow90b, Bur93]. A first relationship between diagrams and rewriting is established in [Laf92, Laf93]. Nevertheless in the thesis we take the algebraic point of view.
Reference: [GG91] <author> S.J. Garland and J.V. Guttag. </author> <title> A Guide to LP, The Larch Prover. </title> <institution> Massachusetts Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: Finally we achieve a partial result for monads as used in functional pro gramming by techniques for higher-order rewrite systems. The proofs have been carried out with the help of a computer. First the Larch Prover <ref> [GG91] </ref> helped to check critical pairs and partially the termination. Afterwards we re-implemented the rewriting based decision procedures in the logic programming language Elf. This language is designed by Pfenning [Pfe89, Pfe91, Pfe94]. <p> The kind of presentation as an inference system is due to [Bac91]. 2.1.3 Rewriting for Categorical Notions We describe how we approach categorical notions with the help of term rewriting. Our attempts are assisted by the Larch Prover <ref> [GG91] </ref> and the logic programming language Elf [Pfe89, Pfe91, Pfe94]. The idea how to treat the type information of morphisms in the frame of rewriting is due to Huet [Hue90a]. Remark. Morphisms in a category come equipped with an additional type information. <p> Since termination is known the check for confluence is equivalent to the check of local confluence which can be done by checking all critical pairs. In the Appendix A.4.1 a trace of this check with the Larch Prover <ref> [GG91] </ref> can be found. First the termination of the first 13 rules is shown with the polynomial interpretation I. Then the last rule is added and all rules are oriented from left to right. The last check is for local confluence. 2 Example.
Reference: [HHP93] <author> R. Harper, F. Honsel, and G. Plotkin. </author> <title> A Framework for Defining Logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Afterwards we re-implemented the rewriting based decision procedures in the logic programming language Elf. This language is designed by Pfenning [Pfe89, Pfe91, Pfe94]. The reason for the re-implementation was the availability of dependent types in Elf which is based on the Edinburgh Logical Framework LF <ref> [HHP93] </ref>. Furthermore Elf as a programming language allows different rewriting strategies. Proofs of equality can be inspected since they are represented as terms in Elf. At the end we will point to remaining open problems and directions of further research. <p> BASIC CATEGORICAL NOTIONS 15 morphism untyped typed o1 ! o2 f mor (o2; f; o1) id o1 ! o2 ! o3 g fl f mor (o3, mor (o3, g, o2) * mor (o2, f, o1), o1) Table 2.3: Coding of the Type Information <ref> [HHP93] </ref> which supports dependent types cf. Appendix B. Example. For comparison we give the static definition for the type checking of morphisms in Elf cf. Tab. 2.4. Since Elf allows dependent types morphisms can be represented as a type indexed by two objects. <p> In the Appendix C.2.2 the second trace of critical pairs shows local confluence with the help of dependent types. 2 6.3.2 Using Dependent Types Here we argue for the importance of dependent types in the context of HRS. Since Elf is based on the Logical Framework LF <ref> [HHP93] </ref> it allows also dependent types (types indexed by objects). We will demonstrate their application by means of examples. Example. Let us consider again lambda calculus and we focus on the typed variant. The typing is not reflected in a HRS.
Reference: [HL86] <author> T. Hardin and A. Laville. </author> <title> Proof of Termination of the Rewriting System SUBST on CCL. </title> <journal> Theoretical Computer Science, </journal> <volume> 46 </volume> <pages> 306-312, </pages> <year> 1986. </year>
Reference-contexts: In a book by Curien [Cur93] a canonical system for adjunctions was given without a proof. We verify this system and prove termination with a special technique adapted from the one used by Hardin/Laville to prove the termination of system SUBST <ref> [HL86] </ref>. This system is related to a special adjunction between products and exponentiation. Motivation. There are two reasons to have a look at the notion of an adjunction. On the one hand they are just the next more complicated categorical notion in the line presented in the previous chapter. <p> It remains to show that this is a canonical system, i.e. it is terminating and confluent. Proof. First termination is shown in a similar way to the proof of the termination of system SUBST in <ref> [HL86] </ref>. <p> First the termination of the first 13 rules is shown with the polynomial interpretation I. Then the last rule is added and all rules are oriented from left to right. The last check is for local confluence. 2 Example. The system SUBST in <ref> [HL86] </ref> is connected with the adjunction fi A a A ) . Here we give a more detailed description of the functors and the characterization of this adjunction. <p> The termination is shown in <ref> [HL86] </ref> where the problematic rule here is Dfl. To demonstrate our method we include the proof local confluence in the Appendix A.4.2. This system is also referred to in [Hue90a]. Chapter 4 Monads In this chapter we define the categorical notion of a monad.
Reference: [HP91a] <author> H. Herrlich and H.-E. Porst. </author> <title> Category Theory at Work. </title> <note> Number 18 in Research and Expositions in Mathematics. Heldermann-Verlag, Ber-lin, 1991. BIBLIOGRAPHY 61 </note>
Reference-contexts: Introduction Category theory can be seen from very different points of view. The main reference is still [ML71], other comprehensive books are <ref> [AHS90, HP91a, HS79] </ref>, an easy introduction for computer scientists can be found in [Pie91]. In fact it developed as generalization of various fields in mathematics.
Reference: [HP91b] <editor> G. Huet and G. Plotkin, editors. </editor> <title> Logical Frameworks. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference: [HS79] <author> H. Herrlich and G.E. Strecker. </author> <title> Category Theory. Number 1 in Sigma Series in Pure Mathematics. </title> <address> Heldermann-Verlag, Berlin, </address> <note> second edition, </note> <year> 1979. </year>
Reference-contexts: Introduction Category theory can be seen from very different points of view. The main reference is still [ML71], other comprehensive books are <ref> [AHS90, HP91a, HS79] </ref>, an easy introduction for computer scientists can be found in [Pie91]. In fact it developed as generalization of various fields in mathematics.
Reference: [HS86] <editor> J.R. Hindley and J.P. Seldin. </editor> <title> Introduction to Combinatory Logic and Lambda Calculus. Number 1 in London Mathematical Society Student Texts. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: Details about lambda calculus or simply typed lambda calculus can 46 CHAPTER 6. RELATED TOPICS be found e.g. in the standard books [Bar84] or <ref> [HS86] </ref> and a more recent presentation of typed lambda calculus is [Bar92]. For the technical details we will follow [MN94]. Notion 23 (simple types, signature, simply typed terms) The set T (B) of simple types over a nonempty set B of base types is the smallest set with: 1.
Reference: [Hue80] <author> G. Huet. </author> <title> Confluent Reductions. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(4) </volume> <pages> 797-821, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: Additionally it occurs at the object level, too. Also the unification in the presence of a functor [Vog78] was not sufficient to establish a canonical system modulo an equational theory as in <ref> [Hue80] </ref> since the functor interacts closely with the law of associativity. Remark. In [Mog89] a monad is exploited by considering a program as a morphism from A (the object of values of type A) to T (B) (the object of computations of type B).
Reference: [Hue81] <author> G. Huet. </author> <title> A complete proof of the correctness of the Knuth-Bendix completion algorithm. </title> <journal> Journal of Computation System Sciences, </journal> <volume> 23 </volume> <pages> 11-21, </pages> <year> 1981. </year>
Reference-contexts: Remark. This is the key notion to formulate the crucial result which allows a finite test of the Church-Rosser property for a given terminating term rewriting system. The source reference is [KB70] whereas the full proof of the following lemma can be found in <ref> [Hue81] </ref>. A general review of this method is given in [Buc87]. Proposition 6 (Critical Pair Lemma) A term rewriting system is locally confluent iff all critical pairs converge. Remark.
Reference: [Hue90a] <author> G. Huet. </author> <title> Cartesian closed categories and lambda-calculus. </title> <booktitle> In [Hue90b], </booktitle> <pages> pages 7-23. </pages> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The emphasis is put mainly on properties of the morphisms. Objects are often only characterized up to isomorphism. In this thesis we study the equality of morphisms in particular categories enriched with structure from an equational point of view. This approach is similar to the investigations in <ref> [Hue90a] </ref>. [RB88] goes even a step further in that it turns categorical constructions into programs. It is very common to describe equations between morphisms in the form of diagrams. <p> Looking at the equations we try to apply methods from term rewriting. Our goal is to achieve a canonical term rewriting system which guarantees normal forms and can be used for deciding equality as in <ref> [Hue90a] </ref>. From the body of research about term rewriting systems we mainly need the critical pair lemma by Knuth and Bendix [KB70]. Termination is shown by interpretation [Der87] which implies that local confluence and confluence coincide. <p> Termination is shown by interpretation [Der87] which implies that local confluence and confluence coincide. A confluent and terminating system is called canonical and can be used as a decision procedure. This approach to the problem has been already chosen by Huet <ref> [Hue90a] </ref> who mainly focused on categorical notions towards Cartesian closed categories. Another approach has been taken by Rydeheard and Burstall [RB88] but with a different goal. <p> Our attempts are assisted by the Larch Prover [GG91] and the logic programming language Elf [Pfe89, Pfe91, Pfe94]. The idea how to treat the type information of morphisms in the frame of rewriting is due to Huet <ref> [Hue90a] </ref>. Remark. Morphisms in a category come equipped with an additional type information. This are the source and target object also called domain and codo-main. For a first test it is sufficient to try the rewriting without this type information. <p> Coding type information in a term rewriting system This method was already sketched by Huet in <ref> [Hue90a] </ref>. The trick is to introduce an auxiliary function symbol e.g. "mor" which makes the typing explicit in that it takes three arguments: an untyped morphism together with source and target object. <p> Table 2.4: Type Information in Elf Remark. It will turn out that for the work with categorical notions related to monads it is not easy to find a canonical rewriting system. It is essential to reformulate given equational specifications. This fact is not surprising. Cartesian closed categories <ref> [Hue90a] </ref> are a well know example of a decidable notion where no canonical rewriting system is known in the original presentation. One pos sible decision procedure proceeds by a translation into a simply typed lambda calculus. <p> The termination is shown in [HL86] where the problematic rule here is Dfl. To demonstrate our method we include the proof local confluence in the Appendix A.4.2. This system is also referred to in <ref> [Hue90a] </ref>. Chapter 4 Monads In this chapter we define the categorical notion of a monad. It is presented in great detail in [BW85]. First we solve the universal word problem for monads by a reduction to an associated adjunctions. <p> Huet in <ref> [Hue90a] </ref> concentrated his study on categorical notions related to Cartesian closed categories. Because of the correspondence to certain typed lambda calculi it would be of great interest to construct a canonical rewriting system for Cartesian closed categories.
Reference: [Hue90b] <editor> G. Huet. </editor> <booktitle> Logical Foundations of Functional Programming. University of Texas at Austin Programming Series. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference: [Kah95a] <author> S. Kahrs. </author> <title> Towards a Domain Theory for Termination Proofs. </title> <editor> In J. Hsiang, editor, </editor> <booktitle> Proceedings of the 6th International Conference, Rewriting Techniques and Applications, RTA-95, number 914 in Lecture Notes in Computer Science, </booktitle> <pages> pages 241-255. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <note> more detailed in [Kah95b]. </note>
Reference-contexts: The key idea is a generalization 50 CHAPTER 6. RELATED TOPICS of the critical pair lemma to the higher-order setting [Nip91]. More details are given in [MN94]. Furthermore a method to prove termination for higher-order rewrite systems will be presented following <ref> [Kah95a] </ref>. Definition 34 (critical pair) Let H be a higher-order rewrite system. <p> The check of these higher-order critical pairs can be found in the Appendix C.2.1. Remark. Now one method to prove the termination of HRS will be sketched. It is based on <ref> [Kah95a] </ref> which is well suitable for various enriched -calculi. Since this requires a wider especially categorical background we only summarize the method and show the application to typed lambda calculus. Method. <p> in particular it is needed that for all rules l ! H r holds [[l]] &gt; [[r]] * each type is interpreted as object in the category of partially well ordered sets W O (extending b) * function symbols are interpreted as morphisms in W O To achieve this in <ref> [Kah95a] </ref> the following ingredients are provided where interpretations involve ordinals o since they are closely related to W O: out : ! o order preserving functions for erasing rules for every type 52 CHAPTER 6. <p> Finally the interpretation of abstraction and application are: [[v:m]] := (z 7! out (z) [[m]] v7!z ) ; [[(m n)]] := [[m]][[n]] Remark. In <ref> [Kah95a] </ref> already several constructions together with algebraic laws are provided which help to achieve a suitable interpretation. Therefore we feel that this method is well suited for a possible automatic verification. Other techniques to prove termination of HRS are [vdP94, vdPS95] and [LP95]. We list some of the propositions from [Kah95a]: <p> <ref> [Kah95a] </ref> already several constructions together with algebraic laws are provided which help to achieve a suitable interpretation. Therefore we feel that this method is well suited for a possible automatic verification. Other techniques to prove termination of HRS are [vdP94, vdPS95] and [LP95]. We list some of the propositions from [Kah95a]: Proposition 31 (cf. [Kah95a]) The following equalities and inequalities hold: 1. x = 0 x &lt; 1 x &lt; : : :, 3. out (n x) = n out (x), 4. fi-reduction cannot increase the interpretation, 5. [[m]](n x) n + [[m]](x) for ! (can be seen by induction). <p> Therefore we feel that this method is well suited for a possible automatic verification. Other techniques to prove termination of HRS are [vdP94, vdPS95] and [LP95]. We list some of the propositions from <ref> [Kah95a] </ref>: Proposition 31 (cf. [Kah95a]) The following equalities and inequalities hold: 1. x = 0 x &lt; 1 x &lt; : : :, 3. out (n x) = n out (x), 4. fi-reduction cannot increase the interpretation, 5. [[m]](n x) n + [[m]](x) for ! (can be seen by induction). Example. <p> Example. Untyped lambda calculus is known to be non-terminating as can be seen from the term (x:(x x))(x:(x x)). On the other hand typed ! fi in the typed case is terminating cf. Theorem 25. This will be verified with the presented method following <ref> [Kah95a] </ref>: The type interpretation is: b (term) := !; b ( ! ) := b () =) b (); b ( ) ) := b () =) b () where ! is the type constructor on the meta-level and ) is the type constructor on the object-level. =) on the right <p> ) := b () =) b (); b ( ) ) := b () =) b () where ! is the type constructor on the meta-level and ) is the type constructor on the object-level. =) on the right hand side of the definitions corresponds to the functor defined in <ref> [Kah95a] </ref>. <p> MONADIC LAWS AS A HRS 53 Some intermediate steps used propositions from <ref> [Kah95a] </ref> including that meta-level fi-reduction on the right hand side can be ignored since this cannot increase the interpretation. 6.3 Monadic Laws as a HRS 6.3.1 A Canonical System Now the laws of the monadic style will be turned into a canonical HRS. <p> Although M F L is a left linear system it is neither a OHRS nor a WOHRS. Theorem 33 (termination of MFL) M F L is terminating. Proof. Now we apply the method from <ref> [Kah95a] </ref>. The type interpretation is: b (term) := !; b ( ! ) := b () =) b () where we only consider the type constructor ! of the meta-level, =) is the functor from [Kah95a]. <p> Proof. Now we apply the method from <ref> [Kah95a] </ref>. The type interpretation is: b (term) := !; b ( ! ) := b () =) b () where we only consider the type constructor ! of the meta-level, =) is the functor from [Kah95a]. <p> Furthermore the method by Kahrs <ref> [Kah95a] </ref> remains applicable for special dependencies. Another topic for further research is the technique of "diagram chasing" from a graphical point of view. In our thesis work we focused on the algebraic side.
Reference: [Kah95b] <author> S. Kahrs. </author> <title> Towards a Domain Theory for Termination Proofs. </title> <type> Technical Report ECS-LFCS-95-314, </type> <institution> LFCS, Department of Computer Science, University of Edinburgh , 1995. </institution>
Reference: [KB70] <author> D.E. Knuth and P.B. Bendix. </author> <title> Simple word problems in universal algebras. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pages 263-297. </pages> <publisher> Pergamon Press, </publisher> <year> 1970. </year>
Reference-contexts: Our goal is to achieve a canonical term rewriting system which guarantees normal forms and can be used for deciding equality as in [Hue90a]. From the body of research about term rewriting systems we mainly need the critical pair lemma by Knuth and Bendix <ref> [KB70] </ref>. Termination is shown by interpretation [Der87] which implies that local confluence and confluence coincide. A confluent and terminating system is called canonical and can be used as a decision procedure. <p> Remark. This is the key notion to formulate the crucial result which allows a finite test of the Church-Rosser property for a given terminating term rewriting system. The source reference is <ref> [KB70] </ref> whereas the full proof of the following lemma can be found in [Hue81]. A general review of this method is given in [Buc87]. Proposition 6 (Critical Pair Lemma) A term rewriting system is locally confluent iff all critical pairs converge. Remark.
Reference: [Klo92] <editor> J.W. Klop. </editor> <booktitle> Handbook of Logic in Computer Science, volume 2, chapter Term Rewriting Systems, </booktitle> <pages> pages 2-116. </pages> <publisher> Oxford Science Publications, </publisher> <year> 1992. </year>
Reference-contexts: First we recall main facts about rewriting. We focus on the notions and theorems which are needed later on. Then we introduce the most basic categorical notions together with their canonical systems. 2.1 Facts about Rewriting 2.1.1 Reduction Relations At the beginning we closely follow <ref> [Klo92] </ref>. Notion 1 (Reduction Relation) Let S be an arbitrary set and ! S fi S be an arbitrary binary relation on S.
Reference: [KZ89] <author> D. Kapur and H. Zhang. RRL: </author> <title> Rewrite Rule Laboratory User's Manual, </title> <note> revised edition, </note> <month> May </month> <year> 1989. </year>
Reference-contexts: At this point it should be stressed that the choice of the representation for co-monads was not obvious to us. The introduction of the auxiliary ? was necessary to succeed. This example could be used to test rewrite tools which allow the extension of the signature as in <ref> [KZ89] </ref> such that one can see to which extent this may be automated. Application. As an applications we derive statements from [BG92] automatically. In that paper a pair of functors is defined relating the category C and the Kleisli category CK.
Reference: [Laf92] <author> Y. Lafont. </author> <title> Penrose diagrams and 2-dimensional rewriting. In M.P. </title> <editor> Fourman, P.T. Johnstone, and A.M. Pitts, editors, </editor> <booktitle> Applications of Categories in Computer Science, number 177 in London Mathematical Society Lecture Notes, </booktitle> <pages> pages 191-201. </pages> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Results about the past ing of diagrams are obtained in [Pow90a, Pow90b, Bur93]. A first relationship between diagrams and rewriting is established in <ref> [Laf92, Laf93] </ref>. Nevertheless in the thesis we take the algebraic point of view. Fokkinga even argues completely in favor of the algebraic presentation [Fok91]. Early work on a special case can be found in [WS82].
Reference: [Laf93] <author> Y. Lafont. </author> <title> Equational reasoning with 2-dimensional diagrams. </title> <type> Technical report, </type> <institution> Laboratoire de Mathematique Discretes, Universite Mar-seille, </institution> <year> 1993. </year> <note> 62 BIBLIOGRAPHY </note>
Reference-contexts: Results about the past ing of diagrams are obtained in [Pow90a, Pow90b, Bur93]. A first relationship between diagrams and rewriting is established in <ref> [Laf92, Laf93] </ref>. Nevertheless in the thesis we take the algebraic point of view. Fokkinga even argues completely in favor of the algebraic presentation [Fok91]. Early work on a special case can be found in [WS82].
Reference: [Lan75] <author> D.S. Lankford. </author> <title> Canonical algebraic simplification in computational logic. </title> <type> Technical report, </type> <institution> University of Texas, Austin, TX, </institution> <year> 1975. </year>
Reference-contexts: Remark. With the help of this criterion several methods for proving termination can be justified. More details can be found in [Der87, pages 77-78] or <ref> [Lan75] </ref>. Here only one of those is presented: the method of polynomial interpretations (see also [Lan79]). Method.
Reference: [Lan79] <author> D.S. Lankford. </author> <title> On proving term rewriting systems are Noetherian. </title> <type> Technical report, </type> <institution> Louisiana Technical University, Ruston, LA, </institution> <year> 1979. </year>
Reference-contexts: Remark. With the help of this criterion several methods for proving termination can be justified. More details can be found in [Der87, pages 77-78] or [Lan75]. Here only one of those is presented: the method of polynomial interpretations (see also <ref> [Lan79] </ref>). Method.
Reference: [Law66] <author> F.W. Lawvere. </author> <title> The category of categories as a foundation of mathematics. </title> <editor> In S. Eilenberg, D.K. Harrison, S. MacLane, and H. Rohrl, editors, </editor> <booktitle> Proceedings of the Conference on Categorical Algebra, </booktitle> <pages> pages 1-20. </pages> <publisher> Springer-Verlag, </publisher> <year> 1966. </year>
Reference-contexts: Its importance is stressed by the fact that it can be used as an alternative foundation of mathematics cf. the pioneering work by Lawvere <ref> [Law66] </ref> in the 1960s. The development of category theory was also heavily influenced by geometric concepts [MLM92]. It plays an important role in the study of semantical questions like for models in logic or semantics of programming languages [AL91, BW90], or in the investigation of type systems [Cro93].
Reference: [Llo87] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <journal> Symbolic Computation. </journal> <note> Springer-Verlag, second, extended edition, </note> <year> 1987. </year>
Reference-contexts: Remark. A most general unifier & of two terms s and t is denoted as mgu (s; t) which is actually an equivalence class of substitutions up to renaming. More details can be found in <ref> [Llo87, pages 20-26] </ref>. Definition 12 (Critical pair) Let l 1 ! R r 1 and l 2 ! R r 2 be renamed versions of two rewrite rules (possibly the same) of a term rewriting system (; R) having no variables in common.
Reference: [LP95] <author> O. Lysne and J. Piris. </author> <title> A Termination Ordering for Higher Order Rewrite Systems. </title> <editor> In J. Hsiang, editor, </editor> <booktitle> Rewriting Techniques and Applications, RTA-95, number 914 in Lecture Notes in Computer Science, </booktitle> <pages> pages 26-40. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In [Kah95a] already several constructions together with algebraic laws are provided which help to achieve a suitable interpretation. Therefore we feel that this method is well suited for a possible automatic verification. Other techniques to prove termination of HRS are [vdP94, vdPS95] and <ref> [LP95] </ref>.
Reference: [LS86] <author> J. Lambek and P.J. Scott. </author> <title> Introduction to higher-order categorical logic. Number 7 in Cambridge Studies in Advanced Mathematics. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: It plays an important role in the study of semantical questions like for models in logic or semantics of programming languages [AL91, BW90], or in the investigation of type systems [Cro93]. A general approach to semantical questions can be found in [Pfa95a] which is extended in [Pfa95b]. <ref> [LS86] </ref> presents logic in a categorical flavor. The basic ingredients of a category are objects and morphisms. The emphasis is put mainly on properties of the morphisms. Objects are often only characterized up to isomorphism.
Reference: [Man76] <author> E. Manes. </author> <title> Algebraic Theories. Number 26 in Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference-contexts: Proof. cf. <ref> [Man76] </ref> The other components can be expressed as: A := A; A := id ? Remark. This gives a more compact way of representing a monad since it was previously described in terms of (id; ffi; T; ; ). <p> Proof. cf. <ref> [Man76] </ref> The other components can be expressed as: * A := A; ffi A := id ? Remark. This gives a more compact way of presenting a co-monad since it was previously described in terms of (id; ffi; T; *; ffi).
Reference: [Mil91] <author> D. Miller. </author> <title> A logic programming language with Lambda-Abstraction, Function variables, and Simple Unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: Remark. Also in the case n = 0 the condition is fulfilled. The notion of a pattern goes back to <ref> [Mil91] </ref>. The restriction to this subset of all simply typed terms allows decidable unification. Theorem 26 (unification for patterns cf. [Mil91]) The unification problem for higher-order patterns is decidable. If two patterns are unifiable a most general unifier can be effectively computed. <p> Remark. Also in the case n = 0 the condition is fulfilled. The notion of a pattern goes back to <ref> [Mil91] </ref>. The restriction to this subset of all simply typed terms allows decidable unification. Theorem 26 (unification for patterns cf. [Mil91]) The unification problem for higher-order patterns is decidable. If two patterns are unifiable a most general unifier can be effectively computed.
Reference: [ML71] <author> S. Mac Lane. </author> <title> Categories for the Working Mathematician. Number 5 in Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: Introduction Category theory can be seen from very different points of view. The main reference is still <ref> [ML71] </ref>, other comprehensive books are [AHS90, HP91a, HS79], an easy introduction for computer scientists can be found in [Pie91]. In fact it developed as generalization of various fields in mathematics. <p> One of the most popular references for category theory is <ref> [ML71] </ref> which provides lots of examples in greater detail than it is possible here. 2.2.2 Functors Definition 14 (Functor) Let C and D be categories. <p> On the other hand they will turn out to be useful for the study of monads due to some equivalence results. 3.1 Definition Several equivalent definitions of an adjunction are given. For comparison see <ref> [ML71] </ref> or [Pie91]. We assume throughout that the morphisms between two objects form a set. Definition 16 (Adjunction) Let C and C 0 be categories and L : C ! C 0 and R : C 0 ! C be functors. <p> A monoid is a very useful mathematical notion which is described equationally and which has a decidable uniform word problem. The equations can be characterized by diagrams as in Fig. 4.1. A monad is the categorical generalization of the this concept <ref> [ML71] </ref>. This gives evidence that there can be a canonical system for monads, too. Note.
Reference: [MLM92] <author> S. Mac Lane and I. Moerdijk. </author> <title> Sheaves in Geometry and Logic. </title> <publisher> Uni-versitext. Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Its importance is stressed by the fact that it can be used as an alternative foundation of mathematics cf. the pioneering work by Lawvere [Law66] in the 1960s. The development of category theory was also heavily influenced by geometric concepts <ref> [MLM92] </ref>. It plays an important role in the study of semantical questions like for models in logic or semantics of programming languages [AL91, BW90], or in the investigation of type systems [Cro93].
Reference: [MN94] <author> R. Mayr and T. Nipkow. </author> <title> Higher-Order Rewrite Systems and their Confluence. </title> <type> Technical Report TUM-I9433, </type> <institution> Technical University, Mu-nich, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: Details about lambda calculus or simply typed lambda calculus can 46 CHAPTER 6. RELATED TOPICS be found e.g. in the standard books [Bar84] or [HS86] and a more recent presentation of typed lambda calculus is [Bar92]. For the technical details we will follow <ref> [MN94] </ref>. Notion 23 (simple types, signature, simply typed terms) The set T (B) of simple types over a nonempty set B of base types is the smallest set with: 1. <p> Now the basic definitions for a higher-order rewrite system are presented together with the basic theorems. Also a simple example is included. Again we roughly follow <ref> [MN94] </ref>. <p> The key idea is a generalization 50 CHAPTER 6. RELATED TOPICS of the critical pair lemma to the higher-order setting [Nip91]. More details are given in <ref> [MN94] </ref>. Furthermore a method to prove termination for higher-order rewrite systems will be presented following [Kah95a]. Definition 34 (critical pair) Let H be a higher-order rewrite system. <p> Definition 37 (WOHRS) A higher-order rewrite system is called weakly orthogonal if it is left linear and has only trivial critical pairs of the form (s; s). Theorem 30 (cf. [vO94]) WOHRS are confluent. 6.2. HIGHER-ORDER REWRITING 51 Remark. Another confluence result of this type can be found in <ref> [MN94] </ref> where confluence modulo an additional equality is considered. Example. Again we consider the pure lambda calculus as a HRS.
Reference: [Mog89] <author> E. Moggi. </author> <title> Computational Lambda-calculus and Monads. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Knuth-Bendix completion. In the study of categorical concepts we focus on monads [BW85] and related notions. Monads are the categorical generalization of monoids. They have been used: * to structure the extensional semantics of programming languages by Moggi <ref> [Mog89] </ref>, * to study the intensional semantics of programming languages by Brookes and Geva [BG92], * to structure purely functional programs to allow an easy incorporation of impure programming concepts by Wadler [Wad93]. <p> First we solve the universal word problem for monads by a reduction to an associated adjunctions. Afterwards we derive an easier canonical system with the help of the Kleisli category of a monad. Motivation. Our motivation to focus on monads is based on the work of Moggi in <ref> [Mog89] </ref> on structuring (extensional) semantics of programming languages. A canonical system for monads can help to automate reasoning about semantics. <p> The equations can be characterized by diagrams as in Fig. 4.1. A monad is the categorical generalization of the this concept [ML71]. This gives evidence that there can be a canonical system for monads, too. Note. A recent application of monads in computer science can be found in <ref> [Mog89] </ref> where they are exploited to structure the semantics of programming languages which later was used to structure purely functional programs as in [Wad93]. 30 CHAPTER 4. MONADS Example. <p> Additionally it occurs at the object level, too. Also the unification in the presence of a functor [Vog78] was not sufficient to establish a canonical system modulo an equational theory as in [Hue80] since the functor interacts closely with the law of associativity. Remark. In <ref> [Mog89] </ref> a monad is exploited by considering a program as a morphism from A (the object of values of type A) to T (B) (the object of computations of type B). Then intuitively is an inclusion of values into computations and flattens a computation of a computation into a computation. <p> This would be a big disadvantage compared with the impure style. Solution. One answer to this question is to program in the so called "monadic style" due to Wadler who was inspired by the work of Moggi <ref> [Mog89] </ref> about structuring the semantics of programming languages. This monadic style comes as a type constructor together with two basic functions. Particular "monads" will require additional functions. Example.
Reference: [New42] <author> M.H.A. Newman. </author> <title> On theories with a combinatorial definition of `equivalence'. </title> <journal> Annals of Mathematics, </journal> <volume> 43(2) </volume> <pages> 223-243, </pages> <year> 1942. </year>
Reference-contexts: Proposition 1 (Equivalence Church-Rosser/Confluence) ! has the Church-Rosser property iff it is confluent. 6 CHAPTER 2. PRELIMINARIES a b c - d Proof. (idea cf. <ref> [New42] </ref>) )) obvious () induction over the length of $ fl Example. Before the next proposition is stated it has to be pointed out that local confluence and confluence are not the same. This can be seen from Fig. 2.2. <p> Proof. (idea cf. <ref> [New42] </ref>) )) obvious () Noetherian induction applied to P (a) :, 8b; c 2 S : ((a ! fl b ^ a ! fl c) ) 9d 2 S : b ! fl d fl c) where the non-trivial inductive step of the proof is shown in Fig. 2.3. Remark.
Reference: [Nip91] <author> T. Nipkow. </author> <title> Higher-Order Critical Pairs. </title> <booktitle> In Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 342-349. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: This definition does not assume any normal form. Rule (H) could also be presented without the substitution acting on s and t since this can always be simulated with (fi), (abs), and (app). Proposition 27 (equality and rewrite relation cf. <ref> [Nip91] </ref>) Let H be a higher-order rewrite system. Then it holds: s = H t () s l H t l fi . Note. This correspondence between = H and ! H explains why it is useful to check properties like termination and (local) confluence of ! H . Example. <p> The key idea is a generalization 50 CHAPTER 6. RELATED TOPICS of the critical pair lemma to the higher-order setting <ref> [Nip91] </ref>. More details are given in [MN94]. Furthermore a method to prove termination for higher-order rewrite systems will be presented following [Kah95a]. Definition 34 (critical pair) Let H be a higher-order rewrite system. <p> This definition excludes the consideration of overlays of a rule with itself, i.e. the overlapping at the top position. Theorem 28 (cf. <ref> [Nip91] </ref>) Let H be a higher-order rewrite system. Then H is locally confluent iff all critical pairs (s; t) 2 cps (H) converge i.e. s # H t. Remark. If H is known to be terminating then local confluence implies confluence (Newman's lemma cf. 2).
Reference: [Nip93] <author> T. Nipkow. </author> <title> Orthogonal Higher-Order Rewrite Systems are Confluent. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <title> Typed Lambda Calculi and Applications, </title> <booktitle> number 664 in Lecture Notes in Computer Science, </booktitle> <pages> pages 306-317. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> BIBLIOGRAPHY 63 </note>
Reference-contexts: Remark. If H is known to be terminating then local confluence implies confluence (Newman's lemma cf. 2). Definition 36 (OHRS) A higher-order rewrite system is called orthogonal if it is left linear and has no critical pairs. Theorem 29 (cf. <ref> [Nip93] </ref>) OHRS are confluent. Remark. This result holds regardless of termination. Definition 37 (WOHRS) A higher-order rewrite system is called weakly orthogonal if it is left linear and has only trivial critical pairs of the form (s; s). Theorem 30 (cf. [vO94]) WOHRS are confluent. 6.2. HIGHER-ORDER REWRITING 51 Remark.
Reference: [Pfa95a] <author> J. Pfalzgraf. </author> <title> Automated Practical Reasoning, chapter On a general notion of a hull, pages 39-51. Texts and Monographs in Symbolic Computation. </title> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: It plays an important role in the study of semantical questions like for models in logic or semantics of programming languages [AL91, BW90], or in the investigation of type systems [Cro93]. A general approach to semantical questions can be found in <ref> [Pfa95a] </ref> which is extended in [Pfa95b]. [LS86] presents logic in a categorical flavor. The basic ingredients of a category are objects and morphisms. The emphasis is put mainly on properties of the morphisms. Objects are often only characterized up to isomorphism.
Reference: [Pfa95b] <author> J. Pfalzgraf. </author> <title> Towards a general semantics for relational structures: A categorical approach. invited contribution to a special issue of Studia Logica in honor of Helena Rasiowa, 1995. </title> <publisher> forthcoming. </publisher>
Reference-contexts: It plays an important role in the study of semantical questions like for models in logic or semantics of programming languages [AL91, BW90], or in the investigation of type systems [Cro93]. A general approach to semantical questions can be found in [Pfa95a] which is extended in <ref> [Pfa95b] </ref>. [LS86] presents logic in a categorical flavor. The basic ingredients of a category are objects and morphisms. The emphasis is put mainly on properties of the morphisms. Objects are often only characterized up to isomorphism.
Reference: [Pfe89] <author> F. Pfenning. </author> <title> Elf: a language for verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: The proofs have been carried out with the help of a computer. First the Larch Prover [GG91] helped to check critical pairs and partially the termination. Afterwards we re-implemented the rewriting based decision procedures in the logic programming language Elf. This language is designed by Pfenning <ref> [Pfe89, Pfe91, Pfe94] </ref>. The reason for the re-implementation was the availability of dependent types in Elf which is based on the Edinburgh Logical Framework LF [HHP93]. Furthermore Elf as a programming language allows different rewriting strategies. Proofs of equality can be inspected since they are represented as terms in Elf. <p> The kind of presentation as an inference system is due to [Bac91]. 2.1.3 Rewriting for Categorical Notions We describe how we approach categorical notions with the help of term rewriting. Our attempts are assisted by the Larch Prover [GG91] and the logic programming language Elf <ref> [Pfe89, Pfe91, Pfe94] </ref>. The idea how to treat the type information of morphisms in the frame of rewriting is due to Huet [Hue90a]. Remark. Morphisms in a category come equipped with an additional type information. This are the source and target object also called domain and codo-main.
Reference: [Pfe91] <author> F. Pfenning. </author> <title> Logic Programming in the LF logical Framework. </title> <booktitle> In [HP91b], </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: The proofs have been carried out with the help of a computer. First the Larch Prover [GG91] helped to check critical pairs and partially the termination. Afterwards we re-implemented the rewriting based decision procedures in the logic programming language Elf. This language is designed by Pfenning <ref> [Pfe89, Pfe91, Pfe94] </ref>. The reason for the re-implementation was the availability of dependent types in Elf which is based on the Edinburgh Logical Framework LF [HHP93]. Furthermore Elf as a programming language allows different rewriting strategies. Proofs of equality can be inspected since they are represented as terms in Elf. <p> The kind of presentation as an inference system is due to [Bac91]. 2.1.3 Rewriting for Categorical Notions We describe how we approach categorical notions with the help of term rewriting. Our attempts are assisted by the Larch Prover [GG91] and the logic programming language Elf <ref> [Pfe89, Pfe91, Pfe94] </ref>. The idea how to treat the type information of morphisms in the frame of rewriting is due to Huet [Hue90a]. Remark. Morphisms in a category come equipped with an additional type information. This are the source and target object also called domain and codo-main.
Reference: [Pfe94] <author> F. Pfenning. </author> <title> Elf: A Meta-Language for Deductive Systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, number 814 in Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 811-815, </pages> <year> 1994. </year>
Reference-contexts: The proofs have been carried out with the help of a computer. First the Larch Prover [GG91] helped to check critical pairs and partially the termination. Afterwards we re-implemented the rewriting based decision procedures in the logic programming language Elf. This language is designed by Pfenning <ref> [Pfe89, Pfe91, Pfe94] </ref>. The reason for the re-implementation was the availability of dependent types in Elf which is based on the Edinburgh Logical Framework LF [HHP93]. Furthermore Elf as a programming language allows different rewriting strategies. Proofs of equality can be inspected since they are represented as terms in Elf. <p> The kind of presentation as an inference system is due to [Bac91]. 2.1.3 Rewriting for Categorical Notions We describe how we approach categorical notions with the help of term rewriting. Our attempts are assisted by the Larch Prover [GG91] and the logic programming language Elf <ref> [Pfe89, Pfe91, Pfe94] </ref>. The idea how to treat the type information of morphisms in the frame of rewriting is due to Huet [Hue90a]. Remark. Morphisms in a category come equipped with an additional type information. This are the source and target object also called domain and codo-main.
Reference: [Pie91] <author> B.C. Pierce. </author> <title> Basic Category Theory for Computer Scientists. </title> <booktitle> Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Introduction Category theory can be seen from very different points of view. The main reference is still [ML71], other comprehensive books are [AHS90, HP91a, HS79], an easy introduction for computer scientists can be found in <ref> [Pie91] </ref>. In fact it developed as generalization of various fields in mathematics. For example it can be understood as: * an abstract theory of functions, * an abstract theory of structures and structure preserving maps, or * an abstract theory of deductions. <p> Here the type information is absolutely essential in that it guarantees termination. 2.2 Basic Categorical Notions 2.2.1 Categories There are several definitions of a category in the literature. For an easily under standable introduction see <ref> [Pie91] </ref>. Here this fundamental notion is introduced only briefly and we refer to the literature for further details. <p> On the other hand they will turn out to be useful for the study of monads due to some equivalence results. 3.1 Definition Several equivalent definitions of an adjunction are given. For comparison see [ML71] or <ref> [Pie91] </ref>. We assume throughout that the morphisms between two objects form a set. Definition 16 (Adjunction) Let C and C 0 be categories and L : C ! C 0 and R : C 0 ! C be functors.
Reference: [Pow90a] <author> A.J. </author> <title> Power. A 2-Categorical Pasting Theorem. </title> <journal> Journal of Algebra, </journal> <volume> 129 </volume> <pages> 439-445, </pages> <year> 1990. </year>
Reference-contexts: The visual presentation of equations for morphisms in the form of commutative diagrams is a very compact and intuitive encoding. [FS90] introduces a graphical language to present categorical definitions. Results about the past ing of diagrams are obtained in <ref> [Pow90a, Pow90b, Bur93] </ref>. A first relationship between diagrams and rewriting is established in [Laf92, Laf93]. Nevertheless in the thesis we take the algebraic point of view. Fokkinga even argues completely in favor of the algebraic presentation [Fok91]. Early work on a special case can be found in [WS82].
Reference: [Pow90b] <author> A.J. </author> <title> Power. An n-Categorical Pasting Theorem. </title> <editor> In A. Carboni, M.C. Pedicchio, and G. Rosolini, editors, </editor> <booktitle> Proceedings for Category Theory, number 1488 in Lecture Notes in Mathematics, </booktitle> <pages> pages 326-358. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The visual presentation of equations for morphisms in the form of commutative diagrams is a very compact and intuitive encoding. [FS90] introduces a graphical language to present categorical definitions. Results about the past ing of diagrams are obtained in <ref> [Pow90a, Pow90b, Bur93] </ref>. A first relationship between diagrams and rewriting is established in [Laf92, Laf93]. Nevertheless in the thesis we take the algebraic point of view. Fokkinga even argues completely in favor of the algebraic presentation [Fok91]. Early work on a special case can be found in [WS82].
Reference: [PW95] <author> J. Pfalzgraf and D. Wang. </author> <title> Automated Practical Reasoning. </title> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference: [RB88] <author> D.E. Rydeheard and R.M. Burstall. </author> <title> Computational Category Theory. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: The emphasis is put mainly on properties of the morphisms. Objects are often only characterized up to isomorphism. In this thesis we study the equality of morphisms in particular categories enriched with structure from an equational point of view. This approach is similar to the investigations in [Hue90a]. <ref> [RB88] </ref> goes even a step further in that it turns categorical constructions into programs. It is very common to describe equations between morphisms in the form of diagrams. <p> A confluent and terminating system is called canonical and can be used as a decision procedure. This approach to the problem has been already chosen by Huet [Hue90a] who mainly focused on categorical notions towards Cartesian closed categories. Another approach has been taken by Rydeheard and Burstall <ref> [RB88] </ref> but with a different goal. They studied categorical notions which can be turned into algorithms. 3 Although in a category the objects themselves are more in the background of consideration they have to be taken into account for rewriting.
Reference: [vdP94] <author> J. van de Pol. </author> <title> Termination proofs for higher-order rewrite systems. </title> <editor> In J. Heering, K. Meinke, B. Moller, and T. Nipkow, editors, </editor> <title> Higher-Order Algebra, Logic and Term Rewriting, </title> <booktitle> HOA'93, volume 816 of Lecture Notes in Computer Science, </booktitle> <pages> pages 305-325. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In [Kah95a] already several constructions together with algebraic laws are provided which help to achieve a suitable interpretation. Therefore we feel that this method is well suited for a possible automatic verification. Other techniques to prove termination of HRS are <ref> [vdP94, vdPS95] </ref> and [LP95].
Reference: [vdPS95] <author> J. van de Pol and H. Schwichtenberg. </author> <title> Strict Functionals for Termination Proofs. </title> <editor> In M. Dezani-Ciancaglini and G. Plotkin, editors, </editor> <title> Typed Lambda Calculi and Applications, </title> <booktitle> TLCA'95, number 902 in Lecture Notes in Computer Science, </booktitle> <pages> pages 350-364, </pages> <year> 1995. </year>
Reference-contexts: In [Kah95a] already several constructions together with algebraic laws are provided which help to achieve a suitable interpretation. Therefore we feel that this method is well suited for a possible automatic verification. Other techniques to prove termination of HRS are <ref> [vdP94, vdPS95] </ref> and [LP95].
Reference: [Vir95] <author> R. Virga. </author> <title> Higher-Order Superposition for Dependent Types. </title> <type> Technical Report CMU-CS-95-150, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year> <note> to appear. </note>
Reference-contexts: interesting topics of future work: * How can higher-order rewriting be extended to dependent types? * Can the critical pair lemma be lifted to this setting? * Do dependent types allow a better treatment of termination for higher order rewrite systems? First steps in this directions are already undertaken cf. <ref> [Vir95] </ref>. Furthermore the method by Kahrs [Kah95a] remains applicable for special dependencies. Another topic for further research is the technique of "diagram chasing" from a graphical point of view. In our thesis work we focused on the algebraic side.
Reference: [vL90] <editor> J. van Leeuwen, editor. </editor> <booktitle> Handbook of Theoretical Computer Science, volume B. </booktitle> <publisher> Elsevier, MIT Press, </publisher> <year> 1990. </year> <note> 64 BIBLIOGRAPHY </note>
Reference: [vO94] <author> V. van Oostrom. </author> <title> Confluence for Abstract and Higher-Order Rewriting. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, Netherlands, </address> <year> 1994. </year>
Reference-contexts: Theorem 29 (cf. [Nip93]) OHRS are confluent. Remark. This result holds regardless of termination. Definition 37 (WOHRS) A higher-order rewrite system is called weakly orthogonal if it is left linear and has only trivial critical pairs of the form (s; s). Theorem 30 (cf. <ref> [vO94] </ref>) WOHRS are confluent. 6.2. HIGHER-ORDER REWRITING 51 Remark. Another confluence result of this type can be found in [MN94] where confluence modulo an additional equality is considered. Example. Again we consider the pure lambda calculus as a HRS.
Reference: [Vog78] <author> E. Vogel. </author> <title> Unifikation von Morphismen (in German). </title> <institution> Diplomarbeit, Universitat Karlsruhe, </institution> <year> 1978. </year>
Reference-contexts: Additionally it occurs at the object level, too. Also the unification in the presence of a functor <ref> [Vog78] </ref> was not sufficient to establish a canonical system modulo an equational theory as in [Hue80] since the functor interacts closely with the law of associativity. Remark.
Reference: [Wad93] <author> P. Wadler. </author> <title> Monads for functional programming. </title> <editor> In M. Broy, editor, </editor> <booktitle> Program Design Calculi, volume 118 of NATO ASI Series F: Computer and System Sciences, </booktitle> <pages> pages 233-264. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: They have been used: * to structure the extensional semantics of programming languages by Moggi [Mog89], * to study the intensional semantics of programming languages by Brookes and Geva [BG92], * to structure purely functional programs to allow an easy incorporation of impure programming concepts by Wadler <ref> [Wad93] </ref>. After showing the problems which occur with the original presentation of monads we undertake the following steps: 1. We reduce the universal word problem of monads to adjunctions. 2. We give an easier solution to the same problem with the help of the Kleisli category for a monad. 3. <p> This gives evidence that there can be a canonical system for monads, too. Note. A recent application of monads in computer science can be found in [Mog89] where they are exploited to structure the semantics of programming languages which later was used to structure purely functional programs as in <ref> [Wad93] </ref>. 30 CHAPTER 4. MONADS Example. <p> can be turned into a canonical higher-order rewrite system it can be used to provide an automated tool for reasoning about monadic functional programs or about the monadic functional programming style as e.g. considered by Filinski in [Fil94]. 6.1 Monadic Functional Style 6.1.1 Examples By means of examples taken from <ref> [Wad93] </ref> we will demonstrate the monadic style to structure purely functional programs. The examples are a variation on the theme of a simple evaluator. Example.

References-found: 72

