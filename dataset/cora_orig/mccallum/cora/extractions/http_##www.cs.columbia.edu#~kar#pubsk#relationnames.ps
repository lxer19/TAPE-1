URL: http://www.cs.columbia.edu/~kar/pubsk/relationnames.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: kar@cs.columbia.edu  
Title: Relations with Relation Names as Arguments: Algebra and Calculus  
Author: Kenneth A. Ross 
Affiliation: Columbia University  
Abstract: We consider a version of the relational model in which relation names may appear as arguments of other relations. Allowing relation names as arguments provides enhanced modelling capabilities, allowing some object-oriented features to be expressed within the relational model. We extend relational algebra with operators for accessing relations, and also define a relational calculus based on the logic HiLog. We prove two equivalence results between extensions of relational algebra and fragments of our HiLog-based calculus. We show that our extensions of relational algebra provide higher expressive power than relational algebra on any given database. Finally, we argue that the extensions proposed here are relatively easy to provide in practice, and should be expressible within modern query languages. 
Abstract-found: 1
Intro-found: 1
Reference: [C + 76] <author> D. D. Chamberlin et al. </author> <title> SEQUEL 2: A unified approach to data definition, manipulation and control. </title> <journal> IBM Journal of Research and Develipment, </journal> <volume> 20(6) </volume> <pages> 560-575, </pages> <year> 1976. </year>
Reference-contexts: 1 Introduction Since the relational approach was proposed in the early 1970's [Cod70] it has become the de-facto standard as a basis for designing real-world database systems. Data are stored in relations that may be queried using either relational algebra or a relational calculus. Query languages such as SQL <ref> [C + 76] </ref> are based on relational calculus, with queries being translated (with optimization) into operations on the relations in relational algebra.
Reference: [CKW89] <author> W. Chen, M. Kifer, and D. S. Warren. HiLog: </author> <title> A first order semantics for higher-order logic programming constructs. </title> <booktitle> In Proc. North American Logic Programming Conference, </booktitle> <year> 1989. </year>
Reference-contexts: In first order logic, predicate symbols and constant symbols come from disjoint domains, and cannot be mixed. Recently, a logic that does allow this mixing has been proposed. This logic is called HiLog <ref> [CKW89] </ref>. One may think of HiLog as a version of first order logic in which there is no distinction between variables, function, constant and predicate symbols. In particular, variables may appear in predicate names. <p> Indeed, our logic should allow variables to appear as relation names. Such a logic, named HiLog, has recently been proposed <ref> [CKW89] </ref>. HiLog is more general than we require, since it allows uninterpreted function symbols. Hence we shall deal with a fragment of HiLog which we call relational HiLog. Relational HiLog is closely related to "DataHiLog," defined implicitly in [Ros91]. <p> Even without function symbols, HiLog can be used to model sets and hierarchies without significant additional complexity. While the syntax may suggest that HiLog is second order, in a formal sense the semantics of HiLog programs is first order <ref> [CKW89] </ref>. On the other hand, one may ask when a deductive database based on HiLog (or relational HiLog) is safe, or domain independent in an analogous way to relational calculus. In general, the problem is undecidable [DiP69].
Reference: [Cod70] <author> E. F. Codd. </author> <title> A relational model for large shared data banks. </title> <journal> C. ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <year> 1970. </year>
Reference-contexts: 1 Introduction Since the relational approach was proposed in the early 1970's <ref> [Cod70] </ref> it has become the de-facto standard as a basis for designing real-world database systems. Data are stored in relations that may be queried using either relational algebra or a relational calculus. <p> Structurally, relations remain first-order. We argue that relational systems could provide additional modelling capability simply by augmenting their calculus and algebra as described in this paper. 2 Algebra We use the term relational algebra to denote the standard notion of relational algebra as introduced by Codd <ref> [Cod70] </ref>. The fundamental notions are union (R [S), difference (RS), cross-product (Rfi S), projection ( i 1 ;;i m (R)), and selection ( F (R)). Other operators, such as join and intersection, can be defined in terms of these.
Reference: [Cod72] <author> E. F. Codd. </author> <title> Relational completeness of data base sublanguages. </title> <booktitle> Data Base Systems, </booktitle> <pages> pages 65-98, </pages> <year> 1972. </year>
Reference-contexts: One of the fundamental results of relational database theory is that exactly the same class of queries can be expressed by relational algebra and the "safe" formulas of relational calculus <ref> [Cod72] </ref>. 1 A translation from queries in one formalism to equivalent queries in the other can be constructed. It was suggested by Codd that any relational query language should have at least the expressive power of these formalisms [Cod72]. <p> be expressed by relational algebra and the "safe" formulas of relational calculus <ref> [Cod72] </ref>. 1 A translation from queries in one formalism to equivalent queries in the other can be constructed. It was suggested by Codd that any relational query language should have at least the expressive power of these formalisms [Cod72]. More recently, researchers have been considering the object-oriented database paradigm, in which features such as structured objects, classes and inheritance are available. <p> 8u (!(u)) is a subformula of , then !(u) false for any values of the free variables of ! (besides u) implies that u is in DOM (!). 2 Codd showed that relational algebra and the safe formulas of (tuple) relational calculus could express exactly the same class of queries <ref> [Cod72] </ref>. We shall do the same for two different extensions of relational algebra using the operators above. The extensions will be shown equivalent to appropriate subsets of relational HiLog.
Reference: [DiP69] <author> R. A. DiPaola. </author> <title> The recursive unsolvabil-ity of the decision problem for the class of definite formulas. </title> <journal> JACM, </journal> <volume> 16(2):p.324, </volume> <year> 1969. </year>
Reference-contexts: On the other hand, one may ask when a deductive database based on HiLog (or relational HiLog) is safe, or domain independent in an analogous way to relational calculus. In general, the problem is undecidable <ref> [DiP69] </ref>. In fact, there is a stronger condition, called preservation under extensions, that effectively requires that the answer to a query (according to a given semantics) doesn't change when new relations sharing no symbols with the original database are added to the database [Ros91].
Reference: [Klu82] <author> A. Klug. </author> <title> Equivalence of relational algebra and relational calculus query languages having aggregate functions. </title> <journal> J. ACM, </journal> <volume> 29(3) </volume> <pages> 699-717, </pages> <year> 1982. </year>
Reference-contexts: HiLog is currently being used as the basis for the NAIL deductive database system at Stanford University [PDR91]. 5.4 Other features In practice, query languages need additional features, such as aggregation. In <ref> [Klu82] </ref>, Klug demonstrates an equivalence between versions of relational algebra and relational calculus that have been extended with aggregate operators.
Reference: [PDR91] <author> G. Phipps, M. Derr, and K. A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <year> 1991. </year>
Reference-contexts: The translation of logical rules into a version of relational algebra for query evaluation could make use of the expansion operators defined here, and apply the optimizations discussed in Section 5.1. HiLog is currently being used as the basis for the NAIL deductive database system at Stanford University <ref> [PDR91] </ref>. 5.4 Other features In practice, query languages need additional features, such as aggregation. In [Klu82], Klug demonstrates an equivalence between versions of relational algebra and relational calculus that have been extended with aggregate operators.
Reference: [Ros91] <author> K. A. Ross. </author> <title> On negation in HiLog. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year> <note> Full version submitted for journal publication. </note>
Reference-contexts: Such a logic, named HiLog, has recently been proposed [CKW89]. HiLog is more general than we require, since it allows uninterpreted function symbols. Hence we shall deal with a fragment of HiLog which we call relational HiLog. Relational HiLog is closely related to "DataHiLog," defined implicitly in <ref> [Ros91] </ref>. Definition 3.1: A relational HiLog term is either a variable or a constant symbol. <p> In general, the problem is undecidable [DiP69]. In fact, there is a stronger condition, called preservation under extensions, that effectively requires that the answer to a query (according to a given semantics) doesn't change when new relations sharing no symbols with the original database are added to the database <ref> [Ros91] </ref>. In [Ros91] it is shown that, while preservation under extensions and domain independence coincide for first-order 6 This is a better solution than using one relation, namely the union of the part-subpart hierarchies with the part number as an extra argument. <p> In fact, there is a stronger condition, called preservation under extensions, that effectively requires that the answer to a query (according to a given semantics) doesn't change when new relations sharing no symbols with the original database are added to the database <ref> [Ros91] </ref>. In [Ros91] it is shown that, while preservation under extensions and domain independence coincide for first-order 6 This is a better solution than using one relation, namely the union of the part-subpart hierarchies with the part number as an extra argument. Space is saved by having to represent one less argument. <p> A sufficient condition for preservation under extensions, called range restrictedness for HiLog programs, has been proposed in <ref> [Ros91] </ref>. It is not difficult to show that strongly safe relational HiLog queries are preserved under extensions, while the class of weakly safe queries is not.
Reference: [SS77] <author> J. M. Smith and D. C. P. Smith. </author> <title> Database abstractions: Aggregation and generalization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 2(2) </volume> <pages> 105-133, </pages> <year> 1977. </year>
Reference-contexts: In this way nested relations can exist without having relation extensions in tuples. The idea of having relation names as arguments goes back to <ref> [SS77] </ref>, where the authors demonstrate how class hierarchies can be naturally modelled using this principle. In addition the authors examine issues of referential integrity. <p> We briefly discuss the issues of optimizing our extended algebras, how schema evolution may be affected, and how relational HiLog may be extended to a deductive database language. The modelling capability of relations with names as arguments significantly extends that of the standard relational approach, as argued in <ref> [SS77] </ref>. We propose extensions of relational algebra and relational calculus that would not be difficult to implement even within the framework of current relational database systems. Structurally, relations remain first-order. <p> Semantic constraints along these lines have been outlined in <ref> [SS77] </ref>. 5.3 Deductive Databases HiLog is useful in deductive databases for the same reasons that it is beneficial as part of a relational calculus. Even without function symbols, HiLog can be used to model sets and hierarchies without significant additional complexity. <p> One issue that needs to be addressed in a data manipulation language is referential integrity. If the name of a relation is modified, then appropriate tuples in various relations will have to be correspondingly modified. Semantic constraints along these lines are discussed in <ref> [SS77] </ref>. One of the ways we would like to generalize the methods presented here is to make the whole formalism less dependent on a relation's arity.
Reference: [Ull89] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge Base Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year> <title> (Two volumes). </title> <note> Page 8 </note>
Reference-contexts: Definition 3.3: Let be a domain relational calculus formula. A domain relational calculus expression fx 1 ; ; x k j (x 1 ; ; x k )g is defined to be safe <ref> [Ull89] </ref> if 3 Since relations must have at least one attribute, we do not allow 0-ary terms. <p> Lemma 4.1: Every E-relational algebra expression has an equivalent expression in strongly safe relational HiLog. Proof : (Sketch) The proof uses an inductive argument similar to that presented in <ref> [Ull89] </ref>. The induction is on the number of operators in the E-relational algebra expression. The operators union, cross-product, difference, projection and selection are handled as in [Ull89]. We show how to express ff j (R) in relational HiLog. <p> Proof : (Sketch) The proof uses an inductive argument similar to that presented in <ref> [Ull89] </ref>. The induction is on the number of operators in the E-relational algebra expression. The operators union, cross-product, difference, projection and selection are handled as in [Ull89]. We show how to express ff j (R) in relational HiLog. By the induction hypothesis, there is some strongly safe relational HiLog expression fXj (X)g for R. <p> DOM S ( ) can then be expressed as [ R i since d ( ) is finite. The proof is then similar to that presented in <ref> [Ull89] </ref>. <p> We show how variables in predicate names can be handled using E-relational algebra; the remaining logical operators are handled as for domain rela tional calculus in <ref> [Ull89] </ref>. We only need to modify the base case.
References-found: 10

