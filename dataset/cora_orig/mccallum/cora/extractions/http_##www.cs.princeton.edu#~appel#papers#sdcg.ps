URL: http://www.cs.princeton.edu/~appel/papers/sdcg.ps
Refering-URL: http://www.cs.princeton.edu/~appel/papers/
Root-URL: http://www.cs.princeton.edu
Title: Semantics-Directed Code Generation  Compilers Code Generation Denotational Semantics  
Author: Andrew W. Appel 
Note: Using this technique, compilers have been written for (most of) Pascal and C which, although they compile slowly, produce fairly good machine code.  
Date: 0 0  July 25, 1984  
Abstract: A denotational semantics, in which each node in the IR graph has a static meaning, can lead to a clean interface between the front and back ends of the compiler. Furthermore, it is possible to concisely specify a code generator to translate the denotational representation into machine code. Combined with recent work allowing the denotational specification of front ends to translate the input language into the IR, a complete compiler with a well-defined semantics may be generated. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: 1. <author> D. S. Scott and C. Strachey, </author> <title> ``Towards a mathematical semantics for computer languages,'' </title> <booktitle> Proc. Symp. Computers and Automata, </booktitle> <pages> pp. 19-46, </pages> <publisher> Polytechnic Press, </publisher> <address> Brooklyn, New York, </address> <year> 1971. </year>
Reference-contexts: The expression-graph may be evaluated without regard to hidden side effects; side-effects of expressions in the source language been made explicit in the IR by representing them as functions from states to states. 2. A semantics-directed compiler Denotational semantics <ref> [1] </ref> is a technique for describing the meanings of programming-language constructs.
Reference: 2. <author> IBM, </author> <title> ``FORTRAN IV (H) compiler program logic manual,'' Form Y28-6642-3, IBM, </title> <address> New York, NY, </address> <year> 1968. </year>
Reference-contexts: Sometimes the abstract machine is a "three-address" machine <ref> [2] </ref>; sometimes it is a stack-machine [3]. These compilers all have a "black box" -- with only an informal semantics -- between the parser and the IR.
Reference: 3. <author> A. S. Tanenbaum, H. van Staveren, and J. W. Stevenson, </author> <title> ``Using Peephole Optimization on Intermediate Code,'' </title> <journal> Trans. Prog. Lang. and Systems, </journal> <volume> vol. 4, no. 1, </volume> <pages> pp. 21-36, </pages> <publisher> ACM, </publisher> <year> 1982. </year>
Reference-contexts: Sometimes the abstract machine is a "three-address" machine [2]; sometimes it is a stack-machine <ref> [3] </ref>. These compilers all have a "black box" -- with only an informal semantics -- between the parser and the IR.
Reference: 4. <author> W. Wulf, R. K. Johnsson, C. B. Weinstock, C. B. Hobbs, and C. M. Geschke, </author> <title> Design of an Optimizing Compiler, </title> <publisher> Elsevier North-Holland, </publisher> <address> New York, </address> <year> 1975. </year>
Reference: 5. <author> R. G. G. Cattell, </author> <title> ``Formalization and automatic derivation of code generators,'' </title> <type> Ph.D. Thesis, </type> <institution> Carnegie-Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> April </month> <year> 1978. </year>
Reference: 6. <author> P. D. Mosses, </author> <title> ``SIS -- Reference and user's guide,'' </title> <institution> DAIMI MD-30, Computer Science Department, University of Aarhus, Denmark, </institution> <year> 1979. </year>
Reference-contexts: Program Source Parser Denotational Semantics l-calculus Reducer Reduction Specifications register transfers Peephole Optimizer Target Machine Description machine code The front end is generated automatically from a denotational-semantic description. Such front ends have been described in <ref> [6] </ref> , [7] , and [8]; no detailed description is given here.
Reference: 7. <author> L. Paulson, </author> <title> ``A Semantics-Directed Compiler Generator,'' </title> <booktitle> Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 224-233, </pages> <publisher> ACM, </publisher> <year> 1982. </year>
Reference-contexts: Program Source Parser Denotational Semantics l-calculus Reducer Reduction Specifications register transfers Peephole Optimizer Target Machine Description machine code The front end is generated automatically from a denotational-semantic description. Such front ends have been described in [6] , <ref> [7] </ref> , and [8]; no detailed description is given here.
Reference: 8. <author> R. Sethi, </author> <title> ``Control Flow Aspects of Semantics Directed Compiling,'' </title> <journal> Trans. Prog. Lang. and Systems, </journal> <volume> vol. 5, no. 4, </volume> <pages> pp. 554-595, </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: Recent work in semantics-directed compilation has shown the feasibility of automatically generating translators from the source language (such as Pascal) to the l-calculus [67], so that no "black box" is necessary between the parser and the IR. Sethi <ref> [8] </ref> showed that by writing the denotational semantics of the source language in terms of a specified set of combinators, a code-generator could be made to translate the resulting l-expressions into stack-machine code. <p> Program Source Parser Denotational Semantics l-calculus Reducer Reduction Specifications register transfers Peephole Optimizer Target Machine Description machine code The front end is generated automatically from a denotational-semantic description. Such front ends have been described in [6] , [7] , and <ref> [8] </ref>; no detailed description is given here.
Reference: 9. <author> Mitchell Wand, </author> <title> ``Deriving Target Code as a Representation of Continuation Semantics,'' </title> <type> TR 94, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1980. </year>
Reference-contexts: However, his choice of combinators was very restrictive, and his reducer was not sufficiently powerful to compile languages with the varied data types of Pascal-like languages. Wand <ref> [9] </ref> gives a set of combinators similar for stack-machine interpretation, but again the semantic specification is severely restricted and the combinators are not sufficiently close to von Neumann machine-instructions. This paper describes a semantics-directed compiler-generator which is powerful enough to implement compilers for Pascal and C.
Reference: 10. <author> J. W. Davidson, </author> <title> ``Simplifying Code Generation Through Peephole Optimization,'' </title> <type> TR 81-19, </type> <institution> Department of Computer Science, University of Arizona, Tucson, Arizona, </institution> <year> 1981. </year>
Reference-contexts: Such front ends have been described in [6] , [7] , and [8]; no detailed description is given here. The peephole optimizer may be generated automatically from the target-machine description, as in <ref> [10] </ref> , [11], and [12]; it performs the task of assigning temporaries to registers and of choosing appropriate target-machine instructions to effect the specified register transfers. - 4 - 4 This paper describes the reducer.
Reference: 11. <author> J. W. Davidson and Christopher W. Fraser, </author> <title> ``Automatic Generation of Peephole Optimizations,'' </title> <booktitle> Sigplan '84 Symposium on Compiler Construction, </booktitle> <pages> pp. 111-116, </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: Such front ends have been described in [6] , [7] , and [8]; no detailed description is given here. The peephole optimizer may be generated automatically from the target-machine description, as in [10] , <ref> [11] </ref>, and [12]; it performs the task of assigning temporaries to registers and of choosing appropriate target-machine instructions to effect the specified register transfers. - 4 - 4 This paper describes the reducer.
Reference: 12. <author> Robert R. Kessler, </author> <title> ``Peep -- An Architectural Description Driven Peephole Optimizer,'' </title> <booktitle> Sigplan '84 Symposium on Compiler Construction, </booktitle> <pages> pp. 106-110, </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: Such front ends have been described in [6] , [7] , and [8]; no detailed description is given here. The peephole optimizer may be generated automatically from the target-machine description, as in [10] , [11], and <ref> [12] </ref>; it performs the task of assigning temporaries to registers and of choosing appropriate target-machine instructions to effect the specified register transfers. - 4 - 4 This paper describes the reducer.
Reference: 13. <author> M. J. Gordon, A. J. Milner, and C. P. </author> <title> Wadsworth, </title> <publisher> Edinburgh LCF, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1979. </year>
Reference-contexts: The sharing of common sub-expressions is extremely important, because the domains of expressions include machine-states, which must not be copied by the reducer; and continuations, which if needlessly copied will produce needless duplication of emitted code. The syntax and semantics of l-expressions is very similar to that of ML <ref> [13] </ref>, and is summarized as follows: identi fier Variable identifiers and combinators. l x . expr Lambda-abstraction on the variable x expr expr Application of first expr to second. (expr , . . . , expr ) N-tuples expr.i Selection of i th element from N-tuple* Tagged variants as in Hope
Reference: 14. <author> R. Burstall, D. MacQueen, and D. Sannella, </author> <title> ``Hope: an Experimental Applicative Language,'' </title> <booktitle> Proceedings of the 1980 LISP Conference, </booktitle> <pages> pp. 136-143, </pages> <address> Stanford, </address> <year> 1980. </year>
Reference-contexts: and is summarized as follows: identi fier Variable identifiers and combinators. l x . expr Lambda-abstraction on the variable x expr expr Application of first expr to second. (expr , . . . , expr ) N-tuples expr.i Selection of i th element from N-tuple* Tagged variants as in Hope <ref> [14] </ref> are also used. Standard reductions are associated with these operators. A selection node connected to a tuple node reduces by selecting one of the elements; a l-node applied to an argument reduces by b-reduction. 4.
References-found: 15

