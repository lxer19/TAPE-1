URL: http://www.cs.toronto.edu/~avigal/mdr.ps
Refering-URL: http://www.cs.toronto.edu/~avigal/publications.html
Root-URL: http://www.cs.toronto.edu
Title: Maintaining Data-driven Rules in Databases using an Invariant Based Language  
Author: Avigdor Gal, Opher Etzion 
Keyword: Database systems, High-level languages, Software engineering, Active databases, Temporal databases  
Address: Haifa, 32000, Israel  
Affiliation: Technion Israel Institute of Technology Faculty of Industrial and Management Engineering  
Date: September 7, 1995  
Abstract: A data-driven rule is a rule that is activated as a result of modifications of data items in a database. Data-driven rules become very useful in applications that use a combination of rules and DBMS technologies. This paper presents the considerations in choosing an adequate programming style for representing data-driven rules based on software engineering aspects, namely, ease of use in a high-level language and better verifiability of the rule language. We show that contemporary database programming styles fail to provide the required tools and present the invariant based language as an adequate tool for representing data-driven rules. 
Abstract-found: 1
Intro-found: 1
Reference: [1] : <author> M.P. Atkinson, </author> <title> O.P. Buneman Types and Persistence in Data Base Programming Languages, </title> <journal> ACM Computing Surveys 19(2), </journal> <month> June </month> <year> 1987. </year> <title> [2] : O. Etzion Active Interdatabase Dependencies, </title> <note> to appear in Information Sciences, </note> <year> 1993. </year>
Reference-contexts: Persistent imperative languages support variables whose persistence does not depend upon their data type. The life-span of these variables are longer than the creating program's life-span, and there is no need for explicit or implicit physical data movement by the programmer <ref> [1] </ref>. In addition, persistent imperative languages employ type completeness [1], where the same database operations can be applied on each data type. An example of a fully persistent language is PS-ALGOL, a language that "tolerates" all 3 data types, including the primitive types of different databases. <p> The life-span of these variables are longer than the creating program's life-span, and there is no need for explicit or implicit physical data movement by the programmer <ref> [1] </ref>. In addition, persistent imperative languages employ type completeness [1], where the same database operations can be applied on each data type. An example of a fully persistent language is PS-ALGOL, a language that "tolerates" all 3 data types, including the primitive types of different databases. As a result, data can move from one database to another. <p> In this case, the t v itself is determined by the rule and not derived as a function of other t v values. For example: Annual-Commission := 0.01 * Total-Dividend in <ref> [NOW ()+2month, 1] </ref> when Distributor-Status=`Low' in [NOW (), NOW ()-1year] 0.02 * Total-Dividend in [NOW ()+1month, 1] when Distributor-Status=`Medium' in [NOW (), NOW ()-1year] 0.05 * Total-Dividend in [NOW (), 1] when Distributor-Status=`High' in [NOW (), NOW ()-1year] The above rule delays the low annual commission for two month and the <p> In this case, the t v itself is determined by the rule and not derived as a function of other t v values. For example: Annual-Commission := 0.01 * Total-Dividend in [NOW ()+2month, 1] when Distributor-Status=`Low' in [NOW (), NOW ()-1year] 0.02 * Total-Dividend in <ref> [NOW ()+1month, 1] </ref> when Distributor-Status=`Medium' in [NOW (), NOW ()-1year] 0.05 * Total-Dividend in [NOW (), 1] when Distributor-Status=`High' in [NOW (), NOW ()-1year] The above rule delays the low annual commission for two month and the medium annual commission for one month. <p> For example: Annual-Commission := 0.01 * Total-Dividend in [NOW ()+2month, 1] when Distributor-Status=`Low' in [NOW (), NOW ()-1year] 0.02 * Total-Dividend in [NOW ()+1month, 1] when Distributor-Status=`Medium' in [NOW (), NOW ()-1year] 0.05 * Total-Dividend in <ref> [NOW (), 1] </ref> when Distributor-Status=`High' in [NOW (), NOW ()-1year] The above rule delays the low annual commission for two month and the medium annual commission for one month.
Reference: [3] <author> O. </author> <title> Etzion - PARDES-A Data-Driven Oriented Active Database Model, </title> <booktitle> SIGMOD RECORD, 22(1),pp. </booktitle> <pages> 7-14, </pages> <month> Mar </month> <year> 1993. </year>
Reference-contexts: All the languages require explicit reference in each case. Situational independence is partially supported by deductive models (if the derivation is expressible in the language) and by some active models (CACTIS). Other language types do not support situational independence. Deterministic execution: <ref> [3] </ref> requires a deterministic interpretation of update operations. Deterministic models enable the definition of well defined semantics for the execution process, thus permitting reasoning and verification of the execution process. The imperative languages are deterministic, since programs are sequential by nature. <p> In this section we present novel features of a paradigm for data-driven rules. This paradigm is based on the PARDES model <ref> [3] </ref> and its temporal extension [4]. Sections 3.1 through 3.3 present the basic premises of this paradigm; Section 3.4 examines the features relative to the requirements discussed in Section 2. 3.1 Basic premises of the paradigm for data-driven rules 3.1.1 Programming by invariants The programming by invariants [3] paradigm in data-driven <p> the PARDES model <ref> [3] </ref> and its temporal extension [4]. Sections 3.1 through 3.3 present the basic premises of this paradigm; Section 3.4 examines the features relative to the requirements discussed in Section 2. 3.1 Basic premises of the paradigm for data-driven rules 3.1.1 Programming by invariants The programming by invariants [3] paradigm in data-driven rules stems from the observation that in data-driven rules, the dependencies among data items can be inferred implicitly by the system. Programming by invariants uses high level abstractions to support dependencies among data items.

Reference: [10] <author> R. Snodgrass, I. </author> <title> Ahn Temporal Databases, </title> <booktitle> IEEE Computer 19, </booktitle> <pages> pp. 35-42, </pages> <month> Sep </month> <year> 1986. </year> <title> [11] : J.D. Ullman Implementation of Logical Query Language for Databases, in: Proceedings of the ACM-SIGMOD International Conference on Management of Data, 1985 [12] : Xerox Advanced Information Technologies HiPAC: A research Project in Active, Time-Constrained Database Management, </title> <type> Final Technical Report, </type> <institution> XAIT-89-02, </institution> <month> July </month> <year> 1989. </year> <month> 21 </month>
Reference-contexts: hand side and on the right hand side, imply the use of the old value in the right hand side, without explicitly stating it. 3.2 Combining temporal data with data-driven rules In recent years, the discipline of temporal databases has been constructed, aimed to add the time dimension to databases <ref> [10] </ref>. This discipline adds a historical dimension to the database, by maintaining different values for the same data item for different time points.
References-found: 3

