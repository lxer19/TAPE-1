URL: http://www.win.tue.nl/inf/onderzoek/csr/abs/95.21.ps
Refering-URL: http://www.win.tue.nl/inf/onderzoek/publicaties.html
Root-URL: http://www.win.tue.nl
Email: arie@win.tue.nl,  
Title: Axiomatizing Early and Late Input by Variable Elimination  
Author: Arie van Deursen 
Date: 15 January, 1995  
Web: http://www.win.tue.nl/win/cs/fm/arie/  
Address: Eindhoven, 5600 MB P.O. Box 513, The Netherlands  
Affiliation: Formal Methods Group, Dept. of Computing Science TU  
Abstract: Variable binding input actions in process algebra expressions can be characterized by early as well as by late bisimulation, where the distinction is concerned with whether or not variables are instantiated when considering process equivalence. Baeten and Bergstra have given an axiomatization of late and early bisimulation for finite data sets. We illustrate their method by an example, provide the necessary intuition, formulate correctness properties, list errata, and discuss possibilities for future research. Note: Supported by NWO, the Netherlands Organization for Scientific Research, project 612-16-433, HOOP: Higher-Order and Object-Oriented Processes. 1991 Mathematics Subject Classification: 68Q60, 68Q10, 68Q40 1991 CR Categories: F.1.2, D.3.1, F.3.1, D.1.3. Additional keywords and phrases: Process algebra, value passing, term rewriting, ACP, ASF+SDF. Note: An extended abstract appeared in Algebra of Communicating Processes, ACP'95 , A. Ponse, C. Verhoef, and B. van Vlijmen (eds). 
Abstract-found: 1
Intro-found: 1
Reference: [BB92] <author> J.C.M. Baeten and J.A. Bergstra. </author> <title> Process algebra with signals and conditions. </title> <editor> In M. Broy, editor, </editor> <booktitle> Programming and Mathematical Method, Marktoberdorf 1990, number F 88 in NATO ASI Series, </booktitle> <pages> pages 273-323. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Two equations not mentioned in [BB94, Section 3.2] (but again needed to show R E = S E ) are: fi 1 :! (fi 2 :! X) = (fi 1 ^ fi 2 ) :! X (8) These equations are provided in <ref> [BB92] </ref>.
Reference: [BB94] <author> J.C.M. Baeten and J.A. Bergstra. </author> <title> On sequential composition, action prefixes and process prefix. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6 </volume> <pages> 250-268, </pages> <year> 1994. </year>
Reference-contexts: A distinction can then be made between "late" and "early" instantiation of variables, a distinction which has consequences for the notion of equality and bisimulation of processes. Baeten and Bergstra have proposed <ref> [BB94] </ref> a general framework, Functional Prefix Algebra, which they use to come up with various algebraic specifications of late and early 1 r (x);if x = 2 then P else Q + Q Q r (1) r (3) r (1) r (x);if x = 2 then P + r (x);if x <p> This paper is to be read in combination with <ref> [BB94] </ref>. <p> The difference between hiding and deleting is elaborated on in [BH93]. 1.4 Understanding by Experiment In order to gain some intuition concerning the specifications of fpa ECA , bvma, vmc, vpc, and vpa as presented in <ref> [BB94] </ref>, we will sometimes explain them by showing what the equations do when they are interpreted as rewrite rules. <p> In <ref> [BB94] </ref> the if-then and if-then-else operators (written :! and / . ) over processes are introduced as well. The if-then operator is equal to ffi if the condition is false. Again, the non-standard elements force us to give several extra equations indicating how certain combinations of operators can be eliminated. <p> The if-then operator is equal to ffi if the condition is false. Again, the non-standard elements force us to give several extra equations indicating how certain combinations of operators can be eliminated. Two equations not mentioned in <ref> [BB94, Section 3.2] </ref> (but again needed to show R E = S E ) are: fi 1 :! (fi 2 :! X) = (fi 1 ^ fi 2 ) :! X (8) These equations are provided in [BB92]. <p> The above should explain the intuition of the various prefixing and sequencing operators. The complete set of axioms is given in <ref> [BB94, Table 4] </ref>, except for r m and which are specified in [BB94, Table 8]. 2.4 Early and Late Read 2.4.1 Axiomatization With the above preliminaries, defining early and late input actions is straightforward. <p> The above should explain the intuition of the various prefixing and sequencing operators. The complete set of axioms is given in [BB94, Table 4], except for r m and which are specified in <ref> [BB94, Table 8] </ref>. 2.4 Early and Late Read 2.4.1 Axiomatization With the above preliminaries, defining early and late input actions is straightforward. <p> simply are: er m (v); X = r m ffi N v:X (13) For the early read, we can prove from (13), (10), (11), and (12) the following identity: er m (v); Y = n=1 which we encountered before as an informal characterization of the early read. 3 Observe that <ref> [BB94, Section 3.8] </ref> indeed does not list * N as an operator that can be eliminated (it does not list either, but that one can be eliminated). 9 2.4.2 The if-then-else Example Revisited Let us keep our promises, and see how the early and late versions of R and S behave: <p> Can we conclude that the R L and S L must be different as well? This is the case if the rewriting system is terminating and confluent. A demonstration of that requires a careful case distinction of all equations given in <ref> [BB94] </ref>. The intuition given by the above normalization should convince the reader that it is safe to conclude that R L 6= S L . <p> Nevertheless, the er m (v); X and lr m (v); X expressions do have a binding effect in the process X, and the name v can be ff-converted. Let us briefly look how this is achieved. In <ref> [BB94] </ref> the are no equations specifying the effect of substituting over er m (v); X; lr m (v); X, and v:X. Nevertheless, the substitution operator can always be eliminated [BB94, Section 3.8]. <p> Let us briefly look how this is achieved. In [BB94] the are no equations specifying the effect of substituting over er m (v); X; lr m (v); X, and v:X. Nevertheless, the substitution operator can always be eliminated <ref> [BB94, Section 3.8] </ref>. This is because the operators for which no substitution equations are given can themselves be eliminated (e.g., the er m (v); X is equal to a summation for every data element, and substitution is defined for the choice operator). <p> The new notation allows one to mix early and late inputs, and to merge them in parallel. In <ref> [BB94] </ref>, the action prefix setting is also being used to axiomatize restricted input , Hoare's input action, prefix iteration, exits, and csp synchronization merge. <p> The direct axiomatization is simply obtained by taking the axioms from ACP, Val, Booleans, and RSC. bvma should not include variables nor substitutions (as suggested in <ref> [BB94] </ref>) if it is to be the algebra for Read/Send Communication from [BK86], as these will introduce non-standard elements in the Booleans. 3.2 VMC The signature of Value Matching Calculus gives us an algebra which is very close to CCS under early bisimulation (i.e., CCS as discussed in [Mil89]). <p> The direct axiomatization merely indicates which communications are known to be ffi, and which ones can be successful. 4 The eia as formulated in <ref> [BB94] </ref> uses a p instead of an i in the third summand, thus allowing tests involving arbitrary free variables. <p> Then: Proposition 4.5 Equality over terms from vmc coincides with the early bisimulation E . Proposition 4.6 Equality over terms from vpc coincides with the late bisimulation L . 5 Concluding Remarks In this paper, we studied Functional Prefix Algebra, as proposed by Baeten and Bergstra <ref> [BB94] </ref>. Their method is simple and elegant, but their article pays more attention to listing the signatures and axioms than to explaining the underlying intuitions.
Reference: [BH93] <author> J.A. Bergstra and J. Heering. </author> <title> Homomorphism preserving algebraic specifications require hidden sorts. </title> <type> Technical Report CS-R9344, </type> <institution> Centrum voor Wiskunde en Informatica (CWI), </institution> <address> Amsterdam, </address> <year> 1993. </year> <note> To appear in Information & Computation. </note>
Reference-contexts: Reduced models are well-known in algebraic specification, and discussed, e.g., in [EM85, Section 6.8] or [Wir90, Section 2.2]. The difference between hiding and deleting is elaborated on in <ref> [BH93] </ref>. 1.4 Understanding by Experiment In order to gain some intuition concerning the specifications of fpa ECA , bvma, vmc, vpc, and vpa as presented in [BB94], we will sometimes explain them by showing what the equations do when they are interpreted as rewrite rules.
Reference: [BHK89] <author> J.A. Bergstra, J. Heering, and P. Klint, </author> <title> editors. Algebraic Specification. </title> <publisher> ACM Press Frontier Series. The ACM Press in co-operation with Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: For instance, when studying fpa ECA , we reduce terms R E and S E (see Section 1.1) to their normal forms, and see that they are the same (as they should with early input). We have used the Asf+Sdf Meta-environment <ref> [BHK89, Kli93] </ref> to perform such experiments. Asf+Sdf supports execution of specifications based on term rewriting. Moreover, its literate specification facilities (in the sense of [Knu92]) translate ASCII to L A T E X, allowing one to incorporate machine-checked specifications directly as texts in documentation or 5 technical reports.
Reference: [BK84] <author> J.A. Bergstra and J.W. Klop. </author> <title> Process algebra for synchronous communication. </title> <journal> Information and Control, </journal> <volume> 60 </volume> <pages> 109-137, </pages> <year> 1984. </year>
Reference: [BK86] <author> J.A. Bergstra and J.W. Klop. </author> <title> Verification of an alternating bit protocol by means of process algebra. </title> <editor> In W. Bibel and K.P. Jantke, editors, </editor> <title> Math. Methods of Specification and Synthesis of Software Systems, </title> <booktitle> volume 215 of LNCS, </booktitle> <pages> pages 9-23. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Next, we will study four subalgebras of fpa ECA , referred to as bvma, vmc, vpc, and vpa (the names will be explained in Section 3). bvma amounts to standard ACP with Read/Send communication (as in <ref> [BK86] </ref>); vmc is early read with free and bound variables, while vpc is its late counterpart; vpa, finally, is an intriguing setting where we have (late) input actions but no variables. 1.3 Reduced Model Specifications When considering a sub-signature M 2 fbvma; vmc; vpc; vpag of fpa ECA , we change <p> we need a substitution operator, which changes a variable occurring in a process, Boolean expression, or data expression into a new data element (either a value or a variable). 2.2 Read/Send Communication In ACP, communication involving data typically comes with the Read/Send communication primitives shown in Figure 4, introduced in <ref> [BK86] </ref>. The axioms are standard (although here not formulated using the fl notation). We explicitly mention port names as a sort, where k; m are variables ranging over this sort 2 . <p> Now that we have seen the full fpa ECA (in Sections 2.1 to 2.4), we can study four interesting subalgebras, as indicated by the signature overview of Figure 3. 3.1 BVMA The signature of Basic Value Matching Algebra (bvma) gives us ACP with existing Read/Send communication, as discussed, e.g., by <ref> [BK86] </ref>. The direct axiomatization is simply obtained by taking the axioms from ACP, Val, Booleans, and RSC. bvma should not include variables nor substitutions (as suggested in [BB94]) if it is to be the algebra for Read/Send Communication from [BK86], as these will introduce non-standard elements in the Booleans. 3.2 VMC <p> gives us ACP with existing Read/Send communication, as discussed, e.g., by <ref> [BK86] </ref>. The direct axiomatization is simply obtained by taking the axioms from ACP, Val, Booleans, and RSC. bvma should not include variables nor substitutions (as suggested in [BB94]) if it is to be the algebra for Read/Send Communication from [BK86], as these will introduce non-standard elements in the Booleans. 3.2 VMC The signature of Value Matching Calculus gives us an algebra which is very close to CCS under early bisimulation (i.e., CCS as discussed in [Mil89]). ACP's sequential composition is dropped, and replaced by an early read prefix operator.
Reference: [BV95] <author> J.C.M. Baeten and C. Verhoef. </author> <title> Concrete process algebra. </title> <editor> In S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> Volume 4. </volume> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: The definitions of ACP are very similar to the standard ones and not discussed any further (see, e.g., <ref> [BV95] </ref>). We start with a setting without atoms, which is gradually extended with atoms (e.g., in the signature of RSC) which all deal with communication. Missing is the communication function fl: communication between atoms is axiomatized directly.
Reference: [BW90] <author> J.C.M. Baeten and W.P Weijland. </author> <title> Process Algebra. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [Deu94] <author> A. van Deursen. </author> <title> Executable Language Definitions: Case Studies and Origin Tracking Techniques. </title> <type> PhD thesis, </type> <institution> University of Amsterdam, </institution> <year> 1994. </year>
Reference: [EM85] <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specifications, Vol. I, Equations and Initial Semantics. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Reduced models are well-known in algebraic specification, and discussed, e.g., in <ref> [EM85, Section 6.8] </ref> or [Wir90, Section 2.2].
Reference: [HL95] <author> M. Hennesy and H. Lin. </author> <title> Symbolic bisimulation. </title> <journal> Theoretical Computer Science, </journal> <volume> 138 </volume> <pages> 353-389, </pages> <year> 1995. </year>
Reference-contexts: In the alternative, late, approach, we do not want to say anything about x's value in advance. We allow ourselves to make r (x) steps, and we see non-instantiated variables in the transition labels, as shown in Figure 2 (see <ref> [HL95] </ref> for a thorough treatment of these "symbolic bisimulations"). This leads to a process equivalence where fewer processes are equal. <p> Then hI (fpa ECA )i M j= t 1 = t 2 , I (M ) j= t 1 = t 2 Let E and L be the early and late bisimulations defined over labeled transitions derived from an operational semantics for vpc and vmc in the style of <ref> [HL95, Fig.11, Fig.10] </ref>. Then: Proposition 4.5 Equality over terms from vmc coincides with the early bisimulation E . Proposition 4.6 Equality over terms from vpc coincides with the late bisimulation L . 5 Concluding Remarks In this paper, we studied Functional Prefix Algebra, as proposed by Baeten and Bergstra [BB94].
Reference: [Kli93] <author> P. Klint. </author> <title> A meta-environment for generating programming environments. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(2) </volume> <pages> 176-201, </pages> <year> 1993. </year>
Reference-contexts: For instance, when studying fpa ECA , we reduce terms R E and S E (see Section 1.1) to their normal forms, and see that they are the same (as they should with early input). We have used the Asf+Sdf Meta-environment <ref> [BHK89, Kli93] </ref> to perform such experiments. Asf+Sdf supports execution of specifications based on term rewriting. Moreover, its literate specification facilities (in the sense of [Knu92]) translate ASCII to L A T E X, allowing one to incorporate machine-checked specifications directly as texts in documentation or 5 technical reports.
Reference: [Knu92] <author> D.E. Knuth. </author> <title> Literate Programming. </title> <booktitle> Number 27 in CSLI Lecture Notes. Center for the Study of Language and Information, </booktitle> <year> 1992. </year>
Reference-contexts: We have used the Asf+Sdf Meta-environment [BHK89, Kli93] to perform such experiments. Asf+Sdf supports execution of specifications based on term rewriting. Moreover, its literate specification facilities (in the sense of <ref> [Knu92] </ref>) translate ASCII to L A T E X, allowing one to incorporate machine-checked specifications directly as texts in documentation or 5 technical reports.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: from [MPW91, p.46], illustrates the differences between early and late input (here we are using CCS notation): R = r (x):(if x = 2 then P else Q) + r (x):0 S = r (x):(if x = 2 then P ) + r (x):(if x 6= 2 then Q) In <ref> [Mil89] </ref> the early approach is taken, and R and S are equal (i.e., they are strongly bisimilar). <p> It is important to realize that these primitives only deal with values, not with variables! In the next sections, we will see how input actions (or at least the early ones) involving variables can be translated into the Read/Send primitives. The standard CCS restriction operation <ref> [Mil89] </ref> can be defined on top of these Read/Send primitives (translating to ffi): n ffi : P fi Port ! P X n ffi m = @ fr m (i);s m (i)ji2Valg (X) 2 In such a setting there is no need to regard equations as "axiom schemas". 7 2.3 Sequences <p> suggested in [BB94]) if it is to be the algebra for Read/Send Communication from [BK86], as these will introduce non-standard elements in the Booleans. 3.2 VMC The signature of Value Matching Calculus gives us an algebra which is very close to CCS under early bisimulation (i.e., CCS as discussed in <ref> [Mil89] </ref>). ACP's sequential composition is dropped, and replaced by an early read prefix operator. We obtain a direct axiomatization by taking some of the theorems we could prove (in Section 2.4) as our new axioms.
Reference: [MPW91] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> Modal logics for mobile processes. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> Proceedings CONCUR'91, volume 527 of LNCS, </booktitle> <pages> pages 45-60. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: This paper is to be read in combination with [BB94]. Before studying that paper, you might find it helpful to make the corrections we give in Appendix A. 1.1 Motivating Example The following example, taken from <ref> [MPW91, p.46] </ref>, illustrates the differences between early and late input (here we are using CCS notation): R = r (x):(if x = 2 then P else Q) + r (x):0 S = r (x):(if x = 2 then P ) + r (x):(if x 6= 2 then Q) In [Mil89] the <p> This is incorrect as (i) it does not follow from the equations over fpa ECA , and (ii) it conflicts with the aim of equating a term with only bound variables to one without any variable. Also observe that the eia characterizations of <ref> [MPW91] </ref>, [PS93, Law SP] are based on the -calculus, and therefore do not distinguish variables and values. 13 4 Assessment The following propositions, which have not (yet) been formally proved, formulate four properties needed to asses the correctness of the various specifications discussed.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes. </title> <booktitle> Information and Computation, </booktitle> <pages> pages 1-77, </pages> <year> 1992. </year>
Reference-contexts: These atomic events should be exactly matched between processes equivalent under late bisimulation. Late bisimulation is particularly relevant to mobile process calculi, such as the -calculus <ref> [MPW92] </ref> (we will not yet consider mobility here - this is deferred to a forthcoming paper). 1.2 fpa ECA and its Subalgebras which symbols occur in each of them. The first few signatures are more or less standard acp; the special operations are in fpa ("Functional Prefix Algebra") and Prefixing.
Reference: [PS93] <author> J. Parrow and D. Sangiorgi. </author> <title> Algebraic theories for name-passing calculi. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> REX A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> volume 803 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: One might wonder what the use of late input is, as it seems so natural to consider agents R and S to be equivalent. Parrow and Sangiorgi <ref> [PS93] </ref> provide the following explanation: The late bisimulation equivalence builds on a more refined operational intuition: a process can decide to receive input on a port, and by doing so it becomes a function from values to processes. <p> This is incorrect as (i) it does not follow from the equations over fpa ECA , and (ii) it conflicts with the aim of equating a term with only bound variables to one without any variable. Also observe that the eia characterizations of [MPW91], <ref> [PS93, Law SP] </ref> are based on the -calculus, and therefore do not distinguish variables and values. 13 4 Assessment The following propositions, which have not (yet) been formally proved, formulate four properties needed to asses the correctness of the various specifications discussed.
Reference: [San95] <author> D. Sangiorgi. </author> <title> -Calculus, internal mobility, and agent-passing calculi. </title> <type> Technical report, </type> <institution> University of Edinburgh, </institution> <year> 1995. </year> <note> To appear in TAPSOFT'95. </note>
Reference-contexts: A first step could be to allow for internal mobility only, as in the I-calculus of <ref> [San95] </ref>. It might be wise to start with finite processes only, which in the -calculus amounts to omitting the replication operator. 14 Acknowledgments I would like to thank Jos Baeten, Jan Bergstra, Gerard Kok, Alban Ponse, and Lars Ake Fredlund for their helpful comments.
Reference: [Sio64] <author> F.M. Sioson. </author> <title> Equational bases of boolean algebras. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 29(3) </volume> <pages> 115-124, </pages> <year> 1964. </year>
Reference-contexts: ! A c equations : r m (i) j s m (i) = c m (i) r m (i) j s k (j) = ffi when k 6= m or i 6= j r m (i) j r k (j) = ffi c m (i) j a = ffi In <ref> [Sio64] </ref> some equational bases for Boolean algebras are discussed in more detail. In [BB94] the if-then and if-then-else operators (written :! and / . ) over processes are introduced as well. The if-then operator is equal to ffi if the condition is false.
Reference: [Vis93] <author> E. Visser. </author> <title> Combinatory logic & compilation of list matching. </title> <type> Master's thesis, </type> <institution> University of Amsterdam, Programming Research Group, </institution> <year> 1993. </year>
Reference: [Wir90] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 675-789. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: Reduced models are well-known in algebraic specification, and discussed, e.g., in [EM85, Section 6.8] or <ref> [Wir90, Section 2.2] </ref>.
References-found: 21

