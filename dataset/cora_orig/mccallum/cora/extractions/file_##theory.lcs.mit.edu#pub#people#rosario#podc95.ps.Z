URL: file://theory.lcs.mit.edu/pub/people/rosario/podc95.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~rosario/research.html
Root-URL: 
Title: Achieving independence efficiently and securely  
Author: Rosario Gennaro 
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: Independence or simultaneous broadcast is a fundamental tool to achieve security in fault tolerant distributed computing. It allows n players to commit to independently chosen values. In this paper we present a constant round protocol to perform this task under general complexity assumptions. Previous solutions were all O(log n) rounds. In the process we develop a new and stronger formal definition for this problem. As an example of the importance of independence in distributed protocols, we show an attack on the Sako-Kilian election scheme presented at CRYPTO 94 made possible by the protocol failure on achieving independence. Using our techniques we will show how to modify the scheme to make it secure. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Josh Benaloh and Moti Yung. </author> <title> Distributing the power of a government to enhance the privacy of voters. </title> <booktitle> In 5th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 52-62, </pages> <year> 1986. </year>
Reference-contexts: Notice that the authority would intervene only once and for all. 4 Election Protocols At CRYPTO 94 Sako and Kilian presented a new voting scheme based on partially compatible homomorphisms [13]. Their scheme is based on a previous protocol of Benaloh and Yung <ref> [1] </ref>. They improve on the previous scheme by using a more general family of homomorphic encryption functions based on a discrete-log like problem.
Reference: [2] <author> Manuel Blum, Alfredo De Santis, Silvio Micali, and Giuseppe Persiano. </author> <title> Non-interactive zero-knowledge. </title> <journal> SIAM Journal of Computing, </journal> <volume> 20(6) </volume> <pages> 1084-1118, </pages> <month> Decem-ber </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Independence is a fundamental tool to achieve security in fault tolerant distributed protocols. In this paper we present improved results based on a careful exploitation of the properties of non-interactive proofs <ref> [2] </ref>. In particular we will exhibit the first constant round protocol for the problem of simultaneous broadcast (previous solutions were O (log n) rounds where n is the number of processors in the system). In the process we will develop a new and stronger formal definition for this problem. <p> More in detail: 1. We describe a constant round protocol for simultaneous broadcast under a general cryptographic assumption. In doing that we will heavily rely on the properties of non-interactive zero-knowledge proofs as introduced by Blum, De Santis, Micali and Persiano in <ref> [2] </ref> and De Santis and Persiano in [14]. 2. We refine the definition of independence to a stronger one. In fact both in [5] and in [6] they define the independence property with respect to a polynomial-time bounded observer. <p> this funda mental property. 2 Preliminaries Before we dive into the description of our work, let us recall some preliminary notions that will be useful to us in the following. 2.1 Non-interactive zero-knowledge proofs The notion of zero-knowledge proofs of knowledge without interaction was introduced by Blum et al. in <ref> [2] </ref> Later De Santis and Persiano in [14] specialized it for the case of noninteractive proofs of knowledge. In this section we will review the important ideas of their work and we will also prove a technical lemma which will be useful to us later. <p> Notice that one of the consequences of this lemma is that access to the random string before the choice of the theorem y, does not help in proving false theorems. This fact was already mentioned in the original papers <ref> [2, 14] </ref> and will be important later. 2.2 The Fiat-Shamir heuristic The Fiat-Shamir heuristic is a less rigorous but more efficient way of building non-interactive proofs. The heuristic is based on a secure hash function. <p> But as we noticed in section 2.1 this will not help P i in manufacturing a false proof. We do not need to generate a new string i for each time we perform the protocol. Indeed using results in <ref> [2, 14, 7] </ref> it is known that multiple theorems can be proven using the same random string. These two observations make the random string assumption less problematic than what it may seem at a first look.
Reference: [3] <author> Benny Chor and Cynthia Dwork. </author> <title> Randomization in byzantine agreement. </title> <editor> In S. Micali, editor, </editor> <booktitle> Randomness and Computation, volume 5 of Advances in Computing Research. </booktitle> <publisher> JAI Press, </publisher> <year> 1989. </year>
Reference-contexts: Fault-tolerance would go down accordingly to t = n=3. With some extra assumption about the existence of some authentication mechanism fault-tolerance could be kept at t = n=2 (see <ref> [3] </ref>). Remark 2: The random string. A possible source of worry in this protocol is the fact that the random string i is easily accessible to P i before the beginning. But as we noticed in section 2.1 this will not help P i in manufacturing a false proof.
Reference: [4] <author> Benny Chor, Shafi Goldwasser, Silvio Micali, and Baruch Awerbuch. </author> <title> Verifiable secret sharing and achieving simultaneity in the presence of faults. </title> <booktitle> In 26th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 383-395, </pages> <year> 1985. </year>
Reference-contexts: Using our techniques we will show how to fix this problem and make Sako-Kilian scheme secure. 1.1 Why independence? The problem of independence in distributed computing was introduced by Chor, Goldwasser, Micali and Awerbuch in <ref> [4] </ref> as one of the motivations behind the introduction of Verifiable Secret Sharing protocols. Informally we are looking fl Postal address: 545 Technology Square, Cambridge MA 02139, USA. Email address: rosario@theory.lcs.mit.edu.
Reference: [5] <author> Benny Chor and Michael Rabin. </author> <title> Achieving independence in logarithmic number of rounds. </title> <booktitle> In 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 260-268, </pages> <year> 1987. </year>
Reference-contexts: Even requiring B to send a different cyphertext would not solve the problem since it could still be possible to produce a cyphertext m B 6= m A that decrypts to a lower bid. Example 2 Coin flipping (from <ref> [5] </ref>) n players decide to flip together a common and random coin b. A way to do this would be for each player P i to broadcast a bit b i and then set b to be the XOR of all the broadcasted bits. <p> However in distributed settings this is not enough: we want the cyphertext to be completely useless. As pointed out in [6] independence is clearly an extension of the concept of semantic security. 1.2 Previous work Chor and Rabin in <ref> [5] </ref> put forward a first formal definition for the problem of simultaneous broadcast: a protocol that allows n players to independently announce n bits. Their solution requires O (log n) rounds to complete. <p> In doing that we will heavily rely on the properties of non-interactive zero-knowledge proofs as introduced by Blum, De Santis, Micali and Persiano in [2] and De Santis and Persiano in [14]. 2. We refine the definition of independence to a stronger one. In fact both in <ref> [5] </ref> and in [6] they define the independence property with respect to a polynomial-time bounded observer. That is no polynomial-time Turing machine that has access to a random sample of successful executions of the protocol is able to detect any correlation among the committed values of the players. <p> This formalization guarantees statistical independence of the committed values. This is where our definition differs from the ones presented previously. In fact the definitions in <ref> [5, 6] </ref> require the values b i and r to appear independent to a probabilistic polynomial time judge. If we assume the players to be computationally bounded this is enough to guarantee the independence of their actions. <p> As pointed out in <ref> [5] </ref> and [6] the problem is eliminated by requiring each party to provide a zero-knowledge proof of knowledge of the committed bit. <p> Suppose in fact that a faulty P i and a correct P j are concurrently providing zero-knowledge proofs, then when queried P i could use P j as an oracle to answer his queries. Chor and Rabin in <ref> [5] </ref> solve this problem by a clever way of scheduling the zero-knowledge proofs. In their protocol each player P i broadcast his encryption scheme E i and the encrypted value E i (b i ). Then each player proves in zero-knowledge that he knows b i .
Reference: [6] <author> Danny Dolev, Cynthia Dwork, and Moni Naor. </author> <title> Nonmalleable cryptography. </title> <booktitle> In 23rd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 542-552, </pages> <year> 1991. </year>
Reference-contexts: To explain the concept of independence let us present some motivating scenarios first. Example 1 Contract bidding (from <ref> [6] </ref>) Town T decides to sell part of their estate and invites potential inquirers to bid for the deal. The city publishes a public-key encryption scheme E for interested people to send their bid. Both companies A and B are interested in buying the estate. <p> The reason is that the definition of semantic security for cryptosystems [12] guarantees that given a cyphertext we cannot learn anything about the corresponding cleartext. However in distributed settings this is not enough: we want the cyphertext to be completely useless. As pointed out in <ref> [6] </ref> independence is clearly an extension of the concept of semantic security. 1.2 Previous work Chor and Rabin in [5] put forward a first formal definition for the problem of simultaneous broadcast: a protocol that allows n players to independently announce n bits. <p> Their solution requires O (log n) rounds to complete. Subsequently in a very nice paper <ref> [6] </ref> Dolev, Dwork and Naor, in quite a different setting, addressed the problem of independence of encrypted messages and zero-knowledge proofs. They call their property non-malleability. <p> We refine the definition of independence to a stronger one. In fact both in [5] and in <ref> [6] </ref> they define the independence property with respect to a polynomial-time bounded observer. That is no polynomial-time Turing machine that has access to a random sample of successful executions of the protocol is able to detect any correlation among the committed values of the players. <p> This formalization guarantees statistical independence of the committed values. This is where our definition differs from the ones presented previously. In fact the definitions in <ref> [5, 6] </ref> require the values b i and r to appear independent to a probabilistic polynomial time judge. If we assume the players to be computationally bounded this is enough to guarantee the independence of their actions. <p> As pointed out in [5] and <ref> [6] </ref> the problem is eliminated by requiring each party to provide a zero-knowledge proof of knowledge of the committed bit.
Reference: [7] <author> Uri Feige, Dror Lapidot, and Adi Shamir. </author> <title> Multiple non-interactive zero-knowledge proofs. </title> <booktitle> In 31st IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: But as we noticed in section 2.1 this will not help P i in manufacturing a false proof. We do not need to generate a new string i for each time we perform the protocol. Indeed using results in <ref> [2, 14, 7] </ref> it is known that multiple theorems can be proven using the same random string. These two observations make the random string assumption less problematic than what it may seem at a first look.
Reference: [8] <author> Paul Feldman and Silvio Micali. </author> <title> An optimal probabilistic protocol for synchronous byzantine agreement. </title> <booktitle> In 20th ACM Symposium on Theory of Computing, </booktitle> <year> 1988. </year>
Reference-contexts: In a model in which this broadcast capability is not available, one could substitute each broadcasted message with a Byzantine Agreement protocol. The round complexity of the protocol would obviously go up. For example, using the Byzantine Agreement protocol of Feldman and Micali <ref> [8] </ref> the round complexity would be only expected constant rounds. Fault-tolerance would go down accordingly to t = n=3. With some extra assumption about the existence of some authentication mechanism fault-tolerance could be kept at t = n=2 (see [3]). Remark 2: The random string.
Reference: [9] <author> Rosario Gennaro. </author> <title> A note on the definition of zero-knowledge arguments. </title> <type> Manuscript, </type> <note> submitted to IPL. </note>
Reference-contexts: One M 0 produces the random string and some auxiliary information ff. The second M 1 extracts the witness out of the proof , the random string and the auxiliary information ff. The zero-knowledge condition is slightly different from the traditional one which produces some technical problems (see <ref> [9] </ref> for a discussion of this point.) De Santis and Persiano in [14] prove the existence of NIZKPK for all NP under the assumption that Dense Secure Public-Key Cryptosystems exist.
Reference: [10] <author> Rosario Gennaro and Silvio Micali. </author> <title> Verifiable secret sharing as secure computation. </title> <booktitle> In EUROCRYPT'95, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: During the second phase (called Recover) the trustees put together the shares they received previously and reconstruct s. A more formal definition and treatment of VSS can be found in <ref> [10] </ref>. The VSS protocol we use is due to Goldreich, Micali and Wigderson. It was presented in [11] as an application of their result that every language in NP has a zero-knowledge proof. The protocol works if less than t = n=2 players are dishonest.
Reference: [11] <author> Oded Goldreich, Silvio Micali, and Avi Wigderson. </author> <title> Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. </title> <journal> Journal of the ACM, </journal> <volume> 38(1) </volume> <pages> 691-729, </pages> <year> 1991. </year>
Reference-contexts: During the second phase (called Recover) the trustees put together the shares they received previously and reconstruct s. A more formal definition and treatment of VSS can be found in [10]. The VSS protocol we use is due to Goldreich, Micali and Wigderson. It was presented in <ref> [11] </ref> as an application of their result that every language in NP has a zero-knowledge proof. The protocol works if less than t = n=2 players are dishonest. <p> If t + 1 such votes are casted P i is disqualified and his value is assumed to be ? 4. Each non-disqualified process P i shares his value b i among all players using the VSS protocol of <ref> [11] </ref>. I.e., P i chooses a random polynomial R i (x) of degree t, such that R (0) = b i . P i sends to player P j the value R i (j) encrypted with P j 's public key.
Reference: [12] <author> Shafi Goldwasser and Silvio Micali. </author> <title> Probabilisitc encryption. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28 </volume> <pages> 270-299, </pages> <year> 1984. </year>
Reference-contexts: The examples above show that encryption is necessary to this task, but not sufficient. The reason is that the definition of semantic security for cryptosystems <ref> [12] </ref> guarantees that given a cyphertext we cannot learn anything about the corresponding cleartext. However in distributed settings this is not enough: we want the cyphertext to be completely useless. <p> The protocol goes as following: Protocol Sim-Br 1. Each process P i publishes his own public key encryption scheme E i . E i is actually a probabilistic encryption scheme as in <ref> [12] </ref> 2.
Reference: [13] <author> Kazue Sako and Joe Kilian. </author> <title> Secure voting using partially compatible homomorphisms. </title> <booktitle> In CRYPTO'94, volume 839 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In the process we will develop a new and stronger formal definition for this problem. Finally as a practical example of the importance of independence in distributed protocol we show an attack to the Sako-Kilian election scheme <ref> [13] </ref> made possible by the protocol failure on achieving independence. <p> A fortiori this will be valid for the players themselves and the adversary since we assume them to be polynomially bounded. 3. We address a possible attack on the Sako-Kilian election scheme presented at CRYPTO 94 <ref> [13] </ref>. The idea of using non-interactive proofs to reduce the rounds of communication in a protocol is not new. For example this is what Sako and Kilian do in their protocol. However one must be careful in the use of such a powerful tool. <p> Notice that the authority would intervene only once and for all. 4 Election Protocols At CRYPTO 94 Sako and Kilian presented a new voting scheme based on partially compatible homomorphisms <ref> [13] </ref>. Their scheme is based on a previous protocol of Benaloh and Yung [1]. They improve on the previous scheme by using a more general family of homomorphic encryption functions based on a discrete-log like problem. <p> In particular they make extended use of the Fiat-Shamir heuristic for removing interaction from proofs of knowledge and so improve substantially on the round complexity of the protocol. In this section we will show that the scheme described in <ref> [13] </ref> fails on achieving independence between votes casted by different players. The problem lies on a wrong application of the Fiat-Shamir scheme that brings consequences similar to the ones described in Section 2.1. <p> Finally set T = t 1 + t 2 . T is equal to the difference between "yes" and "no" votes. The zero-knowledge protocol to check the correctness of the proof can be found in the original paper <ref> [13] </ref>. It is a straightforward commit-challenge-reveal protocol. To eliminate interaction the Fiat-Shamir heuristic is used.
Reference: [14] <author> Alfredo De Santis and Giuseppe Persiano. </author> <title> Zero-knowledge proofs of knowledge without interaction. </title> <booktitle> In 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: More in detail: 1. We describe a constant round protocol for simultaneous broadcast under a general cryptographic assumption. In doing that we will heavily rely on the properties of non-interactive zero-knowledge proofs as introduced by Blum, De Santis, Micali and Persiano in [2] and De Santis and Persiano in <ref> [14] </ref>. 2. We refine the definition of independence to a stronger one. In fact both in [5] and in [6] they define the independence property with respect to a polynomial-time bounded observer. <p> we dive into the description of our work, let us recall some preliminary notions that will be useful to us in the following. 2.1 Non-interactive zero-knowledge proofs The notion of zero-knowledge proofs of knowledge without interaction was introduced by Blum et al. in [2] Later De Santis and Persiano in <ref> [14] </ref> specialized it for the case of noninteractive proofs of knowledge. In this section we will review the important ideas of their work and we will also prove a technical lemma which will be useful to us later. <p> We call ffi the view of the protocol. A non-interactive zero-knowledge proof of knowledge (or NIZKPK) for a language L 2 NP (or alternatively for the relationship W IT L ) is a pair of Turing machines (P; V ) that meets the following conditions (see <ref> [14] </ref>); let p n;x denote the acceptance probability P r [ f0; 1g ; V (x; ; ) = ACCEP T ] then we have: Completeness For all x 2 L, p n;x = 1 Soundness There exists two probabilistic polynomial time Turing Machines M 0 and M 1 (called the <p> The second M 1 extracts the witness out of the proof , the random string and the auxiliary information ff. The zero-knowledge condition is slightly different from the traditional one which produces some technical problems (see [9] for a discussion of this point.) De Santis and Persiano in <ref> [14] </ref> prove the existence of NIZKPK for all NP under the assumption that Dense Secure Public-Key Cryptosystems exist. <p> Notice that one of the consequences of this lemma is that access to the random string before the choice of the theorem y, does not help in proving false theorems. This fact was already mentioned in the original papers <ref> [2, 14] </ref> and will be important later. 2.2 The Fiat-Shamir heuristic The Fiat-Shamir heuristic is a less rigorous but more efficient way of building non-interactive proofs. The heuristic is based on a secure hash function. <p> Then each player will share his value among all other player using the VSS protocol from section 2.3. The total number of rounds will be constant. To be able to use NIZKPK we must assume the existence of Dense Secure Public-Key Cryptosystems (see <ref> [14] </ref>.) We assume that the players share a random string of length nk where k is the security parameter (and so we can assume that in order to produce a NIZKPK in our protocol one needs a reference string of length k.) When P i wants to produce a NIZKPK he <p> But as we noticed in section 2.1 this will not help P i in manufacturing a false proof. We do not need to generate a new string i for each time we perform the protocol. Indeed using results in <ref> [2, 14, 7] </ref> it is known that multiple theorems can be proven using the same random string. These two observations make the random string assumption less problematic than what it may seem at a first look.
Reference: [15] <author> Adi Shamir. </author> <title> How to share a secret. </title> <journal> Communications of the ACM, </journal> <volume> 22(11) </volume> <pages> 612-613, </pages> <year> 1979. </year>
Reference-contexts: The adversary VSS Protocol Share-Verify 1. The dealer breaks the secret s in shares s 1 ; : : : ; s n according to Shamir's Secret Sharing protocol <ref> [15] </ref>. That is, he chooses a random polynomial f of degree t such that f (0) = s. Then he sets s i = f (i) 2.
References-found: 15

