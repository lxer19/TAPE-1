URL: ftp://ftp.ai.univie.ac.at/papers/oefai-tr-92-03.ps.Z
Refering-URL: http://www.ai.univie.ac.at/cgi-bin/biblio_ora/?author=Pfahringer&sort_by_year=yes&tailor=1&keyword=bp_lit&loc=0
Root-URL: 
Email: (email: bernhard@ai.univie.ac.at)  
Title: CLP(gRel): Explicit Manipulation of (ground) Relational Dependencies in Logic Programming  
Author: Bernhard Pfahringer 
Keyword: Area: Automated Reasoning/Constraint Logic Programming  
Note: Category: Short Paper  
Address: Schottengasse 3, A-1010 Vienna, Austria  
Affiliation: Austrian Research Institute for Artificial Intelligence  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Bratko I., Mozetic I., Lavrac N.: </author> <title> Kardio A Study in Deep and Qualitative Knowledge for Expert Systems, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: Such constraints can be used to actively prune the search space by detecting combinations of values that are bound to fail early (cf forward checking [5]). The benefit of relations will be demonstrated in the context of a non-toy problem. We are using the KARDIO system <ref> [1] </ref>, a qualitative simulation model of the electrical activity of the heart, to exemplify our points. Given a state of the heart (some combination of arrhythmias) the KARDIO model can be used to compute possible ECG patterns and vice versa. <p> We will just briefly sketch the model, an extensive description of KARDIO can be found in <ref> [1] </ref>. Overly simplified, the heart works electrically as follows: certain generators supply electrical impulses which are in turn conducted and combined through specific pathways. These resultant impulses allow the model to predict possible ECG patterns.
Reference: [2] <author> Carlsson M., Widen J.: </author> <title> Sicstus Prolog Users Manual , Swedish Institute of Computer Science, </title> <address> SICS/R-88/88007C, </address> <year> 1990. </year>
Reference-contexts: Some experimental Prolog systems already support user-defined extensions to unification either by means of meta-structures [10], [7] or by attaching attributes to variables [8]. None is comparable to an industrial-strength Prolog system. But fortunately we were able to use a modified version of Sicstus Prolog <ref> [2] </ref> for implementing our experiments.
Reference: [3] <author> Guesgen H.W., Hertzberg J.: </author> <title> Some Fundamental Properties of Local Constraint Propagation, </title> <booktitle> Artificial Intelligence, </booktitle> <pages> 36(2)237-247, </pages> <year> 1988. </year>
Reference-contexts: Except for [4] we are not aware of any experiments similar to ours. Typically constraint propagation is used to compute some form of local consistency, be it node- or arc- or path-(of some length)consistency <ref> [3] </ref> plus backtrack search in the reduced solution space. E.g. the element predicate in combination with forward-checking as it is introduced in [6] essentially ensures arc-consistency. Our approach results in global consistency for given variables and is able to combine partial solutions dynamically thus interweaving backtrack search with consistency checks.
Reference: [4] <author> Freuder E.C.: </author> <title> Synthesizing Constraint Expressions, </title> <booktitle> in Communications of the ACM , 21(11), </booktitle> <year> 1978. </year>
Reference-contexts: Except for <ref> [4] </ref> we are not aware of any experiments similar to ours. Typically constraint propagation is used to compute some form of local consistency, be it node- or arc- or path-(of some length)consistency [3] plus backtrack search in the reduced solution space.
Reference: [5] <editor> Hentenryck P.van, Dincbas M.: </editor> <booktitle> Domains in Logic Programming, in Proceedings of the Fifth National Conference on Artificial Intelligence (AAAI-86), </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction In this paper we show how domain variables, a successful constraint propagation technique introduced by <ref> [5] </ref>, can be generalized to capture relational dependencies of logical variables. Unification will be extended to handle variables ranging over relations correctly (and efficiently). Such constraints can be used to actively prune the search space by detecting combinations of values that are bound to fail early (cf forward checking [5]). <p> by <ref> [5] </ref>, can be generalized to capture relational dependencies of logical variables. Unification will be extended to handle variables ranging over relations correctly (and efficiently). Such constraints can be used to actively prune the search space by detecting combinations of values that are bound to fail early (cf forward checking [5]). The benefit of relations will be demonstrated in the context of a non-toy problem. We are using the KARDIO system [1], a qualitative simulation model of the electrical activity of the heart, to exemplify our points.
Reference: [6] <author> Hentenryck P.van: </author> <title> Constraint Satisfaction in Logic Programming, </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1989. </year> <month> 5 </month>
Reference-contexts: Typically constraint propagation is used to compute some form of local consistency, be it node- or arc- or path-(of some length)consistency [3] plus backtrack search in the reduced solution space. E.g. the element predicate in combination with forward-checking as it is introduced in <ref> [6] </ref> essentially ensures arc-consistency. Our approach results in global consistency for given variables and is able to combine partial solutions dynamically thus interweaving backtrack search with consistency checks. This approach is of course not a panacea for all kind of search problems.
Reference: [7] <author> Holzbaur C.: </author> <title> Specification of Constraint Based Inference Mechanisms through Ex--tended Unification, </title> <institution> Institut fuer Med.Kybernetik u. AI, Universitaet Wien, Dissertation, </institution> <year> 1990. </year>
Reference-contexts: Unification being such a basic operation in a logic programming environment, it cannot be delegated to a meta-interpreter when expecting reasonable efficiency. Some experimental Prolog systems already support user-defined extensions to unification either by means of meta-structures [10], <ref> [7] </ref> or by attaching attributes to variables [8]. None is comparable to an industrial-strength Prolog system. But fortunately we were able to use a modified version of Sicstus Prolog [2] for implementing our experiments.
Reference: [8] <author> Huitouze S.le: </author> <title> A new data structure for implementing extensions to Prolog, </title> <editor> in De-ransart P., Maluszunski J.(eds.), </editor> <booktitle> Programming Language Implementation and Logic Programming, </booktitle> <publisher> Springer, Heidelberg, </publisher> <pages> 136-150, </pages> <year> 1990. </year>
Reference-contexts: Unification being such a basic operation in a logic programming environment, it cannot be delegated to a meta-interpreter when expecting reasonable efficiency. Some experimental Prolog systems already support user-defined extensions to unification either by means of meta-structures [10], [7] or by attaching attributes to variables <ref> [8] </ref>. None is comparable to an industrial-strength Prolog system. But fortunately we were able to use a modified version of Sicstus Prolog [2] for implementing our experiments.
Reference: [9] <author> Jaffar J., Michaylov S.: </author> <title> Methodology and Implementation of a CLP System, </title> <booktitle> in Logic Programming Proceedings of the 4th International Conference Volume 1 , MIT Press, </booktitle> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: By use of CLP (gRel) the latter can be sped up without changing the structure of the model considerably. This paper is outlined as follows: Section 2 defines domain variables and CLP (gRel), an instance of the general CLP scheme <ref> [9] </ref> able to handle (g)round (rel)ational dependencies of variables. Section 3 gives a procedural semantics by means of meta-interpreter. Section 4 introduces the KARDIO model and reports on experimental results.
Reference: [10] <author> Neumerkel U.: </author> <title> Extensible Unification by Metastructures, </title> <booktitle> Proc. </booktitle> <address> META90, </address> <year> 1990. </year>
Reference-contexts: Unification being such a basic operation in a logic programming environment, it cannot be delegated to a meta-interpreter when expecting reasonable efficiency. Some experimental Prolog systems already support user-defined extensions to unification either by means of meta-structures <ref> [10] </ref>, [7] or by attaching attributes to variables [8]. None is comparable to an industrial-strength Prolog system. But fortunately we were able to use a modified version of Sicstus Prolog [2] for implementing our experiments.
Reference: [11] <author> Pfahringer B.: </author> <title> Constraint Propagation in Qualitative Modeling: Domains Variables Improve Diagnostic Efficiency, </title> <booktitle> in Proceedings of the Eighth Conference on Artificial Intelligence and Simulation of Behaviour (AISB91), </booktitle> <publisher> Springer, </publisher> <address> London, UK, </address> <year> 1991. </year> <month> 6 </month>
Reference-contexts: As the table given in the previous section shows, CLP (gRel) 3 In an earlier paper we have reported on results implementing domain variables in standard Prolog <ref> [11] </ref>; for the experiments reported in this paper we have used the above mentioned modified Sicstus-Prolog for a straight-forward implementation of domain variables by means of attributed variables 4 can sometimes even be used successfully if one is only interested in one single of all possible solutions, but this is certainly
References-found: 11

