URL: ftp://ftp.csd.uu.se/pub/papers/reports/0082.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Tabulation of Functions in Definite Clause Programs  
Author: Jonas Barklund 
Address: 311, S-751 05 Uppsala, Sweden  
Affiliation: Box  
Abstract: UPMAIL Technical Report No. 82 11 September, 1994 Abstract An extended version of the applicative caching technique from functional programming is adapted to OLD resolution as an alternative to OLDT resolution for predicates that are actually functions. An inference system, OLDTF resolution, is given with a proof procedure. It is argued why this special case is interesting in its own right also outside the area of deductive databases. It is outlined how special cases of our technique can be used to declaratively incorporate efficient data structures with state in logic programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Apt, K. R., </author> <title> Logic Programming, </title> <editor> in: J. van Leeuwen (ed.), </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, </booktitle> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: In general we will follow the usual computational logic terminology <ref> [1, 21] </ref>.
Reference: [2] <author> Barklund, J. and Millroth, H., </author> <title> Hash Tables in Logic Programming, </title> <editor> in: J.- L. Lassez (ed.), </editor> <booktitle> Logic Programming | Proc. Fourth Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: It is also worth mentioning that the ideas described above for using efficient data structures for tabulation of certain kinds of functions can be seen as an alternative to the methods for introducing complex data structures in logic programming proposed earlier by us and others <ref> [2, 3, 12] </ref>.
Reference: [3] <author> Barklund, J. and Millroth, H., </author> <title> Integrating Complex Data Structures in Prolog, </title> <editor> in: S. Haridi (ed.), </editor> <booktitle> Proc. 1987 Symp. on Logic Programming, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Washington, D.C., </address> <year> 1987. </year>
Reference-contexts: It is also worth mentioning that the ideas described above for using efficient data structures for tabulation of certain kinds of functions can be seen as an alternative to the methods for introducing complex data structures in logic programming proposed earlier by us and others <ref> [2, 3, 12] </ref>.
Reference: [4] <author> Bellman, R. E., </author> <title> Dynamic Programming, </title> <publisher> Princeton Univ. Press, </publisher> <address> Princeton, N.J., </address> <year> 1957. </year>
Reference-contexts: Tabulation techniques have their roots in techniques for transforming recursive computations to iterative computations [5, 16, 25], based on a normal form theorem by Kleene [19], as well as in dynamic programming <ref> [4, 11] </ref>. Tabulation is also closely related to the technique of replacing an expression, once it has been reduced (possibly to normal form), with its reduced (possibly normal) form [14].
Reference: [5] <author> Bird, R. S., </author> <title> Improving Programs by the Introduction of Recursion, </title> <journal> Commun. ACM, </journal> 20(11) 856-863 (1977). 
Reference-contexts: Tabulation techniques have their roots in techniques for transforming recursive computations to iterative computations <ref> [5, 16, 25] </ref>, based on a normal form theorem by Kleene [19], as well as in dynamic programming [4, 11]. Tabulation is also closely related to the technique of replacing an expression, once it has been reduced (possibly to normal form), with its reduced (possibly normal) form [14].
Reference: [6] <author> Bird, R. S., </author> <title> Tabulation Techniques for Recursive Programs, </title> <journal> ACM Comput. Surv., </journal> <volume> 12(4) </volume> <month> 403-417 </month> <year> (1980). </year>
Reference-contexts: 1 Introduction In a programming language with referential transparency, an expression can be replaced with any other expression that has the same meaning. Tabulation in functional programming In functional programming languages this has been exploited through a technique called tabulation or memoing <ref> [6, 15, 18, 23] </ref>. This means to maintain, for selected functions, a table of pairs of domain-codomain elements that have already been computed. Further applications of the function to values for which there are "cached" results can be solved by simple table look-ups.
Reference: [7] <author> Bol, R. and Degerstedt, L., </author> <title> Tabulated Resolution for Well Founded Semantics, </title> <editor> in: D. Miller (ed.), </editor> <booktitle> Logic Programming | Proc. 1993 Intl. Symp, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year> <month> 13 </month>
Reference-contexts: This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa [32] and Haskell [17]. Tabulation in logic programming Tabulation has also been applied to logic programming languages <ref> [7, 8, 9, 10, 31, 33] </ref>, through construction of an explicit representation of those instances of a goal atom that are logical consequences of the program.
Reference: [8] <author> Bol, R. and Degerstedt, L., </author> <title> The Underlying Search for Magic Templates and Tabulation, </title> <editor> in: D. S. Warren (ed.), </editor> <booktitle> Logic Programming | Proc. Tenth Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa [32] and Haskell [17]. Tabulation in logic programming Tabulation has also been applied to logic programming languages <ref> [7, 8, 9, 10, 31, 33] </ref>, through construction of an explicit representation of those instances of a goal atom that are logical consequences of the program.
Reference: [9] <author> Chen, W. and Warren, D. S., </author> <title> A Goal-Oriented Approach to Computing Well Founded Semantics, </title> <editor> in: K. R. Apt (ed.), </editor> <booktitle> Logic Programming | Proc. Joint Intl. Conf. and Symp. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa [32] and Haskell [17]. Tabulation in logic programming Tabulation has also been applied to logic programming languages <ref> [7, 8, 9, 10, 31, 33] </ref>, through construction of an explicit representation of those instances of a goal atom that are logical consequences of the program. <p> efficient data structures for tabulation of special cases of functions, e.g., arrays, stream, sequences and simple variables. * Adding tabulation of functions to a real Prolog system, hopefully rep resenting tables using some of the data structures mentioned above. * Investigating the possibility of exploiting tabulation of functions in SLG-resolution <ref> [9] </ref> and the XSB engine [30]. * Running benchmarks to measure the time and space requirements with and without tabulation and for various data structures. 12 * Investigating a programming methodology that is supported by this form of tabulation. * Writing larger application programs that use this form of tabulation. 11
Reference: [10] <author> Dietrich, S. W., </author> <title> Extension Tables: Memo Relations in Logic Programming, </title> <editor> in: S. Haridi (ed.), </editor> <booktitle> Proc. 1987 Symp. on Logic Programming, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Washington, D.C., </address> <year> 1987. </year>
Reference-contexts: This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa [32] and Haskell [17]. Tabulation in logic programming Tabulation has also been applied to logic programming languages <ref> [7, 8, 9, 10, 31, 33] </ref>, through construction of an explicit representation of those instances of a goal atom that are logical consequences of the program. <p> The space requirements may also be a significant problem, we have so far seen no study of reusing storage occupied by OLDT tables. Warren argues [35] that the OLDT resolution by Tamaki & Sato [31], the extension tables by Dietrich & Warren <ref> [10] </ref> and the SLD-AL resolution by Vieille [33] are essentially the same and gives a uniform presentation of them that we will essentially follow below when discussing OLDT resolution and its variants. In general we will follow the usual computational logic terminology [1, 21].
Reference: [11] <author> Dietrich, S. W., </author> <title> Shortest Path by Approximation in Logic Programs, </title> <journal> ACM Lett. Program. Lang. Syst., </journal> <volume> 1(2) </volume> <month> 119-137 </month> <year> (1992). </year>
Reference-contexts: Tabulation techniques have their roots in techniques for transforming recursive computations to iterative computations [5, 16, 25], based on a normal form theorem by Kleene [19], as well as in dynamic programming <ref> [4, 11] </ref>. Tabulation is also closely related to the technique of replacing an expression, once it has been reduced (possibly to normal form), with its reduced (possibly normal) form [14].
Reference: [12] <author> Eriksson, L.-H. and Rayner, M., </author> <title> Incorporating Mutable Arrays into Logic Programming, </title> <editor> in: S. A. Tarnlund (ed.), </editor> <booktitle> Proc. Second Intl. Logic Programming Conf., </booktitle> <publisher> Ord & Form, </publisher> <address> Uppsala, </address> <year> 1984. </year>
Reference-contexts: It is also worth mentioning that the ideas described above for using efficient data structures for tabulation of certain kinds of functions can be seen as an alternative to the methods for introducing complex data structures in logic programming proposed earlier by us and others <ref> [2, 3, 12] </ref>.
Reference: [13] <author> Fredkin, E., </author> <title> Trie Memory, </title> <journal> J. ACM, </journal> <volume> 3(9) </volume> <month> 490-500 </month> <year> (1960). </year>
Reference-contexts: Or suppose that the user has specified that some ternary predicate symbol q denotes a function in its third argument with strings as its domain. That ought to make the language processor use a trie structure <ref> [13] </ref> (with pairs of values at the tips) for tabulating q. 5 One of the most interesting possibilities is letting the programmer advise the language processor to use a limited data structure for tabulation.
Reference: [14] <author> Friedman, D. P. and Wise, D. S., </author> <title> CONS Should Not Evaluate its Arguments, in: Automata, Languages and Programming, </title> <publisher> Edinburgh Univ. Press, </publisher> <year> 1976. </year>
Reference-contexts: Tabulation is also closely related to the technique of replacing an expression, once it has been reduced (possibly to normal form), with its reduced (possibly normal) form <ref> [14] </ref>. Because of sharing in the representation of expressions in a programming language, this may shortcut further attempts to reduce occurrences of that expression. This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa [32] and Haskell [17].
Reference: [15] <author> Friedman, D. P., Wise, D. S. and Wand, M., </author> <title> Recursive Programming through Table Look-Up, </title> <booktitle> in: Symposium on Symbolic and Algebraic Computation, ACM, </booktitle> <address> New York, N.Y., </address> <year> 1976. </year>
Reference-contexts: 1 Introduction In a programming language with referential transparency, an expression can be replaced with any other expression that has the same meaning. Tabulation in functional programming In functional programming languages this has been exploited through a technique called tabulation or memoing <ref> [6, 15, 18, 23] </ref>. This means to maintain, for selected functions, a table of pairs of domain-codomain elements that have already been computed. Further applications of the function to values for which there are "cached" results can be solved by simple table look-ups.
Reference: [16] <author> Hilden, J., </author> <title> Elimination of Recursive Calls Using a Small Table of "Randomly" Selected Function Values, </title> <journal> BIT, </journal> <volume> 16 </volume> <month> 60-73 </month> <year> (1976). </year>
Reference-contexts: Tabulation techniques have their roots in techniques for transforming recursive computations to iterative computations <ref> [5, 16, 25] </ref>, based on a normal form theorem by Kleene [19], as well as in dynamic programming [4, 11]. Tabulation is also closely related to the technique of replacing an expression, once it has been reduced (possibly to normal form), with its reduced (possibly normal) form [14].
Reference: [17] <editor> Hudak, P. et al., </editor> <title> Report on the Programming Language Haskell, </title> <journal> SIGPLAN Notices, </journal> <month> 25(5) </month> <year> (1992). </year>
Reference-contexts: Because of sharing in the representation of expressions in a programming language, this may shortcut further attempts to reduce occurrences of that expression. This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa [32] and Haskell <ref> [17] </ref>. Tabulation in logic programming Tabulation has also been applied to logic programming languages [7, 8, 9, 10, 31, 33], through construction of an explicit representation of those instances of a goal atom that are logical consequences of the program. <p> Finally, a predicate denoting a function having a contiguous integer range as domain and that therefore can be tabulated using a function has an interesting similarity with the lazy array comprehensions of Haskell <ref> [17] </ref>: a data structure for which there is a procedure that can compute the elements on demand and then store them, and to some extent also with monolithic array expressions in other languages (e.g, the constructor-implied-do array constructors of Fortran 90 [22]).
Reference: [18] <author> Keller, R. M. and Sleep, M. R., </author> <title> Applicative Caching, </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 8(1) </volume> <month> 88-108 </month> <year> (1986). </year>
Reference-contexts: 1 Introduction In a programming language with referential transparency, an expression can be replaced with any other expression that has the same meaning. Tabulation in functional programming In functional programming languages this has been exploited through a technique called tabulation or memoing <ref> [6, 15, 18, 23] </ref>. This means to maintain, for selected functions, a table of pairs of domain-codomain elements that have already been computed. Further applications of the function to values for which there are "cached" results can be solved by simple table look-ups. <p> This is a serious problem when using tabulation in practice because the tables can become very large and may contain much information that is unlikely to ever be accessed again. Unlike OLDT resolution, but like "applicative caching" <ref> [18] </ref>, OLDTF resolution allows table entries to be removed. The effect on the algorithm is simply that an answer tuple or none is recomputed. <p> Any advice by the programmer affecting a choice of data structure merely affects how a result is computed, not what is computed. 5 Keller & Sleep also suggest to use trie structures but in a slightly different way: for tabulating a function with a large domain of integers <ref> [18] </ref>. 11 9 Related Work We have already introduced much of the related work done previously on tabulation for functional and logic programs, on tabulation for transformation from recursion to iteration and on dynamic programming. <p> Let us make explicit that our work has been influenced particularly by the work of Keller & Sleep <ref> [18] </ref> on applicative caching and the work by Tamaki & Sato on OLDT resolution [31], presumably the first published proof procedure with tabulation for definite clause programs.
Reference: [19] <author> Kleene, S. C., </author> <title> Introduction to Meta-Mathematics, </title> <publisher> North-Holland, </publisher> <year> 1952. </year>
Reference-contexts: Tabulation techniques have their roots in techniques for transforming recursive computations to iterative computations [5, 16, 25], based on a normal form theorem by Kleene <ref> [19] </ref>, as well as in dynamic programming [4, 11]. Tabulation is also closely related to the technique of replacing an expression, once it has been reduced (possibly to normal form), with its reduced (possibly normal) form [14].
Reference: [20] <author> Kowalski, R. A., </author> <title> Algorithm = Logic + Control, </title> <journal> Commun. ACM, </journal> <volume> 22(7) </volume> <month> 424-435 </month> <year> (1979). </year>
Reference-contexts: The definite program exclusively specifies the logic of the program while the tabulation statements exclusively specify the control of the program. We thus see that the separation of logic and control proposed by Kowalski <ref> [20] </ref> for systematic development of algorithms and programs has been achieved. This lends further support to our intuitive feeling that tabulation of functions and tabulation statements are useful additions to computational logic.
Reference: [21] <author> Lloyd, J. W., </author> <title> Foundations of Logic Programming, second edition, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: In general we will follow the usual computational logic terminology <ref> [1, 21] </ref>. <p> t k )) is a partial function of atoms that yields a tuple of those terms that are marked with in the mode atom (the "output terms"). 4 Definite Programs with Tabulation Statements For this presentation we employ the usual definitions of definite programs and their constituents (see, e.g., Lloyd <ref> [21] </ref>); we shall not waste space by repeating them here. We define a definite TS program to be a definite program extended with a set of tabulation statements.
Reference: [22] <author> Metcalf, M. and Reid, J., </author> <title> Fortran 90 Explained, </title> <publisher> Oxford Univ. Press, Oxford, </publisher> <year> 1990. </year>
Reference-contexts: interesting similarity with the lazy array comprehensions of Haskell [17]: a data structure for which there is a procedure that can compute the elements on demand and then store them, and to some extent also with monolithic array expressions in other languages (e.g, the constructor-implied-do array constructors of Fortran 90 <ref> [22] </ref>). One difference is that in our case the array appears as a named predicate, while the Haskell array is an "anonymous" value. 10 Future Work As stated before, the purpose of this paper is to introduce a formal framework for inference with tabulation of functions.
Reference: [23] <author> Michie, D., </author> <title> `Memo' Functions and Machine Learning, </title> <journal> Nature, </journal> <volume> 218 </volume> <month> 19-22 </month> <year> (1968). </year>
Reference-contexts: 1 Introduction In a programming language with referential transparency, an expression can be replaced with any other expression that has the same meaning. Tabulation in functional programming In functional programming languages this has been exploited through a technique called tabulation or memoing <ref> [6, 15, 18, 23] </ref>. This means to maintain, for selected functions, a table of pairs of domain-codomain elements that have already been computed. Further applications of the function to values for which there are "cached" results can be solved by simple table look-ups.
Reference: [24] <author> Ramakrishnan, R., </author> <title> Magic Templates: A Spellbinding Approach to Logic Programs, </title> <journal> J. Logic Program., </journal> <volume> 11 </volume> <month> 189-216 </month> <year> (1991). </year>
Reference-contexts: This may be justifiable in the context of deductive databases, because such answers do not arise for range-restricted Datalog programs and that restriction is necessary also to avoid difficulties when using the Magic Template transformation <ref> [24] </ref> for bottom-up computation. For tabulation of functions the problem apparently disappears. If the procedure terminates in step 7b, step 7d or step 8 then the particular resolution path chosen fails finitely, but some other path might succeed. Note that the procedure above never enters none in a table.
Reference: [25] <author> Rice, H. G., </author> <title> Recursion and Iteration, </title> <journal> Commun. ACM, </journal> <volume> 8(2) </volume> <month> 114-115 </month> <year> (1965). </year> <month> 14 </month>
Reference-contexts: Tabulation techniques have their roots in techniques for transforming recursive computations to iterative computations <ref> [5, 16, 25] </ref>, based on a normal form theorem by Kleene [19], as well as in dynamic programming [4, 11]. Tabulation is also closely related to the technique of replacing an expression, once it has been reduced (possibly to normal form), with its reduced (possibly normal) form [14].
Reference: [26] <author> Robinson, J. A., </author> <title> A Machine-Oriented Logic Based on the Resolution Principle, </title> <journal> J. ACM, </journal> <volume> 12(1) </volume> <month> 23-41 </month> <year> (1965). </year>
Reference-contexts: In each step, the new sequent is obtained from the previous by adding a goal clause that is a resolvent of a program clause and a goal clause in the previous sequent. Such sequents are equivalent <ref> [26] </ref>. As we only add goal clauses to sequents, the definite TS program P is the same in every sequent. Therefore the representation of the sequents (see step 2 below) does not explicitly contain P .
Reference: [27] <author> Robinson, J. A., </author> <booktitle> Notes on Logic Programming, in: Logic of Programming and Calculi of Discrete Design, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: The following non-deterministic procedure proves a clausal sequent P ) fGg, where P is a definite TS program and G is a definite goal clause. 4 The sequent form of presentation is inspired by Robinson's style of presentation <ref> [27] </ref>.
Reference: [28] <author> Schonfinkel, M., </author> <title> Uber die Bausteine der mathematischen Logik, </title> <journal> Math. Ann., </journal> <volume> 92 </volume> <month> 305-316 </month> <year> (1924). </year>
Reference-contexts: is worth pointing out that there may meaningfully be multiple tabulation statements mentioning the same predicate symbol, for example, if the predicate symbol denotes a bijective function. 4 Let us define three metafunctions of mode atoms that we shall use in our proof procedure below. (All three functions are "curried" <ref> [28, 29] </ref>, because the intention is that applying them to particular mode atoms should yield particular tests and selectors on atoms.) * Let applicable be a function of type mode_atom ! (atom ! ftrue; falseg), such that applicable (p (t 1 ; : : :; t k ))(q (u 1 ;
Reference: [29] <author> Stoy, J. E., </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1977. </year>
Reference-contexts: is worth pointing out that there may meaningfully be multiple tabulation statements mentioning the same predicate symbol, for example, if the predicate symbol denotes a bijective function. 4 Let us define three metafunctions of mode atoms that we shall use in our proof procedure below. (All three functions are "curried" <ref> [28, 29] </ref>, because the intention is that applying them to particular mode atoms should yield particular tests and selectors on atoms.) * Let applicable be a function of type mode_atom ! (atom ! ftrue; falseg), such that applicable (p (t 1 ; : : :; t k ))(q (u 1 ;
Reference: [30] <author> Swift, T. and Warren, D. S., </author> <title> An Abstract Machine for SLG Resolution, </title> <type> Technical report, </type> <institution> Dept. of Computer Science, SUNY at Stony Brook, </institution> <year> 1994. </year>
Reference-contexts: of special cases of functions, e.g., arrays, stream, sequences and simple variables. * Adding tabulation of functions to a real Prolog system, hopefully rep resenting tables using some of the data structures mentioned above. * Investigating the possibility of exploiting tabulation of functions in SLG-resolution [9] and the XSB engine <ref> [30] </ref>. * Running benchmarks to measure the time and space requirements with and without tabulation and for various data structures. 12 * Investigating a programming methodology that is supported by this form of tabulation. * Writing larger application programs that use this form of tabulation. 11 Conclusions We have moved ideas
Reference: [31] <author> Tamaki, H. and Sato, T., </author> <title> OLD Resolution with Tabulation, </title> <editor> in: E. Shapiro (ed.), </editor> <booktitle> Third Intl. Conf. on Logic Programming | Proc., </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa [32] and Haskell [17]. Tabulation in logic programming Tabulation has also been applied to logic programming languages <ref> [7, 8, 9, 10, 31, 33] </ref>, through construction of an explicit representation of those instances of a goal atom that are logical consequences of the program. <p> The space requirements may also be a significant problem, we have so far seen no study of reusing storage occupied by OLDT tables. Warren argues [35] that the OLDT resolution by Tamaki & Sato <ref> [31] </ref>, the extension tables by Dietrich & Warren [10] and the SLD-AL resolution by Vieille [33] are essentially the same and gives a uniform presentation of them that we will essentially follow below when discussing OLDT resolution and its variants. <p> For a more detailed introduction to OLDT resolution, see the overview by Warren [35]; for a complete description see, e.g., the description by Tamaki & Sato <ref> [31] </ref>. 2 Tabulation of Functions Firstly, it is our experience that most relations expressed through definite clause logic programs are actually intended by the programmer to be functional in some of the arguments. (If nothing else, any k-ary relation might be thought of as a function from k-tuples to the truth <p> Let us make explicit that our work has been influenced particularly by the work of Keller & Sleep [18] on applicative caching and the work by Tamaki & Sato on OLDT resolution <ref> [31] </ref>, presumably the first published proof procedure with tabulation for definite clause programs.
Reference: [32] <author> Turner, D. A., Miranda: </author> <title> A Non-Strict Functional Language with Polymorphic Types, </title> <booktitle> in: Functional Programming Languages and Computer Architecture, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: Because of sharing in the representation of expressions in a programming language, this may shortcut further attempts to reduce occurrences of that expression. This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa <ref> [32] </ref> and Haskell [17]. Tabulation in logic programming Tabulation has also been applied to logic programming languages [7, 8, 9, 10, 31, 33], through construction of an explicit representation of those instances of a goal atom that are logical consequences of the program.
Reference: [33] <author> Vieille, L., </author> <title> Recursive Query Processing: the Power of Logic, </title> <journal> Theor. Comput. Sci., </journal> <volume> 69(1) </volume> <month> 1-53 </month> <year> (1989). </year>
Reference-contexts: This technique underlies the efficient implementation of functional programming languages with "call-by-name" semantics, implemented through a leftmost computation rule, such as Mi-randa [32] and Haskell [17]. Tabulation in logic programming Tabulation has also been applied to logic programming languages <ref> [7, 8, 9, 10, 31, 33] </ref>, through construction of an explicit representation of those instances of a goal atom that are logical consequences of the program. <p> The space requirements may also be a significant problem, we have so far seen no study of reusing storage occupied by OLDT tables. Warren argues [35] that the OLDT resolution by Tamaki & Sato [31], the extension tables by Dietrich & Warren [10] and the SLD-AL resolution by Vieille <ref> [33] </ref> are essentially the same and gives a uniform presentation of them that we will essentially follow below when discussing OLDT resolution and its variants. In general we will follow the usual computational logic terminology [1, 21].
Reference: [34] <author> Warren, D. H. D., </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Tech. Note 309, </type> <institution> SRI Intl., Menlo Park, Calif., </institution> <year> 1983. </year>
Reference-contexts: We have not yet implemented OLDTF resolution, but we believe that the general mechanism described so far could be added to Prolog according to the following outline: * Extend Warren's abstract Prolog machine <ref> [34] </ref> with some representa tion of general look-up tables (e.g., trees or hash tables). * For every tabulation statement: Add a prelude to the code for the predicate, performing a look-up in the corresponding table.
Reference: [35] <author> Warren, D. S., </author> <title> Memoing for Logic Programs, </title> <journal> Commun. ACM, </journal> <volume> 35(3) </volume> <month> 93-111 </month> <year> (1992). </year>
Reference-contexts: In particular, OLD resolution with tabulation (OLDT resolution) terminates for all Datalog programs <ref> [35] </ref>. This explains why tabulation has been studied primarily as a technique for deductive databases and not so much as a technique for running arbitrary logic programs, where termination is usually the responsibility of the programmer. <p> The space requirements may also be a significant problem, we have so far seen no study of reusing storage occupied by OLDT tables. Warren argues <ref> [35] </ref> that the OLDT resolution by Tamaki & Sato [31], the extension tables by Dietrich & Warren [10] and the SLD-AL resolution by Vieille [33] are essentially the same and gives a uniform presentation of them that we will essentially follow below when discussing OLDT resolution and its variants. <p> For a more detailed introduction to OLDT resolution, see the overview by Warren <ref> [35] </ref>; for a complete description see, e.g., the description by Tamaki & Sato [31]. 2 Tabulation of Functions Firstly, it is our experience that most relations expressed through definite clause logic programs are actually intended by the programmer to be functional in some of the arguments. (If nothing else, any k-ary
References-found: 35

