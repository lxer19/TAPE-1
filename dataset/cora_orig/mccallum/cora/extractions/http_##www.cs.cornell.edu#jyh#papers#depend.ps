URL: http://www.cs.cornell.edu/jyh/papers/depend.ps
Refering-URL: http://www.cs.cornell.edu/jyh/cornell-papers.html
Root-URL: 
Title: Formal Abstract Data Types  
Author: Jason J. Hickey 
Date: December 7, 1995  
Abstract: Current constructive type theories are powerful systems for describing mathematical objects with complex dependencies between types and computational values, making them expressive enough to encompass large ares of mathematics and programming. However, as the body of formal knowledge in the type theory expands, the problem of managing mathematical domains and their proofs becomes increasingly significant. Though the objects of the theory are formal, the domains are not. In this paper, we show how to apply the methods of formal data abstraction to the organization of the mathematical domains. In the process we expand the tools of data abstraction to include reusability and namespace organization, providing an environment that can be used for defining objects within a domain, for organizing domains within a type theory, and for organizing theories within a system. This environment will require extending the expres-sivness of inductive definitions within the type theory to include the dependent characteristics of type theoretical domains.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Second-order systems. </title> <booktitle> In Proceedings of European Symposium on Programming, </booktitle> <pages> pages 1-24. </pages> <publisher> Springer, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The view that a user takes of an object is a matter of preference; all views have the same underlying meaning. 5 related-work There has been widespread research into formal methods for object-oriented programming. Abadi and Cardelli <ref> [2, 1] </ref> have defined several typed and untyped object calculi. They demonstrate how hard it is to find a semantics for an object-calculus, and they eventually use an axiomatic untyped semantics. They also model the method selection as a combination of field selection and self-application.
Reference: [2] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Untyped and first-order systems. </title> <booktitle> Theoretical Aspects of Computer Software, </booktitle> <pages> pages 296-320, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Signatures are themselves types, and may be used to specify the method types of further objects. We differ from the standard (for example Abadi and Cardelli <ref> [2] </ref>) in that the methods are simple types, not dependent upon the signature being defined. <p> In later sections of this paper, we will deal with 11 domains where method override does not make sense, and we will not include it as a feature of the object system. To handle method interdependence, we include a self-application within a method invocation. In the literature <ref> [2, 17] </ref>, and in many implementations, objects are treated as records, and method invocation is then a composition of field selection and self-application. <p> The view that a user takes of an object is a matter of preference; all views have the same underlying meaning. 5 related-work There has been widespread research into formal methods for object-oriented programming. Abadi and Cardelli <ref> [2, 1] </ref> have defined several typed and untyped object calculi. They demonstrate how hard it is to find a semantics for an object-calculus, and they eventually use an axiomatic untyped semantics. They also model the method selection as a combination of field selection and self-application.
Reference: [3] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 104-118. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: Their type system allows methods to be specialized as they are inherited, by polymorphism over subtypes. Much of the basic theory of object-oriented programming is based on record calculi, and the semantics of subtyping and record extension. Amadio and Cardelli <ref> [3] </ref> discuss subtyping in the presence of recursion. In general, recursive subtyping produces a type larger than simple "record extension." Harper and Pierce [11] present a record calculus, and they apply some of their work to an ML-style module system [10].
Reference: [4] <author> H.P. Barendregt. </author> <title> The Lambda Calculus, Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference: [5] <author> David A. Basin and Robert L. Constable. </author> <booktitle> Metalogic Frameworks, </booktitle> <pages> pages 1-29. </pages> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Cardelli, Mitchell, and Remy develop record calculi. Kamin and Reddy give semantics models of inheritance in record calculi, and Cook, Hill and and Canning decouple inheritance and subtyping, as in a language like Eiffel [16]. There is relatively less work on an interpretation of theories. Basic and Constable <ref> [5] </ref> discuss logical frameworks. They present a meta-logic that is similar our presentation of theories in 4. In their framework, the language of the logic and its proofs are formal objects belonging to abstract data types in some meta-type-theory.
Reference: [6] <author> R. Breu. </author> <title> Algebraic Specification Techniques in Object Oriented Programming Environments. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Wand [20, 21] consider type-inference in the setting of record extension and multiple inheritance, a property that we do not discuss in this paper, but is a useful practical tool. Breu <ref> [6] </ref> applies the techiques of algebraic specification to objects and their signatures. Dybjer has produced results on dependent inductive types with a set theoretic semantics. There is a wealth of information on formal object systems in Gunter and Mitchell [9].
Reference: [7] <author> R.L. Constable, S.F. Allen, H.M. Bromley, W.R. Cleaveland, J.F. Cremer, R.W. Harper, D.J. Howe, T.B. Knoblock, N.P. Mender, P. Panangaden, J.T. Sasaki, and S.F. Smith. </author> <title> Implementing Mathematics in the NuPRL Proof Development Systen. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: While each function described by F is also included in N ! N, clearly F is a more precise specification for the set of functions we are interested in. Inductive types are used to describe recursive objects such as lists and trees. In NuPRL <ref> [7] </ref> simple inductive types are described with an inductive type constructor (X:T ) where X is bound in the term T and represents the fixed point, i.e. (X:T ) = T [ (X:T ) =X]. <p> Pitts [19] presents a view of theories as categories. In many ways, the categorical view is similar to an object approach, where signatures are viewed as categories. Jackson [12] has provided a rich formal environment in the NuPRL system <ref> [7] </ref> and applied it to constructive abstract algebra. Jsckson's work provides the grounds for this proposal|due to the power of his system, it is possible to formalize large areas of mathematics.
Reference: [8] <author> M.J.C. Gordon and T.F. Melham. </author> <title> Introduction to HOL. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: In 3 label type x 0 f 0 x 2 f 2 (x 0 )(x 1 ) . . . Coq [18], a similar construction with a syntactic constraint can be used to define inductive types for the decidable type theory. Similarly, HOL <ref> [8] </ref> contains a mechanism for introducing primitive recursive types. The inductive types are useful for a variety of purposes. They are used to define inductively defined predicates, relations, and also to define abstract data types for some degree of modularity.
Reference: [9] <editor> Carl A. Gunter and John C. Mitchell, editors. </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Breu [6] applies the techiques of algebraic specification to objects and their signatures. Dybjer has produced results on dependent inductive types with a set theoretic semantics. There is a wealth of information on formal object systems in Gunter and Mitchell <ref> [9] </ref>. Remy, Wand, and Ohori and Buneman develop type inference in object systems. Cardelli, Mitchell, and Remy develop record calculi. Kamin and Reddy give semantics models of inheritance in record calculi, and Cook, Hill and and Canning decouple inheritance and subtyping, as in a language like Eiffel [16].
Reference: [10] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In 21st Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: Amadio and Cardelli [3] discuss subtyping in the presence of recursion. In general, recursive subtyping produces a type larger than simple "record extension." Harper and Pierce [11] present a record calculus, and they apply some of their work to an ML-style module system <ref> [10] </ref>. Wand [20, 21] consider type-inference in the setting of record extension and multiple inheritance, a property that we do not discuss in this paper, but is a useful practical tool. Breu [6] applies the techiques of algebraic specification to objects and their signatures.
Reference: [11] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 131-142. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year> <month> 22 </month>
Reference-contexts: Much of the basic theory of object-oriented programming is based on record calculi, and the semantics of subtyping and record extension. Amadio and Cardelli [3] discuss subtyping in the presence of recursion. In general, recursive subtyping produces a type larger than simple "record extension." Harper and Pierce <ref> [11] </ref> present a record calculus, and they apply some of their work to an ML-style module system [10]. Wand [20, 21] consider type-inference in the setting of record extension and multiple inheritance, a property that we do not discuss in this paper, but is a useful practical tool.
Reference: [12] <author> Paul Bernard JAckson. </author> <title> Enhancing the NuPRL Proof Development System and Applying it to Computational Abstract Algebra. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: In our account, we reduce this meta-type-theory to two components: the generalized sequent and modus-ponens. Pitts [19] presents a view of theories as categories. In many ways, the categorical view is similar to an object approach, where signatures are viewed as categories. Jackson <ref> [12] </ref> has provided a rich formal environment in the NuPRL system [7] and applied it to constructive abstract algebra. Jsckson's work provides the grounds for this proposal|due to the power of his system, it is possible to formalize large areas of mathematics.
Reference: [13] <author> Paul Francis Mandler. </author> <title> Inductive Definition in Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> September </month> <year> 1987. </year> <pages> 87-870. </pages>
Reference: [14] <author> Per Martin-Lof. </author> <title> An intuitionistic theory of types: Predicative part. </title> <booktitle> In Logic Colloquium '73, </booktitle> <pages> pages 73-118. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year>
Reference: [15] <author> Per Martin-Lof. </author> <title> Intutionistic Type Theory. </title> <type> Bibliopolis, </type> <institution> Napoli, </institution> <year> 1984. </year>
Reference: [16] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Remy, Wand, and Ohori and Buneman develop type inference in object systems. Cardelli, Mitchell, and Remy develop record calculi. Kamin and Reddy give semantics models of inheritance in record calculi, and Cook, Hill and and Canning decouple inheritance and subtyping, as in a language like Eiffel <ref> [16] </ref>. There is relatively less work on an interpretation of theories. Basic and Constable [5] discuss logical frameworks. They present a meta-logic that is similar our presentation of theories in 4.
Reference: [17] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: In later sections of this paper, we will deal with 11 domains where method override does not make sense, and we will not include it as a feature of the object system. To handle method interdependence, we include a self-application within a method invocation. In the literature <ref> [2, 17] </ref>, and in many implementations, objects are treated as records, and method invocation is then a composition of field selection and self-application. <p> In their work, they define a type Self that stands for the signature of the object being defined, and in order to type an object they must assume that the type is well-defined. Mitchell, Honsell, and Fisher <ref> [17] </ref> develop an object calculus based on the untyped lambda calculus, and develop a static type checking system to later develop equational reasoning about method bodies. Their type system allows methods to be specialized as they are inherited, by polymorphism over subtypes.
Reference: [18] <author> Christine Paulin-Mohring. </author> <title> Inductive Definitions in the systen Coq. </title>
Reference-contexts: For this type to be meaningful according to its semantics, the term T must be a type that is monotonic in X for any type X. In 3 label type x 0 f 0 x 2 f 2 (x 0 )(x 1 ) . . . Coq <ref> [18] </ref>, a similar construction with a syntactic constraint can be used to define inductive types for the decidable type theory. Similarly, HOL [8] contains a mechanism for introducing primitive recursive types. The inductive types are useful for a variety of purposes.
Reference: [19] <author> Andrew Pitts. </author> <title> Categorical Logic, volume VI. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year> <month> (forthcoming). </month>
Reference-contexts: In their framework, the language of the logic and its proofs are formal objects belonging to abstract data types in some meta-type-theory. In our account, we reduce this meta-type-theory to two components: the generalized sequent and modus-ponens. Pitts <ref> [19] </ref> presents a view of theories as categories. In many ways, the categorical view is similar to an object approach, where signatures are viewed as categories. Jackson [12] has provided a rich formal environment in the NuPRL system [7] and applied it to constructive abstract algebra.
Reference: [20] <author> Mitchell Wand. </author> <title> Complete Type Inference for Simple Objects. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 37-44. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Amadio and Cardelli [3] discuss subtyping in the presence of recursion. In general, recursive subtyping produces a type larger than simple "record extension." Harper and Pierce [11] present a record calculus, and they apply some of their work to an ML-style module system [10]. Wand <ref> [20, 21] </ref> consider type-inference in the setting of record extension and multiple inheritance, a property that we do not discuss in this paper, but is a useful practical tool. Breu [6] applies the techiques of algebraic specification to objects and their signatures.
Reference: [21] <author> Mitchell Wand. </author> <title> Type Innference for Record Concatenation and Multiple Inheritance. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 92-97. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Amadio and Cardelli [3] discuss subtyping in the presence of recursion. In general, recursive subtyping produces a type larger than simple "record extension." Harper and Pierce [11] present a record calculus, and they apply some of their work to an ML-style module system [10]. Wand <ref> [20, 21] </ref> consider type-inference in the setting of record extension and multiple inheritance, a property that we do not discuss in this paper, but is a useful practical tool. Breu [6] applies the techiques of algebraic specification to objects and their signatures.
References-found: 21

