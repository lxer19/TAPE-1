URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR355.ps.Z
Refering-URL: http://www.cs.indiana.edu/proglang/proglang.html
Root-URL: 
Email: bruggema@cs.indiana.edu  
Title: Syntactic Abstraction in Scheme  
Author: Robert Hieb R. Kent Dybvig, and Carl Bruggeman 
Date: 1992 (Revised July 3, 1992)  
Note: June  
Address: or  
Affiliation: dyb  
Abstract: Indiana University Computer Science Department Technical Report #355 Abstract Naive program transformations can have surprising effects due to the interaction between introduced identifier references and previously existing identifier bindings, or between introduced bindings and previously existing references. These interactions can result in the inadvertent binding, or capturing, of identifiers. A further complication results from the fact that the transformed program may have little resemblance to the original program, making correlation of source and object code difficult. We address both the capturing problem and the problem of source-object code correlation. Previous approaches to the capturing problem have been both inadequate and overly restrictive, and the problem of source-object code correlation has been largely unaddressed. Our approach is based on a new algorithm for implementing syntactic transformations along with a new representation for syntactic expressions. It allows the programmer to define program transformations using an unrestricted, general-purpose language, while at the same time it helps the programmer avoid capturing problems and maintains a correlation between the original code and the transformed code.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> Elsevier Science Publishers, </publisher> <address> revised edition, </address> <year> 1984. </year>
Reference-contexts: Alpha equivalence is the basis for Barendregt's variable convention, which assumes that the bound variables in terms used in definitions and proofs are always chosen to be different from the free variables <ref> [1, page 26] </ref>.
Reference: [2] <author> Alan Bawden and Jonathan Rees. </author> <title> Syntactic closures. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 86-95, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Since some macros cannot be expressed easily using this language, they have developed a low-level interface that requires new identifiers to be marked explicitly [3]. Bawden and Rees <ref> [2] </ref> approach the capturing problem from a different angle. Rather than providing automatic hygiene, their system forces the programmer to make explicit decisions about the resolution of free identifier references and the scope of identifier bindings. <p> However, since constants can also be annotated, they too must be "exposed" before they can be examined. Source annotations can be implemented by adding another field to the wrapped expression structure of Section 4.4. 5 Conclusions Our system, syntactic closures as augmented by Hanson <ref> [2, 12] </ref>, and the Clinger and Rees "explicit renaming" system [4, 3] are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme [5]. Thus, the three systems differ primarily in the treatment of "low-level" macros.
Reference: [3] <author> William Clinger. </author> <title> Hygienic macros through explicit renaming. LISP Pointers, </title> <type> 4(4), </type> <year> 1991. </year>
Reference-contexts: Since some macros cannot be expressed easily using this language, they have developed a low-level interface that requires new identifiers to be marked explicitly <ref> [3] </ref>. Bawden and Rees [2] approach the capturing problem from a different angle. Rather than providing automatic hygiene, their system forces the programmer to make explicit decisions about the resolution of free identifier references and the scope of identifier bindings. <p> Source annotations can be implemented by adding another field to the wrapped expression structure of Section 4.4. 5 Conclusions Our system, syntactic closures as augmented by Hanson [2, 12], and the Clinger and Rees "explicit renaming" system <ref> [4, 3] </ref> are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme [5]. Thus, the three systems differ primarily in the treatment of "low-level" macros.
Reference: [4] <author> William Clinger and Jonathan Rees. </author> <title> Macros that work. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 155-162, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This paper presents a macro system for Scheme that preserves hygiene automatically while adding only constant overhead to the macro expansion process and solving the source-object correlation problem. This system also maintains "referential transparency" as defined for local macros by Clinger and Rees <ref> [4] </ref> (see Section 2). Also presented is a mechanism that supports a controlled form of variable capture that allows most common "capturing" macros to be written without violating the spirit of hygiene. <p> This is a serious problem for large programs that make heavy use of macros, e.g., nearly all large Scheme programs. Clinger and Rees <ref> [4] </ref> present an algorithm for hygienic macro transformations that does not have the quadratic time complexity of the original KFFD algorithm. They mark only the new identifiers introduced at each iteration of the macro transformation process, as opposed to all of the identifiers as in the original algorithm. <p> The Revised 4 Report on Scheme [5] includes an appendix that contains a proposed macro system for Scheme. The "high-level" (syntax-rules) system described therein is a version of Kohlbecker's extend-syntax [14] with the same restrictions imposed by Clinger and Rees <ref> [4] </ref>. The revised-report appendix also describes a "low-level" system that, although it automatically preserves hygiene and referential transparency, requires manual destructuring of the input and restructuring of the output. <p> Source annotations can be implemented by adding another field to the wrapped expression structure of Section 4.4. 5 Conclusions Our system, syntactic closures as augmented by Hanson [2, 12], and the Clinger and Rees "explicit renaming" system <ref> [4, 3] </ref> are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme [5]. Thus, the three systems differ primarily in the treatment of "low-level" macros.
Reference: [5] <editor> William Clinger, Jonathan A. Rees, et al. </editor> <title> The revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <type> 4(3), </type> <year> 1991. </year>
Reference-contexts: However, their mechanism handles only structured expressions; in particular, it does not handle variable references. The Revised 4 Report on Scheme <ref> [5] </ref> includes an appendix that contains a proposed macro system for Scheme. The "high-level" (syntax-rules) system described therein is a version of Kohlbecker's extend-syntax [14] with the same restrictions imposed by Clinger and Rees [4]. <p> by adding another field to the wrapped expression structure of Section 4.4. 5 Conclusions Our system, syntactic closures as augmented by Hanson [2, 12], and the Clinger and Rees "explicit renaming" system [4, 3] are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme <ref> [5] </ref>. Thus, the three systems differ primarily in the treatment of "low-level" macros. Our system extends automatic hygiene and referential transparency to the low level, whereas the other systems require explicit renaming of identifiers or construction of syntactic closures, which can be tedious and error-prone.
Reference: [6] <author> D. Coutant, S. Meloy, and M. Ruscetta. </author> <title> Doc: A practical approach to source-level debugging of globally optimized code. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 125-134, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: In order for the compiler, run-time system, and debugger to communicate with the programmer in terms of the original program, it is necessary to be able to reliably correlate source code and macro-expanded code. This source-object correlation problem has been addressed by optimizing compiler writers <ref> [13, 6, 18] </ref>. However, if the macro fl Robert Hieb died in an automobile accident on April 30, 1992 1 expansion process loses the correlation between source and macro-expanded code, the efforts of the compiler writer in this regard may be wasted.
Reference: [7] <author> R. Kent Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: This algorithm is extended to support pattern variables, controlled variable capture, and source-object correlation. Our system is applicable to macros written in a general purpose programming language (Scheme), and it extends to macros written in high-level pattern languages such as extend-syntax <ref> [14, 7] </ref>. Other systems have been proposed to solve some of these problems; many of these are described in the following section.
Reference: [8] <author> R. Kent Dybvig. </author> <title> Writing hygienic macros in scheme with syntax-case. </title> <type> Technical Report 356, </type> <institution> Indiana Computer Science Department, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: A detailed description of the features available in the system described in this paper and an extensive set of annotated examples can be found in <ref> [8] </ref>. 3 The language New syntactic forms are defined by associating keywords with transformation procedures, or transformers. At top level, syntactic definitions take the form of: (define-syntax keyword transformer-expression ) The transformer-expression must be an expression that evaluates to a transformer. <p> ) : : : ) e1 e2 : : : ) (syntax (syntax-case (list e0 : : : ) () ((p : : : ) (begin e1 e2 : : : )))))))) A more detailed description of the macro language and many examples of its use can be found in <ref> [8] </ref>. 4 The algorithm 4.1 Traditional macro systems Traditional Lisp macro systems rely on the fact that programs and data have the same representation, both textually and as internal structures.
Reference: [9] <author> R. Kent Dybvig, Daniel P. Friedman, and Christopher T. Haynes. </author> <title> Expansion-passing style: Beyond conventional macros. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 143-150, </pages> <year> 1986. </year>
Reference-contexts: He supports high-level definitions of derived notations in such a way that the definitions have certain formal properties that make them easy to reason about. As a result, however, his system is very restrictive with respect to the sort of macros that can be defined. Dybvig, Friedman and Haynes <ref> [9, 10] </ref> address the source-object correlation problem, demonstrating that their proposed macro expansion protocol, expansion-passing style, is capable of maintaining source-object correlation even in the presence of arbitrary user-defined macros. However, their mechanism handles only structured expressions; in particular, it does not handle variable references.
Reference: [10] <author> R. Kent Dybvig, Daniel P. Friedman, and Christopher T. Haynes. </author> <title> Expansion-passing style: A general macro mechanism. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1) </volume> <pages> 53-75, </pages> <year> 1988. </year>
Reference-contexts: He supports high-level definitions of derived notations in such a way that the definitions have certain formal properties that make them easy to reason about. As a result, however, his system is very restrictive with respect to the sort of macros that can be defined. Dybvig, Friedman and Haynes <ref> [9, 10] </ref> address the source-object correlation problem, demonstrating that their proposed macro expansion protocol, expansion-passing style, is capable of maintaining source-object correlation even in the presence of arbitrary user-defined macros. However, their mechanism handles only structured expressions; in particular, it does not handle variable references.
Reference: [11] <author> Timothy G. Griffin. </author> <title> Definition and Top-Down Refinement for Interactive Proof Development Systems. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: This extends the notion of hygiene to local macro definitions, which were not handled by KFFD algorithm. Like automatic hygiene, however, this transparency is not present in the low-level system. 3 Griffin <ref> [11] </ref> describes a theory of syntactic definitions in the context of interactive proof de-velopment systems. He supports high-level definitions of derived notations in such a way that the definitions have certain formal properties that make them easy to reason about.
Reference: [12] <author> Chris Hanson. </author> <title> A syntactic closures macro facility. LISP Pointers, </title> <type> 4(4), </type> <year> 1991. </year>
Reference-contexts: Unlike traditional closures, however, syntactic closures and their environments must be constructed explicitly. As a result, the mechanism is difficult to use and definitions created using it are difficult to understand and verify. To alleviate this, Hanson <ref> [12] </ref> has recently demonstrated that the restricted high-level specification language supported by Clinger and Rees can be built on top of a modified version of syntactic closures. <p> However, since constants can also be annotated, they too must be "exposed" before they can be examined. Source annotations can be implemented by adding another field to the wrapped expression structure of Section 4.4. 5 Conclusions Our system, syntactic closures as augmented by Hanson <ref> [2, 12] </ref>, and the Clinger and Rees "explicit renaming" system [4, 3] are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme [5]. Thus, the three systems differ primarily in the treatment of "low-level" macros.
Reference: [13] <author> J. Hennessy. </author> <title> Symbolic debugging of optimized code. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 323-344, </pages> <month> July </month> <year> 1982. </year> <month> 17 </month>
Reference-contexts: In order for the compiler, run-time system, and debugger to communicate with the programmer in terms of the original program, it is necessary to be able to reliably correlate source code and macro-expanded code. This source-object correlation problem has been addressed by optimizing compiler writers <ref> [13, 6, 18] </ref>. However, if the macro fl Robert Hieb died in an automobile accident on April 30, 1992 1 expansion process loses the correlation between source and macro-expanded code, the efforts of the compiler writer in this regard may be wasted.
Reference: [14] <author> Eugene Kohlbecker. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> PhD thesis, </type> <institution> Indiana University, Bloomington, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: This algorithm is extended to support pattern variables, controlled variable capture, and source-object correlation. Our system is applicable to macros written in a general purpose programming language (Scheme), and it extends to macros written in high-level pattern languages such as extend-syntax <ref> [14, 7] </ref>. Other systems have been proposed to solve some of these problems; many of these are described in the following section. <p> However, their mechanism handles only structured expressions; in particular, it does not handle variable references. The Revised 4 Report on Scheme [5] includes an appendix that contains a proposed macro system for Scheme. The "high-level" (syntax-rules) system described therein is a version of Kohlbecker's extend-syntax <ref> [14] </ref> with the same restrictions imposed by Clinger and Rees [4]. The revised-report appendix also describes a "low-level" system that, although it automatically preserves hygiene and referential transparency, requires manual destructuring of the input and restructuring of the output.
Reference: [15] <author> Eugene Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and Bruce Duba. </author> <title> Hygienic macro expansion. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-161, </pages> <year> 1986. </year>
Reference-contexts: When one expression is substituted for another, apparent bindings can be shadowed, resulting in unintended capture of variable references. This is the source of many serious and difficult to find bugs. This problem was first addressed by Kohlbecker, Friedman, Felleisen, and Duba <ref> [15] </ref>, who proposed a hygiene condition for macros and a macro-expansion algorithm that enforces this condition. Unfortunately, the KFFD algorithm increases the computational complexity of the macro expansion process. An additional problem of equal practical importance is that Lisp macro systems cannot track source code through the macro-expansion process. <p> These problems were first addressed by Kohlbecker, Friedman, Felleisen, and Duba <ref> [15] </ref>, who develop an algorithm in which the macro system automatically renames bound variables to prevent 2 inadvertent capturing. The fundamental notion underlying the KFFD algorithm is alpha equiva-lence, which equates terms that differ only in the names of bound variables. <p> However, strict automatic hygiene prevents introduced bindings from capturing existing variable references. Previous hygienic systems have provided mechanisms for explicit capturing, typically by allowing a macro to insert a symbol into an expansion as if it were part of the original source program <ref> [15] </ref>. Unfortunately, this means that macros cannot reliably expand into macros that use explicit capturing. Our system provides a more consistent way to accommodate such macros. A macro may construct an implicit identifier that behaves as if it were present in the macro call.
Reference: [16] <author> Guy L. Steele Jr. </author> <title> Common Lisp, the Language. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: ) (let f () e1 : : : (f )))))))))) (The with-syntax form introduces pattern variable bindings within the scope of its body; its definition is shown later.) This same mechanism may be used to create aggregate identifier names typically required when defining structure-definition constructs such as Common Lisp defstruct <ref> [16] </ref>, as macros.
Reference: [17] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: Furthermore, the convenient pattern matching facilities provided by the specification language must be completely abandoned for the same class of macros. Both algorithms also support local macro definitions that are "referentially transparent" <ref> [17] </ref> in the sense that a macro-introduced identifier refers to the binding present at the point of definition of the macro rather than the point of use of the macro. This extends the notion of hygiene to local macro definitions, which were not handled by KFFD algorithm.
Reference: [18] <author> P. Zellweger. </author> <title> An interactive high-level debugger for control-flow optimized programs. </title> <booktitle> In Proceedings of the ACM Software Engineering Symposium on High-Level Debugging, </booktitle> <pages> pages 159-171, </pages> <month> August </month> <year> 1983. </year> <month> 18 </month>
Reference-contexts: In order for the compiler, run-time system, and debugger to communicate with the programmer in terms of the original program, it is necessary to be able to reliably correlate source code and macro-expanded code. This source-object correlation problem has been addressed by optimizing compiler writers <ref> [13, 6, 18] </ref>. However, if the macro fl Robert Hieb died in an automobile accident on April 30, 1992 1 expansion process loses the correlation between source and macro-expanded code, the efforts of the compiler writer in this regard may be wasted.
References-found: 18

