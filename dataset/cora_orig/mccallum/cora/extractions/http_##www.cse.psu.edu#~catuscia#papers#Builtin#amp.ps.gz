URL: http://www.cse.psu.edu/~catuscia/papers/Builtin/amp.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Title: A Theory of First-Order Built-in's of Prolog  
Author: Krzysztof R. Apt Elena Marchiori Catuscia Palamidessi 
Keyword: and Phrases: Prolog programs, built-in's, declarative semantics, termination.  
Web: F.3.2., F.4.1, H.3.3, I.2.3.  
Note: 1985 Mathematics Subject Classification: 68Q40, 68T15, CR Categories:  
Abstract: We provide here a framework for studying Prolog programs with various built-in's that include arithmetic operations, and such metalogical relations like var and ground. To this end we propose a new, declarative semantics and prove completeness of the Prolog computation mechanism w.r.t. this semantics. We also show that this semantics is fully abstract in an appropriate sense. Finally, we provide a method for proving termination of Prolog programs with built-in's which uses this semantics. The method is shown to be modular and is illustrated by proving termination of a number of programs including the unify program of Sterling and Shapiro [SS86]. Note: This research was done during the second and third authors' stay at Centre for Mathematics and Computer Science, Amsterdam. The work of K.R. Apt was partly supported by ESPRIT Basic Research Action 3020 (Integration). The work of C. Palamidessi was partly supported by ESPRIT Basic Research Action 3020 and by the Italian CNR (Con-siglio Nazionale delle Ricerche). The work of E. Marchiori was partly supported by ..... 
Abstract-found: 1
Intro-found: 1
Reference: [AP91] <author> J.-M. Andreoli and R. Pareschi. </author> <title> Linear Objects: Logical processes with built-in inheritance. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 445-473, </pages> <year> 1991. </year> <booktitle> Also in the Proc. of the Seventh International Conference on Logic programming, 1990, </booktitle> <address> Jerusalem. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Level mapping was originally defined to be a function from ground atoms to natural numbers (see Bezem [?], Cavedon [?], Apt and Pedreschi <ref> [AP91] </ref>). The reason why restriction to ground atoms was sufficient can be best explained by the following observation. Let ground (P ) denotes the set of all ground instances of clauses of the program P and ground (C) denotes the set of all ground instances of the clause C. <p> Then by construction d 0 2 D d and its length is greater than k. 2 Thus to reason about termination of pure Prolog programs it is sufficient to study its ground version introducing the concept of boundness. This was done in Apt and Pedreschi <ref> [AP91] </ref> by combining the use of level mappings and models of the program. The following simple example shows that Lemma 3.2 cannot be extended to Prolog programs with built-in's. Example 3.8 Let P = fp (a) nonvar (x); p (a):g. <p> In Pieramico [?] it was proved that UNIFY terminates for ground goals by showing that the program obtained by deleting all built-in relations is acceptable (in the sense of Apt and Pedreschi <ref> [AP91] </ref>). We prove here a stronger statement, namely that UNIFY is strongly terminating by showing that it is acceptable in the sense of Definition 3.12. For the subsequent analysis it is important to understand how this program operates.
Reference: [Apt90] <author> K. R. Apt. </author> <title> Logic programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 493-574. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> Vol. </title> <publisher> B. </publisher>
Reference-contexts: Proof. (i) By a simple generalization of the Variant Lemma 2.8 of Apt <ref> [Apt90] </ref> to the class of Prolog programs, an isomorphism between the LD-trees of P [ fGg and P [ fHg can be established. (ii), (iii) Immediate by the definition. 2 We are now in position to prove the desired result.
Reference: [Bor89] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog, Part III: Built-in predicates for files, terms, arithmetic and input-output. </title> <editor> In Y.Moschovakis, editor, </editor> <booktitle> Proceedings Workshop on Logic from Computer Science. </booktitle> <publisher> Springer MSRI Publications, </publisher> <year> 1989. </year>
Reference: [Cla79] <author> K.L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: introduction of non-ground atoms in the Herbrand interpretations, in order to define the truth value of an atom independently from its ground instances. The first declarative semantics based on non-ground atoms was given by Clark <ref> [Cla79] </ref>, with the aim of defining the validity of open atoms (like p (x)) in terms of their truth value in the least Herbrand model.
Reference: [FD87] <author> G. Ferrand and P. Deransart. </author> <title> An operational formal definition of Prolog. </title> <booktitle> In Proceedings of the 4th Symposium on Logic Programming, </booktitle> <pages> pages 162-172. </pages> <publisher> Computer Society Press, </publisher> <year> 1987. </year>
Reference: [FLMP89] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative modeling of the operational behaviour of logic languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: Successively, other declarative models based on non-ground atoms were investigated in Falaschi et al. <ref> [FLMP89] </ref>: the C-semantics which was shown to be equivalent to Clark's semantics, and the S-semantics. <p> 2 This Corollary shows that the fi-model N P captures precisely the computational meaning of the program P . 2.4 Relation between the fi-semantics and the S-semantics In this section we show that the fi-semantics is a natural extension to Prolog programs of the S-semantics defined in Falaschi et al. <ref> [FLMP89] </ref> for logic programs, in the sense that if P is a pure Prolog program (i.e. it does not contain built-in atoms) then the least fi-model N P is isomorphic with the least S-model S P . <p> To this purpose, it will be helpful to consider the following operational characterization of S P (cf. Falaschi et al. <ref> [FLMP89] </ref>). 15 S P = fp (x)j j p 2 Rel; x 2 Var ; and p (x) has an LD-refutation with c.a.s. jg or, equivalently, S P = fhp (x); ji j p 2 Rel; x 2 Var; and p (x) has an LD-refutation with c.a.s. jg (7) We define <p> Proof. This lemma can be proved by using the correctness and completeness theorems for the S-semantics (cf. Falaschi et al. <ref> [FLMP89] </ref>), but we prefer to give here an independent, purely operational proof. We prove (i) by induction on the length of the refutation. n = 1) Immediate since in this case Q = true and j = *. n &gt; 1) Consider an LD-refutation for Q with c.a.s. j.
Reference: [FLMP91] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A model-theoretic reconstruction of the operational semantics of logic programs. </title> <journal> Information and Computation, </journal> <note> 1991. To appear. Also available as technical report TR 32/89 at the Department of Computer Science, Pisa. </note>
Reference-contexts: On the other hand, the S-semantics is not necessarily monotonic: the S-interpretations are not upward closed. In fact, the S-interpretations are isomorphic to arbitrary sets of pairs the form hp (x); ji, where j represents, roughly, a c.a.s. for the goal p (x); see Falaschi et al. <ref> [FLMP91] </ref>. However, the S-semantics is not suitable for describing the meaning of Prolog programs, either. In fact, in presence of built-in relations like nonvar, another problem arises: the goal nonvar (x) fails whereas for every non-variable term t the goal nonvar (t) succeeds. <p> Falaschi et al. <ref> [FLMP91] </ref>)). This notion can be viewed as the most interesting one, since (as we already argued in the introduction) the notion of ground success set doesn't make much sense in case of programs containing built-in relations.
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: The behavior of the goal p (x) in these programs is different (in P 1 it succeeds, whereas in P 2 it fails). In other words, the independence from the selection rule, and the Switching Lemma of Lloyd <ref> [Llo87] </ref> do not hold for Prolog programs. If we want to characterize declaratively the operational behaviour of goals, we must therefore describe the meaning of `,' in the body of clauses in a non-commutative way, more precisely, we have to mimic the leftmost selection rule of Prolog. <p> In fact, in presence of built-in relations like nonvar, another problem arises: the goal nonvar (x) fails whereas for every non-variable term t the goal nonvar (t) succeeds. Therefore we say that nonvar is a non-down-monotonic relation. Due to the presence of non-down-monotonic relations the Lifting Lemma (see Lloyd <ref> [Llo87] </ref>) does not hold for Prolog programs. Consider for instance P 3 : p (X) nonvar (X). With this program for every non-variable term t the goal p (t) has a refutation, whereas p (x) fails.
Reference: [Pal90] <author> C. Palamidessi. </author> <title> Algebraic properties of idempotent substitutions. In M.S. </title> <editor> Pater-son, editor, </editor> <booktitle> Proc. of the 17th International Colloquium on Automata, Languages and Programming (ICALP), volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 386-399, </pages> <address> Warwick, England, </address> <year> 1990. </year> <note> Springer-Verlag. Full version available as Technical Report TR-33/89, </note> <institution> Dipartimento di Informatica, Universita di Pisa. </institution>
Reference-contexts: Then, by Palamidessi <ref> [Pal90] </ref>, we obtain n = mgu (p (t 1 ; : : : ; t n ); p (u 1 ; : : :; u n )): Again by induction, we show now that I j= ht 1 = u 1 ; : : : ; t n = u n <p> Furthermore, from <ref> [Pal90] </ref> we know that 8i 2 [1; k]: 0 : : : i = mgu (x 1 = u 1 ; : : : ; x i = u i ; u 1 = t 1 ; : : : ; u i = t i ): Therefore we derive 0
Reference: [SS86] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog: </title> <booktitle> Advanced Programming Techniques. Series in Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference: [vEK76] <author> M.H. van Emden and R.A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year> <month> 44 </month>
Reference-contexts: However, all these models are not suitable for Prolog programs, because | like the standard semantics of van Emden and Kowalski <ref> [vEK76] </ref>, the resulting definition of truth treats the body of a clause as a logical conjunction - i.e. the `,' is intrepreted as an `and', and this means that the order of the literals in the body is irrelevant.
References-found: 11

