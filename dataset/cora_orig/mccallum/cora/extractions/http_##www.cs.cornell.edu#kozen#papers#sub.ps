URL: http://www.cs.cornell.edu/kozen/papers/sub.ps
Refering-URL: http://www.cs.cornell.edu/kozen/papers/papers.html
Root-URL: 
Email: kozen@cs.cornell.edu  palsberg@daimi.aau.dk  mis@daimi.aau.dk  
Title: Efficient Recursive Subtyping  
Author: Dexter Kozen Jens Palsberg Michael I. Schwartzbach 
Abstract: Subtyping in the presence of recursive types for the -calculus was studied by Amadio and Cardelli in 1991 [1]. In that paper they showed that the problem of deciding whether one recursive type is a subtype of another is decidable in exponential time. In this paper we give an O(n 2 ) algorithm. Our algorithm is based on a simplification of the definition of the subtype relation, which allows us to reduce the problem to the emptiness problem for a certain finite automaton with quadratically many states. It is known that equality of recursive types and the covariant Bohm order can be decided efficiently by means of finite automata, since they are just language equality and language inclusion, respectively. Our results extend the automata-theoretic approach to handle orderings based on contravariance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Proc. 18th Symp. Princip. Programming Lang., </booktitle> <pages> pages 104-118. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: Since it does not depend on programmer-defined names, it allows the flexible typing of such constructs as data persistence and data migration. The combination of recursive types and subtyping at an abstract level was studied by Amadio and Cardelli in 1991 <ref> [1] </ref>. <p> The size of the product automaton is the product of the sizes of the two term automata. Thus, our algorithm runs in O (n 2 ) time. It may be surprising that the inclusion of recursive types can be decided efficiently using finite automata. To quote Amadio and Cardelli <ref> [1] </ref>: The problem of equating recursive types : : : can be related to well-known solvable problems, such as the equivalence of finite-state automata. However, the similar problem for subtyping has no well-known parallel. <p> In order to handle recursive types, we need to extend the ordering FIN to infinite types in a natural way. Much of the effort in Amadio and Cardelli's paper <ref> [1] </ref> is devoted to this task. Their definition, which involves infinite sequences of finite approximations, is given later (Definition 15). Here we give a simplified definition that does not involve approximations (Definition 11). We will eventually show (Theorem 16) that the two definitions are equivalent. <p> For example, let AC (ff) = ? ; if ff even; &gt; ; if ff odd. The truncation operator j AC k is the one employed by Amadio and Cardelli <ref> [1] </ref>. It has the nice property that tj AC k FIN tj AC k+1 , although this property turns out not to be essential. The following lemma shows that the particular function g chosen in the definition of the truncation operator is irrelevant for our purposes. <p> Assume s and t are given by term automata M and N respectively over the ranked alphabet = f?; !; &gt;g. If s and t are given by other means, say by simultaneous equations as in <ref> [1] </ref>, then results of [5] can be used to obtain the automata in linear time as described in Lemma 8 of Section 3. Recall from Definition 11 that s t iff s (ff) ff t (ff) for all ff 2 D (s) " D (t).
Reference: [2] <author> Luca Cardelli. </author> <title> Amber. </title> <booktitle> In Combinators and Functional Programming Languages, Proc. 13th Summer School School of the LITP, volume 242 of Lect. Notes in Comput. </booktitle> <publisher> Sci. Springer-Verlag, </publisher> <month> May </month> <year> 1985. </year>
Reference-contexts: The unrestricted combination of recursion and subtyping, found for example in Amber <ref> [2] </ref> and Quest [4, 3], is of substantial pragmatic value. Since it does not depend on programmer-defined names, it allows the flexible typing of such constructs as data persistence and data migration.
Reference: [3] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <booktitle> In Lect. Notes for the IFIP Advanced Seminar on Formal Methods in Programming Language Semantics, </booktitle> <year> 1989. </year>
Reference-contexts: The unrestricted combination of recursion and subtyping, found for example in Amber [2] and Quest <ref> [4, 3] </ref>, is of substantial pragmatic value. Since it does not depend on programmer-defined names, it allows the flexible typing of such constructs as data persistence and data migration. The combination of recursive types and subtyping at an abstract level was studied by Amadio and Cardelli in 1991 [1].
Reference: [4] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17:4:471-522, </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: The unrestricted combination of recursion and subtyping, found for example in Amber [2] and Quest <ref> [4, 3] </ref>, is of substantial pragmatic value. Since it does not depend on programmer-defined names, it allows the flexible typing of such constructs as data persistence and data migration. The combination of recursive types and subtyping at an abstract level was studied by Amadio and Cardelli in 1991 [1].
Reference: [5] <author> Bruno Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theor. Comput. Sci., </journal> <volume> 25 </volume> <pages> 95-169, </pages> <year> 1983. </year> <month> 18 </month>
Reference-contexts: If b ffi (q 0 ; ff) does not exist, then t M # ff has empty domain. Thus t M has no more subterms than there are states of M. The equivalence of (i) and (iii) is proved in <ref> [5] </ref>. 2 4 Types Types are terms over the ranked alphabet = f?; !; &gt;g, where ! is binary and ?, &gt; are nullary. Over this signature, every D (t) f0; 1g fl . <p> Assume s and t are given by term automata M and N respectively over the ranked alphabet = f?; !; &gt;g. If s and t are given by other means, say by simultaneous equations as in [1], then results of <ref> [5] </ref> can be used to obtain the automata in linear time as described in Lemma 8 of Section 3. Recall from Definition 11 that s t iff s (ff) ff t (ff) for all ff 2 D (s) " D (t).
Reference: [6] <author> John E. Hopcroft and Jeffrey D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: We show that the set (1) is a regular subset of f0; 1g fl , and describe a conventional finite automaton A (in the sense of <ref> [6] </ref>) over the input alphabet f0; 1g that accepts exactly this set.
Reference: [7] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <booktitle> In Proc. 33rd Symp. Found. Comput. Sci., </booktitle> <pages> pages 363-371. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: Our algorithm is based on a simplification of Amadio and Cardelli's definition of the subtype relation on trees; we show that the two definitions 3 are equivalent. Our definition, which is a generalization of an order intro-duced by us in <ref> [7] </ref>, intuitively says: Two trees are ordered if no common path detects a counterex ample. This allows us to reduce the problem to the emptiness problem for a certain finite automaton which accepts a language of counterexamples. Our algorithm represents recursive types as so-called term automata. <p> However, the similar problem for subtyping has no well-known parallel. Our results establish that the automata-theoretic approach is fruitful even in the presence of subtyping and contravariance. Further evidence is provided by the results of <ref> [7] </ref>, which establish the first known polynomial time algorithm for a type inference problem studied by Thatte [10] and O'Keefe and Wand [9].
Reference: [8] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient recursive subtyping. </title> <booktitle> In Proc. 20th Symp. Princip. Programming Lang., </booktitle> <pages> pages 419-428. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: Army Research Office through the ACSyAM branch of the Mathematical Sciences Institute of Cornell University under contract DAAL03-91-C-0027, and the Danish Research Council under the DART Project (5.21.08.03). An earlier version of this paper appeared as <ref> [8] </ref>.
Reference: [9] <author> Patrick M. O'Keefe and Mitchell Wand. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proc. ESOP'92, European Symposium on Programming, volume 582 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 408-417. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Our results establish that the automata-theoretic approach is fruitful even in the presence of subtyping and contravariance. Further evidence is provided by the results of [7], which establish the first known polynomial time algorithm for a type inference problem studied by Thatte [10] and O'Keefe and Wand <ref> [9] </ref>. In the remainder of the paper we provide the definitions of term automata and labeled trees, prove that Amadio and Cardelli's tree ordering and ours agree, and give the details of our algorithm.
Reference: [10] <author> Satish Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Proc. International Colloquium on Automata, Languages, and Programming 1988, volume 317 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 615-629. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <month> 19 </month>
Reference-contexts: Our results establish that the automata-theoretic approach is fruitful even in the presence of subtyping and contravariance. Further evidence is provided by the results of [7], which establish the first known polynomial time algorithm for a type inference problem studied by Thatte <ref> [10] </ref> and O'Keefe and Wand [9]. In the remainder of the paper we provide the definitions of term automata and labeled trees, prove that Amadio and Cardelli's tree ordering and ours agree, and give the details of our algorithm.
References-found: 10

