URL: http://www.cs.utexas.edu/users/boyer/rsa.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/boyer/publications.html
Root-URL: http://www.cs.utexas.edu
Title: PROOF CHECKING THE RSA PUBLIC KEY ENCRYPTION ALGORITHM 1 MR Classification Numbers: The development of
Author: Robert S. Boyer and J Strother Moore Godel [] 
Pubnum: 03-04, 03B35, 10A25, 68C20, 68G15  
Abstract: But formalized mathematics cannot in practice be written down in full, and therefore we must have confidence in what might be called the common sense of the mathematician ... We shall therefore very quickly abandon formalized mathematics ... -- Bourbaki [1] 
Abstract-found: 1
Intro-found: 1
Reference: <author> 62a. W. Hunt. FM8501: </author> <title> A Verified Microprocessor. </title> <publisher> LNCS 795. Springer-Verlag. </publisher> <year> 1994. </year> <note> 69a. </note> <author> N. Shankar. </author> <title> Metamathematics, Machines, and Goedel's Proof, </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference: 1. <author> N. Bourbaki. </author> <title> Elements of Mathematics. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1968. </year>
Reference-contexts: But from the Pigeon Hole Principle we have that S (p-1,M,p) is a permutation of <ref> [p-1, ... 2, 1] </ref>.) ------------------------------------------------------------------------- To prove Lemma 1 the system inducts on n and uses the previously proved lemma that intermediate mods can be dropped.
Reference: 2. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: A Sketch of the Theorem-Prover The theorem-prover we use is the current version of the system described in <ref> [2] </ref>. The theorem-prover deals with a quantifier free first order logic providing equality, recursively defined functions, mathematical induction, and inductively constructed objects such as the natural numbers and finite sequences. The theorem-prover is a large interactive computer program. <p> Our induction mechanism contains many heuristics for combining and choosing between the suggested inductions. That the inductions invented by the system are valid may be proved by considering the well-foundedness theorems proved when recursive functions are admitted. Readers interested in more details of the theorem-prover should see <ref> [2] </ref>, in which the system, as of May, 1978, is described at a level of detail sufficient to permit reproduction of our results. Several chapters of [2] are devoted to detailed annotated proofs by the system, including its proof of the uniqueness of prime factorizations. <p> Readers interested in more details of the theorem-prover should see <ref> [2] </ref>, in which the system, as of May, 1978, is described at a level of detail sufficient to permit reproduction of our results. Several chapters of [2] are devoted to detailed annotated proofs by the system, including its proof of the uniqueness of prime factorizations. Improvements made to the system since the publication of [2] include the addition of the above mentioned decision procedures for equalities and simple arithmetic inequalities, the extension of the definitional principle to <p> Several chapters of <ref> [2] </ref> are devoted to detailed annotated proofs by the system, including its proof of the uniqueness of prime factorizations. Improvements made to the system since the publication of [2] include the addition of the above mentioned decision procedures for equalities and simple arithmetic inequalities, the extension of the definitional principle to include reflexive functions as described in [16], and a metafunction facility permitting the incorporation of new simplifiers after they have been mechanically proved correct [3]. <p> When we began the encryption proofs we initialized the theorem-prover to the current version of the lemma library listed in Appendix A of <ref> [2] </ref>. The library contains several hundred previously proved theorems. Most of the theorems in this library were irrelevant to the encryption proofs (e.g., there are many theorems about list processing functions such as REVERSE, FLATTEN, and SORT). <p> theorem-prover are: Wilson's Theorem: if p is a prime then (p-1)! mod p = p-1; [18] the termination over the integers of the Takeuchi function [16]: tak (x,y,z) = if x_&lt;y then y else tak (tak (x-1,y,z), tak (y-1,z,x), the soundness and completeness of a decision procedure for propositional calculus <ref> [2] </ref>; the existence of nonprimitive recursive functions; 9 the Turing completeness of the Pure LISP programming language [8]; and the recursive unsolvability of the halting problem for Pure LISP [7]. We take these examples as evidence that proof checking mathematics is not only a theoretical but also a practical possibility.
Reference: 3. <author> R. S. Boyer and J S. Moore. Metafunctions: </author> <title> Proving Them Correct and Using Them Efficiently as New Proof Procedures. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: the publication of [2] include the addition of the above mentioned decision procedures for equalities and simple arithmetic inequalities, the extension of the definitional principle to include reflexive functions as described in [16], and a metafunction facility permitting the incorporation of new simplifiers after they have been mechanically proved correct <ref> [3] </ref>. Finally, we have added a primitive "hint" facility so that the user can tell the theorem-prover how to prove a theorem when its heuristics lead it down blind alleys. There are two types of hints used in this paper.
Reference: 4. <author> R. S. Boyer and J S. Moore. </author> <title> A Verification Condition Generator for FORTRAN. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: The less ambitious motivation behind much automatic theorem-proving research -- certainly ours -- is to mechanize the often mundane and tedious proofs arising in connection with computer programs. For example, our theorem-prover has been used to prove thousands of theorems related to the correctness of various programs <ref> [4, 5] </ref>, communications protocols [9], and computer security [10].
Reference: 5. <author> R. S. Boyer and J S. Moore. </author> <title> MJRTY - A Fast Majority Vote Algorithm. </title> <type> Technical Report ICSCA-CMP-32, </type> <institution> Institute for Computing Science and Computer Applications, University of Texas at Austin, </institution> <year> 1982. </year>
Reference-contexts: The less ambitious motivation behind much automatic theorem-proving research -- certainly ours -- is to mechanize the often mundane and tedious proofs arising in connection with computer programs. For example, our theorem-prover has been used to prove thousands of theorems related to the correctness of various programs <ref> [4, 5] </ref>, communications protocols [9], and computer security [10].
Reference: 6. <author> R. S. Boyer and J S. Moore. </author> <title> "Proof Checking the RSA Public Key Encryption Algorithm". </title> <journal> American Mathematical Monthly 91, </journal> <volume> 3 (1984), </volume> <pages> 181-189. </pages>
Reference-contexts: Theorem. CRYPT.CORRECT (rewrite): (IMPLIES (NOT (EQUAL N 1)) (EQUAL (CRYPT M E N) (REMAINDER (EXP M E) N))) Readers interested in the complete list of definitions and theorems typed by the user, should see section 8 of <ref> [6] </ref>. 7. Conclusion We have shown how an existing mechanical theorem-prover was used to check a recently published proof.
Reference: 7. <author> R. S. Boyer and J S. Moore. </author> <title> "A Mechanical Proof of the Unsolvability of the Halting Problem". </title> <journal> JACM 31, </journal> <volume> 3 (1984), </volume> <pages> 441-458. </pages>
Reference-contexts: if x_&lt;y then y else tak (tak (x-1,y,z), tak (y-1,z,x), the soundness and completeness of a decision procedure for propositional calculus [2]; the existence of nonprimitive recursive functions; 9 the Turing completeness of the Pure LISP programming language [8]; and the recursive unsolvability of the halting problem for Pure LISP <ref> [7] </ref>. We take these examples as evidence that proof checking mathematics is not only a theoretical but also a practical possibility. We doubt that the mechanical theorem-provers of today could be easily used to check theorems at the frontiers of mathematics.
Reference: 8. <author> R. S. Boyer and J S. Moore. </author> <title> A Mechanical Proof of the Turing Completeness of Pure Lisp. In Automated Theorem Proving: After 25 Years, W.W. </title> <editor> Bledsoe and D.W. Loveland, Eds., </editor> <publisher> American Mathematical Society, </publisher> <address> Providence, R.I., </address> <year> 1984, </year> <pages> pp. 133-167. </pages>
Reference-contexts: termination over the integers of the Takeuchi function [16]: tak (x,y,z) = if x_&lt;y then y else tak (tak (x-1,y,z), tak (y-1,z,x), the soundness and completeness of a decision procedure for propositional calculus [2]; the existence of nonprimitive recursive functions; 9 the Turing completeness of the Pure LISP programming language <ref> [8] </ref>; and the recursive unsolvability of the halting problem for Pure LISP [7]. We take these examples as evidence that proof checking mathematics is not only a theoretical but also a practical possibility.
Reference: 9. <author> Benedetto Lorenzo Di Vito. </author> <title> Verification of Communications Protocols and Abstract Process Models. </title> <type> Ph.D. </type> <institution> Th., University of Texas at Austin, </institution> <year> 1982. </year>
Reference-contexts: For example, our theorem-prover has been used to prove thousands of theorems related to the correctness of various programs [4, 5], communications protocols <ref> [9] </ref>, and computer security [10].
Reference: 10. <author> Richard J. Feiertag. </author> <title> A Technique for Proving Specifications are Multilevel Secure. </title> <type> Technical Report CSL-109, </type> <institution> SRI International, </institution> <year> 1981. </year>
Reference-contexts: For example, our theorem-prover has been used to prove thousands of theorems related to the correctness of various programs [4, 5], communications protocols [9], and computer security <ref> [10] </ref>. Because of the high cost of bugs in software, the increasing impact of software due to cheap microprocessors, and the relatively shallow nature of most program correctness proofs, we expect to see, within the decade, commercial use of mechanical theorem-provers and formal logic in software development.
Reference: 11. <author> K. </author> <title> Godel. On Formally Undecidable Propositions of Principia Mathematica and Related Systems. In From Frege to Godel, </title> <editor> J. van Heijenoort, Ed., </editor> <publisher> Harvard University Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1967. </year>
Reference: 12. <author> G. H. Hardy and E. M. Wright. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Oxford University Press, </publisher> <year> 1979. </year>
Reference-contexts: Theorems 53 and 55 We now prove versions of Theorems 53 and 55 from <ref> [12] </ref> and observe trivial corollaries of each. Event 15 is used in the proof of event 16, which is used in the proof of Theorem 53. 15. Theorem. PRODUCT.DIVIDES/LEMMA (rewrite): (IMPLIES (EQUAL (REMAINDER X Z) 0) (EQUAL (REMAINDER (TIMES Y X) (TIMES Y Z)) 0)) 16. Theorem.
Reference: 13. <author> D. E. Knuth and P. Bendix. </author> <title> Simple Word Problems in Universal Algebras. In Computational Problems in Abstract Algebras, </title> <editor> J. Leech, Ed., </editor> <publisher> Pergamon Press, Oxford, </publisher> <year> 1970, </year> <pages> pp. 263-297. </pages>
Reference-contexts: Then a mod p*q = b mod p*q. 3 Hence, under the additional hypothesis b&lt;p*q, a mod p*q = b. 2 This is the Knuth-Bendix problem in rewrite driven simplification. See <ref> [13] </ref> for an elegant solution to the problem in certain cases. 3 Cf. Theorem 53 of Hardy and Wright's An Introduction to the Theory of Numbers. 6 Suppose p is a prime and p does not divide M.
Reference: 14. <author> D. E. Knuth. </author> <title> The Art of Computer Programming. Volume 1/ Fundamental Algorithms. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: Hence, if L is a permutation of [n n-1 ... 2 1] then the product of the elements in L is n!. If p is a prime and n&lt;p, then p does not divide n!. We then had the theorem-prover check the proof of Fermat's theorem in <ref> [14] </ref>. Box 2 Definition. We define S (n,M,p) to be the sequence: [n*M mod p, (n-1)*M mod p, ..., 1*M mod p]. Lemma 1. The product of the elements in S (n,M,p) mod p is equal to n!*M n mod p. Lemma.
Reference: 15. <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming. Volume 2/ Seminumerical Algorithms. </booktitle> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1981. </year>
Reference-contexts: Before accepting the definition of CRYPT the theorem-prover guesses that e decreases in each recursive call and then proves it by showing that when e is a non-0 natural number, e/2 is strictly smaller than e. CRYPT uses the "binary method" of computing M e (see <ref> [15] </ref>), which is based on the observation: (M e/2 ) 2 , if e is even M e = However, by doing multiplications modulo n, CRYPT keeps the intermediate results manageably small and computes M e mod n.
Reference: 16. <author> J S. Moore. </author> <title> "A Mechanical Proof of the Termination of Takeuchi's Function". </title> <journal> Information Processing Letters 9, </journal> <volume> 4 (1979), </volume> <pages> 176-181. </pages>
Reference-contexts: Improvements made to the system since the publication of [2] include the addition of the above mentioned decision procedures for equalities and simple arithmetic inequalities, the extension of the definitional principle to include reflexive functions as described in <ref> [16] </ref>, and a metafunction facility permitting the incorporation of new simplifiers after they have been mechanically proved correct [3]. Finally, we have added a primitive "hint" facility so that the user can tell the theorem-prover how to prove a theorem when its heuristics lead it down blind alleys. <p> Among the other mathematically interesting proofs performed by our theorem-prover are: Wilson's Theorem: if p is a prime then (p-1)! mod p = p-1; [18] the termination over the integers of the Takeuchi function <ref> [16] </ref>: tak (x,y,z) = if x_&lt;y then y else tak (tak (x-1,y,z), tak (y-1,z,x), the soundness and completeness of a decision procedure for propositional calculus [2]; the existence of nonprimitive recursive functions; 9 the Turing completeness of the Pure LISP programming language [8]; and the recursive unsolvability of the halting problem
Reference: 17. <author> R. Rivest, A. Shamir, and L. Adleman. </author> <title> "A Method for Obtaining Digital Signatures and Public-Key Cryptosystems". </title> <journal> Communications of the ACM 21, </journal> <volume> 2 (1978), </volume> <pages> 120-126. </pages>
Reference-contexts: In this paper we illustrate this idea by mechanically checking the recently published proof of the invertibility of the public key encryption algorithm described by Rivest, Shamir, and Adleman <ref> [17] </ref>. We will briefly explain the idea of public key encryption to motivate the theorem proved. In [17] a mathematical function, here called CRYPT, is defined. CRYPT (M,e,n) is the encryption of message M with key (e,n). The function has the following important properties: 1. <p> In this paper we illustrate this idea by mechanically checking the recently published proof of the invertibility of the public key encryption algorithm described by Rivest, Shamir, and Adleman <ref> [17] </ref>. We will briefly explain the idea of public key encryption to motivate the theorem proved. In [17] a mathematical function, here called CRYPT, is defined. CRYPT (M,e,n) is the encryption of message M with key (e,n). The function has the following important properties: 1. It is easy to compute CRYPT (M,e,n). 2. <p> Each user (e.g., a computer on a network) generates an encryption key and a corresponding decryption key, publicizes the encryption key to enable others to send private messages, and never distributes the decryption key. The function defined in <ref> [17] </ref> is CRYPT (M,e,n) = M e mod n; in addition, algorithms are given for constructing e, d, and n so that CRYPT has the three properties above. The first two properties are proved in [17]. The third property is not proved; instead the authors of [17] argue that "all the <p> The function defined in <ref> [17] </ref> is CRYPT (M,e,n) = M e mod n; in addition, algorithms are given for constructing e, d, and n so that CRYPT has the three properties above. The first two properties are proved in [17]. The third property is not proved; instead the authors of [17] argue that "all the obvious approaches to breaking our system are at least as difficult as factoring n." Since there is no known 1 The research reported here was supported by National Science Foundation Grant MCS-8202943 and Office of <p> The function defined in <ref> [17] </ref> is CRYPT (M,e,n) = M e mod n; in addition, algorithms are given for constructing e, d, and n so that CRYPT has the three properties above. The first two properties are proved in [17]. The third property is not proved; instead the authors of [17] argue that "all the obvious approaches to breaking our system are at least as difficult as factoring n." Since there is no known 1 The research reported here was supported by National Science Foundation Grant MCS-8202943 and Office of Naval Research Contract N00014-81-K-0634. 1 algorithm for efficiently factoring large composites, <p> In the induction step, it supposes e is positive and assumes the conjecture for e/2. Observe that this induction is precisely the one suggested by the recursion in CRYPT. The proof required about 6 minutes of cpu time. 4. Fermat's Theorem The proof of the invertibility of CRYPT in <ref> [17] </ref> assumes the reader is familiar with elementary number theory up through Fermat's theorem. While a production model proof checker for informal proofs would come factory equipped with a good number theory library, we had no such library when we began the encryption proofs.
Reference: 18. <author> David M. Russinoff. </author> <title> A Mechanical Proof of Wilson's Theorem. </title> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <year> 1983. </year> <title> i Table of Contents </title>
Reference-contexts: Conclusion We have shown how an existing mechanical theorem-prover was used to check a recently published proof. Among the other mathematically interesting proofs performed by our theorem-prover are: Wilson's Theorem: if p is a prime then (p-1)! mod p = p-1; <ref> [18] </ref> the termination over the integers of the Takeuchi function [16]: tak (x,y,z) = if x_&lt;y then y else tak (tak (x-1,y,z), tak (y-1,z,x), the soundness and completeness of a decision procedure for propositional calculus [2]; the existence of nonprimitive recursive functions; 9 the Turing completeness of the Pure LISP programming
Reference: 1. <institution> Introduction 0 </institution>
Reference-contexts: But from the Pigeon Hole Principle we have that S (p-1,M,p) is a permutation of <ref> [p-1, ... 2, 1] </ref>.) ------------------------------------------------------------------------- To prove Lemma 1 the system inducts on n and uses the previously proved lemma that intermediate mods can be dropped.
Reference: 2. <institution> A Sketch of the Theorem-Prover 1 </institution>
Reference-contexts: A Sketch of the Theorem-Prover The theorem-prover we use is the current version of the system described in <ref> [2] </ref>. The theorem-prover deals with a quantifier free first order logic providing equality, recursively defined functions, mathematical induction, and inductively constructed objects such as the natural numbers and finite sequences. The theorem-prover is a large interactive computer program. <p> Our induction mechanism contains many heuristics for combining and choosing between the suggested inductions. That the inductions invented by the system are valid may be proved by considering the well-foundedness theorems proved when recursive functions are admitted. Readers interested in more details of the theorem-prover should see <ref> [2] </ref>, in which the system, as of May, 1978, is described at a level of detail sufficient to permit reproduction of our results. Several chapters of [2] are devoted to detailed annotated proofs by the system, including its proof of the uniqueness of prime factorizations. <p> Readers interested in more details of the theorem-prover should see <ref> [2] </ref>, in which the system, as of May, 1978, is described at a level of detail sufficient to permit reproduction of our results. Several chapters of [2] are devoted to detailed annotated proofs by the system, including its proof of the uniqueness of prime factorizations. Improvements made to the system since the publication of [2] include the addition of the above mentioned decision procedures for equalities and simple arithmetic inequalities, the extension of the definitional principle to <p> Several chapters of <ref> [2] </ref> are devoted to detailed annotated proofs by the system, including its proof of the uniqueness of prime factorizations. Improvements made to the system since the publication of [2] include the addition of the above mentioned decision procedures for equalities and simple arithmetic inequalities, the extension of the definitional principle to include reflexive functions as described in [16], and a metafunction facility permitting the incorporation of new simplifiers after they have been mechanically proved correct [3]. <p> When we began the encryption proofs we initialized the theorem-prover to the current version of the lemma library listed in Appendix A of <ref> [2] </ref>. The library contains several hundred previously proved theorems. Most of the theorems in this library were irrelevant to the encryption proofs (e.g., there are many theorems about list processing functions such as REVERSE, FLATTEN, and SORT). <p> theorem-prover are: Wilson's Theorem: if p is a prime then (p-1)! mod p = p-1; [18] the termination over the integers of the Takeuchi function [16]: tak (x,y,z) = if x_&lt;y then y else tak (tak (x-1,y,z), tak (y-1,z,x), the soundness and completeness of a decision procedure for propositional calculus <ref> [2] </ref>; the existence of nonprimitive recursive functions; 9 the Turing completeness of the Pure LISP programming language [8]; and the recursive unsolvability of the halting problem for Pure LISP [7]. We take these examples as evidence that proof checking mathematics is not only a theoretical but also a practical possibility.
Reference: 3. <institution> Correctness of CRYPT 3 </institution>
Reference-contexts: the publication of [2] include the addition of the above mentioned decision procedures for equalities and simple arithmetic inequalities, the extension of the definitional principle to include reflexive functions as described in [16], and a metafunction facility permitting the incorporation of new simplifiers after they have been mechanically proved correct <ref> [3] </ref>. Finally, we have added a primitive "hint" facility so that the user can tell the theorem-prover how to prove a theorem when its heuristics lead it down blind alleys. There are two types of hints used in this paper.
Reference: 4. <institution> Fermat's Theorem 5 </institution>
Reference-contexts: The less ambitious motivation behind much automatic theorem-proving research -- certainly ours -- is to mechanize the often mundane and tedious proofs arising in connection with computer programs. For example, our theorem-prover has been used to prove thousands of theorems related to the correctness of various programs <ref> [4, 5] </ref>, communications protocols [9], and computer security [10].
Reference: 5. <institution> Invertibility of CRYPT 7 </institution>
Reference-contexts: The less ambitious motivation behind much automatic theorem-proving research -- certainly ours -- is to mechanize the often mundane and tedious proofs arising in connection with computer programs. For example, our theorem-prover has been used to prove thousands of theorems related to the correctness of various programs <ref> [4, 5] </ref>, communications protocols [9], and computer security [10].
Reference: 6. <institution> Sample Input to the Theorem-Prover 8 </institution>
Reference-contexts: Theorem. CRYPT.CORRECT (rewrite): (IMPLIES (NOT (EQUAL N 1)) (EQUAL (CRYPT M E N) (REMAINDER (EXP M E) N))) Readers interested in the complete list of definitions and theorems typed by the user, should see section 8 of <ref> [6] </ref>. 7. Conclusion We have shown how an existing mechanical theorem-prover was used to check a recently published proof.
Reference: 7. <institution> Conclusion 8 </institution>
Reference-contexts: if x_&lt;y then y else tak (tak (x-1,y,z), tak (y-1,z,x), the soundness and completeness of a decision procedure for propositional calculus [2]; the existence of nonprimitive recursive functions; 9 the Turing completeness of the Pure LISP programming language [8]; and the recursive unsolvability of the halting problem for Pure LISP <ref> [7] </ref>. We take these examples as evidence that proof checking mathematics is not only a theoretical but also a practical possibility. We doubt that the mechanical theorem-provers of today could be easily used to check theorems at the frontiers of mathematics.
Reference: 8. <institution> The Formal Details 10 8.1. </institution> <note> Correctness of CRYPT 10 8.2. Miscellaneous Theorems 10 8.3. Theorems 53 and 55 12 8.4. The Pigeon Hole Principle 13 8.5. Fermat's Theorem 15 8.6. Invertibility of CRYPT 16 </note>
Reference-contexts: termination over the integers of the Takeuchi function [16]: tak (x,y,z) = if x_&lt;y then y else tak (tak (x-1,y,z), tak (y-1,z,x), the soundness and completeness of a decision procedure for propositional calculus [2]; the existence of nonprimitive recursive functions; 9 the Turing completeness of the Pure LISP programming language <ref> [8] </ref>; and the recursive unsolvability of the halting problem for Pure LISP [7]. We take these examples as evidence that proof checking mathematics is not only a theoretical but also a practical possibility.
References-found: 27

