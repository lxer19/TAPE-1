URL: http://www.cs.cornell.edu/slk/papers/TR98-1670.ps
Refering-URL: http://www.cs.cornell.edu/slk/papers.html
Root-URL: 
Title: A Case for Language-Based Protection  
Author: Chris Hawblitzel and Thorsten von Eicken 
Address: Ithaca, NY  
Affiliation: Department of Computer Science Cornell University  
Date: March 1998 1  
Pubnum: Technical Report 98-1670  
Abstract: The use of language mechanisms to enforce protection boundaries around software modules has become increasingly attractive. This paper examines the advantages and disadvantages of language-based protection over more traditional protection mechanisms, such as standard virtual memory protection hardware, software fault isolation, and capability systems. Arguably, state-of-the-art language-based protection is more flexible and as safe as these other mechanisms. Two major remaining issues are the performance of language-based protection, and the management of resources. Regarding the latter, techniques to build an operating system kernel capable of managing resources and revoking rights are presented.
Abstract-found: 1
Intro-found: 1
Reference: [ALL+96] <author> A. Adl-Tabatabai, G. Langdale, S. Lucco, and R. Wahbe. </author> <title> Efficient and Language-Independent Mobile Programs. </title> <booktitle> Conference on Programming Language Design and Implementation, </booktitle> <address> p. 127136, Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Wahbe et. al. [WLA+93] discuss an efficient SFI technique called sandboxing, which slow down various SPEC92 and Splash benchmarks around 20% on average on RISC processors when both loads and stores are checked. Adl-Tabatabai et. al. <ref> [ALL+96] </ref> report slowdowns of 5-20% on RISC and x86 architectures for SFI that protects against errant stores but not loads, and Small [Sma97] reports 1-9% slowdowns when protecting against errant stores on x86, and 40-300% slowdowns when also checking loads. 3.3 Summary The question whether language-based or address-based protection is better
Reference: [Bak92] <author> H.G. Baker. </author> <title> Lively Linear Lisp - 'Look Ma, No Garbage!'. </title> <journal> ACM Sigplan Notices, </journal> <volume> Volume 27, Number 8, </volume> <pages> p. 89-98, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: It includes the type-checker, the garbage collector, and any TAL-tonative instruction translator being used. The properties enforced by the type-checker can all be verified formally, but that has not yet been done for the type checker code itself. Alternatives to garbage collection, such as regions [TT94] and linear objects <ref> [Bak92] </ref> exist, but their practicality is unclear. A system that relies entirely on TAL for protection without any hardware support for address translation or protection, without any hardware privilege levels, and without any synchronous exceptions could arrive at an arguably smaller TCB than current hardware approaches.
Reference: [BAL89] <author> B. N. Bershad, T. E. Anderson, E. D. Lazowska, and H. M. Levy. </author> <title> Lightweight Remote Procedure Call. </title> <booktitle> 12 th ACM Symposium on Operating Systems Principles, p. </booktitle> <pages> 102-113, </pages> <address> Lichtfield Park, AZ, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: To ensure that only capabilities are shared between tasks, the stub passes all non-capability arguments by copy rather than by reference. Tasks then interact with one another by exchanging capabilities and invoking methods on the capabilities. 3 Capabilities can be viewed as implementing a form of LRPC <ref> [BAL89] </ref>, or, more precisely, LRMI (local remote-method-invocation). March 1998 10 The J-Kernel keeps track of all capabilities created by a task and it can revoke any of them by setting the indirection pointers to nil.
Reference: [BSP95] <author> B. N. Bershad, S. Savage, and P. Pardyak. </author> <title> Protection is a Software Issue. </title> <booktitle> Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <address> Orcas Island, WA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: For example, naive emulation of language primitives in hardware and of hardware primitives in a safe language both perform poorly. 3.1 (Stereo-)Typical advantages of language-based mechanisms Language-based protection is generally thought of as having a number of advantages over address-based protection <ref> [BSP95] </ref>. Due to Java, portability is probably the most obvious. But the fact that the language can precisely specify the data items to be protected gives it another advantage over address-based protection, where the precision (sometimes called granularity) of protection is generally a memory page frame.
Reference: [BSP+95] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> 15 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 267284, Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The motivation for using language-based protection in Java is portability (the famous write once, run anywhere). Extensible operating systems use language-based protection as well. In particular, the SPIN OS <ref> [BSP+95] </ref> uses a trusted Modula-3 compiler to protect the core of the operating system from extensions that are loaded into the OS by users. In this case, the motivation for using language-based protection is performance: calls across protection boundaries (i.e., in and out of extensions) are just regular function calls.
Reference: [Che94] <author> D. R. Cheriton. </author> <title> Low and High Risk Operating System Architectures. </title> <booktitle> First USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <address> p. 197, Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In addition, the hardware protection mechanisms are argued to be more secure than software-ones, to work with applications written in any language, and to not slowdown the execution of normal code through interspersed security checks or constraints on code generation <ref> [Che94, JLI98] </ref>. A major difficulty in evaluating these arguments stems from the fact that many levels of abstractions and mechanisms are involved: the protection mechanisms provided by the hardware, the abstractions provided by the operating system, and the features offered by the high-level language. <p> Language-based mechanisms offer efficient fine grain protection: boundaries can be specified precisely and crossed with low overhead. In addition, safety need not be inferior to hardware solutions; language-based protection can no longer be called a high-risk approach <ref> [Che94] </ref>. How an operating system kernel built on language-based protection primitives should be structured remains an open question.
Reference: [CKD94] <author> N. P. Carter, S. W. Keckler, and W. J. Dally. </author> <title> Hardware Support for Fast Capability-based Addressing. </title> <booktitle> Sixth Intl Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> p. 319327, San Jose, CA, </address> <year> 1994. </year>
Reference-contexts: In a capability system, data values are distinguished from pointers (capabilities) and the system enforces that data values cannot be used as capabilities. Some systems add a tag bit to every word in memory to distinguish data and pointers <ref> [CKD94] </ref>, others partition memory into data and capability segments, and some software implementations use cryptography techniques to distinguish capabilities from data. Both safe languages and capability systems work by distinguishing several types of values in memory.
Reference: [EB79] <author> K. Ekanadham and A. J. Bernstein. </author> <title> Conditional Capabilities. </title> <journal> IEEE Transactions on Software Engineering, p. </journal> <volume> 458464, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: More recent work by Necula and Lee [NL98] describe the translation of a typesafe subset of C to proof-carrying code, where the proofs express guarantees provided by the type system. 2.3 General type-based mechanisms Language-based protection is closely related to capability systems <ref> [EB79, Lev84, PCH+82, Red74, WLH81] </ref>. In a capability system, data values are distinguished from pointers (capabilities) and the system enforces that data values cannot be used as capabilities. <p> Revocation has historically been a problem for type-based systems, because pointers point directly to objects, without indirection. Revocation requires either adding a level of indirection, or somehow invalidating the direct pointers to an object. Redells thesis [Red74] and Ekanadham et. al. <ref> [EB79] </ref> discuss many design choices available in the context of capability systems. 3.2.5 Performance of regular code An important problem with language-based protection (and with software-based protection in general) is the performance penalty imposed on regular code, i.e., code that does not make use of any special sharing or protection feature. <p> How an operating system kernel built on language-based protection primitives should be structured remains an open question. A return to capability systems, as proposed in the J-Kernel, seems attractive but raises a 4 Revocation handles are similar to Ekanadhams conditional capabilities <ref> [EB79] </ref>, except that revocation handles point to capabilities and not the other way around, and that revocation cannot be undone. March 1998 11 number of issues.
Reference: [EKO95] <author> R. Engler, M. F. Kaashoek, and J. James OToole. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> 15 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 251266, Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: In this case, the motivation for using language-based protection is performance: calls across protection boundaries (i.e., in and out of extensions) are just regular function calls. Recent work on micro-kernels, most prominently L4 [Hr97, Lie95] and the Exokernel <ref> [EKO95] </ref>, counter-argues that protection boundaries enforced by standard hardware mechanisms can be crossed with very low overheads. In essence, a well-implemented micro-kernel can expose the hardware mechanisms in a very flexible way and can provide very low-overhead inter-process communication.
Reference: [GJS96] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java language specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction The use of language mechanisms to enforce protection boundaries around software modules has increased over the past few years. The most notable example is Java <ref> [GJS96, GS98, WBD+97] </ref> where checks applied at the bytecode level enforce protection boundaries, which, for example, prevent access to arbitrary objects in memory. The motivation for using language-based protection in Java is portability (the famous write once, run anywhere). Extensible operating systems use language-based protection as well.
Reference: [GS98] <author> L. Gong and R. Schemers. </author> <title> Implementing Protection Domains in the Java Development Kit 1.2. Internet Society Symposium on Network and Distributed System Security, </title> <address> San Diego, CA, </address> <month> March </month> <year> 1998. </year>
Reference-contexts: 1 Introduction The use of language mechanisms to enforce protection boundaries around software modules has increased over the past few years. The most notable example is Java <ref> [GJS96, GS98, WBD+97] </ref> where checks applied at the bytecode level enforce protection boundaries, which, for example, prevent access to arbitrary objects in memory. The motivation for using language-based protection in Java is portability (the famous write once, run anywhere). Extensible operating systems use language-based protection as well.
Reference: [Hr97] <author> H. Hrtig, M. Hohmuth, J. Liedtke, S. Schnberg, and J. Wolter. </author> <title> The Performance of m-Kernel-Based Systems. </title> <booktitle> 16 th ACM Symposium on Operating Systems Principles, p. </booktitle> <pages> 66-77, </pages> <address> Saint-Malo, France, </address> <month> October, </month> <year> 1997. </year>
Reference-contexts: In this case, the motivation for using language-based protection is performance: calls across protection boundaries (i.e., in and out of extensions) are just regular function calls. Recent work on micro-kernels, most prominently L4 <ref> [Hr97, Lie95] </ref> and the Exokernel [EKO95], counter-argues that protection boundaries enforced by standard hardware mechanisms can be crossed with very low overheads. In essence, a well-implemented micro-kernel can expose the hardware mechanisms in a very flexible way and can provide very low-overhead inter-process communication.
Reference: [HCC+98] <author> C. Hawblitzel, C. C. Chang, G. Czajkowski, D. Hu, and T. von Eicken. </author> <title> Implementing Multiple Protection Domains in Java. To appear. </title> <booktitle> USENIX Annual Technical Conference, </booktitle> <address> New Orleans, LA, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Alternatively, the micro-kernel facilities could be provided by a special runtime system, or integrated into the language itself. 4.1 Resource management in the J-Kernel One sample system, which layers revocation on top of the language-based protection mechanisms, is the J-Kernel <ref> [HCC+98] </ref>, a micro-kernel written in Java that runs on standard Java virtual machines and allows multiple tasks to run protected from each other. It uses the Java class loader and the safety of Javas type system to isolate the tasks from each other, not unlike browsers do with applets.
Reference: [HFG+96] <author> W. C. Hsieh, M. Fiuczynski, C. Garrett, S. Savage, D. Becker, and B. N. Bershad. </author> <title> Language Support for Extensible Operating Systems. </title> <booktitle> First Workshop on Compiler Support for System Software, </booktitle> <address> Tucson, AZ, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: In C, this can be accomplished by a simple type cast while in Java, an object must be allocated and the data must be copied into it from the byte array. Hsieh et. al. describe an extension to Modula-3 to optimize this particular case <ref> [HFG+96] </ref>. Sirer et al [SFP96] report that for several small benchmarks Modula-3 performance ranges from 20% slower to 8% faster than optimized C code.
Reference: [Int97] <author> Intel Corporation. </author> <title> Pentium Processor Invalid Operand with Locked Compare and Exchange 8Byte (CMPXCHG8B) Instruction Erratum, </title> <note> http://intel.com/support/processors/pentium/ppiie/, November 20 1997. </note>
Reference-contexts: The major gain is that illegal instructions do not need to be handled correctly by the hardware as SFI can guarantee that none will ever be executed. To witness the latest Pentium Invalid CMPXCH8B Instruction bug <ref> [Int97] </ref> in which an illegal instruction can lock up the processor this may be a significant win. In the case of TAL, the TCB is larger than for SFI. It includes the type-checker, the garbage collector, and any TAL-tonative instruction translator being used.
Reference: [JL78] <author> A. K. Jones and B. H. Liskov. </author> <title> A Language Extension for Expressing Constraints on Data Access. </title> <journal> Communications of the ACM, </journal> <volume> Volume 21, Number 5, </volume> <editor> p. </editor> <volume> 358367, </volume> <month> May </month> <year> 1978. </year>
Reference-contexts: One can design safe languages that have more sophisticated access control features than the features above. For instance, Jones and Liskov <ref> [JL78] </ref> extended a languages type system to talk about access rights directly, to provide a similar functionality to advanced capability systems such as Hydra [WLH81]. Recently Myers and Liskov [ML97] have extended this idea to cover information flow control.
Reference: [JLI98] <author> T. Jaeger, J. Liedtke, and N. Islam. </author> <title> Operating System Protection for Fine-Grained Programs. </title> <booktitle> 7 th USENIX Security Symposium, </booktitle> <address> San Antonio, TX, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: In addition, the hardware protection mechanisms are argued to be more secure than software-ones, to work with applications written in any language, and to not slowdown the execution of normal code through interspersed security checks or constraints on code generation <ref> [Che94, JLI98] </ref>. A major difficulty in evaluating these arguments stems from the fact that many levels of abstractions and mechanisms are involved: the protection mechanisms provided by the hardware, the abstractions provided by the operating system, and the features offered by the high-level language. <p> Claims that address-based approaches offer all of the advantages of language-based approaches, without being restricted to a single language or requiring trust in a compiler <ref> [JLI98] </ref> are outdated and do not consider all the issues. Language-based mechanisms offer efficient fine grain protection: boundaries can be specified precisely and crossed with low overhead. In addition, safety need not be inferior to hardware solutions; language-based protection can no longer be called a high-risk approach [Che94].
Reference: [JW75] <author> A. K. Jones and W. A. Wulf. </author> <title> Towards the Design of Secure Systems. </title> <journal> Software Practice and Experience, </journal> <volume> Volume 5, Number 4, </volume> <editor> p. </editor> <volume> 321336, </volume> <year> 1975. </year>
Reference-contexts: The comparisons often hinge on the coupling between the layers of abstraction. For example, while it is possible to build a capability system with fine-grain protection on top of conventional page-level memory protection hardware, it has proven to be inefficient <ref> [JW75, WLH81] </ref>. In the end, what matters is the power of the protection abstractions available to the application programmer and the efficiency with which these can be mapped to the hardware at hand.
Reference: [LES+95] <author> J. Liedtke, K. Elphinstone, S. Schnberg, H. Hrtig, G. Heiser, N. Islam, and T. Jaeger. </author> <title> Achieved IPC Performance. </title> <booktitle> 6 th Workshop on Hot Topics in Operating Systems, </booktitle> <address> p. 2831, Chatham, MA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: This is significantly faster than the fastest micro-kernels. L4, for instance, takes around 242 cycles for a round-trip RPC by using two IPCs on a 166 MHz Pentium (passing up to 3 words of data each way in registers) <ref> [LES+95] </ref>. With this low capability invocation overhead, the most significant cost is likely to be the cost of copying arguments.
Reference: [Lev84] <author> H. M. Levy. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <year> 1984. </year> <month> March </month> <year> 1998 </year> <month> 12 </month>
Reference-contexts: More recent work by Necula and Lee [NL98] describe the translation of a typesafe subset of C to proof-carrying code, where the proofs express guarantees provided by the type system. 2.3 General type-based mechanisms Language-based protection is closely related to capability systems <ref> [EB79, Lev84, PCH+82, Red74, WLH81] </ref>. In a capability system, data values are distinguished from pointers (capabilities) and the system enforces that data values cannot be used as capabilities.
Reference: [Lie95] <editor> J. Liedtke. </editor> <booktitle> 2Qfl NHUQHOfl &RQVWUXFWLRQfl 15 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 237 250, Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: In this case, the motivation for using language-based protection is performance: calls across protection boundaries (i.e., in and out of extensions) are just regular function calls. Recent work on micro-kernels, most prominently L4 <ref> [Hr97, Lie95] </ref> and the Exokernel [EKO95], counter-argues that protection boundaries enforced by standard hardware mechanisms can be crossed with very low overheads. In essence, a well-implemented micro-kernel can expose the hardware mechanisms in a very flexible way and can provide very low-overhead inter-process communication.
Reference: [LY96] <author> T. Lindholm, and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Some languages, such as Scheme, perform almost all type enforcement at runtime, which tends to slow down program execution. In Java the protection is defined at the bytecode level and enforced by the socalled bytecode verifier <ref> [LY96] </ref>. Bytecode is structured such that the verifier can trace all control flows and can verify that the bytecode obeys by the restrictions of the Java type system.
Reference: [Mor73] <author> J. H. Morris Jr. </author> <title> Protection in Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> Volume 16, Number 1, </volume> <editor> p. </editor> <volume> 1521, </volume> <month> January </month> <year> 1973. </year>
Reference-contexts: On top of typesafety, the language must also provide some form of access March 1998 3 control for the objects manipulated by the tasks <ref> [Mor73] </ref>. Most safe languages provide two simple forms of access control: Dynamic access control mechanisms to determine to which objects an executing task has access. Usually a task only has access to objects that it created itself, and to objects that are explicitly passed to it by another task.
Reference: [ML97] <author> A. Myers and B. Liskov. </author> <title> A Decentralized Model for Information Flow Control. </title> <booktitle> 16 th ACM Symposium on Operating System Principles, </booktitle> <address> p. 129142, Saint Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: For instance, Jones and Liskov [JL78] extended a languages type system to talk about access rights directly, to provide a similar functionality to advanced capability systems such as Hydra [WLH81]. Recently Myers and Liskov <ref> [ML97] </ref> have extended this idea to cover information flow control. Another possible feature would be direct support for revocation; the features above allow programs to grant access to other programs, but not to later revoke access. This is explored in more detail in Section 4.
Reference: [MWC+98] <author> G. Morrisett, D. Walker, K. Crary, and N. Glew. </author> <title> From System F to Typed Assembly Language. </title> <booktitle> 25 th Symposium on Principles of Programming Languages. </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: In a recent development, language-based protection mechanisms are being moved to lower and lower levels of abstraction in order to reduce the complexity of the code that transforms the verified code into executable machine instructions. Typed Assembly Language (TAL) <ref> [MWC+98] </ref> consists of a regular instruction set (currently an x86 subset) augmented with a memory allocation instruction and with type annotations. The type annotations allow a type-checker to verify that code is typesafe.
Reference: [Nec97] <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> 24 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> p. 106 119, Paris, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: The return address is a pointer to code that expects an integer in register ECX (the return value of the function) and a stack pointer in register ESP pointing to the same rest of the stack (a1) as at entry. Proof carrying code (PCC) <ref> [Nec97] </ref> generalizes many different approaches to software protection arbitrary binary code can be executed as long as it comes with a proof that it is safe (or satisfies some other policy). PCC may be used to enforce address-based protection, or it can express safety through a type system.
Reference: [NL96] <author> G. Necula and P. Lee. </author> <title> Safe Kernel Extensions Without RunTime Checking. </title> <booktitle> 2 nd USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <address> p. 229243, Seattle, WA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: PCC may be used to enforce address-based protection, or it can express safety through a type system. Necula et. al. described packet filters whose safety predicates were at least partly address-based <ref> [NL96] </ref>. PCC can also be used to express the correctness of software fault isolation.
Reference: [NL98] <author> G. Necula and P. Lee. </author> <title> The Design and Implementation of a Certifying Compiler. To appear. </title> <booktitle> ACM Conference on Programming Language Design and Implementation. </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Necula et. al. described packet filters whose safety predicates were at least partly address-based [NL96]. PCC can also be used to express the correctness of software fault isolation. More recent work by Necula and Lee <ref> [NL98] </ref> describe the translation of a typesafe subset of C to proof-carrying code, where the proofs express guarantees provided by the type system. 2.3 General type-based mechanisms Language-based protection is closely related to capability systems [EB79, Lev84, PCH+82, Red74, WLH81].
Reference: [Org73] <author> E. I. Organick, </author> <title> Computer System Organization, The B5700/B6700 Series. </title> <publisher> Academic Press, </publisher> <year> 1973. </year>
Reference-contexts: While a number of hardware projects have tried to build hardware that implements the elements manipulated by the programming language directly, these efforts have mostly lead to excessively complex hardware <ref> [Org73, PCH+82] </ref>. 3.1.2 Rights amplification A major advantage of the language-based approach is that certain forms of selective rights amplification are very cheap.
Reference: [OW97] <author> M. Odersky and P. Wadler. </author> <title> Pizza into Java: Translating Theory into Practice. </title> <booktitle> 24 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> p. 146159, Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: The Pilot system [RDH80] and Oberon [WG89] are examples where this is the case. It is possible to compile one safe language down to another safe language for instance, Ada95 and Pizza can be compiled to Java bytecode <ref> [OW97, Taf96] </ref>, but mismatches between the language features often result in suboptimal performance when this is done. TAL provides a more universal platform for multiple languages to compile to, but its type system 2 may still lead to mismatches.
Reference: [PCH+82] <author> F. J. Pollack, G. W. Cox, D. W. Hammerstrom, K. C. Kahn, K. K. Lai, and J. R. Rattner. </author> <title> Supporting Ada Memory Management in the iAPX-432. </title> <booktitle> Symposium on Architectural Support for Programming Languages and Operating Systems, p. </booktitle> <pages> 117-131, </pages> <address> Palo Alto, CA, </address> <year> 1982. </year>
Reference-contexts: More recent work by Necula and Lee [NL98] describe the translation of a typesafe subset of C to proof-carrying code, where the proofs express guarantees provided by the type system. 2.3 General type-based mechanisms Language-based protection is closely related to capability systems <ref> [EB79, Lev84, PCH+82, Red74, WLH81] </ref>. In a capability system, data values are distinguished from pointers (capabilities) and the system enforces that data values cannot be used as capabilities. <p> While a number of hardware projects have tried to build hardware that implements the elements manipulated by the programming language directly, these efforts have mostly lead to excessively complex hardware <ref> [Org73, PCH+82] </ref>. 3.1.2 Rights amplification A major advantage of the language-based approach is that certain forms of selective rights amplification are very cheap.
Reference: [Red74] <author> D. D. Redell. </author> <title> Naming and Protection in Extendible Operating Systems. </title> <type> Technical Report 140, </type> <institution> Project MAC, MIT 1974. </institution>
Reference-contexts: More recent work by Necula and Lee [NL98] describe the translation of a typesafe subset of C to proof-carrying code, where the proofs express guarantees provided by the type system. 2.3 General type-based mechanisms Language-based protection is closely related to capability systems <ref> [EB79, Lev84, PCH+82, Red74, WLH81] </ref>. In a capability system, data values are distinguished from pointers (capabilities) and the system enforces that data values cannot be used as capabilities. <p> Revocation has historically been a problem for type-based systems, because pointers point directly to objects, without indirection. Revocation requires either adding a level of indirection, or somehow invalidating the direct pointers to an object. Redells thesis <ref> [Red74] </ref> and Ekanadham et. al. [EB79] discuss many design choices available in the context of capability systems. 3.2.5 Performance of regular code An important problem with language-based protection (and with software-based protection in general) is the performance penalty imposed on regular code, i.e., code that does not make use of any
Reference: [RDH80] <author> D. Redell, Y. Dalal, T. Horsley, H. Lauer, W. Lynch, P. McJones, H. Murray, and S. Purcell. </author> <title> Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> Volume 23, Number 2, </volume> <editor> p. </editor> <volume> 81 92, </volume> <month> February </month> <year> 1980. </year>
Reference-contexts: The Pilot system <ref> [RDH80] </ref> and Oberon [WG89] are examples where this is the case.
Reference: [Sch98] <author> F. B. Schneider. </author> <title> Enforceable Security Policies. </title> <institution> Cornell University Computer Science Technical Report TR98-1664, </institution> <month> January </month> <year> 1998. </year>
Reference-contexts: applies to all software based protection mechanisms: SFI, Java, TAL can all be ported to a variety of existing architectures and operating systems, while hardware-based protection mechanisms by definition cannot. 3.1.4 Power of security policies While this paper primarily examines access rights, it is interesting to note that, as Schneider <ref> [Sch98] </ref> points out, language-based protection mechanisms allow more general security policies to be implemented than mechanisms that rely only on runtime checks of program behavior.
Reference: [SFP96] <author> E. G. Sirer, M. Fiuczynski, and P. Pardyak. </author> <title> Writing an Operating System with Modula-3. </title> <booktitle> First Workshop on Compiler Support for System Software, </booktitle> <address> Tucson, AZ, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: In C, this can be accomplished by a simple type cast while in Java, an object must be allocated and the data must be copied into it from the byte array. Hsieh et. al. describe an extension to Modula-3 to optimize this particular case [HFG+96]. Sirer et al <ref> [SFP96] </ref> report that for several small benchmarks Modula-3 performance ranges from 20% slower to 8% faster than optimized C code.
Reference: [Sma97] <author> C. </author> <title> Small. MiSFIT: A Tool For Constructing Safe Extensible C++ Systems. </title> <booktitle> Third USENIX Conference on ObjectOriented Technologies, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Adl-Tabatabai et. al. [ALL+96] report slowdowns of 5-20% on RISC and x86 architectures for SFI that protects against errant stores but not loads, and Small <ref> [Sma97] </ref> reports 1-9% slowdowns when protecting against errant stores on x86, and 40-300% slowdowns when also checking loads. 3.3 Summary The question whether language-based or address-based protection is better cannot be resolved in absolute.
Reference: [SS75] <author> J. H. Saltzer and M. Schroeder. </author> <title> The Protection of Information in Computer System. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> Volume 63, Number 9, </volume> <editor> p. </editor> <volume> 12781308, </volume> <month> September </month> <year> 1975. </year>
Reference-contexts: For example, in Java, access can be granted precisely to individual objects and even to only certain object fields using the public qualifier. The precision with which access rights can be specified is important in enforcing what Saltzer and Schroeder call the principle of least privilege <ref> [SS75] </ref>: each principal in a system should get access only to the data and operations it needs to perform its task. When sharing data structures between tasks, language-based protection mechanisms make it possible to share just the required elements of the data structure.
Reference: [Taf96] <author> T. Taft. </author> <title> Programming the Internet in Ada 95. </title> <note> http://www.inmet.com/appletmagic/ajpaper/index.html. May 1996. </note>
Reference-contexts: The Pilot system [RDH80] and Oberon [WG89] are examples where this is the case. It is possible to compile one safe language down to another safe language for instance, Ada95 and Pizza can be compiled to Java bytecode <ref> [OW97, Taf96] </ref>, but mismatches between the language features often result in suboptimal performance when this is done. TAL provides a more universal platform for multiple languages to compile to, but its type system 2 may still lead to mismatches.
Reference: [TT94] <author> M. Tofte and J.P. Talpin. </author> <title> Implementation of the Typed Call-by-Value Lambda Calculus using a Stack of Regions. </title> <booktitle> 21 st ACM Symposium on Principles of Programming Languages, </booktitle> <address> p. 188201, Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: It includes the type-checker, the garbage collector, and any TAL-tonative instruction translator being used. The properties enforced by the type-checker can all be verified formally, but that has not yet been done for the type checker code itself. Alternatives to garbage collection, such as regions <ref> [TT94] </ref> and linear objects [Bak92] exist, but their practicality is unclear. A system that relies entirely on TAL for protection without any hardware support for address translation or protection, without any hardware privilege levels, and without any synchronous exceptions could arrive at an arguably smaller TCB than current hardware approaches. <p> Because of these costs, we are investigating how data can be shared directly among tasks without sacrificing revocation and resource reclamation. The most promising approach seems to be to extend the TAL type system to talk about resource revocation directly; regions <ref> [TT94] </ref> provide a promising framework for this. 5 Conclusion The main tenet of this paper is that state-of-the-art language-based protection is an attractive alternative to more traditional approaches.
Reference: [WBD+97] <author> D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. </author> <title> Extensible Security Architectures for Java. </title> <booktitle> 16 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 116128, Saint-Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: 1 Introduction The use of language mechanisms to enforce protection boundaries around software modules has increased over the past few years. The most notable example is Java <ref> [GJS96, GS98, WBD+97] </ref> where checks applied at the bytecode level enforce protection boundaries, which, for example, prevent access to arbitrary objects in memory. The motivation for using language-based protection in Java is portability (the famous write once, run anywhere). Extensible operating systems use language-based protection as well.
Reference: [WG89] <author> N. Wirth, J. Gutknecht. </author> <title> The Oberon System. </title> <journal> Software Practice and Experience, </journal> <volume> Volume 19, Number 9, </volume> <editor> p. </editor> <volume> 857893, </volume> <year> 1989. </year>
Reference-contexts: The Pilot system [RDH80] and Oberon <ref> [WG89] </ref> are examples where this is the case. It is possible to compile one safe language down to another safe language for instance, Ada95 and Pizza can be compiled to Java bytecode [OW97, Taf96], but mismatches between the language features often result in suboptimal performance when this is done.
Reference: [WLA+93] <author> R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> 14 th ACM Symposium on Operating Systems Principles, </booktitle> <address> p. 203216, Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: While it is possible to use smaller page frames in some implementations, this is generally inefficient. Address-based protection can also be implemented in software using a technique called software fault isolation (SFI) <ref> [WLA+93] </ref>. In SFI, an executable is analyzed and modified to enforce that all memory references lie within the address space. Part of the enforcement is by analysis and part is by the insertion of explicit checks. <p> Hsieh et. al. describe an extension to Modula-3 to optimize this particular case [HFG+96]. Sirer et al [SFP96] report that for several small benchmarks Modula-3 performance ranges from 20% slower to 8% faster than optimized C code. Wahbe et. al. <ref> [WLA+93] </ref> discuss an efficient SFI technique called sandboxing, which slow down various SPEC92 and Splash benchmarks around 20% on average on RISC processors when both loads and stores are checked.
Reference: [WLH81] <author> W. A. Wulf, R. Levin, and S. P. Harbsion. </author> <title> Hydra/C.mmp:An Experimental Computer System. </title> <publisher> McGraw Hill, </publisher> <year> 1981. </year>
Reference-contexts: The comparisons often hinge on the coupling between the layers of abstraction. For example, while it is possible to build a capability system with fine-grain protection on top of conventional page-level memory protection hardware, it has proven to be inefficient <ref> [JW75, WLH81] </ref>. In the end, what matters is the power of the protection abstractions available to the application programmer and the efficiency with which these can be mapped to the hardware at hand. <p> One can design safe languages that have more sophisticated access control features than the features above. For instance, Jones and Liskov [JL78] extended a languages type system to talk about access rights directly, to provide a similar functionality to advanced capability systems such as Hydra <ref> [WLH81] </ref>. Recently Myers and Liskov [ML97] have extended this idea to cover information flow control. Another possible feature would be direct support for revocation; the features above allow programs to grant access to other programs, but not to later revoke access. This is explored in more detail in Section 4. <p> More recent work by Necula and Lee [NL98] describe the translation of a typesafe subset of C to proof-carrying code, where the proofs express guarantees provided by the type system. 2.3 General type-based mechanisms Language-based protection is closely related to capability systems <ref> [EB79, Lev84, PCH+82, Red74, WLH81] </ref>. In a capability system, data values are distinguished from pointers (capabilities) and the system enforces that data values cannot be used as capabilities.
References-found: 43

