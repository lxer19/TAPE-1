URL: http://www.idt.unit.no/IDT/grupper/DB-grp/tech_papers/SCCC96/SCCC96.ps
Refering-URL: http://www.idt.unit.no/IDT/grupper/DB-grp/tech_papers/tech_papers.html
Root-URL: 
Email: fnoervaag,kjellbg@idt.ntnu.no  
Title: Aggregate and Grouping Functions in Object-Oriented Databases  
Author: Kjetil Ntrv-ag and Kjell Bratbergsengen 
Keyword: and phrases: aggregate functions, object-oriented databases, database program ming languages, query processing  
Address: N-7034 Trondheim, Norway  
Affiliation: Norwegian University of Science and Technology Department of Computer Science  
Abstract: Efficient evaluation of aggregate functions in object-oriented databases (OODB) can have considerable impact on performance in many application areas, like geographic information systems and statistical and scientific databases. The problem with current systems is inefficient execution of aggregate functions with large data volumes, and lack of flexibility: it is not possible to extend the systems with new aggregate and grouping functions. In this paper, we extend the concept of aggregate functions from relational databases. We introduce the concept of grouping functions, which could enhance flexibility and performance considerably. We show how this could be implemented into an OODB. We also describe how support for special kinds of aggregate queries and data structures can help in designing future high-performance systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Bitton, H. Boral, D. J. DeWitt, and W. K. Wilkinson. </author> <title> Parallel Algorithms for the Execution of Relational Database Operations. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(3), </volume> <year> 1983. </year>
Reference-contexts: The most important work is, of course, research done on aggregate function evaluation in relational databases. The fundamentals are the same, and many results valid for relational databases applies to OODB as well. Valuable sources for aggregate function evaluation are Bitton et.al. <ref> [1] </ref>, Bratbergsengen [3] and Shatdal et.al. [16]. Only recently has the grouping functions been the focus for query optimization [23, 9, 10]. 3 Aggregate and Grouping Functions Aggregation is basically partitioning a set of objects into groups, and evaluate one or several aggregate functions over the objects in the groups.
Reference: [2] <author> K. Bratbergsengen. </author> <title> Hashing Methods and Relational Algebra Operations. </title> <booktitle> In Proceedings of the 10th International Conference on VLDB, </booktitle> <year> 1984. </year>
Reference-contexts: If the input stream is not sorted initially, which is common in an OODB 5 , it is better to use a partition-aggregate algorithm. With un-sorted input, partition-aggregate will always perform better than sort-aggregate <ref> [2] </ref>. 6.4 Parallel Aggregation In general, it is difficult to parallelize navigational queries in OODB [11]. Set processing, on the other hand, lends itself to parallelizing. With parallel machines, distribution of work between nodes can improve performance.
Reference: [3] <author> K. Bratbergsengen. </author> <title> Relational Algebra Operations. </title> <booktitle> In PRISMA Project Workshop, </booktitle> <address> Nordwijk, The Netherlands, </address> <year> 1990. </year>
Reference-contexts: The most important work is, of course, research done on aggregate function evaluation in relational databases. The fundamentals are the same, and many results valid for relational databases applies to OODB as well. Valuable sources for aggregate function evaluation are Bitton et.al. [1], Bratbergsengen <ref> [3] </ref> and Shatdal et.al. [16]. Only recently has the grouping functions been the focus for query optimization [23, 9, 10]. 3 Aggregate and Grouping Functions Aggregation is basically partitioning a set of objects into groups, and evaluate one or several aggregate functions over the objects in the groups. <p> With the notation from Section 4, and the result put into Result, this can be written: AGGREGATE (Employees:avg (age):I (department):Result) 4 This operator is based on the aggregate operator described by Bratbergsengen in <ref> [3] </ref>. <p> Redistribution with Local Aggregation In the parallel aggregation by redistribution algorithm, more data than necessary is moved. With large groups (many objects in each group), we can gain much by doing local aggregation before redistribution <ref> [3] </ref>. This is the way aggregation with grouping is done in e.g. Gamma [6]. In the first phase, all nodes do local aggregation on data residing on the node, just as in the local aggregation/central coordinator algorithm.
Reference: [4] <author> R. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. Release 1.2. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Most object-oriented databases have (or will soon have) support for aggregate functions with grouping in their query language, but lacks support in their application languages, requiring the user to explicitly call the query language from the application language, giving an impedance mismatch. In the ODMG-93 Object Query Language <ref> [4] </ref> the operations are supported by a group-by-expression similar to SQL. To illustrate notation and languages, we will use the employee database in Figure 1 as an example. <p> In that case, the query is formulated as a string interpreted at run-time. This is the case of the current version of the ODMG C++ binding <ref> [4] </ref>.
Reference: [5] <author> D. J. DeWitt. </author> <title> DBMS Roadkill on the Information Superhighway. Invited talk at VLDB'95, </title> <year> 1995. </year>
Reference-contexts: Application areas suitable for OODB, like those discussed in the previous section, should justify the importance. 2. The advantages of storing and processing data in databases instead of files has not been recognized in all applications areas where it is appropriate <ref> [5] </ref>. The focus in scientific computing has been on doing computations with files as inputs. Especially with complex file formats as, e.g., the HDF file format 2 , computations and maintenance is not trivial. It is also worth noting that important projects, as e.g. <p> with query languages already support some aggregate functions, like sum and average, but with new application areas, with very different needs, it is important to have the possibility 2 HDF is a file format for storing and transmitting scientific data sets, and a library interface for working with the data <ref> [5] </ref>. 3 Earth Observing System Data Information System of adding new functions. Examples are statistical functions in statistical and scientific databases, spatial functions as area and perimeter in GIS/spatial databases, and special time-related functions in temporal databases.
Reference: [6] <author> D. J. DeWitt, S. Ghandeharizadeh, D. Schneider, A. Bricker, H.-I. Hsiao, and R. Rasmussen. </author> <title> The gamma database machine project. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <year> 1990. </year>
Reference-contexts: This is important to get high performance. 4 Query Processing Operator It is useful to explain (and implement) aggregation and other operations as language-independent operators. This is also the way it is done in systems as Gamma <ref> [6] </ref> and Volcano [8]. A stream of objects flows through a tree of operators. An "object" can be either a materialized object, or the object identifier. In OODBs it should be is possible to operate on methods, in the same way as on attributes. <p> Redistribution with Local Aggregation In the parallel aggregation by redistribution algorithm, more data than necessary is moved. With large groups (many objects in each group), we can gain much by doing local aggregation before redistribution [3]. This is the way aggregation with grouping is done in e.g. Gamma <ref> [6] </ref>. In the first phase, all nodes do local aggregation on data residing on the node, just as in the local aggregation/central coordinator algorithm. In the second phase, the result is distributed according to a hashing function applied on the value of the result of the grouping methods.
Reference: [7] <author> G. Graefe. </author> <title> Query Evaluation Techniques for Large Databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2), </volume> <year> 1993. </year>
Reference-contexts: Whether to do local aggregation or not depends on data selectivity and communication bandwidth. As suggested by [16], sampling of data should be used to decide if local aggregation should be done before redistribution. 5 Sort-aggregate is the algorithm used in most existing commercial relational systems <ref> [7] </ref>. One reason for this, is that quite often, traditional applications want a sorted result from the aggregation (ORDER BY in SQL). In a typical OODB application, this will probably not be the case. 7 High-Performance Aggregation The performance of evaluation of aggregate functions can be improved in several ways.
Reference: [8] <author> G. Graefe. </author> <title> Volcano | An Extensible and Parallel Query Evaluation System. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 6(1), </volume> <year> 1994. </year>
Reference-contexts: This is important to get high performance. 4 Query Processing Operator It is useful to explain (and implement) aggregation and other operations as language-independent operators. This is also the way it is done in systems as Gamma [6] and Volcano <ref> [8] </ref>. A stream of objects flows through a tree of operators. An "object" can be either a materialized object, or the object identifier. In OODBs it should be is possible to operate on methods, in the same way as on attributes.
Reference: [9] <author> A. Gupta, V. Harinarayan, and D. Quass. </author> <title> Generalized Projections: A Powerful Approach To Aggregation. </title> <type> Technical report, </type> <institution> Stanford, </institution> <year> 1994. </year>
Reference-contexts: The fundamentals are the same, and many results valid for relational databases applies to OODB as well. Valuable sources for aggregate function evaluation are Bitton et.al. [1], Bratbergsengen [3] and Shatdal et.al. [16]. Only recently has the grouping functions been the focus for query optimization <ref> [23, 9, 10] </ref>. 3 Aggregate and Grouping Functions Aggregation is basically partitioning a set of objects into groups, and evaluate one or several aggregate functions over the objects in the groups. The result is one set of values (from the aggregate functions) for each group. <p> It is possible to take advantage of this by either having precomputed the query for part of the database, and/or use stored results from earlier queries. These techniques are quite similar to techniques used for view maintenance/materialized views in data warehousing <ref> [21, 9, 10] </ref>.
Reference: [10] <author> A. Gupta, V. Harinarayan, and D. Quass. </author> <title> Aggregate-Query Processing in Data Warehousing Environments. </title> <booktitle> In Proceedings of the 21st International Conference on Very Large Data Bases, </booktitle> <year> 1995. </year>
Reference-contexts: The fundamentals are the same, and many results valid for relational databases applies to OODB as well. Valuable sources for aggregate function evaluation are Bitton et.al. [1], Bratbergsengen [3] and Shatdal et.al. [16]. Only recently has the grouping functions been the focus for query optimization <ref> [23, 9, 10] </ref>. 3 Aggregate and Grouping Functions Aggregation is basically partitioning a set of objects into groups, and evaluate one or several aggregate functions over the objects in the groups. The result is one set of values (from the aggregate functions) for each group. <p> It is possible to take advantage of this by either having precomputed the query for part of the database, and/or use stored results from earlier queries. These techniques are quite similar to techniques used for view maintenance/materialized views in data warehousing <ref> [21, 9, 10] </ref>.
Reference: [11] <author> K.-C. Kim. </author> <title> Parallelism in Object-Oriented Query Processing. </title> <booktitle> In IEEE Sixth International Conference on Data Engineering, </booktitle> <year> 1990. </year>
Reference-contexts: If the input stream is not sorted initially, which is common in an OODB 5 , it is better to use a partition-aggregate algorithm. With un-sorted input, partition-aggregate will always perform better than sort-aggregate [2]. 6.4 Parallel Aggregation In general, it is difficult to parallelize navigational queries in OODB <ref> [11] </ref>. Set processing, on the other hand, lends itself to parallelizing. With parallel machines, distribution of work between nodes can improve performance.
Reference: [12] <author> N. Kline and R. T. Snodgrass. </author> <title> Computing Temporal Aggregates. </title> <booktitle> In Proceedings of IEEE 11th Int'l Conference on Data Engineering, </booktitle> <month> March, </month> <year> 1995, 1995. </year>
Reference-contexts: The best alternative might be to provide new aggregate operators that work on non-set-like structures. Temporal Aggregates Conventional aggregate algorithms are not efficient when applied to temporal databases. Algorithms for computing temporal aggregates are presented by Kline and Snodgrass in <ref> [12] </ref>. As far as we know, no one has published work on parallel algorithms for temporal aggregation, or algorithms for temporal aggregation in OODBs. Temporal databases can be viewed as a subclass of multidimensional databases, and algorithms similar to aggregation on spatial data structures can be employed.
Reference: [13] <author> D. Lieuwen, D. DeWitt, and M. Mehta. </author> <title> Pointer-based Join Techniques for Object-Oriented Databases. </title> <type> Technical Report CS-TR-92-1099, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1992. </year>
Reference-contexts: The object has to be re-read from disk, which is inefficient. Therefore, we want to control these accesses. This can be done by employing available techniques for functional join. Several algorithms and techniques are described by Shekita et.al. in [19, 18, 17], and Lieuwen et. al. in <ref> [14, 13] </ref>. (a) (b) 6.2 The Structure of Aggregate and Result Objects During aggregation, a new aggregate object is created for each group (see Figure 2a). The aggregate objects will belong to a class with the following attributes: 1.
Reference: [14] <author> D. Lieuwen, D. DeWitt, and M. Mehta. </author> <title> Parallel Pointer-based Join Techniques for Object-Oriented Databases. </title> <booktitle> In Proc. 2nd International Conference on Parallel and Distributed Information Systems, </booktitle> <year> 1993. </year>
Reference-contexts: The object has to be re-read from disk, which is inefficient. Therefore, we want to control these accesses. This can be done by employing available techniques for functional join. Several algorithms and techniques are described by Shekita et.al. in [19, 18, 17], and Lieuwen et. al. in <ref> [14, 13] </ref>. (a) (b) 6.2 The Structure of Aggregate and Result Objects During aggregation, a new aggregate object is created for each group (see Figure 2a). The aggregate objects will belong to a class with the following attributes: 1.
Reference: [15] <author> D. Maier and D. M. Hansen. </author> <title> Bambi Meets Godzilla: Object Databases for Scientific Computing. </title> <booktitle> In Seventh International Working Conference on Scientific and Statistical Database Management. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: Temporal databases can be viewed as a subclass of multidimensional databases, and algorithms similar to aggregation on spatial data structures can be employed. Combining Bulk Loading and Aggregation Bulk loading is loading a large external dataset during a single sitting <ref> [15] </ref>. If it is known at load time what kind of aggregate functions that will be employed later on the data set, it is possible to do aggregation while loading.
Reference: [16] <author> A. Shatdal and J. F. Naughton. </author> <title> Adaptive Parallel Aggregation Algorithms. </title> <booktitle> In Proceedings of the 1995 ACM SIGMOD, </booktitle> <pages> pages 104-114. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: The most important work is, of course, research done on aggregate function evaluation in relational databases. The fundamentals are the same, and many results valid for relational databases applies to OODB as well. Valuable sources for aggregate function evaluation are Bitton et.al. [1], Bratbergsengen [3] and Shatdal et.al. <ref> [16] </ref>. Only recently has the grouping functions been the focus for query optimization [23, 9, 10]. 3 Aggregate and Grouping Functions Aggregation is basically partitioning a set of objects into groups, and evaluate one or several aggregate functions over the objects in the groups. <p> Several implementations have shown that with high-bandwidth communication between nodes, the local aggregation is not necessarily beneficial. Whether to do local aggregation or not depends on data selectivity and communication bandwidth. As suggested by <ref> [16] </ref>, sampling of data should be used to decide if local aggregation should be done before redistribution. 5 Sort-aggregate is the algorithm used in most existing commercial relational systems [7].
Reference: [17] <author> E. Shekita. </author> <title> High-Performance Implementation Techniques for Next-Generation Database Systems. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1991. </year>
Reference-contexts: The object has to be re-read from disk, which is inefficient. Therefore, we want to control these accesses. This can be done by employing available techniques for functional join. Several algorithms and techniques are described by Shekita et.al. in <ref> [19, 18, 17] </ref>, and Lieuwen et. al. in [14, 13]. (a) (b) 6.2 The Structure of Aggregate and Result Objects During aggregation, a new aggregate object is created for each group (see Figure 2a). The aggregate objects will belong to a class with the following attributes: 1.
Reference: [18] <author> E. J. Shekita and M. J. Carey. </author> <title> Performance Enhancement Through Replication in an Object-Oriented DBMS. </title> <booktitle> In Proceedings of the 1989 ACM SIGMOD, </booktitle> <year> 1989. </year>
Reference-contexts: The object has to be re-read from disk, which is inefficient. Therefore, we want to control these accesses. This can be done by employing available techniques for functional join. Several algorithms and techniques are described by Shekita et.al. in <ref> [19, 18, 17] </ref>, and Lieuwen et. al. in [14, 13]. (a) (b) 6.2 The Structure of Aggregate and Result Objects During aggregation, a new aggregate object is created for each group (see Figure 2a). The aggregate objects will belong to a class with the following attributes: 1.
Reference: [19] <author> E. J. Shekita and M. J. Carey. </author> <title> A Performance Evaluation of Pointer-Based Joins. </title> <type> Technical Report 916, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1990. </year>
Reference-contexts: The object has to be re-read from disk, which is inefficient. Therefore, we want to control these accesses. This can be done by employing available techniques for functional join. Several algorithms and techniques are described by Shekita et.al. in <ref> [19, 18, 17] </ref>, and Lieuwen et. al. in [14, 13]. (a) (b) 6.2 The Structure of Aggregate and Result Objects During aggregation, a new aggregate object is created for each group (see Figure 2a). The aggregate objects will belong to a class with the following attributes: 1.
Reference: [20] <author> J. Srivastava and V. Y. Lum. </author> <title> A Tree Based Access Method (TBSAM) for Fast Processing of Aggregate Queries. </title> <booktitle> In IEEE Fourth International Conference on Data Engineering, </booktitle> <year> 1988. </year>
Reference-contexts: Another approach is to have the system maintain an index to the data with statistical summary data. 6 By using a structure which makes it easy to exploit the summary data (a tree is used in the tree based access method proposed by Srivastava and Lum <ref> [20] </ref>), performance can be greatly enhanced if the data are heavily used. Resumable Aggregation In large databases, queries involving aggregation can be a very time consuming. It is desirable that a crash during aggregation does not mean that all the work is wasted.
Reference: [21] <author> J. Widom. </author> <title> Research Problems in Data Warehousing. </title> <booktitle> In Proceedings of the 4th Int'l Conference on Information and Knowledge Management (CIKM), </booktitle> <month> November </month> <year> 1995, 1995. </year>
Reference-contexts: It is possible to take advantage of this by either having precomputed the query for part of the database, and/or use stored results from earlier queries. These techniques are quite similar to techniques used for view maintenance/materialized views in data warehousing <ref> [21, 9, 10] </ref>.
Reference: [22] <author> J. L. Wiener. </author> <title> Algorithms for Loading Object Databases. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1995. </year>
Reference-contexts: Combining bulk loading algorithms with aggregation will probably be beneficial, especially in databases where summary data can be exploited (e.g. in statistical and scientific databases). As a starting point, the bulk loading algorithms developed by J. Wiener <ref> [22] </ref> can be used. But, no good algorithms for parallel loading has yet been developed. This problem has to be solved, as a single-threaded algorithm will be a potential performance bottleneck. Precomputed Results In many of the proposed application areas for aggregate evaluation, much of the data will be static.
Reference: [23] <author> W. Yan and P. A. Larson. </author> <title> Eager Aggregation and Lazy Aggregation. </title> <booktitle> In Proceedings of the 21st International Conference on Very Large Data Bases, </booktitle> <year> 1995. </year>
Reference-contexts: The fundamentals are the same, and many results valid for relational databases applies to OODB as well. Valuable sources for aggregate function evaluation are Bitton et.al. [1], Bratbergsengen [3] and Shatdal et.al. [16]. Only recently has the grouping functions been the focus for query optimization <ref> [23, 9, 10] </ref>. 3 Aggregate and Grouping Functions Aggregation is basically partitioning a set of objects into groups, and evaluate one or several aggregate functions over the objects in the groups. The result is one set of values (from the aggregate functions) for each group.
Reference: [24] <author> A. Yu and J. Chen. </author> <title> The POSTGRES95 User Manual, </title> <year> 1995. </year>
Reference-contexts: Examples are statistical functions in statistical and scientific databases, spatial functions as area and perimeter in GIS/spatial databases, and special time-related functions in temporal databases. It is useful to think of aggregate functions as state transition functions, which in e.g. POST-GRES <ref> [24] </ref> is done explicit by the use of the CREATE AGGREGATE construction. The difference between an aggregate function and an ordinary function is that an initial state has to exist.
References-found: 24

