URL: http://www.cse.ogi.edu/~sherri/BruceParadigmatic.ps
Refering-URL: http://www.cse.ogi.edu/~sherri/Aritcles.html
Root-URL: http://www.cse.ogi.edu
Email: kim@cs.williams.edu  
Title: A Paradigmatic Object-Oriented Programming Language: Design, Static Typing and Semanticsy inheritance and subtyping hierarchy in
Author: Kim B. Bruce Williams 
Address: Williamstown, MA, USA 01267  
Affiliation: College  
Date: 1 (1): 1-000, January 1993  
Note: J. Functional Programming  c 1993 Cambridge University Press 1  the  Symposium on the Principles of Programming Languages.  
Abstract: In order to illuminate the fundamental concepts involved in object-oriented programming languages, we describe the design of TOOPL, a paradigmatic, statically-typed, functional, object-oriented programming language which supports classes, objects, methods, hidden It has proven to be quite difficult to design such a language which has a secure type system. A particular problem with statically type checking object-oriented languages is designing type-checking rules which ensure that methods provided in a superclass will continue to be type correct when inherited in a subclass. The type-checking rules for TOOPL have this feature, enabling library suppliers to provide only the interfaces of classes with actual executable code, while still allowing users to safely create subclasses. In order to achieve greater expressibility while retaining type-safety, we choose to separate While the semantics of our language is rather complex, involving fixed points at both the element and type level, we believe that this reflects the inherent complexity of the basic features of object-oriented programming languages. Particularly complex features include the implicit recursion inherent in the use of the keyword, self, to refer to the current object, and its corresponding type, MyType. The notions of subclass and inheritance introduce the greatest semantic complexities, whereas the notion of subtype is more straightforward to deal with. Our semantic investigations lead us to recommend caution in the use of inheritance, since small changes to method definitions in subclasses can result in major changes to the meanings of the other methods of the class. y An extended abstract of this paper appeared in the Proceedings of the 20th ACM instance variables, subtypes, and inheritance.
Abstract-found: 1
Intro-found: 1
Reference: <author> M Abadi. </author> <title> Doing without F-bounded quantification. Message to Types electronic mail list, </title> <note> February, 1992. </note> <author> 78 Kim B. Bruce Martin Abadi. </author> <title> Baby modula-3 and a theory of objects. </title> <journal> Journal of functional programming, </journal> <note> to appear, </note> <year> 1994. </year>
Reference-contexts: Thus I started with the denotational model of bounded higher-order lambda calculus given in <ref> (Bruce and Mitchell, 1992) </ref>, and began to integrate the semantics of subtyping given in (Bruce and Longo, 1990) with the semantics of inheritance, as explained in (Bruce, 1992) (which itself was based on the work of (Mitchell, 1990a) and (Cook et al., 1990)). <p> This system-wide type checking essentially performs a data flow analysis of the program in order to ensure that only type-safe message sends are performed (see <ref> (Meyer, 1992) </ref> for more details). We consider this solution unsatisfactory since the addition of a new class to a system may result in link-time type errors which would not be predictable from looking at the interface of the previous classes or the code of the new class. <p> In this way, one may show that the meanings of terms depend on only the "erasure" of the term (the term obtained by erasing all type information) and its type. The model given in <ref> (Bruce and Mitchell, 1992) </ref>, which has been cited earlier as a model containing all necessary fixed points for our semantics, is a PER model. Thus, once a term and one of its types has been given, we can determine its meaning independently of the type derivation. <p> The reason for this is that the semantics of the language is given in terms of a model of the F-bounded higher-order lambda calculus with contains elements corresponding to recursive terms, types, and type constructors. (We only used the second-order parts of the model above, but the model in <ref> (Bruce and Mitchell, 1992) </ref> includes higher-order elements as well.) As a result, we can add both recursion and (higher-order) F-bounded polymorphism with few semantic problems. Interestingly, the language presented already supports an indirect form of recursion in objects because of the (implicitly) recursive meaning of self. <p> Later work by (Amadio, 1991) and (Cardone, 1989) provided models supporting subtypes and recursively defined elements and types. (Abadi and Plotkin, 1990) provided a more category-theoretic construction which also resulted in types which are CPO's. Recently, <ref> (Bruce and Mitchell, 1992) </ref> strengthened these constructions 74 Kim B. Bruce to ones which provide the existence of higher-order recursive type constructors as well as supporting higher-order F-bounded quantification. These last models are rich enough to support all constructs described in this paper. <p> The undecidability of type checking F results from the undecidability of determining if one type is a subtype of another. In contrast, <ref> (Dimock and Muller, 1992) </ref> have recently shown that the subtype problem is decidable for TOOPL. Kozen et al. (1993), have shown that subtyping for a similar language which also adds a rule to "unwind" recursively defined types has an O (n 2 ) algorithm.
Reference: <author> M Abadi and G.D. Plotkin. </author> <title> A PER model of polymorphism and recursive types. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <pages> pages 355-365. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: This is similar to the way that one shows that two mutually recursive functions satisfy their specifications. That is, show the first is correct under the assumption that the second is correct and vice-versa. The solution presented here is based on the criteria presented in <ref> (Amadio and Cardelli, 1990) </ref> for determining when two recursively defined types are subtypes. As indicated above, the place where our example with points breaks down is with the eq method. <p> Some languages, such as C++ (Stroustrop, 1986), make no pretense to being type safe. The designers of the language Beta originally seemed to be interested in designing a type-safe language, but have recently argued that they don't care if the language is completely type safe <ref> (Madsen et al., 1990) </ref>. In fact, we argue below that fundamental decisions (especially the decision to identify subclasses and subtypes) made by some of the language designers would make it extremely difficult to create a language as expressive as desired, and still have a safe type system. <p> The only difficult part of the induction is that corresponding to the subtyping rule for object types. Since object types denote fixed points, the desired result follows from a theorem of <ref> (Amadio and Cardelli, 1990) </ref>, which states that our subtyping rule for recursive types is sound. For part 2, the soundness of the (Var ()) axiom follows from the definition of consistency of an environment given above. <p> Even more serious, if the new method name does occur in the current class, its type is not known, so it is impossible to tell if the update is legal or not. The more complex record calculus presented in <ref> (Cardelli and Mitchell, 1990) </ref> may help solve this problem, as it provides both positive and negative information on the presence of particular methods. It was decided not to move to such a system here since the added complexities seem to outweigh the benefits. <p> As noted in (Bruce and Longo, 1990) and <ref> (Cardelli and Mitchell, 1990) </ref>, an update operator is not definable in the standard presentation of bounded second-order lambda calculus. Our restrictions on subclasses, while adding some complexity to the type-checking rules, allow us to overcome this limitation.
Reference: <author> R.M. Amadio. </author> <title> Recursion over realizability structures. </title> <journal> Information and Computation, </journal> <volume> 91(1) </volume> <pages> 55-86, </pages> <year> 1991. </year>
Reference-contexts: Later work by <ref> (Amadio, 1991) </ref> and (Cardone, 1989) provided models supporting subtypes and recursively defined elements and types. (Abadi and Plotkin, 1990) provided a more category-theoretic construction which also resulted in types which are CPO's. Recently, (Bruce and Mitchell, 1992) strengthened these constructions 74 Kim B.
Reference: <author> Roberto Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <type> Technical Report 62, </type> <institution> Digital Systems Research Center, </institution> <year> 1990. </year>
Reference: <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Jean Bezivin et al., editor, </editor> <booktitle> ECOOP '87, </booktitle> <pages> pages 234-242. </pages> <publisher> Springer-Verlag, LNCS 276, </publisher> <year> 1987. </year>
Reference: <author> Pierre America, J. de Bakker, J. Kok, and J. Rutten. </author> <title> Operational semantics of a parallel object-oriented language. </title> <booktitle> In Proc 13th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 194-208, </pages> <year> 1986. </year>
Reference: <author> Pierre America, J. de Bakker, J. Kok, and J. Rutten. </author> <title> Denotational semantics of a parallel object-oriented language. </title> <journal> Information and Computation, </journal> <volume> 83(2) </volume> <pages> 152-205, </pages> <year> 1989. </year>
Reference: <author> Pierre America and Frank van der Linden. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In OOPSLA-ECOOP '90 Proceedings, </booktitle> <pages> pages 161-168. </pages> <booktitle> ACM SIGPLAN Notices,25(10), </booktitle> <month> October </month> <year> 1990. </year>
Reference: <author> G.M. Birtwistle, O.-J. Dahl, B. Myhrhaug, and K. Nygaard. </author> <title> SIMULA Begin. </title> <type> Aurbach, </type> <year> 1973. </year>
Reference-contexts: There are now several object-oriented languages which are being used to produce commercial software. These include Simula <ref> (Birtwistle et al., 1973) </ref>, Smalltalk (Goldberg and Robson, 1983), Eiffel (Meyer, 1988), and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ (Stroustrop, 1986), Oberon (Wirth, 1988), Modula 3 (Cardelli et al., 1988), Object Pascal (Tesler, 1985), and various extensions of LISP ((Moon, 1986),
Reference: <author> Andrew Black. </author> <title> Private communication, </title> <year> 1992. </year>
Reference: <author> A. Black and N. Hutchinson. </author> <title> Typechecking polymorphism in Emerald. </title> <type> Technical Report CRL 91/1 (Revised), </type> <institution> DEC Cambridge Research Lab, </institution> <year> 1991. </year>
Reference-contexts: The language Emerald (Black et al., 1986) is an object-oriented language designed for distributed systems which has types and subtypes, but no classes or inheritance. It includes type parameters and introduces a notion similar to F-bounded quantification to check the applicability of operations to types. <ref> (Black and Hutchinson, 1991) </ref> includes a careful discussion of its type system, including proofs that the dynamic type of an object always "conforms to" its static type, thereby ensuring the absence of "message not understood" error messages. (Hense, 1991; Hense, 1990) present both a language design and semantics for an untyped
Reference: <author> A. Black, N. Hutchinson, E. Jul, and H. Levy. </author> <title> Object structure in the Emerald system. </title> <booktitle> In Proc. ACM Symp. on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pages 78-86, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: This work, like that described in this paper, separates the subclass and subtype hierarchies and also introduces keywords, "self " and "M yT ype," like those described here. No denotational semantics or soundness results are given there. The language Emerald <ref> (Black et al., 1986) </ref> is an object-oriented language designed for distributed systems which has types and subtypes, but no classes or inheritance.
Reference: <author> V. Breazu-Tannen, T. Coquand, C.A. Gunter, and A. Scedrov. </author> <title> Inheritance and explicit coercion. </title> <booktitle> In Fourth IEEE Symp. Logic in Computer Science, </booktitle> <pages> pages 112-129, </pages> <year> 1989. </year>
Reference: <author> V. Breazu-Tannen, T. Coquand, C.A. Gunter, and A. Scedrov. </author> <title> Inheritance and implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference: <author> K. Bruce. </author> <title> The equivalence of two semantic definitions of inheritance in object-oriented languages. </title> <editor> In S. Brookes, M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, </editor> <booktitle> Proceedings of the 7th International Conference on Mathematical Foundations of Programming Semantics, </booktitle> <pages> pages 102-124. </pages> <publisher> LNCS 598, Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Thus I started with the denotational model of bounded higher-order lambda calculus given in <ref> (Bruce and Mitchell, 1992) </ref>, and began to integrate the semantics of subtyping given in (Bruce and Longo, 1990) with the semantics of inheritance, as explained in (Bruce, 1992) (which itself was based on the work of (Mitchell, 1990a) and (Cook et al., 1990)). <p> Thus I started with the denotational model of bounded higher-order lambda calculus given in (Bruce and Mitchell, 1992), and began to integrate the semantics of subtyping given in (Bruce and Longo, 1990) with the semantics of inheritance, as explained in <ref> (Bruce, 1992) </ref> (which itself was based on the work of (Mitchell, 1990a) and (Cook et al., 1990)). While the language described in this paper does not appear to be closely related to the bounded higher-order lambda calculus, the semantics are given with respect to a model of this language. <p> The product over ~ such that ~ A [[t ]][~=MyType] is an example of a type defined by "F-bounded quantification", since the upper bound of ~ is a term involving ~. This technique is used in (Cook et al., 1990) and <ref> (Bruce, 1992) </ref>, and was originally proposed in (Canning et al., 1989). <p> In this way, one may show that the meanings of terms depend on only the "erasure" of the term (the term obtained by erasing all type information) and its type. The model given in <ref> (Bruce and Mitchell, 1992) </ref>, which has been cited earlier as a model containing all necessary fixed points for our semantics, is a PER model. Thus, once a term and one of its types has been given, we can determine its meaning independently of the type derivation. <p> The reason for this is that the semantics of the language is given in terms of a model of the F-bounded higher-order lambda calculus with contains elements corresponding to recursive terms, types, and type constructors. (We only used the second-order parts of the model above, but the model in <ref> (Bruce and Mitchell, 1992) </ref> includes higher-order elements as well.) As a result, we can add both recursion and (higher-order) F-bounded polymorphism with few semantic problems. Interestingly, the language presented already supports an indirect form of recursion in objects because of the (implicitly) recursive meaning of self. <p> Mitchell (1990a) proposed an alternative, more operational, semantics for typed object-oriented languages, which was shown to be equivalent to that of (Cook et al., 1990) in <ref> (Bruce, 1992) </ref>. (Cardelli and Wegner, 1985), following earlier work in (Mitchell, 1988) (originally published as (Mitchell, 1984)), introduced the notion of bounded quantification in higher-order languages, which was extended in (Canning et al., 1989) to handle the more general "F-bounded" quantification used here in the semantics of class definitions. (Bruce and <p> Later work by (Amadio, 1991) and (Cardone, 1989) provided models supporting subtypes and recursively defined elements and types. (Abadi and Plotkin, 1990) provided a more category-theoretic construction which also resulted in types which are CPO's. Recently, <ref> (Bruce and Mitchell, 1992) </ref> strengthened these constructions 74 Kim B. Bruce to ones which provide the existence of higher-order recursive type constructors as well as supporting higher-order F-bounded quantification. These last models are rich enough to support all constructs described in this paper.
Reference: <author> K. Bruce, J. Crabtree, A. Dimock, R. Muller, T. Murtagh, and R. van Gent. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In Proc. ACM Symp. on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pages 29-46, </pages> <year> 1993. </year>
Reference-contexts: Nevertheless, it seemed wise at this point to take a somewhat more conservative approach. Moreover, we perform type checking directly in TOOPL, not in higher-order terms into which it might be translated. In fact, with others (see <ref> (Bruce et al., 1993) </ref>), we have recently shown that if we modify TOOPL by insisting that the programmer provide a small amount of extra type information for class expressions, the type checking problem for TOOPL is decidable. <p> That is, if a term M "reduces to" (i.e., computes) an irreducible value, v, then v can be assigned the same type as M . This is sometimes known as a subject-reduction theorem. In <ref> (Bruce et al., 1993) </ref> we provide an operational semantics for SOOPL, show this operational semantics is consistent with the denotational semantics given here, and prove such a subject-reduction theorem. This provides an alternative proof to Theorem 4.4 for the safety of the typing system. <p> Such a proof for the bounded second-order lambda calculus was given by (Curien and Ghelli, 1992) and is used in (Bruce and Longo, 1990). (An earlier, somewhat different syntactic proof appeared in (Breazu-Tannen et al., 1991)). In <ref> (Bruce et al., 1993) </ref>, we show that in a slight variant of SOOPL, every typable term has a minimum type. <p> From this an algorithm can be derived which solves the type-checking problem for TOOPLE. Thus this language has useful practical as well as theoretical properties. A description of the subtyping and type-checking algorithms can be found in <ref> (Bruce et al., 1993) </ref>. A natural (operational) semantics for TOOPLE is given in (Bruce et al., 1993). This semantics is somewhat easier to understand since it does not rely on the complex fixed points used here. <p> Thus this language has useful practical as well as theoretical properties. A description of the subtyping and type-checking algorithms can be found in <ref> (Bruce et al., 1993) </ref>. A natural (operational) semantics for TOOPLE is given in (Bruce et al., 1993). This semantics is somewhat easier to understand since it does not rely on the complex fixed points used here.
Reference: <author> K. Bruce, J. Crabtree, and G. Kanapathy. </author> <title> An operational semantics for TOOPLE: A statically-typed object-oriented programming language. </title> <note> To appear in Proceedings of MFPS IX, </note> <year> 1993. </year>
Reference-contexts: Nevertheless, it seemed wise at this point to take a somewhat more conservative approach. Moreover, we perform type checking directly in TOOPL, not in higher-order terms into which it might be translated. In fact, with others (see <ref> (Bruce et al., 1993) </ref>), we have recently shown that if we modify TOOPL by insisting that the programmer provide a small amount of extra type information for class expressions, the type checking problem for TOOPL is decidable. <p> That is, if a term M "reduces to" (i.e., computes) an irreducible value, v, then v can be assigned the same type as M . This is sometimes known as a subject-reduction theorem. In <ref> (Bruce et al., 1993) </ref> we provide an operational semantics for SOOPL, show this operational semantics is consistent with the denotational semantics given here, and prove such a subject-reduction theorem. This provides an alternative proof to Theorem 4.4 for the safety of the typing system. <p> Such a proof for the bounded second-order lambda calculus was given by (Curien and Ghelli, 1992) and is used in (Bruce and Longo, 1990). (An earlier, somewhat different syntactic proof appeared in (Breazu-Tannen et al., 1991)). In <ref> (Bruce et al., 1993) </ref>, we show that in a slight variant of SOOPL, every typable term has a minimum type. <p> From this an algorithm can be derived which solves the type-checking problem for TOOPLE. Thus this language has useful practical as well as theoretical properties. A description of the subtyping and type-checking algorithms can be found in <ref> (Bruce et al., 1993) </ref>. A natural (operational) semantics for TOOPLE is given in (Bruce et al., 1993). This semantics is somewhat easier to understand since it does not rely on the complex fixed points used here. <p> Thus this language has useful practical as well as theoretical properties. A description of the subtyping and type-checking algorithms can be found in <ref> (Bruce et al., 1993) </ref>. A natural (operational) semantics for TOOPLE is given in (Bruce et al., 1993). This semantics is somewhat easier to understand since it does not rely on the complex fixed points used here.
Reference: <author> K. Bruce and G. Longo. </author> <title> A modest model of records, inheritance and bounded quantification. </title> <booktitle> In Third IEEE Symp. Logic in Computer Science, </booktitle> <pages> pages 38-51, </pages> <year> 1988. </year>
Reference-contexts: (Mitchell, 1988) (originally published as (Mitchell, 1984)), introduced the notion of bounded quantification in higher-order languages, which was extended in (Canning et al., 1989) to handle the more general "F-bounded" quantification used here in the semantics of class definitions. (Bruce and Longo, 1990) (an early version of which appeared as <ref> (Bruce and Longo, 1988) </ref>) provided the first careful formal semantics of subtyping (using PER models) in this language.
Reference: <author> K. Bruce and G. Longo. </author> <title> A modest model of records, inheritance and bounded quantification. </title> <journal> Information and Computation, </journal> 87(1/2):196-240, 1990. 
Reference-contexts: An important place where the limitations of F show up is in its inability to express polymorphic record updates in the presence of subtyping (see the discussion in Section 6 of <ref> (Bruce and Longo, 1990) </ref>). <p> Thus I started with the denotational model of bounded higher-order lambda calculus given in (Bruce and Mitchell, 1992), and began to integrate the semantics of subtyping given in <ref> (Bruce and Longo, 1990) </ref> with the semantics of inheritance, as explained in (Bruce, 1992) (which itself was based on the work of (Mitchell, 1990a) and (Cook et al., 1990)). <p> For simplicity, we will assume that A !t = A ! A t and that A Bool = ftrue; f alse; ?g. It is straightforward to replace this by the more complex (but more flexible) definition given in <ref> (Bruce et al., 1990) </ref> and (Bruce and Longo, 1990) in case these two assumptions do not hold. In the following, Q i2S T i denotes the set of all functions, f , with domain, S, such that for all i 2 S, f (i) 2 T i . <p> For simplicity, we will assume that A !t = A ! A t and that A Bool = ftrue; f alse; ?g. It is straightforward to replace this by the more complex (but more flexible) definition given in (Bruce et al., 1990) and <ref> (Bruce and Longo, 1990) </ref> in case these two assumptions do not hold. In the following, Q i2S T i denotes the set of all functions, f , with domain, S, such that for all i 2 S, f (i) 2 T i . <p> In terms of type-checking, this implies that any value of the first type can be treated as a value of the second type. This is made explicit, for example, in <ref> (Bruce and Longo, 1990) </ref> and (Breazu-Tannen et al., 1991) by requiring the existence of a well-behaved "coercion" function which takes values of the first type to the second. <p> It will not be necessary to define what a "well-behaved coercion function" is here, as we will simply use this notion to argue for the intuitive correctness of our subtyping rules. See <ref> (Bruce and Longo, 1990) </ref> or (Breazu-Tannen et al., 1991) for details on these coercion functions. The subtype relation between types is reflexive and transitive. If is a subtype of t , we say that t is a supertype of . <p> This coercion function was described informally in section 4.1.1, and may be understood as a sort of homomorphism that preserves behavior. A set of axioms and rules governing the behavior of convert can be found in <ref> (Bruce and Longo, 1990) </ref>. The subsumption rule in the previous section stated that if C; E ` M : t and C ` t , then C; E ` M : . <p> Bruce that a given term can have two different derivations of the same type. How do we know then that the resulting meanings are the same? One can deal with this problem either semantically or syntactically. In PER models of the bounded second-order lambda calculus (see <ref> (Bruce and Longo, 1990) </ref>), the meanings of terms may be obtained from the meanings of an underlying untyped model. In this way, one may show that the meanings of terms depend on only the "erasure" of the term (the term obtained by erasing all type information) and its type. <p> Such a proof for the bounded second-order lambda calculus was given by (Curien and Ghelli, 1992) and is used in <ref> (Bruce and Longo, 1990) </ref>. (An earlier, somewhat different syntactic proof appeared in (Breazu-Tannen et al., 1991)). In (Bruce et al., 1993), we show that in a slight variant of SOOPL, every typable term has a minimum type. <p> We could also add unbounded polymorphism to the language without problem. The semantics of this extension is analogous to that for ordinary function abstraction and application and contains no surprises (after all, our underlying model supports exactly these features). More details can be found in <ref> (Bruce and Longo, 1990) </ref>. In Section 5 we discussed how to implement a language design that hid instance Paradigmatic Object-Oriented Programming Language 67 variables outside of an object, and, conversely, how one could make these hidden instance variables accessible by adding methods to access and update their values. <p> Because of the existence of an operator to update instance variables (actually the operator creates a new copy of the object with a different value for the instance variable), we could not allow the types of instance variables to be changed in subclasses. As noted in <ref> (Bruce and Longo, 1990) </ref> and (Cardelli and Mitchell, 1990), an update operator is not definable in the standard presentation of bounded second-order lambda calculus. Our restrictions on subclasses, while adding some complexity to the type-checking rules, allow us to overcome this limitation. <p> in (Bruce, 1992). (Cardelli and Wegner, 1985), following earlier work in (Mitchell, 1988) (originally published as (Mitchell, 1984)), introduced the notion of bounded quantification in higher-order languages, which was extended in (Canning et al., 1989) to handle the more general "F-bounded" quantification used here in the semantics of class definitions. <ref> (Bruce and Longo, 1990) </ref> (an early version of which appeared as (Bruce and Longo, 1988)) provided the first careful formal semantics of subtyping (using PER models) in this language.
Reference: <author> K. B. Bruce, A. R. Meyer, and J. C. Mitchell. </author> <title> The semantics of second-order lambda calculus. </title> <journal> Information and Computation, </journal> <volume> 85(1) </volume> <pages> 76-134, </pages> <year> 1990. </year> <title> Reprinted in Logical Foundations of Functional Programming, </title> <editor> ed. G. Huet, </editor> <publisher> Addison-Wesley (1990) 213-273. </publisher>
Reference-contexts: An important place where the limitations of F show up is in its inability to express polymorphic record updates in the presence of subtyping (see the discussion in Section 6 of <ref> (Bruce and Longo, 1990) </ref>). <p> Thus I started with the denotational model of bounded higher-order lambda calculus given in (Bruce and Mitchell, 1992), and began to integrate the semantics of subtyping given in <ref> (Bruce and Longo, 1990) </ref> with the semantics of inheritance, as explained in (Bruce, 1992) (which itself was based on the work of (Mitchell, 1990a) and (Cook et al., 1990)). <p> For simplicity, we will assume that A !t = A ! A t and that A Bool = ftrue; f alse; ?g. It is straightforward to replace this by the more complex (but more flexible) definition given in <ref> (Bruce et al., 1990) </ref> and (Bruce and Longo, 1990) in case these two assumptions do not hold. In the following, Q i2S T i denotes the set of all functions, f , with domain, S, such that for all i 2 S, f (i) 2 T i . <p> For simplicity, we will assume that A !t = A ! A t and that A Bool = ftrue; f alse; ?g. It is straightforward to replace this by the more complex (but more flexible) definition given in (Bruce et al., 1990) and <ref> (Bruce and Longo, 1990) </ref> in case these two assumptions do not hold. In the following, Q i2S T i denotes the set of all functions, f , with domain, S, such that for all i 2 S, f (i) 2 T i . <p> In terms of type-checking, this implies that any value of the first type can be treated as a value of the second type. This is made explicit, for example, in <ref> (Bruce and Longo, 1990) </ref> and (Breazu-Tannen et al., 1991) by requiring the existence of a well-behaved "coercion" function which takes values of the first type to the second. <p> It will not be necessary to define what a "well-behaved coercion function" is here, as we will simply use this notion to argue for the intuitive correctness of our subtyping rules. See <ref> (Bruce and Longo, 1990) </ref> or (Breazu-Tannen et al., 1991) for details on these coercion functions. The subtype relation between types is reflexive and transitive. If is a subtype of t , we say that t is a supertype of . <p> This coercion function was described informally in section 4.1.1, and may be understood as a sort of homomorphism that preserves behavior. A set of axioms and rules governing the behavior of convert can be found in <ref> (Bruce and Longo, 1990) </ref>. The subsumption rule in the previous section stated that if C; E ` M : t and C ` t , then C; E ` M : . <p> Bruce that a given term can have two different derivations of the same type. How do we know then that the resulting meanings are the same? One can deal with this problem either semantically or syntactically. In PER models of the bounded second-order lambda calculus (see <ref> (Bruce and Longo, 1990) </ref>), the meanings of terms may be obtained from the meanings of an underlying untyped model. In this way, one may show that the meanings of terms depend on only the "erasure" of the term (the term obtained by erasing all type information) and its type. <p> Such a proof for the bounded second-order lambda calculus was given by (Curien and Ghelli, 1992) and is used in <ref> (Bruce and Longo, 1990) </ref>. (An earlier, somewhat different syntactic proof appeared in (Breazu-Tannen et al., 1991)). In (Bruce et al., 1993), we show that in a slight variant of SOOPL, every typable term has a minimum type. <p> We could also add unbounded polymorphism to the language without problem. The semantics of this extension is analogous to that for ordinary function abstraction and application and contains no surprises (after all, our underlying model supports exactly these features). More details can be found in <ref> (Bruce and Longo, 1990) </ref>. In Section 5 we discussed how to implement a language design that hid instance Paradigmatic Object-Oriented Programming Language 67 variables outside of an object, and, conversely, how one could make these hidden instance variables accessible by adding methods to access and update their values. <p> Because of the existence of an operator to update instance variables (actually the operator creates a new copy of the object with a different value for the instance variable), we could not allow the types of instance variables to be changed in subclasses. As noted in <ref> (Bruce and Longo, 1990) </ref> and (Cardelli and Mitchell, 1990), an update operator is not definable in the standard presentation of bounded second-order lambda calculus. Our restrictions on subclasses, while adding some complexity to the type-checking rules, allow us to overcome this limitation. <p> in (Bruce, 1992). (Cardelli and Wegner, 1985), following earlier work in (Mitchell, 1988) (originally published as (Mitchell, 1984)), introduced the notion of bounded quantification in higher-order languages, which was extended in (Canning et al., 1989) to handle the more general "F-bounded" quantification used here in the semantics of class definitions. <ref> (Bruce and Longo, 1990) </ref> (an early version of which appeared as (Bruce and Longo, 1988)) provided the first careful formal semantics of subtyping (using PER models) in this language.
Reference: <author> Kim B. Bruce and J. Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order polymorphism. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 316-327, </pages> <year> 1992. </year>
Reference: <author> Kim B. Bruce and Robert van Gent. </author> <title> TOIL: A new type-safe object-oriented imperative language. </title> <note> to appear, 1993. Paradigmatic Object-Oriented Programming Language 79 P. </note> <author> Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Functional Prog. and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference: <author> P. Canning, W. Cook, W. Hill, and W. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 457-467, </pages> <year> 1989. </year>
Reference-contexts: It is too weak in that it must be extended with recursively-defined elements, recursive types, either F-bounded quantification <ref> (Canning et al., 1989) </ref> or higher-order functions from types to types, and some sort of record extension operator in order to express many of the features of object-oriented languages. <p> It is also helpful for the more technical sections on semantics to be familiar with the second-order (polymorphic) bounded lambda calculus and the extension to so-called "F-bounded" polymor-phism. The former language was first introduced in (Cardelli and Wegner, 1985), while the latter was introduced in <ref> (Canning et al., 1989) </ref>. However, the non-technical sections of this paper should be accessible to those without this background. 2 Terminology for object-oriented features The language described in this paper offers full support for object-oriented features including objects, classes, methods, instance variables, dynamic method invocation, subclasses, and subtypes. <p> The product over ~ such that ~ A [[t ]][~=MyType] is an example of a type defined by "F-bounded quantification", since the upper bound of ~ is a term involving ~. This technique is used in (Cook et al., 1990) and (Bruce, 1992), and was originally proposed in <ref> (Canning et al., 1989) </ref>. <p> operational, semantics for typed object-oriented languages, which was shown to be equivalent to that of (Cook et al., 1990) in (Bruce, 1992). (Cardelli and Wegner, 1985), following earlier work in (Mitchell, 1988) (originally published as (Mitchell, 1984)), introduced the notion of bounded quantification in higher-order languages, which was extended in <ref> (Canning et al., 1989) </ref> to handle the more general "F-bounded" quantification used here in the semantics of class definitions. (Bruce and Longo, 1990) (an early version of which appeared as (Bruce and Longo, 1988)) provided the first careful formal semantics of subtyping (using PER models) in this language.
Reference: <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year> <title> Special issue devoted to Symp. on Semantics of Data Types, </title> <booktitle> Sophia-Antipolis (France), </booktitle> <year> 1984. </year>
Reference-contexts: These include Simula (Birtwistle et al., 1973), Smalltalk (Goldberg and Robson, 1983), Eiffel (Meyer, 1988), and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ (Stroustrop, 1986), Oberon (Wirth, 1988), Modula 3 <ref> (Cardelli et al., 1988) </ref>, Object Pascal (Tesler, 1985), and various extensions of LISP ((Moon, 1986), for example). There has also been considerable interest in the theoretical community in designing object-oriented languages with clean semantics.
Reference: <author> L. Cardelli. </author> <title> Structural subtyping and the notion of powertype. </title> <booktitle> In Proc 15th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 70-79, </pages> <year> 1988. </year>
Reference-contexts: These include Simula (Birtwistle et al., 1973), Smalltalk (Goldberg and Robson, 1983), Eiffel (Meyer, 1988), and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ (Stroustrop, 1986), Oberon (Wirth, 1988), Modula 3 <ref> (Cardelli et al., 1988) </ref>, Object Pascal (Tesler, 1985), and various extensions of LISP ((Moon, 1986), for example). There has also been considerable interest in the theoretical community in designing object-oriented languages with clean semantics.
Reference: <author> Luca Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. </title> <type> Technical Report 81, </type> <institution> DEC Systems Research Center, </institution> <year> 1992. </year>
Reference: <author> Luca Cardelli. </author> <booktitle> Typed foundations of object-oriented programming, </booktitle> <year> 1992. </year> <note> Tutorial given at POPL '92. </note>
Reference: <author> L. Cardelli, J. Donahue, L. Galssman, M. Jordan, B. Kalsow, and G. Nelson. </author> <type> Modula-3 report. Technical Report SRC-31, </type> <institution> DEC systems Research Center, </institution> <year> 1988. </year>
Reference-contexts: These include Simula (Birtwistle et al., 1973), Smalltalk (Goldberg and Robson, 1983), Eiffel (Meyer, 1988), and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ (Stroustrop, 1986), Oberon (Wirth, 1988), Modula 3 <ref> (Cardelli et al., 1988) </ref>, Object Pascal (Tesler, 1985), and various extensions of LISP ((Moon, 1986), for example). There has also been considerable interest in the theoretical community in designing object-oriented languages with clean semantics.
Reference: <author> Luca Cardelli and Giuseppe Longo. </author> <title> A semantic basis for Quest. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 417-458, </pages> <year> 1991. </year>
Reference: <author> L. Cardelli and J.C. Mitchell. </author> <title> Operations on records. In Math. </title> <booktitle> Foundations of Prog. Lang. Semantics, </booktitle> <pages> pages 22-52. </pages> <publisher> Springer LNCS 442, </publisher> <year> 1990. </year>
Reference-contexts: This is similar to the way that one shows that two mutually recursive functions satisfy their specifications. That is, show the first is correct under the assumption that the second is correct and vice-versa. The solution presented here is based on the criteria presented in <ref> (Amadio and Cardelli, 1990) </ref> for determining when two recursively defined types are subtypes. As indicated above, the place where our example with points breaks down is with the eq method. <p> The only difficult part of the induction is that corresponding to the subtyping rule for object types. Since object types denote fixed points, the desired result follows from a theorem of <ref> (Amadio and Cardelli, 1990) </ref>, which states that our subtyping rule for recursive types is sound. For part 2, the soundness of the (Var ()) axiom follows from the definition of consistency of an environment given above. <p> Even more serious, if the new method name does occur in the current class, its type is not known, so it is impossible to tell if the update is legal or not. The more complex record calculus presented in <ref> (Cardelli and Mitchell, 1990) </ref> may help solve this problem, as it provides both positive and negative information on the presence of particular methods. It was decided not to move to such a system here since the added complexities seem to outweigh the benefits. <p> As noted in (Bruce and Longo, 1990) and <ref> (Cardelli and Mitchell, 1990) </ref>, an update operator is not definable in the standard presentation of bounded second-order lambda calculus. Our restrictions on subclasses, while adding some complexity to the type-checking rules, allow us to overcome this limitation.
Reference: <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: See (Gunter, 1992) or (Mitchell, 1990b), for instance. It is also helpful for the more technical sections on semantics to be familiar with the second-order (polymorphic) bounded lambda calculus and the extension to so-called "F-bounded" polymor-phism. The former language was first introduced in <ref> (Cardelli and Wegner, 1985) </ref>, while the latter was introduced in (Canning et al., 1989). <p> Mitchell (1990a) proposed an alternative, more operational, semantics for typed object-oriented languages, which was shown to be equivalent to that of (Cook et al., 1990) in (Bruce, 1992). <ref> (Cardelli and Wegner, 1985) </ref>, following earlier work in (Mitchell, 1988) (originally published as (Mitchell, 1984)), introduced the notion of bounded quantification in higher-order languages, which was extended in (Canning et al., 1989) to handle the more general "F-bounded" quantification used here in the semantics of class definitions. (Bruce and Longo, 1990)
Reference: <author> F. Cardone. </author> <title> Relational semantics for recursive types and bounded quantification. </title> <booktitle> In ICALP, </booktitle> <pages> pages 164-178. </pages> <publisher> Springer-Verlag LNCS 372, </publisher> <year> 1989. </year>
Reference-contexts: Later work by (Amadio, 1991) and <ref> (Cardone, 1989) </ref> provided models supporting subtypes and recursively defined elements and types. (Abadi and Plotkin, 1990) provided a more category-theoretic construction which also resulted in types which are CPO's. Recently, (Bruce and Mitchell, 1992) strengthened these constructions 74 Kim B.
Reference: <author> Giuseppe Castagna, G. Ghelli, and G. Longo. </author> <title> A calculus for overloaded functions with subtyping. </title> <type> Technical report, </type> <institution> Ecole Normale Superieure, </institution> <year> 1991. </year> <note> To appear. </note>
Reference: <author> G. Castagna and Benjamin Pierce. </author> <title> Decidable bounded quantification. </title> <booktitle> In Proc. ACM Symp. on the Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: He has shown that type checking in F is undecidable. While more recent results <ref> ( Castagna and Pierce, 1994) </ref> show that it is possible to provide a rather natural (and minimal) restriction to this language whose type-checking problem is decidable, it Paradigmatic Object-Oriented Programming Language 5 is not yet known whether the extensions needed here cause more problems.
Reference: <author> W.R. Cook. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference: <author> W.R. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <booktitle> In European Conf. on Object-Oriented Programming, </booktitle> <pages> pages 57-72, </pages> <year> 1989. </year>
Reference: <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proc. 17th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <month> January </month> <year> 1990. </year>
Reference: <author> W. Cook and J. Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-444, </pages> <year> 1989. </year>
Reference: <author> Brad Cox. </author> <title> Object-oriented programming; an evolutionary appoach. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference: <author> P.L. Curien and G. Ghelli. </author> <title> Coherence of subsumption, minimum typing and type-checking in F . Mathematical Structures in Computer Science, </title> <booktitle> 2 </booktitle> <pages> 55-91, </pages> <year> 1992. </year>
Reference-contexts: Such a proof for the bounded second-order lambda calculus was given by <ref> (Curien and Ghelli, 1992) </ref> and is used in (Bruce and Longo, 1990). (An earlier, somewhat different syntactic proof appeared in (Breazu-Tannen et al., 1991)). In (Bruce et al., 1993), we show that in a slight variant of SOOPL, every typable term has a minimum type. <p> The only differences in syntax between TOOPL and TOOPLE are that class, extend, and update terms must be labeled with their intended types. Then, applying techniques suggested in <ref> (Curien and Ghelli, 1992) </ref>, it can be shown (under very natural restrictions on C) that every term which is typable with respect to C; E has a minimum type. From this an algorithm can be derived which solves the type-checking problem for TOOPLE.
Reference: <author> S. Danforth and C. Tomlinson. </author> <title> Type theories and object-oriented programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <year> 1988. </year>
Reference: <author> Allyn Dimock and Robert Muller. </author> <title> Private communication, </title> <year> 1992. </year>
Reference: <author> G. Ghelli. </author> <title> A static type system for message passing. </title> <booktitle> In OOPSLA '91 Proceedings, </booktitle> <pages> pages 129-145. </pages> <booktitle> ACM SIGPLAN Notices,26(11), </booktitle> <month> November </month> <year> 1991. </year>
Reference: <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The language and its implementation. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: There are now several object-oriented languages which are being used to produce commercial software. These include Simula (Birtwistle et al., 1973), Smalltalk <ref> (Goldberg and Robson, 1983) </ref>, Eiffel (Meyer, 1988), and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ (Stroustrop, 1986), Oberon (Wirth, 1988), Modula 3 (Cardelli et al., 1988), Object Pascal (Tesler, 1985), and various extensions of LISP ((Moon, 1986), for example).
Reference: <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference: <author> Andreas V. Hense. </author> <title> Denotational semantics of an object oriented programming language with explicit wrappers. </title> <type> Technical Report A 11/90, </type> <institution> Universitat des Saarlandes, </institution> <note> 1990. </note> <author> 80 Kim B. Bruce Andreas V. Hense. </author> <title> Wrapper semantics of an object oriented programming language with state. </title> <booktitle> In TACS '91 proceedings, </booktitle> <pages> pages 548-568. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: <author> S. Kamin. </author> <title> Inheritance in Smalltalk-80: a denotational definition. </title> <booktitle> In ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 80-87, </pages> <year> 1988. </year>
Reference: <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient recursive subtyping. </title> <booktitle> In 20th ACM Symp. Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference: <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <booktitle> In OOPSLA '87 Addendum to the Proceedings, </booktitle> <pages> pages 17-34. </pages> <booktitle> ACM SIGPLAN Notices,23(5), </booktitle> <month> May </month> <year> 1988. </year>
Reference: <author> O. Madsen, B. Magnusson, and B. Moller-Pedersen. </author> <title> Strong typing of object-oriented languages revisited. </title> <booktitle> In OOPSLA-ECOOP '90 Proceedings, </booktitle> <pages> pages 140-150. </pages> <booktitle> ACM SIGPLAN Notices,25(10), </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Some languages, such as C++ (Stroustrop, 1986), make no pretense to being type safe. The designers of the language Beta originally seemed to be interested in designing a type-safe language, but have recently argued that they don't care if the language is completely type safe <ref> (Madsen et al., 1990) </ref>. In fact, we argue below that fundamental decisions (especially the decision to identify subclasses and subtypes) made by some of the language designers would make it extremely difficult to create a language as expressive as desired, and still have a safe type system.
Reference: <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Since a given construct may be a combination of updates and extensions, we shall use the keyword modify in place of update and extend. We indicate those methods and instance variables which are being changed by listing them in a "redefining" clause as in Eiffel <ref> (Meyer, 1988) </ref>. 2. We write f (x: T 1 ; y: T 2 ) = e to abbreviate f = f un (x: T 1 ) f un (y: T 2 ) e. 3. <p> There are now several object-oriented languages which are being used to produce commercial software. These include Simula (Birtwistle et al., 1973), Smalltalk (Goldberg and Robson, 1983), Eiffel <ref> (Meyer, 1988) </ref>, and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ (Stroustrop, 1986), Oberon (Wirth, 1988), Modula 3 (Cardelli et al., 1988), Object Pascal (Tesler, 1985), and various extensions of LISP ((Moon, 1986), for example). <p> There is hope that these axioms and rules may be substantially simpler than the denotational semantics. In particular, restrictions on the redefinition of methods in subclasses similar to those specified in Eiffel <ref> (Meyer, 1988) </ref> (i.e., preconditions must be weaker and postconditions stronger in overridden methods in subclasses) may result in a language which is more restrictive, but whose semantics can be more easily comprehended. A (relative) completeness theorem for such a system would be desirable, though not essential for practical applications.
Reference: <author> B. Meyer. </author> <title> Eiffel: the language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: This system-wide type checking essentially performs a data flow analysis of the program in order to ensure that only type-safe message sends are performed (see <ref> (Meyer, 1992) </ref> for more details). We consider this solution unsatisfactory since the addition of a new class to a system may result in link-time type errors which would not be predictable from looking at the interface of the previous classes or the code of the new class.
Reference: <author> J.C. Mitchell. </author> <title> Type inference and type containment. </title> <booktitle> In Proc. Int. Symp. on Semantics of Data Types, Sophia-Antipolis (France), </booktitle> <publisher> Springer LNCS 173, </publisher> <pages> pages 257-278, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Mitchell (1990a) proposed an alternative, more operational, semantics for typed object-oriented languages, which was shown to be equivalent to that of (Cook et al., 1990) in (Bruce, 1992). (Cardelli and Wegner, 1985), following earlier work in (Mitchell, 1988) (originally published as <ref> (Mitchell, 1984) </ref>), introduced the notion of bounded quantification in higher-order languages, which was extended in (Canning et al., 1989) to handle the more general "F-bounded" quantification used here in the semantics of class definitions. (Bruce and Longo, 1990) (an early version of which appeared as (Bruce and Longo, 1988)) provided the
Reference: <author> J.C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <journal> Information and Computation, </journal> 76(2/3):211-249, 1988. Reprinted in Logical Foundations of Functional Programming, ed. G. Huet, Addison-Wesley (1990) 153-194. 
Reference-contexts: In other words, we only care that their types are of the form t fi (t ! t ) for some t. The existential types introduced by Mitchell and Plotkin <ref> (Mitchell and Plotkin, 1988) </ref> provide exactly the mechanism necessary to accomplish this. Existential types were originally introduced to hide the representation of a data type. (Mitchell and Plotkin, 1988) describes a very general mechanism for existential types which allows one to hide both the data type and the implementation of operations <p> The existential types introduced by Mitchell and Plotkin <ref> (Mitchell and Plotkin, 1988) </ref> provide exactly the mechanism necessary to accomplish this. Existential types were originally introduced to hide the representation of a data type. (Mitchell and Plotkin, 1988) describes a very general mechanism for existential types which allows one to hide both the data type and the implementation of operations on that data type. As we have no need for hiding operations here, we describe a simpler version. <p> An operator "close" was provided which converts an object from type "SelfType" to "MyType" by hiding the instance variables. Existential types, as presented in 72 Kim B. Bruce <ref> (Mitchell and Plotkin, 1988) </ref>, were used to provide the semantics of this mechanism. While minor variations of the semantic definitions presented here are possible, the semantics given here faithfully represent the intended meanings of the basic constructs of object-oriented languages. <p> Mitchell (1990a) proposed an alternative, more operational, semantics for typed object-oriented languages, which was shown to be equivalent to that of (Cook et al., 1990) in (Bruce, 1992). (Cardelli and Wegner, 1985), following earlier work in <ref> (Mitchell, 1988) </ref> (originally published as (Mitchell, 1984)), introduced the notion of bounded quantification in higher-order languages, which was extended in (Canning et al., 1989) to handle the more general "F-bounded" quantification used here in the semantics of class definitions. (Bruce and Longo, 1990) (an early version of which appeared as (Bruce
Reference: <author> J.C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Proc. 17th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Even more serious, if the new method name does occur in the current class, its type is not known, so it is impossible to tell if the update is legal or not. The more complex record calculus presented in <ref> (Cardelli and Mitchell, 1990) </ref> may help solve this problem, as it provides both positive and negative information on the presence of particular methods. It was decided not to move to such a system here since the added complexities seem to outweigh the benefits. <p> As noted in (Bruce and Longo, 1990) and <ref> (Cardelli and Mitchell, 1990) </ref>, an update operator is not definable in the standard presentation of bounded second-order lambda calculus. Our restrictions on subclasses, while adding some complexity to the type-checking rules, allow us to overcome this limitation.
Reference: <author> J.C. Mitchell. </author> <title> Type systems for programming languages. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 365-458. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: Even more serious, if the new method name does occur in the current class, its type is not known, so it is impossible to tell if the update is legal or not. The more complex record calculus presented in <ref> (Cardelli and Mitchell, 1990) </ref> may help solve this problem, as it provides both positive and negative information on the presence of particular methods. It was decided not to move to such a system here since the added complexities seem to outweigh the benefits. <p> As noted in (Bruce and Longo, 1990) and <ref> (Cardelli and Mitchell, 1990) </ref>, an update operator is not definable in the standard presentation of bounded second-order lambda calculus. Our restrictions on subclasses, while adding some complexity to the type-checking rules, allow us to overcome this limitation.
Reference: <author> J.C. Mitchell and G.D. Plotkin. </author> <title> Abstract types have existential types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year> <note> Preliminary version appeared in Proc. 12th ACM Symp. on Principles of Programming Languages, </note> <year> 1985. </year>
Reference-contexts: In other words, we only care that their types are of the form t fi (t ! t ) for some t. The existential types introduced by Mitchell and Plotkin <ref> (Mitchell and Plotkin, 1988) </ref> provide exactly the mechanism necessary to accomplish this. Existential types were originally introduced to hide the representation of a data type. (Mitchell and Plotkin, 1988) describes a very general mechanism for existential types which allows one to hide both the data type and the implementation of operations <p> The existential types introduced by Mitchell and Plotkin <ref> (Mitchell and Plotkin, 1988) </ref> provide exactly the mechanism necessary to accomplish this. Existential types were originally introduced to hide the representation of a data type. (Mitchell and Plotkin, 1988) describes a very general mechanism for existential types which allows one to hide both the data type and the implementation of operations on that data type. As we have no need for hiding operations here, we describe a simpler version. <p> An operator "close" was provided which converts an object from type "SelfType" to "MyType" by hiding the instance variables. Existential types, as presented in 72 Kim B. Bruce <ref> (Mitchell and Plotkin, 1988) </ref>, were used to provide the semantics of this mechanism. While minor variations of the semantic definitions presented here are possible, the semantics given here faithfully represent the intended meanings of the basic constructs of object-oriented languages. <p> Mitchell (1990a) proposed an alternative, more operational, semantics for typed object-oriented languages, which was shown to be equivalent to that of (Cook et al., 1990) in (Bruce, 1992). (Cardelli and Wegner, 1985), following earlier work in <ref> (Mitchell, 1988) </ref> (originally published as (Mitchell, 1984)), introduced the notion of bounded quantification in higher-order languages, which was extended in (Canning et al., 1989) to handle the more general "F-bounded" quantification used here in the semantics of class definitions. (Bruce and Longo, 1990) (an early version of which appeared as (Bruce
Reference: <author> D. Moon. </author> <title> Object-oriented programming with flavors. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 1-9, </pages> <year> 1986. </year>
Reference: <author> Stephen M. Omohundro. </author> <title> The Sather language. </title> <type> Technical report, </type> <institution> International Computer Science Institute, </institution> <year> 1991. </year>
Reference: <author> J. Palsberg and M. Schwartzback. </author> <title> Type substitution for object-oriented programming. </title> <booktitle> In OOPSLA-ECOOP '90 Proceedings, </booktitle> <pages> pages 151-160. </pages> <booktitle> ACM SIGPLAN Notices,25(10), </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: They point out that their system can result in statically incorrect subclasses in this situation. There seems to be no work-around to this problem with their system. (Palsberg and Schwartzback, 1991) and <ref> (Palsberg and Schwartzback, 1990) </ref> introduce the notion of substitution as a mechanism orthogonal to inheritance which, when combined with inheritance, provides a more general notion of subclassing.
Reference: <author> J. Palsberg and M. Schwartzback. </author> <title> Static typing for object-oriented programming. </title> <type> Technical report, </type> <institution> Aarhus University Computer Science Department, </institution> <year> 1991. </year>
Reference-contexts: The semantics of inheritance in this language is based on (Cook, 1989a). Hense provides language constructs and semantics for explicit wrappers (Hense, 1991) and instance variables (Hense, 1990). The paper <ref> (Palsberg and Schwartzback, 1991) </ref> presents a theory of statically typed object-oriented languages in which subclasses preserve subtypes. Their system requires that types be finite sets of classes. <p> They point out that their system can result in statically incorrect subclasses in this situation. There seems to be no work-around to this problem with their system. <ref> (Palsberg and Schwartzback, 1991) </ref> and (Palsberg and Schwartzback, 1990) introduce the notion of substitution as a mechanism orthogonal to inheritance which, when combined with inheritance, provides a more general notion of subclassing.
Reference: <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Proc 19th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 305-315, </pages> <year> 1992. </year>
Reference: <author> Benjamin C. Pierce and Martin Hoffman. </author> <title> An abstract view of objects and subtyping (preliminary report). </title> <type> Technical Report ECS-LFCS-92-226, </type> <institution> University of Edinburgh, </institution> <year> 1992. </year>
Reference: <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <type> Technical report, </type> <institution> University of Edinburgh, </institution> <year> 1992. </year>
Reference: <author> Benjamin C. Pierce and David N. Turner. </author> <title> Statically typed multi-methods via partially abstract types. </title> <note> Technical Report to appear, </note> <institution> University of Edinburgh, </institution> <year> 1992. </year>
Reference: <author> Benjamin C. Pierce and David N. Turner. </author> <title> Object-oriented programming without recursive types. </title> <booktitle> In Proc 20th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 299-312, </pages> <year> 1993. </year>
Reference: <author> U.S. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proc. ACM Symp. Lisp and Functional Programming Languages, </booktitle> <pages> pages 289-297, </pages> <month> July </month> <year> 1988. </year>
Reference: <author> J.C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. In N.D. </title> <editor> Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, </booktitle> <pages> pages 211-2580. </pages> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> Vol. 94, </volume> <year> 1980. </year> <title> Paradigmatic Object-Oriented Programming Language 81 C. </title> <note> Schaffert, </note> <author> T. Cooper, B. Bullis, M. Kilian, and C. Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In OOPSLA '86 Proceedings, </booktitle> <pages> pages 9-16. </pages> <booktitle> ACM SIGPLAN Notices,21(11), </booktitle> <month> November </month> <year> 1986. </year>
Reference-contexts: effect with a MyClass construct similar to our MyType (see Section 7 for a discussion of this construct), providing updatable instance variables is a simpler solution to this problem. 5.1 Complications due to instance variables The fact that instance variables are updatable (i.e., are acceptors as well as evaluators, see <ref> (Reynolds, 1980) </ref>) will lead to restrictions on changing the types of instance variables in subclasses. Suppose the expression self gets fx = ag, where a: t , appears in the body of a method m of class c.
Reference: <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proc. 1st ACM Symp. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 38-46, </pages> <month> October </month> <year> 1986. </year>
Reference: <author> B. Stroustrop. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: The advantages of statically-typed languages are well-known. They include earlier detection of errors and the provision of better information to allow compiler optimizations. However, early object-oriented languages either had gaping type holes (Simula-67), or provided only very weak dynamic typing (Smalltalk). Some languages, such as C++ <ref> (Stroustrop, 1986) </ref>, make no pretense to being type safe. The designers of the language Beta originally seemed to be interested in designing a type-safe language, but have recently argued that they don't care if the language is completely type safe (Madsen et al., 1990). <p> There are now several object-oriented languages which are being used to produce commercial software. These include Simula (Birtwistle et al., 1973), Smalltalk (Goldberg and Robson, 1983), Eiffel (Meyer, 1988), and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ <ref> (Stroustrop, 1986) </ref>, Oberon (Wirth, 1988), Modula 3 (Cardelli et al., 1988), Object Pascal (Tesler, 1985), and various extensions of LISP ((Moon, 1986), for example). There has also been considerable interest in the theoretical community in designing object-oriented languages with clean semantics.
Reference: <author> L. Tesler. </author> <title> Object Pascal report. </title> <type> Technical Report 1, </type> <institution> Apple Computer, </institution> <year> 1985. </year>
Reference-contexts: These include Simula (Birtwistle et al., 1973), Smalltalk (Goldberg and Robson, 1983), Eiffel (Meyer, 1988), and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ (Stroustrop, 1986), Oberon (Wirth, 1988), Modula 3 (Cardelli et al., 1988), Object Pascal <ref> (Tesler, 1985) </ref>, and various extensions of LISP ((Moon, 1986), for example). There has also been considerable interest in the theoretical community in designing object-oriented languages with clean semantics.
Reference: <author> Robert van Gent. </author> <title> TOIL: An imperative type-safe object-oriented language. </title> <type> Williams College Senior Honors Thesis, </type> <year> 1993. </year>
Reference: <author> Peter Wegner. </author> <title> Concepts and paradigms of object-oriented programming. </title> <journal> OOPS Messenger, </journal> <volume> 1(1) </volume> <pages> 7-87, </pages> <month> August </month> <year> 1990. </year>
Reference: <author> N. Wirth. </author> <title> The programming language Oberon. </title> <journal> Software Practice and Experience, </journal> <volume> 18 </volume> <pages> 671-690, </pages> <year> 1988. </year>
Reference-contexts: There are now several object-oriented languages which are being used to produce commercial software. These include Simula (Birtwistle et al., 1973), Smalltalk (Goldberg and Robson, 1983), Eiffel (Meyer, 1988), and Trellis/Owl (Schaffert et al., 1986), as well as extensions to older programming languages such as C++ (Stroustrop, 1986), Oberon <ref> (Wirth, 1988) </ref>, Modula 3 (Cardelli et al., 1988), Object Pascal (Tesler, 1985), and various extensions of LISP ((Moon, 1986), for example). There has also been considerable interest in the theoretical community in designing object-oriented languages with clean semantics.
References-found: 74

