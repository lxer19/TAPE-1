URL: ftp://ftp.cs.uoregon.edu/pub/ariola/Chapter6.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: 6 Graph Rewriting Systems For Efficient Compilation way to capture sharing is to represent the
Author: Z. M. Ariola and Arvind eds. M.R.Sleep, M.J.Plasmeijer and M.C. van Eekelen 
Note: A  c fl1993 John Wiley Sons Ltd  
Date: 6.1 INTRODUCTION  
Abstract: A modern trend in programming language theory has been to develop calculi to capture some specific aspects of functional language implementations. For example, several calculi for explicit substitution have recently been developed by Curien and Levy [ACCL90, Cur86, Cur91, HL89, Hin77]. An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91]. Barendregt et al., have put forth a calculus to capture sharing in graph reduction implementation of Term Rewriting Systems (TRS) [BBvE + 87, BvEG + 87, Ken90, BvEvLP87]. In the same vein, we want to develop a calculus to capture the sharing of subexpressions in a more general class of languages. Specification of sharing is desirable in the intermediate language used by a compiler for a purely functional language. Consider the function definition F x = x + x and the expression F(2+3). Any decent implementation, independent of the evaluation strategy (normal-order or applicative-order) it employs, will evaluate the subexpression 2 + 3 only once. Dealing with sharing is important if the intermediate language is to be used to express and reason about optimizations. However, sharing becomes a necessity when a functional language is extended with side-effect operations, like I-structures [ANP89]. In general side-effects destroy "referential transparency" in the sense that the definition of an identifier cannot be substituted for each occurrence of the identifier in an unrestricted manner. Thus, the semantics of such a language requires a precise specification of sharing and substitution. 
Abstract-found: 1
Intro-found: 0
Reference: [AA89] <author> Z. M. Ariola and Arvind. P-tac: </author> <title> A parallel intermediate language. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> London, </address> <year> 1989. </year> <month> ARIOLA </month>
Reference-contexts: It is for this reason that in our earlier work we had called our system a Contextual Rewriting System <ref> [AA89, AA91b, AA91a] </ref>. However, Jean-Jacques Levy convinced us that our system basically described graph rewriting, so we renamed it simply a GRS. <p> To that end we have introduced the Kid (Kernel id) language [AA91b] and the P-TAC (Parallel Three Address Code) language <ref> [AA89] </ref>. We also provided the translation of Id into Kid and of Kid into P-TAC [AA91a]. P-TAC can be seen as an example of GRS, while Kid is more general due to the presence of -abstraction.
Reference: [AA91a] <author> Z. M. Ariola and Arvind. </author> <title> Compilation of id. </title> <booktitle> In Proc. of the Fourth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Santa Clara, California, </address> <publisher> Springer-Verlag LNCS 589, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: It is for this reason that in our earlier work we had called our system a Contextual Rewriting System <ref> [AA89, AA91b, AA91a] </ref>. However, Jean-Jacques Levy convinced us that our system basically described graph rewriting, so we renamed it simply a GRS. <p> To that end we have introduced the Kid (Kernel id) language [AA91b] and the P-TAC (Parallel Three Address Code) language [AA89]. We also provided the translation of Id into Kid and of Kid into P-TAC <ref> [AA91a] </ref>. P-TAC can be seen as an example of GRS, while Kid is more general due to the presence of -abstraction. This approach has lead to the formalization of compiler optimizations in terms of source-to-source transformations on these intermediate languages.
Reference: [AA91b] <author> Z. M. Ariola and Arvind. </author> <title> A syntactic approach to program transformations. </title> <booktitle> In Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, </booktitle> <institution> Yale University, </institution> <address> New Haven, CT, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: It is for this reason that in our earlier work we had called our system a Contextual Rewriting System <ref> [AA89, AA91b, AA91a] </ref>. However, Jean-Jacques Levy convinced us that our system basically described graph rewriting, so we renamed it simply a GRS. <p> To that end we have introduced the Kid (Kernel id) language <ref> [AA91b] </ref> and the P-TAC (Parallel Three Address Code) language [AA89]. We also provided the translation of Id into Kid and of Kid into P-TAC [AA91a]. P-TAC can be seen as an example of GRS, while Kid is more general due to the presence of -abstraction. <p> This approach has lead to the formalization of compiler optimizations in terms of source-to-source transformations on these intermediate languages. Moreover, using the notion of information content of a term we have given a criteria for the (partial) correctness of these compiler optimizations <ref> [AA91b] </ref>. The results presented in this chapter (notably Theorems 2.6.10 and 2.6.11) can be applied in a straightforward manner to show the partial correctness of those optimizations that simply increase the sharing in a term.
Reference: [ACCL90] <author> M. Abadi, L. Cardelli, P.-L. Currien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Fran-cisco, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: 6.1 INTRODUCTION A modern trend in programming language theory has been to develop calculi to capture some specific aspects of functional language implementations. For example, several calculi for explicit substitution have recently been developed by Curien and Levy <ref> [ACCL90, Cur86, Cur91, HL89, Hin77] </ref>. An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91].
Reference: [ANP89] <author> Arvind, R. S. Nikhil, and K. K Pingali. I-structures: </author> <title> data structures for parallel computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4), </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: Dealing with sharing is important if the intermediate language is to be used to express and reason about optimizations. However, sharing becomes a necessity when a functional language is extended with side-effect operations, like I-structures <ref> [ANP89] </ref>. In general side-effects destroy "referential transparency" in the sense that the definition of an identifier cannot be substituted for each occurrence of the identifier in an unrestricted manner. Thus, the semantics of such a language requires a precise specification of sharing and substitution.
Reference: [Ari92] <author> Z. M. Ariola. </author> <title> An Algebraic Approach to the Compilation and Operational Semantics of Functional Languages with I-structures. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: In the last section we briefly discuss the applicability of our term model in showing the correctness of compiler optimizations. This paper is based on the PhD thesis of Zena M. Ariola <ref> [Ari92] </ref> where complete proofs and more examples with explanations may be found. 6.2 SYNTAX OF GRS Our formalism for graph rewriting is based on the observation that a natural way to represent a graph textually is to associate an identifier to each node of the graph, and then write down all <p> We can also show the partial correctness of the cyclic Y-rule. In order to prove total correctness we need to discard sharing from our observations at the expenses of introducing more restrictions on the rules, as discussed in <ref> [Ari92] </ref>. We would like to extend GRS with -abstraction and to provide a term model that cover multi-rooted rules to express side-effect operations. This will provide a sound mathematical basis for the Id language.
Reference: [BBvE + 87] <author> H. P. Barendregt, T. H. Brus, M. C. J. D. van Eekelen, J. R. W. Glauert, J. R. Kennaway, M. O. van Leer, M. J. Plasmeijer, and M. R. Sleep. </author> <title> Towards an intermediate language based on graph rewriting. </title> <booktitle> In Proceedings of the PARLE Conference, </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91]. Barendregt et al., have put forth a calculus to capture sharing in graph reduction implementation of Term Rewriting Systems (TRS) <ref> [BBvE + 87, BvEG + 87, Ken90, BvEvLP87] </ref>. In the same vein, we want to develop a calculus to capture the sharing of subexpressions in a more general class of languages. Specification of sharing is desirable in the intermediate language used by a compiler for a purely functional language.
Reference: [BvEG + 87] <author> H.P. Barendregt, M. C. J. D. van Eekelen, J. R. W. Glauert, J.R. Kennaway, M. J. Plasmeijer, and M. R. Sleep. </author> <title> Term graph rewriting. </title> <booktitle> In Proceedings of the PARLE Conference, </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91]. Barendregt et al., have put forth a calculus to capture sharing in graph reduction implementation of Term Rewriting Systems (TRS) <ref> [BBvE + 87, BvEG + 87, Ken90, BvEvLP87] </ref>. In the same vein, we want to develop a calculus to capture the sharing of subexpressions in a more general class of languages. Specification of sharing is desirable in the intermediate language used by a compiler for a purely functional language. <p> We see graph rewriting as a system in its own right, and want to explore its syntactic and semantic properties. We want to include graphs with cycles and rewriting rules that recognize or create cycles. This is not the case in either [Wad71] or <ref> [BvEG + 87] </ref> where only acyclic graphs are considered and thus, some important implementation ideas are ruled out. In the following, we formally introduce Graph Rewriting Systems (GRS), and prove several syntactic properties of such systems.
Reference: [BvEvLP87] <author> T. H. Brus, M. C. J. D. van Eekelen, M. O. vam Leer, and M. J. Plasmeijer. </author> <title> Clean a language for functional graph rewriting. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Portland, Oregon, </address> <publisher> Springer-Verlag LNCS 274, </publisher> <year> 1987. </year>
Reference-contexts: An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91]. Barendregt et al., have put forth a calculus to capture sharing in graph reduction implementation of Term Rewriting Systems (TRS) <ref> [BBvE + 87, BvEG + 87, Ken90, BvEvLP87] </ref>. In the same vein, we want to develop a calculus to capture the sharing of subexpressions in a more general class of languages. Specification of sharing is desirable in the intermediate language used by a compiler for a purely functional language.
Reference: [Cur86] <author> P.-L. Curien. </author> <title> Categorical combinators, sequential algorithms and functional programming. </title> <booktitle> Research Notes in Theoretical Computer Science. </booktitle> <publisher> Pitman, </publisher> <address> London, </address> <year> 1986. </year>
Reference-contexts: 6.1 INTRODUCTION A modern trend in programming language theory has been to develop calculi to capture some specific aspects of functional language implementations. For example, several calculi for explicit substitution have recently been developed by Curien and Levy <ref> [ACCL90, Cur86, Cur91, HL89, Hin77] </ref>. An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91].
Reference: [Cur91] <author> P.-L. Curien. </author> <title> An abstract framework for environment machines. </title> <journal> Theoretical Computer Science, </journal> <volume> 82, </volume> <year> 1991. </year>
Reference-contexts: 6.1 INTRODUCTION A modern trend in programming language theory has been to develop calculi to capture some specific aspects of functional language implementations. For example, several calculi for explicit substitution have recently been developed by Curien and Levy <ref> [ACCL90, Cur86, Cur91, HL89, Hin77] </ref>. An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91].
Reference: [Hin77] <author> R. Hindley. </author> <title> Combinator reductions and lambda reduction compared. In Zeitschr. </title> <journal> f. math. Logik und Grundlagen d. Math. Bd. </journal> <volume> 23, </volume> <pages> S. 169-180, </pages> <year> 1977. </year>
Reference-contexts: 6.1 INTRODUCTION A modern trend in programming language theory has been to develop calculi to capture some specific aspects of functional language implementations. For example, several calculi for explicit substitution have recently been developed by Curien and Levy <ref> [ACCL90, Cur86, Cur91, HL89, Hin77] </ref>. An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91].
Reference: [HL89] <author> T. Hardin and J.-J. Levy. </author> <title> A confluent calculus of substitution. </title> <booktitle> In France-Japan Artificial Intelligence and Computer Science Symposium, </booktitle> <address> Izu, </address> <year> 1989. </year>
Reference-contexts: 6.1 INTRODUCTION A modern trend in programming language theory has been to develop calculi to capture some specific aspects of functional language implementations. For example, several calculi for explicit substitution have recently been developed by Curien and Levy <ref> [ACCL90, Cur86, Cur91, HL89, Hin77] </ref>. An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91].
Reference: [Kat90] <author> V.K. Kathail. </author> <title> Optimal Interpreters for Lambda-calculus Based Functional Languages. </title> <type> PhD thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, </institution> <year> 1990. </year>
Reference-contexts: More recently a new graph structure which allows sharing of "contexts", has been proposed by Kathail <ref> [Kat90] </ref>. This latter technique leads to provably optimal interpreters for the -calculus [L 78]). Much of the past work on graph rewriting has been to prove its correctness with respect to either the -calculus or Term Rewriting Systems (TRS).
Reference: [Ken90] <author> R. Kennaway. </author> <title> Implementing term rewrite languages in dactl. </title> <journal> Theoretical Computer Science, </journal> <volume> 1, </volume> <year> 1990. </year>
Reference-contexts: An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget [Mar91]. Barendregt et al., have put forth a calculus to capture sharing in graph reduction implementation of Term Rewriting Systems (TRS) <ref> [BBvE + 87, BvEG + 87, Ken90, BvEvLP87] </ref>. In the same vein, we want to develop a calculus to capture the sharing of subexpressions in a more general class of languages. Specification of sharing is desirable in the intermediate language used by a compiler for a purely functional language.
Reference: [KKSdV91] <author> J.R. Kennaway, J. W. Klop, M. R. Sleep, and F. J. de Vries. </author> <title> Transfinite reductions in orthogonal term rewriting systems. </title> <booktitle> In Proc. RTA '91, </booktitle> <publisher> Springer-Verlag LNCS, </publisher> <year> 1991. </year>
Reference-contexts: Notice that if both M 1 and M 2 are not reduced to ffi, the confluence property will be lost, as was observed in <ref> [KKSdV91] </ref>. Barendregt's graph reduction system is not confluent precisely because of the absence of such a reduction. 6.6 A GRAPH MODEL FOR GRS We are interested in defining an equality on the set of terms such that the equality is useful in analyzing the correctness of compiler optimizations.
Reference: [L 78] <author> J.-J. Levy. </author> <title> Reductions Correctes et Optimales dans le Lambda-Calcul. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <month> October </month> <year> 1978. </year>
Reference-contexts: More recently a new graph structure which allows sharing of "contexts", has been proposed by Kathail [Kat90]. This latter technique leads to provably optimal interpreters for the -calculus <ref> [L 78] </ref>). Much of the past work on graph rewriting has been to prove its correctness with respect to either the -calculus or Term Rewriting Systems (TRS). We see graph rewriting as a system in its own right, and want to explore its syntactic and semantic properties. <p> GRAPH REWRITING SYSTEMS We introduce a function ! to compute the stable part of a term, that is, the part of the term that will not change as more reductions are performed on it. The ! function captures what Levy has called the direct approximation of a -calculus term <ref> [L 78] </ref>, and Welch has called the instantaneous semantics of a term [Wel75]. Notice that as more reductions are performed the stable part should get larger, that is, if M ! M 1 ! M 2 then !(M ) ! !(M 1 ) ! !(M 2 ) . <p> Reduction of a term in the - calculus or TRS can also result in the upward creation of redexes. However, upward creation of redexes is not possible in RPSs. To cope with this problem in the -calculus, Wadsworth [Wad71] and Levy <ref> [L 78] </ref> have introduced the notion of the !-rule, which states: M ! This simple !-rule reduces any term that can become a redex (by upward creation) to . However, the presence of non left-linear rules makes the generation of !-rules for TRS and GRS difficult.
Reference: [Mar91] <author> L. Maranget. </author> <title> Optimal derivations in weak lambda-calculi and in orthogonal term rewriting systems. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: For example, several calculi for explicit substitution have recently been developed by Curien and Levy [ACCL90, Cur86, Cur91, HL89, Hin77]. An attempt to formalize "weak reduction", i.e., the kind of reduction that is actually done by most functional language implementations, is described by Maranget <ref> [Mar91] </ref>. Barendregt et al., have put forth a calculus to capture sharing in graph reduction implementation of Term Rewriting Systems (TRS) [BBvE + 87, BvEG + 87, Ken90, BvEvLP87].
Reference: [Wad71] <author> C. P. Wadsworth. </author> <title> Semantics and Pragmatics of the Lambda-Calculus. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <year> 1971. </year>
Reference-contexts: This allows sharing of identical terms through pointers, and avoids repeated evaluation of identical terms as it is commonly done in normal-order reduction. Graph reduction for the -calculus was proposed by Wadsworth in order to bring together the advantages of both the applicative and the normal-order evaluation <ref> [Wad71] </ref>. Wadsworth also formally proved the correctness of his graph reduction technique. (As an aside, Wadsworth also showed that his graph reduction did not capture enough of sharing of expressions to lead to an optimal interpreter. <p> We see graph rewriting as a system in its own right, and want to explore its syntactic and semantic properties. We want to include graphs with cycles and rewriting rules that recognize or create cycles. This is not the case in either <ref> [Wad71] </ref> or [BvEG + 87] where only acyclic graphs are considered and thus, some important implementation ideas are ruled out. In the following, we formally introduce Graph Rewriting Systems (GRS), and prove several syntactic properties of such systems. <p> This phe ARIOLA nomena is usually called upward creation of redexes. Reduction of a term in the - calculus or TRS can also result in the upward creation of redexes. However, upward creation of redexes is not possible in RPSs. To cope with this problem in the -calculus, Wadsworth <ref> [Wad71] </ref> and Levy [L 78] have introduced the notion of the !-rule, which states: M ! This simple !-rule reduces any term that can become a redex (by upward creation) to . However, the presence of non left-linear rules makes the generation of !-rules for TRS and GRS difficult.
Reference: [Wel75] <author> P.H. Welch. </author> <title> Continuous semantics and inside-out reductions. In -Calculus and Computer Schience Theory, </title> <publisher> Italy (Springer-Verlag LNCS 37), </publisher> <month> March </month> <year> 1975. </year>
Reference-contexts: The ! function captures what Levy has called the direct approximation of a -calculus term [L 78], and Welch has called the instantaneous semantics of a term <ref> [Wel75] </ref>. Notice that as more reductions are performed the stable part should get larger, that is, if M ! M 1 ! M 2 then !(M ) ! !(M 1 ) ! !(M 2 ) .
References-found: 20

