URL: http://charm.cs.uiuc.edu/version2/papers/RuntimeOptsPDPTA96.ps
Refering-URL: http://charm.cs.uiuc.edu/version2/papers/RuntimeOptsPDPTA96.html
Root-URL: http://www.cs.uiuc.edu
Email: Email fsanjeev,kaleg@cs.uiuc.edu  
Phone: Phone (217) 244-0094  
Title: Automating Runtime Optimizations for Load Balancing in Irregular Problems  
Author: Sanjeev Krishnan and Laxmikant V. Kale 
Keyword: Thinking Machines CM-5.  
Affiliation: Department of Computer Science, University of Illinois, Urbana-Champaign.  
Abstract: In order to reduce the effort required for attaining good performance for parallel programs, it is necessary to use automated performance optimizing techniques. In this paper we describe run-time optimizations for load balancing, and techniques to automate them without programmer intervention using post-mortem analysis of parallel program execution. These techniques are very useful for applications having irregular, nonuniform or dynamic load patterns. We classify the characteristics of parallel programs with respect to object placement (which determines load balance), then describe techniques to discover these characteristics by post-mortem analysis, and present heuristics to choose appropriate load balancing schemes based on these characteristics. Our ideas have been developed in the framework of the Paradise post-mortem analysis tool for the parallel object-oriented language Charm++. We also present results for optimizing simple parallel programs running on the 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Sanjeev Krishnan. </author> <title> Automating Runtime Optimizations for Parallel Object-Oriented Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: This paper is concerned with precise post-mortem analysis which can be used for automating run-time optimizations for load balancing, especially for irregular, non-uniform or dynamic problems. 2 The Optimization Framework This work is part of a larger project to develop a framework for automatic runtime optimizations <ref> [1, 2] </ref>. The need for runtime optimizations arises because compiler transformations alone are not sufficient to optimize all parallel programs. In particular, compiler optimizations cannot take into account unpredictable run-time execution environments and unknown application characteristics.
Reference: [2] <author> Sanjeev Krishnan and L. V. Kale. </author> <title> Automating Runtime Optimizations Using PostMortem Analysis. </title> <booktitle> In Proceedings of the 10th ACM International Conference on Supercomputing, </booktitle> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: This paper is concerned with precise post-mortem analysis which can be used for automating run-time optimizations for load balancing, especially for irregular, non-uniform or dynamic problems. 2 The Optimization Framework This work is part of a larger project to develop a framework for automatic runtime optimizations <ref> [1, 2] </ref>. The need for runtime optimizations arises because compiler transformations alone are not sufficient to optimize all parallel programs. In particular, compiler optimizations cannot take into account unpredictable run-time execution environments and unknown application characteristics. <p> present a much simpler regular computational model for which optimizations are easier to perform, as compared to a parallel object-oriented model which involves dynamic creation of tasks and asynchronous communication. 3 Program model For completeness, we include a brief description of the programming model and its postmortem representation, taken from <ref> [2] </ref>. This work is based on the parallel object-oriented language Charm++, [9, 10] which is an extension of C++. The basic unit of work in Charm++ is a chare, which is a medium-grained concurrent C++ object. Chares are dynamically created; there may be thousands of chares per processor. <p> The Charm run-time system already provides some load balancing schemes such as randomized, neighbor averaging, and distributed manager. We have also designed a new parameterized load balancing scheme for tree-structured computations which exploits information about the tree-structure to optimize load balance <ref> [2] </ref>.
Reference: [3] <author> W. Williams, T. Hoel, and D. Pase. </author> <title> The MPP Apprentice Performance Tool: Delivering the Performance of the Cray T3D. </title> <editor> In K. M. Decker and R. M. Rehmann, editors, </editor> <title> Programming Environments for Massively Parallel Distributed Systems. </title> <publisher> Birkaeuser Verlag, </publisher> <address> Basel, Switzerland, </address> <year> 1994. </year>
Reference-contexts: will solve the performance problems, and generates concise hints which are communicated to runtime libraries by a "hints file". 2.2 Previous work Automatic post-mortem analysis has been used in performance analysis tools for parallel programs, to give the user insights into performance problems such as load imbalance using expert analysis <ref> [3, 4, 5, 6] </ref>. Our framework aims to go a step further in the direction of automation: Paradise not only finds performance problems, but also solutions in terms of optimizations for the problem areas, and in co-operation with the run-time libraries, incorporates the optimizations in the program without programmer intervention.
Reference: [4] <author> B. Robert Helm and Allen Malony. </author> <title> Automating Performance Diagnosis : A Theory and Architecture. </title> <booktitle> In Proceedings of the International Workshop on Computer Performance Measurement and Analysis, </booktitle> <address> Beppu, Japan, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: will solve the performance problems, and generates concise hints which are communicated to runtime libraries by a "hints file". 2.2 Previous work Automatic post-mortem analysis has been used in performance analysis tools for parallel programs, to give the user insights into performance problems such as load imbalance using expert analysis <ref> [3, 4, 5, 6] </ref>. Our framework aims to go a step further in the direction of automation: Paradise not only finds performance problems, but also solutions in terms of optimizations for the problem areas, and in co-operation with the run-time libraries, incorporates the optimizations in the program without programmer intervention.
Reference: [5] <author> Barton P. Miller et al. </author> <title> The Paradyn Parallel Performance Measurement Tools. </title> <journal> IEEE Computer, </journal> <volume> 28(11), </volume> <month> November </month> <year> 1995. </year>
Reference-contexts: will solve the performance problems, and generates concise hints which are communicated to runtime libraries by a "hints file". 2.2 Previous work Automatic post-mortem analysis has been used in performance analysis tools for parallel programs, to give the user insights into performance problems such as load imbalance using expert analysis <ref> [3, 4, 5, 6] </ref>. Our framework aims to go a step further in the direction of automation: Paradise not only finds performance problems, but also solutions in terms of optimizations for the problem areas, and in co-operation with the run-time libraries, incorporates the optimizations in the program without programmer intervention.
Reference: [6] <author> Amitabh B. Sinha. </author> <title> Performance Analysis of Object Based and Message Driven Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: will solve the performance problems, and generates concise hints which are communicated to runtime libraries by a "hints file". 2.2 Previous work Automatic post-mortem analysis has been used in performance analysis tools for parallel programs, to give the user insights into performance problems such as load imbalance using expert analysis <ref> [3, 4, 5, 6] </ref>. Our framework aims to go a step further in the direction of automation: Paradise not only finds performance problems, but also solutions in terms of optimizations for the problem areas, and in co-operation with the run-time libraries, incorporates the optimizations in the program without programmer intervention. <p> Post-mortem representation: The execution of a Charm++ program is represented as an event graph, which is essentially a dynamic task graph constructed using traces collected at run-time. Issues in collecting trace data, reducing perturbation, and constructing the basic event graph are discussed in <ref> [6] </ref> and are beyond the scope of this paper. A simple version of the event graph was originally used for the Projections [11] performance visualization and analysis tool.
Reference: [7] <author> C.H. Koelbel, D.B. Loveman, R.S. Schreiber, G.L. Steele Jr., and M.E. Zosel. </author> <title> The High Performance Fortran Handbook. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Some compilers for data-parallel languages such as HPF <ref> [7] </ref> use profile information to accurately find the cost of various computation and communication operations. In [8], profile information is used to manually calculate weights to be used in weighted graph decomposition, for irregular data-parallel applications.
Reference: [8] <author> K. Tomko and E. Davidson. </author> <title> Profile Driven Weighted Decomposition. </title> <booktitle> In Proceedings of the 10th ACM International Conference on Supercomputing, </booktitle> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Some compilers for data-parallel languages such as HPF [7] use profile information to accurately find the cost of various computation and communication operations. In <ref> [8] </ref>, profile information is used to manually calculate weights to be used in weighted graph decomposition, for irregular data-parallel applications.
Reference: [9] <author> L.V. Kale and Sanjeev Krishnan. </author> <title> Charm++ : A portable concurrent object oriented system based on C++. </title> <booktitle> In Proceedings of the Conference on Object Oriented Programming Systems, Languages and Applications, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: This work is based on the parallel object-oriented language Charm++, <ref> [9, 10] </ref> which is an extension of C++. The basic unit of work in Charm++ is a chare, which is a medium-grained concurrent C++ object. Chares are dynamically created; there may be thousands of chares per processor.
Reference: [10] <author> L. V. Kale and Sanjeev Krishnan. </author> <title> Charm++ : Parallel Programming with Message-Driven Objects. in Parallel Programming using C++, </title> <publisher> MIT Press, </publisher> <year> 1996. </year> <note> To be published. </note>
Reference-contexts: This work is based on the parallel object-oriented language Charm++, <ref> [9, 10] </ref> which is an extension of C++. The basic unit of work in Charm++ is a chare, which is a medium-grained concurrent C++ object. Chares are dynamically created; there may be thousands of chares per processor.
Reference: [11] <author> L.V. Kale and Amitabh Sinha. </author> <title> Projections : A scalable performance tool. In Parallel Systems Fair, </title> <booktitle> International Parallel Processing Sympo sium, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: Issues in collecting trace data, reducing perturbation, and constructing the basic event graph are discussed in [6] and are beyond the scope of this paper. A simple version of the event graph was originally used for the Projections <ref> [11] </ref> performance visualization and analysis tool. The event graph constructed by Paradise consists of vertices representing entry-function executions, edges representing messages between entry functions and edges for dependences between methods (these dependences must be specified in the language or generated by the compiler).
Reference: [12] <author> A. B. Sinha and L.V. Kale. </author> <title> A load balancing strategy for prioritized execution of tasks. </title> <booktitle> In Proceedings of the International Parallel Processing Symposium, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: objects have the same grainsize ) Choose the round-robin scheme. else Choose the neighbor-averaging scheme (large number of objects with varying grainsize: none of the other two will work). endif endif These rules embody some of the expertise we have accumulated while optimizing several applications requiring dynamic load balancing schemes <ref> [12, 13] </ref>.
Reference: [13] <author> L. V. Kale, Ben Richards, and Terry Allen. </author> <title> Efficient parallel graph coloring with prioritization. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <year> 1996. </year> <note> To be published. </note>
Reference-contexts: objects have the same grainsize ) Choose the round-robin scheme. else Choose the neighbor-averaging scheme (large number of objects with varying grainsize: none of the other two will work). endif endif These rules embody some of the expertise we have accumulated while optimizing several applications requiring dynamic load balancing schemes <ref> [12, 13] </ref>.
References-found: 13

