URL: http://www.cs.ucl.ac.uk/staff/A.Hunter/umis.ps
Refering-URL: http://www.cs.ucl.ac.uk/staff/A.Hunter/papers.html
Root-URL: http://www.cs.ucl.ac.uk
Title: 11 LOGICAL HANDLING OF INCONSISTENT AND DEFAULT INFORMATION  
Author: Philippe Besnard Luis Fari~nas del Cerro* Dov Gabbay** Anthony Hunter** 
Address: College London, UK  
Affiliation: IRISA Rennes, France IRIT Universite Paul Sabatier Toulouse, France Department of Computing Imperial  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P. Besnard. </author> <title> Introduction to Default Logic. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: The inference rules are those of classical logic plus a special mechanism to deal with default rules: basically, if ff is inferred, and :fi cannot be inferred, then infer fl. The above examples demonstrated the main ideas; more complete treatment may be found in <ref> [1] </ref>, for instance. 4 LABELED DEDUCTIVE SYSTEMS FOR PRACTICAL REASONING Developing logics for practical reasoning creates new demands on the apparatus for defining the language and the proof theory.
Reference: [2] <author> P. Besnard. </author> <title> Paraconsistent logics approach to knowledge representation. </title> <booktitle> In Proceedings of World Conference on the Fundamentals of Artificial Intelligence, </booktitle> <pages> pages 107-114. </pages> <publisher> Angkor, </publisher> <year> 1991. </year>
Reference-contexts: One such class of logics is the paraconsistent logics (for a review of paracon-sistent logics see <ref> [2] </ref>). These logics use the same language as classical logic, but they use only a subset of the proof rules. This implies that for any given database we may infer fewer conclusions.
Reference: [3] <author> A. Borgida. </author> <title> Language features for flexible handling of exceptions in information systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(4): </volume> <pages> 565-603, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: We conclude in Section 5 with a brief summary. Note that in this chapter we do not review the literature on handling inconsistent information in relational databases. For this, see Chapters 3 and 4 in this book. Other references include <ref> [3, 4, 9, 17] </ref>. 2 HANDLING INCONSISTENT INFORMATION There are many situations in which information and its contrary both appear in an information system. In some situations such inconsistencies could be useful, such as in a collection database, where they could initiate profitable enquiries.
Reference: [4] <author> A. Borgida and K. Williamson. </author> <title> Accommodating exceptions in databases and refining the schema by learning from them. </title> <booktitle> In Proceedings of the Eleventh International Conference on Very Large Data Bases (Stockholm, </booktitle> <address> Sweden, </address> <month> August 21-23), </month> <pages> pages 72-81, </pages> <year> 1985. </year>
Reference-contexts: We conclude in Section 5 with a brief summary. Note that in this chapter we do not review the literature on handling inconsistent information in relational databases. For this, see Chapters 3 and 4 in this book. Other references include <ref> [3, 4, 9, 17] </ref>. 2 HANDLING INCONSISTENT INFORMATION There are many situations in which information and its contrary both appear in an information system. In some situations such inconsistencies could be useful, such as in a collection database, where they could initiate profitable enquiries.
Reference: [5] <author> W. A. Carnielli, L. Fari~nas del Cerro, and M. Lima-Marques. </author> <title> Contextual negation and reasoning with contradiction. </title> <booktitle> In Proceedings of the Twelfth International Joint Conference on Artificial Intelligence (Sydney, </booktitle> <address> Australia, </address> <month> August), </month> <pages> pages 532-537, </pages> <year> 1991. </year>
Reference-contexts: For this we consider the system C ! of da Costa [7] that is formalized by the following proof method of Carnielli et al <ref> [5, 6] </ref>. First, da Costa introduces the notion of a well-behaved formula: :(ff ^ :ff) is not valid in general, but if it does hold for a formula ff, it is a well-behaved formula, and is denoted ff ffi .
Reference: [6] <author> W. A. Carnielli and M. Lima-Marques. </author> <title> Reasoning under inconsistent knowledge. </title> <journal> Journal of Applied Non-Classical Logics, </journal> <volume> 2: </volume> <pages> 49-79, </pages> <year> 1992. </year>
Reference-contexts: For this we consider the system C ! of da Costa [7] that is formalized by the following proof method of Carnielli et al <ref> [5, 6] </ref>. First, da Costa introduces the notion of a well-behaved formula: :(ff ^ :ff) is not valid in general, but if it does hold for a formula ff, it is a well-behaved formula, and is denoted ff ffi .
Reference: [7] <author> N. da Costa. </author> <title> On the theory of inconsistent information. </title> <journal> Notre Dame Journal of Formal Logic, </journal> <volume> 15: </volume> <pages> 497-510, </pages> <year> 1974. </year> <title> Logical Handling of Inconsistent and Default Information 341 </title>
Reference-contexts: For this we consider the system C ! of da Costa <ref> [7] </ref> that is formalized by the following proof method of Carnielli et al [5, 6].
Reference: [8] <author> M. D'Agostino and D. Gabbay. </author> <title> Labelled refutation systems. In Proceedings of the Workshop on Theorem Proving with Analytic Tableaux and Related Methods (Marseilles, </title> <address> France, </address> <month> April), </month> <pages> pages 243-281, </pages> <year> 1993. </year>
Reference-contexts: Different applications of LDS are made possible by different definitions for the logical manipulation of formulae ff and for the algebraic manipulation of the labels i. Furthermore, many existing logics fit into the LDS framework, including temporal logics [10], modal and many-valued logics <ref> [8] </ref>, resource logics [15], and nonmonotonic logics [13, 11, 16]. 4.1 LDS for Default Logic We begin by showing how default logic can be handled by LDS.
Reference: [9] <author> H. Dreizen and S. Chang. </author> <title> Imprecise schema: A rationale for relations with embedded subrelations. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(4): </volume> <pages> 447-479, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: We conclude in Section 5 with a brief summary. Note that in this chapter we do not review the literature on handling inconsistent information in relational databases. For this, see Chapters 3 and 4 in this book. Other references include <ref> [3, 4, 9, 17] </ref>. 2 HANDLING INCONSISTENT INFORMATION There are many situations in which information and its contrary both appear in an information system. In some situations such inconsistencies could be useful, such as in a collection database, where they could initiate profitable enquiries.
Reference: [10] <author> M. Finger and D. Gabbay. </author> <title> Labelled database management system. </title> <booktitle> In Proceedings of the International Conference on Database Theory, volume 646 of Lecture Notes in Computer Science, </booktitle> <pages> pages 188-200. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Different applications of LDS are made possible by different definitions for the logical manipulation of formulae ff and for the algebraic manipulation of the labels i. Furthermore, many existing logics fit into the LDS framework, including temporal logics <ref> [10] </ref>, modal and many-valued logics [8], resource logics [15], and nonmonotonic logics [13, 11, 16]. 4.1 LDS for Default Logic We begin by showing how default logic can be handled by LDS.
Reference: [11] <author> D. Gabbay. </author> <title> Abduction in labelled deductive systems: A conceptual abstract. In Symbolic and Quantitative Approaches to Uncertainty, </title> <booktitle> volume 548 of Lecture Notes in Computer Science, </booktitle> <pages> pages 3-12. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Furthermore, many existing logics fit into the LDS framework, including temporal logics [10], modal and many-valued logics [8], resource logics [15], and nonmonotonic logics <ref> [13, 11, 16] </ref>. 4.1 LDS for Default Logic We begin by showing how default logic can be handled by LDS. We assume the usual set of logical formulae, which we denote F , and we label each item in F with the symbol 0.
Reference: [12] <author> D. Gabbay. </author> <title> Labelled deductive systems. </title> <type> Technical report, </type> <institution> Centrum fur Informations und Sprachverabeitung, Universitat Munchen, </institution> <year> 1991. </year>
Reference-contexts: This approach has driven the development of a general framework, called Labeled Deductive Systems (LDS), for presenting logics that handle labeled formulae <ref> [12, 14] </ref>. The basic unit of information in LDS is a labeled formula i : ff, where i is a label, and ff is an unlabeled formula. A logic can then be defined in terms of Logical Handling of Inconsistent and Default Information 333 allowed operations on the labeled formulae.
Reference: [13] <author> D. Gabbay. </author> <title> Theoretical foundations for non-monotonic reasoning, part 2: Structured non-monotonic theories. </title> <booktitle> In Proceedings of Scandinavian Conference on Artificial Intelligence, </booktitle> <pages> pages 19-40. </pages> <publisher> IOS Press, </publisher> <year> 1991. </year>
Reference-contexts: Furthermore, many existing logics fit into the LDS framework, including temporal logics [10], modal and many-valued logics [8], resource logics [15], and nonmonotonic logics <ref> [13, 11, 16] </ref>. 4.1 LDS for Default Logic We begin by showing how default logic can be handled by LDS. We assume the usual set of logical formulae, which we denote F , and we label each item in F with the symbol 0.
Reference: [14] <author> D. Gabbay. </author> <title> Labelled deductive systems: A position paper. </title> <booktitle> In Logic Colloquium 90, volume 2 of Lecture Notes in Logic, </booktitle> <pages> pages 66-88. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This approach has driven the development of a general framework, called Labeled Deductive Systems (LDS), for presenting logics that handle labeled formulae <ref> [12, 14] </ref>. The basic unit of information in LDS is a labeled formula i : ff, where i is a label, and ff is an unlabeled formula. A logic can then be defined in terms of Logical Handling of Inconsistent and Default Information 333 allowed operations on the labeled formulae.
Reference: [15] <author> D. Gabbay and R. de Queiroz. </author> <title> Extending the Curry-Howard interpretation to linear, relevant and other resource logics. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 57: </volume> <pages> 1319-1366, </pages> <year> 1992. </year>
Reference-contexts: Different applications of LDS are made possible by different definitions for the logical manipulation of formulae ff and for the algebraic manipulation of the labels i. Furthermore, many existing logics fit into the LDS framework, including temporal logics [10], modal and many-valued logics [8], resource logics <ref> [15] </ref>, and nonmonotonic logics [13, 11, 16]. 4.1 LDS for Default Logic We begin by showing how default logic can be handled by LDS. We assume the usual set of logical formulae, which we denote F , and we label each item in F with the symbol 0.
Reference: [16] <author> A. Hunter. </author> <title> A conceptualization of preferences in non-monotonic proof theories. </title> <booktitle> In Logics in AI, volume 633 of Lecture Notes in Computer Science, </booktitle> <pages> pages 174-188. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Furthermore, many existing logics fit into the LDS framework, including temporal logics [10], modal and many-valued logics [8], resource logics [15], and nonmonotonic logics <ref> [13, 11, 16] </ref>. 4.1 LDS for Default Logic We begin by showing how default logic can be handled by LDS. We assume the usual set of logical formulae, which we denote F , and we label each item in F with the symbol 0.
Reference: [17] <author> P. King and C. </author> <title> Small. Default databases and incomplete information. </title> <journal> Computer Journal, </journal> <volume> 34: </volume> <pages> 239-244, </pages> <year> 1991. </year>
Reference-contexts: We conclude in Section 5 with a brief summary. Note that in this chapter we do not review the literature on handling inconsistent information in relational databases. For this, see Chapters 3 and 4 in this book. Other references include <ref> [3, 4, 9, 17] </ref>. 2 HANDLING INCONSISTENT INFORMATION There are many situations in which information and its contrary both appear in an information system. In some situations such inconsistencies could be useful, such as in a collection database, where they could initiate profitable enquiries.
Reference: [18] <author> J. Martins and S. Shapiro. </author> <title> A model of belief revision. </title> <journal> Artificial Intelligence, </journal> <volume> 35: </volume> <pages> 25-79, </pages> <year> 1988. </year>
Reference-contexts: For example, paraconsistent logics can be used as a formal basis for truth maintenance systems, which are meant to partition the database into consistent subsets of data (for example, <ref> [18] </ref>). 3 HANDLING DEFAULT INFORMATION It is noteworthy that practical reasoning relies much more on exploiting general rules (i.e., rules that are not necessarily universal) than on a myriad of individual facts. General rules tend to be less than perfectly accurate and may therefore have exceptions.
Reference: [19] <author> R. Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13: </volume> <pages> 187-214, </pages> <year> 1980. </year>
Reference-contexts: Applying, the new rule now, yields Exception (Smith), violating the proviso imposed on the earlier application, and thus voiding it. To summarize, default logic <ref> [19] </ref> aims at formalizing reasoning from default information by means of formulas of classical logic and the so-called default rules, namely the expressions ff : fi where ff, fi, and fl are formulas of classical logic.
References-found: 19

