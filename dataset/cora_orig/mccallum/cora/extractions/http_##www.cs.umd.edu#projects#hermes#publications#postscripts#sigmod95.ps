URL: http://www.cs.umd.edu/projects/hermes/publications/postscripts/sigmod95.ps
Refering-URL: http://www.cs.umd.edu/projects/hermes/publications/abstracts/sigmod95.html
Root-URL: 
Email: lu@sol.cs.bucknell.edu  moer@gom.informatik.rwth-aachen.de  schue@ira.uka.de  vs@cs.umd.edu  
Title: Efficient Maintenance of Materialized Mediated Views  
Author: James Lu Guido Moerkotte Joachim Schu V.S. Subrahmanian 
Address: RWTH Aachen  Karlsruhe  
Affiliation: Bucknell University  Lehrstuhl fur Informatik III  Universitat  University of Maryland  
Abstract: Integrating data and knowledge from multiple heterogeneous sources | like databases, knowledge bases or specific software packages | is often required for answering certain queries. Recently, a powerful framework for defining mediated views spanning multiple knowledge bases by a set of constrained rules (cf. work of Kanellakis et. al. [27]) was proposed [39, 5, 26]. Within this paper, we investigate the materialization of these views by unfolding the view definition and the efficient maintenance of the resulting materialized mediated view in case of updates. Thereby, we consider two kinds of updates: updates to the view and updates to the underlying sources. For each of these two cases several efficient algorithms maintaining materialized mediated views are given. We improve on previous algorithms like the DRed algorithm [22] and introduce a new fixpoint operator W P which | opposed to the standard fixpoint operator T P [19] | allows us to correctly capture the update's semantics without any recomputation of the materialized view.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and view. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: This problem is called the view update problem and has been discussed extensively for relational [6, 13, 15], deductive [6, 32, 42, 43], and object-oriented <ref> [1, 14, 31, 35] </ref> databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [2] <author> S. Abiteboul, S. Cluet, and T. Milo. </author> <title> Querying and updating the file. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 73-84, </pages> <year> 1993. </year>
Reference-contexts: The most prominent example of such a source is the file. Lately, it was proposed to integrate (structured) files and object bases by providing an object base view on the file and a file view upon the object base <ref> [2, 20] </ref>. Again, though the means by which mediators are defined are different from the traditional ones, they form the basis for the integration. Another also recent but quite different application area for mediators are cooperative intelligent agents [10].
Reference: [3] <author> S. Adal and R. Emery. </author> <title> (1994) A Uniform Framework for Integrating Knowledge in Heterogeneous Knowledge Systems, </title> <note> to appear in Proceedings of ICDE. </note>
Reference-contexts: Section 5 discusses related work and Section 6 concludes the paper. 2 Preliminaries and Motivating Example 2.1 Syntax and Semantics In this section, we will briefly describe the basic theory behind mediated systems proposed in <ref> [26, 39, 4, 5, 3] </ref>. Illustration is provided via the HERMES implementation. <p> The key idea behind a mediated system is that constraints provide the link to external sources, whether they be databases, object bases, or other knowledge sources. This idea is developed extensively in <ref> [26, 39, 4, 5, 3] </ref> and we do not elaborate on them here.
Reference: [4] <author> S. Adal and V.S. Subrahmanian. </author> <title> (1993) Amalgamating Knowledge Bases, II: Algorithms, Data Structures and Query Processing, </title> <note> submitted for journal publication. </note>
Reference-contexts: Section 5 discusses related work and Section 6 concludes the paper. 2 Preliminaries and Motivating Example 2.1 Syntax and Semantics In this section, we will briefly describe the basic theory behind mediated systems proposed in <ref> [26, 39, 4, 5, 3] </ref>. Illustration is provided via the HERMES implementation. <p> The key idea behind a mediated system is that constraints provide the link to external sources, whether they be databases, object bases, or other knowledge sources. This idea is developed extensively in <ref> [26, 39, 4, 5, 3] </ref> and we do not elaborate on them here. <p> In its current form, HERMES integrates INGRES, PARADOX, path planning packages developed by the US Army, Face Recognition packages used in Federal Law Enforcement, spatial data structures, a text database, and a pictorial database. Descriptions of the theory of HERMES may be found in <ref> [40, 4, 5, 39, 40, 41] </ref> in particular, [26] shows that HERMES generalizes constrained databases as proposed by Kanellakis et. al. [27]. In this paper, we have dealt with the problem of efficiently maintaining materialized mediated views such as those that may occur when any constrained database system is updated.
Reference: [5] <author> S. Adal and V.S. Subrahmanian. </author> <title> (1994) Amalgamating Knowledge Bases, III: </title> <journal> Distributed Mediators, </journal> <note> to appear in Journal of Cooperative Information Systems, </note> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Another also recent but quite different application area for mediators are cooperative intelligent agents [10]. Another powerful technique | based on constraint logic | for integrating multiple knowledge bases is introduced in <ref> [39, 5, 26] </ref> and is based, in part, on the ideas of constrained databases due to Kanellakis, Kuper and Revesz [27]. While this work examines a framework for expressing mediated views, the paper [41] describes a concrete implementation of one such mediating system called HERMES (HEterogeneous Reasoning and MEdiator System). <p> Section 5 discusses related work and Section 6 concludes the paper. 2 Preliminaries and Motivating Example 2.1 Syntax and Semantics In this section, we will briefly describe the basic theory behind mediated systems proposed in <ref> [26, 39, 4, 5, 3] </ref>. Illustration is provided via the HERMES implementation. <p> The key idea behind a mediated system is that constraints provide the link to external sources, whether they be databases, object bases, or other knowledge sources. This idea is developed extensively in <ref> [26, 39, 4, 5, 3] </ref> and we do not elaborate on them here. <p> In its current form, HERMES integrates INGRES, PARADOX, path planning packages developed by the US Army, Face Recognition packages used in Federal Law Enforcement, spatial data structures, a text database, and a pictorial database. Descriptions of the theory of HERMES may be found in <ref> [40, 4, 5, 39, 40, 41] </ref> in particular, [26] shows that HERMES generalizes constrained databases as proposed by Kanellakis et. al. [27]. In this paper, we have dealt with the problem of efficiently maintaining materialized mediated views such as those that may occur when any constrained database system is updated.
Reference: [6] <author> F. Bancilhon and N. Spyratos. </author> <title> Update semantics and relational views. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 6(4) </volume> <pages> 557-575, </pages> <year> 1981. </year>
Reference-contexts: If an update of the first kind occurs to a view, whether materialized or not, the problem occurs on how to reflect the update correctly by changing the base tables appropriately. This problem is called the view update problem and has been discussed extensively for relational <ref> [6, 13, 15] </ref>, deductive [6, 32, 42, 43], and object-oriented [1, 14, 31, 35] databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source. <p> This problem is called the view update problem and has been discussed extensively for relational [6, 13, 15], deductive <ref> [6, 32, 42, 43] </ref>, and object-oriented [1, 14, 31, 35] databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [7] <author> M. Baudinet, M. Niezette, P. Wolper. </author> <title> (1991) On the Representation of Infinite Temporal Data and Queries, </title> <booktitle> in Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <address> Denver, Colorado, </address> <month> May </month> <year> 1991, </year> <month> pp.280-290 </month>
Reference: [8] <author> J. Blakeley, N. Coburn, and P.-A. Larson. </author> <title> Updating derived relations: Detecting irrelevant and autonomously computable updates. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <year> 1989. </year>
Reference-contexts: Within the traditional context, the second case occurs if an update to a base table occurs which possibly affects a materialized view. The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 <ref> [8, 23, 38] </ref> and deductive databases [30, 24, 21, 44, 37]. The same problem occurs also for the materialization of functions within object bases [28]: if the values of some object's attributes change, the materialized function value becomes invalid. <p> Likewise, f t;t+1 (&lt; args &gt;) is the set of objects returned by executing function f at time t that are not returned when f is executed at time t + 1. Note that the efficient computation of the difference between two successive database states has been extensively studied <ref> [8, 28, 30, 23, 38] </ref>. However, as we will see, we do not need the difference explicitly for our view maintenance mechanism. We only use it to investigate the effects of an update to an external function onto a materialized mediated view if T P is used.
Reference: [9] <author> J. Chomicki. </author> <title> (1990) Polynomial Time Query Processing in Temporal Deductive Databases, </title> <booktitle> in Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <address> Nashville, Tennessee, </address> <month> April </month> <year> 1990, </year> <pages> pp. 379-391 </pages>
Reference: [10] <institution> Communications of the ACM 37 (7). </institution> <note> Intelligent agents (Special Issue), </note> <month> July </month> <year> 1994. </year>
Reference-contexts: Again, though the means by which mediators are defined are different from the traditional ones, they form the basis for the integration. Another also recent but quite different application area for mediators are cooperative intelligent agents <ref> [10] </ref>. Another powerful technique | based on constraint logic | for integrating multiple knowledge bases is introduced in [39, 5, 26] and is based, in part, on the ideas of constrained databases due to Kanellakis, Kuper and Revesz [27].
Reference: [11] <author> Stefano Ceri and Jennifer Widom. </author> <title> Deriving Production Rules for Incremental View Maintenance. </title> <booktitle> In 17th VLDB, </booktitle> <year> 1991. </year>
Reference-contexts: To some extent, this has already been done in 18 this paper for instance, the DRed algorithm presented in [22] has been extended to handle deletions in constrained and mediated databases. The relationship between the DRed algorithm and algorithms in <ref> [11, 12, 44, 30] </ref> has been discussed in detail in [22] however, none of these algorithms deal with constraints, and they all assume that a materialized view contains only ground, fully instantiated tuples assumptions that are removed in this paper.
Reference: [12] <author> Stefano Ceri and Jennifer Widom. </author> <title> Deriving Incremental Production Rules for Deductive Data. </title> <type> IBM RJ 9071, </type> <institution> IBM Almaden, </institution> <year> 1992. </year>
Reference-contexts: To some extent, this has already been done in 18 this paper for instance, the DRed algorithm presented in [22] has been extended to handle deletions in constrained and mediated databases. The relationship between the DRed algorithm and algorithms in <ref> [11, 12, 44, 30] </ref> has been discussed in detail in [22] however, none of these algorithms deal with constraints, and they all assume that a materialized view contains only ground, fully instantiated tuples assumptions that are removed in this paper.
Reference: [13] <author> C.C. Cosmadakis and C.H. Papadmitriou. </author> <title> Updates of relational views. </title> <journal> Journal of the ACM, </journal> <volume> 31(4) </volume> <pages> 742-760, </pages> <year> 1984. </year>
Reference-contexts: If an update of the first kind occurs to a view, whether materialized or not, the problem occurs on how to reflect the update correctly by changing the base tables appropriately. This problem is called the view update problem and has been discussed extensively for relational <ref> [6, 13, 15] </ref>, deductive [6, 32, 42, 43], and object-oriented [1, 14, 31, 35] databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [14] <author> U. Dayal. </author> <title> Queries and views in a object-oriented databases. </title> <booktitle> In Int. Workshop on Database Programming Languages, </booktitle> <year> 1989. </year> <month> 20 </month>
Reference-contexts: This problem is called the view update problem and has been discussed extensively for relational [6, 13, 15], deductive [6, 32, 42, 43], and object-oriented <ref> [1, 14, 31, 35] </ref> databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [15] <author> U. Dayal and P. Bernstein. </author> <title> On the correct translation of update operations on relational views. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7(3), </volume> <year> 1982. </year>
Reference-contexts: If an update of the first kind occurs to a view, whether materialized or not, the problem occurs on how to reflect the update correctly by changing the base tables appropriately. This problem is called the view update problem and has been discussed extensively for relational <ref> [6, 13, 15] </ref>, deductive [6, 32, 42, 43], and object-oriented [1, 14, 31, 35] databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [16] <author> U. Dayal and H. Hwang. </author> <title> View definition and generalization for database integration in a multi-database system. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-10(6):628-644, </volume> <year> 1984. </year>
Reference-contexts: Traditional research on view or schema integration, and interoperability of databases concentrates on integrating databases, possibly with different underlying schemata or even data models <ref> [16, 29, 33, 36] </ref>. The basic idea often is to aim for a global integrating schema or view whose definition mediates between different databases. Only lately, investigations started to integrate other sources of data available. The most prominent example of such a source is the file.
Reference: [17] <author> J. Doyle. </author> <title> A Truth Maintenance System. </title> <journal> Artificial Intelligence, </journal> <volume> vol. 12, </volume> <year> 1979. </year>
Reference-contexts: Neither of which possesses a support that contains a sub-support in P OU T . Hence the algorithm terminates. 2 Several observations are in order here. First, the supports that we use are similar to justifications used in truth-maintenance systems <ref> [17] </ref> in that they provide a "history" of the derivation of constraint atoms. However, they serve different purposes.
Reference: [18] <author> M. Falaschi, G. Levi, M. Martelli, C. </author> <title> Palamidessi (1991) A New Declarative Semantics for Logic Programs, </title> <type> ICLP, </type> <year> 1991 </year>
Reference: [19] <author> M. Gabbrielli, G. Levi. </author> <title> (1991) Modelling answer constraints in Constraint Logic Programs, </title> <type> ICLP, </type> <year> 1991, </year> <month> pp.238-251, </month>
Reference-contexts: For updates of the first kind, we depart from using the standard fixpoint operation T P as defined by Gabrielli and Levi <ref> [19] </ref>. Instead, we introduce the fixpoint operator W P . W P is able to capture updates of the second kind without any recomputation of the materialized mediated view while maintaining the semantics of T P and correctly capturing the update. The rest of the paper is organized as follows. <p> This operator was originally defined by Gabbrielli and Levi <ref> [19] </ref> who used it to define a non-ground representation of the ground least Herbrand model of a constrained database/logic program.
Reference: [20] <author> N. Gehani, H. Jagadish, and W. Roome. OdeFS: </author> <title> A file system interface to an object-oriented database. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 249-260, </pages> <year> 1994. </year>
Reference-contexts: The most prominent example of such a source is the file. Lately, it was proposed to integrate (structured) files and object bases by providing an object base view on the file and a file view upon the object base <ref> [2, 20] </ref>. Again, though the means by which mediators are defined are different from the traditional ones, they form the basis for the integration. Another also recent but quite different application area for mediators are cooperative intelligent agents [10].
Reference: [21] <author> Ashish Gupta, Dinesh Katiyar, and Inderpal Singh Mumick. </author> <title> Counting Solutions to the View Maintenance Problem. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 [8, 23, 38] and deductive databases <ref> [30, 24, 21, 44, 37] </ref>. The same problem occurs also for the materialization of functions within object bases [28]: if the values of some object's attributes change, the materialized function value becomes invalid. <p> This strategy is unsuitable for databases because we would like view maintenance to lead to a single resulting materialized view, not a possibly exponential number of materialized views such as may be the case with TMSs. Secondly, the algorithm differs from the counting algorithm of <ref> [21] </ref> since here, each constraint atom in the materialized view corresponds to a single proof. The counting algorithm maintains a count of the number of proofs of an atom, but does not distinguish between different derivations. <p> [22] may be extended to handle constraints. * We have developed a unique straight delete algorithm for deletion that uses supports to accomplish deletions of constrained atoms; this algorithm is brand new, and, even when constraints are absent, it improves upon the counting method (that can lead to infinite counts) <ref> [21] </ref> and also improves upon the re-derivation algorithm (as it requires no re-derivations.
Reference: [22] <author> A. Gupta, </author> <title> I.S. Mumick and V.S. Subrahmanian. Maintaining Views Incrementally, </title> <booktitle> Proc. 1993 ACM SIGMOD Conf. on Management of Data, </booktitle> <address> Washington, DC. </address>
Reference-contexts: To our knowledge, there are currently no methods to incrementally maintain views in constrained databases. 2. We show for updates of the second kind that even in the case of unconstrained databases, such as those considered by Gupta, Mumick and Subrahmanian <ref> [22] </ref>, this approach leads to a simpler and more efficient deletion algorithm than the deletion algorithm, DRed presented in [22]. 3. For updates of the first kind, we depart from using the standard fixpoint operation T P as defined by Gabrielli and Levi [19]. <p> We show for updates of the second kind that even in the case of unconstrained databases, such as those considered by Gupta, Mumick and Subrahmanian <ref> [22] </ref>, this approach leads to a simpler and more efficient deletion algorithm than the deletion algorithm, DRed presented in [22]. 3. For updates of the first kind, we depart from using the standard fixpoint operation T P as defined by Gabrielli and Levi [19]. Instead, we introduce the fixpoint operator W P . <p> Any clause in P with a head different from A ( ~ X) is in P 0 . 8 We present two algorithms for accomplishing the above deletion. The first algorithm extends the DRed algorithm of Gupta, Mumick and Subrahmanian <ref> [22] </ref> to the mediated case. <p> However, considering the orthogonality of the approaches, it might be worthwhile to investigate an integration of this work with our approach. To some extent, this has already been done in 18 this paper for instance, the DRed algorithm presented in <ref> [22] </ref> has been extended to handle deletions in constrained and mediated databases. The relationship between the DRed algorithm and algorithms in [11, 12, 44, 30] has been discussed in detail in [22] however, none of these algorithms deal with constraints, and they all assume that a materialized view contains only ground, <p> To some extent, this has already been done in 18 this paper for instance, the DRed algorithm presented in <ref> [22] </ref> has been extended to handle deletions in constrained and mediated databases. The relationship between the DRed algorithm and algorithms in [11, 12, 44, 30] has been discussed in detail in [22] however, none of these algorithms deal with constraints, and they all assume that a materialized view contains only ground, fully instantiated tuples assumptions that are removed in this paper. <p> To our knowledge, this is the first paper that addresses the view maintenance problem for constrained databases and/or for heterogeneous, mediated systems. The main contributions we have made are the following: * We have shown how the DRed deletion algorithm of Gupta et. al. <ref> [22] </ref> may be extended to handle constraints. * We have developed a unique straight delete algorithm for deletion that uses supports to accomplish deletions of constrained atoms; this algorithm is brand new, and, even when constraints are absent, it improves upon the counting method (that can lead to infinite counts) [21]
Reference: [23] <author> E. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 440-453, </pages> <year> 1987. </year>
Reference-contexts: Within the traditional context, the second case occurs if an update to a base table occurs which possibly affects a materialized view. The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 <ref> [8, 23, 38] </ref> and deductive databases [30, 24, 21, 44, 37]. The same problem occurs also for the materialization of functions within object bases [28]: if the values of some object's attributes change, the materialized function value becomes invalid. <p> Likewise, f t;t+1 (&lt; args &gt;) is the set of objects returned by executing function f at time t that are not returned when f is executed at time t + 1. Note that the efficient computation of the difference between two successive database states has been extensively studied <ref> [8, 28, 30, 23, 38] </ref>. However, as we will see, we do not need the difference explicitly for our view maintenance mechanism. We only use it to investigate the effects of an update to an external function onto a materialized mediated view if T P is used.
Reference: [24] <author> John V. Harrison and Suzanne Dietrich. </author> <title> Maintenance of Materialized Views in a Deductive Database: An Update Propagation Approach. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 [8, 23, 38] and deductive databases <ref> [30, 24, 21, 44, 37] </ref>. The same problem occurs also for the materialization of functions within object bases [28]: if the values of some object's attributes change, the materialized function value becomes invalid.
Reference: [25] <author> J. Jaffar, J.-L. Lassez. </author> <title> Constraint Logic Programming In. </title> <booktitle> Proceedings of Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 111-119. </pages> <publisher> ACM, </publisher> <address> New York, USA, </address> <year> 1987 </year>
Reference-contexts: The reader may specifically note that even though negation occurs in the body of clauses in P [ , this negation occurs in the constraint part of the clause, and hence, the resulting constrained database still has a least fixpoint <ref> [25] </ref>. We now present an algorithm that incrementally inserts a constrained atom into a materialized view. Algorithm 3 (Constrained Atom Insertion) 1. Unfold the constraint base fact to be inserted with respect to the original constrained database P .
Reference: [26] <author> J. Lu, A. Nerode and V.S. Subrahmanian. </author> <title> Hybrid Knowledge Bases, </title> <note> to appear in IEEE Transactions on Data and Knowledge Engineering. </note>
Reference-contexts: Another also recent but quite different application area for mediators are cooperative intelligent agents [10]. Another powerful technique | based on constraint logic | for integrating multiple knowledge bases is introduced in <ref> [39, 5, 26] </ref> and is based, in part, on the ideas of constrained databases due to Kanellakis, Kuper and Revesz [27]. While this work examines a framework for expressing mediated views, the paper [41] describes a concrete implementation of one such mediating system called HERMES (HEterogeneous Reasoning and MEdiator System). <p> Section 5 discusses related work and Section 6 concludes the paper. 2 Preliminaries and Motivating Example 2.1 Syntax and Semantics In this section, we will briefly describe the basic theory behind mediated systems proposed in <ref> [26, 39, 4, 5, 3] </ref>. Illustration is provided via the HERMES implementation. <p> The key idea behind a mediated system is that constraints provide the link to external sources, whether they be databases, object bases, or other knowledge sources. This idea is developed extensively in <ref> [26, 39, 4, 5, 3] </ref> and we do not elaborate on them here. <p> not however, detract from the generality of the techniques described in the paper It can be shown (Example 2 presents one example of how to do this) that all the kinds of constraints considered by Kanellakis et. al. can be captured within this framework (Lu, Nerode, Subrahmanian present further details <ref> [26] </ref>). 2.2 Motivating Example We introduce a running example which also motivates our approach. This example has been addressed in the existing HERMES implementation [40]. <p> Figure 1 shows the logical arrangement of the domains being integrated. Example 2 (Constrained Databases) Kanellakis et. al. [27] have introduced the concept of constrained databases, which can be modeled within our framework (a formal proof is contained in <ref> [26] </ref>). <p> How to do this is not the topic of this paper, see <ref> [26] </ref> for details). Likewise, plus (X; Y) returns the singleton set fX + Yg. <p> Descriptions of the theory of HERMES may be found in [40, 4, 5, 39, 40, 41] in particular, <ref> [26] </ref> shows that HERMES generalizes constrained databases as proposed by Kanellakis et. al. [27]. In this paper, we have dealt with the problem of efficiently maintaining materialized mediated views such as those that may occur when any constrained database system is updated.
Reference: [27] <author> P. Kanellakis, G. Kuper and P. Revesz. </author> <title> (1990) Constraint Query Languages, </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <address> pps 299-313. </address>
Reference-contexts: Another powerful technique | based on constraint logic | for integrating multiple knowledge bases is introduced in [39, 5, 26] and is based, in part, on the ideas of constrained databases due to Kanellakis, Kuper and Revesz <ref> [27] </ref>. While this work examines a framework for expressing mediated views, the paper [41] describes a concrete implementation of one such mediating system called HERMES (HEterogeneous Reasoning and MEdiator System). <p> Taking materialized views to be sets of constrained atoms leads to a number of advantages: 1. First of all, it allows us to perform updates to constrained databases such as those described by Kanellakis et. al. <ref> [27] </ref>. To our knowledge, there are currently no methods to incrementally maintain views in constrained databases. 2. <p> The above three clauses express the mediator for this example in its entirety. Figure 1 shows the logical arrangement of the domains being integrated. Example 2 (Constrained Databases) Kanellakis et. al. <ref> [27] </ref> have introduced the concept of constrained databases, which can be modeled within our framework (a formal proof is contained in [26]). <p> Descriptions of the theory of HERMES may be found in [40, 4, 5, 39, 40, 41] in particular, [26] shows that HERMES generalizes constrained databases as proposed by Kanellakis et. al. <ref> [27] </ref>. In this paper, we have dealt with the problem of efficiently maintaining materialized mediated views such as those that may occur when any constrained database system is updated.
Reference: [28] <author> A. Kemper, C. Kilger, G. Moerkotte. </author> <title> Function Materialization in Object Bases: Design, Realization, </title> <journal> and Evaluation IEEE Transactions on Knowledge and Data Engineering, Vol.6, </journal> <volume> No.4, </volume> <month> August </month> <year> 1994 </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 [8, 23, 38] and deductive databases [30, 24, 21, 44, 37]. The same problem occurs also for the materialization of functions within object bases <ref> [28] </ref>: if the values of some object's attributes change, the materialized function value becomes invalid. <p> Likewise, f t;t+1 (&lt; args &gt;) is the set of objects returned by executing function f at time t that are not returned when f is executed at time t + 1. Note that the efficient computation of the difference between two successive database states has been extensively studied <ref> [8, 28, 30, 23, 38] </ref>. However, as we will see, we do not need the difference explicitly for our view maintenance mechanism. We only use it to investigate the effects of an update to an external function onto a materialized mediated view if T P is used. <p> However, the work on view maintenance which was partially cited in the introduction of this paper becomes relevant as soon as we want to guarantee an efficient evaluation of the in predicate by materializing the external function calls. Especially for the integration of software packages, the methods presented in <ref> [28] </ref> become relevant. 6 Conclusion and future work It is generally well accepted that constrained databases are very important, increasing the expressive power of Datalog considerably. In this paper, we have developed techniques to incrementally update views in constrained databases.
Reference: [29] <author> R. Krishnamurthy, W. Litwin, and W. Kent. </author> <title> Language features for interoperability of databases with schematic discrepancies. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 40-49, </pages> <year> 1991. </year>
Reference-contexts: Traditional research on view or schema integration, and interoperability of databases concentrates on integrating databases, possibly with different underlying schemata or even data models <ref> [16, 29, 33, 36] </ref>. The basic idea often is to aim for a global integrating schema or view whose definition mediates between different databases. Only lately, investigations started to integrate other sources of data available. The most prominent example of such a source is the file.
Reference: [30] <author> V. Kuchenhoff. </author> <title> On the efficient computation of the difference between consecutive database states. </title> <booktitle> In Proc. Int. Conf. on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 478-502, </pages> <year> 1991. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 [8, 23, 38] and deductive databases <ref> [30, 24, 21, 44, 37] </ref>. The same problem occurs also for the materialization of functions within object bases [28]: if the values of some object's attributes change, the materialized function value becomes invalid. <p> Likewise, f t;t+1 (&lt; args &gt;) is the set of objects returned by executing function f at time t that are not returned when f is executed at time t + 1. Note that the efficient computation of the difference between two successive database states has been extensively studied <ref> [8, 28, 30, 23, 38] </ref>. However, as we will see, we do not need the difference explicitly for our view maintenance mechanism. We only use it to investigate the effects of an update to an external function onto a materialized mediated view if T P is used. <p> To some extent, this has already been done in 18 this paper for instance, the DRed algorithm presented in [22] has been extended to handle deletions in constrained and mediated databases. The relationship between the DRed algorithm and algorithms in <ref> [11, 12, 44, 30] </ref> has been discussed in detail in [22] however, none of these algorithms deal with constraints, and they all assume that a materialized view contains only ground, fully instantiated tuples assumptions that are removed in this paper.
Reference: [31] <author> C. Medeiros and J.-C. Mamou. </author> <title> Interactive manipulation of object-oriented views. </title> <booktitle> In Proc. IEEE Conference on Data Engineering, </booktitle> <year> 1991. </year> <month> 21 </month>
Reference-contexts: This problem is called the view update problem and has been discussed extensively for relational [6, 13, 15], deductive [6, 32, 42, 43], and object-oriented <ref> [1, 14, 31, 35] </ref> databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [32] <author> G. </author> <title> Moerkotte and P.C. Lockemann. Reactive consistency control in deductive databases. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 16(4) </volume> <pages> 670-702, </pages> <year> 1991. </year>
Reference-contexts: This problem is called the view update problem and has been discussed extensively for relational [6, 13, 15], deductive <ref> [6, 32, 42, 43] </ref>, and object-oriented [1, 14, 31, 35] databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [33] <author> A. Motro. Superviews: </author> <title> Virtual integration of multiple databases. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 13(7) </volume> <pages> 785-798, </pages> <year> 1987. </year>
Reference-contexts: Traditional research on view or schema integration, and interoperability of databases concentrates on integrating databases, possibly with different underlying schemata or even data models <ref> [16, 29, 33, 36] </ref>. The basic idea often is to aim for a global integrating schema or view whose definition mediates between different databases. Only lately, investigations started to integrate other sources of data available. The most prominent example of such a source is the file.
Reference: [34] <author> I. S. Mumick. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> Ph.D. Thesis, </type> <institution> Stanford University, </institution> <address> CA 94305, </address> <year> 1991. </year>
Reference-contexts: This corresponds to an extension, to the case of constrained databases, of the well-known duplicate semantics proposed by Mumick <ref> [34] </ref> in the context of ordinary deductive databases. 3 Updating Views In our context, view updating deals with the following problem: given a constrained database P , a materialized view MMV, and an update u, compute a new materialized view that accurately reflects this update.
Reference: [35] <author> M. Scholl, C. Laasch, and M. Tresch. </author> <title> Updatable views in object-oriented databases. </title> <booktitle> In Proc. Int. Conf. on Deductive and Object-Oriented Databases (DOOD), </booktitle> <year> 1991. </year>
Reference-contexts: This problem is called the view update problem and has been discussed extensively for relational [6, 13, 15], deductive [6, 32, 42, 43], and object-oriented <ref> [1, 14, 31, 35] </ref> databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [36] <author> A. Sheth and J. Larson. </author> <title> Federated database systems for managing distributed, heterogeneous and autonomous databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(3) </volume> <pages> 183-236, </pages> <year> 1990. </year>
Reference-contexts: Traditional research on view or schema integration, and interoperability of databases concentrates on integrating databases, possibly with different underlying schemata or even data models <ref> [16, 29, 33, 36] </ref>. The basic idea often is to aim for a global integrating schema or view whose definition mediates between different databases. Only lately, investigations started to integrate other sources of data available. The most prominent example of such a source is the file.
Reference: [37] <author> Oded Shmueli and Alon Itai. </author> <title> Maintenance of Views. </title> <booktitle> In Sigmod Record, </booktitle> <volume> 14(2) </volume> <pages> 240-255, </pages> <year> 1984. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 [8, 23, 38] and deductive databases <ref> [30, 24, 21, 44, 37] </ref>. The same problem occurs also for the materialization of functions within object bases [28]: if the values of some object's attributes change, the materialized function value becomes invalid.
Reference: [38] <author> M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On rules, procedures, caching and views in data base systems. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 281-290, </pages> <year> 1990. </year>
Reference-contexts: Within the traditional context, the second case occurs if an update to a base table occurs which possibly affects a materialized view. The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 <ref> [8, 23, 38] </ref> and deductive databases [30, 24, 21, 44, 37]. The same problem occurs also for the materialization of functions within object bases [28]: if the values of some object's attributes change, the materialized function value becomes invalid. <p> Likewise, f t;t+1 (&lt; args &gt;) is the set of objects returned by executing function f at time t that are not returned when f is executed at time t + 1. Note that the efficient computation of the difference between two successive database states has been extensively studied <ref> [8, 28, 30, 23, 38] </ref>. However, as we will see, we do not need the difference explicitly for our view maintenance mechanism. We only use it to investigate the effects of an update to an external function onto a materialized mediated view if T P is used.
Reference: [39] <author> V.S. Subrahmanian. </author> <title> Amalgamating Knowledge Bases, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 19, 2, </volume> <pages> pps 291-331, </pages> <year> 1994. </year>
Reference-contexts: Another also recent but quite different application area for mediators are cooperative intelligent agents [10]. Another powerful technique | based on constraint logic | for integrating multiple knowledge bases is introduced in <ref> [39, 5, 26] </ref> and is based, in part, on the ideas of constrained databases due to Kanellakis, Kuper and Revesz [27]. While this work examines a framework for expressing mediated views, the paper [41] describes a concrete implementation of one such mediating system called HERMES (HEterogeneous Reasoning and MEdiator System). <p> Section 5 discusses related work and Section 6 concludes the paper. 2 Preliminaries and Motivating Example 2.1 Syntax and Semantics In this section, we will briefly describe the basic theory behind mediated systems proposed in <ref> [26, 39, 4, 5, 3] </ref>. Illustration is provided via the HERMES implementation. <p> The key idea behind a mediated system is that constraints provide the link to external sources, whether they be databases, object bases, or other knowledge sources. This idea is developed extensively in <ref> [26, 39, 4, 5, 3] </ref> and we do not elaborate on them here. <p> In its current form, HERMES integrates INGRES, PARADOX, path planning packages developed by the US Army, Face Recognition packages used in Federal Law Enforcement, spatial data structures, a text database, and a pictorial database. Descriptions of the theory of HERMES may be found in <ref> [40, 4, 5, 39, 40, 41] </ref> in particular, [26] shows that HERMES generalizes constrained databases as proposed by Kanellakis et. al. [27]. In this paper, we have dealt with the problem of efficiently maintaining materialized mediated views such as those that may occur when any constrained database system is updated.
Reference: [40] <author> V.S. Subrahmanian. </author> <title> Hybrid Knowledge Bases for Integrating Symbolic, Numeric and Image Data, </title> <booktitle> Proc. 1994 Intl. Workshop on Applied Imagery and Pattern Recognition, </booktitle> <address> Wash-ington DC, Oct. 1994, </address> <publisher> SPIE Press. </publisher>
Reference-contexts: This example has been addressed in the existing HERMES implementation <ref> [40] </ref>. <p> In its current form, HERMES integrates INGRES, PARADOX, path planning packages developed by the US Army, Face Recognition packages used in Federal Law Enforcement, spatial data structures, a text database, and a pictorial database. Descriptions of the theory of HERMES may be found in <ref> [40, 4, 5, 39, 40, 41] </ref> in particular, [26] shows that HERMES generalizes constrained databases as proposed by Kanellakis et. al. [27]. In this paper, we have dealt with the problem of efficiently maintaining materialized mediated views such as those that may occur when any constrained database system is updated.
Reference: [41] <author> V.S. Subrahmanian, S. Adali, A. Brink, R. Emery, A. Rajput, T.J. Rogers, R. Ross, and C. ward. </author> <title> (1994) HERMES: A Heterogeneous Reasoning and Mediator System, </title> <type> draft manuscript. </type>
Reference-contexts: While this work examines a framework for expressing mediated views, the paper <ref> [41] </ref> describes a concrete implementation of one such mediating system called HERMES (HEterogeneous Reasoning and MEdiator System). HERMES supports the integration of multiple databases and reasoning paradigms on both the PC/Windows and the SUN/Unix platforms and provides an environment which allows flexibility in adding new databases and software packages. <p> In order to answer the above query, we must be able to integrate the above software packages at the software level, as well as at the logical level. In this paper, we will not go into the software integration scheme it is described in <ref> [41] </ref>, but we will go into some details about the mediator syntax itself in order to define what "soundness and completeness" of view maintenance means, and in order to develop algorithms for view maintenance that are sound and complete. <p> In its current form, HERMES integrates INGRES, PARADOX, path planning packages developed by the US Army, Face Recognition packages used in Federal Law Enforcement, spatial data structures, a text database, and a pictorial database. Descriptions of the theory of HERMES may be found in <ref> [40, 4, 5, 39, 40, 41] </ref> in particular, [26] shows that HERMES generalizes constrained databases as proposed by Kanellakis et. al. [27]. In this paper, we have dealt with the problem of efficiently maintaining materialized mediated views such as those that may occur when any constrained database system is updated.
Reference: [42] <author> E. Teniente. </author> <title> Updating knowledge bases while maintaining their consistency. </title> <journal> VLDB Journal, </journal> <note> 1994. to appear. </note>
Reference-contexts: This problem is called the view update problem and has been discussed extensively for relational [6, 13, 15], deductive <ref> [6, 32, 42, 43] </ref>, and object-oriented [1, 14, 31, 35] databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source. <p> This kind of update affecting the view's definition is typically not treated within the view update literature. One exception are deductive databases, where the addition or deletion of rules to the definition of an intensional predicate is discussed <ref> [42] </ref>. However, they neither materialize nor preprocess the view for efficiency reasons. Within the traditional context, the second case occurs if an update to a base table occurs which possibly affects a materialized view.
Reference: [43] <author> A. Tomasic. </author> <title> View update translation via deduction and annotation. </title> <booktitle> In ICDT, </booktitle> <pages> pages 338-352, </pages> <year> 1988. </year>
Reference-contexts: This problem is called the view update problem and has been discussed extensively for relational [6, 13, 15], deductive <ref> [6, 32, 42, 43] </ref>, and object-oriented [1, 14, 31, 35] databases. However, our objective is slightly different. As motivated by an example in Section 2.2, we do not necessarily assume that an update occurring to a view has to be reflected within some underlying source.
Reference: [44] <author> Toni Urpi and Antoni Olive. </author> <title> A Method for Change Computation in Deductive Databases. </title> <booktitle> In 18th VLDB, </booktitle> <pages> pages 225-237, </pages> <year> 1992. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation 2 [8, 23, 38] and deductive databases <ref> [30, 24, 21, 44, 37] </ref>. The same problem occurs also for the materialization of functions within object bases [28]: if the values of some object's attributes change, the materialized function value becomes invalid. <p> To some extent, this has already been done in 18 this paper for instance, the DRed algorithm presented in [22] has been extended to handle deletions in constrained and mediated databases. The relationship between the DRed algorithm and algorithms in <ref> [11, 12, 44, 30] </ref> has been discussed in detail in [22] however, none of these algorithms deal with constraints, and they all assume that a materialized view contains only ground, fully instantiated tuples assumptions that are removed in this paper.
Reference: [45] <author> G. Wiederhold. </author> <title> (1993) Intelligent Integration of Information, </title> <booktitle> Proc. 1993 ACM SIGMOD Conf. on Management of Data, </booktitle> <address> pps 434-437. </address>
Reference-contexts: F30602-93-C-0241 (Order Nr. A716), and by an NSF Young Investigator award IRI-93-57756. James Lu was supported by the NSF under grant number CCR9225037. motivating example see Sec. 2.2.) In order to answer these queries, it is necessary to define a mediator <ref> [45, 46] </ref> integrating the different sources on a semantic level by providing an integrated view spanning these sources. Traditional research on view or schema integration, and interoperability of databases concentrates on integrating databases, possibly with different underlying schemata or even data models [16, 29, 33, 36].
Reference: [46] <author> G Wiederhold, S. Jajodia, and W. Litwin. </author> <title> Integrating temporal data in a heterogeneous environment. In Temporal Databases. </title> <address> Benjamin/Cummings, </address> <month> Jan </month> <year> 1993. </year> <month> 22 </month>
Reference-contexts: F30602-93-C-0241 (Order Nr. A716), and by an NSF Young Investigator award IRI-93-57756. James Lu was supported by the NSF under grant number CCR9225037. motivating example see Sec. 2.2.) In order to answer these queries, it is necessary to define a mediator <ref> [45, 46] </ref> integrating the different sources on a semantic level by providing an integrated view spanning these sources. Traditional research on view or schema integration, and interoperability of databases concentrates on integrating databases, possibly with different underlying schemata or even data models [16, 29, 33, 36].
References-found: 46

