URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/tygar/www/papers/replicated.secure/crypto87.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/tygar/www/publications.html
Root-URL: http://www.cs.cmu.edu
Title: How to Make Replicated Data Secure  
Author: Maurice P. Herlihy and J. D. Tygar 
Note: This research was sponsored by the Defense Advanced Research Projects Agency (DOD), ARPA Order Numbers 4864 and 4976, monitored by the Air Force Avionics Laboratory under Contracts F33615-84-K-1520 and N00039-84-C-0467.  
Date: August 1987  
Pubnum: CMU-CS-87-143  
Abstract: Many distributed systems manage some form of long-lived data, such as files or data bases. The performance and fault-tolerance of such systems may be enhanced if the repositories for the data are physically distributed. Nevertheless, distribution makes security more difficult, since it may be difficult to ensure that each repository is physically secure, particularly if the number of repositories is large. This paper proposes new techniques for ensuring the security of long-lived, physically distributed data. These techniques adapt replication protocols for fault-tolerance to the more demanding requirements of security. For a given threshold value, one set of protocols ensures that an adversary cannot ascertain the state of a data object by observing the contents of fewer than a threshold of repositories. These protocols are cheap; the message traffic needed to tolerate a given number of compromised repositories is only slightly more than the message traffic needed to tolerate the same number of failures. A second set of protocols ensures that an object's state cannot be altered by an adversary who can modify the contents of fewer than a threshold of repositories. These protocols are more expensive; to tolerate t-1 compromised repositories, clients executing certain operations must communicate with t-1 additional sites. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Alexi, B. Chor, O. Goldreich, and C. P. Schnorr. </author> <title> RSA and Rabin functions: certain parts are as hard as the whole. </title> <booktitle> In Proceedings, 25th IEEE Symposium on the Foundations of Computer Science. </booktitle> <month> November, </month> <year> 1984. </year> <note> To appear in SIAM J. on Computing. </note>
Reference-contexts: Given the current limits of complexity theory, we do not have a way of proving bit-security without making some assumption about the lower bound on an algorithmic problem. For example, it has been shown <ref> [1] </ref> that the RSA th [20] cryptosystem is bit-secure under the assumption that taking k roots modulo pq, a product of two large primes, cannot be done in randomized polynomial time and that the Rabin [15] signature schemes is bit-secure if factorization is not in randomized polynomial time. (These assumptions are
Reference: [2] <author> A. Birrell. </author> <title> Secure communication using remote procedure calls. </title> <journal> ACM Transactions on Computer Systems 3(1) </journal> <pages> 1-14, </pages> <month> February, </month> <year> 1985. </year>
Reference-contexts: To keep our presentation as straightforward as possible, we assume that a communications subsystem provides secure and authenticated communication using known protocols, e.g., <ref> [2, 14, 10, 8] </ref>. Here, we consider only attacks that bypass the communications subsystem, isolating some set of repositories and directly observing or modifying their data.
Reference: [3] <author> M. Blum and S. Micali. </author> <title> How to generate cryptographically strong sequences of pseudo-random bits. </title> <journal> SIAM J. on Computing 13(4) </journal> <pages> 850-864, </pages> <year> 1984. </year>
Reference-contexts: Background 2.1. Terminology We use two notions of cryptographic security in this paper. One notion, of bit-security, <ref> [3, 19] </ref>, implies that given ciphertext, no processor with randomized polynomial resources can derive information about any given bit in the corresponding cleartext with certainty greater than 1/2+e for any e &gt; 0.
Reference: [4] <author> B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. </author> <title> Verifiable secret sharing and achieving simultaneity in the presence of faults. </title> <booktitle> In Proceedings, 26th IEEE Symposium on the Foundations of Computer Science. </booktitle> <month> October, </month> <year> 1985. </year>
Reference-contexts: Unlike previous approaches, our protocol attacks the issues of security and fault-tolerance simultaneously with a single mechanism. Tompa and Woll [23] have given a stronger version of the secret sharing protocol that is also applicable to our model. Chor et al. <ref> [4] </ref> have given a ``verifiable secret sharing'' protocol which ensures that the dealer 8 cannot cheat. Chor and Rabin [5] have shown how this protocol can be used to generate bits with a high degree of independence in a Byzantine distributed system.
Reference: [5] <author> B. Chor and M. Rabin. </author> <title> Achieving independence in a logarithmic number of rounds. </title> <note> 1987. To appear, PODC 87. </note>
Reference-contexts: Tompa and Woll [23] have given a stronger version of the secret sharing protocol that is also applicable to our model. Chor et al. [4] have given a ``verifiable secret sharing'' protocol which ensures that the dealer 8 cannot cheat. Chor and Rabin <ref> [5] </ref> have shown how this protocol can be used to generate bits with a high degree of independence in a Byzantine distributed system. The verifiable secret sharing protocol can also be incorporated into our techniques, but it would be more expensive to do so.
Reference: [6] <author> W. Diffie and M. E. Hellman. </author> <title> New Directions in Cryptography. </title> <journal> IEEE Transactions on Information Theory IT-22(6):644-654, </journal> <month> Nov., </month> <year> 1976. </year>
Reference-contexts: More surprisingly, the registration penalty in Example 3 can be eliminated, as we show in the next section. 4. Public Key Secure Quorum Consensus In this section we describe a variant of SQC in which the bit-secure private key scheme is replaced by a bit-secure public key scheme <ref> [6] </ref>. Instead of a single key K, we use an encryption key K and a E decryption key K , where K cannot be derived from K with polynomial resources, and vice-versa.
Reference: [7] <author> D. K. Gifford. </author> <title> Weighted Voting for Replicated Data. </title> <booktitle> In Proceedings of the Seventh Symposium on Operating Systems Principles. ACM SIGOPS, </booktitle> <month> December, </month> <year> 1979. </year>
Reference-contexts: In particular, the availability of long-lived data can be enhanced by storing the data redundantly at multiple sites, a technique commonly known as replication <ref> [7, 11] </ref>. In this paper, we consider how replication protocols originally proposed to enhance fault-tolerance can be adapted to the more demanding requirements of security. <p> A quorum assignment associates each operation with a set of quorums. An operation's quorums determine its availability, and the constraints governing an object's quorum assignments determine the range of availability properties realizable by a replication method. A replicated file <ref> [7] </ref> is represented as a collection of timestamped versions, where timestamps are generated by logical clocks [12]. To read a file, a front-end reads the version from a read quorum of repositories and chooses the version with the latest timestamp.
Reference: [8] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> Proofs that yield nothing but the validity of their assertion. </title> <type> Preprint. </type>
Reference-contexts: To keep our presentation as straightforward as possible, we assume that a communications subsystem provides secure and authenticated communication using known protocols, e.g., <ref> [2, 14, 10, 8] </ref>. Here, we consider only attacks that bypass the communications subsystem, isolating some set of repositories and directly observing or modifying their data.
Reference: [9] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic encryption and how to play mental poker. </title> <booktitle> In Proceedings of the 14th Symposium on the Theory of Computation. </booktitle> <month> May, </month> <year> 1982. </year>
Reference-contexts: It depends on the existence of a bit-secure private key encryption scheme, in which a single key K is used for both encryption and decryption. The encryption scheme must be probabilistic <ref> [9] </ref> to ensure that repeated instances of the same cleartext (e.g., Inc entries for a replicated counter) produce different ciphertext instances. 3.1. Overview The private key Secure Quorum Consensus (SQC) protocol is implemented by three kinds of sites: 1. <p> Rabin and Karp have given such a checksum [21]. Another approach to this method is given by the more expensive technique of probabilistic encryption <ref> [9] </ref>. The integrity threshold t is less than or equal to t (for private key SQC) or t (for public key I E SQC). Otherwise the problem is clearly hopeless.
Reference: [10] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The knowledge complexity of interactive proofs. </title> <booktitle> In Proceedings of the 17th Symposium on the Theory of Computation. </booktitle> <month> May, </month> <year> 1985. </year>
Reference-contexts: To keep our presentation as straightforward as possible, we assume that a communications subsystem provides secure and authenticated communication using known protocols, e.g., <ref> [2, 14, 10, 8] </ref>. Here, we consider only attacks that bypass the communications subsystem, isolating some set of repositories and directly observing or modifying their data.
Reference: [11] <author> M. P. Herlihy. </author> <title> A quorum-consensus replication method for abstract data types. </title> <journal> ACM Transactions on Computer Systems 4(1), </journal> <month> February, </month> <year> 1986. </year>
Reference-contexts: In particular, the availability of long-lived data can be enhanced by storing the data redundantly at multiple sites, a technique commonly known as replication <ref> [7, 11] </ref>. In this paper, we consider how replication protocols originally proposed to enhance fault-tolerance can be adapted to the more demanding requirements of security. <p> When we say that a ciphertext gives no information about the corresponding cleartext, we mean that it satisfies either of the above definitions of security. 2.2. Quorum Consensus Replication A complete description of quorum consensus replication is given elsewhere <ref> [11] </ref>. For brevity, we give two informal examples: files and counters. 3 A replicated object is implemented by two kinds of modules: repositories and front-ends. Repositories provide long-term storage for the object's state, while front-ends carry out operations for clients. Different objects may have different sets of repositories. <p> It provides three operations: Inc () increments the counter by one, Dec () decrements the counter by one, and Value () returns the counter's current value. Such a counter is used as part of a protocol for dynamic reconfiguration of replicated objects <ref> [11] </ref>. The counter is a replicated reference count that keeps track of the number of existing references to a particular replicated object. The counter is incremented whenever a new reference is created, and decremented whenever an existing reference is destroyed. <p> A quorum assignment is correct if and only if (1) each final Dec quorum intersects each initial Value quorum, and (2) each final Inc quorum intersects each final Value quorum. Many other examples of replicated typed objects appear elsewhere <ref> [11] </ref>. 2.3. Shared Secrets In this section, we give a brief overview of Shamir's secret sharing algorithm [22]. <p> If p of the unaltered pieces are known to the adversary, however, then the threshold for the new key is effectively t-p of n-p. If this level of security is unsatisfactory, then as long as max (r,w,t) repositories are accessible, known protocols for on-the-fly reconfiguration (e.g., <ref> [11] </ref>) can be used to replace the inaccessible repositories with new, trusted repositories, using a completely new set of pieces to encrypt the key. 6. A Protocol for Preserving Integrity So far, the protocols described here have been concerned with preserving the secrecy of data against a passive adversary.
Reference: [12] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM 21(7) </journal> <pages> 558-565, </pages> <month> July, </month> <year> 1978. </year>
Reference-contexts: An operation's quorums determine its availability, and the constraints governing an object's quorum assignments determine the range of availability properties realizable by a replication method. A replicated file [7] is represented as a collection of timestamped versions, where timestamps are generated by logical clocks <ref> [12] </ref>. To read a file, a front-end reads the version from a read quorum of repositories and chooses the version with the latest timestamp. To write the file, a front-end generates a new timestamp and records the newly timestamped version at a write quorum of repositories.
Reference: [13] <author> C. Meyer and S. Matyas. </author> <title> Cryptography. </title> <publisher> Wiley, </publisher> <year> 1982. </year>
Reference-contexts: and recovery of the original 3 text requires solution of a small linear system (time O (t )). (We are assuming here a fixed p; the complexity of these operations is polynomial in the logarithm of p.) This compares very favorably with standard private key and public key encryption techniques <ref> [13] </ref>. 3. Private Key Secure Quorum Consensus The protocol described here protects the secrecy of the object against an adversary who can observe the contents of fewer than t repositories.
Reference: [14] <author> R. Needham and M. Schroeder. </author> <title> Using encryption for authentication in large networks of computers. </title> <journal> Communications of the ACM 21(12), </journal> <month> December, </month> <year> 1978. </year> <month> 10 </month>
Reference-contexts: To keep our presentation as straightforward as possible, we assume that a communications subsystem provides secure and authenticated communication using known protocols, e.g., <ref> [2, 14, 10, 8] </ref>. Here, we consider only attacks that bypass the communications subsystem, isolating some set of repositories and directly observing or modifying their data.
Reference: [15] <author> M. Rabin. </author> <title> Digitalized signatures and public-key functions as intractable as factorization. </title> <type> Technical Report MIT/LCS/TR-212, </type> <institution> Laboratory for Computer Science, MIT, </institution> <month> January, </month> <year> 1979. </year>
Reference-contexts: For example, it has been shown [1] that the RSA th [20] cryptosystem is bit-secure under the assumption that taking k roots modulo pq, a product of two large primes, cannot be done in randomized polynomial time and that the Rabin <ref> [15] </ref> signature schemes is bit-secure if factorization is not in randomized polynomial time. (These assumptions are generally accepted by the academic computer science community.) The second notion, of perfect security, implies that given ciphertext, no processor with unlimited resources can derive a probability distribution of the corresponding cleartext other than a
Reference: [16] <author> M. Rabin and J. D. Tygar. </author> <title> An integrated toolkit for operating system security. </title> <type> Technical Report TR-01-87, </type> <institution> Aiken Computation Laboratory, Harvard University, </institution> <month> January, </month> <year> 1987. </year>
Reference-contexts: Chor and Rabin [5] have shown how this protocol can be used to generate bits with a high degree of independence in a Byzantine distributed system. The verifiable secret sharing protocol can also be incorporated into our techniques, but it would be more expensive to do so. The ITOSS <ref> [16] </ref> operating system used the secret sharing protocol to provide a distributed command processor for high security applications. 9
Reference: [17] <author> B. Randell. </author> <title> Recursively structured distributed computing systems. </title> <booktitle> In Proceedings, Third Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 113-118. </pages> <month> October, </month> <year> 1983. </year>
Reference-contexts: Remarks and Related Work Brian Randell <ref> [17, 18] </ref> posed the following question: can security and fault-tolerance be integrated in a single mechanism? This question challenges the traditional rule of thumb in security work that as a system becomes more distributed, vulnerability to security attacks increases.
Reference: [18] <author> B. Randell and J. Dobson. </author> <title> Reliability and security issues in distributed computing systems. </title> <booktitle> In Proceedings, Fifth Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 113-118. </pages> <month> January, </month> <year> 1986. </year>
Reference-contexts: Remarks and Related Work Brian Randell <ref> [17, 18] </ref> posed the following question: can security and fault-tolerance be integrated in a single mechanism? This question challenges the traditional rule of thumb in security work that as a system becomes more distributed, vulnerability to security attacks increases.
Reference: [19] <author> J. Reif and J. D. Tygar. </author> <title> Efficient parallel pseudo-random number generation. </title> <booktitle> In Advances in Cryptology: CRYPTO-85, </booktitle> <pages> pages 433-446. </pages> <publisher> Springer-Verlag, </publisher> <month> August, </month> <year> 1985. </year> <note> To appear in SIAM J. on Computing. </note>
Reference-contexts: Background 2.1. Terminology We use two notions of cryptographic security in this paper. One notion, of bit-security, <ref> [3, 19] </ref>, implies that given ciphertext, no processor with randomized polynomial resources can derive information about any given bit in the corresponding cleartext with certainty greater than 1/2+e for any e &gt; 0.
Reference: [20] <author> R. Rivest, A. Shamir, and L. </author> <note> Adleman. </note>
Reference-contexts: Given the current limits of complexity theory, we do not have a way of proving bit-security without making some assumption about the lower bound on an algorithmic problem. For example, it has been shown [1] that the RSA th <ref> [20] </ref> cryptosystem is bit-secure under the assumption that taking k roots modulo pq, a product of two large primes, cannot be done in randomized polynomial time and that the Rabin [15] signature schemes is bit-secure if factorization is not in randomized polynomial time. (These assumptions are generally accepted by the academic
References-found: 20

