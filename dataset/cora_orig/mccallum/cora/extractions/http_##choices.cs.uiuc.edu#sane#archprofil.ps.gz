URL: http://choices.cs.uiuc.edu/sane/archprofil.ps.gz
Refering-URL: http://choices.cs.uiuc.edu/sane/home.html
Root-URL: http://www.cs.uiuc.edu
Email: (sane,roy)@cs.uiuc.edu sefika@macs.nul.ls  
Title: Architecture-Oriented Visualization  
Author: Mohlalefi Sefika Aamod Sane and Roy H. Campbell P. O. 
Web: http://choices.cs.uiuc.edu  
Address: 180, Lesotho Urbana, IL 61801  Africa  
Affiliation: Department of Mathematics and Computer Science Department of Computer Science National University of Lesotho University of Illinois at Urbana-Champaign  Roma  Southern  
Abstract: This paper shows that architecture-oriented visualization, the graphical presentation of system statics and dynamics in terms of its architectural abstractions, is highly beneficial in designing complex systems. In addition, the paper presents architecture-aware instrumentation, a new technique for building efficient on-line instrumentation to support architectural queries. We demonstrate the effectiveness and performance of the scheme with case studies in the design of the Choices object-oriented operating system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ull-man. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference: [2] <author> Marla J. Baker and Stephen G. Eick. </author> <title> Visualizing Software Systems. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 59-67, </pages> <year> 1994. </year>
Reference-contexts: The system offers many graphical presentations, each suitable for viewing behavior at some abstraction level. When we want aggregate, relative statistics, we use diagrams like bar charts and ternary diagrams [9]. When the information must be correlated to the system structure, we use space-filling diagrams <ref> [2] </ref> that make it easy to relate the run-time statistics to the relevant system parts. When we have to display pair-wise component interaction, we use affinity diagrams [23] and object interaction diagrams [3]. At each point, the user may choose from a palette of possible diagrams. <p> We select the VM bar from Figure 1 to get the space-filling diagram <ref> [2] </ref> of Figure 2. The diagram depicts the virtual memory subsystem frameworks and their class hierarchy components, with filled rectangles indicating the relative number of processes blocked. The class hierarchies are represented by rectangles whose size is proportional to the number of classes in the corresponding hierarchy.
Reference: [3] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design With Applications . The Benjamin/Cummings Publishing Company, </title> <publisher> Inc., </publisher> <year> 1994. </year>
Reference-contexts: When the information must be correlated to the system structure, we use space-filling diagrams [2] that make it easy to relate the run-time statistics to the relevant system parts. When we have to display pair-wise component interaction, we use affinity diagrams [23] and object interaction diagrams <ref> [3] </ref>. At each point, the user may choose from a palette of possible diagrams. Our system also supports multiple simultaneous diagrams and combined static and dynamic perspectives. Moreover, the diagrams are hyperlinked to one another so that information displayed on the screen can be easily used to guide system navigation. <p> For the most part, the framework and the subsystem appear to be cohesive: intra-component interaction is much greater than inter-component interaction. However, Disk and RpcBuffer exhibit anoma lous, heavy communication. * Class Interactions: To understand the unusual interaction, we click on the thick arrow, generating the object interaction diagram <ref> [3] </ref> of Figure 6. This diagram portrays a trace of method calls between instances of Disk and RpcBuffer. The diagram statistics indicate that the method getState () is called with high frequency on the Disk object.
Reference: [4] <author> R. H. Campbell, N. Islam, D. Raila, and P. Madany. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Recent research [24, 5, 7] demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems. In our own studies of the customization of the Choices <ref> [4] </ref> object-oriented operating system, we often needed answers to questions like: * How many times does this application process visit the file system? * Is this lock currently in use by any subframework of the virtual memory system? * Which subframework of the virtual memory system communicates most frequently with the <p> In ProgramExplorer [14], the data is collected into a Prolog database. In ObjectVisualizer [20], multi-level hash tables organize the data, supporting data accumulation, albeit only on a per-method basis. Structured instruments were exploited in a limited manner in the Choices operating system <ref> [4] </ref>.
Reference: [5] <author> L. Peter Deutsch. </author> <title> Design Reuse and Frameworks in the Smalltalk-80 Programming System. </title> <editor> In Ted J. Big-gerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> volume II, </volume> <pages> pages 55-71. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Designers conceive complex systems as architectures with design patterns [7], frameworks <ref> [5] </ref>, architectural styles [8], and subsystems. As the system evolves, they customize these large-grained components, tune performance, and make reuse decisions. Such complex tasks require understanding component behavior, tracking resource usage, and detecting integration problems. <p> Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods [19, 20, 14, 15, 17, 12]. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research <ref> [24, 5, 7] </ref> demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems.
Reference: [6] <author> Brian Foote and Ralph E. Johnson. </author> <title> Reflective Facilities in Smalltalk-80. </title> <booktitle> In OOPSLA 89, Conference Proceedings, </booktitle> <pages> pages 327-335. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Snodgrass' instrumentation is mainly targeted towards distributed debugging and monitoring, not on analyzing the software architecture of the system. Other related research includes work on computational reflection. While rich structures and meta-level architectures for reflection have previously been defined <ref> [18, 11, 6, 26] </ref>, issues in the explicit representation of gross architectural abstractions appear to be under emphasized because the problems being investigated are different.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns, Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Designers conceive complex systems as architectures with design patterns <ref> [7] </ref>, frameworks [5], architectural styles [8], and subsystems. As the system evolves, they customize these large-grained components, tune performance, and make reuse decisions. Such complex tasks require understanding component behavior, tracking resource usage, and detecting integration problems. <p> Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods [19, 20, 14, 15, 17, 12]. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research <ref> [24, 5, 7] </ref> demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems. <p> The hierarchy is built using the COMPOSITE <ref> [7] </ref> pattern. * Consequences: Using the COMPOSITE-based design, it is transparent to the client code whether it is accessing aggregate instruments like a Subsystem or primitive instruments like a Method. Thus, client programs become independent of the granularity of an instrument. <p> For instance, a user might want to use the same traversal strategy over multiple abstraction levels, or to rely on customized navigation policies for individual levels. * Solution: We separate the responsibility for traversing the instruments in an ITERATOR <ref> [7] </ref> object. Each iterator has a specialized algorithm for traversing its collection of instruments. * Consequences: Iterators know the details of the collection, but the instrument managers and data collectors are isolated from those details.
Reference: [8] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Exploiting Style in Architectural Design Environments. </title> <booktitle> In Proceedings of the 2nd ACM SIGSOFT, </booktitle> <pages> pages 175-188, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Designers conceive complex systems as architectures with design patterns [7], frameworks [5], architectural styles <ref> [8] </ref>, and subsystems. As the system evolves, they customize these large-grained components, tune performance, and make reuse decisions. Such complex tasks require understanding component behavior, tracking resource usage, and detecting integration problems.
Reference: [9] <author> Philip Haynes, Tim Menzies, and Robert F. Co-hen. </author> <title> Visualisations of large object-oriented systems. </title> <type> Technical Report TR 95-4, </type> <institution> Monash University, </institution> <address> Mel-bourne, Australia, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: In each study, we use information from higher levels to select lower-level components for further study. The system offers many graphical presentations, each suitable for viewing behavior at some abstraction level. When we want aggregate, relative statistics, we use diagrams like bar charts and ternary diagrams <ref> [9] </ref>. When the information must be correlated to the system structure, we use space-filling diagrams [2] that make it easy to relate the run-time statistics to the relevant system parts. When we have to display pair-wise component interaction, we use affinity diagrams [23] and object interaction diagrams [3]. <p> We exploit this facility to routinely check the design properties of Choices after every version [23, 21]. This case study considers an instance where we recognized and repaired undesirable subsystem couplings during our system evaluation. * Subsystem: The ternary diagram <ref> [9] </ref> in Figure 4 portrays relative communication between four device driver frameworks and three subsystems: the naming system, the remote procedure call (RPC) system, and the device driver system. The diagram helps quickly compare the degree of interaction among each framework and the three subsystems.
Reference: [10] <author> J. A. Interrante and M. A. Linton. </author> <title> Run-time Access to Type Information in C++. </title> <booktitle> In Proceedings of the USENIX C++ Conference, </booktitle> <address> San Francisco, California, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Classes provide run-time type information, enabling the querying of class inheritance and class instance relations among objects. Instruments that are related by inheritance can be controlled in groups dynamically. However, the instrument selection is purely based on class type information <ref> [10] </ref>. This introspection scheme does not go beyond the class level, nor does it explicitly represent relations among instruments other than Classes. A similar class-based approach is adopted by De Pauw et al.[19].
Reference: [11] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Snodgrass' instrumentation is mainly targeted towards distributed debugging and monitoring, not on analyzing the software architecture of the system. Other related research includes work on computational reflection. While rich structures and meta-level architectures for reflection have previously been defined <ref> [18, 11, 6, 26] </ref>, issues in the explicit representation of gross architectural abstractions appear to be under emphasized because the problems being investigated are different.
Reference: [12] <author> D. R. Kohr, S. Zhang, M. Rahman, and D. A. Reed. </author> <title> Object-Oriented Parallel Operating Systems: A Performance Study. </title> <booktitle> In Scientific Programming, </booktitle> <year> 1994. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis directly in terms of higher-level, architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [24, 5, 7] demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems. <p> Each packet encodes a component identifier, a cumulative call count, and meta-information needed by the visualizer to unmarshal the packet. In the performance display graph of Figure 12, the dotted bars depict trace data generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, data packets are generated on a per-method basis; every data packet includes information about the method that was called. Consequently, the number of packets equals the number of methods called regardless of the granularity of system modeling.
Reference: [13] <author> C. </author> <title> Laffra and A Malhotra. HotWire:A Visual Debugger for C++. </title> <booktitle> In Proceedings of the USENIX C++ Conference, </booktitle> <pages> pages 39-54, </pages> <year> 1994. </year>
Reference-contexts: is an acceptable tradeoff given the significant benefits to be gained by using instruments that understand the structure of the system, and given the consistent trend of falling memory prices. 6 Related research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions <ref> [19, 20, 13] </ref>. ProgramExplorer [14, 15], Pattern-Lint [23], and OS View [22] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [14] <author> Danny B. Lange and Yuichi Nakamura. </author> <title> Interactive Visualization of Design Patterns Can help in Framework Understanding. </title> <booktitle> In OOPSLA, </booktitle> <year> 1995. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis directly in terms of higher-level, architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [24, 5, 7] demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems. <p> Each packet encodes a component identifier, a cumulative call count, and meta-information needed by the visualizer to unmarshal the packet. In the performance display graph of Figure 12, the dotted bars depict trace data generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, data packets are generated on a per-method basis; every data packet includes information about the method that was called. Consequently, the number of packets equals the number of methods called regardless of the granularity of system modeling. <p> ProgramExplorer <ref> [14, 15] </ref>, Pattern-Lint [23], and OS View [22] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods. <p> No system that we know supports dynamic architecture-oriented visualization, where the graphical presentations of the running system directly map to architectural abstractions like frameworks. Previous research on object-oriented program visualization has concentrated more on trace data organization than on structuring the instruments that gather the data. In ProgramExplorer <ref> [14] </ref>, the data is collected into a Prolog database. In ObjectVisualizer [20], multi-level hash tables organize the data, supporting data accumulation, albeit only on a per-method basis. Structured instruments were exploited in a limited manner in the Choices operating system [4].
Reference: [15] <author> Danny B. Lange and Yuichi Nakamura. </author> <title> Program Explorer: A Program Visualizer for C++. </title> <booktitle> In Usenix Conference on Object-Oriented Technologies, </booktitle> <pages> pages 39-54, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis directly in terms of higher-level, architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [24, 5, 7] demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems. <p> Each packet encodes a component identifier, a cumulative call count, and meta-information needed by the visualizer to unmarshal the packet. In the performance display graph of Figure 12, the dotted bars depict trace data generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, data packets are generated on a per-method basis; every data packet includes information about the method that was called. Consequently, the number of packets equals the number of methods called regardless of the granularity of system modeling. <p> ProgramExplorer <ref> [14, 15] </ref>, Pattern-Lint [23], and OS View [22] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [16] <author> Rahman M. </author> <title> Choices Instrumentation Support. </title> <type> Technical report, </type> <institution> University of Illinois-Urbana Cham-paign, </institution> <year> 1992. </year>
Reference-contexts: Each packet encodes a component identifier, a cumulative call count, and meta-information needed by the visualizer to unmarshal the packet. In the performance display graph of Figure 12, the dotted bars depict trace data generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, data packets are generated on a per-method basis; every data packet includes information about the method that was called. Consequently, the number of packets equals the number of methods called regardless of the granularity of system modeling.
Reference: [17] <author> Peter W. Madany, Roy H. Campbell, and Panos Kou-giouris. </author> <title> Experiences Building an Object-Oriented System in C++. </title> <booktitle> In Technology of Object-Oriented Languages and Systems Conference, </booktitle> <address> Paris, France, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis directly in terms of higher-level, architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [24, 5, 7] demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems.
Reference: [18] <editor> Pattie Maes. </editor> <title> Concepts and Experiments in Computational Reflection. </title> <booktitle> In OOPSLA 87, Conference Proceedings, </booktitle> <pages> pages 147-155. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: Snodgrass' instrumentation is mainly targeted towards distributed debugging and monitoring, not on analyzing the software architecture of the system. Other related research includes work on computational reflection. While rich structures and meta-level architectures for reflection have previously been defined <ref> [18, 11, 6, 26] </ref>, issues in the explicit representation of gross architectural abstractions appear to be under emphasized because the problems being investigated are different.
Reference: [19] <author> W. De Pauw, R. Helm, D. Kimelman, and J. Vlissides. </author> <title> Visualizing the Behavior of Object-Oriented Systems. </title> <booktitle> In OOPSLA, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis directly in terms of higher-level, architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [24, 5, 7] demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems. <p> Each packet encodes a component identifier, a cumulative call count, and meta-information needed by the visualizer to unmarshal the packet. In the performance display graph of Figure 12, the dotted bars depict trace data generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, data packets are generated on a per-method basis; every data packet includes information about the method that was called. Consequently, the number of packets equals the number of methods called regardless of the granularity of system modeling. <p> is an acceptable tradeoff given the significant benefits to be gained by using instruments that understand the structure of the system, and given the consistent trend of falling memory prices. 6 Related research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions <ref> [19, 20, 13] </ref>. ProgramExplorer [14, 15], Pattern-Lint [23], and OS View [22] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [20] <author> W. De Pauw, R. Helm, D. Kimelman, and J. Vlis-sides. </author> <title> Modelling Object-Oriented Program Execution. </title> <booktitle> In Proceedings of the 8th European Conference on Object-Oriented Programming, ECOOP'94. Lecture Notes in Computer Science, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis directly in terms of higher-level, architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [24, 5, 7] demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems. <p> Each packet encodes a component identifier, a cumulative call count, and meta-information needed by the visualizer to unmarshal the packet. In the performance display graph of Figure 12, the dotted bars depict trace data generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, data packets are generated on a per-method basis; every data packet includes information about the method that was called. Consequently, the number of packets equals the number of methods called regardless of the granularity of system modeling. <p> is an acceptable tradeoff given the significant benefits to be gained by using instruments that understand the structure of the system, and given the consistent trend of falling memory prices. 6 Related research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions <ref> [19, 20, 13] </ref>. ProgramExplorer [14, 15], Pattern-Lint [23], and OS View [22] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods. <p> Previous research on object-oriented program visualization has concentrated more on trace data organization than on structuring the instruments that gather the data. In ProgramExplorer [14], the data is collected into a Prolog database. In ObjectVisualizer <ref> [20] </ref>, multi-level hash tables organize the data, supporting data accumulation, albeit only on a per-method basis. Structured instruments were exploited in a limited manner in the Choices operating system [4].
Reference: [21] <author> Mohlalefi Sefika. </author> <title> Design Conformance Management of Software Systems: An Architecture-Oriented Approach. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: The second study (Section 3.1) concerns a problem in subsystem cohesion and coupling that showed up during a routine check that we apply after every major change in system design <ref> [23, 21] </ref>. The check tracks subsystem interactions at the subsystem-, framework-, class-, and method-levels and reveals significant architectural changes that could indicate flaws in the modifications. The check is essentially a conformance test and is feasible because architecture-oriented visualization simplifies the process. <p> We exploit this facility to routinely check the design properties of Choices after every version <ref> [23, 21] </ref>. <p> A single indirection suffices to achieve this binding without significant impact on efficiency. More details of the instrumentation system organization can be found in <ref> [21] </ref>. 4.5 Queries The instrumentation and visualization system supports queries about architectural concerns and their interactions. (BNF)[1].
Reference: [22] <author> Mohlalefi Sefika and Roy H. Campbell. </author> <title> An Open Visual Model For Object-Oriented Operating Systems. </title> <booktitle> In Fourth International Workshop on Object Orientation in Operating Systems, Lund, </booktitle> <address> Sweden, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: ProgramExplorer [14, 15], Pattern-Lint [23], and OS View <ref> [22] </ref> are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [23] <author> Mohlalefi Sefika, Aamod Sane, and Roy H. Camp-bell. </author> <title> Monitoring Compliance of a Software System With Its High-Level Design Models. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering (ICSE), </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: The second study (Section 3.1) concerns a problem in subsystem cohesion and coupling that showed up during a routine check that we apply after every major change in system design <ref> [23, 21] </ref>. The check tracks subsystem interactions at the subsystem-, framework-, class-, and method-levels and reveals significant architectural changes that could indicate flaws in the modifications. The check is essentially a conformance test and is feasible because architecture-oriented visualization simplifies the process. <p> When the information must be correlated to the system structure, we use space-filling diagrams [2] that make it easy to relate the run-time statistics to the relevant system parts. When we have to display pair-wise component interaction, we use affinity diagrams <ref> [23] </ref> and object interaction diagrams [3]. At each point, the user may choose from a palette of possible diagrams. Our system also supports multiple simultaneous diagrams and combined static and dynamic perspectives. <p> We exploit this facility to routinely check the design properties of Choices after every version <ref> [23, 21] </ref>. <p> This coupling is probably undesirable. * Framework Details: To examine the details of the suspicious communication, we click on the Devices framework circle and the RPC system axis to generate an affinity diagram <ref> [23] </ref> that shows how the framework and the subsystem components interact. In Figure 5, classes attract each other if they communicate frequently, otherwise they repel. The higher the communication between two classes, the thicker their connecting lines. The line arrows indicate the direction of calls. <p> ProgramExplorer [14, 15], Pattern-Lint <ref> [23] </ref>, and OS View [22] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [24] <author> Mary Shaw and David Garlan. </author> <title> Software Architecture: Perspectives on an Emerging Discipline. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods [19, 20, 14, 15, 17, 12]. Many, rich architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research <ref> [24, 5, 7] </ref> demonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex systems.
Reference: [25] <author> R Snodgrass. </author> <title> A Relational Approach to Monitoring Complex Systems. </title> <journal> ACM Transactions of Computer Systems 6(2) </journal> <pages> 157-196, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: However, the instrument selection is purely based on class type information [10]. This introspection scheme does not go beyond the class level, nor does it explicitly represent relations among instruments other than Classes. A similar class-based approach is adopted by De Pauw et al.[19]. Snodgrass <ref> [25] </ref> presents a method for monitoring program execution in which a programmer uses relational algebra queries to track run-time dynamics. The scheme is more tailored for data organization (using a conceptual, temporal database) than instrument organization.
Reference: [26] <author> Yasuhiko Yokote, Fumino Teraoka, Atsushi Mit-suzawa, Nobuhisa Fujinami, and Mario Tokoro. </author> <title> The Muse Object Architecture: A New Operating System Structuring Concept. </title> <type> Technical Report SCSL-TR-90-012, </type> <institution> Sony Computer Science Laboratory Inc., </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: Snodgrass' instrumentation is mainly targeted towards distributed debugging and monitoring, not on analyzing the software architecture of the system. Other related research includes work on computational reflection. While rich structures and meta-level architectures for reflection have previously been defined <ref> [18, 11, 6, 26] </ref>, issues in the explicit representation of gross architectural abstractions appear to be under emphasized because the problems being investigated are different.
References-found: 26

