URL: ftp://ftp.cs.jhu.edu/pub/scott/hoots.ps.Z
Refering-URL: http://www.cs.jhu.edu/~scott/homepage/papers.html
Root-URL: http://www.cs.jhu.edu
Email: scott@cs.jhu.edu  
Title: The Coverage of Operational Semantics  
Author: Scott F. Smith 
Keyword: Dimensions of the untyped programming language design space addressed here include functions, injections, pairs, objects, and memories.  
Web: http://www.cs.jhu.edu/scott/  
Affiliation: Department of Computer Science The Johns Hopkins University  
Abstract: Techniques of operational semantics do not apply universally to all language varieties: techniques that work for simple functional languages may not apply to more realistic languages with features such as objects and memory effects. We focus mainly on the characterization of the so-called finite elements. The presence of finite elements in a semantics allows for an additional powerful induction mechanism. We show that in some languages a reasonable notion of finite element may be defined, but for other languages this is problematic, and we analyse the reasons for these difficulties. We develop a formal theory of language embeddings and establish a number of properties of embeddings. More complex languages are given semantics by embedding them into simpler languages. Embeddings may be used to establish more general results and avoid reproving some results. It also gives us a formal metric to describe the gap between different languages. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abadi, M., L. Cardelli, and R. </author> <title> Viswanathan (1996). An interpretation of objects and object types. </title> <booktitle> In Conference Record of the Twenty-Third Annual ACM Symposium on Principles of Programming Languages. ACM. </booktitle>
Reference-contexts: Our simple objects contain methods that may refer to the object itself. Since they are functional, they do not contain mutable instances, and there is also no notion of class or of method override. Classes (Eifrig, Smith, Trifonov, and Zwarico 1995) and method override <ref> (Abadi, Cardelli, and Viswanathan 1996) </ref> may also be interpreted via homomorphic embeddings; for brevity we leave them out of this presentation.
Reference: <author> Abadi, M., B. Pierce, and G. </author> <title> Plotkin (1991). Faithful ideal models for recursive polymorphic types. </title> <booktitle> International Journal of Foundations of Computer Science 2(1), </booktitle> <pages> 1-21. </pages>
Reference-contexts: For instance, extensionality (Theorem 5.8) is one such property. For this reason, extensionality of a more fine-grained equivalence will not imply extensionality of = . The notion of a faithful ideal <ref> (Abadi, Pierce, and Plotkin 1991) </ref> also has a negative instance of = : if a 2 I and a = b, then b 2 I. The secondary source of problems is that a more fine-grained equivalence will mean some operational equivalences will not be provable via the too-fine-grained characterization.
Reference: <author> Abramsky, S. </author> <year> (1990). </year> <title> The lazy lambda calculus. </title> <booktitle> In Research Topics in Functional Programming, </booktitle> <pages> pp. 65-116. </pages> <publisher> Addison-Wesley. </publisher>
Reference-contexts: However, proofs are possible. A number of alternate characterizations of = have been developed to make proofs of equivalence much simpler, including bisimulation <ref> (Abramsky 1990) </ref>, applicative orderings (Bloom 1990), and ciu equivalence (Mason and Talcott 1991). These alternate characterizations may be shown to be the same as = (a so-called fully abstract alternate equivalence).
Reference: <author> Agha, G., I. Mason, S. F. Smith, and C. </author> <title> Talcott (1992). Towards a theory of actor computation. </title> <booktitle> In CONCUR, Volume 630 of Lecture notes in Computer Science, </booktitle> <pages> pp. 565-579. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Operational equivalence has also been shown to yield good notions of equivalence for languages with memories (Mason and Talcott 1991), explicit control operators (Talcott 1989), types and objects (Gordon and Rees 1996), and distributed objects <ref> (Agha, Mason, Smith, and Talcott 1992) </ref>.
Reference: <author> Barendregt, H. P. </author> <year> (1984). </year> <title> The Lambda Calculus: Its Syntax and Semantics (Revised ed.), </title> <booktitle> Volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <address> Amsterdam: </address> <publisher> North-Holland. </publisher>
Reference-contexts: This approach The Coverage of Operational Semantics 15 to finite expressions is not found in Barendregt <ref> (Barendregt 1984) </ref>. Barendregt Chapter 14 does review another similar approach which is worth contrasting: Hyland and Wadsworth's labelled -calculus.
Reference: <author> Bloom, B. </author> <year> (1990). </year> <title> Can LCF be topped? Information and Computation 87, 264-301. The Coverage of Operational Semantics 39 Egidi, </title> <editor> L., F. Honsell, and S. R. </editor> <title> della Rocca (1992). Operational, denotational and logical descriptions: a case study. </title> <note> Fundamenta Informaticae 16(2), 149-170. </note>
Reference-contexts: However, proofs are possible. A number of alternate characterizations of = have been developed to make proofs of equivalence much simpler, including bisimulation (Abramsky 1990), applicative orderings <ref> (Bloom 1990) </ref>, and ciu equivalence (Mason and Talcott 1991). These alternate characterizations may be shown to be the same as = (a so-called fully abstract alternate equivalence).
Reference: <author> Eifrig, J., S. Smith, V. Trifonov, and A. </author> <title> Zwarico (1995). An interpretation of typed OOP in a language with state. </title> <booktitle> Lisp and Symbolic Computation 8(4), </booktitle> <pages> 357-397. </pages>
Reference-contexts: Our simple objects contain methods that may refer to the object itself. Since they are functional, they do not contain mutable instances, and there is also no notion of class or of method override. Classes <ref> (Eifrig, Smith, Trifonov, and Zwarico 1995) </ref> and method override (Abadi, Cardelli, and Viswanathan 1996) may also be interpreted via homomorphic embeddings; for brevity we leave them out of this presentation.
Reference: <author> Felleisen, M. </author> <year> (1991). </year> <title> On the expressive power of programming languages. </title> <booktitle> Science of Computer Programming 17, </booktitle> <pages> 35-75. </pages>
Reference-contexts: Our (i) is Mitchell's (R1) condition, and (ii) is similar to Felleisen's condition 2 of his Eliminability notion <ref> (Felleisen 1991) </ref>. For brevity in this presentation, we will generally not define # h and 7! h for the high-level languages. We will often leave 7! h undefined and take (ii) above as a definition of # h . <p> The reader may now want to look ahead to Definitions 4.3, 4.18, and 5.3, which contain examples of parametric embeddings. Parametric embeddings are closely related to Felleisen's condition 3, so-called Macro Eliminability <ref> (Felleisen 1991) </ref>. One other important property of an embedding is the syntax of some high-level operators may be preserved by the embedding. <p> Our notion of homomorphic embedding is closely related to Felleisen's eliminability definition, condition 1 <ref> (Felleisen 1991) </ref>. Definitions 4.3 and 4.18 below are examples of homomorphic embeddings. Embeddings compose in the obvious fashion.
Reference: <author> Felleisen, M., D. Friedman, and E. </author> <title> Kohlbecker (1987). A syntactic theory of sequential control. </title> <booktitle> Theoretical Computer Science 52, </booktitle> <pages> 205-237. </pages>
Reference-contexts: typewriter font parentheses a (b) abbreviate function application. fix is a call-by-value version of the standard fixed-point combinator for functionals. 3.1 Operational Semantics The operational semantics of expressions is given by a single-step evaluation relation 7! inj , using the convenient notion of a reduction context (a.k.a. evaluation context) from <ref> (Felleisen, Friedman, and Kohlbecker 1987) </ref>. The redices are expressions of the form v (a), is i (v), or out i (v). Redices are either immediately available for execution, out i (inj i (a)), or are stuck, out i (x:x). In this presentation stuck computations are treated as divergent for simplicity.
Reference: <author> Felleisen, M. and R. </author> <title> Hieb (1992). The revised report on the syntactic theories of sequential control and state. </title> <booktitle> Theoretical Computer Science 103, </booktitle> <pages> 235-271. </pages>
Reference: <author> Freyd, P., P. Mulry, G. Rosolini, and D. </author> <title> Scott (1990). Extensional PERs. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pp. 346-354. </pages>
Reference-contexts: A number of solutions to this problem are possible. For one, we could restrict the directed sets A to be recursively enumerable (r.e.) sets. The lub will also be r.e. since A is r.e. This approach may be effectively applied to the simply typed -calculus <ref> (Freyd, Mulry, Rosolini, and Scott 1990) </ref>. 1 For technical reasons, we only allow directed sets with finitely many free variables, otherwise a directed set may contain all the variables Xfree and problems may arise in obtaining fresh variables.
Reference: <author> Gordon, A. D. and G. D. </author> <title> Rees (1996). Bisimularity for a first-order calculus of objects with subtyping. </title> <booktitle> In Conference Record of the Twenty-Third Annual ACM Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: Operational equivalence has also been shown to yield good notions of equivalence for languages with memories (Mason and Talcott 1991), explicit control operators (Talcott 1989), types and objects <ref> (Gordon and Rees 1996) </ref>, and distributed objects (Agha, Mason, Smith, and Talcott 1992).
Reference: <author> Harper, R., F. Honsell, and G. </author> <title> Plotkin (1993). A framework for defining logics. </title> <journal> Journal of the Association of Computing Machinery, </journal> <pages> 143-184. </pages>
Reference-contexts: Languages are taken to come with an operational evaluation relation. Some of the language mappings need to be based on the grammatical structure of the language, so a general notation for operators op is also defined in the tradition of a theory of arities <ref> (Harper, Honsell, and Plotkin 1993) </ref>. All languages are defined with respect to a single shared set of program variables Xfor simplicity.
Reference: <author> Honsell, F., I. A. Mason, S. F. Smith, and C. L. </author> <title> Talcott (1995). A variable typed logic of effects. </title> <booktitle> Information and Computation 119(1), </booktitle> <pages> 55-90. </pages>
Reference-contexts: THEOREM 5.7 (CIU) a @ m b iff a @ ciu For a proof, see <ref> (Honsell, Mason, Smith, and Talcott 1995) </ref>. The theorem also follows from set ordering ciu, proved below as Theorem 5.10, by Lemma 2.6 (iii). Applicative bisimulation equivalences may be defined for languages with memories (Ritter and Pitts 1995) and may be effectively used to directly establish equivalences. <p> This proof does not appear in previous papers and so is given here. The proof here is a direct combination of the proof of fg @ fg ciu for a functional call-by-value language in (Mason, Smith, and Talcott 1996) and ciu for a memory-based language in <ref> (Honsell, Mason, Smith, and Talcott 1995) </ref>. The proof may be factored into three Lemmas. The ( ) ) direction is not difficult, since @ m has a smaller collection of contexts to distinguish expressions than fg @ m fg has. ( ( ) is the difficult direction.
Reference: <author> Howe, D. J. </author> <year> (1996, </year> <month> February). </month> <title> Proving congruence of bisimulation in functional programming languages. </title> <booktitle> Information and Computation 124(2), </booktitle> <pages> 103-112. </pages>
Reference-contexts: For this simple language it is even possible to characterize @ inj via a bisimulation ordering <ref> (Howe 1996) </ref>. We now list a collection of basic = inj = @ inj properties, all easily provable from Theorem 3.7.
Reference: <author> Kamin, S. N. and U. S. </author> <title> Reddy (1994). Two semantic models of object-oriented languages. </title> <editor> In C. A. Gunter and J. C. Mitchell (Eds.), </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming, Chapter 13, </booktitle> <pages> pp. 464-495. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: : : : )))) [[send m (e)]] = out k+1 ([[e]])(count (m)) [[isobj (e)]] = eif (is k+1 ([[e]]); true; false) [[e]] = homomorphic for all other e This encoding does not expose the self (x 1 , : : : ,x n ) since a fixed point is taken <ref> (Kamin and Reddy 1994) </ref>. We conjecture this encoding is fully abstract. CONJECTURE 4.19 [[]] 2 L obj (k) ! L bpn (k+1) is set fully abstract.
Reference: <author> MacQueen, D. B., G. Plotkin, and R. </author> <title> Sethi (1984). An ideal model of types. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: So, even if !-algebraicity cannot be established, there still may be particular finitary decompositions that lead to useful proof principles. Another example of the use of rank induction is found in the ideal model construction <ref> (MacQueen, Plotkin, and Sethi 1984) </ref>, where it is used to give semantics to recursive types. The obvious solution for defining finite elements is to work in a domain that models the language. The inductive structure is usually present in a domain directly by its manner of definition (Scott 1976).
Reference: <author> Mason, I. A., S. F. Smith, and C. L. </author> <title> Talcott (1996). From operational semantics to domain theory. </title> <booktitle> Information and Computation 128(1). </booktitle>
Reference-contexts: In fact, none of the languages studied in this paper have such a model extant in the literature. Our alternate approach here is to build finite elements out of the program syntax. This approach has proved successful for a particular simple functional language <ref> (Mason, Smith, and Talcott 1996) </ref>. Syntactic projection functions n (e) are defined within the programming language to project expression e to be a finite expression of level n. In this operational theory an additional powerful induction principle is thus obtained: induction on the rank of the finite elements. <p> 3.6 (CIU ORDERING, @ inj ) inj b iff for all R; oe such that R [a [oe] ]; R [b [oe] ] closed; R [a [oe] ] # implies R [b [oe] ] # THEOREM 3.7 (CIU) a @ inj b iff a @ ciu For a proof, see <ref> (Mason, Smith, and Talcott 1996) </ref>. For this simple language it is even possible to characterize @ inj via a bisimulation ordering (Howe 1996). We now list a collection of basic = inj = @ inj properties, all easily provable from Theorem 3.7. <p> The main characterization theorem is THEOREM 3.10 (SET ORDERING CIU) A @ inj B iff A @ ciu This is Theorem 4.6 of <ref> (Mason, Smith, and Talcott 1996) </ref>. fg @ inj fg has the important property of allowing fixed points to be approximated. Fixed points may be shown equivalent to their set of finite unrollings. This breaks the cycle of a fixed point and gives an induction principle for reasoning about recursive functions. <p> As mentioned in the introduction, this allows reasoning about infinite elements in terms of their finite elements since each infinite element is the lub of all smaller finite elements. We show in this section how finite elements may be defined in an operational semantics. This material is taken from <ref> (Mason, Smith, and Talcott 1996) </ref>, where complete proofs are also to be found. With the fixed point property we saw how recursive functions could be decomposed into finite components for inductive reasoning. Similar properties could be proved for other particular structures, such as lists formed via iterative pairing. <p> 2 E ; inj and n 2 N, n (a) is finite in the sense of Definition 2.7. (iii) E ! S inj and a = inj n (a)g Furthermore, fg @ inj fg-directed sets all may be shown to have least upper bounds, and @ inj is !-algebraic; see <ref> (Mason, Smith, and Talcott 1996) </ref> for these properties and a proof of the previous Theorem. 4 A Space Of Languages In the previous section a very simple language family L inj (k) was studied. <p> Proofs of these theorems are found in <ref> (Mason, Smith, and Talcott 1996) </ref>. The principle of induction on the finite rank n is thus successfully obtained for this language. 4.2 Booleans, pairs, and numbers without recognizers It is interesting to consider ramifications of languages without recognizers isnat, ispr, isbool, and is k . <p> Most of the proofs in this section are direct generalizations of the functional proofs from <ref> (Mason, Smith, and Talcott 1996) </ref> to a language with memories. Very little extra reasoning is needed to handle the memory. The projection functions, defined in the following section, do require considerable extra work in the memory case. <p> The ciu theorem is THEOREM 5.10 ( @ m CIU) A @ m B. This proof does not appear in previous papers and so is given here. The proof here is a direct combination of the proof of fg @ fg ciu for a functional call-by-value language in <ref> (Mason, Smith, and Talcott 1996) </ref> and ciu for a memory-based language in (Honsell, Mason, Smith, and Talcott 1995). The proof may be factored into three Lemmas. <p> We are still not quite able to answer that question. One particular challenge is whether it is possible to give a semantics to Standard ML that defines types semantically, without recourse to type proof systems. Acknowledgements The original research on finite projections <ref> (Mason, Smith, and Talcott 1996) </ref> was done in collaboration with Ian Mason and Carolyn Talcott. The author would like to also thank Carolyn Talcott for a careful reading of an early version of this paper that caught a number of errors; Lemma 5.20 is hers.
Reference: <author> Mason, I. A. and C. L. </author> <title> Talcott (1991). Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming 1, </journal> <pages> 287-327. </pages>
Reference-contexts: A full and faithful notion of equivalence may be defined over an operational semantics via the Morris/Plotkin notion of operational/observational equivalence between program expressions, = . Operational equivalence has also been shown to yield good notions of equivalence for languages with memories <ref> (Mason and Talcott 1991) </ref>, explicit control operators (Talcott 1989), types and objects (Gordon and Rees 1996), and distributed objects (Agha, Mason, Smith, and Talcott 1992). <p> However, proofs are possible. A number of alternate characterizations of = have been developed to make proofs of equivalence much simpler, including bisimulation (Abramsky 1990), applicative orderings (Bloom 1990), and ciu equivalence <ref> (Mason and Talcott 1991) </ref>. These alternate characterizations may be shown to be the same as = (a so-called fully abstract alternate equivalence). <p> This equivalence is thus called ciu equivalence, = ciu inj , following <ref> (Mason and Talcott 1991) </ref>. a = ciu inj b means a and b behave identically when closed (the closed instances part) and placed in any reduction context R (the uses part).
Reference: <author> Milne, R. E. and C. </author> <title> Strachey (1976). A theory of programming language semantics. </title> <publisher> Chapman and Hall, London, and Wiley, </publisher> <address> New York. </address>
Reference-contexts: The mappings also allow us to define some hybrid forms of language quite easily, and in certain cases allows the lifting of theorems from low-level to high-level languages. The approach of defining language features by embeddings has a long history going back to Strachey <ref> (Milne and Strachey 1976) </ref>. We obtain some interesting results about these mappings, and the mappings themselves are an additional topic of the paper. An outline of the paper is as follows. A language-independent framework for operational semantics and language embeddings is defined in Section 2. <p> The languages studied in the previous section all could be defined by homomorphic embed-dings, because there were no global effects. The addition of global effects thus represents a significant change. We first present an embedding into L bpn (k+1) . Strachey's memory-threading transformation is used <ref> (Milne and Strachey 1976) </ref>. After establishing some results about this embedding, we define an equivalent direct operational semantics: proving facts via the embedding is cumbersome. We then develop a series of results which characterize the finite elements for a memory-based language.
Reference: <author> Milner, R. </author> <year> (1977). </year> <title> Fully abstract models of typed -calculi. </title> <note> Theoretical Computer Science 4, 1-22. </note> <author> 40 Smith Mitchell, J. </author> <year> (1993). </year> <title> On abstraction and the expressive power of programming languages. </title> <booktitle> Science of Computer Programming 21. </booktitle>
Reference-contexts: that for expressions in a simply-typed -calculus, there is no need for run-time projection operations: given the type of an expression e, k (e) can be partially evaluated to remove all cases on the sort, as the type itself reveals the sort This is one way to characterize Milner's construction <ref> (Milner 1977) </ref>. The following lemma establishes elementary properties of the syntactic projec tions. For brevity henceforward we drop the subscript inj from the projections n .
Reference: <author> Mosses, P. D. </author> <year> (1992). </year> <title> Action Semantics. </title> <publisher> Cambridge. </publisher>
Reference-contexts: It is general enough to encompass all languages studied herein, but is not intended as a general framework along the lines of <ref> (Mosses 1992) </ref>. In particular it will not fully capture nondeterministic or concurrent languages. It will allow for a general notion of language embedding to be defined.
Reference: <author> Pitts, A. M. </author> <year> (1996, </year> <month> 15 June). </month> <title> Relational properties of domains. </title> <booktitle> Information and Computation 127(2), </booktitle> <pages> 66-90. </pages>
Reference: <author> Riecke, J. G. </author> <year> (1993). </year> <title> Fully abstract translations between functional languages. </title> <booktitle> Mathematical Structures in Computer Science 3, </booktitle> <pages> 387-415. </pages>
Reference: <author> Ritter, E. and A. M. </author> <title> Pitts (1995). A fully abstract translation between a -calculus with reference types and standard ml. </title> <booktitle> In 2nd Int. Conf. on Typed Lambda Calculus and Applications, Edinburgh, 1995, Volume 902 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 397-413. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: THEOREM 5.7 (CIU) a @ m b iff a @ ciu For a proof, see (Honsell, Mason, Smith, and Talcott 1995). The theorem also follows from set ordering ciu, proved below as Theorem 5.10, by Lemma 2.6 (iii). Applicative bisimulation equivalences may be defined for languages with memories <ref> (Ritter and Pitts 1995) </ref> and may be effectively used to directly establish equivalences. They (to lesser degree) suffer the same problem of lack of locality as does [[a]] = bpn (k+1) [[b]], and so are not fully abstract. An important property that holds for @ m is extensionality.
Reference: <author> Scott, D. </author> <year> (1976). </year> <title> Data types as lattices. </title> <journal> SIAM J. Computing 5, </journal> <pages> 522-587. </pages>
Reference-contexts: This is very important because it gives a new, and often powerful, induction principle. A closely related property is fixed point induction <ref> (Scott 1976) </ref>. The greatest utility of the finite elements lies in the proof principle of rank induction, as just mentioned. For special cases of d it is possible to consider special forms of v-ordered chain. <p> The obvious solution for defining finite elements is to work in a domain that models the language. The inductive structure is usually present in a domain directly by its manner of definition <ref> (Scott 1976) </ref>. However, it is well-known that for many languages it is difficult to define a domain which has a notion of equivalence that is fully abstract. In fact, none of the languages studied in this paper have such a model extant in the literature.
Reference: <author> Smith, S. F. </author> <year> (1992). </year> <title> From operational to denotational semantics. </title> <booktitle> In MFPS 1991, Volume 598 of Lecture notes in Computer Science, </booktitle> <pages> pp. 54-76. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Operational equivalence has also been shown to yield good notions of equivalence for languages with memories (Mason and Talcott 1991), explicit control operators (Talcott 1989), types and objects (Gordon and Rees 1996), and distributed objects <ref> (Agha, Mason, Smith, and Talcott 1992) </ref>. <p> So, this approach may be of limited value. It thus does not appear to be feasible to construct structures isomorphic to domains directly on expressions. It is however possible to make progress by using @ -directed sets of expressions as a space over which an ordering is defined <ref> (Smith 1992) </ref>. A simple pre-ordering on directed sets of expressions, fg @ fg, is defined for this purpose. This pre-ordering has the property that a @ b iff fag @ meaning that it fully and faithfully generalizes @ .
Reference: <author> Talcott, C. L. </author> <year> (1989). </year> <title> Programming and proving with function and control abstractions. </title> <type> Technical Report STAN-CS-89-1288, </type> <institution> Stanford University, </institution> <address> Stan-ford, CA 94305. </address>
Reference-contexts: A full and faithful notion of equivalence may be defined over an operational semantics via the Morris/Plotkin notion of operational/observational equivalence between program expressions, = . Operational equivalence has also been shown to yield good notions of equivalence for languages with memories (Mason and Talcott 1991), explicit control operators <ref> (Talcott 1989) </ref>, types and objects (Gordon and Rees 1996), and distributed objects (Agha, Mason, Smith, and Talcott 1992). <p> Properties of the above general form may be proved across a wide range of languages (Mason and Talcott 1991; Gordon and Rees 1996; Talcott 1989). They may in theory be proved directly by induction on computation length <ref> (Talcott 1989) </ref>, but it is far more effective to prove them via first establishing an alternate characterization of @ inj via @ ciu inj or a bisimulation ordering.
Reference: <author> Talcott, C. L. </author> <year> (1997). </year> <title> Reasoning about functions with effects. </title> <editor> In A. D. Gordon and A. M. Pitts (Eds.), </editor> <title> Higher Order Operational Techniques in Semantics. </title> <publisher> Cambridge University Press. This volume. </publisher>
Reference-contexts: It is a difficult question how operational equivalences a = b may be established in practice (see <ref> (Talcott 1997) </ref> in this volume for more on this topic). Using computational induction as outlined above to directly establish operational equivalences is in fact very difficult.
References-found: 29

