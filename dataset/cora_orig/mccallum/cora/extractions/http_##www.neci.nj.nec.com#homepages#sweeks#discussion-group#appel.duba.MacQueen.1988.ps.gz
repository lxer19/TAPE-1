URL: http://www.neci.nj.nec.com/homepages/sweeks/discussion-group/appel.duba.MacQueen.1988.ps.gz
Refering-URL: http://www.neci.nj.nec.com/homepages/sweeks/discussion-group/index.html
Root-URL: http://www.neci.nj.nec.com
Title: Profiling in the Presence of Optimization and Garbage Collection  
Author: Andrew W. Appel* Bruce F. Duba David B. MacQueen 
Address: Murray Hill, NJ.  
Affiliation: AT&T Bell Laboratories,  
Note: Supported in part by NSF Grant CCR-8806121 and by a Digital Equipment Corp. Faculty Incentive Grant.  
Date: November 1988  
Abstract: Profiling the execution of programs can be a great help in tuning their performance, and programs written in functional languages are no exception. The standard techniques of call-counting and statistical (interrupt-driven) execution time measurement work well, but with some modification. In particular, the program counter is not the best indicator of ``current function.'' Our profiler inserts explicit increment and assignment statements into the intermediate representation, and is therefore very simple to implement and completely independent of the code-generator. 
Abstract-found: 1
Intro-found: 1
Reference: [Appel87] <author> Appel, Andrew W. and MacQueen, David B. </author> <title> ``A Standard ML compiler,'' </title> <booktitle> in Functional Programming Languages and Computer Architecture, </booktitle> <volume> LNCS 274, </volume> <editor> G. Kahn, </editor> <publisher> ed., </publisher> <pages> pp 301-324, </pages> <year> 1987 </year>
Reference-contexts: This problem -3- could have been solved by elaborate bookkeeping in the runtime system, which we also wanted to avoid. We had to deal with these problems in the course of implementing a profiler for an optimizing compiler for the functional language Standard ML <ref> [Appel87] </ref>. The approach we used is described in the next section. 2. Intermediate Representation of call-counting and current-function For execution-time estimation we use a timer interrupt, as does prof, to increment a histogram entry. How-ev er, we don't use the program counter to calculate which histogram entry to increment.
Reference: [Graham82] <author> Graham, Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick. </author> <title> ``gprof: a call graph execution profiler''" in Proc. </title> <booktitle> SIGPLAN '82 Symp. on Compiler Construction, SIG-PLAN Notices 17(4), </booktitle> <pages> pp. 120-126, </pages> <year> 1982. </year>
Reference-contexts: The interrupt-driven sampling method has a much lower overhead than querying a clock on each entry to and exit from a function. A more elaborate profiling tool, gprof <ref> [Graham82] </ref>, provides even more information. When one primitive function (e.g. a table-lookup routine) is used in many places, it is useful to know, not only the total time for the execution of the primitive, but also, how much time to ``charge'' the calling functions.
Reference: [Johnston70] <author> Johnston, T. Y., and Johnson, R. H., </author> <title> Program Performance Measurement, SLAC User Note 33, </title> <type> Rev. 1, </type> <institution> Stanford University, California, </institution> <year> 1970. </year>
Reference-contexts: An approximation to the amount of total time spent in the function is gathered by the use of a timer interrupt: ev ery 1/60th of a second, the operating system notes in a ``histogram'' array the value of the program counter. (This is an ancient technique <ref> [Johnston70] </ref>.) Then, at the end of program execution, prof estimates the amount of time spent in each function by summing the values in the histogram array corresponding to program counter samples between the beginning and end of the machine code for that function.
Reference: [Unix] <institution> Unix Programmer's Manual, ``prof command,'' section 1, Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1979. </year>
Reference-contexts: By using a theoretical analysis of the algorithms used in a program, such functions can be identified; but a complete theoretical analysis is complex and impractical for large programs. An execution profiler provides an empirical measurement of the time spent in each function. A widely-used Unix tool, prof <ref> [Unix] </ref>, provides a count of how many times each function is called, and how many seconds were spent in each function.
References-found: 4

