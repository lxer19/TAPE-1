URL: ftp://ftp.cs.washington.edu/tr/1993/05/UW-CSE-93-05-05.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: Training Compilers for Better Inlining Decisions  
Author: Jeffrey Dean and Craig Chambers 
Abstract: Department of Computer Science and Engineering, FR-35 University of Washington Seattle, Washington 98195 USA Technical Report 93-05-05 May 1993 
Abstract-found: 1
Intro-found: 1
Reference: [Agesen et al. 93] <author> Ole Agesen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Type Inference of SELF. </title> <booktitle> To appear in ECOOP 93 Conference Proceedings, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July, </month> <year> 1993. </year>
Reference-contexts: Good inlining decision making will become more important in the future, as new implementation techniques, such as more sophisticated type analysis, interprocedural type analysis <ref> [Agesen et al. 93] </ref>, and adaptive recompilation systems [Hlzle et al. 91b], enable more methods to be inlined. With these increased opportunities for inlining come increased responsibility for inlining wisely. The techniques of inlining experiments and maintaining an inlining database are not specific to SELF nor even to object-oriented languages.
Reference: [Aho et al. 86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Other static information at the call site might have an effect on the generated code, such as the set of available expressions for common subexpression elimination <ref> [Aho et al. 86] </ref>, but we expect this to be a relatively minor effect. Each time an optimization is performed, the compiler estimates the amount of time the optimization saved, derived from the code which would have been emitted and executed if the optimization had not been performed.
Reference: [Allen & Johnson 88] <author> Randy Allen and Steve Johnson. </author> <title> Compiling C for Vectorization, Parallelization, and Inline Expansion. </title> <booktitle> In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 241-249, </pages> <address> Atlanta, GA, </address> <month> June, </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(7), </note> <month> July, </month> <year> 1988. </year>
Reference-contexts: We believe that the area of compiler self-monitoring offers new opportunities for adaptive, optimizing systems. 6 Related Work Previous work on automatic inlining focuses primarily on attempting to maximize the direct benefits of inlining without too much increase in compiled code space <ref> [Scheier 77, Allen & Johnson 88, Chang et al. 92] </ref>. In the context of this related work, indirect benefits of inlining tend to be relatively unimportant.
Reference: [Chambers et al. 89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 49-70, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Balancing the 2 costs against the benefits to simultaneously achieve short compile times and short execution times is a difficult task. Keeping compilation time low is particularly important for SELF since SELF is based on dynamic compilation technology <ref> [Deutsch & Schiffman 84, Chambers et al. 89] </ref>, where the system interleaves compilation and execution, thereby making compilation pauses visible at run time. <p> The current SELF compiler generates a customized version of a method for each receiver class used during program execution <ref> [Chambers et al. 89] </ref>. Customization lets the compiler determine statically the class of the receiver in the body of a customized method, enabling all sends to self to be inlined. In effect, each routine is partially evaluated with respect to class of the receiver.
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference-contexts: SELF is a dynamically-typed object-oriented language that provides only object-oriented features to the programmer [Ungar & Smith 87, Hlzle et al. 91a]. In order to obtain reasonable performance, the SELF compiler performs several optimizations that allow a significant percentage of message sends to be inlined <ref> [Chambers & Ungar 91, Hlzle et al. 91b, Chambers 92] </ref>.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <type> technical report STAN-CS-92-1420, </type> <month> March, </month> <year> 1992. </year>
Reference-contexts: SELF is a dynamically-typed object-oriented language that provides only object-oriented features to the programmer [Ungar & Smith 87, Hlzle et al. 91a]. In order to obtain reasonable performance, the SELF compiler performs several optimizations that allow a significant percentage of message sends to be inlined <ref> [Chambers & Ungar 91, Hlzle et al. 91b, Chambers 92] </ref>. <p> It is done to preserve type information present along the paths that would be lost if the paths were merged together. This allows transforming polymorphic code along the single path into multiple paths containing monomorphic code, enabling optimizations such as inlining to be performed along the paths <ref> [Chambers 92] </ref>. Splitting occurs when the compiler has merged together multiple paths in the CFG graph, but later decides that it would be worthwhile to postpone the merge so that it can exploit type information on one or more of the merged paths.
Reference: [Chang et al. 92] <author> Phua P. Chang, Scott A. Mahlke, William Y. Chen, and Wen-Mei W. Hwu. </author> <title> Profile-guided Automatic Inline Expansion for C Programs. </title> <booktitle> In Software Practice and Experience 22(5), </booktitle> <pages> pp. 349-369, </pages> <month> May, </month> <year> 1992. </year>
Reference-contexts: We believe that the area of compiler self-monitoring offers new opportunities for adaptive, optimizing systems. 6 Related Work Previous work on automatic inlining focuses primarily on attempting to maximize the direct benefits of inlining without too much increase in compiled code space <ref> [Scheier 77, Allen & Johnson 88, Chang et al. 92] </ref>. In the context of this related work, indirect benefits of inlining tend to be relatively unimportant.
Reference: [Cooper et al. 92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> Procedure Cloning. </title> <booktitle> In Proceeding of the 1992 IEEE International Conference on Computer Languages, </booktitle> <pages> pp. 96-105, </pages> <address> Oakland, CA, </address> <month> April, </month> <year> 1992. </year>
Reference-contexts: Cooper, Hall, and Kennedy present a technique for identifying when creating multiple, specialized copies of a procedure can enable optimizations <ref> [Cooper et al. 92] </ref>. They apply this algorithm to the interprocedural constant propagation problem.
Reference: [Dean & Chambers 93] <author> Jeffrey Dean and Craig Chambers. </author> <title> Training Compilers for Better Inlining Decisions. </title> <note> Submitted to OOPSLA 93. </note>
Reference: [Deutch & Schiffman 84] <editor> Efficient Implementation of the Smalltalk-80 System. </editor> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 297-302, </pages> <address> Salt Lake City, UT, </address> <month> January, </month> <year> 1984. </year>
Reference: [Hlzle et al. 91a] <author> Urs Hlzle, Bay-Wei Chang, Craig Chambers, Ole Ageson, and David Ungar. </author> <title> The SELF Manual, </title> <note> Version 1.1, unpublished manual, </note> <month> February, </month> <year> 1991. </year>
Reference-contexts: Implemented straightforwardly, a message send requires additional run-time type tests or memory indirections on top of a normal procedure call. Consequently, efficient implementations of object-oriented languages focus on implementing message sends more efficiently. SELF is a dynamically-typed object-oriented language that provides only object-oriented features to the programmer <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>. In order to obtain reasonable performance, the SELF compiler performs several optimizations that allow a significant percentage of message sends to be inlined [Chambers & Ungar 91, Hlzle et al. 91b, Chambers 92].
Reference: [Hlzle et al. 91b] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Programming Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91 Conference Proceedings, </booktitle> <pages> pp. 21-38, </pages> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: SELF is a dynamically-typed object-oriented language that provides only object-oriented features to the programmer [Ungar & Smith 87, Hlzle et al. 91a]. In order to obtain reasonable performance, the SELF compiler performs several optimizations that allow a significant percentage of message sends to be inlined <ref> [Chambers & Ungar 91, Hlzle et al. 91b, Chambers 92] </ref>. <p> Good inlining decision making will become more important in the future, as new implementation techniques, such as more sophisticated type analysis, interprocedural type analysis [Agesen et al. 93], and adaptive recompilation systems <ref> [Hlzle et al. 91b] </ref>, enable more methods to be inlined. With these increased opportunities for inlining come increased responsibility for inlining wisely. The techniques of inlining experiments and maintaining an inlining database are not specific to SELF nor even to object-oriented languages.
Reference: [Ruf & Weise 91] <author> Erik Ruf and Daniel Weise. </author> <title> Using Types to Avoid Redundant Specialization. </title> <booktitle> In Proceedings of the PEPM 91 Symposium on Partial Evaluation and Semantics-Based Program Manipulations, </booktitle> <pages> pp. 321-333, </pages> <address> New Haven, CT, </address> <month> June, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(9), </note> <month> September, </month> <year> 1991. </year>
Reference-contexts: Additionally, the indirect benefits of inlining often are more important in determining profitability than the simple direct costs. Ruf and Weise describe a technique for avoiding redundant specialization in a partial evaluator for Scheme <ref> [Ruf & Weise 91] </ref>. When specializing a called routine for the static information available at a call site, their technique computes a generalization of the actual types that still leads to the same specialized version of the called routine.
Reference: [Scheier 77] <author> Robert W. Scheier. </author> <title> An Analysis of Inline Substitution for a Structured Programming Language. </title> <booktitle> In Communications of the ACM 20(9), </booktitle> <pages> pp. 647-654, </pages> <month> September, </month> <year> 1977. </year>
Reference-contexts: We believe that the area of compiler self-monitoring offers new opportunities for adaptive, optimizing systems. 6 Related Work Previous work on automatic inlining focuses primarily on attempting to maximize the direct benefits of inlining without too much increase in compiled code space <ref> [Scheier 77, Allen & Johnson 88, Chang et al. 92] </ref>. In the context of this related work, indirect benefits of inlining tend to be relatively unimportant.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year> <month> 20 </month>
Reference-contexts: Implemented straightforwardly, a message send requires additional run-time type tests or memory indirections on top of a normal procedure call. Consequently, efficient implementations of object-oriented languages focus on implementing message sends more efficiently. SELF is a dynamically-typed object-oriented language that provides only object-oriented features to the programmer <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>. In order to obtain reasonable performance, the SELF compiler performs several optimizations that allow a significant percentage of message sends to be inlined [Chambers & Ungar 91, Hlzle et al. 91b, Chambers 92].
References-found: 15

