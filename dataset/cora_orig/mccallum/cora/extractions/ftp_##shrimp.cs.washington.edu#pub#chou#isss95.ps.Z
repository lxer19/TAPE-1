URL: ftp://shrimp.cs.washington.edu/pub/chou/isss95.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/lis/chinook/www/publications.html
Root-URL: 
Title: The Chinook Hardware/Software Co-Synthesis System  
Author: Pai H. Chou Ross B. Ortega Gaetano Borriello 
Address: Seattle, WA 98195-2350  
Affiliation: Department of Computer Science Engineering University of Washington  
Abstract: Designers of embedded systems are facing ever tighter constraints on design time, but computer aided design tools for embedded systems have not kept pace with these trends. The Chinook co-synthesis system addresses the automation of the most time-consuming and error-prone tasks in embedded controller design, namely: the synthesis of interface hardware and software needed to integrate system components; the migration of functions between processors or custom logic; and the co-simulation of the design before, during, and after synthesis. This paper describes the principal elements of Chinook and discuss its application to a variety of embedded designs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Boussinot and R. De Simone. </author> <title> The Esterel language. </title> <journal> Proc. IEEE, </journal> <volume> 79(9), </volume> <month> Sept. </month> <year> 1991. </year>
Reference: [2] <author> CADENCE Design Systems, Inc. </author> <title> Programming Language Interface Reference Manual. CADENCE Design Systems, </title> <publisher> Inc., </publisher> <year> 1992. </year>
Reference-contexts: As abstract communications and operations become refined into more concrete signals and components, outputs from intermediate design steps and the final implementation can also be simulated with cycle-level accuracy. The simulator uses the Verilog-XL Programming Language Interface <ref> [2] </ref> to communicate with peripheral device models. The device models are written in C and make X-window calls to visually represent the simulated device. Each device model exports the same application program interface (API) for simulation and synthesis.
Reference: [3] <author> M. Chiodo et al. </author> <title> HW-SW codesign of embedded systems. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 26-36, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: This is for the most part done informally using a mixture of natural language documents, pseudo-code, and block diagrams. This approach has made design maintenance, upgrading, and retargeting very time consuming and difficult. Several formal specification methods have been proposed including finite state machines <ref> [3] </ref>, Petri nets [18], and CSP [15]. Today's tools lie somewhere in the middle, using a high-level programming or a simulatable hardware description language, but there is still no accepted formalization of the timing and performance constraints.
Reference: [4] <author> P. Chou and G. Borriello. </author> <title> Software scheduling in the co-synthesis of reactive real-time systems. </title> <booktitle> In Proc. 31st DAC, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: We do not use critical regions to achieve atomic execution because they disable interleaving, which is necessary when servicing devices with long separation between sequential events. Instead, Chinook allows the user to define safe points in the handlers, where potential mode transitions can safely occur <ref> [4] </ref>. All parallel handlers must reach their safe points before a mode transition is allowed to take effect. 6 Interface Synthesis Interface synthesis is the realization of communication between components via both hardware and software elements. Chinook handles a wide range of interface synthesis problems.
Reference: [5] <author> P. Chou and G. Borriello. </author> <title> Interval scheduling: Fine-grained software scheduling for embedded systems. </title> <booktitle> In Proc. 32nd DAC, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Chinook statically schedules all low-level I/O and high-level operations as grouped in modes. A customized dynamic scheduler may be generated for modes at the top of the hierarchy. Chinook uses a static, nonpreemptive scheduling algorithm to meet min/max timing constraints on fine-grained operations with delay ranges <ref> [5] </ref>. It determines a serial ordering for the operations, and inserts delays to meet minimum constraints, if necessary. Because the complexity of the problem is NP-hard, we use heuristics to help the exact algorithm quickly find a valid and short schedule.
Reference: [6] <author> P. Chou, R. Ortega, and G. Borriello. </author> <title> Interface Co-Synthesis Techniques for Embedded Systems. </title> <booktitle> In Proc. </booktitle> <address> IC-CAD, </address> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: Devices are allocated portions of the address space of the processor controlling them. Currently Chinook can synthesize address matching logic using either one-hot, binary, or Huffman encoding to address the devices <ref> [6] </ref>. Chi-nook also generates the I/O primitives in terms of load/store instructions. 7 Communication Synthesis Requirements for faster response times and increased modularity frequently guide embedded system designers to employ multiple processors. These processors are often heterogeneous as cost and modularity concerns drive designers to tailor processors to specific functions. <p> The general solution to this requires behavioral synthesis but is quite straightforward in most cases. The original software is replaced with routines that pass the inputs, kick-start the state machine on the other processor, and then read back the result <ref> [6] </ref>. 8 Simulation The design can be simulated at different levels of detail. The initial specification is compatible with behavioral Ver-ilog and is simulated without exact timing or detailed I/O.
Reference: [7] <author> P. Chou, R. Ortega, and G. Borriello. </author> <booktitle> Synthesis of the HW/SW interface in microcontroller-based systems. In Proc. </booktitle> <address> ICCAD, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: These ports can be accessed from software-like registers thus providing a low-cost and straightforward interfacing mechanism. Chinook provides a port allocation scheme that also outputs customized access routines to reflect the pin assignment <ref> [7] </ref>. The key idea is that an I/O port may be able to service multiple devices without glue logic and without performance penalties. These devices have interfaces that are able to isolate themselves from the shared bus, and become active only when the appropriate control signals, or guards, enable them.
Reference: [8] <author> P. Chou, E. A. Walkup, and G. Borriello. </author> <title> Scheduling for reactive real-time systems. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 37-47, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: At the low level, the constraints may correspond to setup and hold times, or simply the sequencing constraints between successive I/Os. At the high level, they may express response times to system inputs and rate constraints on performance <ref> [8] </ref>. In a given mode, the system's responses are defined by a set of handlers. Conceptually, they are event-triggered routines, but their activation conditions are checked by a time-triggered loop. A handler consists of a trigger condition and a body. <p> In statically scheduling the software, Chinook first converts handlers within a mode into a single handler containing their bodies, possibly using unrolling, and then schedules this single partially-ordered handler by interleaving <ref> [8] </ref>. Note that a mode transition may be triggered by one of the handlers before other handlers run to completion, and the scheduler must maintain the integrity of all handler states.
Reference: [9] <author> R. Ernst, J. Henkel, and T. Benner. </author> <title> HW-SW cosynthesis for microcontrollers. </title> <journal> IEEE D&TC, </journal> <volume> 10(4) </volume> <pages> 64-75, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Partitioning is the process of determining the components on which to implement portions of system functionality. This may be a split between a processor and auxiliary logic or among a set of processors. Attempts at automating partitioning have included simulated annealing algorithms <ref> [9] </ref> and hardware to software migration [12] but have generally ignored interfacing and communication between the parts. In fact, designers spend a large fraction of the time in interfacing system components to each other and the operating environment, including user interfaces, because it is where the bulk of errors lie.
Reference: [10] <author> D. D. Gajski and F. Vahid. </author> <title> Specification and design of embedded HW-SW systems. </title> <journal> IEEE D&TC, </journal> <volume> 12(1) </volume> <pages> 53-67, </pages> <month> Spring </month> <year> 1995. </year>
Reference: [11] <author> B. Gladstone. </author> <title> Specification of timing in a digital system. ASIC and EDA, </title> <address> pp.46-52, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: The first are requirements imposed on the user of the interface, while the last two are timing promises made by the device. When new devices are added to the device library, these constraints and their corresponding timing diagrams are entered via an interactive editor <ref> [11] </ref>.
Reference: [12] <author> R. Gupta and G. De Micheli. </author> <title> HW-SW cosynthesis for digital systems. </title> <journal> Computers and Electrical Engineering, </journal> <volume> 10(3) </volume> <pages> 29-41, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: Partitioning is the process of determining the components on which to implement portions of system functionality. This may be a split between a processor and auxiliary logic or among a set of processors. Attempts at automating partitioning have included simulated annealing algorithms [9] and hardware to software migration <ref> [12] </ref> but have generally ignored interfacing and communication between the parts. In fact, designers spend a large fraction of the time in interfacing system components to each other and the operating environment, including user interfaces, because it is where the bulk of errors lie.
Reference: [13] <author> R. K. Gupta and G. De Micheli. </author> <title> Constrained software generation for HW-SW systems. In Pro. </title> <booktitle> 3rd Int'l Workshop on HW/SW Codesign, </booktitle> <address> pp.56-63, </address> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: Because the complexity of the problem is NP-hard, we use heuristics to help the exact algorithm quickly find a valid and short schedule. Experimental results show that our best heuristic consistently outperforms one that solves the same problem inexactly <ref> [13] </ref>. At the high level, rate constraints are specified on a ref-erence event between successive iterations, and response times are constraints on the time it takes to do a mode transition.
Reference: [14] <author> D. Harel. StateCharts: </author> <title> a visual formalism for complex systems. </title> <journal> Science of Programming, </journal> <volume> 8, </volume> <year> 1987. </year>
Reference-contexts: A mode also defines a scope for a set of timing constraints that must be satisfied while the system is within that mode but not necessarily when it is operating outside of it. Modes are similar to the hierarchical states of <ref> [14] </ref> in that they can capture both sequential and concurrent behavior. Chinook allows the specification of real-time requirements in terms of minimum and maximum separation between I/O events. At the low level, the constraints may correspond to setup and hold times, or simply the sequencing constraints between successive I/Os.
Reference: [15] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: This approach has made design maintenance, upgrading, and retargeting very time consuming and difficult. Several formal specification methods have been proposed including finite state machines [3], Petri nets [18], and CSP <ref> [15] </ref>. Today's tools lie somewhere in the middle, using a high-level programming or a simulatable hardware description language, but there is still no accepted formalization of the timing and performance constraints. Without these constraints explicitly represented, designers must devise and validate software schedules and interactions between components by hand.
Reference: [16] <author> J. Kuskin et al. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In 21st Annual International Symposium on Computer Architecture, </booktitle> <address> pp.302-313, </address> <year> 1994. </year>
Reference-contexts: After building this application in hardware according to the generated netlist, the system operated correctly upon applying power. 9.2 MAGIC The MAGIC (Memory and General Interconnect Con troller) is a custom node controller for the FLASH architecture <ref> [16] </ref>. It communicates with a processor, network, I/O devices and DRAM (see Figure 2b). We modeled this architecture with three handlers, one for the processor requests, one for the network requests and one for the I/O requests.
Reference: [17] <author> A. K. Mok. </author> <title> The design of real-time programming systems based on process models. In Real Time Systems Symposium, </title> <address> pp.5-17, </address> <year> 1984. </year>
Reference-contexts: Their interaction with the devices and the environment must respect not only low-level signaling constraints but also performance requirements such as rate and response time constraints. To satisfy these high-level constraints, designers have used process-based scheduling techniques based on operating systems concepts <ref> [17] </ref>. These techniques are coarse-grained, priority-driven, and dynamically preemptive. They assume that the processor does not perform I/O directly and the processes are independent of each other. Since all timing constraints are coarse-grained, overhead incurred by the executive during preemption can be dismissed.
Reference: [18] <author> T. Murata. </author> <title> Petri nets: Properties, analysis, </title> <journal> and applications. Proc. IEEE, </journal> <volume> 77(4) </volume> <pages> 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: This is for the most part done informally using a mixture of natural language documents, pseudo-code, and block diagrams. This approach has made design maintenance, upgrading, and retargeting very time consuming and difficult. Several formal specification methods have been proposed including finite state machines [3], Petri nets <ref> [18] </ref>, and CSP [15]. Today's tools lie somewhere in the middle, using a high-level programming or a simulatable hardware description language, but there is still no accepted formalization of the timing and performance constraints.
Reference: [19] <author> C. Y. Park. </author> <title> Predicting Deterministic Execution Times of Real-Time Programs. </title> <type> PhD thesis, </type> <institution> Univ. of Washington, </institution> <year> 1992. </year> <type> TR 92-08-02, </type> <institution> Dep't of CS&E. </institution>
Reference-contexts: The device library contains detailed generic specifications of device interfaces (in the form of timing diagrams and Verilog code) and mod els for their simulation (in C). For processors it contains specifications of their interfaces as well as timing schemas for software run-time estimation <ref> [19] </ref>.
Reference: [20] <author> M. Srivastava, B.C.Richards, and R.W.Brodersen. </author> <title> System level hardware module generation. </title> <journal> IEEE Trans. on VLSI Systems, </journal> <volume> 3(1), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: Yet, interfacing remains one of the least addressed areas in many co-synthesis tools. The interfacing task may involve both hardware and software aspects of the interface as well as low level timing concerns that may require glue logic. Interface generation has been described in <ref> [20] </ref>, though the synthesis of interface software is not addressed. Other aspects of the embedded system design cycle include retargetable code-generation, for off-the-shelf processors as well as custom ones.
Reference: [21] <author> D. E. Thomas and P. R. Moorby. </author> <title> The Verilog Hardware Description Language. </title> <publisher> Kluwer Academic, </publisher> <year> 1991. </year>
Reference: [22] <author> E. A. Walkup and G. Borriello. </author> <title> Interface timing verification with application to synthesis. </title> <booktitle> In Proc. 31st DAC, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: When new devices are added to the device library, these constraints and their corresponding timing diagrams are entered via an interactive editor [11]. Chinook parses these files and synthesizes the device driver code by choosing a linear schedule of controller events, and inserting additional interface glue logic where necessary <ref> [22] </ref>. 6.2 I/O Port Allocation Many processors used in embedded systems include I/O ports that can be used to directly sense and manipulate the processor's environment. These ports can be accessed from software-like registers thus providing a low-cost and straightforward interfacing mechanism.
References-found: 22

