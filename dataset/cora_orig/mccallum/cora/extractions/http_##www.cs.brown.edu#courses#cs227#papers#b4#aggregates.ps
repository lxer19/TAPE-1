URL: http://www.cs.brown.edu/courses/cs227/papers/b4/aggregates.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: Sophie.Cluet@inria.fr moer @gom.informatik.rwth-aachen.de  
Title: Efficient Evaluation of Aggregates on Bulk Types  
Author: Sophie Cluet Guido Moerkotte 
Date: February 5, 1996  
Address: BP 105 RWTH-Aachen Domaine de Voluceau Ahornstr. 55 78153 Le Chesnay Cedex 52074 Aachen France Germany  
Affiliation: INRIA Lehrstuhl fur Informatik III  
Abstract: A new method for efficiently evaluating queries with aggregate functions is presented. More specifically, we introduce a class of aggregate queries where traditional query evaluation strategies in general require O(n 2 ) time and space in the size of the (at most two) input relations. For this class of aggregate queries our approach needs at most O(n log n) time and linear space. Further, our approach deals not only with relations but with general bulk types like sets, bags, and lists.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. M. Astrahan and D. D. Chamberlin. </author> <title> Implementation of a structured English query language. </title> <journal> Communications of the ACM, </journal> <volume> 18(10) </volume> <pages> 580-588, </pages> <year> 1975. </year> <month> 10 </month>
Reference-contexts: In this paper we are concerned with the efficient evaluation of aggregate functions. At the source level of an SQL-like query language, aggregate functions are often expressed as nested queries (Type JA of Kim's classification [14]). The original proposal to evaluate these queries is to perform a nested loop <ref> [1] </ref>. In order to eliminate the inherent inefficiency of this approach, Kim suggests a more efficient method [14]: perform a join between the relations of the outer and inner block, group the result, and then apply the scalar aggregate to each group.
Reference: [2] <author> C. Beeri and Y. Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <booktitle> In Proc. Int. Conf. on Database Theory (ICDT), </booktitle> <pages> pages 72-88, </pages> <year> 1990. </year>
Reference-contexts: Operations corresponding to + can be defined for all bulk types (see, e.g., <ref> [2] </ref>: their bulk constructor C can be used to define +). For all bulk types, we denote membership by the symbol 2. <p> Sec. 3.4). Nevertheless, this point is beyond the scope of the paper. 2 the elements of a bulk instance where duplicates are iterated over as many times as they are present and bulk type orders are adhered to. This roughly corresponds to the apply-to-all operator <ref> [2] </ref> but foreach will be used at a lower level of abstraction as a means for expressing query evaluation plans. At the algebraic level, we use the operator instead.
Reference: [3] <author> S. Ceri and G. Pelagatti. </author> <title> Correctness of query execution strategies in distributed databases. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 8(4):?-?, </volume> <year> 1983. </year>
Reference-contexts: Third, -tables can be used to efficiently implement the binary grouping operation introduced in [8] in order to enable the unnesting of queries which cannot be unnested otherwise. Fourth, the technique introduced here can be seen as an extension of two techniques proposed in Section 5.3 of [4] and <ref> [3] </ref>.
Reference: [4] <author> S. Ceri and G. Pelagatti. </author> <title> Distributed Databases. </title> <booktitle> Computer Science Series. </booktitle> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference-contexts: Third, -tables can be used to efficiently implement the binary grouping operation introduced in [8] in order to enable the unnesting of queries which cannot be unnested otherwise. Fourth, the technique introduced here can be seen as an extension of two techniques proposed in Section 5.3 of <ref> [4] </ref> and [3]. <p> Last not least, since -tables are implicit representations of -joins, their usefulness for efficiently evaluating successive non-equi joins seems worth to be investigated. Acknowledgement: We thank the anonymous referees for their detailed comments. We also thank S. Ceri for pointing out to us Chapter 5 of <ref> [4] </ref>.
Reference: [5] <author> S. Chaudhuri and K. Shim. </author> <title> Including group-by in query optimization. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 354-366, </pages> <address> Santiago, Chile, </address> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops [7, 16, 17]. Let us call this approach A-G-J. Lately, it was proposed to exchange grouping and aggregate operations 1 with joins <ref> [19, 18, 20, 5, 6] </ref>. This work is orthogonal to our's in that our method can be used to implement the grouping and aggregate operations used there. Consider the performance of this approach if the join is a non-equi join, e.g., a -join, or 6=-join.
Reference: [6] <author> S. Chaudhuri and K. Shim. </author> <title> The promise of early aggregation. </title> <type> Technical report, </type> <institution> HP Lab, </institution> <year> 1994. </year>
Reference-contexts: Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops [7, 16, 17]. Let us call this approach A-G-J. Lately, it was proposed to exchange grouping and aggregate operations 1 with joins <ref> [19, 18, 20, 5, 6] </ref>. This work is orthogonal to our's in that our method can be used to implement the grouping and aggregate operations used there. Consider the performance of this approach if the join is a non-equi join, e.g., a -join, or 6=-join.
Reference: [7] <author> S. Cluet and G. Moerkotte. </author> <title> Nested queries in object bases. </title> <booktitle> In Proc. Int. Workshop on Database Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: The main point is to use an outer join instead of a regular join. Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops <ref> [7, 16, 17] </ref>. Let us call this approach A-G-J. Lately, it was proposed to exchange grouping and aggregate operations 1 with joins [19, 18, 20, 5, 6]. This work is orthogonal to our's in that our method can be used to implement the grouping and aggregate operations used there. <p> Hence, any bulk (t ) instance is turned into a bulk ([x : t ]) instance. The main motivation behind these definitions is that it is quite convenient to deal with bulks of tuples only <ref> [7, 12] </ref>. The last operator needed on bulk types is selection. For a function p : t ! Bool, it is denoted by p and has the signature p : bulk (t ) ! bulk (t ).
Reference: [8] <author> S. Cluet and G. Moerkotte. </author> <title> Classification and optimization of nested queries in object bases. </title> <type> Technical Report 95-6, </type> <institution> RWTH Aachen, </institution> <year> 1995. </year>
Reference-contexts: Second, note that the methods add and eval give a possible implementation of the generalized aggregate function G-aggr [9]. Remember that G-aggr is a combination of (unary) grouping and the computation of a scalar aggregate. Third, -tables can be used to efficiently implement the binary grouping operation introduced in <ref> [8] </ref> in order to enable the unnesting of queries which cannot be unnested otherwise. Fourth, the technique introduced here can be seen as an extension of two techniques proposed in Section 5.3 of [4] and [3].
Reference: [9] <author> U. Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates, and quantifiers. </title> <booktitle> In VLDB, </booktitle> <pages> pages 197-208, </pages> <year> 1987. </year>
Reference-contexts: Clearly, if the join is an equi-join, this can be efficiently implemented. Subsequently, several bugs in this approach have been detected and corrected <ref> [9, 11, 13] </ref>. The main point is to use an outer join instead of a regular join. Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops [7, 16, 17]. Let us call this approach A-G-J. <p> Hence, they can also be used to optimize queries involving non-equi joins. Second, note that the methods add and eval give a possible implementation of the generalized aggregate function G-aggr <ref> [9] </ref>. Remember that G-aggr is a combination of (unary) grouping and the computation of a scalar aggregate. Third, -tables can be used to efficiently implement the binary grouping operation introduced in [8] in order to enable the unnesting of queries which cannot be unnested otherwise.
Reference: [10] <author> R. Epstein. </author> <title> Techniques for processing of aggregates in relational database systems. </title> <institution> ERL/UCB Memo M79/8, University of California, Berkeley, </institution> <year> 1979. </year>
Reference-contexts: 1 Introduction Many queries involve the application of functions like count, sum, avg [15]. Among these queries, two different classes can be detected: scalar aggregates and aggregate functions <ref> [10] </ref>. Scalar aggregates return a single number from an input relation. Examples thereof are count, sum, avg etc. Aggregate functions, on the other hand, return a set of values for a given relation. Aggregate functions typically involve grouping. Then, a scalar aggregate is applied to each group.
Reference: [11] <author> R. Ganski and H. Wong. </author> <title> Optimization of nested SQL queries revisited. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 23-33, </pages> <year> 1987. </year>
Reference-contexts: Clearly, if the join is an equi-join, this can be efficiently implemented. Subsequently, several bugs in this approach have been detected and corrected <ref> [9, 11, 13] </ref>. The main point is to use an outer join instead of a regular join. Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops [7, 16, 17]. Let us call this approach A-G-J.
Reference: [12] <author> A. Kemper and G. Moerkotte. </author> <title> Query optimization in object bases: Exploiting relational techniques. </title> <booktitle> In Proc. Dagstuhl Workshop on Query Optimization (J.-C. </booktitle> <editor> Freytag, D. Maier und G. Vossen (eds.)). Morgan-Kaufman, </editor> <year> 1993. </year>
Reference-contexts: Hence, any bulk (t ) instance is turned into a bulk ([x : t ]) instance. The main motivation behind these definitions is that it is quite convenient to deal with bulks of tuples only <ref> [7, 12] </ref>. The last operator needed on bulk types is selection. For a function p : t ! Bool, it is denoted by p and has the signature p : bulk (t ) ! bulk (t ).
Reference: [13] <author> W. Kiessling. </author> <title> SQL-like and Quel-like correlation queries with aggregates revisited. </title> <type> ERL/UCB Memo 84/75, </type> <institution> University of Berkeley, </institution> <year> 1984. </year>
Reference-contexts: Clearly, if the join is an equi-join, this can be efficiently implemented. Subsequently, several bugs in this approach have been detected and corrected <ref> [9, 11, 13] </ref>. The main point is to use an outer join instead of a regular join. Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops [7, 16, 17]. Let us call this approach A-G-J.
Reference: [14] <author> W. Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <month> Sep 82. </month>
Reference-contexts: As an example consider the query retrieving the number of employees for each department. In this paper we are concerned with the efficient evaluation of aggregate functions. At the source level of an SQL-like query language, aggregate functions are often expressed as nested queries (Type JA of Kim's classification <ref> [14] </ref>). The original proposal to evaluate these queries is to perform a nested loop [1]. In order to eliminate the inherent inefficiency of this approach, Kim suggests a more efficient method [14]: perform a join between the relations of the outer and inner block, group the result, and then apply the <p> level of an SQL-like query language, aggregate functions are often expressed as nested queries (Type JA of Kim's classification <ref> [14] </ref>). The original proposal to evaluate these queries is to perform a nested loop [1]. In order to eliminate the inherent inefficiency of this approach, Kim suggests a more efficient method [14]: perform a join between the relations of the outer and inner block, group the result, and then apply the scalar aggregate to each group. Clearly, if the join is an equi-join, this can be efficiently implemented.
Reference: [15] <author> A. Klug. </author> <title> Access paths in the "ABE" statistical query facility. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 161-173, </pages> <address> Orlando, Fla., </address> <month> June </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Many queries involve the application of functions like count, sum, avg <ref> [15] </ref>. Among these queries, two different classes can be detected: scalar aggregates and aggregate functions [10]. Scalar aggregates return a single number from an input relation. Examples thereof are count, sum, avg etc. Aggregate functions, on the other hand, return a set of values for a given relation.
Reference: [16] <author> M. Muralikrishna. </author> <title> Improved unnesting algorithms for join aggregate SQL queries. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 91-102, </pages> <year> 1992. </year>
Reference-contexts: The main point is to use an outer join instead of a regular join. Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops <ref> [7, 16, 17] </ref>. Let us call this approach A-G-J. Lately, it was proposed to exchange grouping and aggregate operations 1 with joins [19, 18, 20, 5, 6]. This work is orthogonal to our's in that our method can be used to implement the grouping and aggregate operations used there.
Reference: [17] <author> R. Nakano. </author> <title> Translation with optimization from relational calculus to relational algebra having aggregate funktions. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 15(4) </volume> <pages> 518-557, </pages> <year> 1990. </year>
Reference-contexts: The main point is to use an outer join instead of a regular join. Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops <ref> [7, 16, 17] </ref>. Let us call this approach A-G-J. Lately, it was proposed to exchange grouping and aggregate operations 1 with joins [19, 18, 20, 5, 6]. This work is orthogonal to our's in that our method can be used to implement the grouping and aggregate operations used there.
Reference: [18] <author> W. Yan and P.-A. Larson. </author> <title> Performing group-by before join. </title> <type> Technical Report CS 93-46, </type> <institution> Dept. of Computer Science, University of Waterloo, Canada, </institution> <year> 1993. </year>
Reference-contexts: Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops [7, 16, 17]. Let us call this approach A-G-J. Lately, it was proposed to exchange grouping and aggregate operations 1 with joins <ref> [19, 18, 20, 5, 6] </ref>. This work is orthogonal to our's in that our method can be used to implement the grouping and aggregate operations used there. Consider the performance of this approach if the join is a non-equi join, e.g., a -join, or 6=-join.
Reference: [19] <author> W. Yan and P.-A. Larson. </author> <title> Performing group-by before join. </title> <booktitle> In Proc. IEEE Conference on Data Engineering, </booktitle> <pages> pages 89-100, </pages> <address> Houston, TX, </address> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops [7, 16, 17]. Let us call this approach A-G-J. Lately, it was proposed to exchange grouping and aggregate operations 1 with joins <ref> [19, 18, 20, 5, 6] </ref>. This work is orthogonal to our's in that our method can be used to implement the grouping and aggregate operations used there. Consider the performance of this approach if the join is a non-equi join, e.g., a -join, or 6=-join.
Reference: [20] <author> W. Yan and P.-A. Larson. </author> <title> Interchanging the order of grouping and join. </title> <type> Technical Report CS 95-09, </type> <institution> Dept. of Computer Science, University of Waterloo, Canada, </institution> <year> 1995. </year> <month> 11 </month>
Reference-contexts: Nevertheless, the main idea | join, group, aggregate | still remains the same and is even today the only known improvement over nested loops [7, 16, 17]. Let us call this approach A-G-J. Lately, it was proposed to exchange grouping and aggregate operations 1 with joins <ref> [19, 18, 20, 5, 6] </ref>. This work is orthogonal to our's in that our method can be used to implement the grouping and aggregate operations used there. Consider the performance of this approach if the join is a non-equi join, e.g., a -join, or 6=-join.
References-found: 20

