URL: http://splish.ee.byu.edu/docs/fccm94.nano.ps.gz
Refering-URL: http://www.cs.wustl.edu/~sds/research/html/hga_conf/node18.html
Root-URL: 
Title: The Nano Processor: a Low Resource Reconfigurable Processor  
Author: Michael J. Wirthlin and Brad L. Hutchings Kent L. Gilson 
Date: April 11, 1994  
Address: Provo, UT 84602  9500 South 500 West Suite #104 Sandy, UT 84070  
Affiliation: Dept. of Electrical and Computer Eng. Brigham Young University  National Technology Inc.  
Abstract: Reconfigurable logic systems approach the performance of Application-Specific Integrated Circuits (ASICs) while retaining much of the generality of conventional computing systems through reconfiguration. Unfortunately, the development of these systems, unlike conventional software systems, is hardware intensive, requiring significant hardware development time. One way to introduce a more flexible development approach is to implement a customizable stored-program processor. For a given application, the designer can develop customized hardware to increase performance and then control the sequencing and operation of this hardware with software. Development time can be significantly reduced because conventional software development tools, e.g., assemblers and compilers, can be used to quickly develop new applications on the customized processor. This paper presents the Nano Processor (nP), a fully customizable reconfigurable processor, together with its integrated assembler, that has been successfully implemented on the Xilinx 3000 series Field Programmable Gate Array (FPGA). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Gokhale, W. Holmes, A. Kosper, D. Kunze, D. Lopresti, S. Lucas, R. Minnich, and P. Olsen. </author> <title> SPLASH: a reconfigurable linear logic array. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages I-526-I-532, </pages> <year> 1990. </year>
Reference-contexts: Therefore, reconfigurable logic systems can approach the performance of custom ASICs without the inflexibility of custom silicon. This combination of custom hardware and flexible configurability has also been shown to outperform large scale general purpose computing systems <ref> [1, 2] </ref>. Thus, reconfigurable logic systems have the potential to bring application-specific performance to general purpose computing systems. In order for reconfigurable systems to become general purpose computing systems, they must be easy to program and use.
Reference: [2] <author> P. Bertin, D. Roncin, and J. Vuillemin. </author> <title> Programmable Active Memories: a Performance Assessment. </title> <booktitle> Research on Integrated Systems: proceedings of the 1993 symposium, </booktitle> <pages> pp. 88-102, </pages> <year> 1993. </year>
Reference-contexts: Therefore, reconfigurable logic systems can approach the performance of custom ASICs without the inflexibility of custom silicon. This combination of custom hardware and flexible configurability has also been shown to outperform large scale general purpose computing systems <ref> [1, 2] </ref>. Thus, reconfigurable logic systems have the potential to bring application-specific performance to general purpose computing systems. In order for reconfigurable systems to become general purpose computing systems, they must be easy to program and use. <p> In order for reconfigurable systems to become general purpose computing systems, they must be easy to program and use. Although some early work has been done on automated software/hardware co-synthesis [3], most reconfigurable systems are programmed using conventional hardware development techniques such as schematic capture or hardware description languages <ref> [2] </ref>. As the number of FPGAs in reconfigurable systems increases, the task of developing custom circuits for each FPGA in the system becomes enormous. In addition, the knowledge and tools necessary to develop reconfigurable applications further hinders general purpose implementation.
Reference: [3] <author> P. Athanas and H. Silverman. </author> <title> Processor reconfiguration through instruction-set metamorphosis. </title> <booktitle> IEEE Computer, </booktitle> <month> March </month> <year> 1993. </year>
Reference-contexts: Thus, reconfigurable logic systems have the potential to bring application-specific performance to general purpose computing systems. In order for reconfigurable systems to become general purpose computing systems, they must be easy to program and use. Although some early work has been done on automated software/hardware co-synthesis <ref> [3] </ref>, most reconfigurable systems are programmed using conventional hardware development techniques such as schematic capture or hardware description languages [2]. As the number of FPGAs in reconfigurable systems increases, the task of developing custom circuits for each FPGA in the system becomes enormous. <p> IEEE Workshop on FPGAs for Custom Computing Machines, Napa, CA, April 10-13, 1994, pg. 23-30. 2 2.1 Background The PRISM architecture is based on a standard microprocessor closely coupled with a reconfigurable hardware platform <ref> [3, 4] </ref>. The microprocessor implements standard functions, and executes application-specific instructions on the reconfigurable platform. The advantage of PRISM is that the integrated compiler generates both the hardware image of the unique instructions and the source code for the microprocessor.
Reference: [4] <author> M. Wazlowski, L. Agarwal, T. Lee, A. Smith, E. Lam, P. Athanas, H. Silverman, and S. Ghosh. </author> <title> PRISM-II Compiler and Architecture. </title> <booktitle> Proceedings: IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <pages> pp. 9-16, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: IEEE Workshop on FPGAs for Custom Computing Machines, Napa, CA, April 10-13, 1994, pg. 23-30. 2 2.1 Background The PRISM architecture is based on a standard microprocessor closely coupled with a reconfigurable hardware platform <ref> [3, 4] </ref>. The microprocessor implements standard functions, and executes application-specific instructions on the reconfigurable platform. The advantage of PRISM is that the integrated compiler generates both the hardware image of the unique instructions and the source code for the microprocessor.
Reference: [5] <author> Iseli, C. and E. Sanchez. Spyder: </author> <title> A Reconfigurable VLIW Processor using FPGAs. </title> <booktitle> Proceedings: IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <pages> pp. 17-24, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: With little or no hardware background, users can generate a hardware configuration and software executable for the integrated system through high a level programming language. The Spyder processor uses an array of FPGAs to implement a reconfigurable VLIW processor <ref> [5] </ref>. The processor has multiple execution units, dual register banks and a host computer interface. Application specific functionality is implemented in custom execution units. The large array allows a complex multiprocessing system to be implemented. Currently, the execution units are hand made with conventional schematic entry tools.
Reference: [6] <author> J. Davidson. </author> <title> FPGA Implementation of a Reconfigurable Microprocessor. </title> <booktitle> Proceedings of the IEEE 1993 Custom Integrated Circuits Conference, pp 3.2.1 - 3.2.4, </booktitle> <year> 1993. </year>
Reference-contexts: Application specific functionality is implemented in custom execution units. The large array allows a complex multiprocessing system to be implemented. Currently, the execution units are hand made with conventional schematic entry tools. An 8-bit Reconfigurable Microprocessor (RM) has been developed that includes a complete instruction set <ref> [6] </ref>. In addition, a cross-assembler was developed to port C code to the processor. This single FPGA reconfigurable processor is intended for low-volume custom processor applications. Using a FPGA for this processor allows for easy testing and modification. <p> The nP implements application-specific functionality through the development of custom instructions. An integrated assembler generates the program data necessary to convert custom assembly instructions into executable code. Similar to the Reconfigurable Microprocessor <ref> [6] </ref>, the nP implements the processor control within a FPGA instead of using a standard microprocessor. Not only does this reduce the part count, but it allows full control over processor operation. As with PRISM, the nP offers available reconfigurable logic for implementing application-specific hardware to achieve application-specific performance.
Reference: [7] <author> XILINX: </author> <title> The Programmable Gate Array Data Book. </title> <address> San Jose, CA, </address> <year> 1992. </year>
Reference-contexts: With most of the FPGA resources dedicated to application-specific hardware, the nP can approach the performance achieved by application-specific hardware systems. The nP is currently implemented on any of the Xil-inx 3000 series parts <ref> [7] </ref> in conjunction with a variable size 8-bit static RAM (Figure 1).
References-found: 7

