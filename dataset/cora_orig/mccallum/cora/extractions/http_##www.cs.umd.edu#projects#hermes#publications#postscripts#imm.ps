URL: http://www.cs.umd.edu/projects/hermes/publications/postscripts/imm.ps
Refering-URL: http://www.cs.umd.edu/projects/hermes/publications/abstracts/imm.html
Root-URL: 
Title: Well-Founded Views in Constraint Databases: Incremental Materialization and Maintenance  
Author: James Lu Bertram Ludascher Joachim Schu V.S. Subrahmanian 
Abstract: In this paper, we study the problem of incremental maintenance of materialized views when the view definitions are allowed to contain: (a) constraints, and (b) well-founded modes of negation. A materialized view in our framework consists of a set of constrained non-ground tuples. We develop incremental algorithms to compute such non-ground materialized well-founded views, extending previous results of Gottlob et. al. and Eiter et. al. With respect to (b), previous attempts at view maintenance have been limited to the case when stratified negation is used. In contrast, in this paper, we allow arbitrary (stratified and/or unstratified) usage of negation. Recursive views are also allowed. We develop a view maintenance algorithm called WF-Red for handling updates in such cases. WF-Red takes two parameters as input a list of insertions and a list of deletions. To handle insertions, the list of deletions is kept empty and vice-versa. The algorithm correctly handles both insertions and deletions to the materialized view.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul, S. Cluet, and T. Milo. </author> <title> Querying and updating the file. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 73-84, </pages> <year> 1993. </year>
Reference: [2] <author> K. Apt and H. Blair and A. Walker. </author> <title> (1988) Towards a Theory of Declarative Knowledge, in: Foundations of Deductive Databases and Logic Programming (ed. </title> <editor> J. Minker), </editor> <address> pps 89-148, </address> <publisher> Morgan Kaufmann. </publisher> <pages> 18 </pages>
Reference-contexts: However, in contrast to [23], we study the problem of maintaining such materialized views when well-founded negation is allowed to occur, and no assumption of stratification <ref> [2] </ref> is made. As is customary, we allow the operations of insertions and deletions to modify the materialized view. The next section summarizes the basic syntax and semantics of constrained view definitions. <p> The "base" relation s is in stratum 1. Note that RSNs can be assigned to all constraint programs, including ones that are not stratified in the sense of Apt. et. al. <ref> [2] </ref>. In this paper, we will mean by the "stratum" of a predicate/rule, the stratum assigned by the above topological sorting. In particular, within a given stratum, recursion may occur through negation as is seen in the example depicted by Figure 1.
Reference: [3] <author> F. Bancilhon and N. Spyratos. </author> <title> Update semantics and relational views. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 6(4) </volume> <pages> 557-575, </pages> <year> 1981. </year>
Reference-contexts: concides with semantics of Definition 4.2. 5 Conclusions and Related Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational <ref> [3, 8, 10] </ref>, deductive [3, 26, 32, 33], and object-oriented [9, 25, 29] databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature. <p> Definition 4.2. 5 Conclusions and Related Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational [3, 8, 10], deductive <ref> [3, 26, 32, 33] </ref>, and object-oriented [9, 25, 29] databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature.
Reference: [4] <author> C. Baral and V.S. Subrahmanian. </author> <title> Stable and Extension Class Theory for Logic Programs and Default Theories, </title> <journal> Journal of Automated Reasoning, </journal> <volume> 8, </volume> <pages> pps 345-366, </pages> <year> 1992. </year>
Reference-contexts: Then as T P is monotone with respect to (see Theorem 1), it is guaranteed a least fixpoint which we denote lf p (T P ). It is well-known <ref> [4] </ref> that the well-founded semantics can be defined in terms of the operator used by Gelfond and Lifschitz [13] to define stable models. However, that transformation applies only to fully grounded views something that is impossible to do in practice. The following defines a non-ground Gelfond-Lifschitz transformation for CVD's.
Reference: [5] <author> J. Blakeley, N. Coburn, and P.-A. Larson. </author> <title> Updating derived relations: Detecting irrelevant and autonomously computable updates. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <year> 1989. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation <ref> [5, 17, 31] </ref> and deductive databases [22, 18, 15, 35, 30].
Reference: [6] <author> Stefano Ceri and Jennifer Widom. </author> <title> Deriving Production Rules for Incremental View Maintenance. </title> <booktitle> In 17th VLDB, </booktitle> <year> 1991. </year>
Reference-contexts: Hence a proper computation of overestimates at once is not feasible. The essential idea of our algorithm is to incrementally maintain k P for each k 1 by adapting the delete-rederive algorithm <ref> [6, 16] </ref> developed for safe stratified programs. Since k P is the least fixpoint of a negation-free program, the Gelfond-Lifschitz transform of P with respect to k1 P is a negation-free program that can be used to rederive relevant constrained atoms.
Reference: [7] <author> Stefano Ceri and Jennifer Widom. </author> <title> Deriving Incremental Production Rules for Deductive Data. </title> <type> IBM RJ 9071, </type> <institution> IBM Almaden, </institution> <year> 1992. </year>
Reference: [8] <author> C.C. Cosmadakis and C.H. Papadmitriou. </author> <title> Updates of relational views. </title> <journal> Journal of the ACM, </journal> <volume> 31(4) </volume> <pages> 742-760, </pages> <year> 1984. </year>
Reference-contexts: concides with semantics of Definition 4.2. 5 Conclusions and Related Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational <ref> [3, 8, 10] </ref>, deductive [3, 26, 32, 33], and object-oriented [9, 25, 29] databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature.
Reference: [9] <author> U. Dayal. </author> <title> Queries and views in a object-oriented databases. </title> <booktitle> In Int. Workshop on Database Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational [3, 8, 10], deductive [3, 26, 32, 33], and object-oriented <ref> [9, 25, 29] </ref> databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature. <p> Though the above cited references comprehensively address the view maintenance problem in the setting of relational databases and in the case of object-oriented databases <ref> [9, 21] </ref>, there has been very little work when view definitions can contain well-founded modes of negation in them in particular, such efforts have been limited to stratified negation [16]. In contrast, our approach deals with view maintenance when view definitions can include not just stratified, but also unstratified negation.
Reference: [10] <author> U. Dayal and P. Bernstein. </author> <title> On the correct translation of update operations on relational views. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7(3), </volume> <year> 1982. </year>
Reference-contexts: concides with semantics of Definition 4.2. 5 Conclusions and Related Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational <ref> [3, 8, 10] </ref>, deductive [3, 26, 32, 33], and object-oriented [9, 25, 29] databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature.
Reference: [11] <author> U. Dayal and H. Hwang. </author> <title> View definition and generalization for database integration in a multi-database system. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-10(6):628-644, </volume> <year> 1984. </year>
Reference: [12] <author> T. Eiter, G. Gottlob, J. Lu and V.S. Subrahmanian. </author> <title> (1994) A Constraint-based Representation of Stable and Well-Founded Semantics, </title> <type> Tech. Report, </type> <institution> TU-Wien. </institution>
Reference-contexts: Recent advances in constraint databases by Jaffar and Lassez [19] and Kanellakis et. al. [20] show that in such cases, it is better to admit tuples that contain variables which obey relevant constraints. Using this intuition, Gottlob et. al. [14] and Eiter et. al. <ref> [12] </ref> have defined a version of the well-founded semantics of deductive databases that accommodates constraints. We recapitulate the essential definitions below. <p> Given any constraint-program P and c-interpretation I, let P (I) = lf p (T CGL (P;I) ). The next theorem follows immediately. Theorem 1 (Eiter et. al. <ref> [12] </ref>) 1. T P is monotone, i.e. I J ) T P (I) T P (J). 2. P is anti-monotone, i.e. <p> Ground atom A is false in CW F S (P ) iff A is not true in gf p ( 2 P ). 3. Otherwise, A is undefined with respect to CW F S (P ). Theorem 2 (Eiter et. al. <ref> [12] </ref>) The above definition of CWFS coincides with the standard definition of well-founded semantics [36] when no constraints are present. 3 Incremental Materialization of CVDs In this section, we will develop a way of materializing well-founded views.
Reference: [13] <author> M. Gelfond and V. Lifschitz. </author> <title> (1988) The Stable Model Semantics for Logic Programs, </title> <booktitle> Proc. 1988 Intl. Conf. on Logic Programming (eds. </booktitle> <editor> K. Bowen and R. Kowalski), </editor> <publisher> MIT Press. </publisher>
Reference-contexts: The constraint program P defined by a constraint database is of the form fA ( ~ t j ) j A is a base relation g [ C. Definition 2.2 (Negation-Free Case) The following fixpoint operator T P over interpretation corresponds to the mapping given in <ref> [13] </ref> for propositional logic programs. Let P and I be respectively, a constraint-program and a constrained-interpretation. <p> Then as T P is monotone with respect to (see Theorem 1), it is guaranteed a least fixpoint which we denote lf p (T P ). It is well-known [4] that the well-founded semantics can be defined in terms of the operator used by Gelfond and Lifschitz <ref> [13] </ref> to define stable models. However, that transformation applies only to fully grounded views something that is impossible to do in practice. The following defines a non-ground Gelfond-Lifschitz transformation for CVD's. Definition 2.3 (Negation Case) Let P be a constraint program and J a constrained-interpretation.
Reference: [14] <author> G. Gottlob, S. Marcus, A. Nerode and V.S. Subrahmanian. </author> <title> (1994) Non-Ground Stable and Well-Founded Semantics, </title> <note> to appear in Theoretical Computer Science. </note>
Reference-contexts: Recent advances in constraint databases by Jaffar and Lassez [19] and Kanellakis et. al. [20] show that in such cases, it is better to admit tuples that contain variables which obey relevant constraints. Using this intuition, Gottlob et. al. <ref> [14] </ref> and Eiter et. al. [12] have defined a version of the well-founded semantics of deductive databases that accommodates constraints. We recapitulate the essential definitions below.
Reference: [15] <author> Ashish Gupta, Dinesh Katiyar, and Inderpal Singh Mumick. </author> <title> Counting Solutions to the View Maintenance Problem. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation [5, 17, 31] and deductive databases <ref> [22, 18, 15, 35, 30] </ref>.
Reference: [16] <author> A. Gupta, </author> <title> I.S. Mumick and V.S. Subrahmanian. Maintaining Views Incrementally, </title> <booktitle> Proc. 1993 ACM SIGMOD Conf. on Management of Data, </booktitle> <address> Washington, DC. </address>
Reference-contexts: not (C l1 ( ~ Y l1 )); ffi (C l ( ~ Y l )); The problem of incremental view maintenance in well-founded semantics based materialized views is complicated by the fact that when evaluating the ffi clauses using methods similar to the DRed algorithm of Gupta et. al. <ref> [16] </ref>, a (negated) constrained atom in the body of a clause may not have been completely evaluated at that stage. Hence a proper computation of overestimates at once is not feasible. <p> Hence a proper computation of overestimates at once is not feasible. The essential idea of our algorithm is to incrementally maintain k P for each k 1 by adapting the delete-rederive algorithm <ref> [6, 16] </ref> developed for safe stratified programs. Since k P is the least fixpoint of a negation-free program, the Gelfond-Lifschitz transform of P with respect to k1 P is a negation-free program that can be used to rederive relevant constrained atoms. <p> Furthermore, the application of other techniques for views with a finite number of derivation trees, such as counting <ref> [16] </ref>, become feasible. &gt;From an implementation point of view, the required extra bookkeeping is minimal since in addition to maintaining a set of true and unknown atoms, it is necessary only to keep a copy of 1 P and then to remember when atoms are removed from 1 P for the <p> cited references comprehensively address the view maintenance problem in the setting of relational databases and in the case of object-oriented databases [9, 21], there has been very little work when view definitions can contain well-founded modes of negation in them in particular, such efforts have been limited to stratified negation <ref> [16] </ref>. In contrast, our approach deals with view maintenance when view definitions can include not just stratified, but also unstratified negation. The examples given in this paper (program P at the beginning of Section 3 and the Win-Move example) involve non-stratified negation as well as recursive view definitions.
Reference: [17] <author> E. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 440-453, </pages> <year> 1987. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation <ref> [5, 17, 31] </ref> and deductive databases [22, 18, 15, 35, 30].
Reference: [18] <author> John V. Harrison and Suzanne Dietrich. </author> <title> Maintenance of Materialized Views in a Deductive Database: An Update Propagation Approach. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation [5, 17, 31] and deductive databases <ref> [22, 18, 15, 35, 30] </ref>.
Reference: [19] <author> J. Jaffar, J.-L. Lassez. </author> <title> Constraint Logic Programming In. </title> <booktitle> Proceedings of Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 111-119. </pages> <publisher> ACM, </publisher> <address> New York, USA, </address> <year> 1987 </year>
Reference-contexts: In contrast, when considering constraints, such grounding is not feasible. For example, an atom A (X) that is true whenever X 3 leads to infinitely many ground 3 instances which obviously cannot be stored as a flat, materialized relation. Recent advances in constraint databases by Jaffar and Lassez <ref> [19] </ref> and Kanellakis et. al. [20] show that in such cases, it is better to admit tuples that contain variables which obey relevant constraints. Using this intuition, Gottlob et. al. [14] and Eiter et. al. [12] have defined a version of the well-founded semantics of deductive databases that accommodates constraints.
Reference: [20] <author> P. Kanellakis, G. Kuper and P. Revesz. </author> <title> (1990) Constraint Query Languages, </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <address> pps 299-313. </address>
Reference-contexts: For example, an atom A (X) that is true whenever X 3 leads to infinitely many ground 3 instances which obviously cannot be stored as a flat, materialized relation. Recent advances in constraint databases by Jaffar and Lassez [19] and Kanellakis et. al. <ref> [20] </ref> show that in such cases, it is better to admit tuples that contain variables which obey relevant constraints. Using this intuition, Gottlob et. al. [14] and Eiter et. al. [12] have defined a version of the well-founded semantics of deductive databases that accommodates constraints.
Reference: [21] <author> A. Kemper, C. Kilger, G. Moerkotte. </author> <title> Function Materialization in Object Bases: Design, Realization, </title> <journal> and Evaluation IEEE Transactions on Knowledge and Data Engineering, Vol.6, </journal> <volume> No.4, </volume> <month> August </month> <year> 1994 </year>
Reference-contexts: Though the above cited references comprehensively address the view maintenance problem in the setting of relational databases and in the case of object-oriented databases <ref> [9, 21] </ref>, there has been very little work when view definitions can contain well-founded modes of negation in them in particular, such efforts have been limited to stratified negation [16]. In contrast, our approach deals with view maintenance when view definitions can include not just stratified, but also unstratified negation.
Reference: [22] <author> V. Kuchenhoff. </author> <title> On the efficient computation of the difference between consecutive database states. </title> <booktitle> In Proc. Int. Conf. on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 478-502, </pages> <year> 1991. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation [5, 17, 31] and deductive databases <ref> [22, 18, 15, 35, 30] </ref>.
Reference: [23] <author> J. Lu, G. Moerkotte, J. Schu and V.S. Subrahmanian. </author> <title> (1995) Efficient Maintenance of Materialized Mediated Views, </title> <booktitle> Proceedings of the ACM SIGMOD Annual Conference, </booktitle> <address> May 1995, San Jose, CA. </address>
Reference-contexts: In general, there are many different ways of speci fying a view. * How is the materialized view stored ? Most often, a materialized view is stored as a set of relations; however, there are differences for example, in <ref> [23] </ref> materialized views are sets of constrained tuples. * What kinds of updates are allowed? Several techniques only allow updates (insertions/deletions) to base relations. However, it is often the case that derived relations (views) are defined in terms of other derived relations. <p> Moreover, not only do we study well-founded views, we also study well-founded views when constraints are present. * In our framework, we will allow materialized views to be sets of constrained atoms. <ref> [23] </ref> was the first paper to study the case when materialized views consisted of constrained atoms. However, in contrast to [23], we study the problem of maintaining such materialized views when well-founded negation is allowed to occur, and no assumption of stratification [2] is made. <p> only do we study well-founded views, we also study well-founded views when constraints are present. * In our framework, we will allow materialized views to be sets of constrained atoms. <ref> [23] </ref> was the first paper to study the case when materialized views consisted of constrained atoms. However, in contrast to [23], we study the problem of maintaining such materialized views when well-founded negation is allowed to occur, and no assumption of stratification [2] is made. As is customary, we allow the operations of insertions and deletions to modify the materialized view. <p> One use of such constraints for view maintenance in heterogeneous mediated environments was studied in <ref> [24, 23] </ref>. This paper extends the [23] framework to apply to constrained view definitions containing well-founded negation in them. Furthermore, constraint databases have been applied to several other domains such as temporal reasoning and spatial reasoning. Our techniques are therefore applicable in principle to these paradigms as well. <p> One use of such constraints for view maintenance in heterogeneous mediated environments was studied in [24, 23]. This paper extends the <ref> [23] </ref> framework to apply to constrained view definitions containing well-founded negation in them. Furthermore, constraint databases have been applied to several other domains such as temporal reasoning and spatial reasoning. Our techniques are therefore applicable in principle to these paradigms as well.
Reference: [24] <author> J. Lu, A. Nerode and V.S. Subrahmanian. </author> <title> (1993) Hybrid Knowledge Bases, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <note> to appear. </note>
Reference-contexts: In particular, Rule 3 uses non-monotonic negation to determine those who are rich. In addition to the above example, constraint domains could access data over different data sources - <ref> [24] </ref> shows how constraint domains may be used for the purposes of implementing mediators for integrating information from heterogeneous data sources. 2.1 Well-Founded Semantics for Constraint View Definitions In this section, we briefly describe how the well-founded semantics for deductive databases proposed by Van Gelder, Ross and Schlipf [36] may be <p> One use of such constraints for view maintenance in heterogeneous mediated environments was studied in <ref> [24, 23] </ref>. This paper extends the [23] framework to apply to constrained view definitions containing well-founded negation in them. Furthermore, constraint databases have been applied to several other domains such as temporal reasoning and spatial reasoning. Our techniques are therefore applicable in principle to these paradigms as well.
Reference: [25] <author> C. Medeiros and J.-C. Mamou. </author> <title> Interactive manipulation of object-oriented views. </title> <booktitle> In Proc. IEEE Conference on Data Engineering, </booktitle> <year> 1991. </year>
Reference-contexts: Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational [3, 8, 10], deductive [3, 26, 32, 33], and object-oriented <ref> [9, 25, 29] </ref> databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature.
Reference: [26] <author> G. </author> <title> Moerkotte and P.C. Lockemann. Reactive consistency control in deductive databases. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 16(4) </volume> <pages> 670-702, </pages> <year> 1991. </year>
Reference-contexts: Definition 4.2. 5 Conclusions and Related Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational [3, 8, 10], deductive <ref> [3, 26, 32, 33] </ref>, and object-oriented [9, 25, 29] databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature.
Reference: [27] <author> A. Motro. Superviews: </author> <title> Virtual integration of multiple databases. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 13(7) </volume> <pages> 785-798, </pages> <year> 1987. </year>
Reference: [28] <author> I. S. Mumick. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> Ph.D. Thesis, </type> <institution> Stanford University, </institution> <address> CA 94305, </address> <year> 1991. </year>
Reference: [29] <author> M. Scholl, C. Laasch, and M. Tresch. </author> <title> Updatable views in object-oriented databases. </title> <booktitle> In Proc. Int. Conf. on Deductive and Object-Oriented Databases (DOOD), </booktitle> <year> 1991. </year>
Reference-contexts: Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational [3, 8, 10], deductive [3, 26, 32, 33], and object-oriented <ref> [9, 25, 29] </ref> databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature.
Reference: [30] <author> Oded Shmueli and Alon Itai. </author> <title> Maintenance of Views. </title> <booktitle> In Sigmod Record, </booktitle> <volume> 14(2) </volume> <pages> 240-255, </pages> <year> 1984. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation [5, 17, 31] and deductive databases <ref> [22, 18, 15, 35, 30] </ref>.
Reference: [31] <author> M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On rules, procedures, caching and views in data base systems. </title> <booktitle> In Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 281-290, </pages> <year> 1990. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation <ref> [5, 17, 31] </ref> and deductive databases [22, 18, 15, 35, 30].
Reference: [32] <author> E. Teniente. </author> <title> Updating knowledge bases while maintaining their consistency. </title> <journal> VLDB Journal, </journal> <note> 1994. to appear. </note>
Reference-contexts: Definition 4.2. 5 Conclusions and Related Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational [3, 8, 10], deductive <ref> [3, 26, 32, 33] </ref>, and object-oriented [9, 25, 29] databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature. <p> This kind of update affecting the view's definition is typically not treated within the view update literature. One exception are deductive databases, where the addition or deletion of rules to the definition of an intensional predicate is discussed <ref> [32] </ref>. However, they neither materialize nor preprocess the view for efficiency reasons.
Reference: [33] <author> A. Tomasic. </author> <title> View update translation via deduction and annotation. </title> <booktitle> In ICDT, </booktitle> <pages> pages 338-352, </pages> <year> 1988. </year>
Reference-contexts: Definition 4.2. 5 Conclusions and Related Work Whenever an update occurs to a view, whether materialized or not, the problem of how to reflect the update correctly by changing the base tables appropriately is called the view update problem and has been discussed extensively for relational [3, 8, 10], deductive <ref> [3, 26, 32, 33] </ref>, and object-oriented [9, 25, 29] databases. In particular, the view itself | or, to be more precise, its definition | is affected by the update. This kind of update affecting the view's definition is typically not treated within the view update literature.
Reference: [34] <author> J. D. Ullman. </author> <title> (1989) Principles of Database and Knowledge-Base Systems, Volume II, </title> <publisher> Computer Science Press, </publisher> <address> New York. </address>
Reference-contexts: The implemen tation of semi-naive evaluation based on T ffi P is straightforward and we omit its discussion 2 This is due to the fact that the sequences U k and O k are monotonically increasing and decreasing, respectively. 8 in this paper (see e.g. <ref> [34] </ref>). The essential idea is that whenever a new tuple is added from the head of a rule in an iteration, at least one literal in the body of the rule must have been newly produced from the previous iteration. <p> Hence, in the algorithms that we present next, P new will denote either the rewritten program given in Section 4.1.1, or the one given in Section 4.1.2, but not both. 4.2 View Maintenance Algorithms 4.2.1 Deletion Algorithms The following definition adapts the semi-naive computation given in <ref> [34] </ref> to perform incremental view maintenance in CVDs. When deleting a constraint atom A ( ~ X) ffi, we use ffi (A ( ~ X)) ffi to denote an overestimate of the instances of A ( ~ X) ffi that are to be deleted.
Reference: [35] <author> Toni Urpi and Antoni Olive. </author> <title> A Method for Change Computation in Deductive Databases. </title> <booktitle> In 18th VLDB, </booktitle> <pages> pages 225-237, </pages> <year> 1992. </year>
Reference-contexts: The resulting problem | preserving the consistency of the view | is called view maintenance and has been discussed for, e.g., for (extended) relation [5, 17, 31] and deductive databases <ref> [22, 18, 15, 35, 30] </ref>.
Reference: [36] <author> A. Van Gelder and K. Ross and J. Schlipf. </author> <title> The Well-Founded Semantics for General Logic Programs, </title> <journal> Journal of the ACM, </journal> <volume> 38, </volume> <pages> 3,pps 620-650. 20 </pages>
Reference-contexts: ); not (C 1 ( ~ Y 1 )); : : : ; not (C m ( ~ Y m )) Each of the A (::); B (::); and C (::)'s are atoms, ffi is a constraint a first order formula over an appropriate domain and not represents well-founded negation <ref> [36] </ref>. To our knowledge, this is the first paper in which view maintenance is studied when view definitions are allowed to contain well-founded modes of negation. <p> sources - [24] shows how constraint domains may be used for the purposes of implementing mediators for integrating information from heterogeneous data sources. 2.1 Well-Founded Semantics for Constraint View Definitions In this section, we briefly describe how the well-founded semantics for deductive databases proposed by Van Gelder, Ross and Schlipf <ref> [36] </ref> may be extended to the case of constrained databases. One of the fundamental problems with the original formulation of the well-founded semantics is that ground instances of all atoms are computed and stored as tuples in a relational DBMS. In contrast, when considering constraints, such grounding is not feasible. <p> i ^ f ~ X i = ~ X 0 i g) is solvableg 1 Without loss of generality, variables that appear in different constraint atoms of a c-interpretation is assumed to be standardized apart. 4 To provide a better understanding of the algorithms, we present the win/move program from <ref> [36] </ref> as a continuing example in this paper. <p> Otherwise, A is undefined with respect to CW F S (P ). Theorem 2 (Eiter et. al. [12]) The above definition of CWFS coincides with the standard definition of well-founded semantics <ref> [36] </ref> when no constraints are present. 3 Incremental Materialization of CVDs In this section, we will develop a way of materializing well-founded views. First, we will develop a sound and complete approach later, this approach will be refined to include incremental computation steps.
References-found: 36

