URL: http://www.csl.sri.com/reports/postscript/experiments.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Email: havelund@litp.ibp.fr  shankar@csl.sri.com  
Phone: Phone: +33 (1)44.27.40.55  Phone: +1 (415) 859-5272  
Title: Experiments in Theorem Proving and Model Checking for Protocol Verification  
Author: K. Havelund N. Shankar 
Note: 1 Supported by a European Community HCM grant, with origin institution being  2 Supported by NSF Grant CCR-930044 and by ARPA through NASA Ames Research Center under Contract NASA-NAG-2-891 (ARPA Order A721).  
Date: September 20, 1995  
Address: 4, place Jussieu 75252 Paris Cedex 05 France  Menlo Park CA 94025 USA  Denmark.  
Affiliation: LITP, Institut Blaise Pascal  Computer Science Laboratory SRI International  DIKU, Institute of Computer Science, University of Copenhagen,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. A. Bartlett, R. A. Scantlebury, and P. T. Wilkinson. </author> <title> A note on reliable full-duplex transmission over half-duplex links. </title> <journal> Communications of the ACM, 12(5):260, </journal> <volume> 261, </volume> <month> May </month> <year> 1969. </year>
Reference-contexts: The protocol is a nontrivial extension of the alternating bit protocol <ref> [1] </ref> that uses timeouts and aborts transmission following a bounded number of retransmission attempts. The environment of the protocol consists of the producer and the consumer. The black box view of the system is that it accepts requests REQ (f ) from the producer to transmit the file f . <p> Let us illustrate a few transition rules of the protocol. We focus on the sender. The following rule models how the environment "generates" a new request to the sender: 14 Ruleset d1 : Data; d2 : Data; d3 : Data Do Rule "write_req" !req_full ==&gt; req_full := true; req <ref> [1] </ref> := d1; req [3] := d3; End; The rule is "quantified" over the data of the request: any booleans may be chosen for d1, d2 and d3. The rule is called write req. <p> initiates the induction, discharges the base case, eliminates universal quantification (by introducing the Skolem constants st1!1 and st2!1), expands out the transition, and then case-splits according to the program actions, we get 17 sequents, one of which is: f-1g st2!1 = Rule_read_req (st1!1) [-2] Delta (st1!1) [-3] safe (st1!1) |------- <ref> [1] </ref> safe (st2!1) At this point a pre-defined tactic is applied, which tries to prove the sequent automatically. Our experience is that all such sequents that are provable by syntactic deduction are proved by this tactic. <p> One of these sequents is the one we saw earlier (see page 32), and which is repeated here: f-1g st2!1 = Rule_read_req (st1!1) [-2] Delta (st1!1) [-3] safe (st1!1) |------- <ref> [1] </ref> safe (st2!1) In fact, we would like PVS to try out itself to prove each such sequent before "giving up" and apply for human interaction for some extra invariant to be discovered. <p> WITH [stimer1_enabled := FALSE] IN st ELSE st ENDIF 38 In proving the invariant p ref abusy from above (page 33), the following sequent is generated (amongst 17) after splitting the transition relation: p_ref_abusy.2.11 : f-1g st2!1 = Rule_stimer1 (st1!1) [-2] Delta (st1!1) [-3] safe (st1!1) [-4] ref_abusy (st1!1) |------- <ref> [1] </ref> ref_abusy (st2!1) Let us first apply the technique we have used before. <p> So we return to the sequent: p_ref_abusy.2.11 : f-1g st2!1 = Rule_stimer1 (st1!1) [-2] Delta (st1!1) [-3] safe (st1!1) [-4] ref_abusy (st1!1) |------- <ref> [1] </ref> ref_abusy (st2!1) The Rule stimer1 rule can be regarded as a command, and the formula ref abusy (st2!1) below the line can be regarded as the post-condition. The information needed to prove this sequent is the weakest pre-condition of these two. <p> := false; abusy := false; For i := 1 To last Do afile [i] := false End; ahead := nil; afirst := true; aerror := false; End; -- Environment Actions -- Ruleset d1 : Data; d2 : Data; d3 : Data Do Rule "write_req" !req_full ==&gt; req_full := true; req <ref> [1] </ref> := d1; req [3] := d3; End; Rule "read_conf" conf_full ==&gt; conf_full := false; End; Rule "read_ind" 74 ind_full ==&gt; ind_full := false; End; Rule "read_ind_error" ind_error ==&gt; ind_error := false; End; Rule "lose_msg" K_full ==&gt; K_full := false; stimer1_enabled := true; End; Rule "lose_ack" L L := false; stimer1_enabled
Reference: [2] <author> Rachel Mary Cardell-Oliver. </author> <title> The formal verification of hard real-time systems. </title> <type> Technical Report 255, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1992. </year>
Reference-contexts: Most finite-state model checking tools, however, cannot cope with potentially infinite but reachably finite state spaces and therefore cannot exploit such an abstraction. Cardell-Oliver <ref> [2] </ref> has used the HOL proof checking system [10] to verify the sliding window protocol. It would 3 be an interesting challenge to obtain a finite-state abstraction of the sliding window protocol.
Reference: [3] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The bulk of their verification is in proving various invariance properties but their main result is a refinement argument showing that one I/O automaton specification implements another more abstract one. We have employed a formalization that is closer to the state-transition model of Unity <ref> [3] </ref> and TLA [16]. By superposing the abstract and concrete state machines, we reduce the refinement demonstration to that of invariance. <p> First we give a short introduction to Mur, then we present the protocol and the correctness criteria. The full formal Mur program is contained in appendix A. 3.1 Short Introduction to Mur Mur uses a program model that is similar to Unity <ref> [3] </ref>. A Mur program has three components: a declaration of the global variables, a description of the initial state, and a collection of transition rules. <p> We focus on the sender. The following rule models how the environment "generates" a new request to the sender: 14 Ruleset d1 : Data; d2 : Data; d3 : Data Do Rule "write_req" !req_full ==&gt; req_full := true; req [1] := d1; req <ref> [3] </ref> := d3; End; The rule is "quantified" over the data of the request: any booleans may be chosen for d1, d2 and d3. The rule is called write req. It's pre-condition is that the req variable is "empty" (req full is false - `!' means negation). <p> Non-determinism is only allowed at the outermost level where, in each execution step, any rule with a true pre condition may be selected for execution. This decision to model rules as functions is in accordance with the semantics of UNITY <ref> [3] </ref>. Another choice would be to define rules as relations of type [[state,state] -&gt; bool], as is the case in TLA [16]. This techniques has in fact earlier been ap plied in PVS [25]. <p> false; For i := 1 To last Do afile [i] := false End; ahead := nil; afirst := true; aerror := false; End; -- Environment Actions -- Ruleset d1 : Data; d2 : Data; d3 : Data Do Rule "write_req" !req_full ==&gt; req_full := true; req [1] := d1; req <ref> [3] </ref> := d3; End; Rule "read_conf" conf_full ==&gt; conf_full := false; End; Rule "read_ind" 74 ind_full ==&gt; ind_full := false; End; Rule "read_ind_error" ind_error ==&gt; ind_error := false; End; Rule "lose_msg" K_full ==&gt; K_full := false; stimer1_enabled := true; End; Rule "lose_ack" L L := false; stimer1_enabled := true; End; --
Reference: [4] <author> E.M. Clark, O. Grumberg, and D.E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: We do not provide a systematic method for obtaining abstractions; this is a topic for future research. The theoretical ideas underlying our use of abstraction have been studied and developed by Clarke, Grumberg, and Long <ref> [4] </ref>, by Dams, Grumberg, and Gerth [7], and by Loiseaux, Graf, Sifakis, Bouajjani, and Bensalem [17]. 4 5 Chapter 2 The Bounded Retransmission Protocol The bounded retransmission protocol developed at Philips Research Laboratory communicates messages from a producer to a consumer over an unreliable physical medium that can lose messages. <p> The resulting model checker by itself has few advantages over a conventional model checker. The main advantage is when it is combined with theorem proving to exploit the use of abstraction to reduce unbounded state spaces to finite ones. Abstraction is well-studied in the literature <ref> [4, 7, 17] </ref>, but the reasoning is usually carried out informally because the model checkers were not hitherto integrated with theorem provers. 44 5.2 Abstraction Proofs, the General Case In order to prove an AG property, there is a simple way to define an abstraction, as shown in [4] and recalled <p> the literature [4, 7, 17], but the reasoning is usually carried out informally because the model checkers were not hitherto integrated with theorem provers. 44 5.2 Abstraction Proofs, the General Case In order to prove an AG property, there is a simple way to define an abstraction, as shown in <ref> [4] </ref> and recalled in [24]. Suppose we are given a concrete, possibly infinite-state, system S c (like our protocol) defined by a state type, an initialization predicate and a next-state transition relation over the state.
Reference: [5] <author> C. Cornes, J. Courant, J.C. Filliatre, G. Huet, P. Manoury, C Paulin-Mohring, C. Munoz, C. Murthy, C. Parent, A. Saibi, and B. Werner. </author> <title> The Coq proof assistant reference manual, version 5.10. </title> <type> Technical report, </type> <institution> INRIA, Rocquencourt, France, </institution> <month> February </month> <year> 1995. </year> <note> This version is newer than the version used to verify the BRP-protocol in [11]. </note>
Reference-contexts: File transmission is aborted if any message in the file remains unacknowledged after a fixed number of retransmissions. This protocol has already been verified by researchers at Philips and CWI using the Coq proof checker <ref> [5] </ref> using the framework of Lynch and Tuttle's I/O automata [18]. Their hand proof effort occupied two man-months, and it took them three man-months to mechanize this proof using Coq.
Reference: [6] <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <editor> In Ramayya Kumar and Thomas Kropf, editors, </editor> <booktitle> Theorem Provers in Circuit Design (TPCD '94), volume 910 of Lecture Notes in Computer Science, </booktitle> <pages> pages 203-222, </pages> <address> Bad Herrenalb, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: While the manual effort required by both their proof and by our initial proof attempt with BRP-PVS is comparable, PVS seems to provide greater and more efficient automation in the verification process particularly through the use of highly optimized rewriting and BDDs <ref> [6] </ref>. Our use of the abstracted protocol BRP-mu yields a considerable simplification in the proof and a valuable technique for other protocol correctness proofs. Muller and Nipkow [22] use a clever abstraction for reducing the alternating bit protocol to an infinite-state system with only a finite number of reachable states.
Reference: [7] <author> Dennis Dams, Orna Grumberg, and Rob Gerth. </author> <title> Abstract interpretation of reactive systems: Abstractions preserving 8CTL*, </title> <editor> 9CTL* and CTL*. In Ernst-Rudiger Olderog, editor, </editor> <booktitle> Programming Concepts, Methods and Calculi (PROCOMET '94), </booktitle> <pages> pages 561-581, </pages> <year> 1994. </year> <month> 242 </month>
Reference-contexts: We do not provide a systematic method for obtaining abstractions; this is a topic for future research. The theoretical ideas underlying our use of abstraction have been studied and developed by Clarke, Grumberg, and Long [4], by Dams, Grumberg, and Gerth <ref> [7] </ref>, and by Loiseaux, Graf, Sifakis, Bouajjani, and Bensalem [17]. 4 5 Chapter 2 The Bounded Retransmission Protocol The bounded retransmission protocol developed at Philips Research Laboratory communicates messages from a producer to a consumer over an unreliable physical medium that can lose messages. <p> The resulting model checker by itself has few advantages over a conventional model checker. The main advantage is when it is combined with theorem proving to exploit the use of abstraction to reduce unbounded state spaces to finite ones. Abstraction is well-studied in the literature <ref> [4, 7, 17] </ref>, but the reasoning is usually carried out informally because the model checkers were not hitherto integrated with theorem provers. 44 5.2 Abstraction Proofs, the General Case In order to prove an AG property, there is a simple way to define an abstraction, as shown in [4] and recalled
Reference: [8] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: In general, however, several (from 1 to 10) such sequents were returned, and all would be examined to produce a guess for a missing invariant, making the guessing less obvious. This lead to the idea to generate the weakest pre-condition <ref> [8] </ref> of the relevant transition rule with respect to the invariant to be proven. In fact, in some cases this was done by hand on a piece of paper when inspiration was missing. To ease that process, we experimented with tactics that could automatically generate these weakest pre-conditions. <p> Let us first shortly recall the theory of weakest pre-conditions, and then put it into the context of our transition system. Weakest pre-conditions were introduced to give semantics to programming languages <ref> [8] </ref>. The mechanism was that of predicate transformers producing a weakest pre-condition from a pair consisting of a command and a post-condition.
Reference: [9] <author> E. A. Emerson. </author> <title> Handbook of Theoretical Computer Science: Temporal and Modal Logic, </title> <booktitle> chapter 16, </booktitle> <pages> pages 996-1072. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: To say whether this is the case still requires some experiments. In any case, our encoding may be seen as being a special instance of the more general notion of temporal logic <ref> [9] </ref>.
Reference: [10] <author> M. J. C. Gordon. </author> <title> HOL: A proof generating system for higher-order logic. </title> <editor> In G. Birtwistle and P. A. Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 73-128. </pages> <publisher> Kluwer, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1988. </year>
Reference-contexts: Most finite-state model checking tools, however, cannot cope with potentially infinite but reachably finite state spaces and therefore cannot exploit such an abstraction. Cardell-Oliver [2] has used the HOL proof checking system <ref> [10] </ref> to verify the sliding window protocol. It would 3 be an interesting challenge to obtain a finite-state abstraction of the sliding window protocol.
Reference: [11] <author> L. Helmink, M.P.A. Sellink, and F.W. Vaandrager. </author> <title> Proof-checking a data link protocol. </title> <type> Technical Report CS-R9420, </type> <institution> Centrum voor Wiskunde en Informatica (CWI), Computer Science/Department of Software Technology, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: We show how it is possible to combine the two techniques to create an effective and general methodology for protocol verification. The specific protocol we examine is the bounded retransmission protocol (BRP) from Philips <ref> [11] </ref>. This variant of the alternating bit protocol transmits files, each consisting of a sequence of individual messages. File transmission is aborted if any message in the file remains unacknowledged after a fixed number of retransmissions. <p> The closest related work is obviously the earlier, original verification of Helmink, Sellink, and Vandraager <ref> [11] </ref>. The bulk of their verification is in proving various invariance properties but their main result is a refinement argument showing that one I/O automaton specification implements another more abstract one. We have employed a formalization that is closer to the state-transition model of Unity [3] and TLA [16]. <p> Communication is asynchronous: K and L are actually unbounded buffers but since there is at most one message active in a channel at any point in time, these are modeled here for simplicity as one-place buffers. This simplification is also present in the work of Helmink, et al <ref> [11] </ref>. The protocol uses three timers to deal with loss of messages and acknowledgments. A timer has a fixed period T of time associated. When it is set, a timeout occurs T time units or more later. <p> We do not model the real-time aspects of the protocol but instead represent the timers by timer events. For example, the timeout event which is supposed to detect message loss is instead defined to occur when a message is lost. This simplification is also present in Helmink, et al <ref> [11] </ref>. The receiver may also retransmit acknowledgments. This happens when the receiver gets a message that it has already received once. The receiver 7 distinguishes between an old message and a new message via the alternating bit (the toggle) which is part of the message. <p> It is, however, difficult to come up with a predicate P that gives a good intuitive feeling of correctness. The solution we shall choose mimics the correctness criteria defined in <ref> [11] </ref>, where the protocol is proved to be a refinement of a more abstract protocol. We shall not prove a refinement, but we shall formulate the correctness criteria in terms of a more abstract protocol, the same as in [11] basically. <p> The solution we shall choose mimics the correctness criteria defined in <ref> [11] </ref>, where the protocol is proved to be a refinement of a more abstract protocol. We shall not prove a refinement, but we shall formulate the correctness criteria in terms of a more abstract protocol, the same as in [11] basically. <p> Mur is not able to deal with timers explicitly, so they have to be modeled using the existing technology of transition rules and global variables. Also in <ref> [11] </ref> timers have been modeled, however, we use a different and in our opinion more clear modeling. For each timer, there are two variables. For example for timer 1 (of the sender) we have: Var stimer1_on : boolean; stimer1_enabled : boolean; To begin with, these timer variables are false. <p> The technique allows mutually recursive proofs. It turns out that some invariants are logical consequences of others, and that for these we can avoid reasoning about the transition relation and just prove the implication. As a matter of fact, our invariant safe 1 is such a consequence: following <ref> [11] </ref>, we namely define an invariant that describes a relation between the variables of the abstract automaton and the variables in the protocol, and safe 1 is a consequence of this invariant. <p> We have found it useful and productive to employ a state exploration tool such as Mur as a prelude to full theorem proving. Mur was also useful for checking putative invariants. In <ref> [11] </ref> a refinement between the protocol and an abstract protocol was defined and verified. Our contribution has been to reformulate refinement as a safety property by superposing the implementation and specification of the protocol. This technique seems simple and yet useful. <p> Our contribution has been to reformulate refinement as a safety property by superposing the implementation and specification of the protocol. This technique seems simple and yet useful. The infinite-state PVS specification initially took three man-months to verify. This is comparable to the work in Coq <ref> [11] </ref> where they were starting from a hand-written proof.
Reference: [12] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: Of course one can define special programming language syntax even within PVS (as PVS functions), but we have felt no need at 67 all to do this. Also, an alternative to the shared variable paradigm is the message passing paradigm found in CCS [21], CSP <ref> [12] </ref> or IO-automata [18]. We have felt no loss in generality working with shared variables. On the contrary, it feels straight forward. Our use of abstraction yields a better understanding of the protocol since it extracts out the relevant control skeleton. A deeper study will reveal systematic abstraction techniques. Acknowledgments.
Reference: [13] <author> G. J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Introduction Communication protocols are an important class of concurrent algorithms that pose a difficult challenge for existing verification technologies <ref> [13] </ref>. Tools based on model checking and state exploration are effective and widely used for protocol verification, but many real-life protocols are not finite-state and cannot be fully analyzed by these methods.
Reference: [14] <author> G. </author> <type> Janssen. </type> <institution> ROBDD software. Department of Electrical Engineering, Eindhoven University of Technology, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: The correspondence between BRP-PVS and BRP-mu is verified using PVS. The resulting finite-state protocol BRP-mu can be verified using a model checking or state exploration tool. We have successfully applied and can compare the PVS model checker <ref> [14] </ref>, Mur [20], and SMV [19] on this example. The PVS proof of the abstraction mapping took two man-weeks. The model checking part is automatic, but our initial attempts with the PVS model checker were unsuccessful until the mu-calculus definition of invariance was revised to compute fixpoints differently. <p> (st1!1)) f-4g (stimer1_enabled (st1!1)) |------- f1g abusy (st1!1) f2g spc (st1!1) = SF f4g spc (st1!1) = SC Now we can more conveniently make our guess about the missing invari ant. 42 Chapter 5 Abstraction and Model Checking in the -calculus In recent work [24] a propositional mu-calculus model checker <ref> [14] </ref> has been integrated into PVS as a decision procedure. This integration uses a relational mu-calculus (quantified Boolean formulas with least and greatest fixpoints of monotone Boolean predicate transformers) as a medium for communicating between PVS and the model checker for the propositional mu-calculus. <p> Our initial definition of the AG operator was such that it explored all those states that could potentially lead to a state violating the invariant in order to check if these states included the start state. Obviously, many more states were explored in this manner. The mu-calculus <ref> [14] </ref> has recently been extended with a reachability option (like option `-f' in SMV), which is expected to be incorporated into PVS.
Reference: [15] <author> Simon S. Lam and A. Udaya Shankar. </author> <title> Protocol verification via projections. </title> <journal> IEEE Trans. on S.W. Engg, </journal> <volume> SE-10(4):325-342, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Cardell-Oliver [2] has used the HOL proof checking system [10] to verify the sliding window protocol. It would 3 be an interesting challenge to obtain a finite-state abstraction of the sliding window protocol. Lam and Udaya Shankar <ref> [15] </ref> present a systematic method of projecting images of protocols by applying stepwise refinement to the protocol with respect to the property being verified. Their abstractions preserve the property so that protocol M has property P if and only if the abstract protocol M 0 has the property P .
Reference: [16] <author> L. Lamport. </author> <title> The Temporal Logic of Actions. </title> <type> Technical report, </type> <institution> Digital Equipment Corporation (DEC) Systems Research Center, Palo Alto, California, USA, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: The bulk of their verification is in proving various invariance properties but their main result is a refinement argument showing that one I/O automaton specification implements another more abstract one. We have employed a formalization that is closer to the state-transition model of Unity [3] and TLA <ref> [16] </ref>. By superposing the abstract and concrete state machines, we reduce the refinement demonstration to that of invariance. <p> This decision to model rules as functions is in accordance with the semantics of UNITY [3]. Another choice would be to define rules as relations of type [[state,state] -&gt; bool], as is the case in TLA <ref> [16] </ref>. This techniques has in fact earlier been ap plied in PVS [25].
Reference: [17] <author> C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, and S. Bensalem. </author> <title> Property preserving abstractions for the verification of concurrent systems. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 6 </volume> <pages> 11-44, </pages> <year> 1995. </year>
Reference-contexts: The theoretical ideas underlying our use of abstraction have been studied and developed by Clarke, Grumberg, and Long [4], by Dams, Grumberg, and Gerth [7], and by Loiseaux, Graf, Sifakis, Bouajjani, and Bensalem <ref> [17] </ref>. 4 5 Chapter 2 The Bounded Retransmission Protocol The bounded retransmission protocol developed at Philips Research Laboratory communicates messages from a producer to a consumer over an unreliable physical medium that can lose messages. <p> The resulting model checker by itself has few advantages over a conventional model checker. The main advantage is when it is combined with theorem proving to exploit the use of abstraction to reduce unbounded state spaces to finite ones. Abstraction is well-studied in the literature <ref> [4, 7, 17] </ref>, but the reasoning is usually carried out informally because the model checkers were not hitherto integrated with theorem provers. 44 5.2 Abstraction Proofs, the General Case In order to prove an AG property, there is a simple way to define an abstraction, as shown in [4] and recalled
Reference: [18] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <address> New York, </address> <pages> pages 137-151. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: File transmission is aborted if any message in the file remains unacknowledged after a fixed number of retransmissions. This protocol has already been verified by researchers at Philips and CWI using the Coq proof checker [5] using the framework of Lynch and Tuttle's I/O automata <ref> [18] </ref>. Their hand proof effort occupied two man-months, and it took them three man-months to mechanize this proof using Coq. The interesting question therefore is whether this verification effort can be dramatically reduced, perhaps by using a combination of finite-state and theorem proving techniques. <p> Of course one can define special programming language syntax even within PVS (as PVS functions), but we have felt no need at 67 all to do this. Also, an alternative to the shared variable paradigm is the message passing paradigm found in CCS [21], CSP [12] or IO-automata <ref> [18] </ref>. We have felt no loss in generality working with shared variables. On the contrary, it feels straight forward. Our use of abstraction yields a better understanding of the protocol since it extracts out the relevant control skeleton. A deeper study will reveal systematic abstraction techniques. Acknowledgments.
Reference: [19] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1993. </year> <month> 243 </month>
Reference-contexts: The correspondence between BRP-PVS and BRP-mu is verified using PVS. The resulting finite-state protocol BRP-mu can be verified using a model checking or state exploration tool. We have successfully applied and can compare the PVS model checker [14], Mur [20], and SMV <ref> [19] </ref> on this example. The PVS proof of the abstraction mapping took two man-weeks. The model checking part is automatic, but our initial attempts with the PVS model checker were unsuccessful until the mu-calculus definition of invariance was revised to compute fixpoints differently. <p> Mur has the characteristics that it uses an explicit (not symbolic) representation of the state space and only explores the reachable states, while the mu-calculus checker explores all states, if not guided in a way that we later discovered. 6.2 SMV The SMV system <ref> [19] </ref> is a tool for checking finite-state systems against specifications in the temporal logic CTL. It is based on (O)BDD's.
Reference: [20] <author> R. Melton, D.L. Dill, and C. Norris Ip. </author> <title> Murphi annotated reference manual, version 2.6. </title> <type> Technical report, </type> <institution> Stanford University, Palo Alto, California, USA, </institution> <month> November </month> <year> 1993. </year> <title> Written by C. Norris Ip. </title>
Reference-contexts: The correspondence between BRP-PVS and BRP-mu is verified using PVS. The resulting finite-state protocol BRP-mu can be verified using a model checking or state exploration tool. We have successfully applied and can compare the PVS model checker [14], Mur <ref> [20] </ref>, and SMV [19] on this example. The PVS proof of the abstraction mapping took two man-weeks. The model checking part is automatic, but our initial attempts with the PVS model checker were unsuccessful until the mu-calculus definition of invariance was revised to compute fixpoints differently. <p> The parallel composition of the concrete and the abstract protocols has the big advantage that it can be model checked in the finite-state case. 9 10 Chapter 3 State Exploration in Mur In this section we present the formulation of the protocol and its correctness criteria in Mur <ref> [20] </ref>, a state exploration tool for finite-state transition systems. First we give a short introduction to Mur, then we present the protocol and the correctness criteria.
Reference: [21] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Of course one can define special programming language syntax even within PVS (as PVS functions), but we have felt no need at 67 all to do this. Also, an alternative to the shared variable paradigm is the message passing paradigm found in CCS <ref> [21] </ref>, CSP [12] or IO-automata [18]. We have felt no loss in generality working with shared variables. On the contrary, it feels straight forward. Our use of abstraction yields a better understanding of the protocol since it extracts out the relevant control skeleton.
Reference: [22] <author> Olaf Muller and Tobias Nipkow. </author> <title> Combining model checking and deduction for I/O automata. </title> <type> Draft manuscript, </type> <year> 1995. </year>
Reference-contexts: Our use of the abstracted protocol BRP-mu yields a considerable simplification in the proof and a valuable technique for other protocol correctness proofs. Muller and Nipkow <ref> [22] </ref> use a clever abstraction for reducing the alternating bit protocol to an infinite-state system with only a finite number of reachable states. Most finite-state model checking tools, however, cannot cope with potentially infinite but reachably finite state spaces and therefore cannot exploit such an abstraction.
Reference: [23] <author> S. Owre, J.M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), Saratoga - NY, Lecture Notes in Artificial Intelligence, </booktitle> <volume> Volume 607, </volume> <pages> pages 748-752. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: To answer this question, we first consider a scaled-down version of the protocol BRP-M and show that it can be quickly analyzed and debugged using the Mur state 1 exploration tool from Stanford University. This Mur specification can be converted into PVS <ref> [23] </ref> using a mechanical translator. The PVS description of the protocol is then generalized to the full protocol BRP-PVS, and the main safety property of the protocol is proved in a conventional manner as an invariant. <p> Then, we describe the PVS-specification obtained by the translation. Finally, we describe the correctness proof. The full formal texts associated with this chapter are contained in appendix B. 21 4.1 Short Introduction to PVS PVS (Prototype Verification System) is an environment for writing specifications and developing proofs <ref> [23] </ref>. It serves as a prototype for exploring new approaches to mechanized formal methods.
Reference: [24] <author> S. Rajan, N. Shankar, </author> <title> and M.K. Srivas. An integration of model-checking with automated proof checking. </title> <booktitle> In Computer-Aided Verification (CAV) 1995, Liege, Belgium, Lecture Notes in Computer Science, </booktitle> <volume> Volume 939, </volume> <pages> pages 84-97. </pages> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1995. </year> <note> Long version of this paper is available. </note>
Reference-contexts: Since this level of effort is still very large, we investigate techniques for reducing the verification effort without compromising the generality of the protocol. The PVS theorem prover has recently been extended with mu-calculus based model checking <ref> [24] </ref> so it is natural to ask whether model checking can somehow be applied to BRP-PVS. We answer this question in the affirmative by using theorem proving to construct a property-preserving finite-state abstraction BRP-mu that can be verified using model checking. <p> It also illustrates the value of tightly integrating theorem proving and model checking as has recently been achieved in PVS <ref> [24] </ref>. The main difference between our work and previous work is that we develop a mechanized verification methodology for communication protocols where theorem proving is used to compute finite abstractions that can be verified by model checking. <p> (st1!1) [-2] SAFE (st1!1) f-3g (stimer1_on (st1!1)) f-4g (stimer1_enabled (st1!1)) |------- f1g abusy (st1!1) f2g spc (st1!1) = SF f4g spc (st1!1) = SC Now we can more conveniently make our guess about the missing invari ant. 42 Chapter 5 Abstraction and Model Checking in the -calculus In recent work <ref> [24] </ref> a propositional mu-calculus model checker [14] has been integrated into PVS as a decision procedure. This integration uses a relational mu-calculus (quantified Boolean formulas with least and greatest fixpoints of monotone Boolean predicate transformers) as a medium for communicating between PVS and the model checker for the propositional mu-calculus. <p> 17], but the reasoning is usually carried out informally because the model checkers were not hitherto integrated with theorem provers. 44 5.2 Abstraction Proofs, the General Case In order to prove an AG property, there is a simple way to define an abstraction, as shown in [4] and recalled in <ref> [24] </ref>. Suppose we are given a concrete, possibly infinite-state, system S c (like our protocol) defined by a state type, an initialization predicate and a next-state transition relation over the state.
Reference: [25] <author> N. Shankar. </author> <title> Mechanized verification of real-time systems using PVS. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, California, USA, </address> <month> March </month> <year> 1993. </year> <month> 244 </month>
Reference-contexts: This decision to model rules as functions is in accordance with the semantics of UNITY [3]. Another choice would be to define rules as relations of type [[state,state] -&gt; bool], as is the case in TLA [16]. This techniques has in fact earlier been ap plied in PVS <ref> [25] </ref>. We chose however the functional style since we be lieved that the theorem prover would deal more efficiently with equalities of the form new state = Rule (old state) than with general predicates like Rule (old state,new state). To say whether this is the case still requires some experiments.
References-found: 25

