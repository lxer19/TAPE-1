URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/96-008.ps.Z
Refering-URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/FILE.html
Root-URL: http://www.cs.unc.edu
Title: Probabilistic Reliable Message Transmission  
Author: Subodh Kumar 
Date: January 17, 1996  
Abstract: Most communication systems require reliable transmission of a sequence of messages over a physical network which can potentially lose and reorder packets sent over it. For this purpose, typically, headers are associated with messages by the sender and they are acknowledged by the receiver. It is known that protocols that use a fixed set of headers to solve reliable message transmission problem between two asynchronous processors are inherently inefficient. This paper investigates the efficiency of such protocols if the probabilistic behavior of the network delay is known. It is shown that even if we are willing to accept a finite probability of error in the transmission, any protocol using a fixed number of headers remains inefficient. But for synchronous and semi-synchronous processors, we can bound the probability of error with more efficiency. 
Abstract-found: 1
Intro-found: 1
Reference: [AAF + ] <author> Y Afek, H Attiya, A Fekete, M Fischer, N Lynch, Y Monsour, D Wang, and L Zuck. </author> <title> Reliable communication over unreliable channel. </title> <journal> JACM, </journal> <pages> pages 0-0. </pages>
Reference-contexts: These headers can grow arbitrarily large. In this paper we refer to the data link layer messages as high level or RL-messages and the underlying physical layer messages as low level or UL- messages. [LMF88] and <ref> [AAF + ] </ref> prove that its not efficient to bound the size of headers. Specifically, protocols that are able to transmit every high level message using only a constant number or O (1) of low level messages once the network starts behaving ideally, must use unbounded headers. <p> Such protocols are called O (1) bounded protocols. A formal definition follows later. O (n)-bounded protocols that use bounded headers have been shown to exist by <ref> [AAF + ] </ref> and [TL90]. [MS89] shows the necessity of an unbounded receive buffer to transmit n high level messages with less than n headers. <p> In our model, we assign a probability density function, pdf , to the delay in the network. We assume that the delay of each message (only low level messages are sent on the link) is probabilistically independent of other messages. Mostly the model and terminology of <ref> [AAF + ] </ref> is followed. The new results include the formalization of a probabilistic version of the reliable message transmission problem (RMTP), in which correct transmission is required only with some (high) probability. The probability is taken over executions. <p> The probability is taken over executions. We prove that any O (1) or constant bounded algorithm, even for this weaker correctness condition, requires an unbounded number of headers, as in the deter 1 ministic case. The proof is just an extension of the one by <ref> [AAF + ] </ref> and shows that for any value of correctness probability greater than zero, any constant bounded algorithm must have an infinite number of headers. <p> We are interested in implementing a reliable layer on top of an unreliable layer. This can be done as demonstrated in <ref> [AAF + ] </ref>. An I/O automaton A that solves RMTP is said to implement the reliable layer on an unreliable layer iff every fair execution of A that is UL-consistent is also RL-consistent. <p> However, any such implementation must be inefficient, in terms of the complexity measure presented in the next subsection, as proved by <ref> [AAF + ] </ref>. 2.4 Boundedness Suppose that A t and A r implement layer RL on layer UL. Let A be the composition of A t and A r . <p> We require that a good fi exist, so that the execution fffi is correct, for every possible sequence, , of inputs to A or send RL events. The paper <ref> [AAF + ] </ref> showed that no deterministic implementation of a reliable layer on top of an unreliable layer can be constant bounded. Suppose we relaxed the problem and were ready to accept automata which allowed executions violating some of the properties 1-6, once in a while, say with probability p. <p> But it was necessary in the proof to know something stronger, namely that the good executions are somehow "evenly distributed", or at least that they are evenly distributed over the extensions that satisfy the k-bounded property. 3 The Impossibility Proof The proof by <ref> [AAF + ] </ref> that shows the impossibility of bounded alphabet (read bounded headers) for constant bounded protocols works for the probabilistic case with only a slight change. The idea remains the same that the accumulation of undesirable network packets can become unbounded in the network. <p> This is the result that we'll use to show a contradiction, if constant bounded protocols could implement PRMTP using fixed UL-message set. The general structure of the proof follows that in <ref> [AAF + ] </ref>. Lemma 3.2 ([AAF + ]) Let ff be a finite execution of a RMTP solution A, that is both RL- and UL-consistent. Consider a finite UL-consistent extension fffi of A such that fi contains a recv RL event. <p> Consider a finite UL-consistent extension fffi of A such that fi contains a recv RL event. If we remove all actions of the transmitter component of A from fi to get fffl, it is still a finite UL-consistent execution of A. 8 See <ref> [AAF + ] </ref> for proof. This holds for all PRMTP solutions also, since the proof doesn't use anything about the time of actions. We use this fact to show the following lemma, that shows us that a PRMTP must not decide to recv RL too soon.
Reference: [Bla91] <author> Uyless Black. </author> <title> OSI: A model for Computer Communications standards. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction We consider the problem of reliable message transmission in computer communication networks. This is the problem of implementing a reliable order-preserving communication layer between two processes that works on top of an unreliable communication layer which can lose and reorder messages. Borrowing terminology from the OSI network model <ref> [Zim80, Bla91] </ref>, this reliable layer (RL) is called the data link layer and the unreliable layer (UL) is called the physical layer.
Reference: [BS88] <author> A Baratz and Segal. </author> <title> Reliable link initialization procedures. </title> <journal> IEEE ToC, </journal> <month> Feb </month> <year> 1988. </year>
Reference-contexts: link don't have independent delays and links can behave in a faulty and byzantine manner and the processor can also crash. [LMF88] shows that no constant bounded Data Link protocol can work in the presence of processor crashes. [GHM89] shows an O (n)-bounded algorithm that has a small probabilistic error. <ref> [BS88] </ref> gives an algorithm that is resilient to processor crashes if a single bit of non-volatile memory is made available to it. 18
Reference: [Cyp80] <author> R J Cyper. </author> <title> Communication Architecture for Distributed Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1980. </year>
Reference-contexts: Though these terms are taken from the OSI model, these two layers are essentially found in most of the common network models like ARPANET [MW77], SNA and DECNET <ref> [Wec80, Cyp80] </ref>. This also holds for higher levels of such layered models, e.g. the transport layer built on the top of the data link layer. All these protocols rely on correctly being able to transmit a sequence of messages from one point to another.
Reference: [GHM89] <author> Oded Goldreich, Amir Herzberg, and Yishay Mansour. </author> <title> Source to destination communication in presence of faults. </title> <booktitle> In PODC, </booktitle> <pages> pages 85-101, </pages> <year> 1989. </year>
Reference-contexts: It also shows that if packets are lost on the link with some probability q, then, with a high probability, there exists an exponential lower bound on the number of low level messages needed to be sent by any protocol that uses a fixed number of headers. <ref> [GHM89] </ref> gives a protocol that ensures that the transmission of messages are reliable with a high probability. Their protocol is not O (1)-bounded. In our model, we assign a probability density function, pdf , to the delay in the network. <p> that need to be studied are when the different UL-message on the link don't have independent delays and links can behave in a faulty and byzantine manner and the processor can also crash. [LMF88] shows that no constant bounded Data Link protocol can work in the presence of processor crashes. <ref> [GHM89] </ref> shows an O (n)-bounded algorithm that has a small probabilistic error. [BS88] gives an algorithm that is resilient to processor crashes if a single bit of non-volatile memory is made available to it. 18
Reference: [LMF88] <author> Nancy Lynch, Yishay Monsour, and Alan Fekete. </author> <title> Data link layer: Two impossibility results. </title> <booktitle> In PODC, </booktitle> <pages> pages 149-170, </pages> <year> 1988. </year>
Reference-contexts: These headers can grow arbitrarily large. In this paper we refer to the data link layer messages as high level or RL-messages and the underlying physical layer messages as low level or UL- messages. <ref> [LMF88] </ref> and [AAF + ] prove that its not efficient to bound the size of headers. Specifically, protocols that are able to transmit every high level message using only a constant number or O (1) of low level messages once the network starts behaving ideally, must use unbounded headers. <p> Other cases that need to be studied are when the different UL-message on the link don't have independent delays and links can behave in a faulty and byzantine manner and the processor can also crash. <ref> [LMF88] </ref> shows that no constant bounded Data Link protocol can work in the presence of processor crashes. [GHM89] shows an O (n)-bounded algorithm that has a small probabilistic error. [BS88] gives an algorithm that is resilient to processor crashes if a single bit of non-volatile memory is made available to it.
Reference: [LS89] <author> N Lynch and E Stark. </author> <title> A proof of the kahn principle for input/output automata. </title> <journal> Information and Computation, </journal> <volume> 82(1) </volume> <pages> 81-92, </pages> <month> Jul </month> <year> 1989. </year>
Reference-contexts: Hence we we need to be able to construct fair executions. Lemma 3.1 Pr (ffifi is a fair execution of A such that fi is UL-consistent and contains no send RL events j ffi is a finite UL-consistent execution of A) &gt; 0. Proof <ref> [LS89] </ref> shows how to construct a fi so that ffifi is fair. It is essentially done by dovetailing actions from different fairness class. <p> We can let an imminent recv UL event occur at any time in that construction and build the rest of sequence around these recv UL 's. What this means is that, we construct a fi as shown in <ref> [LS89] </ref> and then any valid assignnment of times for the events is permissible.
Reference: [LT87] <author> N Lynch and M R Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In PODC, </booktitle> <pages> pages 137-151, </pages> <year> 1987. </year>
Reference-contexts: This delay is characterized by a probability density function, pdf . The delays of different packets have the same density function and they are independent of each other. This is what the physical layer consists of. 2.1 I/O Automata We use the I/O automata formalism <ref> [LT87, LT89] </ref>, summarized in this subsection, for our problem statement. Each system component is modeled with an automaton. The automaton is a state machine whose state transitions are labeled with actions.
Reference: [LT89] <author> N Lynch and M R Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> In CWI Quarterly, </journal> <volume> volume 2(3), </volume> <pages> pages 219-246, </pages> <month> Sept </month> <year> 1989. </year>
Reference-contexts: This delay is characterized by a probability density function, pdf . The delays of different packets have the same density function and they are independent of each other. This is what the physical layer consists of. 2.1 I/O Automata We use the I/O automata formalism <ref> [LT87, LT89] </ref>, summarized in this subsection, for our problem statement. Each system component is modeled with an automaton. The automaton is a state machine whose state transitions are labeled with actions.
Reference: [MS89] <author> Yishay Mansour and Baruch Schiebar. </author> <title> The intractability of bounded protocols for non-fifo channels. </title> <booktitle> In PODC, </booktitle> <pages> pages 59-72, </pages> <year> 1989. </year>
Reference-contexts: Such protocols are called O (1) bounded protocols. A formal definition follows later. O (n)-bounded protocols that use bounded headers have been shown to exist by [AAF + ] and [TL90]. <ref> [MS89] </ref> shows the necessity of an unbounded receive buffer to transmit n high level messages with less than n headers.
Reference: [MW77] <author> J M McQuillan and D C Walden. </author> <title> The arpa network design decisions. </title> <journal> Computer Networks, </journal> <volume> 1 </volume> <pages> 243-289, </pages> <month> Aug </month> <year> 1977. </year>
Reference-contexts: Though these terms are taken from the OSI model, these two layers are essentially found in most of the common network models like ARPANET <ref> [MW77] </ref>, SNA and DECNET [Wec80, Cyp80]. This also holds for higher levels of such layered models, e.g. the transport layer built on the top of the data link layer. All these protocols rely on correctly being able to transmit a sequence of messages from one point to another.
Reference: [Ste76] <author> M V Stenning. </author> <title> A data transfer protocol. </title> <journal> Computer Networks, </journal> <volume> 1 </volume> <pages> 99-110, </pages> <year> 1976. </year>
Reference-contexts: All these protocols rely on correctly being able to transmit a sequence of messages from one point to another. Most of these reliable message transmission protocols use some variant of Stenning's algorithm <ref> [Ste76] </ref> that uses headers to identify messages and acknowledgements. These headers can grow arbitrarily large.
Reference: [TL90] <author> Ewan Tempero and Richard Ladner. </author> <title> Tight bounds for weakly bounded protocols. </title> <booktitle> In PODC, </booktitle> <pages> pages 205-218, </pages> <year> 1990. </year>
Reference-contexts: Such protocols are called O (1) bounded protocols. A formal definition follows later. O (n)-bounded protocols that use bounded headers have been shown to exist by [AAF + ] and <ref> [TL90] </ref>. [MS89] shows the necessity of an unbounded receive buffer to transmit n high level messages with less than n headers.
Reference: [Wec80] <author> S Wecker. </author> <title> Dna: the digital network architecture. </title> <journal> IEEE ToC, </journal> <volume> com28:510-526, </volume> <month> April </month> <year> 1980. </year>
Reference-contexts: Though these terms are taken from the OSI model, these two layers are essentially found in most of the common network models like ARPANET [MW77], SNA and DECNET <ref> [Wec80, Cyp80] </ref>. This also holds for higher levels of such layered models, e.g. the transport layer built on the top of the data link layer. All these protocols rely on correctly being able to transmit a sequence of messages from one point to another.
Reference: [Zim80] <author> H Zimmermann. </author> <title> Osi reference model the iso model of architecture for open system interconnection. </title> <journal> IEEE ToC, </journal> <volume> com28:425-432, </volume> <month> April </month> <year> 1980. </year> <month> 19 </month>
Reference-contexts: 1 Introduction We consider the problem of reliable message transmission in computer communication networks. This is the problem of implementing a reliable order-preserving communication layer between two processes that works on top of an unreliable communication layer which can lose and reorder messages. Borrowing terminology from the OSI network model <ref> [Zim80, Bla91] </ref>, this reliable layer (RL) is called the data link layer and the unreliable layer (UL) is called the physical layer.
References-found: 15

