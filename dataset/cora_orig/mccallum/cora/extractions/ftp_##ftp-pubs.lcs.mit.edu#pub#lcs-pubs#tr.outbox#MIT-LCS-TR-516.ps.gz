URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-516.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr500.html
Root-URL: 
Title: PROTEUS: A High-Performance Parallel-Architecture Simulator  
Author: by Eric A. Brewer Chrysanthos N. Dellarocas Adrian Colbrook William E. Weihl 
Keyword: Execution-driven simulation, parallel algorithm design and evaluation, parallel architecture, parallel debugging  
Address: Cambridge, Massachusetts 02139  
Affiliation: of  Massachusetts Institute of Technology Laboratory for Computer Science  
Note: c Massachusetts Institute of Technology 1991 This is an electronically reproduced version  
Date: September 1991  
Pubnum: Technical Report MIT/LCS/TR-516.  
Abstract: Proteus is a high-performance simulator for MIMD multiprocessors. It is fast, accurate, and flexible: it is one to two orders of magnitude faster than comparable simulators, it can reproduce results from real multiprocessors, and it is easily configured to simulate a wide range of architectures. Proteus provides a modular structure that simplifies customization and independent replacement of parts of architecture. There are typically multiple implementations of each module that provide different combinations of accuracy and performance; users pay for accuracy only when and where they need it. Finally, Proteus provides repeatability, nonintrusive monitoring and debugging, and integrated graphical output, which result in a development environment superior to those available on real multiprocessors. This work was supported in part by the National Science Foundation under grant CCR-8716884, by the Defense Advanced Research Projects Agency (DARPA) under Contract N00014-89-J-1988, and by an equipment grant from Digital Equipment Corporation. Eric A. Brewer was supported by an Office of Naval Research Fellowship, Chrysanthos N. Dellarocas by a Starr Foundation Fellowship, and Adrian Colbrook by a Science and Engineering Research Council Postdoctoral Fellowship. 
Abstract-found: 1
Intro-found: 1
Reference: [A + 91] <author> A. Agarwal et al. </author> <title> The MIT Alewife machine: A large-scale distributed-memory multiprocessor. In Scalable Shared-Memory Multiprocessors. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: In summary, the modular structure of Proteus allows easy replacement and customization of individual parts of the simulator. This allows users to tailor Proteus to a particular architecture. We have exploited this ability to reproduce both the nCUBE [FJL + 88], a message-passing multiprocessor, and Alewife <ref> [A + 91] </ref>, a shared-memory multiprocessor. (Section 7 describes the correspondence between the nCUBE version of Proteus and the real nCUBE.) The modular structure also allows selection of modules based on required accuracy, which allows users to maximize performance for a particular simulation by trading unneeded accuracy for increased performance. <p> The overhead factor is the ratio of the pixie cycle count for the augmented version over that of the normal version. The overhead is consistently a small factor. ASIM is a multiprocessor simulator developed for the Alewife project at MIT <ref> [A + 91, CLN90] </ref>; it is representative of instruction-interpreting simulators. infinite loops. The simulation overhead incurred by code augmentation is much lower than that incurred by instruction interpretation, which is used in most processor simulators. Table 3 shows the overhead due to augmentation for three sequential programs.
Reference: [Aga91] <author> A. Agarwal. </author> <title> Limits on interconnection network performance. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 2(4), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: This allows complete simulation of network contention, including hot spots. It correctly simulates uni- and bidirectional edges, end-around connections, internal switch delays, and virtual channels [DS87]. The high-performance version uses an analytical model developed by Agarwal <ref> [Aga91] </ref>. Instead of simulating each hop, it computes the arrival time at the target using a formula presented in the paper and a contention factor based on a sliding-window view of recent network traffic. This version is acceptable when the traffic is mild.
Reference: [Bre91] <author> E. A. Brewer. </author> <title> Aspects of a high-performance parallel-architecture simulator. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> December </month> <year> 1991. </year>
Reference: [CBDW91] <author> A. Colbrook, E. A. Brewer, C. N. Dellarocas, and W. E. Weihl. </author> <title> An algorithm for concurrent search trees. </title> <booktitle> In Proceedings of the 1991 International Conference on Parallel Processing (ICPP '91), </booktitle> <pages> pages III138-III141, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Proteus was originally designed for evaluating language, compiler, and runtime system mechanisms to support portability; thus, flexibility, accuracy, and performance are all important. We have also used it for algorithmic and architectural studies, including concurrent search trees and network and cache research <ref> [CBDW91] </ref>. In general, Proteus is an excellent development platform for parallel software: it supports testing and debugging, performance evaluation and tuning, and graphical output. Section 2 provides an overview of the simulator, Section 3 discusses Proteus' modular structure, and Section 4 describes the use of direct execution and augmentation. <p> Further refinements would improve the accuracy of the nCUBE version, but the first order modifications were sufficient to obtain results consistently within four percent. Evidence for the accuracy of Proteus comes from other sources as well. In our research on concurrent search trees <ref> [CBDW91] </ref>, we found that Proteus was able to reproduce published search tree 19 the error in the Proteus results. 20 8 RELATED WORK results [CS90] that were measured on a Supernode multiprocessor [Nic88]. Proteus also reproduced the results published in "Synchronization without Contention" by Mellor-Crummey and Scott [MCS91].
Reference: [Cha90] <author> D. Chaiken. </author> <title> Cache coherence protocols for large-scale multiprocessors. </title> <type> Technical Report MIT/LCS/TR-489, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: The high traffic leads to a high contention factor, even though none of the packets contend for an edge. Thus the model-based version artificially inflates network delays when there is no contention. 4 The accurate cache module simulates Chaiken's cache-coherence protocol for direct networks <ref> [Cha90] </ref>. It simulates all of the cache states and protocol packets. <p> In general, any effect that we expected to see has actually appeared. More importantly, all unexpected results have (so far) proven to be real effects rather than inaccuracies introduced by Proteus. For example, we noticed excessive communication problems in David Chaiken's cache-coherence protocol that severely hindered performance <ref> [Cha90] </ref>. In his thesis, Chaiken predicted the possibility of cache thrashing, but he did not know if it would be a problem in practice. The solutions he suggested resolved our problem, confirming that the excessive communication was due to thrashing in the cache.
Reference: [Che89] <author> D.-K. Chen. </author> <title> MaxPar: An execution-driven simulator for studying parallel systems. </title> <type> Technical Report CSRD 917 and UILU-ENG-89-8013, </type> <institution> University of Illinois, </institution> <month> October </month> <year> 1989. </year> <note> 24 REFERENCES </note>
Reference-contexts: The use of direct execution with augmentation was used first by Mathieson and Francis [MF88] and by Covington et al. [CMM + 88]. The technique has been used in several other simulators <ref> [DGH91, Che89, SF89] </ref>. We extend the work in this area in three ways. First, Proteus provides support for nonintrusive monitoring, which is discussed in Section 5.1. <p> Work Augmentation was first used to profile sequential programs by Weinberger [Wei84]; direct execution with augmentation for multiprocessor simulation was developed by Mathieson and Francis for their Threads simulator, and by Covington et al. for the Rice Parallel Processing Testbed (RPPT) [CMM + 88], and is used in several simulators <ref> [DGH91, Che89, SF89] </ref>. Section 4 discusses our extensions to this work. Among these simulators, only the RPPT provides substantial support for debugging. It provides some form of "parallel debugger/tracer" that interprets and controls the simulation.
Reference: [CLN90] <author> D. Chaiken, B.-H. Lim, and D. Nussbaum. </author> <note> ASIM Users Manual. ALEWIFE SYSTEMS MEMO #13, </note> <month> August </month> <year> 1990. </year>
Reference-contexts: The overhead factor is the ratio of the pixie cycle count for the augmented version over that of the normal version. The overhead is consistently a small factor. ASIM is a multiprocessor simulator developed for the Alewife project at MIT <ref> [A + 91, CLN90] </ref>; it is representative of instruction-interpreting simulators. infinite loops. The simulation overhead incurred by code augmentation is much lower than that incurred by instruction interpretation, which is used in most processor simulators. Table 3 shows the overhead due to augmentation for three sequential programs. <p> Table 4 summarizes the performance of three multiprocessor simulators. 16 6 PERFORMANCE Program Slowdown Per Processor Simulator Best Typical Proteus 2 35-100 ASIM 200 1,000-5,000 Tango 2 500-2,000 Table 4: Overall system performance for several multiprocessor simulators. The ASIM simulator <ref> [CLN90] </ref>, which was developed for the Alewife project at MIT, is a fairly representative instruction-interpreting simulator. The overhead of instruction interpretation is reflected in the "Best" column of Table 4, and limits the typical performance substantially. <p> The solutions he suggested resolved our problem, confirming that the excessive communication was due to thrashing in the cache. The thrashing problems and solutions were confirmed by Chaiken's own simulations using ASIM <ref> [CLN90] </ref>. 8 Related Work Augmentation was first used to profile sequential programs by Weinberger [Wei84]; direct execution with augmentation for multiprocessor simulation was developed by Mathieson and Francis for their Threads simulator, and by Covington et al. for the Rice Parallel Processing Testbed (RPPT) [CMM + 88], and is used in
Reference: [CMM + 88] <author> R. G. Covington, S. Madala, V. Mehta, J. R. Jump, and J. B. Sinclair. </author> <title> The Rice parallel processing testbed. </title> <booktitle> In Proceedings of the 1988 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: 1 Introduction This paper presents the design of Proteus, a simulator for MIMD multiprocessors. Proteus is an execution-driven simulator <ref> [CMM + 88] </ref>; it multiplexes a single processor among the various activities in a simulated parallel machine to provide accurate information about the timing and behavior of an application and the underlying simulated architecture. <p> Because the counter is incremented every time a block executes, the counter correctly tracks the required cycles for any path through the control-flow graph. The use of direct execution with augmentation was used first by Mathieson and Francis [MF88] and by Covington et al. <ref> [CMM + 88] </ref>. The technique has been used in several other simulators [DGH91, Che89, SF89]. We extend the work in this area in three ways. First, Proteus provides support for nonintrusive monitoring, which is discussed in Section 5.1. <p> by Chaiken's own simulations using ASIM [CLN90]. 8 Related Work Augmentation was first used to profile sequential programs by Weinberger [Wei84]; direct execution with augmentation for multiprocessor simulation was developed by Mathieson and Francis for their Threads simulator, and by Covington et al. for the Rice Parallel Processing Testbed (RPPT) <ref> [CMM + 88] </ref>, and is used in several simulators [DGH91, Che89, SF89]. Section 4 discusses our extensions to this work. Among these simulators, only the RPPT provides substantial support for debugging. It provides some form of "parallel debugger/tracer" that interprets and controls the simulation.
Reference: [CS90] <author> A. Colbrook and C. Smythe. </author> <title> Efficient implementation of search trees on parallel distributed-memory architectures. </title> <booktitle> In IEE Proceedings Part E, </booktitle> <volume> volume 137, </volume> <pages> pages 394-400, </pages> <year> 1990. </year>
Reference-contexts: Evidence for the accuracy of Proteus comes from other sources as well. In our research on concurrent search trees [CBDW91], we found that Proteus was able to reproduce published search tree 19 the error in the Proteus results. 20 8 RELATED WORK results <ref> [CS90] </ref> that were measured on a Supernode multiprocessor [Nic88]. Proteus also reproduced the results published in "Synchronization without Contention" by Mellor-Crummey and Scott [MCS91]. This paper compared locking algorithms on both a Sequent Symmetry and a BBN Butterfly. In general, any effect that we expected to see has actually appeared.
Reference: [D + 89] <author> W. J. Dally et al. </author> <title> The J-machine: A fine-grain concurrent computer. </title> <editor> In G.X. Ritter, editor, </editor> <booktitle> Proceedings of the IFIP Congress, </booktitle> <pages> pages 1147-1153. </pages> <publisher> North-Holland, </publisher> <month> August </month> <year> 1989. </year>
Reference-contexts: If the network chip uses DMA to get the packet, then the processor is resumed fairly quickly. Other architectures, such as the J-machine <ref> [D + 89] </ref>, require that the processor feed the packet to the network chip word by word. In this case, the delay depends on the length of the packet. The mode argument is used to pass flags to the module.
Reference: [DECa] <institution> Digital Equipment Corporation. pixie(1). Ultrix 4.0 General Information, </institution> <note> Vol. 3B (Commands(1): M-Z). </note>
Reference-contexts: This table compares several sequential programs with and without augmentation. The cycles were determined by pixie <ref> [DECa] </ref>, a profiling tool available on MIPS-based workstations. The overhead factor is the ratio of the pixie cycle count for the augmented version over that of the normal version. The overhead is consistently a small factor.
Reference: [DECb] <institution> Digital Equipment Corporation. prof(1). Ultrix 4.0 General Information, </institution> <note> Vol. 3B (Commands(1): M-Z). </note>
Reference-contexts: The technique has been used in several other simulators [DGH91, Che89, SF89]. We extend the work in this area in three ways. First, Proteus provides support for nonintrusive monitoring, which is discussed in Section 5.1. Second, profiling information, similar to the Unix tool prof <ref> [DECb] </ref>, can be generated by using a procedure-specific cycle counter in addition to the global cycle counter. This produces very accurate counts of the simulated cycles spent in each procedure. As with prof, the profiling information guides tuning and aids debugging.
Reference: [Del91] <author> C. N. Dellarocas. </author> <title> A high-performance retargetable simulator for parallel architectures. </title> <type> Technical Report MIT/LCS/TR-505 (Master's Thesis), </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1991. </year>
Reference: [DGH91] <author> H. Davis, S. R. Goldschmidt, and J. Hennessy. </author> <title> Multiprocessor simulation and tracing using Tango. </title> <booktitle> In Proceedings of the 1991 International Conference on Parallel Processing (ICPP '91), </booktitle> <pages> pages II99-II107, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: These and other factors discussed in Section 6 result in a performance improvement of one to two orders of magnitude when compared to other simulators with comparable flexibility such as Tango <ref> [DGH91] </ref>. Another important feature of Proteus is the ability it provides the user to control the level of accuracy of the simulation. In general, there is a tradeoff between accuracy and performance: a more accurate simulation requires more time. <p> The use of direct execution with augmentation was used first by Mathieson and Francis [MF88] and by Covington et al. [CMM + 88]. The technique has been used in several other simulators <ref> [DGH91, Che89, SF89] </ref>. We extend the work in this area in three ways. First, Proteus provides support for nonintrusive monitoring, which is discussed in Section 5.1. <p> The simulation overhead incurred by code augmentation is much lower than that incurred by instruction interpretation, which is used in most processor simulators. Table 3 shows the overhead due to augmentation for three sequential programs. As discussed by Davis et al. <ref> [DGH91] </ref>, the overhead for augmentation is about a factor of two, which is about one hundred times lower than the overhead for instruction interpretation. Unfortunately, these numbers only apply for local instructions; non-local instructions must still be interpreted. <p> The ASIM simulator [CLN90], which was developed for the Alewife project at MIT, is a fairly representative instruction-interpreting simulator. The overhead of instruction interpretation is reflected in the "Best" column of Table 4, and limits the typical performance substantially. Tango <ref> [DGH91] </ref> is very similar to Proteus in its use of direct execution with augmentation. Thus, its peak performance has an overhead factor of about two. The typical performance, however, is far worse than that of Proteus. This seems surprising, since Tango has similar overhead for augmentation. <p> Work Augmentation was first used to profile sequential programs by Weinberger [Wei84]; direct execution with augmentation for multiprocessor simulation was developed by Mathieson and Francis for their Threads simulator, and by Covington et al. for the Rice Parallel Processing Testbed (RPPT) [CMM + 88], and is used in several simulators <ref> [DGH91, Che89, SF89] </ref>. Section 4 discusses our extensions to this work. Among these simulators, only the RPPT provides substantial support for debugging. It provides some form of "parallel debugger/tracer" that interprets and controls the simulation.
Reference: [DS87] <author> W. J. Dally and C. L. Seitz. </author> <title> Deadlock free message routing in multiprocessor interconnection networks. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(5):547-553, </volume> <month> May </month> <year> 1987. </year>
Reference-contexts: The accurate version of the k-ary n-cube network module simulates the progress of each packet hop by hop. This allows complete simulation of network contention, including hot spots. It correctly simulates uni- and bidirectional edges, end-around connections, internal switch delays, and virtual channels <ref> [DS87] </ref>. The high-performance version uses an analytical model developed by Agarwal [Aga91]. Instead of simulating each hop, it computes the arrival time at the target using a formula presented in the paper and a contention factor based on a sliding-window view of recent network traffic.
Reference: [DSNB87] <author> B. A. Delagi, N. Saraiya, S. Nishimura, and G. Byrd. </author> <title> An instrumented architectural simulation system. </title> <type> Technical Report KSL 86-36, </type> <institution> Knowledge Systems Laboratory, Stanford University, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: Debugging in Proteus is simple and straightforward, primarily because we support sequential debugging techniques. The support for integrated data collection and display is unique to Proteus among execution-driven simulators, although Tango provides some form of general monitoring. The CARE simulator <ref> [DSNB87] </ref>, which simulates LISP code using direct execution and a hardware timer, provides integrated monitoring and graphics. The TESS simulator [Sta85], a commercial discrete-event simulation system, provides very general data collection and display abilities, but is not very useful for multiprocessor simulation.
Reference: [FJL + 88] <author> G. C. Fox, M. A. Johnson, G. A. Lyzenga, S. W. Otto, J. K. Salmon, and D. W. Walker. </author> <title> Solving Problems on Concurrent Processors, Volume 1: General Techniques and Regular Problems. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: In summary, the modular structure of Proteus allows easy replacement and customization of individual parts of the simulator. This allows users to tailor Proteus to a particular architecture. We have exploited this ability to reproduce both the nCUBE <ref> [FJL + 88] </ref>, a message-passing multiprocessor, and Alewife [A + 91], a shared-memory multiprocessor. (Section 7 describes the correspondence between the nCUBE version of Proteus and the real nCUBE.) The modular structure also allows selection of modules based on required accuracy, which allows users to maximize performance for a particular simulation
Reference: [Gai86] <author> Jason Gait. </author> <title> A probe effect in concurrent programs. </title> <journal> Software Practice and Experience, </journal> <volume> 16(3) </volume> <pages> 225-233, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: In addition, Proteus avoids interpreting user application code whenever 1 Some parallel debuggers support repeatability|e.g., Instant Replay [LM86]|but at the cost of maintaining huge trace files and of introducing a significant probe effect <ref> [Gai86] </ref>. 3 possible, thus removing the overhead of interpretation for most instructions. Proteus is also designed so that the entire simulation system, including the application program and the network and memory simulators, runs in a single address space. <p> Real multiprocessor systems suffer from the probe effect: the addition of monitoring code may cause the monitored effect to disappear <ref> [Gai86] </ref>. This prevents programmers from collecting additional data for debugging. Proteus allows users to add arbitrary monitoring or debugging code without changing the behavior of the simulation. For non-cycle-counted code, the addition is trivial.
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: The nCUBE is a message-passing multiprocessor with a hypercube topology; that is, there are 2 n processors with each processor connected to n other processors. Communication is in the style of CSP <ref> [Hoa85] </ref>: every send must have a matching receive. The primitives transfer data blocks via DMA over the network to the target processor. There is no cache coherence. The algorithm comparison comes from Quinn's paper "Analysis and Benchmarking of Two Parallel Sorting Algorithms: Hyperquicksort and Quickmerge" [Qui89].
Reference: [Lin90] <author> M. A. Linton. </author> <title> The evolution of dbx. </title> <booktitle> In Proceedings of the 1990 USENIX Summer Conference, </booktitle> <pages> pages 211-220, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Proteus also provides repeatability: users can rerun simulations to pinpoint bugs. Real multiprocessors generally provide neither of these abilities. Because Proteus runs as a single process, it works well with sequential debuggers such as dbx <ref> [Lin90] </ref>. This extends the power of advanced sequential debuggers to the parallel development arena. Furthermore, Proteus provides an internal debugging mode that allows users to examine the states of threads, processors, locks, and memory.
Reference: [LM86] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging parallel programs with Instant Replay. </title> <type> Technical Report TR194, </type> <institution> University of Rochester, Computer Science Department, </institution> <month> September </month> <year> 1986. </year>
Reference: [MCS91] <author> J. M. Mellor-Crummey and M. L. Scott. </author> <title> Synchronization without contention. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 269-278, </pages> <month> April </month> <year> 1991. </year> <note> REFERENCES 25 </note>
Reference-contexts: Proteus also reproduced the results published in "Synchronization without Contention" by Mellor-Crummey and Scott <ref> [MCS91] </ref>. This paper compared locking algorithms on both a Sequent Symmetry and a BBN Butterfly. In general, any effect that we expected to see has actually appeared. More importantly, all unexpected results have (so far) proven to be real effects rather than inaccuracies introduced by Proteus.
Reference: [MF88] <author> I. Mathieson and R. Francis. </author> <title> A dynamic-trace-driven simulator for evaluating parallelism. </title> <booktitle> In Proceedings of 21st Hawaii International Conference on System Sciences, </booktitle> <volume> volume 1 (Architecture), </volume> <pages> pages 158-166, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Because the counter is incremented every time a block executes, the counter correctly tracks the required cycles for any path through the control-flow graph. The use of direct execution with augmentation was used first by Mathieson and Francis <ref> [MF88] </ref> and by Covington et al. [CMM + 88]. The technique has been used in several other simulators [DGH91, Che89, SF89]. We extend the work in this area in three ways. First, Proteus provides support for nonintrusive monitoring, which is discussed in Section 5.1.
Reference: [Nic88] <author> D. A. Nicole. </author> <title> Esprit Project 1085: Reconfigurable transputer processor architecture. </title> <booktitle> In Proceedings of CONPAR '88, </booktitle> <pages> pages 81-89, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: In our research on concurrent search trees [CBDW91], we found that Proteus was able to reproduce published search tree 19 the error in the Proteus results. 20 8 RELATED WORK results [CS90] that were measured on a Supernode multiprocessor <ref> [Nic88] </ref>. Proteus also reproduced the results published in "Synchronization without Contention" by Mellor-Crummey and Scott [MCS91]. This paper compared locking algorithms on both a Sequent Symmetry and a BBN Butterfly. In general, any effect that we expected to see has actually appeared.
Reference: [Qui89] <author> M. J. Quinn. </author> <title> Analysis and benchmarking of two parallel sorting algorithms: </title> <journal> Hyperquicksort and quickmerge. BIT, </journal> <volume> 29(2) </volume> <pages> 239-250, </pages> <year> 1989. </year>
Reference-contexts: The primitives transfer data blocks via DMA over the network to the target processor. There is no cache coherence. The algorithm comparison comes from Quinn's paper "Analysis and Benchmarking of Two Parallel Sorting Algorithms: Hyperquicksort and Quickmerge" <ref> [Qui89] </ref>. Quinn compares two sorting algorithms on a 64-processor nCUBE/7. Both algorithms mix local sorting with communication; they differ in their strategies for dividing the values among the processors. In general, quickmerge requires fewer but larger messages than hyperquicksort. and a version with a generic network module.
Reference: [SF89] <author> C. B. Stunkel and W. K. Fuchs. TRAPEDS: </author> <title> Producing traces for multicomputers via execution driven simulation. </title> <booktitle> In Proceedings of ACM Sigmetrics 1989, </booktitle> <pages> pages 70-78, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: The use of direct execution with augmentation was used first by Mathieson and Francis [MF88] and by Covington et al. [CMM + 88]. The technique has been used in several other simulators <ref> [DGH91, Che89, SF89] </ref>. We extend the work in this area in three ways. First, Proteus provides support for nonintrusive monitoring, which is discussed in Section 5.1. <p> Work Augmentation was first used to profile sequential programs by Weinberger [Wei84]; direct execution with augmentation for multiprocessor simulation was developed by Mathieson and Francis for their Threads simulator, and by Covington et al. for the Rice Parallel Processing Testbed (RPPT) [CMM + 88], and is used in several simulators <ref> [DGH91, Che89, SF89] </ref>. Section 4 discusses our extensions to this work. Among these simulators, only the RPPT provides substantial support for debugging. It provides some form of "parallel debugger/tracer" that interprets and controls the simulation.
Reference: [Smi81] <author> B. J. Smith. </author> <title> Architecture and applications of the HEP multiprocessor computer system. </title> <booktitle> SPIE, </booktitle> <volume> 298 </volume> <pages> 241-248, </pages> <year> 1981. </year>
Reference-contexts: In addition to the kernel interrupt handlers, users may define their own interprocessor interrupts (IPIs) and handlers; for example, user-defined IPIs are used to build dispatch routines for message-passing architectures. The shared-memory module provides access to local shared memory, handles full-empty bits <ref> [Smi81] </ref>, and provides atomic operations such as test-and-set and compare-and-swap. The shared memory of a remote processor is not accessed directly via the shared-memory module; instead, a network request is generated (usually by the cache module) that invokes the shared-memory module when it arrives at the remote node.
Reference: [SS87] <author> Dennis Shasha and Marc Snir. </author> <title> Efficient and correct execution of parallel programs that share memory. </title> <type> Technical Report 58037, </type> <institution> Courant Institute, </institution> <month> July </month> <year> 1987. </year>
Reference-contexts: It generates calls to both the shared-memory module (for local accesses) and the network module (for remote accesses). The primary operations provided by the cache module are read, write, and flush. In addition, the module defines operations for software coherence: soft read and write, and fence <ref> [SS87] </ref>. The intent of the soft operations is to access the currently cached, possibly stale, data. The fence operation blocks until all pending protocol transactions for the given cache line have completed and is used to ensure coherence for that cache line.
Reference: [Sta85] <author> Charles R. Standridge. </author> <title> Performing simulation projects with The Extended Simulation System (TESS). </title> <journal> SIMULATION, </journal> <volume> 45(6) </volume> <pages> 283-291, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: The support for integrated data collection and display is unique to Proteus among execution-driven simulators, although Tango provides some form of general monitoring. The CARE simulator [DSNB87], which simulates LISP code using direct execution and a hardware timer, provides integrated monitoring and graphics. The TESS simulator <ref> [Sta85] </ref>, a commercial discrete-event simulation system, provides very general data collection and display abilities, but is not very useful for multiprocessor simulation. The modular structure of Proteus extends the separation of functionality introduced by Tango.
Reference: [Wei84] <author> P. J. Weinberger. </author> <title> Cheap dynamic instruction counting. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1815-1826, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: The solutions he suggested resolved our problem, confirming that the excessive communication was due to thrashing in the cache. The thrashing problems and solutions were confirmed by Chaiken's own simulations using ASIM [CLN90]. 8 Related Work Augmentation was first used to profile sequential programs by Weinberger <ref> [Wei84] </ref>; direct execution with augmentation for multiprocessor simulation was developed by Mathieson and Francis for their Threads simulator, and by Covington et al. for the Rice Parallel Processing Testbed (RPPT) [CMM + 88], and is used in several simulators [DGH91, Che89, SF89]. Section 4 discusses our extensions to this work.
References-found: 30

