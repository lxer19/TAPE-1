URL: http://www.csc.ncsu.edu/faculty/riely/papers/98popl.ps.gz
Refering-URL: http://www.csc.ncsu.edu/faculty/riely/papers.html
Root-URL: http://www.csc.ncsu.edu
Title: A Typed Language for Distributed Mobile Processes (Extended abstract)  
Author: James Riely and Matthew Hennessy 
Abstract: We describe a foundational language for specifying dynamically evolving networks of distributed processes, Dp. The language is a distributed extension of the p-calculus which incorporates the notions of remote execution, migration, and site failure. Novel features of Dp include 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and A. D. Gordon. </author> <title> A calculus for cryptographic protocols: The spi calculus. </title> <type> Technical Report 414, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Barbed equivalence provides a primitive proof technique for reasoning about processes. Indeed, substantial theorems can be established this way <ref> [16, 1] </ref>. Proofs using the definition of barbed congruence directly, however, are hard work due to the quantification over all possible observers. It is useful, therefore, to find alternative characterizations of the equivalence which do not involve universal quantification over observers. <p> Dp arose from an attempt to understand the use of permissions in distributed systems and in this sense, it is related to work on the spi-calculus <ref> [1] </ref> of Abadi and Gordon. There, however, the permissions are used to control the ability to interpret data that has been received. The type system most closely related to ours is that of Pierce and Sangiorgi [16].
Reference: [2] <author> R. Amadio and S. Prasad. </author> <title> Localities and failures. </title> <booktitle> In Proc. 14th Foundations of Software Technology and Theoretical Computer Science, volume 880 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: These features make locations more visible in Dp than they are in DJoin. The goto operation is based on the spawn operation found in Facile [13] and related calculi <ref> [2, 3] </ref>; this operator is objective [8] and operates only on inactive code, making it very inexpensive to implement. By contrast, the subjective migration operator of DJoin operates on running code, making it more flexible and costlier to implement.
Reference: [3] <author> Roberto Amadio. </author> <title> An asynchronous model of locality, failure, and process mobility. In COORDINATION '97, </title> <booktitle> volume 1282 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: These features make locations more visible in Dp than they are in DJoin. The goto operation is based on the spawn operation found in Facile [13] and related calculi <ref> [2, 3] </ref>; this operator is objective [8] and operates only on inactive code, making it very inexpensive to implement. By contrast, the subjective migration operator of DJoin operates on running code, making it more flexible and costlier to implement. <p> Without these properties our alternative characterization would fail. Other type systems for controlling the use of names in distributed systems have been presented by Amadio <ref> [3] </ref> and Sewell [22]. Amadio's type system seeks to guarantee that names are defined at only one location; his type system also guarantees that at every moment there is exactly one abstraction placed at each channel.
Reference: [4] <author> Roberto Amadio, Ilaria Castellani, and Davide Sangiorgi. </author> <title> On bisimu-lations for the asynchronous p-calculus. </title> <editor> In U. Montanari and V. Sas-sone, editors, </editor> <booktitle> CONCUR: Proceedings of the International Conference on Concurrency Theory, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147162, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: It is useful, therefore, to find alternative characterizations of the equivalence which do not involve universal quantification over observers. Such alternative characterizations, in the form of (labelled) bisimulation relations, have been given, for example, for the synchronous and asynchronous p-calculi <ref> [20, 4] </ref> and for distributed CCS [18]. In the full paper, we present such an alternative characterization of barbed equivalence for Dp, for image-finite processes. <p> Space does not permit us to present the full definition here, rather we discuss some of the issues involved in developing the labelled transition system (LTS) which is the basis of the alternative characterization. In constructing a labelled transition relation for the ordinary p-calculus <ref> [15, 20, 4] </ref>, one must be careful to distinguish the communication of a free name (which a testing context may already know about) from the communication of a bound name (which is guaranteed to be fresh for any testing context).
Reference: [5] <author> Grard Berry and Grard Boudol. </author> <title> The chemical abstract machine. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 8194, </pages> <address> San Francisco, </address> <month> January </month> <year> 1990. </year> <note> ACM Press. </note>
Reference-contexts: P ! L 0 . P 0 is given in Table 2 where it is assumed that all the process configurations are well formed, i.e. all of the free locations in P are found in L (i.e. locs (P) locs (L)). Structural equivalence. Following <ref> [5, 14] </ref>, we define reduction using an auxiliary structural equivalence, which we now explain. The structural equivalence j includes many standard rules and axioms.
Reference: [6] <author> Michele Boreale and Davide Sangiorgi. </author> <title> Typed bisimulation for the pi-calculus. Talk at EXPRESS97, </title> <month> September </month> <year> 1997. </year>
Reference-contexts: A similar approach has been developed independently by Boreale and Sangiorgi in order to define bisimulations for the p-calculus without matching <ref> [6] </ref>. 5 Conclusions We have presented a novel foundational language, Dp, for the study of typed distributed systems. The language includes constructs for process migration and failure. <p> Sewell studies a language similar to Dp, but closer in spirit to the join calculus. He generalizes the type system of Pierce and Sangiorgi by distinguishing local from non-local communication, with the goal of allowing compiler optimizations. Recently, Boreale and Sangiorgi <ref> [6] </ref> have presented an alternative characterization of the equivalence studied in [16] for a calculus without matching. Using their technique, one should be able to extend our results to a distributed language with the ability to match names explicitly predicated upon a permission.
Reference: [7] <author> G. Boudol. </author> <title> Asynchrony and the p-calculus. </title> <type> Research Report 1702, </type> <institution> INRIA, Sophia-Antipolis, </institution> <year> 1992. </year>
Reference: [8] <author> L. Cardelli and A. D. Gordon. Mobile ambients, </author> <year> 1997. </year> <note> Draft, Available from http://www.cl.cam.ac.uk/users/adg/. </note>
Reference-contexts: The rule s-split provides a clear contrast between the treatment of locations in Dp and the treatment of ambients in the ambient calculus <ref> [8] </ref>; in the ambient calculus, s-split does not hold. The rule s-chan states that `[(na)P] is equivalent to (n ` a)`[P] as long as ` contains the permission to create new channels. Note that when a channel declaration is pulled out of a thread its location is recorded. <p> Note that, unlike goto, the effect of a migration is non-local. The same is true of halt. It is for this reason that the effect of these operators is recorded in the runtime environment L, rather than in the local process term. In Cardelli and Gordon's terminology <ref> [8] </ref>, migration is subjective a local thread initiates `'s move to the new parent location whereas goto is objective a foreign thread invades location k. <p> Movement operators which combine these attributes in other ways are also possible; some of these are discussed in <ref> [8] </ref>. The rule r-comm is the most complicated of the rules in Table 2. Here, an abstraction (X :z) Q and a concretion hV i P are ready to synchronize at channel b of location `. <p> These features make locations more visible in Dp than they are in DJoin. The goto operation is based on the spawn operation found in Facile [13] and related calculi [2, 3]; this operator is objective <ref> [8] </ref> and operates only on inactive code, making it very inexpensive to implement. By contrast, the subjective migration operator of DJoin operates on running code, making it more flexible and costlier to implement. <p> Process movement is also the central concern of Cardelli and Gordon's ambient calculus <ref> [8] </ref>, although in their work locations (or ambients) are used to model a hierarchy of administrative domains, rather than, as in Dp, a hierarchy of 12 physical distribution as determined by failure dependencies.
Reference: [9] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <booktitle> Computing Systems, </booktitle> <address> 8(1):2759, </address> <month> January </month> <year> 1995. </year> <note> A preliminary version appeared in Proceedings of the 22nd ACM Symposium on Principles of Programming. </note>
Reference: [10] <author> R. De Nicola and M. C. B. Hennessy. </author> <title> Testing equivalences for processes. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 34:83133, </address> <year> 1984. </year>
Reference-contexts: Intuitively we wish to say that M is equivalent to N at D if M 10 and N are in PConfig (D) and for every appropriate context C , C [M] D C [N]. These contexts are intended to provide testing scenarios for the terms M and N <ref> [10] </ref>; therefore it is sufficient to restrict our attention to contexts in which a located process R (the experimenter, or observer) is run in parallel with M and N.
Reference: [11] <author> C. Fournet and G. Gonthier. </author> <booktitle> The refliexive CHAM and the join-calculus. In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> Paris, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference: [12] <author> C. Fournet, G. Gonthier, J.J. Levy, L. Marganget, and D. Remy. </author> <title> A calculus of mobile agents. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> CONCUR: Proceedings of the International Conference on Concur-rency Theory, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 406421, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Related work. There are two strains of related work; the first concerns the language itself, the second, the type system. Our model of location hierarchy, migration and failure is similar to model used in the distributed join calculus (DJoin) of Fournet, Gonthier and their co-workers <ref> [12] </ref>. Dp is a larger language, however; in addition to permissions, Dp includes synchronous communication, the goto operator, for code movement, and position testing; all of these require nontrivial encodings in DJoin. In addition, message routing is not automatic as it is in DJoin.
Reference: [13] <author> A. Giacalone, P. Mishra, and S. Prasad. </author> <title> A symmetric integration of concurrent and functional programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2):121160, </volume> <year> 1989. </year>
Reference-contexts: To send a message to a remote location in Dp, a process must first spawn a thread which goes to that location. These features make locations more visible in Dp than they are in DJoin. The goto operation is based on the spawn operation found in Facile <ref> [13] </ref> and related calculi [2, 3]; this operator is objective [8] and operates only on inactive code, making it very inexpensive to implement. By contrast, the subjective migration operator of DJoin operates on running code, making it more flexible and costlier to implement.
Reference: [14] <author> Robin Milner. </author> <title> The polyadic p-calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, UK, </institution> <month> October </month> <year> 1991. </year> <title> Also in Logic and Algebra of Specification, </title> <editor> ed. F. L. Bauer, W. Brauer and H. Schwichtenberg, </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: P ! L 0 . P 0 is given in Table 2 where it is assumed that all the process configurations are well formed, i.e. all of the free locations in P are found in L (i.e. locs (P) locs (L)). Structural equivalence. Following <ref> [5, 14] </ref>, we define reduction using an auxiliary structural equivalence, which we now explain. The structural equivalence j includes many standard rules and axioms. <p> The examples use recursive definitions of the form A (= P, where P is a basic process. It is well-known that such recursive definitions can be implemented using the replication operator flP (see for example <ref> [14] </ref>). First consider the following definition of a cell C (v). C (v) (= p? (x)C (x) + g? (y::z) C (v) j y :: z! hvi nil C (v) contains two channels: p for putting data into the cell and g for getting data out.
Reference: [15] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, Parts I and II. </title> <journal> Information and Computation, </journal> <volume> 100:1 77, </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: Space does not permit us to present the full definition here, rather we discuss some of the issues involved in developing the labelled transition system (LTS) which is the basis of the alternative characterization. In constructing a labelled transition relation for the ordinary p-calculus <ref> [15, 20, 4] </ref>, one must be careful to distinguish the communication of a free name (which a testing context may already know about) from the communication of a bound name (which is guaranteed to be fresh for any testing context).
Reference: [16] <author> Benjamin Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <note> Mathematical Structures in Computer Science, 6(5):409454, 1996. Extended abstract in LICS '93. </note>
Reference-contexts: The syntax for types, z, is built up using sets of the capabilities, g, as given in Table 1. Channels and locations are of types k and l respectively, whereas tuples of values have type e z. The channel types generalize those of Pierce and Sangiorgi <ref> [16] </ref> and location types are an extension of the same approach to locations. Note that in the channel type, chan g z, g dictates the use of the channel (send, receive, neither or both) while the type z constrains values that can be communicated on the channel. <p> In order to use b in any way (e.g. to distinguish it from other names at k), the receiver must receive the run capability on k. Note that, as in <ref> [16] </ref> in the syntax for processes all bound occurrences of identifiers must have associated with them an explicit type. <p> As stated above we are mainly interested in the type system as a way of controlling permissions, and thus we have not endowed it with features such as recursive types, poly-morphism, linearity, etc., many of which are entirely separate concerns; for example, the generalization to recursive types is straightforward <ref> [16, 24] </ref>. In Section 3 we introduce a type system for Dp and prove that well-typed programs are free of runtime type errors; to prove that the type system is safe, we also give a definition of runtime error in Section 3. <p> The use of tags and tag refinement is the major difference between our reduction semantics and that of <ref> [16] </ref>. Here when values are communicated the associated permissions are explicitly communicated as well, appropriately refined by the type of the channel used for the communication, while in [16] only the names but not the permissions are communicated. <p> The use of tags and tag refinement is the major difference between our reduction semantics and that of <ref> [16] </ref>. Here when values are communicated the associated permissions are explicitly communicated as well, appropriately refined by the type of the channel used for the communication, while in [16] only the names but not the permissions are communicated. The rules for the other constructs of the language are straightforward although it is worth noting how the rules for restriction are used. <p> The typing system is built up using the subtype relation defined in Table 4, which adapts the subtyping relation of <ref> [16] </ref> to our type system. Intuitively x z indicates that x is less restrictive than z, in the sense that whenever a context is well formed under the assumption that r has type z, then it is also well formed assuming that r has the more general type x. <p> More permissive types allow the sender to send data with fewer capabilities. Thus: chan fsndg (loc frung ) chan fsndg (loc frun;migg ) In short, input (rcv) is covariant and output (snd) is con-travariant. For further discussion, see <ref> [16] </ref>. Typing. The judgments of the typing system are given in Table 5, where we abbreviate the statement D ` w P:proc to D ` w P and D ` P:proc to D ` P. In the table two auxiliary typing judgments are also given: for values and predicates. <p> The typing system is defined on explicitly tagged terms, although it ignores tags entirely. Tags are included so that runtime error and type safety can be defined below. Many of the rules are adapted from those of <ref> [16] </ref>, although the style of presentation is somewhat different. We make heavy use of judgments concerning identifiers. The 8 judgment D ` w u:k should be read in D, u is a channel iden-tifier at location w with at least the permissions declared in k. <p> Barbed equivalence provides a primitive proof technique for reasoning about processes. Indeed, substantial theorems can be established this way <ref> [16, 1] </ref>. Proofs using the definition of barbed congruence directly, however, are hard work due to the quantification over all possible observers. It is useful, therefore, to find alternative characterizations of the equivalence which do not involve universal quantification over observers. <p> There, however, the permissions are used to control the ability to interpret data that has been received. The type system most closely related to ours is that of Pierce and Sangiorgi <ref> [16] </ref>. Besides the fact that we treat a distributed language, with an extended collection of types, we have made two main contributions, building on [16]. <p> The type system most closely related to ours is that of Pierce and Sangiorgi <ref> [16] </ref>. Besides the fact that we treat a distributed language, with an extended collection of types, we have made two main contributions, building on [16]. First we presented our language in such a way that the communication of permissions is explicit; we believe that this gives our Type Safety Theorem more operational intuition than that of [16]. <p> treat a distributed language, with an extended collection of types, we have made two main contributions, building on <ref> [16] </ref>. First we presented our language in such a way that the communication of permissions is explicit; we believe that this gives our Type Safety Theorem more operational intuition than that of [16]. Second, we have outlined an alternative characterization of barbed congruence, relativised to a typing constraint, as a bisimulation relation. We have been careful to construct the language so that a context can determine the structure of entire location tree and can test every name for equality. <p> He generalizes the type system of Pierce and Sangiorgi by distinguishing local from non-local communication, with the goal of allowing compiler optimizations. Recently, Boreale and Sangiorgi [6] have presented an alternative characterization of the equivalence studied in <ref> [16] </ref> for a calculus without matching. Using their technique, one should be able to extend our results to a distributed language with the ability to match names explicitly predicated upon a permission.
Reference: [17] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict: A programming language based on the pi-calculus. </title> <type> Technical Report CSCI 476, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year> <title> To appear in Proof, Language and Interaction: Essays in Honour of Robin Milner, </title> <editor> Gordon Plotkin, Colin Stirling, and Mads Tofte, editors, </editor> <publisher> MIT Press. </publisher>
Reference: [18] <author> James Riely and Matthew Hennessy. </author> <title> Distributed processes and location failures. </title> <institution> Computer Science Technical Report 2/97, University of Sussex, Department of Computer Science, </institution> <year> 1997. </year> <note> Available from http://www.cogs.susx.ac.uk/. </note>
Reference-contexts: It is useful, therefore, to find alternative characterizations of the equivalence which do not involve universal quantification over observers. Such alternative characterizations, in the form of (labelled) bisimulation relations, have been given, for example, for the synchronous and asynchronous p-calculi [20, 4] and for distributed CCS <ref> [18] </ref>. In the full paper, we present such an alternative characterization of barbed equivalence for Dp, for image-finite processes. <p> In the full paper, we prove that t ! and the reduction relation coincide. The other actions all require participation by the surrounding context. Four of these forms of actions are straightforward, being simple generalizations of those used in <ref> [18] </ref>: a!V :z the context receives V with permissions z. (ner)a?V the context sends V , revealing private names er. #` the context kills location `. `k the context moves ` to k.
Reference: [19] <author> James Riely and Matthew Hennessy. </author> <title> A typed language for distributed mobile processes. </title> <institution> Computer Science Technical Report 4/97, University of Sussex, Department of Computer Science, </institution> <year> 1997. </year> <note> Available from http://www.cogs.susx.ac.uk/. </note>
Reference: [20] <author> Davide Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> University of Edin-burgh, </institution> <year> 1992. </year>
Reference-contexts: P # b and a =2 n (b) L . P j Q # b if L . P # b Table 7: The commitment predicates <ref> [20] </ref>. The basic approach is to say that two processes P and Q are semantically equivalent if in every appropriate context C , C [P] C [Q], where : is a simple behavioral equivalence based on some notion of observation. <p> For this simple equivalence : we adapt the definition of barbed bisimulation; we are then left with the question of what are appropriate contexts in this typed language. We first adapt the definition of barbed bisimulation <ref> [20] </ref> to Dp. At this point we ignore entirely the tags on names, instead working with closed, well-typed terms. Throughout this section, let D and G range over closed type environments (i.e. environments whose domain contains no variables). <p> It is useful, therefore, to find alternative characterizations of the equivalence which do not involve universal quantification over observers. Such alternative characterizations, in the form of (labelled) bisimulation relations, have been given, for example, for the synchronous and asynchronous p-calculi <ref> [20, 4] </ref> and for distributed CCS [18]. In the full paper, we present such an alternative characterization of barbed equivalence for Dp, for image-finite processes. <p> Space does not permit us to present the full definition here, rather we discuss some of the issues involved in developing the labelled transition system (LTS) which is the basis of the alternative characterization. In constructing a labelled transition relation for the ordinary p-calculus <ref> [15, 20, 4] </ref>, one must be careful to distinguish the communication of a free name (which a testing context may already know about) from the communication of a bound name (which is guaranteed to be fresh for any testing context).
Reference: [21] <author> Davide Sangiorgi. </author> <title> Localities and true-concurrency in calculi for mobile processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 155, </volume> <year> 1996. </year>
Reference: [22] <author> Peter Sewell. </author> <title> Global/local subtyping for a distributed p-calculus. </title> <type> Technical Report 435, </type> <institution> Computer Laboratory, University of Cam-bridge, </institution> <month> August </month> <year> 1997. </year>
Reference-contexts: Without these properties our alternative characterization would fail. Other type systems for controlling the use of names in distributed systems have been presented by Amadio [3] and Sewell <ref> [22] </ref>. Amadio's type system seeks to guarantee that names are defined at only one location; his type system also guarantees that at every moment there is exactly one abstraction placed at each channel. Sewell studies a language similar to Dp, but closer in spirit to the join calculus.
Reference: [23] <author> Gert Smolka. </author> <title> The oz programming model. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today, volume 1000 of Lecture Notes in Computer Science, </booktitle> <pages> pages 324343. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference: [24] <author> David Turner. </author> <title> The Polymorphic Pi-Calculus: Theory and Implementation. </title> <type> PhD thesis, </type> <institution> Edinburgh University, </institution> <year> 1995. </year> <month> 13 </month>
Reference-contexts: As stated above we are mainly interested in the type system as a way of controlling permissions, and thus we have not endowed it with features such as recursive types, poly-morphism, linearity, etc., many of which are entirely separate concerns; for example, the generalization to recursive types is straightforward <ref> [16, 24] </ref>. In Section 3 we introduce a type system for Dp and prove that well-typed programs are free of runtime type errors; to prove that the type system is safe, we also give a definition of runtime error in Section 3.
References-found: 24

