URL: http://www.tns.lcs.mit.edu/~djw/library/GIT-CC-97-21.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Email: frdk,ammar,calvertg@cc.gatech.edu  
Title: Implementing Protocols in Java: The Price of Portability  
Author: Bobby Krupczak, Ken Calvert, Mostafa Ammar 
Note: This work was supported in part by grants from the National Science Foundation (NCR-9612855, NCR-9628379, and NCR 9305115). Java, JavaStation, JavaOS, JavaChip, and Solaris are all trademarks  
Date: August 1, 1997  
Address: Atlanta, GA 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  of Sun Microsystems, Inc.  
Pubnum: GIT-CC-97-21  
Abstract: As the number and variety of Web- and network-based applications continues to increase, so does the need for flexible communication protocols and services to support them. Traditionally, a major impediment to deployment of new protocols is the need to upgrade millions of end-systems with compatible implementations. At the same time, Java a language explicitly designed to support development and distribution of new applications via the Web is emerging as a (potentially) ubiquitous system platform. It is therefore natural to consider whether Java might speed the introduction of protocols to better support new applications. In this paper, we investigate the tradeoffs involved in using Java for protocol implementation and deployment. Using insights from a Java-based protocol suite and supporting subsystem we have implemented, we describe the benefits of using the Java language and quantify the performance cost of implementing a protocol in Java for various combinations of interpretation and compilation. We find that the performance cost of using Java-based protocols is presently equivalent to four years of hardware performance gains, i.e., interpreted, Java-based protocol performance on current hardware is roughly equivalent to the performance of compiled C code on four-year-old hardware. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> AT&T. </author> <title> UNIX System V Network Programmer's Guide. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1987. </year>
Reference-contexts: When outgoing packets enter the Java Ether protocol, they traverse out 5 of the virtual machine and into native-C methods which convert them into a format dictated by the Transport Layer Interface (TLI) <ref> [1] </ref> and Streams and then send them using the underlying Solaris Ethernet device driver.
Reference: [2] <author> Tim Berners-Lee, Robert Cailliau, Ari Luotonen, Henrik Frystyk Nielsen, and Arthur Secret. </author> <title> The world-wide web. </title> <journal> Communications of the ACM, </journal> <volume> 37(8) </volume> <pages> 76-82, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The tremendous growth of the World-Wide Web <ref> [2] </ref> has brought both new users and new applications to the Internet. Many of these new applications require network services not ideally matched by those provided by the traditional protocols (TCP/IP and UDP/IP).
Reference: [3] <author> Peter Deutsch and Alan M. Schiffman. </author> <title> Efficient implementation of the smalltalk-80 system. </title> <booktitle> In 11th Annual Symposium on Principles of Programming Languages (POPL-11), </booktitle> <pages> pages 297-302, </pages> <month> January </month> <year> 1984. </year> <month> 18 </month>
Reference-contexts: However, approaches such as just-in-time compilation <ref> [3, 16] </ref>, which performs runtime compilation of Java bytecode into that directly usable by the underlying host system, may reduce this gap. Figure 5 depicts the performance improvements attributable to the just-in-time (JIT) compilation of our JavaTalk implementation.
Reference: [4] <author> R. Droms. </author> <title> Dynamic host configuration protocol. Request for Comments (Experimental) RFC 1541, </title> <institution> Internet Engineering Task Force, </institution> <month> oct </month> <year> 1993. </year> <note> (Obsoletes RFC1531). </note>
Reference-contexts: Several different approaches can be applied to solve the addressing and security issues highlighted by HotLava. They are: * In-kernel end-point servers can be used to arbitrate addressing among user-level subsystems (both Java and non-Java based) [25]. * Dynamic address assignment protocols like DHCP <ref> [4] </ref> and AppleTalk's Name Binding Protocol (NBP) can be extended to allow the assignment of multiple, different logical addresses per physical entity.
Reference: [5] <author> Joseph R. Falcone. </author> <title> A programmable interface language for heterogeneous distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 330-351, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: The arrangements in which protocols are composed to provide services are described (and in some cases constrained) by a protocol graph. 2.1 Related Work The idea of configurable and extensible communication subsystems has been the subject of considerable research. Falcone <ref> [5] </ref>, Tschudin [26], and Holzmann [7] proposed extensible subsystems in which protocol code can be downloaded from protocol servers. The Streams [21] and x-Kernel [8] subsystems support some level of configurability and extensibility while Da CaPo [19] seeks to improve network performance through the elimination of unnecessary protocol functionality.
Reference: [6] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java T M language specification. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <month> October </month> <year> 1996. </year> <note> Version 1.0. </note>
Reference-contexts: TCP-style congestion control [9]) be re-invented over and over. Yet many new applications for example, multimedia conferencing could clearly benefit from such reusable, application-tailored protocols. Almost simultaneously, a new model for developing and deploying applications based on Java <ref> [6, 17] </ref> is emerging. Java and the World-Wide Web together are developing into a network-capable application-loader, providing a consistent interface to many network services and, more importantly, a portable and system-independent application platform. <p> However, as we shall see, the protocol portability problem is not completely eliminated due to constraints imposed by the way the Java virtual machine is integrated into the underlying system. 2.2 Overview of Java Java actually comprises two separate entities a programming language <ref> [6] </ref> and an underlying machine specification called the Java virtual machine [17]. Together, these can be thought of as roughly analogous to the combination of the C programming language and Sparc CPU architecture. The programming language 3 itself is object-oriented yet is simpler than languages like C++ and Smalltalk.
Reference: [7] <author> Gerard J. Holzmann. </author> <title> Standardized protocol interfaces. </title> <journal> Software Practice and Experience, </journal> <volume> 23(7) </volume> <pages> 711-93, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The arrangements in which protocols are composed to provide services are described (and in some cases constrained) by a protocol graph. 2.1 Related Work The idea of configurable and extensible communication subsystems has been the subject of considerable research. Falcone [5], Tschudin [26], and Holzmann <ref> [7] </ref> proposed extensible subsystems in which protocol code can be downloaded from protocol servers. The Streams [21] and x-Kernel [8] subsystems support some level of configurability and extensibility while Da CaPo [19] seeks to improve network performance through the elimination of unnecessary protocol functionality.
Reference: [8] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: Falcone [5], Tschudin [26], and Holzmann [7] proposed extensible subsystems in which protocol code can be downloaded from protocol servers. The Streams [21] and x-Kernel <ref> [8] </ref> subsystems support some level of configurability and extensibility while Da CaPo [19] seeks to improve network performance through the elimination of unnecessary protocol functionality. SPIN [20] is an extensible operating system supporting the dynamic addition of protocols at run-time while still providing a level of safety and performance.
Reference: [9] <author> Van Jacobson. </author> <title> Congestion avoidance and control. </title> <booktitle> In ACM SIGCOMM-1988 Symposium, </booktitle> <pages> pages 314-329, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: At best, custom protocols are incorporated into the application code itself which inhibits code re-use and requires that the same wheel (e.g. TCP-style congestion control <ref> [9] </ref>) be re-invented over and over. Yet many new applications for example, multimedia conferencing could clearly benefit from such reusable, application-tailored protocols. Almost simultaneously, a new model for developing and deploying applications based on Java [6, 17] is emerging.
Reference: [10] <author> Bobby Krupczak, Mostafa Ammar, and Ken Calvert. </author> <title> Multi-Subsystem Protocol Architectures: Motivation and Experience with an Adapter-Based Approach. </title> <booktitle> In Proceedings of IEEE INFOCOM, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: Others have implemented application protocols in Java; however, we know of no other work that focuses on general-purpose protocol support techniques and rigorously examines performance. Our own previous work <ref> [10, 11, 12] </ref> has considered protocol portability and proposed two different approaches for overcoming it within the context of traditional subsystems. In both cases, protocol portability was enhanced because protocols could remain in their native subsystem [10, 12] or could be re-used in another through encapsulation [11, 12]. <p> Our own previous work [10, 11, 12] has considered protocol portability and proposed two different approaches for overcoming it within the context of traditional subsystems. In both cases, protocol portability was enhanced because protocols could remain in their native subsystem <ref> [10, 12] </ref> or could be re-used in another through encapsulation [11, 12]. The research described in this paper addresses the protocol portability problem but does so by shifting the problem outward, toward the protocol subsystem and away from the protocol implementations themselves. <p> How protocols in HotLava access devices depends on the execution model and on the use of adapters (depicted as circles labeled with 'A') in Figure 2) tailored to that particular configuration. Adapter protocols <ref> [10, 12] </ref> are special purpose modules that provide conversion services for packets wishing to exit one subsystem and enter another. <p> We discuss that overhead next. 4.1 Protocol Processing Time and HotLava (Figure 4a) against that coded in C and Streams (Figure 4b). In order to provide more context, we also chart DDP's performance in C and the BSD and x-Kernel subsystems (taken from our earlier work <ref> [10] </ref>). These measurements depict send and receive protocol processing times per DDP packet. The results for the system Pugsley indicate that the use of Java increases protocol processing latency by a factor of approximately 10 for sending and 17 for receiving when running the subsystem as a Java application.
Reference: [11] <author> Bobby Krupczak, Ken Calvert, and Mostafa Ammar. </author> <title> Protocol Portability through Module Encapsulation. </title> <booktitle> In Proceedings of the International Conference on Network Protocols (ICNP-96), </booktitle> <pages> pages 56-63, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Others have implemented application protocols in Java; however, we know of no other work that focuses on general-purpose protocol support techniques and rigorously examines performance. Our own previous work <ref> [10, 11, 12] </ref> has considered protocol portability and proposed two different approaches for overcoming it within the context of traditional subsystems. In both cases, protocol portability was enhanced because protocols could remain in their native subsystem [10, 12] or could be re-used in another through encapsulation [11, 12]. <p> In both cases, protocol portability was enhanced because protocols could remain in their native subsystem [10, 12] or could be re-used in another through encapsulation <ref> [11, 12] </ref>. The research described in this paper addresses the protocol portability problem but does so by shifting the problem outward, toward the protocol subsystem and away from the protocol implementations themselves.
Reference: [12] <author> Bobby Krupczak, Kenneth L. Calvert, and Mostafa H. Ammar. </author> <title> Increasing the portability and re-usability of protocol code. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <note> 1997. (to appear). </note>
Reference-contexts: This combination offers several interesting features. First, protocols and additional code required to support them can be downloaded and executed on the fly as needed, thus enhancing the flexibility and interoperability of end systems. Second, the severity of the protocol code portability problem <ref> [12] </ref> is greatly reduced because the environment in which protocols execute (the Java virtual machine) has been ported instead of the individual protocols. Third, object-oriented features such as inheritance, specialization, and polymorphism can provide additional power for protocol programmers and enhance code re-use [13, 23]. <p> Others have implemented application protocols in Java; however, we know of no other work that focuses on general-purpose protocol support techniques and rigorously examines performance. Our own previous work <ref> [10, 11, 12] </ref> has considered protocol portability and proposed two different approaches for overcoming it within the context of traditional subsystems. In both cases, protocol portability was enhanced because protocols could remain in their native subsystem [10, 12] or could be re-used in another through encapsulation [11, 12]. <p> Our own previous work [10, 11, 12] has considered protocol portability and proposed two different approaches for overcoming it within the context of traditional subsystems. In both cases, protocol portability was enhanced because protocols could remain in their native subsystem <ref> [10, 12] </ref> or could be re-used in another through encapsulation [11, 12]. The research described in this paper addresses the protocol portability problem but does so by shifting the problem outward, toward the protocol subsystem and away from the protocol implementations themselves. <p> In both cases, protocol portability was enhanced because protocols could remain in their native subsystem [10, 12] or could be re-used in another through encapsulation <ref> [11, 12] </ref>. The research described in this paper addresses the protocol portability problem but does so by shifting the problem outward, toward the protocol subsystem and away from the protocol implementations themselves. <p> Our Java-based protocol approach makes extensive use of the capability to load and execute protocols on the fly. 3 Java-based Protocol Subsystem Design We next focus on the design of a Java-based protocol subsystem, which we term HotLava, using a previously-developed subsystem analysis methodology <ref> [12] </ref> that identifies the salient properties of protocol subsystems. We then present several different system models available to Java protocol programmers. We design and implement a Java-based protocol subsystem for several important reasons. <p> How protocols in HotLava access devices depends on the execution model and on the use of adapters (depicted as circles labeled with 'A') in Figure 2) tailored to that particular configuration. Adapter protocols <ref> [10, 12] </ref> are special purpose modules that provide conversion services for packets wishing to exit one subsystem and enter another.
Reference: [13] <author> R. Greg Lavender, Dennis G. Kafura, and Chris J. Tomlinson. </author> <title> Implementing communication protocols using object-oriented techniques. </title> <type> Technical Report TR-93-11, </type> <institution> Department of Computer Science, Virginia Tech, </institution> <year> 1992. </year>
Reference-contexts: Third, object-oriented features such as inheritance, specialization, and polymorphism can provide additional power for protocol programmers and enhance code re-use <ref> [13, 23] </ref>. These advantages, however, are not without cost. Presently, the Java virtual machine is invariably emulated in software. Until hardware implementations are available, the use of Java will carry a cost in terms of performance.
Reference: [14] <author> Samuel J. Leffler, Marshall Kirk McKusick, Michael J. Karels, and John S. Quaterman. </author> <title> The Design and Implementation of the 4.3 BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <address> 1st edition, </address> <year> 1989. </year>
Reference-contexts: Traditionally, protocol subsystems have normally resided entirely within the kernel or operating system. This placement has tended to increase the difficulty of developing and testing new protocol implementations. Alternatively, protocols and subsystems can reside in user-space along with applications. Thekkath [25] examined the problems encountered when moving the BSD <ref> [14] </ref> subsystem into user space. While they too cited flexibility and extensibility as goals, simply moving protocols to user-space does not necessarily improve portability since their implementations are still tied to a particular operating system and CPU architecture.
Reference: [15] <author> Peter W. Madany. </author> <title> JavaOS: A standalone java environment. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <month> May </month> <year> 1996. </year> <note> White Paper. </note>
Reference-contexts: In this case, HotLava executes alongside other Java applications within a network computer or JavaStation running a small, light-weight 7 operating system (termed the JavaOS <ref> [15] </ref>) that provides just enough services for the virtual machine to operate directly on hardware platforms 4 without the aid of a host operating system. In this configuration, a single virtual machine executes both HotLava and applications.
Reference: [16] <author> Sun Microsystems. </author> <title> Java JIT compiler overview. </title> <address> http://www.sun.com/workshop/java/jit/. </address>
Reference-contexts: However, approaches such as just-in-time compilation <ref> [3, 16] </ref>, which performs runtime compilation of Java bytecode into that directly usable by the underlying host system, may reduce this gap. Figure 5 depicts the performance improvements attributable to the just-in-time (JIT) compilation of our JavaTalk implementation.
Reference: [17] <author> Sun Microsystems. </author> <title> The Java virtual machine specification. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <month> August </month> <year> 1995. </year> <note> Version 1.0 Beta Draft. </note>
Reference-contexts: TCP-style congestion control [9]) be re-invented over and over. Yet many new applications for example, multimedia conferencing could clearly benefit from such reusable, application-tailored protocols. Almost simultaneously, a new model for developing and deploying applications based on Java <ref> [6, 17] </ref> is emerging. Java and the World-Wide Web together are developing into a network-capable application-loader, providing a consistent interface to many network services and, more importantly, a portable and system-independent application platform. <p> see, the protocol portability problem is not completely eliminated due to constraints imposed by the way the Java virtual machine is integrated into the underlying system. 2.2 Overview of Java Java actually comprises two separate entities a programming language [6] and an underlying machine specification called the Java virtual machine <ref> [17] </ref>. Together, these can be thought of as roughly analogous to the combination of the C programming language and Sparc CPU architecture. The programming language 3 itself is object-oriented yet is simpler than languages like C++ and Smalltalk.
Reference: [18] <author> P. Mockapetris. </author> <title> DNS encoding of network names and other types. Request for Comments RFC 1101, </title> <institution> Internet Engineering Task Force, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: For example, DHCP could be modified to assign multiple IP addresses to the same MAC-layer address. In effect, each different subsystem currently in use would obtain its own IP address. However, this solution is not without its costs. The domain-name address resolution protocol <ref> [18] </ref> may also require modification which can be extremely expensive for a fielded implementation. Lastly, this solution does not necessarily prevent spoofing attacks because it still requires cooperating user-level subsystems there is no mechanism to prevent a protocol implementation from using any address it chooses.
Reference: [19] <author> Thomas Plagemann, Bernhard Plattner, Martin Vogt, and Thomas Walter. </author> <title> Modules as building blocks for protocol configuration. </title> <booktitle> In Proceedings of the International Conference on Network Protocols (ICNP-93), </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Falcone [5], Tschudin [26], and Holzmann [7] proposed extensible subsystems in which protocol code can be downloaded from protocol servers. The Streams [21] and x-Kernel [8] subsystems support some level of configurability and extensibility while Da CaPo <ref> [19] </ref> seeks to improve network performance through the elimination of unnecessary protocol functionality. SPIN [20] is an extensible operating system supporting the dynamic addition of protocols at run-time while still providing a level of safety and performance.
Reference: [20] <author> Pardyak Przemyslaw and Brian N. Bershad. </author> <title> Dynamic binding for an extensible system. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation (OSDI'96), </booktitle> <pages> pages 201-212, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The Streams [21] and x-Kernel [8] subsystems support some level of configurability and extensibility while Da CaPo [19] seeks to improve network performance through the elimination of unnecessary protocol functionality. SPIN <ref> [20] </ref> is an extensible operating system supporting the dynamic addition of protocols at run-time while still providing a level of safety and performance.
Reference: [21] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-1910, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Falcone [5], Tschudin [26], and Holzmann [7] proposed extensible subsystems in which protocol code can be downloaded from protocol servers. The Streams <ref> [21] </ref> and x-Kernel [8] subsystems support some level of configurability and extensibility while Da CaPo [19] seeks to improve network performance through the elimination of unnecessary protocol functionality.
Reference: [22] <author> Douglas C. Schmidt and Tatsuya Suda. </author> <title> Transport system architecture services for high-performance communications systems. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 11(4) </volume> <pages> 489-506, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Process architecture Subsystems dictate how protocol entities like messages, layers, connections, buffers, and timers are bound to the underlying unit of scheduling. The manner in which they are bound is called a subsystem's process architecture <ref> [22] </ref>. HotLava defines a vertical process architecture in which packets are escorted through the protocol graph via non-preemptable threads.
Reference: [23] <author> Douglas C. Schmidt and Tatsuya Suda. </author> <title> An object-oriented framework for dynamically configuring extensible distributed communication systems. </title> <journal> IEE Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <month> December </month> <year> 1994. </year> <month> 19 </month>
Reference-contexts: Third, object-oriented features such as inheritance, specialization, and polymorphism can provide additional power for protocol programmers and enhance code re-use <ref> [13, 23] </ref>. These advantages, however, are not without cost. Presently, the Java virtual machine is invariably emulated in software. Until hardware implementations are available, the use of Java will carry a cost in terms of performance.
Reference: [24] <author> Gursharan S. Sidhu, Richard F. Andrews, and Alan B. Oppenheimer. </author> <title> Inside AppleTalk. </title> <publisher> Addison-Wesley, </publisher> <address> 1st edition, </address> <year> 1989. </year>
Reference-contexts: Both implementations are fully functional and have been tested against each other, against native Macintosh implementations, and against AppleTalk routers. We chose the AppleTalk protocol suite <ref> [24] </ref> for several important reasons. First, AppleTalk provides a broad set of services equivalent to the Internet protocol suite, is in widespread use, and provides a reasonable platform upon which to base our evaluation.
Reference: [25] <author> C. A. Thekkath, T. D. Nguyen, E. Moy, and E. D. Lazowska. </author> <title> Implementing network protocols at user level. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 554-565, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Traditionally, protocol subsystems have normally resided entirely within the kernel or operating system. This placement has tended to increase the difficulty of developing and testing new protocol implementations. Alternatively, protocols and subsystems can reside in user-space along with applications. Thekkath <ref> [25] </ref> examined the problems encountered when moving the BSD [14] subsystem into user space. While they too cited flexibility and extensibility as goals, simply moving protocols to user-space does not necessarily improve portability since their implementations are still tied to a particular operating system and CPU architecture. <p> Several different approaches can be applied to solve the addressing and security issues highlighted by HotLava. They are: * In-kernel end-point servers can be used to arbitrate addressing among user-level subsystems (both Java and non-Java based) <ref> [25] </ref>. * Dynamic address assignment protocols like DHCP [4] and AppleTalk's Name Binding Protocol (NBP) can be extended to allow the assignment of multiple, different logical addresses per physical entity.
Reference: [26] <author> Christian Tschudin. </author> <title> Flexible protocol stacks. </title> <booktitle> In ACM SIGCOMM-1991 Symposium, </booktitle> <pages> pages 197-205, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: The arrangements in which protocols are composed to provide services are described (and in some cases constrained) by a protocol graph. 2.1 Related Work The idea of configurable and extensible communication subsystems has been the subject of considerable research. Falcone [5], Tschudin <ref> [26] </ref>, and Holzmann [7] proposed extensible subsystems in which protocol code can be downloaded from protocol servers. The Streams [21] and x-Kernel [8] subsystems support some level of configurability and extensibility while Da CaPo [19] seeks to improve network performance through the elimination of unnecessary protocol functionality.
References-found: 26

