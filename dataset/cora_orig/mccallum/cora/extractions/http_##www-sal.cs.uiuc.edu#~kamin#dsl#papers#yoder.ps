URL: http://www-sal.cs.uiuc.edu/~kamin/dsl/papers/yoder.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/dsl/index.html
Root-URL: http://www.cs.uiuc.edu
Title: Abstract  
Abstract: Spreadsheets comprise a language metaphor which has been found very useful for manipulation and presentation of financial data. As such they may be considered a domain-specific language. The metaphor may have application in other areas, however. For example, spreadsheets simultaneously offer natural parallelism and ease of use. Adapting them to do general-purpose computing while preserving their natural parallelism and ease of use would be highly desirable, especially given the current trend toward massive parallelism. And the ease with which users are able to format their output would be a desirable addition to any general-purpose language. This paper focuses on two things. The first is language features that may reasonably be added to existing spreadsheets to make them look more like general-purpose languages. These features include user-defined functions, structures, cyclical dependencies and so on. The second is on the domain-specific features of spreadsheets which are not encompassed by any general-purpose language constructs. These are primarily the addressing modes, and constitute an as yet unstandardized way of denoting cells at an arbitrary offset from a given cell. 
Abstract-found: 1
Intro-found: 1
Reference: [AFJ 91] <author> E.A. Ashcroft, A.A.Faustini and R. Jagannathan. </author> <title> An Intensional Language for Parallel Applications Programming. In Parallel Functional Languages and Compilers, </title> <editor> Boleslaw K. Szymanski, </editor> <publisher> ed. </publisher> <pages> pp. 11-49. </pages> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: It may be possible to take some inspiration from Lucid <ref> [AFJ 91] </ref>, an intensional dataflow language which does provide a notion of context. In Lucid, variables represent infinite temporal sequences of values. These sequences represent the intension, the union of all possible contexts for the variable.
Reference: [AU 91] <author> Arvind, L. Bic and T. Ungerer. </author> <title> Evolution of Data-Flow Computers. </title> <booktitle> In Advanced Topics in Data-Flow Computing. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: The crucial difference between a spreadsheet and a dataflow system is that in dataflow, nodes are not computed until all their inputs are available <ref> [AU 91] </ref>. This means that if the user changes the value in cell A1, a dataflow system would not recompute A3 until the user also changed the value of A2.
Reference: [BC 91] <author> J. A. Brown and H. P. Crowder. APL2: </author> <title> Getting Started. </title> <journal> In IBM Systems Journal 30(4) </journal> <pages> 433-445, </pages> <year> 1991. </year>
Reference-contexts: A block is a hyper-rectangular container for cells. As with arrays in general-purpose languages, blocks are of fixed size. Borrowing from APL <ref> [BC 91] </ref> and array theory [Mor 73], a blocks dimensionality is called its rank, and the vector containing the sizes of each dimension is called its shape. Blocks can be nested.
Reference: [DW 90] <author> Weiching Du and W. W. Wadge. </author> <title> The Eductive Implementation of a Three-dimensional Spreadsheet. </title> <booktitle> In SoftwarePractice and Experience 20(11): </booktitle> <pages> 1097-1114. </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: A sequence is evaluated to whatever degree is needed; the unneeded portion of a sequence is represented by a closure, which encapsulates the last known value and a function for computing the next one. Plane Lucid <ref> [DW 90] </ref> is a variant of Lucid in which additional primitives are present for dealing with objects in a plane. These primitives, such as right, left, up, down and so on, do give this conventional language a notion of geometric context.
Reference: [FJ 93] <author> A.A. Faustini and R. Jagannathan. </author> <title> Multidimensional Problem Solving in Lucid. From the authors. </title>
Reference-contexts: This is not very much different, however, from saying that an array in a conventional programming language is intentional because the result of an indexing operation varies with the value of the index. Multidimensional variants of Lucid <ref> [FJ 93] </ref> allow for sequences of multiple dimen-sionalities; the foregoing objection seems to hold for these as well. Other languages that feature lazy evaluation, such as SASL [Kam 90], are capable of building infinite sequences without a notion of context.
Reference: [KBB 96] <author> P. Kogge et al, Pursuing a Petaop: </author> <title> Point Designes for 100 TF Computers Using PIM Technologies. </title> <booktitle> In Frontiers of Massively Parallel Computation, </booktitle> <year> 1996. </year>
Reference-contexts: Processor-in-memory (PIM) technology, for instance, which is focused on reducing the processor-memory bottleneck by embedding processors directly in the memory arrays, tends toward an architecture which provides many thousands of simple processors in a grid layout <ref> [KBB 96] </ref>.
Reference: [Kam 90] <author> Sam Kamin. </author> <title> Programming Languages, an Interpreter-based Approach. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Multidimensional variants of Lucid [FJ 93] allow for sequences of multiple dimen-sionalities; the foregoing objection seems to hold for these as well. Other languages that feature lazy evaluation, such as SASL <ref> [Kam 90] </ref>, are capable of building infinite sequences without a notion of context. A sequence is evaluated to whatever degree is needed; the unneeded portion of a sequence is represented by a closure, which encapsulates the last known value and a function for computing the next one.
Reference: [Lie 86] <author> Henry Liebermann. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In OOPSLA '86 Conference Proceedings, </booktitle> <pages> pp 214-223, </pages> <year> 1986. </year> <note> Published as SIGPLAN Notice 21(11), </note> <month> November </month> <year> 1986. </year>
Reference-contexts: Addressing General-purpose languages which provide arrays always provide some means of addressing various elements within an array. Spreadsheets, however, intro 1. Allowing other cells to be the source of a formula evolves the spreadsheet language toward the concept of delegation <ref> [Lie 86] </ref>. It also opens up the door for a multi-level delegation scheme, in which a cell inherits first from its row, or if that is empty, its column, or finally its parent block.
Reference: [Mor 73] <author> Trenchard More. </author> <title> Axioms and Theorems for a Theory of Arrays. </title> <journal> In IBM Journal of Research and Development 17(2) </journal> <pages> 135-175, </pages> <month> March </month> <year> 1973. </year>
Reference-contexts: A block is a hyper-rectangular container for cells. As with arrays in general-purpose languages, blocks are of fixed size. Borrowing from APL [BC 91] and array theory <ref> [Mor 73] </ref>, a blocks dimensionality is called its rank, and the vector containing the sizes of each dimension is called its shape. Blocks can be nested. <p> But this means that the cell C must (at least indirectly) assign values to its child cells. The same problem pertains with almost all array operations. This is a shame, because there is, on the surface, a simple and intuitive mapping from the constructs of APL and array theory <ref> [Mor 73] </ref> to the spreadsheet metaphor. We seem to be in a bit of a quandary. On the one hand, side-effecting assignment is evil. On the other =C A Bx hand, it seems to help us to provide a valuable abstraction (array operations), and so it is good.
Reference: [RS 95] <author> Repenning, A. and T. Sumner, "Agentsheets: </author> <title> A Medium for Creating Domain-Oriented Visual Languages," </title> <journal> In IEEE Computer, </journal> <volume> Vol. 28, </volume> <pages> pp. 17-25, </pages> <year> 1995 </year>
Reference-contexts: We also attempt to answer, at least in part, whether domain-specific language constructs found in spreadsheets can be moved into general purpose languages. Our approach is largely orthogonal to the work of others, such as Alex Repenning <ref> [RS 95] </ref>, who have tackled the problem of domain-specific problem representations, also using spreadsheets as a starting point, with fairly spectacular results.
Reference: [YC 94] <author> Alan G. Yoder and David L. Cohn. </author> <title> Real Spreadsheets for Real Programmers. </title> <booktitle> In Proceedings of the 1994 IEEE Conference on Computer Languages (ICCL 94). </booktitle> <pages> pp. 20-30. </pages>
Reference-contexts: The question is, then, are there any obstacles to this adaptation? Some efforts have been made to move spreadsheets toward the main stream of programming languages <ref> [YC 94] </ref>; the results have tended to look like a mainstream procedural language with a spreadsheet as a GUI, and the implicit parallelism of the metaphor has also been largely lost. <p> Keeping all cell values up to date (a process known as recalculation) is a fundamental task for any spreadsheet system. Since cells use other cells values to calculate their own, a graph of dependencies is implicit in every spreadsheet. This dependency graph (DG) can be used to optimize recalculation <ref> [YC 94] </ref>. Its existence suggests that a spreadsheet could be mapped naturally to a dataflow language system. It turns out that this intuition is not entirely accurate; this interesting result is discussed in section 5. <p> Iteration Iteration can be added to a spreadsheet language in two fundamental ways. First, it can be provided by the in-cell language; this method has been used in prior work <ref> [YC 94] </ref>. Second, it can be emulated using circular dependencies; this is truer to the functional, declarative nature of spreadsheets, and better preserves opportunities for parallelism. Iteration via circular dependencies is best explained with an example.
References-found: 11

