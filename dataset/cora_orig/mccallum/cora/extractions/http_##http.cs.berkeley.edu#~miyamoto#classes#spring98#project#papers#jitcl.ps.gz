URL: http://http.cs.berkeley.edu/~miyamoto/classes/spring98/project/papers/jitcl.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~miyamoto/classes/spring98/project/index.html
Root-URL: http://www.cs.berkeley.edu
Email: bchen@eecs.harvard.edu  
Title: Improving Instruction Locality with Just-In-Time Code Layout  
Author: J. Bradley Chen and Bradley D. D. Leupen 
Affiliation: Division of Engineering and Applied Sciences Harvard University  
Abstract: This paper describes Just-In-Time code layout (JITCL), a new method for improving the locality of an instruction reference stream by selecting the order of procedures in the text segment during program execution. By determining procedure placement dynamically, this method provides an optimized procedure layout without requiring profile data. For UNIX-style workloads, JITCL provides improvements in instruction cache performance comparable to profile-based layout strategies, while avoiding the requirement of profile data. The late nature of this optimization makes it possible to implement procedure orderings across executable and DLL boundaries, overcoming a limitation of current profile-based techniques. Simulations using Etch [RVL97] on Windows NT show that inter-module JITCL commonly reduces the memory footprint of executable text by 50%. 
Abstract-found: 1
Intro-found: 1
Reference: [CL97] <author> J. Bradley Chen and Bradley D.D. Leupen. </author> <title> Improving Instruction Locality with Just-In-Time Code Layout, </title> <type> Technical Report, </type> <institution> Division of Engineering and Applied Sciences, Harvard University, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: In this case, a user-level routine to flush a cache line or set can be implemented with minimal operating system support <ref> [CL97] </ref>. Just-in-time compilers, as have been proposed for languages such as Java [GJS96], are likely to encounter similar problems. Each procedure that is referenced dynamically is copied exactly once into instruction memory before being invoked.
Reference: [RVL97] <author> Ted Romer, Geoff Voelker, Dennis Lee, Alec Wolman, Wayne Wong, Brian Bershad, Hank Levy, and Brad Chen. </author> <title> Etch, an Instrumentation and Optimization tool for Win32 Programs. </title> <booktitle> Proceedings of the 1997 USENIX Windows NT Workshop, USENIX Association, </booktitle> <address> Berkeley CA. </address> <note> (In this volume). See also http://www.cs.washington.edu/ homes/bershad/Etch/. </note>
Reference-contexts: The results in Section 4 show that JITCL compares favorably with profile-based layout schemes, in spite of this optimistic estimate of the benefit of profile-based layout. 3.2 Win32 Methodology We evaluated our Win32 workloads using Windows NT 4.0 on an Intel Pentium-Pro based PC. We used the Etch <ref> [RVL97] </ref> instrumentation and optimization system to implement an instruction cache simulator. For these experiments, we modeled an on-chip 8K byte 2-way set associative instruction cache, backed by a 512K byte direct-mapped off-chip cache. Both caches used 32-byte lines.
Reference: [FF92] <author> J. A. Fisher and S. M. Freudenberger. </author> <title> Predicting Conditional Branch Directions from Previous Runs of a Program, </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, ACM, </booktitle> <pages> pp. 85-97, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For the Pettis and Hansen experiments, we trained and tested on the same input. This tends to give a high estimate for the potential benefit of the profile-based optimization; conventional methodology prescribes that different inputs should be used for training and testing <ref> [FF92] </ref>. The results in Section 4 show that JITCL compares favorably with profile-based layout schemes, in spite of this optimistic estimate of the benefit of profile-based layout. 3.2 Win32 Methodology We evaluated our Win32 workloads using Windows NT 4.0 on an Intel Pentium-Pro based PC.
Reference: [GJS96] <author> J. Gosling, B. Joy, and G. Steele, </author> <title> The Java Language Specification, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: In this case, a user-level routine to flush a cache line or set can be implemented with minimal operating system support [CL97]. Just-in-time compilers, as have been proposed for languages such as Java <ref> [GJS96] </ref>, are likely to encounter similar problems. Each procedure that is referenced dynamically is copied exactly once into instruction memory before being invoked. JITCL relies on filesystem caching to minimize the number of operations to disk when copying procedures from the executable file into instruction memory.
Reference: [PH90] <author> K. Pettis and R. Hansen. </author> <title> Profile Guided Code Positioning, </title> <booktitle> Proceedings of SIGPLAN `90 Conference on Programming Language Design and Implementation, ACM, </booktitle> <pages> pp. 16-27, </pages> <month> June </month> <year> 1990. </year>
Reference: [SE94] <author> A. Srivastava and A. Eustace. </author> <title> ATOM: A System for Building Customized Program Analysis Tools, </title> <booktitle> Proceedings of the SIGPLAN 1994 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 196-205, </pages> <month> June </month> <year> 1994. </year> <note> See also DEC WRL Research Report 94/2. </note>
Reference-contexts: Our Win32 experiments build on the UNIX results by exploring the behavior of JITCL for large Windows applications that use many DLLs. 3.1 UNIX Methodology We evaluated our UNIX workloads on Digital UNIX and the Digital Alpha microprocessor, using the Atom <ref> [SE94] </ref> instrumentation system to implement our simulator. We instrumented basic blocks, loads and stores in the executable program, inserting calls at these points to our JITCL simulator. Within the simulator, we maintained the state of the caches.
References-found: 6

