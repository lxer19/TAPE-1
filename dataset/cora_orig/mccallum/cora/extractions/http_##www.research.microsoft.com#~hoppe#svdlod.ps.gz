URL: http://www.research.microsoft.com/~hoppe/svdlod.ps.gz
Refering-URL: http://www.research.microsoft.com/~hoppe/
Root-URL: http://www.research.microsoft.com
Title: Smooth View-Dependent Level-of-Detail Control and its Application to Terrain Rendering  
Author: Hugues Hoppe 
Affiliation: Microsoft Research  
Abstract: The key to real-time rendering of large-scale surfaces is to locally adapt surface geometric complexity to changing view parameters. Several schemes have been developed to address this problem of view-dependent level-of-detail control. Among these, the view-dependent progressive mesh (VDPM) framework represents an arbitrary triangle mesh as a hierarchy of geometrically optimized refinement transformations, from which accurate approximating meshes can be efficiently retrieved. In this paper we extend the general VDPM framework to provide temporal coherence through the run-time creation of geomorphs. These geomorphs eliminate popping artifacts by smoothly interpolating geometry. Their implementation requires new output-sensitive data structures, which have the added benefit of reducing memory use. We specialize the VDPM framework to the important case of terrain rendering. To handle huge terrain grids, we introduce a block-based simplification scheme that constructs a progressive mesh as a hierarchy of block refinements. We demonstrate the need for an accurate approximation metric during simplification. Our contributions are highlighted in a real-time flyover of a large, rugged terrain. Notably, the use of geomorphs results in visually smooth rendering even at 72 frames/sec on a graphics workstation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bajaj, C., and Schikore, D. </author> <title> Error-bounded reduction of triangle meshes with multivariate data. </title> <booktitle> SPIE 2656 (1996), </booktitle> <pages> 34-45. </pages>
Reference-contexts: Many types of graphics scenes have complex geometric descriptions. It should be emphasized, however, that scenes often contain many distinct small-scale objects, for which LOD can be adjusted independently [10] using traditional view-independent simplification techniques (e.g. <ref> [1, 3, 12, 15, 21] </ref>). In our opinion, the overhead of view-dependent LOD is only justified when necessary for large-scale continuous surfaces. In outdoor scenes, the primary instance is the terrain surface. <p> We therefore want to compute the maximum height deviation between this triangulated grid and the open neighborhood of each edge collapse transformation. (Similar derivations are described in <ref> [1, 3, 9] </ref>.) The maximum height deviation between two triangle meshes is known to lie at a vertex of their union partition in the plane (e.g. the vertices labeled in Figure 8).
Reference: [2] <author> Cignoni, P., Puppo, E., and Scopigno, R. </author> <title> Representation and visualization of terrain surfaces at variable resolution. </title> <booktitle> The Visual Computer 13 (1997), </booktitle> <pages> 199-217. </pages>
Reference-contexts: As a result, the approximations may be far from optimal when one considers the space of all possible triangulations of the domain. Several methods use Delaunay triangulation to develop mul-tiresolution hierarchies <ref> [2, 5] </ref>. In particular, Cohen-Or and Lev-anoni [5] support on-line view-dependent LOD with temporal coherence, but must resort to two-stage geomorphs. Compared to quadtrees and bintrees, these methods allow more general distribution of vertices over the domain. <p> static storage to 48n bytes using 16-bit indices, quantization, and lookup tables as described in Section 4.1. 5.1 Exact approximation error For height fields, it is common in the literature to measure the approximation error of a simplified mesh by its maximum vertical deviation at the original grid points (e.g. <ref> [2, 7, 11] </ref>). For view-dependent LOD, however, measuring deviation solely at grid points is generally insufficient, which is surprising at first since the only input is the discrete set of grid points, i.e., there is no knowledge of the surface between the points. <p> For height fields, an alternative approach requiring less memory is to start from a coarse approximation and progressively insert vertices <ref> [2, 11] </ref>. However, such greedy refinement methods generally yield inferior approximations (e.g. compare Figures 25-26 in [11] with Figure 8b in [15]).
Reference: [3] <author> Cohen, J., Manocha, D., and Olano, M. </author> <title> Simplifying polygonal models using successive mappings. </title> <booktitle> In Visualization '97 Proceedings (1997), IEEE, </booktitle> <pages> pp. 81-88. </pages>
Reference-contexts: Many types of graphics scenes have complex geometric descriptions. It should be emphasized, however, that scenes often contain many distinct small-scale objects, for which LOD can be adjusted independently [10] using traditional view-independent simplification techniques (e.g. <ref> [1, 3, 12, 15, 21] </ref>). In our opinion, the overhead of view-dependent LOD is only justified when necessary for large-scale continuous surfaces. In outdoor scenes, the primary instance is the terrain surface. <p> (on heap) [m] ListNode listnode // list stringing active vertices Vertex* vertex // pointer back to static vertex VGeom vgeom // vertex coordinates (x,y,z) VertexMorph* vmorph // 6= 0 if geomorphing (Section 4.2) struct AFace // Active face (on heap) [2m] ListNode listnode // list stringing active faces AVertex* vertices <ref> [3] </ref> // ordered counter-clockwise AFace* neighbors [3] // neighbors [j] across from vertices [j] int texture id // texture tile identifier struct VertexMorph // (on heap, see Section 4.2) [g] bool coarsening // true if coarsening, false if refining short gtime // # of geomorph frames remaining VGeom vg refined // <p> list stringing active vertices Vertex* vertex // pointer back to static vertex VGeom vgeom // vertex coordinates (x,y,z) VertexMorph* vmorph // 6= 0 if geomorphing (Section 4.2) struct AFace // Active face (on heap) [2m] ListNode listnode // list stringing active faces AVertex* vertices <ref> [3] </ref> // ordered counter-clockwise AFace* neighbors [3] // neighbors [j] across from vertices [j] int texture id // texture tile identifier struct VertexMorph // (on heap, see Section 4.2) [g] bool coarsening // true if coarsening, false if refining short gtime // # of geomorph frames remaining VGeom vg refined // refined geometry (back-up copy) VGeom vginc <p> We therefore want to compute the maximum height deviation between this triangulated grid and the open neighborhood of each edge collapse transformation. (Similar derivations are described in <ref> [1, 3, 9] </ref>.) The maximum height deviation between two triangle meshes is known to lie at a vertex of their union partition in the plane (e.g. the vertices labeled in Figure 8). <p> In this section we briefly discuss how the techniques of Section 5 can be generalized to work on arbitrary meshes. Approximation error. Several recent methods are able to track upper bounds on maximum geometric error during simplification of arbitrary meshes. Among these, at least two <ref> [3, 13] </ref> specifically consider sequences of edge collapse transformations. It would be easy to include these methods within the general VDPM framework. Other recent work [4] obtains bounds on parametric approximation error, which is appropriate in the presence of texture mapping. Hierarchical construction.
Reference: [4] <author> Cohen, J., Olano, M., and Manocha, D. </author> <title> Appearance-preserving simplification. </title> <booktitle> Computer Graphics (SIGGRAPH '98 Proceedings) (1998). </booktitle>
Reference-contexts: parent // parent vertex, 0 if root int i // index of vsplit i , -1 if leaf struct Face // Static face [2n] AFace* aface // active face, 0 if inactive struct Vsplit // Vertex split [n] VGeom vu vgeom // geometry for child vertex v u Face* fn <ref> [4] </ref> // required neighbors f n0 ; f n1 ; f n2 ; f n3 float radius // max extent r v of affected region y float sin2alpha // cone-of-normals angle (sin 2 ff v ) y float uni error // uniform error v float dir error // directional error ffi <p> Several recent methods are able to track upper bounds on maximum geometric error during simplification of arbitrary meshes. Among these, at least two [3, 13] specifically consider sequences of edge collapse transformations. It would be easy to include these methods within the general VDPM framework. Other recent work <ref> [4] </ref> obtains bounds on parametric approximation error, which is appropriate in the presence of texture mapping. Hierarchical construction. A Voronoi construction as in [9] can be used to recursively partition an arbitrary mesh into a hierarchy of regions.
Reference: [5] <author> Cohen-Or, D., and Levanoni, Y. </author> <title> Temporal continuity of levels of detail in Delaunay trianulated terrain. </title> <booktitle> In Visualization '96 Proceedings (1996), IEEE, </booktitle> <pages> pp. 37-42. </pages>
Reference-contexts: As a result, the approximations may be far from optimal when one considers the space of all possible triangulations of the domain. Several methods use Delaunay triangulation to develop mul-tiresolution hierarchies <ref> [2, 5] </ref>. In particular, Cohen-Or and Lev-anoni [5] support on-line view-dependent LOD with temporal coherence, but must resort to two-stage geomorphs. Compared to quadtrees and bintrees, these methods allow more general distribution of vertices over the domain. <p> As a result, the approximations may be far from optimal when one considers the space of all possible triangulations of the domain. Several methods use Delaunay triangulation to develop mul-tiresolution hierarchies [2, 5]. In particular, Cohen-Or and Lev-anoni <ref> [5] </ref> support on-line view-dependent LOD with temporal coherence, but must resort to two-stage geomorphs. Compared to quadtrees and bintrees, these methods allow more general distribution of vertices over the domain. However, the mesh connectivities are again constrained, in this case by the Delaunay triangulation criterion. Arbitrary meshes.
Reference: [6] <author> De Floriani, L., Magillo, P., and Puppo, E. </author> <title> Building and traversing a surface at variable resolution. </title> <booktitle> In Visualization '97 Proceedings (1997), IEEE, </booktitle> <pages> pp. 103-110. </pages>
Reference-contexts: Whereas Xia and Varshney construct the hierarchy using an edge length heuristic, Hoppe constructs it from the geometrically optimized sequence in a progressive mesh representation (Section 3). De Floriani et al. <ref> [6] </ref> introduce another related refinement hierarchy. When applied to the special case of height fields, these frameworks are able to satisfy a given approximation error using fewer faces due to the absence of connectivity constraints.
Reference: [7] <author> De Floriani, L., Marzano, P., and Puppo, E. </author> <title> Multiresolu-tion models for topographic surface description. </title> <booktitle> The Visual Computer 12, 7 (1996), </booktitle> <pages> 317-345. </pages>
Reference-contexts: Scalability : To handle huge terrain models, we present a block-based recursive simplification process (Section 5.2). The result of this process is a hierarchical progressive mesh representation that permits runtime memory management. 2 RELATED WORK Height fields. Although there exist numerous multiresolution representations for height fields (see surveys in <ref> [7, 14] </ref>), only a subset support view-dependent LOD, and it is only recently that efficient on-line algorithms have been introduced that incrementally adapt LOD as the view parameters change. Taylor and Barrett [22] extract mesh approximations from rectangular quadtree hierarchies. <p> static storage to 48n bytes using 16-bit indices, quantization, and lookup tables as described in Section 4.1. 5.1 Exact approximation error For height fields, it is common in the literature to measure the approximation error of a simplified mesh by its maximum vertical deviation at the original grid points (e.g. <ref> [2, 7, 11] </ref>). For view-dependent LOD, however, measuring deviation solely at grid points is generally insufficient, which is surprising at first since the only input is the discrete set of grid points, i.e., there is no knowledge of the surface between the points.
Reference: [8] <author> Duchaineau, M., Wolinsky, M., Sigeti, D., Miller, M., Aldrich, C., and Mineev-Weinstein, M. </author> <title> ROAMing terrain: real-time optimally adapting meshes. </title> <booktitle> In Visualization '97 Proceedings (1997), IEEE, </booktitle> <pages> pp. 81-88. </pages>
Reference-contexts: Taylor and Barrett [22] extract mesh approximations from rectangular quadtree hierarchies. Both Lindstrom et al. [18] and Duchaineau et al. <ref> [8] </ref> define bintree hierarchies, based on binary subdivision of right isosceles triangles, and demonstrate real-time view-dependent LOD. Because these representations are based on regular subdivision, they offer concise storage. Duchaineau et al. are able to create optimal approximating meshes through incremental changes at each frame.
Reference: [9] <author> Eck, M., DeRose, T., Duchamp, T., Hoppe, H., Louns-bery, M., and Stuetzle, W. </author> <title> Multiresolution analysis of arbitrary meshes. </title> <booktitle> Computer Graphics (SIGGRAPH '95 Proceedings) (1995), </booktitle> <pages> 173-182. </pages>
Reference-contexts: We therefore want to compute the maximum height deviation between this triangulated grid and the open neighborhood of each edge collapse transformation. (Similar derivations are described in <ref> [1, 3, 9] </ref>.) The maximum height deviation between two triangle meshes is known to lie at a vertex of their union partition in the plane (e.g. the vertices labeled in Figure 8). <p> It would be easy to include these methods within the general VDPM framework. Other recent work [4] obtains bounds on parametric approximation error, which is appropriate in the presence of texture mapping. Hierarchical construction. A Voronoi construction as in <ref> [9] </ref> can be used to recursively partition an arbitrary mesh into a hierarchy of regions. Although the regions are no longer square blocks, the bottom-up simplification and stitching scheme should work with little modification.
Reference: [10] <author> Funkhouser, T., and S equin, C. </author> <title> Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments. </title> <booktitle> Computer Graphics (SIGGRAPH '93 Proceedings) (1993), </booktitle> <pages> 247-254. </pages>
Reference-contexts: To our knowledge this is the first runtime scheme for temporally smooth, view-dependent LOD control on arbitrary meshes. Many types of graphics scenes have complex geometric descriptions. It should be emphasized, however, that scenes often contain many distinct small-scale objects, for which LOD can be adjusted independently <ref> [10] </ref> using traditional view-independent simplification techniques (e.g. [1, 3, 12, 15, 21]). In our opinion, the overhead of view-dependent LOD is only justified when necessary for large-scale continuous surfaces. In outdoor scenes, the primary instance is the terrain surface.
Reference: [11] <author> Garland, M., and Heckbert, P. </author> <title> Fast polygonal approximation of terrains and height fields. </title> <type> CMU-CS 95-181, </type> <institution> CS Dept., Carnegie Mellon University, </institution> <year> 1995. </year>
Reference-contexts: static storage to 48n bytes using 16-bit indices, quantization, and lookup tables as described in Section 4.1. 5.1 Exact approximation error For height fields, it is common in the literature to measure the approximation error of a simplified mesh by its maximum vertical deviation at the original grid points (e.g. <ref> [2, 7, 11] </ref>). For view-dependent LOD, however, measuring deviation solely at grid points is generally insufficient, which is surprising at first since the only input is the discrete set of grid points, i.e., there is no knowledge of the surface between the points. <p> For height fields, an alternative approach requiring less memory is to start from a coarse approximation and progressively insert vertices <ref> [2, 11] </ref>. However, such greedy refinement methods generally yield inferior approximations (e.g. compare Figures 25-26 in [11] with Figure 8b in [15]). <p> For height fields, an alternative approach requiring less memory is to start from a coarse approximation and progressively insert vertices [2, 11]. However, such greedy refinement methods generally yield inferior approximations (e.g. compare Figures 25-26 in <ref> [11] </ref> with Figure 8b in [15]). Our hierarchical strategy allows us to tackle the problem piecemeal with an accurate simplification-based method. * For even larger models, a pre-simplified mesh may still be too large to fit in main memory. <p> If one resorts to the operating system's virtual memory manager, the resulting paging causes 1 The use of an L 2 norm to integrate squared error over the domain is inadequate, as reported in <ref> [11] </ref>. the process to pause intermittently, disturbing frame rate. By partitioning the refinement database into a block hierarchy, we can exploit domain knowledge to explicitly pre-fetch refinement data before it is needed. * Just as the geometry data may be too large for memory, so may its associated texture image.
Reference: [12] <author> Garland, M., and Heckbert, P. </author> <title> Surface simplification using quadric error metrics. </title> <booktitle> Computer Graphics (SIGGRAPH '97 Proceedings) (1997), </booktitle> <pages> 209-216. </pages>
Reference-contexts: Many types of graphics scenes have complex geometric descriptions. It should be emphasized, however, that scenes often contain many distinct small-scale objects, for which LOD can be adjusted independently [10] using traditional view-independent simplification techniques (e.g. <ref> [1, 3, 12, 15, 21] </ref>). In our opinion, the overhead of view-dependent LOD is only justified when necessary for large-scale continuous surfaces. In outdoor scenes, the primary instance is the terrain surface.
Reference: [13] <author> Gu eziec, A. </author> <title> Surface simplification with variable tolerance. </title> <booktitle> In Proceedings of the Second International Symposium on Medical Robotics and Computer Assisted Surgery (November 1995), </booktitle> <pages> pp. 132-139. </pages>
Reference-contexts: In this section we briefly discuss how the techniques of Section 5 can be generalized to work on arbitrary meshes. Approximation error. Several recent methods are able to track upper bounds on maximum geometric error during simplification of arbitrary meshes. Among these, at least two <ref> [3, 13] </ref> specifically consider sequences of edge collapse transformations. It would be easy to include these methods within the general VDPM framework. Other recent work [4] obtains bounds on parametric approximation error, which is appropriate in the presence of texture mapping. Hierarchical construction.
Reference: [14] <author> Heckbert, P., and Garland, M. </author> <title> Survey of polygonal surface simplification algorithms. In Multiresolution surface modeling (SIGGRAPH '97 Course notes #25). </title> <booktitle> ACM SIGGRAPH, </booktitle> <year> 1997. </year>
Reference-contexts: Scalability : To handle huge terrain models, we present a block-based recursive simplification process (Section 5.2). The result of this process is a hierarchical progressive mesh representation that permits runtime memory management. 2 RELATED WORK Height fields. Although there exist numerous multiresolution representations for height fields (see surveys in <ref> [7, 14] </ref>), only a subset support view-dependent LOD, and it is only recently that efficient on-line algorithms have been introduced that incrementally adapt LOD as the view parameters change. Taylor and Barrett [22] extract mesh approximations from rectangular quadtree hierarchies.
Reference: [15] <author> Hoppe, H. </author> <title> Progressive meshes. </title> <booktitle> Computer Graphics (SIGGRAPH '96 Proceedings) (1996), </booktitle> <pages> 99-108. </pages>
Reference-contexts: Many types of graphics scenes have complex geometric descriptions. It should be emphasized, however, that scenes often contain many distinct small-scale objects, for which LOD can be adjusted independently [10] using traditional view-independent simplification techniques (e.g. <ref> [1, 3, 12, 15, 21] </ref>). In our opinion, the overhead of view-dependent LOD is only justified when necessary for large-scale continuous surfaces. In outdoor scenes, the primary instance is the terrain surface. <p> Lilleskog [17] reports that the VDPM scheme uses 50-75% of the number of active triangles required by bintree schemes for the same screen-space error. 3 REVIEW OF VIEW-DEPENDENT PROGRESSIVE MESH FRAMEWORK As introduced in <ref> [15] </ref>, a progressive mesh (PM) representation describes an arbitrary triangle mesh M n as a coarse base mesh M 0 together with a sequence of n refinement transformations fvsplit 0 ; : : : ; vsplit n1 g called vertex splits (Figure 2) that progressively recover detail. <p> For height fields, an alternative approach requiring less memory is to start from a coarse approximation and progressively insert vertices [2, 11]. However, such greedy refinement methods generally yield inferior approximations (e.g. compare Figures 25-26 in [11] with Figure 8b in <ref> [15] </ref>). Our hierarchical strategy allows us to tackle the problem piecemeal with an accurate simplification-based method. * For even larger models, a pre-simplified mesh may still be too large to fit in main memory.
Reference: [16] <author> Hoppe, H. </author> <title> View-dependent refinement of progressive meshes. </title> <booktitle> Computer Graphics (SIGGRAPH '97 Proceedings) (1997), </booktitle> <pages> 189-198. </pages>
Reference-contexts: To be temporally continuous, the rendered mesh should not visibly pop from one frame to the next. Several schemes have been developed to address view-dependent LOD control, as summarized in Section 2. Among these, the view-dependent progressive mesh (VDPM) framework <ref> [16] </ref> represents an arbitrary triangle mesh as a hierarchy of geometrically optimized refinement transformations. Consequently, it is able to satisfy a given screen-space approximation tolerance with a simpler mesh a key advantage in reducing the geometry bottleneck. <p> Compared to quadtrees and bintrees, these methods allow more general distribution of vertices over the domain. However, the mesh connectivities are again constrained, in this case by the Delaunay triangulation criterion. Arbitrary meshes. Xia and Varshney [23] and Hoppe <ref> [16] </ref> show that multiresolution hierarchies for arbitrary meshes can be defined using a general refinement transformation called a vertex split (Figure 2). Whereas Xia and Varshney construct the hierarchy using an edge length heuristic, Hoppe constructs it from the geometrically optimized sequence in a progressive mesh representation (Section 3). <p> A PM representation for M n is obtained by edge collapse coarsening operation. vertex hierarchy. carefully simplifying it using n successive edge collapse transformations (Figure 2), and recording their inverses. As shown in the VDPM framework <ref> [16] </ref>, this same sequence of vsplit refinement transformations uniquely defines a vertex hierarchy (Figure 3), in which the root nodes correspond to the vertices of the base mesh M 0 , and the leaf nodes correspond to the fully detailed mesh M n . <p> To achieve view-dependent LOD, the active vertex front is traversed prior to rendering each frame, and each vertex may be either coarsened or refined based on view-dependent refinement criteria. In <ref> [16] </ref>, a vsplit refinement is performed if its neighborhood satisfies 3 criteria: (1) it intersects the view frustum, (2) its Gauss map is not strictly oriented away, and (3) its screen-projected deviation from M n exceeds a user-specified pixel tolerance t . <p> and conservative runtime evaluation of these criteria, each vertex in the hierarchy stores the following: a bounding-sphere radius r v , a normal vector ^ n v , a cone-of-normals angle ff v , and a deviation space encoded by a uniform component v and a directional component ffi v <ref> [16] </ref>. Geomorphs are demonstrated to be feasible within the VDPM framework, but their runtime creation is left as future work. <p> We let m denote the number of vertices in the active mesh M, so that M has approximately 2m faces. Typically, m t n. 4 EFFICIENT, TEMPORALLY SMOOTH VDPM 4.1 Output-sensitive data structures One limitation of the original VDPM scheme <ref> [16] </ref> is that all its data structures scale proportionally with the size n of the fully refined mesh M n . <p> Overall, the new data structures need 88n + 112m + 52g bytes, compared to 224n bytes in <ref> [16] </ref>. Because in practice the number of active faces is 2m 12,000 &lt; 65,536, the AVertex* and AFace* pointers in the static structure can be replaced by 16-bit indices. <p> Here is the modified pseudocode: function is invisible (v s ) return outside view frustum (v s ) or oriented away (v s ) // see <ref> [16] </ref> for their definitions procedure vsplit (v s ) : : : // code from Section 4.1 if not is invisible (v s ) v u :avertex:vgeom v t :avertex:vgeom vm v u :avertex:vmorph new VertexMorph vm:coarsening false vm:gtime gtime vm:vg refined vsplits [v s :i]:vu vgeom vm:vginc (vm:vg refined v <p> Fortunately, geomorph coarsening is required only when the viewer is moving backwards a more infrequent situation. Implementation of geomorph coarsening primarily involves changes to the function that adjusts the active vertex front: procedure adapt refinement () // compare with definition in <ref> [16] </ref> for each v 2 active vertices v s v:vertex if v s :i 0 and not is invisible (v s ) and screen error (v s ) &gt; t force vsplit (v s ) else if v s :parent and ecol legal (v s :parent) vmc (v:vmorph and v:vmorph:coarsening) if <p> We estimate this future location by extrapolation based on the current per-frame viewer velocity e. A more rigorous solution to account for changes in velocity would require altering the lifetimes of ongoing geomorphs, which seems expensive. The original refinement criterion from <ref> [16, 18] </ref> is: ffi v s kv ek &gt; ; where e is the viewpoint, v the mesh vertex, ^ n v its normal, ffi v its neighborhood's residual error, and = 2t tan ' 2 accounts for field-of-view angle ' and pixel tolerance t . <p> We obtain a constant frame rate of 30 frames/sec by regulating the screen-space error tolerance t to maintain approximately 12,000 active faces, and by amortizing the work of the procedure adapt refinement over 3 frames, as described in <ref> [16] </ref>. pixels. Over the whole flight, the screen-space tolerance t averages 1.7 pixel, and attains a maximum of 3.3 pixels. (Because of approximations in the computation of screen-space errors [16], the tolerance values t are unfortunately not upper bounds on screen-space error.) The fraction of vertices undergoing geomorph refinement and coarsening <p> maintain approximately 12,000 active faces, and by amortizing the work of the procedure adapt refinement over 3 frames, as described in <ref> [16] </ref>. pixels. Over the whole flight, the screen-space tolerance t averages 1.7 pixel, and attains a maximum of 3.3 pixels. (Because of approximations in the computation of screen-space errors [16], the tolerance values t are unfortunately not upper bounds on screen-space error.) The fraction of vertices undergoing geomorph refinement and coarsening averages 28.3% and 2.2% respectively.
Reference: [17] <author> Lilleskog, T. </author> <title> Continuous level of detail. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Norwegian University of Science and Technology, </institution> <month> February </month> <year> 1998. </year>
Reference-contexts: De Floriani et al. [6] introduce another related refinement hierarchy. When applied to the special case of height fields, these frameworks are able to satisfy a given approximation error using fewer faces due to the absence of connectivity constraints. Lilleskog <ref> [17] </ref> reports that the VDPM scheme uses 50-75% of the number of active triangles required by bintree schemes for the same screen-space error. 3 REVIEW OF VIEW-DEPENDENT PROGRESSIVE MESH FRAMEWORK As introduced in [15], a progressive mesh (PM) representation describes an arbitrary triangle mesh M n as a coarse base mesh
Reference: [18] <author> Lindstrom, P., Koller, D., Ribarsky, W., Hodges, L., Faust, N., and Turner, G. </author> <title> Real-time, continuous level of detail rendering of height fields. </title> <booktitle> Computer Graphics (SIGGRAPH '96 Proceedings) (1996), </booktitle> <pages> 109-118. </pages>
Reference-contexts: Taylor and Barrett [22] extract mesh approximations from rectangular quadtree hierarchies. Both Lindstrom et al. <ref> [18] </ref> and Duchaineau et al. [8] define bintree hierarchies, based on binary subdivision of right isosceles triangles, and demonstrate real-time view-dependent LOD. Because these representations are based on regular subdivision, they offer concise storage. Duchaineau et al. are able to create optimal approximating meshes through incremental changes at each frame. <p> We estimate this future location by extrapolation based on the current per-frame viewer velocity e. A more rigorous solution to account for changes in velocity would require altering the lifetimes of ongoing geomorphs, which seems expensive. The original refinement criterion from <ref> [16, 18] </ref> is: ffi v s kv ek &gt; ; where e is the viewpoint, v the mesh vertex, ^ n v its normal, ffi v its neighborhood's residual error, and = 2t tan ' 2 accounts for field-of-view angle ' and pixel tolerance t . <p> criterion by simplifying the function is invisible as follows: function is invisible (v s ) return outside view frustum (v s ) Since the texture image is mapped onto the terrain using a vertical projection, we measure surface deviation parametrically using strictly a vertical distance ffi v as done in <ref> [18] </ref>. If in addition, texture mapping is performed without Gouraud shading, the storage of vertex normals becomes unnecessary. <p> Specifically, we can use the thresholds to compute the maximum screen-projected error for each active block as in <ref> [18] </ref>. If this error exceeds the screen-space tolerance t , its child block refinements are loaded into memory and further tested. <p> window frames/ # faces pixel tol. t config. dimensions sec (2m) avg. max. ours R10K-MXI 710x520 30 12,000 1.7 3.3 R10K-MXI 710x520 60 5,000 3.5 8.3 Onyx-IR 710x520 30 16,000 1.3 2.3 Onyx-IR 710x520 60 8,000 2.1 4.5 R10K-MXI 1000x1000 30 11,000 2.9 5.2 Onyx-IR 1000x1000 30 6,000 n/a n/a <ref> [18] </ref> Onyx-RE2 640x480 20-30 4-9,000 2.0 2.0 Table 2: Runtime statistics and comparison with previous work. By modifying the regulation to instead maintain 5,000 active faces, we consistently achieve a target frame rate of 60 frames/sec. Similarly, 4,000 active faces yields a rate of 72 frames/sec.
Reference: [19] <author> Luebke, D., and Erikson, C. </author> <title> View-dependent simplification of arbitrary polygonal environments. </title> <booktitle> Computer Graphics (SIGGRAPH '97 Proceedings) (1997), </booktitle> <pages> 199-208. </pages>
Reference-contexts: In our opinion, the overhead of view-dependent LOD is only justified when necessary for large-scale continuous surfaces. In outdoor scenes, the primary instance is the terrain surface. In other domains, examples include the virtual flythroughs of organic structures and of CAD surfaces like ship hulls <ref> [19, 23] </ref>. In this paper we place the emphasis on terrain rendering because of its importance in the growing entertainment market. In the second half of the paper, we specialize the VDPM framework to the special case of terrains (i.e. height fields).
Reference: [20] <author> Montrym, J., Baum, D., Dignam, D., and Migdal, C. In-finiteReality: </author> <title> a real-time graphics system. </title> <booktitle> Computer Graphics (SIG-GRAPH '97 Proceedings) (1997), </booktitle> <pages> 293-302. </pages>
Reference-contexts: By partitioning the refinement database into a block hierarchy, we can exploit domain knowledge to explicitly pre-fetch refinement data before it is needed. * Just as the geometry data may be too large for memory, so may its associated texture image. Clip-maps <ref> [20] </ref> offer an elegant solution to this problem, but require hardware assistance currently available only on high-end systems. A more traditional approach is to partition the texture image into tiles that can be mip-mapped and paged independently.
Reference: [21] <author> Rossignac, J., and Borrel, P. </author> <title> Multi-resolution 3D approximations for rendering complex scenes. In Modeling in Computer Graphics, </title> <editor> B. Falcidieno and T. L. Kunii, Eds. </editor> <publisher> Springer-Verlag, </publisher> <year> 1993, </year> <pages> pp. 455-465. </pages>
Reference-contexts: Many types of graphics scenes have complex geometric descriptions. It should be emphasized, however, that scenes often contain many distinct small-scale objects, for which LOD can be adjusted independently [10] using traditional view-independent simplification techniques (e.g. <ref> [1, 3, 12, 15, 21] </ref>). In our opinion, the overhead of view-dependent LOD is only justified when necessary for large-scale continuous surfaces. In outdoor scenes, the primary instance is the terrain surface.
Reference: [22] <author> Taylor, D. C., and Barrett, W. A. </author> <title> An algorithm for continuous resolution polygonalizations of a discrete surface. </title> <booktitle> In Proceedings of Graphics Interface '94 (1994), </booktitle> <pages> pp. 33-42. </pages>
Reference-contexts: Although there exist numerous multiresolution representations for height fields (see surveys in [7, 14]), only a subset support view-dependent LOD, and it is only recently that efficient on-line algorithms have been introduced that incrementally adapt LOD as the view parameters change. Taylor and Barrett <ref> [22] </ref> extract mesh approximations from rectangular quadtree hierarchies. Both Lindstrom et al. [18] and Duchaineau et al. [8] define bintree hierarchies, based on binary subdivision of right isosceles triangles, and demonstrate real-time view-dependent LOD. Because these representations are based on regular subdivision, they offer concise storage.

References-found: 22

