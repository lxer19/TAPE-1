URL: ftp://ftp.cs.columbia.edu/reports/reports-1991/cucs-029-91.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1991.html
Root-URL: http://www.cs.columbia.edu
Title: An Architecture for Dynamic Reconfiguration in a Distributed Object-Based Programming Language "Dynamic Reconfiguration in an
Author: Brent Hailpern Gail E. Kaiser Brent Hailpern and Gail E. Kaiser 
Keyword: abstract types, distributed system, dynamic object update, portfolio management, soft real-time processing  
Note: Copyright 1991  An extended abstract of this paper titled  appeared in the Eleventh International Conference on Distributed Computing Systems, Arlington TX, May 1991, pp. 73-80.  
Address: Armonk, NY 10504 New York, NY 10027  
Affiliation: IBM Columbia University Old Orchard Road Department of Computer Science  
Pubnum: CUCS-029-91  
Email: bth@watson.ibm.com kaiser@cs.columbia.edu  
Phone: 914-765-6481 212-854-3856  
Date: 20 September 1991  
Abstract: Distributed applications ideally allow reconfiguration while the application is running, but changes are usually limited to adding new client and server processes and changing the bindings among such processes. In some application domains, such as real-time financial services, it is necessary to support finer grained reconfiguration at the level of entities smaller than processes, but for performance reasons it is desirable to avoid conventional approaches that require dynamic storage allocation. We present a scheme for special cases of fine-grained dynamic reconfiguration sufficient for our application domain and show how it can be used for practical changes. We introduce new language concepts to apply this scheme in the context of an object-based programming language that supports shared data in a distributed environment. Part of this work was completed at the IBM T.J. Watson Research Center while Dr. Hailpern was a Research Staff Member and Prof. Kaiser was an Academic Visitor. Kaiser is supported by National Science Foundation grants CCR-9000930 and CCR-8858029, by grants from AT&T, BNR, DEC and SRA, by the New York State Center for Advanced Technology in Computers and Information Systems and by the NSF Engineering Research Center for Telecommunications Research. 
Abstract-found: 1
Intro-found: 1
Reference: [Black 86] <author> Andrew Black, Norman Hutchinson, Eril Jul and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> Object-Oriented Programming Systems, Languages and Applications Conference, </booktitle> <pages> pages 78-86. </pages> <publisher> ACM, </publisher> <address> Portland OR, </address> <month> September, </month> <year> 1986. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: Every facet that contains this set of slots is a member of the breed, and thus is presumed to provide the defined service. Facets may contain more slots than those included in the breed. Thus a 3 breed corresponds to an abstract type in Emerald <ref> [Black 86] </ref> or a role in RPDE [Harrison 90]. <p> Related Work There is extensive related work on object models, which we describe in our previous paper introducing PROFIT . Since this paper concentrates on abstract interfaces (breeds) and dynamic reconfiguration, this 0 section addresses work related only to these topics. 9.1. Abstract Interfaces Emerald <ref> [Black 86] </ref> uses the notion of abstract types to provide the benefits of static type checking while retaining the flexibility and extensibility of untyped object-oriented languages. Abstract types are analogous to PROFIT breeds.
Reference: [Boult 90] <author> Terry Boult. </author> <title> Private Communication. </title> <year> 1990 </year>
Reference-contexts: Our programming model also supports other architectures on this spectrum, and is not specific to financial services. It is suitable for other applications, such as network management [Mazumdar 89], machine vision <ref> [Boult 90] </ref> and animation [Haeberli 88], with similar characteristics. We have developed a language, called PROFIT (PROgrammed FInancial Trading), based on this model.
Reference: [Ciancarini 90] <author> Paola Ciancarini. </author> <title> Coordination Languages for Open System Design. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 252-260. </pages> <address> New Orleans LA, </address> <month> March, </month> <year> 1990. </year>
Reference-contexts: It is suitable for other applications, such as network management [Mazumdar 89], machine vision [Boult 90] and animation [Haeberli 88], with similar characteristics. We have developed a language, called PROFIT (PROgrammed FInancial Trading), based on this model. PROFIT is a coordination language <ref> [Ciancarini 90] </ref> that extends the declarations and statements of some base computation language, such as C, with additional facilities to support distributed computation in the 2 context of rapidly changing shared data.
Reference: [Frieder 91] <author> Ophir Frieder and Mark E. Segal. </author> <title> On Dynamically Updating a Computer Program: From Concept to Prototype. </title> <journal> The Journal of Systems and Software 14(2) </journal> <pages> 111-128, </pages> <month> February, </month> <year> 1991. </year>
Reference-contexts: Polylith permits changes only when the system is in a reconfigurable state; since PROFIT only extends the existing system, a change can be made at any time except there can be only one change in progress at a time. Frieder and Segal <ref> [Frieder 91] </ref> describe a finer grained approach, where individual procedures may be replaced in a running program.
Reference: [Haeberli 88] <author> Paul E. Haeberli. ConMan: </author> <title> A Visual Programming Language for Interactive Graphics. </title> <booktitle> In SIGGRAPH '88, </booktitle> <pages> pages 103-111. </pages> <address> Atlanta GA, </address> <month> August, </month> <year> 1988. </year> <journal> Special issue of Computer Graphics, </journal> <volume> 22(4), </volume> <month> August </month> <year> 1988. </year>
Reference-contexts: Our programming model also supports other architectures on this spectrum, and is not specific to financial services. It is suitable for other applications, such as network management [Mazumdar 89], machine vision [Boult 90] and animation <ref> [Haeberli 88] </ref>, with similar characteristics. We have developed a language, called PROFIT (PROgrammed FInancial Trading), based on this model.
Reference: [Hailpern 90] <author> Brent Hailpern and Harold Ossher. </author> <title> Extending objects to provide multiple interfaces and access control. </title> <journal> IEEE Transactions on Software Engineering 16(11) </journal> <pages> 1247-1257, </pages> <month> November, </month> <year> 1990. </year>
Reference-contexts: The two-dimensional organization of RPDE allows it to support both subtyping and 3 code-sharing inheritance. RPDE does not support sharing between objects or concurrent programming. Hailpern and Ossher <ref> [Hailpern 90] </ref> have extended the notion of abstract type (breed) to a ``view'' that includes interface specification, the set of objects that can provide a service (servers), and a set of objects that can consume the service (clients).
Reference: [Harrison 87] <author> William Harrison. </author> <title> 3 RPDE : A framework for integrating tool fragments. </title> <booktitle> IEEE Software 4(6) </booktitle> <pages> 46-56, </pages> <month> November, </month> <year> 1987. </year>
Reference-contexts: Such a parameter is passed by reference, but at the time of the call it is relocated to the destination site. In contrast, PROFIT does not support object migration; PROFIT parameters are passed by value and facets cannot themselves be parameters. 3 RPDE <ref> [Harrison 87] </ref> is not a programming language, but rather an open-ended, structural framework for integrating tools that manipulate objects. A tool, in general, can perform many functions, and can manipulate objects of a variety of types.
Reference: [Harrison 90] <author> William Harrison and Harold Ossher. </author> <title> Checking Evolving Interfaces in the Presence of Persistent Objects. </title> <type> Technical Report RC 15520, </type> <institution> IBM Research Division, </institution> <month> February, </month> <year> 1990. </year> <month> 30 </month>
Reference-contexts: Facets may contain more slots than those included in the breed. Thus a 3 breed corresponds to an abstract type in Emerald [Black 86] or a role in RPDE <ref> [Harrison 90] </ref>.
Reference: [Jones 85] <author> Michael B. Jones, Richard F. Rashid and Mary R. Thompson. Matchmaker: </author> <title> An Interface Specification Language for Distributed Processing. </title> <booktitle> In 12th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 225-235. </pages> <address> New Orleans LA, </address> <month> January, </month> <year> 1985. </year>
Reference-contexts: Thus the facility comparable to stalls/occupants is implicit, and there is nothing comparable to our pens, herds or registries. The Matchmaker system <ref> [Jones 85] </ref> is similar to Mercury. It provides an interface specification language for heterogeneous distributed systems, but does not seem to support dynamic reconfiguration. Hermes [Strom 91] is another system that supports distributed programs with well-defined interfaces between processes.
Reference: [Kaiser 90] <author> Gail E. Kaiser and Brent Hailpern. </author> <title> An Object Model for Shared Data. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 135-144. </pages> <address> New Orleans LA, </address> <month> March, </month> <year> 1990. </year>
Reference-contexts: What we have in mind is essentially soft real-time processing, where it is not mandatory for every portfolio to be informed of every possibly trivial price change, but where the quality of service is balanced against the computation and communication costs of providing that service. In a previous paper <ref> [Kaiser 90] </ref>, we introduced a distributed object-based programming model that addresses these problems. This programming model supports an application architecture where price changes are monitored by daemons operating on behalf of individual portfolio managers.
Reference: [Kaiser 91] <author> Gail E. Kaiser and Brent Hailpern. </author> <title> An Object-Based Programming Model for Shared Data. </title> <journal> ACM Transactions on Programming Languages and Systems , 1991. </journal> <note> In press. Available as IBM Research Report RC 16442 and Columbia University Department of Computer Science CUCS-046-90, revised December 1990. </note>
Reference-contexts: Relying on an existing computation language allows us to focus on the innovative aspects of our model. We briefly sketch the primary PROFIT language concepts below. A more complete treatment, with 0 several financial examples, may be found in another paper <ref> [Kaiser 91] </ref>. 2.1. Facets A facet has a unique name and a set of named slots, each of which may contain either a data value or procedure code.
Reference: [Kramer 89] <author> Jeff Magee, Jeff Kramer, and Morris Sloman. </author> <title> Constructing Distributed Systems in Conic. </title> <journal> IEEE Transactions on Software Engineering 15(6) </journal> <pages> 663-675, </pages> <month> June, </month> <year> 1989. </year>
Reference-contexts: New processes can also be added using the create of statement, but only from within an existing process. Thus it is not possible to add new facilities that were not included in some sense in the original program. 27 The Conic <ref> [Kramer 89] </ref> is also port-based. Task modules, analogous to facets, contain code, data, entry ports and exit ports. These task modules are configuration independent: there is no direct naming of other modules, just sends and receives to ports.
Reference: [Krishnan 91] <editor> Iyengar Krishnan and Wolfgang Zimmer (editor). </editor> <booktitle> IFIP TC6/WG6.6 2nd International Symposium on Integrated Network Management. </booktitle> <publisher> North-Holland, </publisher> <address> Washington DC, </address> <year> 1991. </year>
Reference-contexts: As networked systems get larger and faster, it has become necessary to automate these processes, so new management and control approaches are being developed to automatically change configurations, as well as to detect and correct performance bottlenecks and failures <ref> [Krishnan 91] </ref>.
Reference: [Liskov 88] <author> Barbara Liskov, Toby Bloom, David Gifford, Robert Scheifler and William Weihl. </author> <title> Communication in the Mercury System. </title> <editor> In Bruce D. Shriver (editor), </editor> <booktitle> 21st Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 178-187. </pages> <publisher> IEEE Computer Society, </publisher> <address> Kona HI, </address> <month> January, </month> <year> 1988. </year>
Reference-contexts: SOS provides a mechanism for certain cases of dynamic reconfiguration in the form of dynamic classes, where all member functions are called via a dynamic table, but requires dynamic linking capabilities avoided by PROFIT. The Mercury system <ref> [Liskov 88] </ref> provides a general interprocess communication mechanism for heterogeneous systems. Servers are written independently of whether their application clients choose communication protocols to provide low latency or high throughput.
Reference: [Mazumdar 89] <author> Subrata Mazumdar and Aurel A. Lazar. </author> <title> Knowledge-Based Monitoring of Integrated Networks. </title> <editor> In Branislav Meandzija and Jil Westcott (editors), </editor> <booktitle> IFIP TC 6/WG 6.6 Symposium on Integrated Network Management, </booktitle> <pages> pages 235-243. </pages> <publisher> North-Holland, </publisher> <address> Boston MA, </address> <month> May, </month> <year> 1989. </year>
Reference-contexts: This approach falls in the middle of the spectrum from polling to active values, and combines the advantages of both extremes. Our programming model also supports other architectures on this spectrum, and is not specific to financial services. It is suitable for other applications, such as network management <ref> [Mazumdar 89] </ref>, machine vision [Boult 90] and animation [Haeberli 88], with similar characteristics. We have developed a language, called PROFIT (PROgrammed FInancial Trading), based on this model.
Reference: [Patel 91a] <author> Tushar M. Patel and Gail E. Kaiser. </author> <title> The SPLENDORS Real Time Portfolio Management System. </title> <booktitle> In 1st International Conference on Artificial Intelligence Applications on Wall Street. </booktitle> <address> New York NY, </address> <month> October, </month> <year> 1991. </year> <note> In press. </note> <institution> Available as Columbia University Department of Computer Science, CUCS-011-91, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Threads are supported using the Sun lightweight processes package (lwp). The parser consists of 4375 lines of C, 247 lines of lex rules and 645 lines of yacc rules. The run-time support consists of an additional 1366 lines of C. 24 One reasonably large application program, called SPLENDORS <ref> [Patel 91a] </ref>, has recently been completed. SPLENDORS includes 551 lines of PROFIT coordination code and 6148 lines of C computation code 0 (1541 lines of which are for the user interface).
Reference: [Patel 91b] <author> Tushar M. Patel. </author> <title> Real-time Portfolio Management and Automatic Extensions. </title> <type> Master's thesis, </type> <institution> Columbia University, </institution> <month> October, </month> <year> 1991. </year>
Reference-contexts: SPLENDORS uses a different facility for dynamic reconfiguration than described here <ref> [Patel 91b] </ref>. Since the PROFIT implementation supports only a single process, it was not possible to use our ranchhouses 0 scheme. Instead, an interpretive approach was followed. The programmer provides a library of generic price and daemon facets, with two versions of each interpreted and compiled.
Reference: [Peinl 88] <author> Peter Peinl, Andrea Reuter and Harald Sammer. </author> <title> High Contention in a Stock Trading Database: A Case Study. </title> <booktitle> In ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 260-268. </pages> <address> Chicago IL, </address> <month> June, </month> <year> 1988. </year> <journal> Special issue of SIGMOD Record, </journal> <volume> 17(3), </volume> <month> September </month> <year> 1988. </year>
Reference-contexts: These problems have been articulated by other researchers (e.g., <ref> [Peinl 88] </ref>), but not solved. An on-line stock trading program might consist of a shared ``prices database'' and a number of analyst workstations that execute portfolio management programs.
Reference: [Purtilo 91] <author> James M. Purtilo and Christine R. Hofmeister. </author> <title> Dynamic Reconfiguration of Distributed Programs. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 560-571. </pages> <month> May, </month> <year> 1991. </year> <month> 31 </month>
Reference-contexts: This object selection language is navigational, describing which objects are linked through which ports to which other objects, rather than associative as in PROFIT breeds and queries. The Polylith distributed programming system <ref> [Purtilo 91] </ref> provides facilities for dynamic reconfiguration of program modules. It provides reliable techniques for programmers to change module implementations, system topology (i.e., the bindings between module interfaces), and system geometry (i.e., the mapping of the structure onto a distributed architecture).
Reference: [Shapiro 89] <author> Marc Shapiro, Philippe Gautron and Laurence Mosseri. </author> <title> Persistence and Migration for C++ Objects. </title> <editor> In Stephen Cook (editor), </editor> <booktitle> 3rd European Conference on Object-Oriented Programming, </booktitle> <pages> pages 191-204. </pages> <publisher> Cambridge University Press, </publisher> <address> Nottingham, UK, </address> <month> July, </month> <year> 1989. </year>
Reference-contexts: As networked systems get larger and faster, it has become necessary to automate these processes, so new management and control approaches are being developed to automatically change configurations, as well as to detect and correct performance bottlenecks and failures [Krishnan 91]. The SOS operating system <ref> [Shapiro 89] </ref> is similar to PROFIT in that multiple objects (similar to our facets) can be combined into a group (similar to our notion of object), with easy communication among the objects in the group, even though the objects reside in multiple contexts (similar to our processes).
Reference: [Strom 91] <author> Robert E. Strom, David F. Bacon, Arthur P. Goldberg, Andy Lowry, Daniel M. Yellin and Shaula Alexander Yemini. </author> <title> Hermes A Language for Distributed Computing. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs NJ, </address> <year> 1991. </year>
Reference-contexts: Thus the facility comparable to stalls/occupants is implicit, and there is nothing comparable to our pens, herds or registries. The Matchmaker system [Jones 85] is similar to Mercury. It provides an interface specification language for heterogeneous distributed systems, but does not seem to support dynamic reconfiguration. Hermes <ref> [Strom 91] </ref> is another system that supports distributed programs with well-defined interfaces between processes. New ports can be added to an executing process and existing port connections can be changed, by statements executed from within the existing Hermes code. This is analogous to PROFIT's facilities for filling stalls and pens.
Reference: [Sun 87] <author> SunOS Reference Manual Section 3L: </author> <title> Lightweight Processes Library Sun Microsystems, </title> <publisher> Inc., </publisher> <year> 1987. </year>
Reference-contexts: The only physical representation of objects are their binding and entry tables, which are replicated in every process containing one or more of their facets. PROFIT relies on medium-weight threads similar to Sun's lwp package <ref> [Sun 87] </ref>. Along with a simple 0 locus of control, a thread maintains context (that is, a stack) between nested calls, thereby permitting recursion. Each call in a facet queue is represented by a thread, which provides the context of the call.
Reference: [Tanenbaum 87] <author> Andrew S. Tanenbaum. </author> <title> Operating Systems Design and Implementation. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs NJ, </address> <year> 1987. </year>
Reference-contexts: Throughout our work on PROFIT , we deliberately avoided introducing pointers 0 to facets, or other kinds of facet identifiers. Such identifiers are ugly in principle because without hardware or operating system support (e.g., capabilities <ref> [Tanenbaum 87] </ref>), programs can manipulate them in arbitrary ways, forge them, and access the associated facets in violation of integrity constraints, e.g., one could extract the tenth through thirteenth words offset from the beginning of a facet.
Reference: [Ungar 87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> Object-Oriented Programming Systems, Languages and Applications Conference Proceedings, </booktitle> <pages> pages 227-242. </pages> <publisher> ACM Press, </publisher> <address> Orlando FL, </address> <month> October, </month> <year> 1987. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 22(12), </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: Data slots may be reassigned during execution to new values, but procedure slots cannot be changed. This structure is similar to objects in Self <ref> [Ungar 87] </ref>.
Reference: [Wei 91] <institution> Jiawang Wei and Markus Endler. </institution>
Reference-contexts: As a result, dynamic reconfiguration in Conic cannot affect the internals of a group module: it is compiled into only one logical node. PROFIT can, however, extend objects with new facets by including them in a new process, via a new room. Wei and Endler <ref> [Wei 91] </ref> describe a similar port-based facility with three kinds of modules: definition modules (data type and procedure declarations), program modules (code and port declarations), and configuration modules (which map ports to ports and include ``change script'' specifications).
References-found: 25

