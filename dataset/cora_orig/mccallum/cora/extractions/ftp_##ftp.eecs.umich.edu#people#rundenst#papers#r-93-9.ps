URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-93-9.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Title: Implementation Experience with Building an Object-Oriented View Management System  
Author: Harumi A. Kuno and Elke A. Rundensteiner 
Keyword: Schema Integration, Meta Schema, View Definition, Data Independence, Object-Oriented Databases, GemStone, Smalltalk.  
Address: 1301 Beal Avenue Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elect. Engineering and Computer Science Software Systems Research Laboratory The University of Michigan,  
Email: e-mail: kuno@eecs.umich.edu, rundenst@eecs.umich.edu  
Phone: fax: (313) 763-1503 phone: (313) 936-2971  
Date: August, 1993  
Abstract: Although views have been found to be important mechanisms for database systems, currently no commercially available OODBMS supports view management tools. There are many challenging problems related to view management that must be adressed in the context of object-oriented models: what features are required to support a view system, how to provide updatable views, and how to utilize the complexity of the object-oriented data model for view definition (such as behavioral customization, view hierarchy manipulation, and incorporating virtual classes into a consistent global schema). We solve all of these problems in our implementation of the MultiView view management system, which supports updatable views on top of the GemStone OODBMS. The resulting system preserves the functionality of the underlying commercial OODBMS while adding view mechanisms and the features needed to support the view system. Our implementation is general purpose we provide generic classes defined in Smalltalk that can easily be ported to other OODBMS systems. fl This work was supported in part by the NSF RIA grant #IRI-9309076 and the University of Michigan Faculty Award Program. We are also grateful for support from the 1993 NASA Graduate Student Researchers Program. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: The rows of the table refer to the different view approaches being compared, generally listing the first view-related paper by the respective first authors. The first row is our MultiView approach [13] [14] [16] [15]; row two corresponds to the view approach proposed by Abiteboul and Bonner <ref> [1] </ref>; row three represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's three step approach [20]; row seven represents the COCOON project by Scholl, Schek, Laasch, <p> However, in most other systems, such as [22], the integration is manual, rather than automatic. Other approaches do not generate a global schema, but instead import individual classes into various view class hierarchies <ref> [1] </ref>, or support only partial classification [17] [3] [9] [11] (as discussed in Section 3). 15 16 The entries in this column indicate the degree to which virtual classes are integrated into the global schema. * MultiView is the only system of those listed which features the upwards relocation of method <p> Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. In fact, most researchers have focused on how query languages can be used to support the definition of virtual classes <ref> [9, 17, 22, 1, 14, 3] </ref>. In their discussion of FUGUE, Heiler and Zdonik [9] propose that the query language of FUGUE can be used for the specification of object-oriented virtual classes. They do not investigate either the issues of classification nor the re-use of methods. <p> On the contrary, they require the view definer to manually enter the methods to be associated with a newly derived class, rather than deriving them automatically whenever possible, as done in our system. Abiteboul and Bonner <ref> [1] </ref> mention the integration of select classes into a view schema, but choose to enable selective upward versus downwards inheritance rather than creating intermediate classes and propagating methods upwards.
Reference: [2] <author> T. Atwood, R. Cattell, J. Duhl, G. Ferran, and D. Wade. </author> <title> The odmg object model. </title> <journal> Journal of Object Oriented Programming, </journal> <pages> pages 64-69, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: However, MultiView adapts GemStone's native data model to concur more closely with the ODMG data model <ref> [2] </ref> and to incorporate features necessary for the support of updatable views.
Reference: [3] <author> E. Bertino. </author> <title> A view mechanism for object-oriented databases. </title> <booktitle> In 3rd International Conference on Extending Database Technology, </booktitle> <pages> pages 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: require the user to specify explicitly the relationship between a virtual class and 4 existing base classes [22]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [17]; or (3) simply relate a virtual class with its source class via a derived-from relationship <ref> [3] </ref>, (4) or with the root of the schema [9, 11]. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship. <p> The first row is our MultiView approach [13] [14] [16] [15]; row two corresponds to the view approach proposed by Abiteboul and Bonner [1]; row three represents Bertino's view mechanism <ref> [3] </ref>; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's three step approach [20]; row seven represents the COCOON project by Scholl, Schek, Laasch, and Tresch [18] [17]; and row eight <p> However, in most other systems, such as [22], the integration is manual, rather than automatic. Other approaches do not generate a global schema, but instead import individual classes into various view class hierarchies [1], or support only partial classification [17] <ref> [3] </ref> [9] [11] (as discussed in Section 3). 15 16 The entries in this column indicate the degree to which virtual classes are integrated into the global schema. * MultiView is the only system of those listed which features the upwards relocation of method code. <p> Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. In fact, most researchers have focused on how query languages can be used to support the definition of virtual classes <ref> [9, 17, 22, 1, 14, 3] </ref>. In their discussion of FUGUE, Heiler and Zdonik [9] propose that the query language of FUGUE can be used for the specification of object-oriented virtual classes. They do not investigate either the issues of classification nor the re-use of methods.
Reference: [4] <author> R. J. Brachman and H. J. Levesque. </author> <title> The tractability of subsumption in frame-based description languages. </title> <booktitle> In American Association for Artificial Intelligence Conference, </booktitle> <pages> pages 34-37, </pages> <year> 1984. </year> <month> 18 </month>
Reference: [5] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. </title> <booktitle> In Semantics of Data Types Lecture Notes in Computer Science, </booktitle> <volume> 173, </volume> <pages> pages 51-67. </pages> <publisher> Springer, </publisher> <year> 1984. </year>
Reference: [6] <author> R. G. G. Cattell. </author> <title> Object Data Management: Object-Oriented and Extended Relational Database Systems. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: We incorporate extent directly within class definition in MultiView (as is done in numerous other approaches, <ref> [6] </ref> and is necessary for the extent of virtual classes to be calculated). Base classes are hence represented by a subclass of M ultiV iewClass with the added instance variable of Extent containing the set of instances belonging to the class.
Reference: [7] <author> C. J. Date. </author> <title> An Introduction to Database Systems, volume I. </title> <booktitle> Addison-Wesley Systems Programming Series, </booktitle> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: It is an unresolved issue at this point whether object generating view definition languages can automatically solve the view update problem. * Unlike relational databases, in which most views are not updatable <ref> [7] </ref>, object-oriented views are potentially updatable. Two reasons why object-oriented systems potentially permit updatable views are that objects have unique, system-generated object identifiers, and class-specific methods are associated with each object.
Reference: [8] <author> J. P. Gilbert and L. Bic. </author> <title> An object-oriented data model for semantic relativism. </title> <booktitle> In ECOOP, </booktitle> <year> 1989. </year>
Reference-contexts: The first row is our MultiView approach [13] [14] [16] [15]; row two corresponds to the view approach proposed by Abiteboul and Bonner [1]; row three represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic <ref> [8] </ref>; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's three step approach [20]; row seven represents the COCOON project by Scholl, Schek, Laasch, and Tresch [18] [17]; and row eight corresponds to the schema virtualization work done by Tanaka, Yoshikawa, and Ishihara <p> This column indicates whether or not the system offers updatable views. * Some systems (such as <ref> [8] </ref> and [20]) associate multiple protocols (interfaces) with each class rather than having objects belong to multiple (possibly virtual) classes. We call this alternative to the traditional multiple inheritance data model multiple protocols. <p> There are also some proposals on supporting multiple protocols (interfaces) for each class <ref> [8, 20] </ref>; such an approach would require however considerable extensions to the typical object model. To the best of our knowledge, no implementation of this approach has been attempted as of now.
Reference: [9] <author> S. Heiler and S. B. Zdonik. </author> <title> Object views: Extending the vision. </title> <booktitle> IEEE Data Engineering Conference, </booktitle> <month> February </month> <year> 1990. </year>
Reference-contexts: a virtual class and 4 existing base classes [22]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [17]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema <ref> [9, 11] </ref>. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship. <p> row is our MultiView approach [13] [14] [16] [15]; row two corresponds to the view approach proposed by Abiteboul and Bonner [1]; row three represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model <ref> [9] </ref>; row six refers to Shilling and Sweeney's three step approach [20]; row seven represents the COCOON project by Scholl, Schek, Laasch, and Tresch [18] [17]; and row eight corresponds to the schema virtualization work done by Tanaka, Yoshikawa, and Ishihara [22]. <p> However, in most other systems, such as [22], the integration is manual, rather than automatic. Other approaches do not generate a global schema, but instead import individual classes into various view class hierarchies [1], or support only partial classification [17] [3] <ref> [9] </ref> [11] (as discussed in Section 3). 15 16 The entries in this column indicate the degree to which virtual classes are integrated into the global schema. * MultiView is the only system of those listed which features the upwards relocation of method code. <p> Whether or not these collections are composed into view schemata supporting their own inheritance hierarchy is an open issue. For example, <ref> [9] </ref> consider views to be simple collections of virtual classes, while others consider the views to be sub-schema graphs. * Those systems that support the definition of view schemata in addition to virtual class creation should provide view schema closure checking to ensure that classes referenced by the classes participating in <p> Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. In fact, most researchers have focused on how query languages can be used to support the definition of virtual classes <ref> [9, 17, 22, 1, 14, 3] </ref>. In their discussion of FUGUE, Heiler and Zdonik [9] propose that the query language of FUGUE can be used for the specification of object-oriented virtual classes. They do not investigate either the issues of classification nor the re-use of methods. <p> In fact, most researchers have focused on how query languages can be used to support the definition of virtual classes [9, 17, 22, 1, 14, 3]. In their discussion of FUGUE, Heiler and Zdonik <ref> [9] </ref> propose that the query language of FUGUE can be used for the specification of object-oriented virtual classes. They do not investigate either the issues of classification nor the re-use of methods.
Reference: [10] <author> H. J. Kim. </author> <title> Issues in Object Oriented Database Systems. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: Tanaka et al. [22] propose that view schemata be defined by manually manipulating the edges in the global schema graph. <ref> [10] </ref> also uses DAG rearrangement for view schema definition. Such DAG manipulation approaches must deal with the issues of (1) possibly introducing inconsistencies into the view schema due to human error and of (2) unintentionally modifying the semantics of a virtual class due to side effects of graph manipulation.
Reference: [11] <author> W. Kim. </author> <title> A model of queries in object-oriented databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 423-432, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: a virtual class and 4 existing base classes [22]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [17]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema <ref> [9, 11] </ref>. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship. <p> However, in most other systems, such as [22], the integration is manual, rather than automatic. Other approaches do not generate a global schema, but instead import individual classes into various view class hierarchies [1], or support only partial classification [17] [3] [9] <ref> [11] </ref> (as discussed in Section 3). 15 16 The entries in this column indicate the degree to which virtual classes are integrated into the global schema. * MultiView is the only system of those listed which features the upwards relocation of method code.
Reference: [12] <author> M. M. A. Morsi, S. B. Navathe, and H. J. Kim. </author> <title> A schema management and prototyping interface for an object-oriented database environment. </title> <editor> In F. Van Assche, B. Moulin, and C. Rolland, editors, </editor> <booktitle> Object Oriented Approach in Information Systems, </booktitle> <pages> pages 157-180. </pages> <publisher> Elsevier Science Publishers B. V. (North Holland), </publisher> <year> 1991. </year>
Reference-contexts: This feature of MultiView is a significant difference to other approaches. For instance, in <ref> [12] </ref>, the specification of a virtual class (both type and extent) has to be dynamically recomputed for each view schema it is inserted in, since for example the addition of an is-a relationship may add new inherited attributes to the virtual type. <p> Such DAG manipulation approaches must deal with the issues of (1) possibly introducing inconsistencies into the view schema due to human error and of (2) unintentionally modifying the semantics of a virtual class due to side effects of graph manipulation. For example, in <ref> [12] </ref>, the addition of an is-a relationship may add new inherited attributes to the virtual type, so the specification of a virtual class (both type and extent) is dynamically recomputed for each view schema in which it is inserted.
Reference: [13] <author> E. A. Rundensteiner. </author> <title> A class integration algorithm and its application for supporting consistent object views. </title> <type> Technical Report 92-50, </type> <institution> University of California, Irvine, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: These problems and their solutions are described in more detail in <ref> [13] </ref> and [14]. Inheritance mismatch is a problem of the type hierarchy which occurs when a new virtual class is created for which there is no existent correct place in the global hierarchy, as illustrated in the bottom half of Figure 2. <p> As described earlier, if two classes C 1 and C 2 share some common property then they both must 5 have inherited if from some lowest common superclass (LCS) in the class lattice for which this common property is defined. <ref> [13] </ref> presents an efficient algorithm for creating a minimal, yet sufficient, set of these intermediate classes. This approach supports true upwards inheritance of method code for both base and virtual classes. <p> The rows of the table refer to the different view approaches being compared, generally listing the first view-related paper by the respective first authors. The first row is our MultiView approach <ref> [13] </ref> [14] [16] [15]; row two corresponds to the view approach proposed by Abiteboul and Bonner [1]; row three represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling
Reference: [14] <author> E. A. Rundensteiner. </author> <title> Multiview: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In 18th VLDB Conference, </booktitle> <year> 1992. </year>
Reference-contexts: These problems and their solutions are described in more detail in [13] and <ref> [14] </ref>. Inheritance mismatch is a problem of the type hierarchy which occurs when a new virtual class is created for which there is no existent correct place in the global hierarchy, as illustrated in the bottom half of Figure 2. <p> The algorithm then determines a set VE of is-a edges among classes in VV such that VS = (VV,VE) is a valid view schema <ref> [14] </ref>. <p> The rows of the table refer to the different view approaches being compared, generally listing the first view-related paper by the respective first authors. The first row is our MultiView approach [13] <ref> [14] </ref> [16] [15]; row two corresponds to the view approach proposed by Abiteboul and Bonner [1]; row three represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and <p> Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. In fact, most researchers have focused on how query languages can be used to support the definition of virtual classes <ref> [9, 17, 22, 1, 14, 3] </ref>. In their discussion of FUGUE, Heiler and Zdonik [9] propose that the query language of FUGUE can be used for the specification of object-oriented virtual classes. They do not investigate either the issues of classification nor the re-use of methods.
Reference: [15] <author> E. A. Rundensteiner. </author> <title> Design tool integration using object-oriented database views. </title> <booktitle> In IEEE Int. Conf. on Computer-Aided Design, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: The rows of the table refer to the different view approaches being compared, generally listing the first view-related paper by the respective first authors. The first row is our MultiView approach [13] [14] [16] <ref> [15] </ref>; row two corresponds to the view approach proposed by Abiteboul and Bonner [1]; row three represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's three
Reference: [16] <author> E. A. Rundensteiner. </author> <title> Tools for view generation in oodbs. </title> <booktitle> In ACM 2nd Int. Conf on Information and Knowledge Management (CIKM'93), </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: The algorithm then determines a set VE of is-a edges among classes in VV such that VS = (VV,VE) is a valid view schema [14]. We can apply standard graph algorithms to solve the view generation problem as we proposed elsewhere in <ref> [16] </ref>. 4 View Management Modeling Requirements The MultiView data model is similar to the OPAL model used by GemStone, and is fully object-oriented, supporting classes, class methods, object instances, object identifiers, complete encapsulation 4 , and many other features [19]. <p> The rows of the table refer to the different view approaches being compared, generally listing the first view-related paper by the respective first authors. The first row is our MultiView approach [13] [14] <ref> [16] </ref> [15]; row two corresponds to the view approach proposed by Abiteboul and Bonner [1]; row three represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's
Reference: [17] <author> M. H. Scholl, C. Laasch, and M. Tresch. </author> <title> Updatable views in object-oriented databases. </title> <booktitle> In Proceedings of the Second DOOD Conference, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: Existing approaches in the literature either: (1) require the user to specify explicitly the relationship between a virtual class and 4 existing base classes [22]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship <ref> [17] </ref>; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema [9, 11]. <p> MultiView adopts all of these recommendations. In addition, MultiView also extends the GemStone data model to incorporate features necessary for the support of updatable views, such as dynamic reclassification, multiple inheritance, multiple class membership, and multiple type instantiation <ref> [17] </ref>. <p> Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's three step approach [20]; row seven represents the COCOON project by Scholl, Schek, Laasch, and Tresch [18] <ref> [17] </ref>; and row eight corresponds to the schema virtualization work done by Tanaka, Yoshikawa, and Ishihara [22]. <p> Two reasons why object-oriented systems potentially permit updatable views are that objects have unique, system-generated object identifiers, and class-specific methods are associated with each object. For example, because the COCOON system [18] <ref> [17] </ref> is object preserving, operations performed upon objects in views automatically take effect upon the actual objects on which the virtual objects are based, and similarly, updates on base objects are reflected in views. <p> However, in most other systems, such as [22], the integration is manual, rather than automatic. Other approaches do not generate a global schema, but instead import individual classes into various view class hierarchies [1], or support only partial classification <ref> [17] </ref> [3] [9] [11] (as discussed in Section 3). 15 16 The entries in this column indicate the degree to which virtual classes are integrated into the global schema. * MultiView is the only system of those listed which features the upwards relocation of method code. <p> Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. In fact, most researchers have focused on how query languages can be used to support the definition of virtual classes <ref> [9, 17, 22, 1, 14, 3] </ref>. In their discussion of FUGUE, Heiler and Zdonik [9] propose that the query language of FUGUE can be used for the specification of object-oriented virtual classes. They do not investigate either the issues of classification nor the re-use of methods. <p> To the best of our knowledge, an implementation of their approach using the O2 system is planned, but is still in progress. Scholl and Schek's [18] work on views comes closest to our work; they have also developed a prototype of their approach <ref> [17] </ref>. They suggest use of an object-preserving subset of their algebra to define virtual classes and thus achieve updatable views.
Reference: [18] <author> M. H. Scholl and H. J. Schek. </author> <title> Survey of the cocoon project. </title> <institution> Objektbanken fur Experten, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's three step approach [20]; row seven represents the COCOON project by Scholl, Schek, Laasch, and Tresch <ref> [18] </ref> [17]; and row eight corresponds to the schema virtualization work done by Tanaka, Yoshikawa, and Ishihara [22]. The columns of Figure 9 represent the following criteria for comparing view management systems: * The terms object preserving (along with value generating and object generating), as used by [18], refer to the <p> Laasch, and Tresch <ref> [18] </ref> [17]; and row eight corresponds to the schema virtualization work done by Tanaka, Yoshikawa, and Ishihara [22]. The columns of Figure 9 represent the following criteria for comparing view management systems: * The terms object preserving (along with value generating and object generating), as used by [18], refer to the closure property of query models whether queries result in a collection of objects identical to the original database objects, a set of data values abstracted from the database objects, or a collection of newly created objects. <p> Two reasons why object-oriented systems potentially permit updatable views are that objects have unique, system-generated object identifiers, and class-specific methods are associated with each object. For example, because the COCOON system <ref> [18] </ref> [17] is object preserving, operations performed upon objects in views automatically take effect upon the actual objects on which the virtual objects are based, and similarly, updates on base objects are reflected in views. <p> Some of these systems are based upon existing or commercial systems, while others are designed from scratch. For example, Scholl et al <ref> [18] </ref> have developed their own system, COCOON, while Tanaka et al [22] base their object model upon Smalltalk. * As far as we know, no commercial system provides a general view management system for their object-oriented database system, and most of the systems proposed in academia have not yet been implemented. <p> To the best of our knowledge, an implementation of their approach using the O2 system is planned, but is still in progress. Scholl and Schek's <ref> [18] </ref> work on views comes closest to our work; they have also developed a prototype of their approach [17]. They suggest use of an object-preserving subset of their algebra to define virtual classes and thus achieve updatable views.
Reference: [19] <author> Servio Corporation. </author> <note> Programming in OPAL, version 2.5 edition, </note> <month> August </month> <year> 1991. </year>
Reference-contexts: to solve the view generation problem as we proposed elsewhere in [16]. 4 View Management Modeling Requirements The MultiView data model is similar to the OPAL model used by GemStone, and is fully object-oriented, supporting classes, class methods, object instances, object identifiers, complete encapsulation 4 , and many other features <ref> [19] </ref>. However, MultiView adapts GemStone's native data model to concur more closely with the ODMG data model [2] and to incorporate features necessary for the support of updatable views.
Reference: [20] <author> J. Shilling and P. Sweeney. </author> <title> Three steps to views: Extending the object-oriented paradigm. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 353 - 361, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: corresponds to the view approach proposed by Abiteboul and Bonner [1]; row three represents Bertino's view mechanism [3]; row four covers the Polyview system developed by Gilbert and Bic [8]; row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's three step approach <ref> [20] </ref>; row seven represents the COCOON project by Scholl, Schek, Laasch, and Tresch [18] [17]; and row eight corresponds to the schema virtualization work done by Tanaka, Yoshikawa, and Ishihara [22]. <p> This column indicates whether or not the system offers updatable views. * Some systems (such as [8] and <ref> [20] </ref>) associate multiple protocols (interfaces) with each class rather than having objects belong to multiple (possibly virtual) classes. We call this alternative to the traditional multiple inheritance data model multiple protocols. <p> There are also some proposals on supporting multiple protocols (interfaces) for each class <ref> [8, 20] </ref>; such an approach would require however considerable extensions to the typical object model. To the best of our knowledge, no implementation of this approach has been attempted as of now.
Reference: [21] <author> L. A. Stein and S. B. Zdonik. Clovers: </author> <title> The dynamic behavior of types and instances. </title> <type> Technical Report CS-89-42, </type> <institution> Brown University, </institution> <month> November </month> <year> 1989. </year>
Reference: [22] <author> K. Tanaka, M. Yoshikawa, and K. Ishihara. </author> <title> Schema virtualization in object-oriented databases. </title> <booktitle> International Conference on Data Engineering, </booktitle> <month> February </month> <year> 1988. </year> <month> 19 </month>
Reference-contexts: Existing approaches in the literature either: (1) require the user to specify explicitly the relationship between a virtual class and 4 existing base classes <ref> [22] </ref>; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [17]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema [9, 11]. <p> row five refers to Heiler and Zdonik's FUGUE model [9]; row six refers to Shilling and Sweeney's three step approach [20]; row seven represents the COCOON project by Scholl, Schek, Laasch, and Tresch [18] [17]; and row eight corresponds to the schema virtualization work done by Tanaka, Yoshikawa, and Ishihara <ref> [22] </ref>. <p> This column shows whether or not the system features multiple protocols. * MultiView is one of several systems advocating the integration of virtual classes into a global schema. However, in most other systems, such as <ref> [22] </ref>, the integration is manual, rather than automatic. <p> Some of these systems are based upon existing or commercial systems, while others are designed from scratch. For example, Scholl et al [18] have developed their own system, COCOON, while Tanaka et al <ref> [22] </ref> base their object model upon Smalltalk. * As far as we know, no commercial system provides a general view management system for their object-oriented database system, and most of the systems proposed in academia have not yet been implemented. <p> Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. In fact, most researchers have focused on how query languages can be used to support the definition of virtual classes <ref> [9, 17, 22, 1, 14, 3] </ref>. In their discussion of FUGUE, Heiler and Zdonik [9] propose that the query language of FUGUE can be used for the specification of object-oriented virtual classes. They do not investigate either the issues of classification nor the re-use of methods. <p> However, they do not address the classification of virtual classes into a global schema or the automatic generation of complete view schemata. 17 Others define view schemata through the manipulation of the object schema graph rather than solely by query languages. Tanaka et al. <ref> [22] </ref> propose that view schemata be defined by manually manipulating the edges in the global schema graph. [10] also uses DAG rearrangement for view schema definition.
References-found: 22

