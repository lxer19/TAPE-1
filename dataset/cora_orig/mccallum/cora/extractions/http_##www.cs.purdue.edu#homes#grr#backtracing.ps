URL: http://www.cs.purdue.edu/homes/grr/backtracing.ps
Refering-URL: http://www.cs.purdue.edu/people/grr/
Root-URL: http://www.cs.purdue.edu
Email: (grr@cs.purdue.edu),  (russo@cs.purdue.edu)  
Title: Cyclic Distributed Garbage Collection Without Global Synchronization in CORBA  
Author: Gustavo Rodriguez-Rivera Vince Russo 
Address: West Lafayette, IN 47907  
Affiliation: Computer Science Department Purdue University  
Abstract: 1 Abstract 
Abstract-found: 1
Intro-found: 1
Reference: [BDS91] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proceedings of the 1991 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <address> Toronto, Ontario, June 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Boehm's conservative garbage collector <ref> [BDS91] </ref>, Orbix [Ion95], Solaris, and C++. The distributed garbage collector (DGC) is implemented as a library that can be linked with any Orbix program. The DGC automatically collects Orbix objects when they are no longer reachable from any local or remote root.
Reference: [BEN + 93] <author> Andrew Birrell, David Evers, Greg Nelson, Susan Owicki, and Edward Wobber. </author> <title> Distributed Garbage Collection for Network Objects. </title> <type> Technical Report 116, </type> <institution> Digital Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: This relaxed approximation eliminates the need of a termination algorithm to collect garbage, but has the disadvantage that cyclic garbage is not collected. Reference listing is a variation of reference counting that is tolerant to failures <ref> [SDP92a, BEN + 93, MS91] </ref>. In reference listing the server that owns an exported object keeps a list of other servers that have references to that object. In this way, increment/decrement operations are substituted by insert/delete operations. <p> The same is also valid for delete messages. There are some implementations that combine reference listing with local garbage collection <ref> [BEN + 93] </ref>. During a local garbage collection, every exported object is considered part of the root set. When a proxy is found to be unreachable from the root set, a delete message is sent to the corresponding remote object to delete that server from the reference list. <p> If a server does not respond to the ping messages after a prespecified number of them, the server is deleted from the reference list <ref> [BEN + 93] </ref>. Reference listing scales up well to large networks. However it is not capable of collecting garbage cycles. Currently reference listing has been implemented in commercial products like Microsoft DCOM [Mic94], and Java RMI [GM95]. Tracing distributed garbage collection is based on mark-and-sweep garbage collection.
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: This paper addresses and solves these issues. It also shows how a prototype of the back-tracing algorithm was built using the Orbix distributed system [Ion95], and Boehm's conservative garbage collector <ref> [BW88] </ref>. Finally, the paper shows directions of future work. 3 The Back-Tracing Algorithm By definition, live objects are the objects that are reachable from root objects by following a chain of object references.
Reference: [DeT90] <author> John DeTreville. </author> <title> Experience with concurrent garbage collectors for Modula-2+. </title> <type> Technical Report 64, </type> <institution> Digital Equipment Corporation Systems Research Center, Palo Alto, California, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: This section explain a heuristic that takes into account the age of the objects. In generational garbage collection <ref> [Wil95, LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>, new objects are collected more frequently than older ones because they are the most likely to be garbage. By using the same idea, generational back-tracing performs back-tracing of recently allocated objects more frequently than old objects.
Reference: [DLM + 78] <author> Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: Assuming that this new proxy is reachable from a root, but no other object in the back-trace was found reachable from a root, then the exported-object will be prematurely collected. This problem can be described in terms of Dijkstra's tricolor marking used for incremental garbage collection <ref> [DLM + 78] </ref>, and now adapted for back-tracing. Exported objects and proxies in Q that have been already back-traced are black. Exported objects and proxies in Q that have not been back-traced are grey. All the objects that are not in Q are white.
Reference: [Fuc95] <author> Matthew Fuchs. </author> <title> Garbage collection on an open network. </title> <editor> In Henry Baker, editor, </editor> <booktitle> In--ternational Workshop on Memory Management, Lecture Notes in Computer Science, </booktitle> <institution> Concurrent Engineering Research Center, West Virginia University, Mor gantown, </institution> <address> WV, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: It is shown in this paper that the synchronization needed for back-tracing does not require the servers to stop execution. Some previous work has been done on back-tracing <ref> [Fuc95] </ref>. However several important implementation issues were left open: These issues have to be solved before back-tracing can be implemented. First, normal pointers can be followed in only one direction, the to direction, and back-tracing needs to follow pointers backwards, the from direction.
Reference: [GM95] <author> James Gosling and Henry McGilton. </author> <title> The JAVA Language Environment: </title> <note> A White Paper. Available from http://www.javasoft.com/whitePaper, 1995. </note>
Reference-contexts: Reference listing scales up well to large networks. However it is not capable of collecting garbage cycles. Currently reference listing has been implemented in commercial products like Microsoft DCOM [Mic94], and Java RMI <ref> [GM95] </ref>. Tracing distributed garbage collection is based on mark-and-sweep garbage collection. Tracing distributed garbage collection is able to collect cycles of garbage, however it requires global coordination. The reason is the following: mark-and-sweep defines as garbage everything that is left unmarked after a mark phase.
Reference: [Hay91] <author> Barry Hayes. </author> <title> Using key object opportunism to collect old objects. </title> <editor> In Andreas Paepcke, editor, </editor> <booktitle> Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '91), </booktitle> <pages> pages 33-46, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: This section explain a heuristic that takes into account the age of the objects. In generational garbage collection <ref> [Wil95, LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>, new objects are collected more frequently than older ones because they are the most likely to be garbage. By using the same idea, generational back-tracing performs back-tracing of recently allocated objects more frequently than old objects.
Reference: [Hug85] <author> John Hughes. </author> <title> A distributed garbage collection algorithm. </title> <editor> In Jean-Pierre Jouan-naud, editor, </editor> <booktitle> Functional Languages and Computer Architectures, number 201 in Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272, </pages> <address> Nancy (France), </address> <month> September </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: More work has to be done to reduce the number of remote method calls needed for back-tracing. It would be possible to reduce the number of remote method calls by using a better heuristic for choosing garbage suspects. One possibility is to combine Hughes algorithm <ref> [Hug85] </ref> with back-tracing and perform back-tracing only in those objects that have a time-stamp older than some prespecified value. Also the distributed garbage collection implementation shown here is homogeneous in the sense that only Orbix applications in Solaris can use it.
Reference: [Ion95] <author> Iona Technologies, </author> <title> Dublin, Ireland. Orbix Programmer's Guide, </title> <month> July </month> <year> 1995. </year>
Reference-contexts: Finally, no implementation was available to prove that this algorithm could be successfully implemented with off the shelf software components. This paper addresses and solves these issues. It also shows how a prototype of the back-tracing algorithm was built using the Orbix distributed system <ref> [Ion95] </ref>, and Boehm's conservative garbage collector [BW88]. Finally, the paper shows directions of future work. 3 The Back-Tracing Algorithm By definition, live objects are the objects that are reachable from root objects by following a chain of object references. <p> Boehm's conservative garbage collector [BDS91], Orbix <ref> [Ion95] </ref>, Solaris, and C++. The distributed garbage collector (DGC) is implemented as a library that can be linked with any Orbix program. The DGC automatically collects Orbix objects when they are no longer reachable from any local or remote root.
Reference: [JJ92] <author> N. C. Juul and E. </author> <month> Jul. </month> <title> Comprehensive and robust garbage collection in a distributed system. </title> <booktitle> In Proc. Int. Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <pages> pages 103-115, </pages> <address> Saint-Malo (France), </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: This problem is equivalent to the costly termination detection problem in a distributed system [TM93]. Examples of distributed garbage collection algorithms that implement mark-and-sweep garbage collection are <ref> [JJ92, MA84] </ref>. In one hand, reference counting algorithms can be efficient and scalable, but are unable to collect cyclic garbage. In the other hand, tracing distributed garbage collection algorithms collect cyclic garbage but require global synchronization.
Reference: [Jon96] <author> Richard E. Jones. </author> <title> Garbage Collection: Algorithms for Automatic Dynamic Memory Management. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1996. </year> <title> With a chapter on Distributed Garbage Collection by R. </title> <type> Lins. </type>
Reference-contexts: Garbage collection is now a required feature in modern computer languages. For the same reasons, distributed garbage collection is also a necessity in modern distributed systems. Distributed garbage collection algorithms can be grouped in two families: Reference Counting and Tracing <ref> [Jon96, PS95] </ref>. Reference counting is a garbage collection technique that is rarely used in non-distributed systems because of its high overhead and its incapability to collect cyclic garbage. However, it is a popular technique in distributed garbage collection because it does not require global synchronization.
Reference: [LH83] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: This section explain a heuristic that takes into account the age of the objects. In generational garbage collection <ref> [Wil95, LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>, new objects are collected more frequently than older ones because they are the most likely to be garbage. By using the same idea, generational back-tracing performs back-tracing of recently allocated objects more frequently than old objects.
Reference: [MA84] <author> Khayri A. Mohamed-Ali. </author> <title> Object Oriented Storage Management and Garbage Collection in Distributed Processing Systems. </title> <type> PhD thesis, </type> <institution> Royal Institute of Technology, Stockholm, </institution> <month> December </month> <year> 1984. </year>
Reference-contexts: This problem is equivalent to the costly termination detection problem in a distributed system [TM93]. Examples of distributed garbage collection algorithms that implement mark-and-sweep garbage collection are <ref> [JJ92, MA84] </ref>. In one hand, reference counting algorithms can be efficient and scalable, but are unable to collect cyclic garbage. In the other hand, tracing distributed garbage collection algorithms collect cyclic garbage but require global synchronization.
Reference: [Mic94] <author> Microsoft Corporation. </author> <title> OLE2 Programmer's Reference, volume 2. </title> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: Reference listing scales up well to large networks. However it is not capable of collecting garbage cycles. Currently reference listing has been implemented in commercial products like Microsoft DCOM <ref> [Mic94] </ref>, and Java RMI [GM95]. Tracing distributed garbage collection is based on mark-and-sweep garbage collection. Tracing distributed garbage collection is able to collect cycles of garbage, however it requires global coordination. The reason is the following: mark-and-sweep defines as garbage everything that is left unmarked after a mark phase.
Reference: [MS91] <author> Luigi Mancini and S. K. Shrinivastava. </author> <title> Fault-tolerant reference counting for garbage collection in distributed systems. </title> <journal> Computer Journal, </journal> <volume> 34(6) </volume> <pages> 503-513, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: This relaxed approximation eliminates the need of a termination algorithm to collect garbage, but has the disadvantage that cyclic garbage is not collected. Reference listing is a variation of reference counting that is tolerant to failures <ref> [SDP92a, BEN + 93, MS91] </ref>. In reference listing the server that owns an exported object keeps a list of other servers that have references to that object. In this way, increment/decrement operations are substituted by insert/delete operations.
Reference: [PS95] <author> David Plainfosse and Marc Shapiro. </author> <title> A survey of distributed garbage collection techniques. </title> <booktitle> In Proc. Int. Workshop on Memory Management, </booktitle> <address> Kinross Scotland (UK), </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Garbage collection is now a required feature in modern computer languages. For the same reasons, distributed garbage collection is also a necessity in modern distributed systems. Distributed garbage collection algorithms can be grouped in two families: Reference Counting and Tracing <ref> [Jon96, PS95] </ref>. Reference counting is a garbage collection technique that is rarely used in non-distributed systems because of its high overhead and its incapability to collect cyclic garbage. However, it is a popular technique in distributed garbage collection because it does not require global synchronization.
Reference: [SDP92a] <author> Marc Shapiro, Peter Dickman, and David Plainfosse. </author> <title> Robust, distributed references and acyclic garbage collection. </title> <booktitle> In Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 135-146, </pages> <address> Vancouver (Canada), </address> <month> August </month> <year> 1992. </year> <note> ACM. Superseded by [SDP92b]: corrects a bug, more elegant, more informative. </note>
Reference-contexts: This relaxed approximation eliminates the need of a termination algorithm to collect garbage, but has the disadvantage that cyclic garbage is not collected. Reference listing is a variation of reference counting that is tolerant to failures <ref> [SDP92a, BEN + 93, MS91] </ref>. In reference listing the server that owns an exported object keeps a list of other servers that have references to that object. In this way, increment/decrement operations are substituted by insert/delete operations.
Reference: [SDP92b] <author> Marc Shapiro, Peter Dickman, and David Plainfosse. </author> <title> SSP chains: Robust, distributed references supporting acyclic garbage collection. </title> <institution> Rapport de Recherche 1799, Institut National de la Recherche en Informatique et Automatique, Rocquencourt (France), </institution> <month> nov </month> <year> 1992. </year> <note> Also available as Broadcast Technical Report #1. </note>
Reference: [Sha88] <author> Robert A. Shaw. </author> <title> Empirical Analysis of a Lisp System. </title> <type> PhD thesis, </type> <institution> Stanford University, Palo Alto, California, </institution> <month> February </month> <year> 1988. </year> <type> Technical Report CSL-TR-88-351, </type> <institution> Stanford University Computer Systems Laboratory. </institution>
Reference-contexts: This section explain a heuristic that takes into account the age of the objects. In generational garbage collection <ref> [Wil95, LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>, new objects are collected more frequently than older ones because they are the most likely to be garbage. By using the same idea, generational back-tracing performs back-tracing of recently allocated objects more frequently than old objects.
Reference: [TM93] <author> G. Tel and F. Mattern. </author> <title> The derivation of distributed termination detection algorithms from garbage collection schemes. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 1-35, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: This implies that after a mark-phase, all the servers in the system have to agree on the same condition: that there are no more objects to be marked. This problem is equivalent to the costly termination detection problem in a distributed system <ref> [TM93] </ref>. Examples of distributed garbage collection algorithms that implement mark-and-sweep garbage collection are [JJ92, MA84]. In one hand, reference counting algorithms can be efficient and scalable, but are unable to collect cyclic garbage. In the other hand, tracing distributed garbage collection algorithms collect cyclic garbage but require global synchronization.
Reference: [Ung84] <author> David M. Ungar. </author> <title> Generation scavenging: A non-disruptive high-performance storage reclamation algorithm. </title> <booktitle> In ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167. </pages> <publisher> ACM Press, </publisher> <month> April </month> <year> 1984. </year> <note> Published as ACM SIGPLAN Notices 19(5), </note> <month> May, </month> <year> 1987. </year>
Reference-contexts: This section explain a heuristic that takes into account the age of the objects. In generational garbage collection <ref> [Wil95, LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>, new objects are collected more frequently than older ones because they are the most likely to be garbage. By using the same idea, generational back-tracing performs back-tracing of recently allocated objects more frequently than old objects.
Reference: [Wil92] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Yves Bekkers and Jacques Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-42, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference: [Wil95] <author> Paul R. Wilson. </author> <title> Garbage collection. </title> <journal> Computing Surveys, </journal> <note> 1995. Expanded version of [Wil92]. Draft available via anonymous internet FTP from cs.utexas.edu as pub/garbage/bigsurv.ps. In revision, to appear. </note>
Reference-contexts: This section explain a heuristic that takes into account the age of the objects. In generational garbage collection <ref> [Wil95, LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>, new objects are collected more frequently than older ones because they are the most likely to be garbage. By using the same idea, generational back-tracing performs back-tracing of recently allocated objects more frequently than old objects.
Reference: [Zor90] <author> Benjamin Zorn. </author> <title> Comparing mark-and-sweep and stop-and-copy garbage collection. </title> <booktitle> In Conference Record of the 1990 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 87-98, </pages> <address> Nice, France, June 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This section explain a heuristic that takes into account the age of the objects. In generational garbage collection <ref> [Wil95, LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>, new objects are collected more frequently than older ones because they are the most likely to be garbage. By using the same idea, generational back-tracing performs back-tracing of recently allocated objects more frequently than old objects.
References-found: 25

