URL: http://www.cs.arizona.edu/scout/Papers/TR97-15.ps
Refering-URL: http://www.cs.arizona.edu/scout/nettv.html
Root-URL: http://www.cs.arizona.edu
Title: Predicting MPEG Execution Times  
Author: Andy Bavier and Brady Montz and Larry L. Peterson 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Date: TR 97-15  
Abstract: This paper reports on a set of experiments that measure the amount of CPU processing needed to decode MPEG-compressed video in software. These experiments were designed to discover indicators that could be used to predict how many cycles are required to decode a given frame. Such predictors can be used to do more accurate CPU scheduling. We found that by considering both frame type and size, it is possible to construct a linear model of MPEG decoding with R 2 values of 0.97 and higher. Moreover, this model can be used to predict decoding times at both the frame and packet level that are almost always accurate to within 25% of the actual decode times. This is a surprising result given the large variability in MPEG decoding times, and suggests that it is feasible to design systems that make quality of service guarantees for MPEG-encoded video, rather than less variable encodings, such as JPEG. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bavier, D. Mosberger, and L. L. Peterson. </author> <title> Scheduling realtime and best effort paths in Scout. </title> <type> Technical report, </type> <note> In preparation. </note>
Reference-contexts: The latest acceptable start time for the decoding task is the deadline of that frame minus the length of time to decode that frame. Scheduling algorithms are now being designed to exploit such information <ref> [1, 7, 2] </ref>. This paper focuses on the fine-grain predictors that are suitable for scheduling, but in doing so, also lays the ground work for designing better load control mechanisms. <p> This makes EDF inappropriate when one is trying to mix realtime and non-realtime tasks. Scheduling both realtime and non-realtime tasks under load requires knowing how long a realtime task is going to run <ref> [1, 7, 2] </ref>.
Reference: [2] <author> P. Goyal, X. Guo, and H. Vin. </author> <title> A hierarchial CPU scheduler for multimedia operating systems. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 107122, </pages> <address> Seattle, WA, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: The latest acceptable start time for the decoding task is the deadline of that frame minus the length of time to decode that frame. Scheduling algorithms are now being designed to exploit such information <ref> [1, 7, 2] </ref>. This paper focuses on the fine-grain predictors that are suitable for scheduling, but in doing so, also lays the ground work for designing better load control mechanisms. <p> This makes EDF inappropriate when one is trying to mix realtime and non-realtime tasks. Scheduling both realtime and non-realtime tasks under load requires knowing how long a realtime task is going to run <ref> [1, 7, 2] </ref>.
Reference: [3] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 1(20):4661, </volume> <month> Jan. </month> <year> 1973. </year>
Reference-contexts: First, due to video's realtime constraints, each frame must be decoded by a certain time. It is only by knowning how long this thread will run that we can determine the latest time the thread must start executing. Classical realtime scheduling algorithms, such as Earliest Deadline First (EDF) <ref> [3] </ref>, do not require knowing the execution time, but they have the limitation of not operating well under load. This makes EDF inappropriate when one is trying to mix realtime and non-realtime tasks. <p> the following code, returns type B PKT if the packet contains any B-blocks, else it returns type P PKT if the packet contains any P-blocks, else it returns type I PKT. 16 Frame Predictor struct framePredictor - long cycles; long bytes; long frames; long x_diff, y_diff; -; struct framePredictor framep <ref> [3] </ref>; long frame_prediction (int frame_type, long bytes) - struct framePredictor *fp; long prediction, avg_bytes, slope; fp = &framep [frame_type]; if (fp-&gt;frames &gt; 0) - prediction = fp-&gt;cycles / fp-&gt;frames; avg_bytes = fp-&gt;bytes / fp-&gt;frames; if (fp-&gt;x_diff != 0) - slope = fp-&gt;y_diff/fp->x_diff; prediction += (bytes - avg_bytes) * slope; - else <p> (same_signs && fp-&gt;frames &gt;= WAIT) - fp-&gt;x_diff = ((fp-&gt;x_diff*7)>>3) + (abs (bytes - avg_bytes)&gt;>3); fp-&gt;y_diff = ((fp-&gt;y_diff*7)>>3) + (abs (cycles - avg_cycles)&gt;>3); - fp-&gt;frames++; fp-&gt;cycles += cycles; 17 fp-&gt;bytes += bytes; - Packet Predictor struct packetPredictor - long cycles; long blks; long packets; long x_diff, y_diff; -; struct packetPredictor packetp <ref> [3] </ref>; extern long ditherTime; enum -I_PKT, P_PKT, B_PKT-; long packet_prediction (int num_EOFs, int Iblks, int Pblks, int B1blks, int B2blks) - struct packetPredictor *pp; long prediction, avg_blks, slope, blks; int type; type = getPacketType (Iblks, Pblks, B1blks, B2blks); pp = &packetp [type]; if (pp-&gt;packets &gt; 0) - prediction = (pp-&gt;cycles /
Reference: [4] <author> J. Mitchell, W. Pennebaker, C. Fogg, and D. LeGall. </author> <title> MPEG Video Compression Standard. </title> <publisher> Chapman and Hall, </publisher> <year> 1996. </year>
Reference-contexts: describe the execution environment in which the measurements were taken, and in which the resulting estimators were eventually employed. 2.1 MPEG The MPEG video compression standard defines a video stream as a sequence of still images (frames) that are displayed at some rate, for example, 30 frames per second (fps) <ref> [4] </ref>. Each frame is of a particular type: I frames (intrapicture), P frames (predicted picture) and B frames (bidirectional predicted picture). I frames are self-contained, complete images. P and B frames are encoded as differences from other reference frames. Only I and P frames may be used as reference frames.
Reference: [5] <author> D. Mosberger. </author> <title> Scout: A Path-Based Operating System. </title> <type> PhD thesis, </type> <institution> University of Arizona, </institution> <year> 1997. </year>
Reference-contexts: This is especially true of P and I macroblocks, which can vary in length by a factor of four or more within a single video. Based on this observation, and a similar insight by Mosberger <ref> [5] </ref>, we next plotted the frame decoding time as a function of the length (in bytes) of each frame type, as depicted in Figure 4. This Figure plots the predicted cycles (x-axis) against the actual required cycles (y-axis), with the regression line shown.
Reference: [6] <author> D. Mosberger and L. Peterson. </author> <title> Making paths explicit in the Scout operating system. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 73153168, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Then, the delta for the pixel is added to the average of these two reference pixels. 2.2 Scout OS We measured MPEG decoding performance in the context of the Scout operating system <ref> [6] </ref>. Scout is a configurable OS explicitly designed to support data streams such as MPEG-compressed video. Specifically, Scout defines a path abstraction that encapsulates data as it moves through the system, for example, from input device to output device.
Reference: [7] <author> J. Nieh and M. Lam. </author> <title> The design, implementation and evaluation of SMART: A scheduler for multimedia applications. </title> <booktitle> In Proceedings of the Sixteenth Symposium on Operating System Principles, </booktitle> <pages> pages 184197, </pages> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: The latest acceptable start time for the decoding task is the deadline of that frame minus the length of time to decode that frame. Scheduling algorithms are now being designed to exploit such information <ref> [1, 7, 2] </ref>. This paper focuses on the fine-grain predictors that are suitable for scheduling, but in doing so, also lays the ground work for designing better load control mechanisms. <p> This makes EDF inappropriate when one is trying to mix realtime and non-realtime tasks. Scheduling both realtime and non-realtime tasks under load requires knowing how long a realtime task is going to run <ref> [1, 7, 2] </ref>.
References-found: 7

