URL: http://www.cs.utah.edu/~cs686/boehm-pldi96.ps
Refering-URL: http://www.cs.utah.edu/~cs686/
Root-URL: 
Email: boehm@parc.xerox.com  
Title: Simple Garbage-Collector-Safety conservative garbage collectors require minimal cooperation from the compiler, they do require some
Author: Hans-J. Boehm 
Keyword: Garbage-Collector-Safety  
Note: Although  referenced by p. Thus such  
Affiliation: Xerox PARC  
Abstract: A conservative garbage collector can typically be used with conventionally compiled programs written in C or C++. But two safety issues must be considered. First, the source code must not hide pointers from the garbage collector. This primarily requires stricter adherence to existing restrictions in the language definition. Second, we must ensure that the compiler will not perform transformations that invalidate this requirement. We argue that the same technique can be used to address both issues. We present an algorithm for annotating source or intermediate code to either check the validity of pointer arithmetic in the source, or to guarantee that under minimal, clearly defined assumptions about the compiler, the optimizer cannot ``disguise'' pointers. We discuss an implementation based on a preprocessor for the GNU C compiler (gcc), and give some measurements of program slowdown. Copyright 1996 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advanatage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on severs, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept., ACM Inc., fax +1 (212) 869-0481, or (permissions@acm.org). This originally appeared in Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation SIGPLAN Notices ??, ?, pp. ??-??. Automatic garbage collection can significantly simplify program development. It can also help to isolate program errors to one module by helping to ensure that no module can invalidate a data structure maintained by another. Though it is hard to quantify this benefit, most expert guesses seem to place it in the range of 30-40% of program development time for programs that manipulate complex linked data structures (cf. [Rovner85]). Furthermore, in our experience, garbage collected programs tend to be based on higher level abstractions where appropriate, and thus tend to have fewer arbitrary restrictions on functionality (e.g. input size limitations). Tracing garbage collectors identify all accessible memory by starting at program pointer variables, and traversing all pointers through the heap. Conservative garbage collectors (cf. [Bartlett88], [BoehmWeiser88], [Rovner85], [Boehm 95]) can do so even in the presence of incomplete information about pointer identity by treating any bit pattern that might represent the address of a heap object as a pointer. This may result in some extra memory retention, but this is rarely significant [Boehm93]. This approach enables garbage collectors to operate easily with conventional programming languages such as C and C++, and with minimal or no modification to existing compilers. It has been used by many language implementations that use C as an intermediate code (cf. [Bartlett89], [AtkinsonEtAl89], [Omohundro91], [RoseMuller92], [SchelterBallantyne88]) , and it facilitates interoperation between C and higher level programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [ANSI89] <author> Standard X3.159-1989, </author> <title> American National Standard for Information Systems - Programming Language - C, </title> <publisher> American National Standards Institute, Inc. </publisher>
Reference-contexts: Our approach to inserting checking code is significantly different, in that we essentially treat pointer offset calculations as pointer arithmetic. This appears to result in better checking of structure accesses. Compiler Safety Problem Statement We are interested in compiling ANSI C <ref> [ANSI89] </ref>, minimally restricted as defined above, such that the object code resulting from a strictly conforming program is guaranteed to operate correctly with a conservative garbage collector, if we replace every call to the malloc, calloc and realloc functions by corresponding calls to a collecting allocator, and remove all calls to
Reference: [AtkinsonEtAl89] <author> Atkinson, Russ, Alan Demers, Carl Hauser, Christian Jacobi, Peter Kessler, and Mark Weiser, </author> <title> ``Experiences Creating a Portable Cedar'', </title> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, SIGPLAN Notices 24, </booktitle> <month> 7 (July </month> <year> 1989), </year> <pages> pp. 322-329. </pages>
Reference: [AustinBreachSohi94] <author> Austin, Todd M., Scott E. Breach, and Gurindar S. Sohi, </author> <title> ``Efficient Detection of all Pointer and Array Access Errors'', </title> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, SIGPLAN Notices 29, </booktitle> <month> 6 (June </month> <year> 1994), </year> <pages> pp. 290-301. </pages>
Reference-contexts: Hence they are not performance competitive with conservative collectors, though the expense may be unavoidable in hard real-time environments [Edelson91]. There has been a substantial amount of work on safer C implementations (cf. [HastingsJoyce92], <ref> [AustinBreachSohi94] </ref>, [JonesKelly95].) Most of these have concentrated on detecting erroneous memory accesses, not erroneous pointer or subscript arithmetic. Though the two are related, the distinction is important. <p> This fails in a garbage collected system. It may also result in incorrect pointer comparisons on segmented memory machines. Like Purify, but unlike <ref> [AustinBreachSohi94] </ref>, our checked code uses the same data structure layout as unchecked code. Hence it is possible, indeed trivial, to use checked code with third party object-code-only libraries, or with faster, unchecked modules. Our checked code is very similar in spirit to recent independent work by Jones and Kelly [JonesKelly95].
Reference: [Bartlett88] <author> Bartlett, Joel F. </author> <title> ``Compacting garbage collection with ambiguous roots'', Lisp Pointers 1, </title> <booktitle> 6 (April-June 1988), </booktitle> <pages> pp. 3-12. </pages>
Reference: [Bartlett89] <author> Bartlett, Joel F., </author> <title> Scheme --&gt; C a Portable Scheme-to-C Compiler, </title> <note> WRL Research Report 89/1, </note> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <month> January </month> <year> 1989. </year>
Reference: [Boehm93] <author> Boehm, Hans-J., </author> <title> ``Space Efficient Conservative Garbage Collection'', </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, SIGPLAN Notices 28, </booktitle> <month> 6 (June </month> <year> 1993), </year> <pages> pp. 197-206. </pages>
Reference-contexts: Recent experience suggests that this is the right framework, particularly for typical C++ implementations which implicitly generate pointers to the interior of an object. The techniques of <ref> [Boehm93] </ref> can greatly reduce the danger of space leakage that we previously associated with this approach. This new assumption greatly simplifies our task. Unfortunately, it also usually invalidates assumption (A) of [BoehmChase92], so our correctness argument has to be different. <p> This requires asserting that the client program stores only pointers to the base of an object in the heap or in statically allocated variables. It would again be possible to insert dynamic checks to verify this. This avoids some complications with allocating large objects as discussed in <ref> [Boehm93] </ref>. However it interacts suboptimally with C++ compilers that use interior pointers as part of their multiple inheritance implementation. Acknowledgements Some of this grew out of prior work with David Chase and extensive discussion with John Ellis.
Reference: [Boehm94] <institution> The SPARC scheduler is available from parcftp.xerox.com:pub/gc/sched.tar.Z. </institution> <note> It also operates in a GC-safe mode, along the lines of [BoehmChase92]. </note>
Reference-contexts: To test this hypothesis, we built a simple peephole optimizer that operates on the SPARC assembly code level. (The code was derived from a simple SPARC 1/2 instruction scheduler <ref> [Boehm94] </ref>.) It first performs a simple global, intraprocedural analysis that allows us to identify possible uses of register values.
Reference: [Boehm95] <institution> An overview of our conservative garbage collector along with the source code can be accessed from ftp://parcftp.xerox.com/pub/gc/gc.html. </institution>
Reference: [BoehmChase92] <author> Boehm, Hans-J., and David Chase, </author> <title> A Proposal for GC-Safe C Compilation, The Journal of C Language Translation 4, </title> <month> 2 (December , </month> <year> 1992), </year> <pages> pp. 126-141. </pages> <note> Also available (with the publishers permission) from parcftp.xerox.com:pub/gc/boecha.ps.Z. </note>
Reference-contexts: This could be remedied at minimal cost with the insertion of an additional check. Related Work We extend, refine and implement the work presented in <ref> [BoehmChase92] </ref> and [EllisDetlefs93]. Unlike [BoehmChase92] we start with the assumption that the garbage collector recognizes all pointers to the interior of an object, not just to the first byte of the object. <p> This could be remedied at minimal cost with the insertion of an additional check. Related Work We extend, refine and implement the work presented in <ref> [BoehmChase92] </ref> and [EllisDetlefs93]. Unlike [BoehmChase92] we start with the assumption that the garbage collector recognizes all pointers to the interior of an object, not just to the first byte of the object. <p> The techniques of [Boehm93] can greatly reduce the danger of space leakage that we previously associated with this approach. This new assumption greatly simplifies our task. Unfortunately, it also usually invalidates assumption (A) of <ref> [BoehmChase92] </ref>, so our correctness argument has to be different. An approach even more similar to ours here is presented in [EllisDetlefs93], but not in a great amount of detail. <p> The value will continue to be explicitly available through a dereference or another KEEP_LIVE in the presence of all standard compiler optimizations. This implementation of KEEP_LIVE is, of course, terribly inefficient. More efficient implementations are suggested in <ref> [BoehmChase92] </ref>, and one is described below.
Reference: [BoehmDemersShenker91] <author> Boehm, H., A. Demers, and S. </author> <title> Shenker,``Mostly Parallel Garbage Collection'', </title> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, SIGPLAN Notices 26, </booktitle> <month> 6 (June </month> <year> 1991), </year> <pages> pp. 157-164. </pages>
Reference: [BoehmWeiser88] <author> Boehm, Hans-J. and Mark Weiser, </author> <title> ``Garbage collection in an uncooperative environment'', </title> <journal> Software Practice & Experience 18, </journal> <month> 9 (Sept. </month> <year> 1988), </year> <pages> pp. 807-820. </pages>
Reference: [DiwanMossHudson92] <author> Diwan, Amer, Eliot Moss, Richard Hudson, </author> <title> ``Compiler Support for Garbage Collection in a Statically Typed Language'', </title> <booktitle> ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, SIGPLAN Notices 27, </booktitle> <month> 7 (July </month> <year> 1992), </year> <pages> pp. 273-282. </pages>
Reference-contexts: An approach even more similar to ours here is presented in [EllisDetlefs93], but not in a great amount of detail. There has been much work on the generation and representation of object and stack layout information by the compiler for the garbage collector. Recent examples include <ref> [DiwanMossHudson92] </ref> [Goldberg91], and [Fradet94]. The idea is to generate static information (either tables or traversal functions) to communicate pointer locations to the garbage collector. <p> The last point may introduce other forms of overhead in some multithreaded environments. To our knowledge, none of this work addresses the issue of run-time overhead required to keep pointers accessible, though <ref> [DiwanMossHudson92] </ref> does discuss the necessity for such overhead. There have also been many proposals for completely source-level implementation of garbage-collection using either the C++ constructor/destructor mechanism or Ada 9X ``finalization''. These typically greatly increase the number of memory references necessary for pointer assignments or pointer variable creation.
Reference: [DetlefsDosserZorn93] <author> Detlefs, David, Al Dosser, and Benjamin Zorn, </author> <title> ``Memory Allocation Costs in Large C and C++ Programs'', </title> <institution> University of Colorado, </institution> <type> Boulder Technical Report CU-CS-665-93. </type> <note> Available for ftp from cs.colorado.edu:pub/techreports/zorn/CU-CS-665-93.ps.Z. </note>
Reference-contexts: Performance We measured a small collection of small-to-medium-sized C programs, mostly drawn from the Zorn benchmark suite <ref> [DetlefsDosserZorn93] </ref>. All of these programs are very pointer and allocation intensive. Standard C libraries were not preprocessed.
Reference: [Edelson91] <author> Edelson, Daniel, </author> <title> ``A Mark-and-Sweep Collector for C++'', </title> <booktitle> Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992, </year> <pages> pp. 51-58. </pages>
Reference-contexts: These typically greatly increase the number of memory references necessary for pointer assignments or pointer variable creation. Hence they are not performance competitive with conservative collectors, though the expense may be unavoidable in hard real-time environments <ref> [Edelson91] </ref>. There has been a substantial amount of work on safer C implementations (cf. [HastingsJoyce92], [AustinBreachSohi94], [JonesKelly95].) Most of these have concentrated on detecting erroneous memory accesses, not erroneous pointer or subscript arithmetic. Though the two are related, the distinction is important.
Reference: [EllisDetlefs93] <author> Ellis, John R., and David L. Detlefs, </author> <title> "Safe Efficient Garbage Collection for C++'', </title> <note> Xerox PARC Technical Report CSL-93-4, September 1993. Also available from parcftp.xerox.com:pub/ellis/gc/gc.ps. </note>
Reference-contexts: This could be remedied at minimal cost with the insertion of an additional check. Related Work We extend, refine and implement the work presented in [BoehmChase92] and <ref> [EllisDetlefs93] </ref>. Unlike [BoehmChase92] we start with the assumption that the garbage collector recognizes all pointers to the interior of an object, not just to the first byte of the object. <p> This new assumption greatly simplifies our task. Unfortunately, it also usually invalidates assumption (A) of [BoehmChase92], so our correctness argument has to be different. An approach even more similar to ours here is presented in <ref> [EllisDetlefs93] </ref>, but not in a great amount of detail. There has been much work on the generation and representation of object and stack layout information by the compiler for the garbage collector. Recent examples include [DiwanMossHudson92] [Goldberg91], and [Fradet94].
Reference: [Fradet94] <author> Fradet, </author> <title> Pascal, ``Collecting More Garbage'', </title> <booktitle> Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 24-33. </pages>
Reference-contexts: An approach even more similar to ours here is presented in [EllisDetlefs93], but not in a great amount of detail. There has been much work on the generation and representation of object and stack layout information by the compiler for the garbage collector. Recent examples include [DiwanMossHudson92] [Goldberg91], and <ref> [Fradet94] </ref>. The idea is to generate static information (either tables or traversal functions) to communicate pointer locations to the garbage collector.
Reference: [Goldberg91] <author> Goldberg, Benjamin, </author> <title> ``Tag-Free Garbage Collection for Strongly Typed Programming Languages'', </title> <booktitle> ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, SIGPLAN Notices 26, </booktitle> <month> 6 (June </month> <year> 1991), </year> <pages> pp. 165-176. </pages>
Reference-contexts: An approach even more similar to ours here is presented in [EllisDetlefs93], but not in a great amount of detail. There has been much work on the generation and representation of object and stack layout information by the compiler for the garbage collector. Recent examples include [DiwanMossHudson92] <ref> [Goldberg91] </ref>, and [Fradet94]. The idea is to generate static information (either tables or traversal functions) to communicate pointer locations to the garbage collector.
Reference: [HastingsJoyce92] <author> Hastings, Reed, and Bob Joyce, </author> <title> ``Fast Detection of Memory Leaks and Access Errors'', </title> <booktitle> Proceedings of the Winter '92 USENIX conference, </booktitle> <pages> pp. 125-136. </pages>
Reference-contexts: Admittedly the annotated program will incur a significant performance loss, at least without substantially more analysis than we perform. We expect such checking to be performed only during debugging, by analogy to the current use of systems like Purify <ref> [HastingsJoyce92] </ref>. Our checking is not completely accurate, since the garbage collector rounds up object sizes. But it is sufficient to ensure that on a machine with typical RISC alignment restrictions at most unused memory can be accidentally referenced through an incorrectly computed heap pointer to a primitive type. <p> Hence they are not performance competitive with conservative collectors, though the expense may be unavoidable in hard real-time environments [Edelson91]. There has been a substantial amount of work on safer C implementations (cf. <ref> [HastingsJoyce92] </ref>, [AustinBreachSohi94], [JonesKelly95].) Most of these have concentrated on detecting erroneous memory accesses, not erroneous pointer or subscript arithmetic. Though the two are related, the distinction is important.
Reference: [JonesKelly95] <author> Jones, Richard, and Paul Kelly, </author> <title> ``Bounds Checking for C'', </title> <address> http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html. </address>
Reference-contexts: Hence they are not performance competitive with conservative collectors, though the expense may be unavoidable in hard real-time environments [Edelson91]. There has been a substantial amount of work on safer C implementations (cf. [HastingsJoyce92], [AustinBreachSohi94], <ref> [JonesKelly95] </ref>.) Most of these have concentrated on detecting erroneous memory accesses, not erroneous pointer or subscript arithmetic. Though the two are related, the distinction is important. <p> Hence it is possible, indeed trivial, to use checked code with third party object-code-only libraries, or with faster, unchecked modules. Our checked code is very similar in spirit to recent independent work by Jones and Kelly <ref> [JonesKelly95] </ref>. The major differences are that we do not check references to statically allocated and stack memory, we use the garbage collector's data structures to determine whether two pointers reference the same object, and we take a different approach to inserting the checking code.
Reference: [Omohundro91] <author> Omohundro, Stephen M., </author> <title> The Sather Language, </title> <type> ICSI, </type> <institution> Berkeley, </institution> <year> 1991. </year>
Reference: [OTooleNettles94] <author> O'Toole, James, and Scott Nettles, </author> <title> ``Concurrent Replicating Garbage Collection'', </title> <booktitle> Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 34-42. </pages>
Reference: [RoseMuller92] <author> Rose, John R., and Hans Muller, </author> <title> ``Integrating the Scheme and C languages'', </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 247-259. </pages>
Reference: [Rovner85] <author> Rovner, Paul, </author> <title> ``On Adding Garbage Collection and Runtime Types to a Strongly-Typed Statically Checked, Concurrent Language'', </title> <type> Technical Report CSL-84-7, </type> <institution> Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <month> July </month> <year> 1985. </year>
Reference: [SchelterBallantyne88] <author> Schelter, W. F., and M. Ballantyne, </author> <title> ``Kyoto Common Lisp'', </title> <journal> AI Expert 3, </journal> <volume> 3 (1988), </volume> <pages> pp. 75-77. </pages>
References-found: 24

