URL: ftp://cl-ftp.dfki.uni-sb.de/pub/papers/local/tdl-coli94.ps.Z
Refering-URL: http://cl-www.dfki.uni-sb.de/cl/papers/cl-abstracts.html
Root-URL: 
Email: fkrieger,schaeferg@dfki.uni-sb.de  
Title: TDL|A Type Description Language for Constraint-Based Grammars  
Author: Hans-Ulrich Krieger, Ulrich Schafer 
Address: Stuhlsatzenhausweg 3, D-66123 Saarbrucken, Germany  
Affiliation: German Research Center for Artificial Intelligence (DFKI)  
Abstract: This paper presents TDL, a typed feature-based representation language and inference system. Type definitions in TDL consist of type and feature constraints over the boolean connectives. TDL supports open- and closed-world reasoning over types and allows for partitions and incompatible types. Working with partially as well as with fully expanded types is possible. Efficient reasoning in TDL is accomplished through specialized modules. Topical Paper. Topic Area: software for NLP, grammar formalism for typed feature structures. 
Abstract-found: 1
Intro-found: 1
Reference: [ 1 ] <author> Hassan At-Kaci, Robert Boyer, Patrick Lincoln, and Roger Nasr. </author> <title> Efficient implementation of lattice operations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <pages> 115-146, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Moreover, generalizations can be put at the appropriate levels of representation. * efficient processing Certain type constraints can be compiled into efficient representations like bit vectors <ref> [ 1 ] </ref> , where a GLB (greatest lower bound), LUB (least upper bound), or a (type subsumption) computation reduces to low-level bit manipulation; see Section 3.2. Moreover, types release untyped unification from expensive computation through the possibility to declare them incompatible. <p> either called directly by the control machinery of T DL during the definition of a type (type classification) or indirectly via the simplifier both at definition and at run time (type unification). 3.2.1 Encoding Method The implementation of the type hierarchy is based on At-Kaci's encoding technique for partial orders <ref> [ 1 ] </ref> . Every type t is assigned a code fl (t) (represented via a bit vector) such that fl (t) reflects the reflexive transitive closure of the subsumption relation with respect to t.
Reference: [ 2 ] <author> Hassan At-Kaci, Andreas Podelski, and Seth Copen Goldstein. </author> <title> Order-sorted feature theory unification. </title> <type> Techn. Report 32, </type> <institution> DEC Paris Research Lab., </institution> <year> 1993. </year>
Reference-contexts: Because our logic is much more richer, we immediately get the same result for TDL. However, one can choose in T DL between a complete expansion algorithm which may not terminate and a non-complete one to guarantee termination (see <ref> [ 2 ] </ref> and [ 5, Ch. 15 ] for similar proposals). The latter case heavily depends on the notion of resolvedness (see above). <p> In both cases, the depth of the search space can be restricted by specifying a maximal path length. 4 Comparison with other Systems T DL is unique in that it implements many novel features not found in other systems like ALE [ 4 ] , LIFE <ref> [ 2 ] </ref> , or TFS [ 15 ] . Of course, these systems provide other features which are not present in our formalism.
Reference: [ 3 ] <author> Rolf Backofen and Christoph Weyers. </author> <title> UDiNe|a feature constraint solver with distributed disjunction and classical negation. </title> <type> Technical report, </type> <institution> DFKI, Saar-brucken, Germany, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: The DISCO grammar currently consists of approx. 900 type specifications written in T DL and is the largest HPSG grammar for German [ 9 ] . The core engine of DISCO consists of T DL and the feature constraint solver UDiNe <ref> [ 3 ] </ref> . UDiNe itself is a powerful untyped unification machinery which allows the use of distributed disjunctions, general negation, and functional dependencies.
Reference: [ 4 ] <author> Bob Carpenter. </author> <title> ALE|the attribute logic engine user's guide. Version fi. </title> <type> Technical report, </type> <institution> Laboratory for Computational Linguistics. Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <year> 1992. </year>
Reference-contexts: Later, other operations came into play, e.g., (classical) negation. Other proposals consider the integration of functional/relational dependencies into the formalism which make them in general Turing-complete (e.g., ALE <ref> [ 4 ] </ref> ). However the most important extension to formalisms consists of the incorporation of types, for instance in modern systems like TFS [ 15 ] , CUF [ 6 ] , or T DL [ 7 ] . <p> In both cases, the depth of the search space can be restricted by specifying a maximal path length. 4 Comparison with other Systems T DL is unique in that it implements many novel features not found in other systems like ALE <ref> [ 4 ] </ref> , LIFE [ 2 ] , or TFS [ 15 ] . Of course, these systems provide other features which are not present in our formalism.
Reference: [ 5 ] <author> Bob Carpenter. </author> <title> The Logic of Typed Feature Structures. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1992. </year>
Reference-contexts: Reconstructing the constraints which determine a type (represented as a feature structure) requires a complex operation called type expansion. This is comparable to Carpenter's totally well-typedness <ref> [ 5 ] </ref> . 3.4.1 Motivation In TDL, the motivation for type expansion is man ifold: * consistency At definition time, type expansion determines whether the set of type definitions (grammar and lexicon) is consistent. <p> Because our logic is much more richer, we immediately get the same result for TDL. However, one can choose in T DL between a complete expansion algorithm which may not terminate and a non-complete one to guarantee termination (see [ 2 ] and <ref> [ 5, Ch. 15 ] </ref> for similar proposals). The latter case heavily depends on the notion of resolvedness (see above).
Reference: [ 6 ] <author> Jochen Dorre and Michael Dorna. </author> <title> CUF|a formalism for linguistic knowledge representation. </title> <editor> In J. Dorre, editor, </editor> <title> Computational Aspects of Constraint-Based Linguistic Description. </title> <address> DYANA, </address> <year> 1993. </year>
Reference-contexts: Other proposals consider the integration of functional/relational dependencies into the formalism which make them in general Turing-complete (e.g., ALE [ 4 ] ). However the most important extension to formalisms consists of the incorporation of types, for instance in modern systems like TFS [ 15 ] , CUF <ref> [ 6 ] </ref> , or T DL [ 7 ] . Types are ordered hierarchically as it is known from object-oriented programming languages. This leads to multiple inheritance in the description of linguistic entities.
Reference: [ 7 ] <author> Hans-Ulrich Krieger and Ulrich Schafer. </author> <title> TDL|a type description language for HPSG. Part 2: user guide. </title> <type> Technical report, </type> <institution> DFKI, Saarbrucken, Ger-many, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: However the most important extension to formalisms consists of the incorporation of types, for instance in modern systems like TFS [ 15 ] , CUF [ 6 ] , or T DL <ref> [ 7 ] </ref> . Types are ordered hierarchically as it is known from object-oriented programming languages. This leads to multiple inheritance in the description of linguistic entities.
Reference: [ 8 ] <author> Joachim Laubsch. Zebu: </author> <title> A tool for specifying reversible LALR(1) parsers. </title> <type> Technical report, </type> <institution> Hewlett-Packard, </institution> <year> 1993. </year>
Reference-contexts: There exists a special instance definition facility to ease the writing of lexicon entries which differ from normal types in that they are not entered into the type hierarchy. Input given to TDL is parsed by a Zebu-generated LALR (1) parser <ref> [ 8 ] </ref> to allow for an intuitive, high-level input syntax and to abstract from uninteresting details imposed by the unifier and the underlying Lisp system.
Reference: [ 9 ] <author> Klaus Netter. </author> <title> Architecture and coverage of the DISCO grammar. </title> <editor> In S. Busemann and K. Harbusch, eds., </editor> <booktitle> Proc. of the DFKI Workshop on Natural Language Systems: Modularity and Re-Usability, </booktitle> <year> 1993. </year>
Reference-contexts: Work on T DL has started within the DISCO project of the DFKI [ 14 ] (this volume). The DISCO grammar currently consists of approx. 900 type specifications written in T DL and is the largest HPSG grammar for German <ref> [ 9 ] </ref> . The core engine of DISCO consists of T DL and the feature constraint solver UDiNe [ 3 ] . UDiNe itself is a powerful untyped unification machinery which allows the use of distributed disjunctions, general negation, and functional dependencies.
Reference: [ 10 ] <author> Peter Norvig. </author> <title> Techniques for automatic memoization with applications to context-free parsing. </title> <journal> Computational Linguistics, </journal> <volume> 17(1) </volume> <pages> 91-98, </pages> <year> 1991. </year>
Reference-contexts: Example: a &lt; NF b &lt; NF bb &lt; NF :a &lt; NF a ^ b &lt; NF a ^ :a &lt; NF a _ b &lt; NF a _ b _ c &lt; NF a _ 1 3.3.4 Memoization The memoization technique described in <ref> [ 10 ] </ref> has been adapted in order to reuse precomputed results of type simplification. The lexicographically sorted normal form guarantees fast access to precomputed type simplifications. Memoization results are also used by the recursive simplification algorithm to exploit pre computed results for subexpressions.
Reference: [ 11 ] <author> William C. Rounds and Alexis Manaster-Ramer. </author> <title> A logical version of functional grammar. </title> <booktitle> In Proceedings of the ACL, </booktitle> <pages> pages 89-96, </pages> <year> 1987. </year>
Reference-contexts: This simple idea leads to a massive reduction of the search space when dealing with incremental expansion (e.g., during parsing). It is worth noting that the satisfiability of fea-ture descriptions admitting recursive type equations/definitions is in general undecidable. Rounds and Manaster-Ramer <ref> [ 11 ] </ref> were the first having shown that a Kasper-Rounds logic enriched with recursive types allows one to encode a Turing machine. Because our logic is much more richer, we immediately get the same result for TDL.
Reference: [ 12 ] <author> Gert Smolka. </author> <title> A feature logic with subsorts. </title> <type> LILOG Report 33, </type> <institution> IBM Germany, Stuttgart, </institution> <year> 1988. </year>
Reference-contexts: The kernel of T DL (and of most other monotonic systems) can be given a set-theoretical semantics along the lines of <ref> [ 12 ] </ref> . It is easy to translate TDL statements into denotation-preserving expressions of Smolka's feature logic, thus viewing T DL only as syntactic sugar for a restricted (decidable) subset of first-order logic.
Reference: [ 13 ] <author> Hans Uszkoreit. </author> <title> Strategies for adding control information to declarative grammars. </title> <booktitle> In Proceedings of the ACL, </booktitle> <pages> pages 237-245, </pages> <year> 1991. </year>
Reference-contexts: Working in the type deduction paradigm enforces a grammar writer to replace the context-free back bone through recursive types. Here, parameter-ized delayed type expansion is the ticket to the world of controlled linguistic deduction <ref> [ 13 ] </ref> ; see Section 3.4. 3 TDL T DL is a unification-based grammar development environment and run time system supporting HPSG-like grammars. Work on T DL has started within the DISCO project of the DFKI [ 14 ] (this volume). <p> However, [ 15 ] has shown that type expansion without sophisticated control strategies is in many cases inefficient and moreover does not guarantee termination. 3.4.2 Controlled Type Expansion Uszkoreit <ref> [ 13 ] </ref> introduced a new strategy for linguistic processing called controlled linguistic deduction. His approach permits the specification of linguistic performance models without giving up the declarative basis of linguistic competence, especially monotonicity and completeness. The evaluation of both conjunctive and disjunctive constraints can be controlled in this framework.
Reference: [ 14 ] <author> H. Uszkoreit, R. Backofen, S. Busemann, A.K. Di-agne, E.A. Hinkelman, W. Kasper, B. Kiefer, H.- U. Krieger, K. Netter, G. Neumann, S. Oepen, and S.P. Spackman. </author> <title> DISCO|an HPSG-based NLP system and its application for appointment scheduling. </title> <booktitle> In Proceedings of COLING, </booktitle> <year> 1994. </year>
Reference-contexts: Work on T DL has started within the DISCO project of the DFKI <ref> [ 14 ] </ref> (this volume). The DISCO grammar currently consists of approx. 900 type specifications written in T DL and is the largest HPSG grammar for German [ 9 ] . The core engine of DISCO consists of T DL and the feature constraint solver UDiNe [ 3 ] . <p> The system as described in this paper has been implemented in Common Lisp and integrated in the DISCO environment <ref> [ 14 ] </ref> . The next major version of T DL will be integrated into a declarative specification language which allows linguists to define control knowledge that can be used during processing.
Reference: [ 15 ] <author> Remi Zajac. </author> <title> Inheritance and constraint-based grammar formalisms. </title> <journal> Computational Linguistics, </journal> <volume> 18(2) </volume> <pages> 159-182, </pages> <year> 1992. </year>
Reference-contexts: Other proposals consider the integration of functional/relational dependencies into the formalism which make them in general Turing-complete (e.g., ALE [ 4 ] ). However the most important extension to formalisms consists of the incorporation of types, for instance in modern systems like TFS <ref> [ 15 ] </ref> , CUF [ 6 ] , or T DL [ 7 ] . Types are ordered hierarchically as it is known from object-oriented programming languages. This leads to multiple inheritance in the description of linguistic entities. <p> Type expansion together with a sufficiently specified grammar then is responsible in both cases for constructing a fully specified feature structure which is maximal informative and compatible with the input. However, <ref> [ 15 ] </ref> has shown that type expansion without sophisticated control strategies is in many cases inefficient and moreover does not guarantee termination. 3.4.2 Controlled Type Expansion Uszkoreit [ 13 ] introduced a new strategy for linguistic processing called controlled linguistic deduction. <p> cases, the depth of the search space can be restricted by specifying a maximal path length. 4 Comparison with other Systems T DL is unique in that it implements many novel features not found in other systems like ALE [ 4 ] , LIFE [ 2 ] , or TFS <ref> [ 15 ] </ref> . Of course, these systems provide other features which are not present in our formalism.
References-found: 15

