URL: http://www.win.tue.nl/cs/pa/janz/article.ps.gz
Refering-URL: http://www.win.tue.nl/cs/pa/janz/publications.html
Root-URL: http://www.win.tue.nl
Abstract-found: 0
Intro-found: 1
Reference: [AC96] <author> David Aspinall and Adriana Compagnoni. </author> <title> Subtyping dependent types. </title> <booktitle> In 11th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> New Brunswick, New Jersey, USA, </address> <year> 1996. </year>
Reference-contexts: There are alternatives for this rule which are more general (see section 2.3.2), but (-B) has the best meta-theoretical properties. * Rules (-) and (-app) are the usual rules for lifting subtyping pointwise to higher levels in systems with type constructors, e.g. in F ! [SP97] and in P <ref> [AC96] </ref>. Pointwise lifting of means that function f is a subtype of function g iff for all x we have f x g x. <p> Rules (B-form) through (B-elim) and (-B) are not applicable, since R is empty. Rules (-) and (-) give subtyping on dependent types. The system P as described in <ref> [AC96] </ref> is roughly the same as this P T S . To be more precise: typing on programs in both systems is equivalent. Subtyping, and typing on datatype-constructors are not exactly the same (but this has no effect on programs, surprisingly). <p> To be more precise: typing on programs in both systems is equivalent. Subtyping, and typing on datatype-constructors are not exactly the same (but this has no effect on programs, surprisingly). Consider the context = Int : * ; Nat Int : * ; Bool : * . In <ref> [AC96] </ref> the judgment ` X : Int: Bool X : Nat: Bool is derivable, in our version of P it isn't. <p> On the other hand, in our version of P we have ` Int ! * Nat ! * and also ; even : Int ! * ` even : Nat ! * , but in <ref> [AC96] </ref> neither judgment is derivable. 2.3.6 The Calculus of Constructions, C The P T S C is specified as follows: S = f * ; 2 g; A = f ( * : 2 )g; R = f ( * ; * ); ( * ; 2 ); ( 2 ; <p> In a more liberal version, the domains of the functions could be different, as follows: ` A 0 A ; x : A 0 ` b b 0 (--liberal) This rule is introduced in <ref> [AC96] </ref>, but it does not have any effect on typing programs in P or in ! L . <p> So the sorts of all declared variables are computed once and forever. 52 5 Conclusions 5.1 Related work We compare our work with five systems with subtyping: kernel-Fun [CW85], F ! [SP97], P <ref> [AC96] </ref>, C as defined in [Che97] and F ! [CG97], which are all systems of the -cube [Bar92] extended with subtyping. <p> We also use the terminology defined in section 2.3. A common difference is that we consider a whole family of type systems, where each of the references considers one concrete system. As a consequence, <ref> [CW85, SP97, AC96, CG97] </ref> make a natural syntactical distinction between programs (in those accounts called terms) and datatype-constructors (types) and kinds. Also different typing judgments are distinguished corresponding to the syntactical categories of terms they concern. <p> Algorithms What are the subtyping and typing algorithms? We remark here that none of the references use triples in the syntax-directed typing judgments as we do. However, in <ref> [SP97, AC96, CG97] </ref> every level of terms (programs and datatype-constructors) has its own typing algorithm, just as it has its own typing judgment. <p> The final subtyping algorithms are the same, except for the Top-types. Also the typing algorithms are essentialy the same. * The calculus P <ref> [AC96] </ref> is equal to our calculus P when considering the derivable typing judgments concerning programs (section 2.3.5). The differences in both the derivable 53 subtyping judgments and the typing judgments concerning datatype-constructors are incon-sequential. This system is the first calculus discussed here with mutual dependency between programs and datatype-constructors. <p> The typing algorithms are essentially the same. * The system C as described in [Che97] is equal to our C (section 2.3.7). Both formu lations have no bounded quantifications. Here, programs and type-constructors are also mutually dependent, but the "trick" of splitting fi-reduction in <ref> [AC96] </ref> is not feasible any more, because there would be four kinds of reduction. But the typing judgments occurring in subtyping rules all have the simple form ` A : s. <p> We don't know whether this approach is applicable to P T S s. Minimality of typing is not proved for F ! . The subtyping algorithm of [CG97] is similar to our algorithm. One difference is that they postpone applications of the (-refl) rule (as in <ref> [AC96] </ref>). Another difference is that our algorithm relates terms in normal form, whereas theirs works with weak head normal forms, and postpones reduction as long as possible. <p> The last technical part of this chapter is the development of a type-checking algorithm for P T S s that are bijective and SN fioe . This algorithm extends that of [Pol93] with a subtyping algorithm and whoe-reduction; both appear in a similar form in [SP97] and <ref> [AC96] </ref>, which in their turn stem from work on F (e.g. see [CG92]). The main work here lies in reformulating the typing rules, so they become syntax-directed. The subtyping rules were already tamed before, so little work is needed there.
Reference: [Bar84] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus, Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North Holland, </publisher> <year> 1984. </year>
Reference-contexts: Proof sketch: Perform the following steps: 1. Show in untyped -calculus: If M fl&gt; fi N and N is in whfinf , then for some P in whfinf M fl&gt; whfi P , i.e. M has a whfinf . This can be proved using the so-called standardization theorem <ref> [Bar84] </ref>. 28 2. Transfer this result to P T S s, using a translation from P T S terms to untyped terms. 3.
Reference: [Bar92] <author> H. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In S. Abramsky, D. M. Gabbai, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2. </volume> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: The usual definition of pseudocontext <ref> [Bar92] </ref>, is more liberal; fewer demands are imposed on the variables. The typing rules, however, enforce our demands for well-formed contexts. We have chosen this definition of pseudocontext over the more usual definition, for the following reason. The subtyping rules may not depend on the typing judgment. <p> Most of these examples are systems of the -cube <ref> [Bar92] </ref>, extended with subtyping. The systems in the -cube all have S = f * ; 2 g; A = f ( * : 2 )g and R consists only of pairs. <p> So the sorts of all declared variables are computed once and forever. 52 5 Conclusions 5.1 Related work We compare our work with five systems with subtyping: kernel-Fun [CW85], F ! [SP97], P [AC96], C as defined in [Che97] and F ! [CG97], which are all systems of the -cube <ref> [Bar92] </ref> extended with subtyping.
Reference: [Bar96] <author> Gilles Barthe. </author> <title> Implicit coercions in type systems. </title> <booktitle> In Proceedings of the International Workshop Types '95, Torino, Italy, volume 1158 of Lecture Notes in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: We do not have subtyping on sorts (e.g. as in [Luo89]), or coercive subtyping, which means that subtyping between existing types can be defined with coercions <ref> [Bar96, Luo97] </ref>. For this thesis, the main application of the P T S s is the system ! L . In the following chapters we show how the features of ! L are used to write object-oriented programs and reason about such programs.
Reference: [BCGS91] <author> Val Breazu-Tannen, Thierry Coquand, Carl Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year> <note> Also in [GM94]. </note>
Reference-contexts: Proving SN fioe for C (from which SN fioe for all example systems in section 2.3 follows) might be done as follows. 1. Prove SN fi for C from SN fi for C , using a reduction preserving translation. This transla tion might proceed as in [CG92] or <ref> [BCGS91] </ref>, but the translation is more complicated here, because of lifted subtyping. On the other hand, we do not need to prove the translation is "coherent". 2. Prove SN oe for C . 3.
Reference: [Car88] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 176 </volume> <pages> 138-164, </pages> <year> 1988. </year>
Reference-contexts: Hence (-) and (-app) are not used in ! . The system ! is the standard extension of ! with subtyping, e.g. defined in [Com95]. ! is the pure fragment of <ref> [Car88] </ref>, where pure means that practical constructs like some primitive datatypes, records, variants and recursive types have been left out. 2.3.2 The polymorphic -calculus with subtyping The system 2 is specified by: S = f * ; 2 g; A = f ( * : 2 )g; R = f (
Reference: [Car91] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The presentation of the system would be more elegant (fewer rules) if we could consider both quantifications as instances of one more general quantification. One way of doing this is by introducing Top-types. We already discussed why we haven't done so. Another way is to introduce power types <ref> [Car91] </ref>. Intuitively, the power type Sub A (a) is the subset of A with only Subtypes of a as elements. The bounded quantification x a : A: B would now be written as x : Sub A (a): B.
Reference: [Car92] <author> Luca Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. </title> <type> Technical Report 81, </type> <institution> DEC Systems Research Center, </institution> <year> 1992. </year> <note> Also in [GM94]. </note>
Reference-contexts: So Top cannot eliminate the need for ordinary quantifications, hence the original reason for having Top is not valid for P T S s. An advantage of having Top is that records with subtyping can be encoded using Top <ref> [Car92] </ref>.
Reference: [CG92] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption, minimum typing and the type checking in F . Mathematical Structures in Computer Science, </title> <booktitle> 2(1) </booktitle> <pages> 55-91, </pages> <year> 1992. </year> <note> Also in [GM94]. </note>
Reference-contexts: Our rule, (-B) is the Fun rule [CW85] for bounded quantification which yields a decidable system. Instead of (-B), other rules have been proposed, that allow the bounds in the quantifications to be different. The first, and most natural, proposal was the rule of system F <ref> [CG92] </ref>: ` (x a : A: B) (x a 0 : A: B 0 ) (-B-contra) 8 However this rule renders subtyping undecidable [Pie94]. Another alternative for (-B), de-scribed in [CP94], turned out to destroy the minimal typing property [CP95]. <p> Proving SN fioe for C (from which SN fioe for all example systems in section 2.3 follows) might be done as follows. 1. Prove SN fi for C from SN fi for C , using a reduction preserving translation. This transla tion might proceed as in <ref> [CG92] </ref> or [BCGS91], but the translation is more complicated here, because of lifted subtyping. On the other hand, we do not need to prove the translation is "coherent". 2. Prove SN oe for C . 3. <p> Let us now consider the individual systems. * The calculus kernel-Fun (the pure fragment of Fun [CW85]) is equal to 2 , except we don't have their Top type. Kernel-Fun on its turn is equal to F <ref> [CG92] </ref>, except for the more liberal (-) rule present in the latter. Section 2.3.2 elaborates on these differences. <p> This algorithm extends that of [Pol93] with a subtyping algorithm and whoe-reduction; both appear in a similar form in [SP97] and [AC96], which in their turn stem from work on F (e.g. see <ref> [CG92] </ref>). The main work here lies in reformulating the typing rules, so they become syntax-directed. The subtyping rules were already tamed before, so little work is needed there. It is easy to convert the reformulated rules into a proper algorithm.
Reference: [CG97] <author> Adriana Compagnoni and Healfdene Goguen. </author> <title> Typed operational semantics for higher order subtyping. </title> <type> Technical Report ECS-LFCS-97-361, </type> <institution> University of Edinburgh, </institution> <year> 1997. </year>
Reference-contexts: However, in extensions of ! + these bounded abstractions can be useful, for example if some primitive operations on datatypes put certain subtyping demands on their arguments. The system ! + corresponds with the system F ! defined in <ref> [CG97] </ref>. There are two differences. First, we have no Top-types (see sections 2.3.2 and 2.3.3). <p> The fl whoe reduction reduces a term x b 1 : : : b n to c b 1 : : : b n if c is the bound of x. This reduction is the weak head restriction of the so-called -reduction found in <ref> [SP97, Che97, CG97] </ref>. We show basic properties of these reduction relations in lemmas 3.3.11 through 3.3.13, then relate fl&gt; whfioe and in lemmas 3.3.14 and 3.3.15, and prove Subject Reduction for fl whfioe and some consequences in lemmas 3.3.16 through 3.3.18. <p> So the sorts of all declared variables are computed once and forever. 52 5 Conclusions 5.1 Related work We compare our work with five systems with subtyping: kernel-Fun [CW85], F ! [SP97], P [AC96], C as defined in [Che97] and F ! <ref> [CG97] </ref>, which are all systems of the -cube [Bar92] extended with subtyping. <p> We also use the terminology defined in section 2.3. A common difference is that we consider a whole family of type systems, where each of the references considers one concrete system. As a consequence, <ref> [CW85, SP97, AC96, CG97] </ref> make a natural syntactical distinction between programs (in those accounts called terms) and datatype-constructors (types) and kinds. Also different typing judgments are distinguished corresponding to the syntactical categories of terms they concern. <p> Algorithms What are the subtyping and typing algorithms? We remark here that none of the references use triples in the syntax-directed typing judgments as we do. However, in <ref> [SP97, AC96, CG97] </ref> every level of terms (programs and datatype-constructors) has its own typing algorithm, just as it has its own typing judgment. <p> No concrete algorithms are given. Termination of these algorihmic rules is proved, so [Che97] has decidable subtyping, whereas we have this result only under the condition that SN fioe holds. No typing algorithm is given in [Che97]. * The system F ! <ref> [CG97] </ref> is equal to our ! + , except that we don't have Top-types and subtyping on bounded operator abstractions (section 2.3.4). The meta-theory developed in [CG97] follows a quite different approach than works men tioned above and our work; by giving a typed operational semantics they solve the mutual dependence <p> No typing algorithm is given in [Che97]. * The system F ! <ref> [CG97] </ref> is equal to our ! + , except that we don't have Top-types and subtyping on bounded operator abstractions (section 2.3.4). The meta-theory developed in [CG97] follows a quite different approach than works men tioned above and our work; by giving a typed operational semantics they solve the mutual dependence between the typing and subtyping judgments occurring in F ! . We don't know whether this approach is applicable to P T S s. <p> We don't know whether this approach is applicable to P T S s. Minimality of typing is not proved for F ! . The subtyping algorithm of <ref> [CG97] </ref> is similar to our algorithm. One difference is that they postpone applications of the (-refl) rule (as in [AC96]). Another difference is that our algorithm relates terms in normal form, whereas theirs works with weak head normal forms, and postpones reduction as long as possible.
Reference: [CH88] <author> Thierry Coquand and Gerard P. Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: S C is specified as follows: S = f * ; 2 g; A = f ( * : 2 )g; R = f ( * ; * ); ( * ; 2 ); ( 2 ; * ); ( 2 ; 2 )g; This is the Calculus of Constructions <ref> [CH88] </ref>, the most powerful system in the -cube, extended with subtyping and bounded quantifications. It includes all systems given above. In contrast to ! + , the bounded rule ( 2 ; 2 ) 2 R is quite useful here.
Reference: [Che97] <author> Gang Chen. </author> <title> Subtyping calculus of construction. </title> <booktitle> In Mathematical Foundations of Computer Science (FMCS'97), Bratislava, Slovakia, </booktitle> <volume> volume 1295, </volume> <pages> pages 189-198. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1997. </year>
Reference-contexts: So the only difference with C is the possibility to have subtyping declarations in the context, and to use these. The P T S C is exactly the same as the system defined in <ref> [Che97] </ref> (although Chen calls his system C , which we find rather unfortunate). An interesting observation in [Che97] is that the rule (-) is redundant in this system. 11 2.3.8 The programming logic ! L L is specified as follows: S = f * s ; 2 s ; * p <p> The P T S C is exactly the same as the system defined in <ref> [Che97] </ref> (although Chen calls his system C , which we find rather unfortunate). An interesting observation in [Che97] is that the rule (-) is redundant in this system. 11 2.3.8 The programming logic ! L L is specified as follows: S = f * s ; 2 s ; * p ; 2 p g R = f ( 2 s ; 2 s ); ( 2 s <p> The rule is more general to cater for the absence of the (-app) rule. In all other cases, the (-trans) rule is not essential, because it can be "pushed" upwards through the derivation, ending only in situations 1 or 2. This property, sometimes called "Transitivity Elimination" <ref> [Com95, Che97] </ref>. is in fact formally proved in lemma 3.1.15. <p> The fl whoe reduction reduces a term x b 1 : : : b n to c b 1 : : : b n if c is the bound of x. This reduction is the weak head restriction of the so-called -reduction found in <ref> [SP97, Che97, CG97] </ref>. We show basic properties of these reduction relations in lemmas 3.3.11 through 3.3.13, then relate fl&gt; whfioe and in lemmas 3.3.14 and 3.3.15, and prove Subject Reduction for fl whfioe and some consequences in lemmas 3.3.16 through 3.3.18. <p> So the sorts of all declared variables are computed once and forever. 52 5 Conclusions 5.1 Related work We compare our work with five systems with subtyping: kernel-Fun [CW85], F ! [SP97], P [AC96], C as defined in <ref> [Che97] </ref> and F ! [CG97], which are all systems of the -cube [Bar92] extended with subtyping. <p> The subtyping algorithm for P is similar to our algorithm, the main difference being that they postpone applications of the (-refl) rule as long as possible, while we apply this rule as soon as possible. The typing algorithms are essentially the same. * The system C as described in <ref> [Che97] </ref> is equal to our C (section 2.3.7). Both formu lations have no bounded quantifications. Here, programs and type-constructors are also mutually dependent, but the "trick" of splitting fi-reduction in [AC96] is not feasible any more, because there would be four kinds of reduction. <p> This method does not work for P T S s, since terms involved in the subtype relation are not always typable with a sort. The algorithmic derivation rules of <ref> [Che97] </ref> are our reformulated subtyping rules (definition 3.1.2) minus (-app), (-B) and (-). No concrete algorithms are given. Termination of these algorihmic rules is proved, so [Che97] has decidable subtyping, whereas we have this result only under the condition that SN fioe holds. No typing algorithm is given in [Che97]. * <p> The algorithmic derivation rules of <ref> [Che97] </ref> are our reformulated subtyping rules (definition 3.1.2) minus (-app), (-B) and (-). No concrete algorithms are given. Termination of these algorihmic rules is proved, so [Che97] has decidable subtyping, whereas we have this result only under the condition that SN fioe holds. No typing algorithm is given in [Che97]. * The system F ! [CG97] is equal to our ! + , except that we don't have Top-types and subtyping on bounded operator abstractions (section 2.3.4). <p> of <ref> [Che97] </ref> are our reformulated subtyping rules (definition 3.1.2) minus (-app), (-B) and (-). No concrete algorithms are given. Termination of these algorihmic rules is proved, so [Che97] has decidable subtyping, whereas we have this result only under the condition that SN fioe holds. No typing algorithm is given in [Che97]. * The system F ! [CG97] is equal to our ! + , except that we don't have Top-types and subtyping on bounded operator abstractions (section 2.3.4). <p> But ! L is not the sole application of P T S s. Many existing type systems with subtyping can be seen as members of our framework, viz. ! , F , F ! , F ! , P and the calculus of <ref> [Che97] </ref>. Other members, like C (section 2.3.6) are new systems which have promising features, both applicable in programming languages and in theorem proving. 54 We developed the meta-theory for P T S s, including Subject Reduction and Minimal Typing for functional systems.
Reference: [Com95] <author> Adriana B. Compagnoni. </author> <title> Higher-Order Subtyping with Intersection Types. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <address> The Netherlands, </address> <year> 1995. </year>
Reference-contexts: Hence (-) and (-app) are not used in ! . The system ! is the standard extension of ! with subtyping, e.g. defined in <ref> [Com95] </ref>. ! is the pure fragment of [Car88], where pure means that practical constructs like some primitive datatypes, records, variants and recursive types have been left out. 2.3.2 The polymorphic -calculus with subtyping The system 2 is specified by: S = f * ; 2 g; A = f ( * <p> The rule is more general to cater for the absence of the (-app) rule. In all other cases, the (-trans) rule is not essential, because it can be "pushed" upwards through the derivation, ending only in situations 1 or 2. This property, sometimes called "Transitivity Elimination" <ref> [Com95, Che97] </ref>. is in fact formally proved in lemma 3.1.15.
Reference: [CP94] <author> Giuseppe Castagna and Benjamin C. Pierce. </author> <title> Decidable bounded quantification. </title> <booktitle> In Proceedings of the 21st ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <address> Portland, Oregon. </address> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: The first, and most natural, proposal was the rule of system F [CG92]: ` (x a : A: B) (x a 0 : A: B 0 ) (-B-contra) 8 However this rule renders subtyping undecidable [Pie94]. Another alternative for (-B), de-scribed in <ref> [CP94] </ref>, turned out to destroy the minimal typing property [CP95]. Minimal typing (see theorem 3.3.19) is necessary to keep type-checking tractable. The system 2 is equal to kernel-Fun (the pure fragment of Fun [CW85]), except for their Top type.
Reference: [CP95] <author> Giuseppe Castagna and Benjamin C. Pierce. </author> <title> Corrigendum: Decidable bounded quantification. </title> <booktitle> In Proceedings of the 22nd ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <address> Portland, Oregon. </address> <publisher> ACM, </publisher> <year> 1995. </year>
Reference-contexts: Another alternative for (-B), de-scribed in [CP94], turned out to destroy the minimal typing property <ref> [CP95] </ref>. Minimal typing (see theorem 3.3.19) is necessary to keep type-checking tractable. The system 2 is equal to kernel-Fun (the pure fragment of Fun [CW85]), except for their Top type.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: E.g. take j Int : * ; Nat Int : * , then Nat Int : * 2 (-var) * = fi * (-conv) ` Int ! * Nat ! * * Rule (-B) is called the kernel-Fun rule, since it appears in Cardelli and Wegner's original Fun calculus <ref> [CW85] </ref>. <p> But the rules for bounded quantifications are used. There has been quite some debate about the subtyping rule for these bounded quantifications. The main concern is the meta-theory. Our rule, (-B) is the Fun rule <ref> [CW85] </ref> for bounded quantification which yields a decidable system. Instead of (-B), other rules have been proposed, that allow the bounds in the quantifications to be different. <p> Another alternative for (-B), de-scribed in [CP94], turned out to destroy the minimal typing property [CP95]. Minimal typing (see theorem 3.3.19) is necessary to keep type-checking tractable. The system 2 is equal to kernel-Fun (the pure fragment of Fun <ref> [CW85] </ref>), except for their Top type. The rules for the Top type in 2 would be: ` ok (Top-form) ` A : * (-Top) The second rule says that any datatype is a subtype of Top. <p> In practice, e.g. in the proof-assistant Yarrow, we maintain an extended context , and not just a context . So the sorts of all declared variables are computed once and forever. 52 5 Conclusions 5.1 Related work We compare our work with five systems with subtyping: kernel-Fun <ref> [CW85] </ref>, F ! [SP97], P [AC96], C as defined in [Che97] and F ! [CG97], which are all systems of the -cube [Bar92] extended with subtyping. <p> We also use the terminology defined in section 2.3. A common difference is that we consider a whole family of type systems, where each of the references considers one concrete system. As a consequence, <ref> [CW85, SP97, AC96, CG97] </ref> make a natural syntactical distinction between programs (in those accounts called terms) and datatype-constructors (types) and kinds. Also different typing judgments are distinguished corresponding to the syntactical categories of terms they concern. <p> Let us now consider the individual systems. * The calculus kernel-Fun (the pure fragment of Fun <ref> [CW85] </ref>) is equal to 2 , except we don't have their Top type. Kernel-Fun on its turn is equal to F [CG92], except for the more liberal (-) rule present in the latter. Section 2.3.2 elaborates on these differences.
Reference: [GM94] <author> Carl A. Gunter and John C. Mitchell. </author> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design. </title> <publisher> The MIT Press, </publisher> <year> 1994. </year> <month> 56 </month>
Reference: [KvOvR93] <author> Jan Willem Klop, Vincent van Oostrom, and Femke van Raamsdonk. </author> <title> Combinatory reduction systems: Introduction and survey. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 121(1-2):279-308, </address> <year> 1993. </year>
Reference-contexts: Alternatively, this property can be proved by considering the terms and reduction of P T S s as an orthogonal Combinatory Reduction System <ref> [KvOvR93] </ref>. 2 3.1 Properties of subtyping Unfortunately, the subtyping rules given in definition 2.2.4 are quite intractable; it is hard to prove properties about them. They are so intractable, because there is some redundancy in the subtyping rules; there can be several quite different derivations of the same subtyping judgment.
Reference: [Luo89] <author> Zhaohui Luo. </author> <title> ECC: an Extended Calculus of Constructions. </title> <booktitle> In Proceedings of IEEE 4th Annual Symposium on Logic in Computer Science (LICS'89), Asilomar, </booktitle> <address> Califor-nia, </address> <year> 1989. </year>
Reference-contexts: We could allow subtyping on sorts, by introducing a set A of subtyping axioms for sorts, with rule: (s 1 s 2 ) 2 A (-sort) Adding A allows us to consider the extended calculus of constructions <ref> [Luo89] </ref>, with its infinity hierarchy of sorts and sort inclusion, as a P T S (ignoring the strong sum types). <p> No typing algorithm (for programs) is given. 5.2 Summary and conclusion In this chapter we defined the framework of Pure Type Systems with Subtyping, an extension of the P T Ss with subtyping, bounded quantification and lifted subtyping. We do not have subtyping on sorts (e.g. as in <ref> [Luo89] </ref>), or coercive subtyping, which means that subtyping between existing types can be defined with coercions [Bar96, Luo97]. For this thesis, the main application of the P T S s is the system ! L .
Reference: [Luo97] <author> Zhaohui Luo. </author> <title> Coercive subtyping in type theory. </title> <booktitle> In Proceedings of the 10th International Workshop on Computer Science Logic (CSL '96), Utrecht, The Netherlands, volume 1258 of Lecture Notes in Computer Science, </booktitle> <pages> pages 275-296, </pages> <year> 1997. </year>
Reference-contexts: We do not have subtyping on sorts (e.g. as in [Luo89]), or coercive subtyping, which means that subtyping between existing types can be defined with coercions <ref> [Bar96, Luo97] </ref>. For this thesis, the main application of the P T S s is the system ! L . In the following chapters we show how the features of ! L are used to write object-oriented programs and reason about such programs.
Reference: [Pie94] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <journal> Information and Computation, </journal> <volume> 112(1) </volume> <pages> 131-165, </pages> <year> 1994. </year> <note> Also in [GM94]. </note>
Reference-contexts: The first, and most natural, proposal was the rule of system F [CG92]: ` (x a : A: B) (x a 0 : A: B 0 ) (-B-contra) 8 However this rule renders subtyping undecidable <ref> [Pie94] </ref>. Another alternative for (-B), de-scribed in [CP94], turned out to destroy the minimal typing property [CP95]. Minimal typing (see theorem 3.3.19) is necessary to keep type-checking tractable. The system 2 is equal to kernel-Fun (the pure fragment of Fun [CW85]), except for their Top type.
Reference: [Pol92] <author> R. Pollack. </author> <title> Typechecking in pure type systems. </title> <editor> In Eds Bengt Nordstrom, Kent Petersson, and Gordon Plotkin, editors, </editor> <booktitle> Proceedings of the 1992 Workshop on Types for Proofs and Programs, Bastad, </booktitle> <pages> pages 271-288, </pages> <year> 1992. </year> <note> Available from http://www.dcs.ed.ac.uk/lfcsinfo/research/types_bra/proc/index.html </note>
Reference-contexts: In <ref> [Pol92] </ref> a natural algorithm is given, but it works only on a small set of the so-called semi-full P T Ss (from the - cube, only P and C are semi-full). <p> Section 4.5 tells how to interpret the sd rules as an algorithm, and section 4.6 shows for a class of P T S s that this algorithm is terminating. 4.1 Completeness is problematic As noted by <ref> [Pol92, vBJMP94, Sev96, Pol93] </ref>, proofs of completeness of syntax-directed typing rules for P T Ss (and also for P T S s) are problematic because of the (-intro) rule: ; x : B ` c : C ` (x : B: C) : s (-intro) The most naive sd version of <p> The type-as-subject problem is solved in the algorithm of <ref> [Pol92] </ref> by replacing the premise ` sd (x : B: C) : S by a simple syntactical condition on C, and in [vBJMP94] and [Sev96] by checking this condition in a slightly different derivation system. The type-as-subject problem occurs at a number of other places.
Reference: [Pol93] <author> Erik Poll. </author> <title> A typechecker for bijective pure type systems. </title> <type> Technical Report 93-22, </type> <institution> Eindhoven University of Technology, </institution> <year> 1993. </year>
Reference-contexts: Considering the fact that P T S s have roughly twice as many typing rules as P T Ss, this approach is unworkable here. We choose for the approach given in <ref> [Pol93] </ref>, that works for all so-called bijective P T Ss, which includes all systems in the -cube and ! L . The rest of the introduction explains this approach, adapted to P T S s. <p> It is straightforward to prove soundness, but completeness is problematic, as we will show in section 4.1. We use the following tricks, from <ref> [Pol93] </ref>, to tackle this problem. 34 1. Consider syntax-directed typing judgments with not only the type, but also the sort of the term, so those judgments have the form ` sd a : A : s 2. Integrate the -formation rule intro the syntax-directed -introduction rule. <p> Section 4.5 tells how to interpret the sd rules as an algorithm, and section 4.6 shows for a class of P T S s that this algorithm is terminating. 4.1 Completeness is problematic As noted by <ref> [Pol92, vBJMP94, Sev96, Pol93] </ref>, proofs of completeness of syntax-directed typing rules for P T Ss (and also for P T S s) are problematic because of the (-intro) rule: ; x : B ` c : C ` (x : B: C) : s (-intro) The most naive sd version of <p> In the proof of Minimal Typing of P T S s we encountered it (page 27, problem 1). It also occurs when one tries to prove the so-called Expansion Postponement property [vBJMP94, Pol98]. 36 4.2 Syntax-directed rules Most definitions of this section are adapted from <ref> [Pol93] </ref>. Before we give the typing rules, we specify for which systems the typing rules are meant. <p> The last technical part of this chapter is the development of a type-checking algorithm for P T S s that are bijective and SN fioe . This algorithm extends that of <ref> [Pol93] </ref> with a subtyping algorithm and whoe-reduction; both appear in a similar form in [SP97] and [AC96], which in their turn stem from work on F (e.g. see [CG92]). The main work here lies in reformulating the typing rules, so they become syntax-directed.
Reference: [Pol98] <author> Erik Poll. </author> <title> Theoretical pearl: Expansion postponement for normalising pure type systems. </title> <journal> Journal of Functional Programming, </journal> <volume> 8(10) </volume> <pages> 89-96, </pages> <year> 1998. </year>
Reference-contexts: The type-as-subject problem occurs at a number of other places. In the proof of Minimal Typing of P T S s we encountered it (page 27, problem 1). It also occurs when one tries to prove the so-called Expansion Postponement property <ref> [vBJMP94, Pol98] </ref>. 36 4.2 Syntax-directed rules Most definitions of this section are adapted from [Pol93]. Before we give the typing rules, we specify for which systems the typing rules are meant.
Reference: [Sev96] <author> Paula Severi. </author> <title> Normalisation in Lambda Calculus and its relation to Type Inference. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1996. </year>
Reference-contexts: In [Pol92] a natural algorithm is given, but it works only on a small set of the so-called semi-full P T Ss (from the - cube, only P and C are semi-full). Another approach is chosen in both [vBJMP94] (section 6) and <ref> [Sev96] </ref>, that give similar algorithms, that work for all functional P T Ss, but both algorithms use an auxiliary algorithm. Considering the fact that P T S s have roughly twice as many typing rules as P T Ss, this approach is unworkable here. <p> Section 4.5 tells how to interpret the sd rules as an algorithm, and section 4.6 shows for a class of P T S s that this algorithm is terminating. 4.1 Completeness is problematic As noted by <ref> [Pol92, vBJMP94, Sev96, Pol93] </ref>, proofs of completeness of syntax-directed typing rules for P T Ss (and also for P T S s) are problematic because of the (-intro) rule: ; x : B ` c : C ` (x : B: C) : s (-intro) The most naive sd version of <p> The type-as-subject problem is solved in the algorithm of [Pol92] by replacing the premise ` sd (x : B: C) : S by a simple syntactical condition on C, and in [vBJMP94] and <ref> [Sev96] </ref> by checking this condition in a slightly different derivation system. The type-as-subject problem occurs at a number of other places. In the proof of Minimal Typing of P T S s we encountered it (page 27, problem 1).
Reference: [SP97] <author> Martin Steffen and Benjamin C. Pierce. </author> <title> Higher-order subtyping. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 176(1-2):235-282, </address> <year> 1997. </year>
Reference-contexts: But first we make precise which form of subtyping we have. As suggested in section ??, we have subtyping as in F ! <ref> [SP97] </ref>. This has the following three features: * A subtyping judgment ` A B, induced by subtyping rules, and the subsumption rule: ` a : A ` A B (subsum) * Bounded quantifications, e.g. <p> There are alternatives for this rule which are more general (see section 2.3.2), but (-B) has the best meta-theoretical properties. * Rules (-) and (-app) are the usual rules for lifting subtyping pointwise to higher levels in systems with type constructors, e.g. in F ! <ref> [SP97] </ref> and in P [AC96]. Pointwise lifting of means that function f is a subtype of function g iff for all x we have f x g x. <p> have ` methodOnA SigB b : Object SigB so the methodOnA working on b delivers a new object in class B. 9 All derivation rules for P T S s are used in ! , including (-) and (-app) for lifting subtyping to datatype-constructors. ! is equal to F ! <ref> [SP97] </ref>, except that F ! has a family of Top-types, for every kind one, e.g. Top ( * ), which corresponds to Top in the previous section, and Top ( * ! * ). <p> The fl whoe reduction reduces a term x b 1 : : : b n to c b 1 : : : b n if c is the bound of x. This reduction is the weak head restriction of the so-called -reduction found in <ref> [SP97, Che97, CG97] </ref>. We show basic properties of these reduction relations in lemmas 3.3.11 through 3.3.13, then relate fl&gt; whfioe and in lemmas 3.3.14 and 3.3.15, and prove Subject Reduction for fl whfioe and some consequences in lemmas 3.3.16 through 3.3.18. <p> On the other hand, we do not need to prove the translation is "coherent". 2. Prove SN oe for C . 3. Combine the results, along the lines of the proof of SN fioe for F ! in <ref> [SP97] </ref>. In practice, e.g. in the proof-assistant Yarrow, we maintain an extended context , and not just a context . <p> So the sorts of all declared variables are computed once and forever. 52 5 Conclusions 5.1 Related work We compare our work with five systems with subtyping: kernel-Fun [CW85], F ! <ref> [SP97] </ref>, P [AC96], C as defined in [Che97] and F ! [CG97], which are all systems of the -cube [Bar92] extended with subtyping. <p> We also use the terminology defined in section 2.3. A common difference is that we consider a whole family of type systems, where each of the references considers one concrete system. As a consequence, <ref> [CW85, SP97, AC96, CG97] </ref> make a natural syntactical distinction between programs (in those accounts called terms) and datatype-constructors (types) and kinds. Also different typing judgments are distinguished corresponding to the syntactical categories of terms they concern. <p> Algorithms What are the subtyping and typing algorithms? We remark here that none of the references use triples in the syntax-directed typing judgments as we do. However, in <ref> [SP97, AC96, CG97] </ref> every level of terms (programs and datatype-constructors) has its own typing algorithm, just as it has its own typing judgment. <p> Section 2.3.2 elaborates on these differences. We ignore the meta-theoretical part and the algorithmic part of the comparison, because those are treated below for the more general F ! , and accounts of the meta-theory for the second-order calculus use the undecidable F . * The calculus F ! <ref> [SP97] </ref> is equal to our ! , except we don't have their Top types (section 2.3.3). As noted in the introduction, they first develop meta-theory about typing datatype-constructors, then about the subtyping judgment and finally about typing programs. <p> As noted in the introduction, they first develop meta-theory about typing datatype-constructors, then about the subtyping judgment and finally about typing programs. This cannot be done in general for P T S s, since typing for the various categories of terms is mutually dependent. In <ref> [SP97] </ref> the Minimal Typing property is proved using the typing algorithm, whereas we prove this property separately, because our typing algorithm works only for the bijective SN fioe P T S s. The final subtyping algorithms are the same, except for the Top-types. <p> Subject Reduction with respect to fi 1 . This careful distinction of different kinds of reduction is very hard in P T S s, since we cannot syntactically distinguish programs and type-constructors (these notions themselves make little sense in the general P T S s). Just as in <ref> [SP97] </ref> the Minimal Typing property is proved using the typing algorithm, whereas we prove this property separately. <p> The last technical part of this chapter is the development of a type-checking algorithm for P T S s that are bijective and SN fioe . This algorithm extends that of [Pol93] with a subtyping algorithm and whoe-reduction; both appear in a similar form in <ref> [SP97] </ref> and [AC96], which in their turn stem from work on F (e.g. see [CG92]). The main work here lies in reformulating the typing rules, so they become syntax-directed. The subtyping rules were already tamed before, so little work is needed there.
Reference: [vBJMP94] <author> L.S. van Benthem Jutting, James McKinna, and Randy Pollack. </author> <title> Checking algorithms for pure type systems. </title> <editor> In H. Barendregt and T. Nipkov, editors, </editor> <booktitle> Proceedings of Types for Proofs and Programs, International Workshop Types '93, Nijmegen, The Netherlands, volume 806 of Lecture Notes in Computer Science, </booktitle> <pages> pages 19-61, </pages> <year> 1994. </year> <month> 57 </month>
Reference-contexts: In [Pol92] a natural algorithm is given, but it works only on a small set of the so-called semi-full P T Ss (from the - cube, only P and C are semi-full). Another approach is chosen in both <ref> [vBJMP94] </ref> (section 6) and [Sev96], that give similar algorithms, that work for all functional P T Ss, but both algorithms use an auxiliary algorithm. Considering the fact that P T S s have roughly twice as many typing rules as P T Ss, this approach is unworkable here. <p> Section 4.5 tells how to interpret the sd rules as an algorithm, and section 4.6 shows for a class of P T S s that this algorithm is terminating. 4.1 Completeness is problematic As noted by <ref> [Pol92, vBJMP94, Sev96, Pol93] </ref>, proofs of completeness of syntax-directed typing rules for P T Ss (and also for P T S s) are problematic because of the (-intro) rule: ; x : B ` c : C ` (x : B: C) : s (-intro) The most naive sd version of <p> The type-as-subject problem is solved in the algorithm of [Pol92] by replacing the premise ` sd (x : B: C) : S by a simple syntactical condition on C, and in <ref> [vBJMP94] </ref> and [Sev96] by checking this condition in a slightly different derivation system. The type-as-subject problem occurs at a number of other places. In the proof of Minimal Typing of P T S s we encountered it (page 27, problem 1). <p> The type-as-subject problem occurs at a number of other places. In the proof of Minimal Typing of P T S s we encountered it (page 27, problem 1). It also occurs when one tries to prove the so-called Expansion Postponement property <ref> [vBJMP94, Pol98] </ref>. 36 4.2 Syntax-directed rules Most definitions of this section are adapted from [Pol93]. Before we give the typing rules, we specify for which systems the typing rules are meant.
References-found: 27

