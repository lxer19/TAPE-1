URL: http://www.cs.wisc.edu/~fischer/ftp/pub/cao/pfpaper.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/cao/
Root-URL: 
Title: Memory Reference Behavior and Page Replacement for Modern Applications  
Abstract: We present a study of memory reference behaviors of modern applications and performance of page replacement policies in virtual memory systems. We begin with memory reference traces for fourteen nontrivial programs. These traces, when plotted in the form of space-time graphs|address space references as a function of process execution time|reveal strikingly different patterns for different applications. We then examine how the dominant current page replacement policy (LRU) compares to the optimal policy (OPT). We find that LRU performs acceptably for many programs, but for a significant class of applications, LRU performs quite poorly. To remedy LRU's deficiencies, we have synthesized a new replacement algorithm, SEQ. SEQ is designed to handle programs that suffer under LRU, while at the same time not penalize programs which do well under LRU. Trace driven simulation reveals that SEQ does in fact perform well in practice, often coming within five to ten percent more page faults than OPT. We then generalize SEQ to handle multi-process global memory replacements. Our simulation of concurrent applications show that global SEQ performs as well as or significantly better than global LRU for this workload. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, P.J. Denning, and J.D. Ullman. </author> <title> Principles of optimal page replacement. </title> <journal> In Journal of ACM, </journal> <volume> vol. 18, </volume> <pages> pages 80-93, </pages> <month> January </month> <year> 1971. </year>
Reference-contexts: Among these theoretical studies, of particular interests to our study are the ones on program behavior modelling and optimal online algorithms for each model. The models include independent reference <ref> [1] </ref>, LRU stack [30], working set [11], access graphs [5], Markov model [21]. For each of these models optimal online algorithms are found, for example, LRU for LRU-stack model [16], access-graph algorithm [18], and Markov paging algorithm [21].
Reference: [2] <author> Maurice J. Bach. </author> <title> The Design of the UNIX Operating System. </title> <booktitle> Prentice-Hall Software Series, </booktitle> <year> 1986. </year>
Reference-contexts: The studies show that the performance of the approximation algorithms is similar to that of LRU. Most operating systems today uses CLOCK or a variant of it <ref> [10, 19, 2] </ref>. Though not reported in this paper, we performed simulations of FIFO and a simple version of CLOCK algorithm on our traces. Our findings are similar to the early studies: FIFO generally performs worse than LRU, and CLOCK performs similar to LRU across the applications.
Reference: [3] <author> L. A. Belady. </author> <title> A study of replacement algorithms for virtural storage. </title> <journal> IBM Systems Journal, </journal> <pages> pages 5 78-101, </pages> <year> 1966. </year>
Reference-contexts: Curves are serial and concurrent executions under LRU and SEQ policies. 26 swim and trygtsl. Curves are serial and concurrent executions under LRU and SEQ policies. 27 6 Related Work Operating systems researchers have investigated the memory management problem for over thirty years. Belady's paper in 1966 <ref> [3] </ref> articulated the primary purpose of virtual memory paging: manage physical memory automatically so that programmers do not have to divide a program into separate portions (overlays) and bring them into memory under program control. The paper [3] also introduced the optimal o*ine replacement algorithm, which is the OPT algorithm used <p> Belady's paper in 1966 <ref> [3] </ref> articulated the primary purpose of virtual memory paging: manage physical memory automatically so that programmers do not have to divide a program into separate portions (overlays) and bring them into memory under program control. The paper [3] also introduced the optimal o*ine replacement algorithm, which is the OPT algorithm used in this study. Since then there have been extensive theoretical studies on the page replacement algorithms; a good survey can be found in [16]. <p> A good survey can be found in [12, 32]. Except a few early studies [22], most experimental studies focused on efficient implementation of LRU page replacement algorithms in practice. A number of approximation algorithms, FIFO with second chance [4], CLOCK algorithms <ref> [3] </ref>, etc. have been proposed and implemented in various systems [8, 24, 31]. The studies show that the performance of the approximation algorithms is similar to that of LRU. Most operating systems today uses CLOCK or a variant of it [10, 19, 2].
Reference: [4] <author> A. </author> <title> Bensoussan, C.T. Clingen, and R.C. Daley. The multics virtual memory: Concepts and design. </title> <journal> In Communications of the ACM, </journal> <volume> 15(5), </volume> <pages> pages 308-318, </pages> <month> May </month> <year> 1972. </year>
Reference-contexts: Along with the theoretical studies there have been extensive experimental studies. A good survey can be found in [12, 32]. Except a few early studies [22], most experimental studies focused on efficient implementation of LRU page replacement algorithms in practice. A number of approximation algorithms, FIFO with second chance <ref> [4] </ref>, CLOCK algorithms [3], etc. have been proposed and implemented in various systems [8, 24, 31]. The studies show that the performance of the approximation algorithms is similar to that of LRU. Most operating systems today uses CLOCK or a variant of it [10, 19, 2].
Reference: [5] <author> A. Borodin, S. Irani, P. Raghavan, and B. Schieber. </author> <title> Competitive paging with locality of reference. </title> <booktitle> In Proc. 23rd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 249-259, </pages> <year> 1991. </year>
Reference-contexts: Among these theoretical studies, of particular interests to our study are the ones on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [30], working set [11], access graphs <ref> [5] </ref>, Markov model [21]. For each of these models optimal online algorithms are found, for example, LRU for LRU-stack model [16], access-graph algorithm [18], and Markov paging algorithm [21]. Our study suggests that the access-graph model might be the appropriate model for the regular-pattern applications.
Reference: [6] <author> D.C. Burger, A. Kagi, and J.R. Goodman. </author> <title> Memory bandwidth limitations of future microprocessors. </title> <booktitle> In The 23rd Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Also, there is also no clear "working-sets", and no clear "knees" in the fault-curve, contrary to what is observed in [12]. Recently there have been a number of studies on applications' memory reference behavior in the context of cache management in computer architecture. One study <ref> [6] </ref> (on out-of-chip bandwidth requirement) confirmed that there is a significant difference in cache miss ratios under LRU and under OPT replacement policies. Another study on the similar topic [26] plotted a space-time graph for some SPEC95 benchmarks at cache line level.
Reference: [7] <author> Pei Cao, Edward W. Felten, Anna R. Karlin, and Kai Li. </author> <title> A study of integrated prefetching and caching strategies. </title> <booktitle> In Proc. 1995 ACM SIG-METRICS, </booktitle> <pages> pages 188-197, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Though we only talked about replacement policy in this paper, it is obvious that sequence detection can be used for prefetching as well. How to balance the prefetching and caching, though, is a complicated issue that needs further study <ref> [7] </ref>. Recent research projects on application-controlled kernels show the potentials of application-specific replacement policies [34, 17, 25, 23]. However, most of those studies focus on letting applications inform kernel of their access patterns, instead of having operating systems detect them at run-time (as in the SEQ algorithm).
Reference: [8] <author> R. W. Carr and J. L. Hennessy. </author> <title> WSCLOCK | A simple and effective algorithm for virtual memory management. </title> <booktitle> In Proc. 8th SOSP, Operating Sys. Review, </booktitle> <pages> page 87, </pages> <month> December </month> <year> 1981. </year> <title> Published as Proc. 8th SOSP, Operating Sys. </title> <journal> Review, </journal> <volume> volume 15, number 5. </volume>
Reference-contexts: Except a few early studies [22], most experimental studies focused on efficient implementation of LRU page replacement algorithms in practice. A number of approximation algorithms, FIFO with second chance [4], CLOCK algorithms [3], etc. have been proposed and implemented in various systems <ref> [8, 24, 31] </ref>. The studies show that the performance of the approximation algorithms is similar to that of LRU. Most operating systems today uses CLOCK or a variant of it [10, 19, 2].
Reference: [9] <author> Robert F. Cmelik and David Keppel. Shade: </author> <title> A fast instruction-set simulator for execution profiling. </title> <type> Technical Report SMLI 93-12, </type> <institution> UWCSE 93-06-06, Sun Microsystems Labs, </institution> <year> 1993. </year>
Reference-contexts: wave5 (SPECfp95):, 2-D relativistic electromagnetic particle-in-cell simulation code for various plasma phenomena, written in Fortran, running the train input from SPEC; A brief summary of these applications, including their total data set size and instruction counts, appear in Table 1. 2.1 Trace Collection We collected memory reference traces using Shade <ref> [9] </ref>. Shade is an instruction-level simulator for SPARC that allows one to write a processing routine to examine each application instruction before it executes. We observe PC values and virtual addresses for load and store instructions.
Reference: [10] <author> Helen Custer. </author> <title> Inside Windows NT. </title> <publisher> Microsoft Press, </publisher> <year> 1992. </year>
Reference-contexts: The studies show that the performance of the approximation algorithms is similar to that of LRU. Most operating systems today uses CLOCK or a variant of it <ref> [10, 19, 2] </ref>. Though not reported in this paper, we performed simulations of FIFO and a simple version of CLOCK algorithm on our traces. Our findings are similar to the early studies: FIFO generally performs worse than LRU, and CLOCK performs similar to LRU across the applications.
Reference: [11] <author> Peter J. Denning. </author> <title> The working set model for program behavior. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 323-333, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: Among these theoretical studies, of particular interests to our study are the ones on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [30], working set <ref> [11] </ref>, access graphs [5], Markov model [21]. For each of these models optimal online algorithms are found, for example, LRU for LRU-stack model [16], access-graph algorithm [18], and Markov paging algorithm [21]. Our study suggests that the access-graph model might be the appropriate model for the regular-pattern applications.
Reference: [12] <author> Peter J. Denning. </author> <title> Working sets past and present. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):64-84, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: However, in concurrent execution all applications compete for memory, so each has less than the total memory size, possibly leading to an increase in total page faults. This is essentially the load control problem describing in Denning's Working Set paper <ref> [12] </ref>. In our study, we are curious as to how concurrent executions of these applications compare to serial execution, that is, whether multiprocessing is a win or loss under the different replacement policies. <p> Part of our future work is to investigate applying the general access-graph algorithms for more complicated patterns in applications. Along with the theoretical studies there have been extensive experimental studies. A good survey can be found in <ref> [12, 32] </ref>. Except a few early studies [22], most experimental studies focused on efficient implementation of LRU page replacement algorithms in practice. A number of approximation algorithms, FIFO with second chance [4], CLOCK algorithms [3], etc. have been proposed and implemented in various systems [8, 24, 31]. <p> Our observations of program memory behavior arrive at different conclusions from the early research results in this area, such as those described in Den-ning's excellent survey on memory management studies up to the 80's <ref> [12] </ref>. The biggest difference is that the applications we investigated do not have signifi cant "phase-transition" behavior, and their reference patterns tend to be the same throughout execution (i.e. no phases). <p> Also, there is also no clear "working-sets", and no clear "knees" in the fault-curve, contrary to what is observed in <ref> [12] </ref>. Recently there have been a number of studies on applications' memory reference behavior in the context of cache management in computer architecture. One study [6] (on out-of-chip bandwidth requirement) confirmed that there is a significant difference in cache miss ratios under LRU and under OPT replacement policies.
Reference: [13] <author> David L. Dill, Andreas J. Drexler, Alan J. Hu, and C. Han Yang. </author> <title> Protocol verification as a hardware design aid. </title> <booktitle> In Proc. 1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <pages> pages 522-525. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1992. </year>
Reference-contexts: the GCC benchmark; * gnuplot: graph plotting software, processing an address space trace to generate a PostScript im age like those shown in Section 2.2 below. * m88ksim (SPECint95): cycle-level simulator for the Motorola 88100 microprocessor, written in C, using the ref input set; * murphi: protocol verifier tool Murphi <ref> [13] </ref> version 2.9.1, verifying a locking protocol (sample input file mcslock1.m); the verifier compiles the specification into a C++ program; we tested the resulting C++ program, not the compiler itself; * perl: interpreted scripting language, version 5.001, written in C, executing the jumble script from SPECint95 version of the perl benchmark;
Reference: [14] <author> Eric Ristad et. al. </author> <note> untitled working paper. Octo-ber 1996. 29 </note>
Reference-contexts: Equations; written in Fortran, run with train input set; * coral: a deductive database system [28], written in C++, evaluating a nested query; * es: microstructure electrostatics simulation used in fluid simulation [15], written in C, computing boundary integral equations for an N-body problem; * fgm: finite growth model test <ref> [14] </ref> (compares greyscale images), written in C; * gcc: GNU CC version 2.6.3, compiling the preprocessed file cccp.i from the SPEC95 distribution for that version of the GCC benchmark; * gnuplot: graph plotting software, processing an address space trace to generate a PostScript im age like those shown in Section 2.2
Reference: [15] <author> F. Fraenkle, M.D. Hill, and S. Kim. </author> <title> Solv--ing microstructure electrostatics on a proposed parallel computer. </title> <journal> Computers chem. Engng, </journal> 19(6/7):743-757, 1995. 
Reference-contexts: and their sources are as follows. * applu (SPECfp95): floating point intensive; solves five coupled parabolic/elliptic Partial Differential Equations; written in Fortran, run with train input set; * coral: a deductive database system [28], written in C++, evaluating a nested query; * es: microstructure electrostatics simulation used in fluid simulation <ref> [15] </ref>, written in C, computing boundary integral equations for an N-body problem; * fgm: finite growth model test [14] (compares greyscale images), written in C; * gcc: GNU CC version 2.6.3, compiling the preprocessed file cccp.i from the SPEC95 distribution for that version of the GCC benchmark; * gnuplot: graph plotting
Reference: [16] <author> Edward G. Coffman, Jr. and Peter J. Denning. </author> <title> Operating Systems Theory. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1973. </year>
Reference-contexts: The paper [3] also introduced the optimal o*ine replacement algorithm, which is the OPT algorithm used in this study. Since then there have been extensive theoretical studies on the page replacement algorithms; a good survey can be found in <ref> [16] </ref>. Among these theoretical studies, of particular interests to our study are the ones on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [30], working set [11], access graphs [5], Markov model [21]. <p> The models include independent reference [1], LRU stack [30], working set [11], access graphs [5], Markov model [21]. For each of these models optimal online algorithms are found, for example, LRU for LRU-stack model <ref> [16] </ref>, access-graph algorithm [18], and Markov paging algorithm [21]. Our study suggests that the access-graph model might be the appropriate model for the regular-pattern applications. Indeed, the SEQ algorithm can be viewed as an attempt to apply the access-graph algorithms for a simple graph: sequences of pages.
Reference: [17] <author> K. Harty and D. R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proc. Fifth International Conf. on Architectural Support for Programming Languages and Operating Systems, SIGOPS Operating Systems Review Special Issue, </booktitle> <volume> volume 26, </volume> <pages> page 187, </pages> <address> Boston, MA, </address> <month> October 12-15 </month> <year> 1992. </year>
Reference-contexts: How to balance the prefetching and caching, though, is a complicated issue that needs further study [7]. Recent research projects on application-controlled kernels show the potentials of application-specific replacement policies <ref> [34, 17, 25, 23] </ref>. However, most of those studies focus on letting applications inform kernel of their access patterns, instead of having operating systems detect them at run-time (as in the SEQ algorithm).
Reference: [18] <author> S. Irani, A. Karlin, and S. Phillips. </author> <title> Strongly competitive algorithms for paging with locality of reference. </title> <booktitle> In 3rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 228-236, </pages> <year> 1992. </year>
Reference-contexts: The models include independent reference [1], LRU stack [30], working set [11], access graphs [5], Markov model [21]. For each of these models optimal online algorithms are found, for example, LRU for LRU-stack model [16], access-graph algorithm <ref> [18] </ref>, and Markov paging algorithm [21]. Our study suggests that the access-graph model might be the appropriate model for the regular-pattern applications. Indeed, the SEQ algorithm can be viewed as an attempt to apply the access-graph algorithms for a simple graph: sequences of pages.
Reference: [19] <author> Michael K. Johnson. </author> <title> The Kernel Hacker's Guide 0.7. </title> <address> http://www.redhat.com:8080/HyperNews/ get/khg.html, </address> <year> 1996. </year>
Reference-contexts: The studies show that the performance of the approximation algorithms is similar to that of LRU. Most operating systems today uses CLOCK or a variant of it <ref> [10, 19, 2] </ref>. Though not reported in this paper, we performed simulations of FIFO and a simple version of CLOCK algorithm on our traces. Our findings are similar to the early studies: FIFO generally performs worse than LRU, and CLOCK performs similar to LRU across the applications.
Reference: [20] <author> Norman P. Jouppi. </author> <title> Improving direct-mapped cache performance by the addition of a small fully-associative cache and prefetch buffers. </title> <booktitle> In The 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 364-373, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: These studies suggest that the reference behavior at page level might be similar to that at cache line level. We plan to investigate this correlation. There are also sequence detection in hardware cache management. Mostly the detection is for prefetching, as in the case of stream buffers <ref> [33, 20] </ref>. Though we only talked about replacement policy in this paper, it is obvious that sequence detection can be used for prefetching as well. How to balance the prefetching and caching, though, is a complicated issue that needs further study [7].
Reference: [21] <author> Anna R. Karlin, Steven J. Phillips, and Prab-hakar Raghavan. </author> <title> Markov paging. </title> <booktitle> In Proc. 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 208-217, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Among these theoretical studies, of particular interests to our study are the ones on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack [30], working set [11], access graphs [5], Markov model <ref> [21] </ref>. For each of these models optimal online algorithms are found, for example, LRU for LRU-stack model [16], access-graph algorithm [18], and Markov paging algorithm [21]. Our study suggests that the access-graph model might be the appropriate model for the regular-pattern applications. <p> The models include independent reference [1], LRU stack [30], working set [11], access graphs [5], Markov model <ref> [21] </ref>. For each of these models optimal online algorithms are found, for example, LRU for LRU-stack model [16], access-graph algorithm [18], and Markov paging algorithm [21]. Our study suggests that the access-graph model might be the appropriate model for the regular-pattern applications. Indeed, the SEQ algorithm can be viewed as an attempt to apply the access-graph algorithms for a simple graph: sequences of pages.
Reference: [22] <author> T. Kilburn, D. B. G. Edwards, M. J. Lanigan, and F. H. Sumner. </author> <title> One-level storage system. </title> <journal> In IEEE Transaction on Electronic Communications, </journal> <pages> pages 223-235, </pages> <month> April </month> <year> 1962. </year>
Reference-contexts: Part of our future work is to investigate applying the general access-graph algorithms for more complicated patterns in applications. Along with the theoretical studies there have been extensive experimental studies. A good survey can be found in [12, 32]. Except a few early studies <ref> [22] </ref>, most experimental studies focused on efficient implementation of LRU page replacement algorithms in practice. A number of approximation algorithms, FIFO with second chance [4], CLOCK algorithms [3], etc. have been proposed and implemented in various systems [8, 24, 31].
Reference: [23] <author> CHao-Hsien Lee, Meng Chang Chen, and Ruei-Chuan Chang. </author> <title> HiPEC: High performance external virtual memory caching. </title> <booktitle> In Proceedings of the First Symposium on Operating System Design and Implementation, </booktitle> <pages> pages 153-164, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: How to balance the prefetching and caching, though, is a complicated issue that needs further study [7]. Recent research projects on application-controlled kernels show the potentials of application-specific replacement policies <ref> [34, 17, 25, 23] </ref>. However, most of those studies focus on letting applications inform kernel of their access patterns, instead of having operating systems detect them at run-time (as in the SEQ algorithm).
Reference: [24] <author> H. M. Levy and P. H. Lipman. </author> <title> Virtual memory management in the VAX/VMS operating system. </title> <journal> IEEE Computer, </journal> <volume> 15(3) </volume> <pages> 35-41, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: Except a few early studies [22], most experimental studies focused on efficient implementation of LRU page replacement algorithms in practice. A number of approximation algorithms, FIFO with second chance [4], CLOCK algorithms [3], etc. have been proposed and implemented in various systems <ref> [8, 24, 31] </ref>. The studies show that the performance of the approximation algorithms is similar to that of LRU. Most operating systems today uses CLOCK or a variant of it [10, 19, 2].
Reference: [25] <author> Dylan McNamee and Katherine Armstrong. </author> <title> Extending the Mach external pager interface to accommodate user-level page replacement policies. </title> <booktitle> In Proceedings of USENIX Mach Symposiumi '91, </booktitle> <pages> pages 17-29, </pages> <year> 1990. </year>
Reference-contexts: How to balance the prefetching and caching, though, is a complicated issue that needs further study [7]. Recent research projects on application-controlled kernels show the potentials of application-specific replacement policies <ref> [34, 17, 25, 23] </ref>. However, most of those studies focus on letting applications inform kernel of their access patterns, instead of having operating systems detect them at run-time (as in the SEQ algorithm).
Reference: [26] <author> Sharon E. Perl and Richard L. </author> <title> Sites. Studies of windows NT performance using dynamic execution traces. </title> <booktitle> In Proceedings of the 2nd Symposium on Operating Systems Design and Implementation (OSDI'96), </booktitle> <address> Seattle, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: One study [6] (on out-of-chip bandwidth requirement) confirmed that there is a significant difference in cache miss ratios under LRU and under OPT replacement policies. Another study on the similar topic <ref> [26] </ref> plotted a space-time graph for some SPEC95 benchmarks at cache line level. Though their graphs are for a much shorter duration of the application's execution (e.g. 50K instructions), the graphs are similar to our graphs for the SPEC95 benchmarks.
Reference: [27] <author> Rob Pike. </author> <booktitle> Notes on programming in C, </booktitle> <month> February </month> <year> 1989. </year> <note> Available at http://www.lysator.liu.se/c/ pikestyle.html. </note>
Reference-contexts: These applications seem to be array-based, though some of them are written in C (fgm and gnuplot). These behaviors remind us of the comments of Rob Pike: "there are only three data structures: linked lists, hash tables, and arrays." <ref> [27] </ref> It does seem to us that it is true in practice: the applications exhibiting regular reference patterns are array-based; vortex, perl and coral are either using hash tables or traversing a tree structure (judging from the way the address space grows); gcc seems to use linked lists heavily, and we
Reference: [28] <author> Raghu Ramakrishnan, Di-vesh Srivastava, Praveen Seshadri, and S. Sudar-shan. </author> <title> Implementation of the CORAL deductive database system. </title> <booktitle> In 19 ACM SIGMOD Conf. on the Management of Data, </booktitle> <address> Washington,DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: 6 discusses related work and Section 7 concludes. 2 Applications and Traces The fourteen applications we studied and their sources are as follows. * applu (SPECfp95): floating point intensive; solves five coupled parabolic/elliptic Partial Differential Equations; written in Fortran, run with train input set; * coral: a deductive database system <ref> [28] </ref>, written in C++, evaluating a nested query; * es: microstructure electrostatics simulation used in fluid simulation [15], written in C, computing boundary integral equations for an N-body problem; * fgm: finite growth model test [14] (compares greyscale images), written in C; * gcc: GNU CC version 2.6.3, compiling the preprocessed
Reference: [29] <author> E. Rothberg, J.P. Singh, and A. Gupta. </author> <title> Working sets, cache sizes, and node granularity issues for large-scale multiprocessors. </title> <booktitle> In The 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 14-26, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Though their graphs are for a much shorter duration of the application's execution (e.g. 50K instructions), the graphs are similar to our graphs for the SPEC95 benchmarks. Finally, one study on large-scale multiprocessor architectures investigated the "working-set" and cache size issues for parallel scientific applications <ref> [29] </ref>. The study investigated a number of parallel applications, measuring their "working-sets" by simulating the number of cache misses versus cache sizes under the LRU replacement. The cache misses versus cache size curves in [29] are quite similar to our LRU page fault curves for scientific applications. <p> study on large-scale multiprocessor architectures investigated the "working-set" and cache size issues for parallel scientific applications <ref> [29] </ref>. The study investigated a number of parallel applications, measuring their "working-sets" by simulating the number of cache misses versus cache sizes under the LRU replacement. The cache misses versus cache size curves in [29] are quite similar to our LRU page fault curves for scientific applications. These studies suggest that the reference behavior at page level might be similar to that at cache line level. We plan to investigate this correlation. There are also sequence detection in hardware cache management.
Reference: [30] <author> G. S. Shedler and C. Tung. </author> <title> Locality in page reference string. </title> <journal> In SIAM J. Computer, </journal> <volume> vol. 1, </volume> <pages> pages 218-241, </pages> <month> September </month> <year> 1972. </year>
Reference-contexts: Among these theoretical studies, of particular interests to our study are the ones on program behavior modelling and optimal online algorithms for each model. The models include independent reference [1], LRU stack <ref> [30] </ref>, working set [11], access graphs [5], Markov model [21]. For each of these models optimal online algorithms are found, for example, LRU for LRU-stack model [16], access-graph algorithm [18], and Markov paging algorithm [21].
Reference: [31] <author> A. Silberschatz and P. B. Galvin. </author> <title> Operating Systems Concepts. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, 4th edition, </address> <year> 1994. </year>
Reference-contexts: Except a few early studies [22], most experimental studies focused on efficient implementation of LRU page replacement algorithms in practice. A number of approximation algorithms, FIFO with second chance [4], CLOCK algorithms [3], etc. have been proposed and implemented in various systems <ref> [8, 24, 31] </ref>. The studies show that the performance of the approximation algorithms is similar to that of LRU. Most operating systems today uses CLOCK or a variant of it [10, 19, 2].
Reference: [32] <author> Alan J. Smith. </author> <title> Disk cache|miss ratio analysis and design considerations. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 161-203, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Part of our future work is to investigate applying the general access-graph algorithms for more complicated patterns in applications. Along with the theoretical studies there have been extensive experimental studies. A good survey can be found in <ref> [12, 32] </ref>. Except a few early studies [22], most experimental studies focused on efficient implementation of LRU page replacement algorithms in practice. A number of approximation algorithms, FIFO with second chance [4], CLOCK algorithms [3], etc. have been proposed and implemented in various systems [8, 24, 31].
Reference: [33] <author> Alan Jay Smith. </author> <title> Sequential program prefetch-ing in memory hierarchies. </title> <journal> IEEE Computer, </journal> <volume> 11(12) </volume> <pages> 7-21, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: These studies suggest that the reference behavior at page level might be similar to that at cache line level. We plan to investigate this correlation. There are also sequence detection in hardware cache management. Mostly the detection is for prefetching, as in the case of stream buffers <ref> [33, 20] </ref>. Though we only talked about replacement policy in this paper, it is obvious that sequence detection can be used for prefetching as well. How to balance the prefetching and caching, though, is a complicated issue that needs further study [7].
Reference: [34] <author> Michael Young, Avadis Tevanian, Richard Rashid, David Golub, Jeffrey Eppinger, Jonathan Chew, William Bolosky, David Black, and Robert Baron. </author> <title> The Duality of Memory and Communication in the implementation of a Multiprocessor Operating System. </title> <booktitle> In The Proceedings of the 11th Symposium on Operating System Principles, </booktitle> <month> November </month> <year> 1987. </year> <month> 30 </month>
Reference-contexts: How to balance the prefetching and caching, though, is a complicated issue that needs further study [7]. Recent research projects on application-controlled kernels show the potentials of application-specific replacement policies <ref> [34, 17, 25, 23] </ref>. However, most of those studies focus on letting applications inform kernel of their access patterns, instead of having operating systems detect them at run-time (as in the SEQ algorithm).
References-found: 34

