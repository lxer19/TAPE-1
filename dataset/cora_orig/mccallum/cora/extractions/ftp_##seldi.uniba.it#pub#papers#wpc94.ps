URL: ftp://seldi.uniba.it/pub/papers/wpc94.ps
Refering-URL: http://www.cs.umd.edu/~lanubile/public.html
Root-URL: 
Title: Analyzing the Application of a Reverse Engineering Process to a Real Situation experience gave rise
Author: Fabio Abbattista Gregorio M.G. Fatone Filippo Lanubile Giuseppe Visaggio 
Date: [6].  
Note: The  program was consolidated. The experience enabled  to obtain the reverse engineering products was made  The paper describes the  305 no. of files: 70 no. of data: 9 000 no. of Instructions: 900 000 (including comments but not copy books) 2: The reverse engineering process The first involved  Figure 1 shows the process model, which is briefly described underneath. Further details may be obtained from [10].  
Address: Basica S.p.A., Potenza, Italy  
Affiliation: Dipartimento di Informatica, University of Bari, Italy  
Pubnum: [4],  
Abstract: We present an experience in which process quality and product quality interact and mutually improve one another. The process is reverse engineering while the product is the documentation of programs necessary to exploit the program better. The salient point to be gained from the experience are, in general, the model as it appears after improvements stemming from trial on the field and, in particular, the method for integrating static and dynamic analyses to improve the process. These programs constitute a "large" software system as they are integrated by a database and cover various banking business areas. Their long life (average 12 years, reaching peaks of 23 years) was mirrored by their "old" structure, so that they were difficult to maintain and had inconsistent, invariably poor documentation. The system is so diffuse within the user bank that substituting it would have been impracticable. It was therefore necessary to rejuvenate the software system and, as the only reliable component was the source code, it was judged necessary to start by reverse engineering to understand the programs, while acknowledging that reengineering would then be required. The paper includes a brief description of the process model (section 2), the results of its application (section 3), the modifications made to the process model (section 4) and the final conclusions (section 5). Our reverse engineering process had two main objectives: (1) to increase the ease of maintenance of the software system, and (2) to improve its usability by the final users and the ease of knowledge transfer among different users [5]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Abbattista, F. Lanubile, and G. Visaggio, </author> <title> "Recovering conceptual data models is human intensive", </title> <booktitle> Fifth International Conference on Software engineering and Knowledge engineering, </booktitle> <address> San Francisco, California, </address> <year> 1993. </year>
Reference-contexts: Abstract Data. All the data in the application domain which belong to the logical model and are not dead are associated with the corresponding meaningful concept for the application domain <ref> [1] </ref>. 4. Analysis of Existing Information. This activity involves identifying the expected functions in the program being reversed using two types of information. The first is static knowledge, i. e. the internal and external documentation of the rules governing the application domain of the function.
Reference: [2] <author> BACHMAN, </author> <note> Bachman/Analyst Reference Manual , Release 4.10. </note>
Reference-contexts: Complexity of some programs and their extracted modules During restoration, thanks to BACHMANs tool <ref> [2] </ref> and VIASOFTs tool [14], and to the techniques used, the reverse operator extracts a lot of information which cannot be expressed in any of the documents produced.
Reference: [3] <author> G. Canfora, A. Cimitile, and U. De Carlini, </author> <title> "A logic based approach to reverse engineering tool production", </title> <booktitle> Conference on Software Maintenance , Sorrento, </booktitle> <address> Italy, </address> <year> 1991. </year>
Reference: [4] <author> G. Canfora, A. Cimitile, and M. </author> <title> Munro "RE 2 : reverse engineering and reuse reengineering", </title> <institution> Computer Science Technical Report 8/92 , University of Duhram, School of Engineering and Computer Science, </institution> <year> 1992. </year>
Reference-contexts: The first involved reconstruction of the project design documentation and restoration of the most degraded parts while the second required reconstruction of the user documentation and the data conceptual model. This helps users to understand their own information system better from the point of view of the data processed <ref> [4] </ref>, [6]. described underneath. Further details may be obtained from [10]. 1. Inventory Software System. The following cross references are extracted from the old software system: call dependence X-ref, copybook X-ref, and file access X-ref.
Reference: [5] <author> E. J. Chikofsky, and J. H. </author> <title> Cross II, "Reverse engineering and design recovery: a taxonomy", </title> <note> IEEE Software , January 1990. </note>
Reference-contexts: 4) and the final conclusions (section 5). 2: The reverse engineering process Our reverse engineering process had two main objectives: (1) to increase the ease of maintenance of the software system, and (2) to improve its usability by the final users and the ease of knowledge transfer among different users <ref> [5] </ref>. The first involved reconstruction of the project design documentation and restoration of the most degraded parts while the second required reconstruction of the user documentation and the data conceptual model.
Reference: [6] <author> G. Como, F. Lanubile, and G. Visaggio, </author> <title> "Design recovery of a data-strong application", </title> <booktitle> 3rd International Conference on Software engineering and Knowledge engineering, </booktitle> <address> Illinois,USA,1991. </address>
Reference-contexts: This helps users to understand their own information system better from the point of view of the data processed [4], <ref> [6] </ref>. described underneath. Further details may be obtained from [10]. 1. Inventory Software System. The following cross references are extracted from the old software system: call dependence X-ref, copybook X-ref, and file access X-ref.
Reference: [7] <author> F. Cutillo, F. Lanubile, and G. Visaggio, </author> <title> "Extracting application domain functions from old code: a real experience", </title> <booktitle> 2nd Workshop on Program Comprehension , Capri, </booktitle> <address> Italy, </address> <year> 1993. </year>
Reference: [8] <author> F. Cutillo, P. Fiore, and G. Visaggio, </author> <title> "Identification and extraction of domain independent components in large programs", </title> <booktitle> Working Conference on Reverse Engineering, </booktitle> <address> Baltimora, </address> <year> 1993. </year>
Reference-contexts: Some examples of modifications are renaming of variables , making their identifiers more meaningful; extracting modules with high internal cohesion from those with low cohesion and isolating them in the structure ([7], <ref> [8] </ref>, [12], [13]); externalizing modules which, in the present process, are in line with the main; localizing variables declared to be global but used locally in both existing modules and in processes extracted during restoration.
Reference: [9] <author> F. Cutillo, F. Lanubile, and G. Visaggio, </author> <title> "Using program slicing for software comprehension", </title> <booktitle> IEEE Workshop Notes on Software Comprehension , Orlando, </booktitle> <address> Florida, </address> <year> 1992. </year>
Reference-contexts: Abstract Functions. The functions abstracted during restoration are documented. The aim of each function is described in textual form. The relationships between functions are also documented by means of data flow diagrams. The latter, together with the description of each function, constitute the conceptual model <ref> [9] </ref>. The reverse engineering process is not symmetrical because the programs are restored while the data are not, because any interference with the latter would affect the procedures and make the whole restoration process very expensive.
Reference: [10] <author> FORMATICA, </author> <title> "Definition of the production line. reverse engineering: process model", </title> <journal> Int. doc. </journal> <volume> no. </volume> <month> 69 . September </month> <year> 1992 </year>
Reference-contexts: This helps users to understand their own information system better from the point of view of the data processed [4], [6]. described underneath. Further details may be obtained from <ref> [10] </ref>. 1. Inventory Software System. The following cross references are extracted from the old software system: call dependence X-ref, copybook X-ref, and file access X-ref.
Reference: [11] <author> R. Gopal, </author> <title> "Dynamic program slicing based on dependence relationships", </title> <booktitle> Conference on Software Maintenance , Sorrento, </booktitle> <address> Italy, </address> <year> 1991. </year>
Reference-contexts: Finally, the experience with the test cases suggested using them to perform dynamic slicing of too complex modules, during the restoration phase. A formal description of this dynamic slicing can be found in <ref> [11] </ref>.
Reference: [12] <author> F. Lanubile, and G.Visaggio, </author> <title> "Function recovery based on program slicing", </title> <booktitle> Conference on Software Maintenance , Montreal, </booktitle> <address> Quebec, Canada, </address> <year> 1993. </year>
Reference-contexts: Some examples of modifications are renaming of variables , making their identifiers more meaningful; extracting modules with high internal cohesion from those with low cohesion and isolating them in the structure ([7], [8], <ref> [12] </ref>, [13]); externalizing modules which, in the present process, are in line with the main; localizing variables declared to be global but used locally in both existing modules and in processes extracted during restoration.
Reference: [13] <author> M. Weiser, </author> <title> "Program Slicing", </title> <journal> IEEE Transactions on Software Engineering , vol.SE-10, </journal> <volume> n4, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Some examples of modifications are renaming of variables , making their identifiers more meaningful; extracting modules with high internal cohesion from those with low cohesion and isolating them in the structure ([7], [8], [12], <ref> [13] </ref>); externalizing modules which, in the present process, are in line with the main; localizing variables declared to be global but used locally in both existing modules and in processes extracted during restoration.
Reference: [14] <author> VIASOFT, </author> <title> VIA/Renaissance User Manual , VIA/Insight User Manual , VIA/SmartDoc User Manual </title> . 
Reference-contexts: Complexity of some programs and their extracted modules During restoration, thanks to BACHMANs tool [2] and VIASOFTs tool <ref> [14] </ref>, and to the techniques used, the reverse operator extracts a lot of information which cannot be expressed in any of the documents produced. In particular, for many modules in the restored program, he will know not only their description but the algorithms themselves contained in the module.
References-found: 14

