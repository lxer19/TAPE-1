URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/jvm-short-preprint.ps
Refering-URL: http://fas.sfu.ca/cs/people/GradStudents/pwfong/personal/bookmarks.html
Root-URL: 
Title: A Type System for Java Bytecode Subroutines  
Author: Raymie Stata and Martn Abadi 
Affiliation: Digital Equipment Corporation Systems Research Center  
Abstract: JVML has a subroutine construct used for the compilation of Java's try-finally statement. Subroutines are a major source of complexity for the bytecode verifier because they are not obviously last-in/first-out and because they require a kind of polymorphism. Focusing on subroutines, we isolate an interesting, small subset of JVML. We give typing rules for this subset and prove their correctness. Our type system constitutes a sound basis for bytecode verification and a rational reconstruction of a delicate part of Sun's bytecode verifier. 
Abstract-found: 1
Intro-found: 1
Reference: [Coh97] <author> Richard M. Cohen. </author> <title> Defensive Java Virtual Machine version 0.5 alpha release. </title> <note> Web pages at http://www.cli.com/, May 13, </note> <year> 1997. </year>
Reference-contexts: While testing does not provide an adequate replacement for precise specifications and proofs, it is a cost-effective way to find certain flaws and oddities. More broadly, there have been several other implementations of the Java VM. Of particular interest is a partial implementation developed at Computational Logic, Inc. <ref> [Coh97] </ref>. This implementation is defensive, in the sense that it includes strong (and expensive) dynamic checks, removing the need for bytecode verification. The implementation is written in a formal language, and is intended as a model rather than for production use.
Reference: [DE97] <author> Sophia Drossopoulou and Susan Eisenbach. </author> <title> Java is type safe|probably. </title> <booktitle> In Proceedings of ECOOP'97, </booktitle> <pages> pages 389-418, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Therefore, the main problems addressed in this paper do not arise in the context of TIL. Finally, the literature contains many proofs of type soundness for higher-level languages, and in particular proofs for a fragment of Java <ref> [DE97, Sym97] </ref>. Those proofs have not had to deal with JVML peculiarities (in particular, with subroutines); nevertheless, their techniques may be helpful in extending our work to the full JVML. In summary, there has not been much work closely related to ours.
Reference: [LY96] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Bytecode verification and typing rules The Java language is typically compiled into an intermediate language that is interpreted by the Java Virtual Machine (VM) <ref> [LY96] </ref>. This intermediate language, which we call JVML, is an object-oriented language similar to Java. Its features include packages, classes with single inheritance, and interfaces with multiple inheritance. However, unlike method bodies in Java, method bodies in JVML are sequences of bytecode instructions. <p> Of course, such a linearization of the subroutine call graph exists only when the call graph is acyclic, that is, when subroutines do not recurse. (We believe that we can prove our theorems while allowing recursion, but disallowing recursion simplifies our proofs and agrees with Sun's specification <ref> [LY96, p. 124] </ref>.) Figure 9 contains the rules for this new judgement, and Figure 10 gives an example; in this example, the order 4 and 7 could be reversed in C 10 and C 11 .
Reference: [Mor95] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: There have also been typed intermediate languages other than JVML. Several have been developed for ML and Haskell [TIC97]. We discuss the TIL intermediate languages <ref> [Mor95, MTC + 96] </ref> as representative examples. The TIL intermediate languages provide static guarantees similar to those of JVML. Although these languages have sophisticated type systems, they do not include an analogue to JVML subroutines; instead, they include constructs as high-level as Java's try-finally statement.
Reference: [MTC + 96] <author> G. Morrisett, D. Tarditi, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> The TIL/ML compiler: Performance and safety through types. </title> <booktitle> In Workshop on Compiler Support for Systems Software, </booktitle> <year> 1996. </year>
Reference-contexts: There have also been typed intermediate languages other than JVML. Several have been developed for ML and Haskell [TIC97]. We discuss the TIL intermediate languages <ref> [Mor95, MTC + 96] </ref> as representative examples. The TIL intermediate languages provide static guarantees similar to those of JVML. Although these languages have sophisticated type systems, they do not include an analogue to JVML subroutines; instead, they include constructs as high-level as Java's try-finally statement.
Reference: [Qia97] <author> Zhenyu Qian. </author> <title> A formal specification of Java(tm) Virtual Machine instructions (draft). </title> <note> Web page at http://www.informatik.uni-bremen .de/~qian/abs-fsjvm.html, </note> <year> 1997. </year>
Reference-contexts: However, interest in the formal treat ment of bytecode verification seems to be mounting; several approaches are currently being pursued <ref> [Qia97, Sar97] </ref>. 10 Conclusions The bytecode verifier is an important part of the Java VM; through static checks, it helps reconcile safety with efficiency. Common descriptions of the bytecode verifier are ambiguous and contradictory. This paper suggests the use of a type system as an alternative to those descriptions.
Reference: [Sar97] <author> Vijay Saraswat. </author> <title> The Java bytecode verification problem. </title> <note> Web page at http://www.research .att.com/~vj/main.html, </note> <year> 1997. </year>
Reference-contexts: However, interest in the formal treat ment of bytecode verification seems to be mounting; several approaches are currently being pursued <ref> [Qia97, Sar97] </ref>. 10 Conclusions The bytecode verifier is an important part of the Java VM; through static checks, it helps reconcile safety with efficiency. Common descriptions of the bytecode verifier are ambiguous and contradictory. This paper suggests the use of a type system as an alternative to those descriptions.
Reference: [SMB97] <author> Emin Gun Sirer, Sean McDirmid, and Brian Bershad. Kimera: </author> <title> A Java system security architecture. </title> <note> Web pages at http://kimera.cs .washington.edu/, </note> <year> 1997. </year>
Reference-contexts: Only recently has there been any systematic attempt to understand all these implementations. In particular, the Kimera project has tested several implementations, pointing out some mistakes and discrepancies <ref> [SMB97] </ref>. We take a complementary approach, based on rigorous reasoning rather than on testing. Both rigorous reasoning and testing may affect our confidence in bytecode verification. While testing does not provide an adequate replacement for precise specifications and proofs, it is a cost-effective way to find certain flaws and oddities.
Reference: [Sym97] <author> Don Syme. </author> <title> Proving Java type soundness. </title> <type> Technical Report 427, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: Therefore, the main problems addressed in this paper do not arise in the context of TIL. Finally, the literature contains many proofs of type soundness for higher-level languages, and in particular proofs for a fragment of Java <ref> [DE97, Sym97] </ref>. Those proofs have not had to deal with JVML peculiarities (in particular, with subroutines); nevertheless, their techniques may be helpful in extending our work to the full JVML. In summary, there has not been much work closely related to ours.
Reference: [TIC97] <institution> ACM SIGPLAN Workshop on Types in Compilation (TIC97). </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: Ultimately, one may hope to prove that the defensive implementation is equivalent to an aggressive implementation plus a sound bytecode verifier (perhaps one based on our rules). There have also been typed intermediate languages other than JVML. Several have been developed for ML and Haskell <ref> [TIC97] </ref>. We discuss the TIL intermediate languages [Mor95, MTC + 96] as representative examples. The TIL intermediate languages provide static guarantees similar to those of JVML.
Reference: [Yel97] <author> Frank Yellin. </author> <title> Private communication. </title> <month> March </month> <year> 1997. </year>
Reference-contexts: In summary, there has not been much work closely related to ours. We do not find this surprising, given that the handling of subroutines is one of the most original parts of the bytecode verifier; it was not derived from prior papers or systems <ref> [Yel97] </ref>. However, interest in the formal treat ment of bytecode verification seems to be mounting; several approaches are currently being pursued [Qia97, Sar97]. 10 Conclusions The bytecode verifier is an important part of the Java VM; through static checks, it helps reconcile safety with efficiency.
References-found: 11

