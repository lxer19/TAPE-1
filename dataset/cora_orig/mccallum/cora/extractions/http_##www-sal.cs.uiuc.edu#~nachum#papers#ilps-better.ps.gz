URL: http://www-sal.cs.uiuc.edu/~nachum/papers/ilps-better.ps.gz
Refering-URL: http://sal.cs.uiuc.edu/~nachum/papers/
Root-URL: http://www.cs.uiuc.edu
Email: nachum@cs.uiuc.edu  
Title: Goal Solving as Operational Semantics  
Author: Nachum Dershowitz 
Address: Urbana, IL 61801, USA  
Affiliation: Department of Computer Science University of Illinois  
Abstract: To combine a functional or equational programming style with logic programming, one can use an underlying logic of Horn clauses with equality (as an interpreted predicate symbol) and (typed) terms. From this point of view, the most satisfying operational semantics would search for solutions to equations or predicates. "Narrowing" and many of its variants are complete mechanisms for generating solutions. Such a melded language is more expressive than either paradigm alone: functional dependencies are explicit; "multi-valued" functions can be better expressed as predicates; nested functions can be evaluated without recourse to search (backtracking); (non-constructor) terms can serve as arguments to predicates; functions can be inverted; nonterminating functions can be programmed in a terminating fashion; goals can be simplified in a "don't care" manner; "functional" negation can prune searches. Moreover, the availability of backtracking and existential ("logic") variables provides an alternative to infinite data structures ("streams"). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Marco Bellia and Giorgio Levi. </author> <title> The relation between logic and functional languages: A survey. </title> <journal> J. of Logic Programming, </journal> <volume> 3(3) </volume> <pages> 217-236, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: For other methods of establishing conditional confluence, see [15, 26]. 3 Functional-Logic Programming Various proposals have been set forth for combining features of functional programming and logic (relational) programming; surveys include <ref> [1, 15, 35] </ref>. Functional notation and an evaluation mechanism are borrowed from functional programming; assignment by unification and goal-solving are borrowed from logic programming. One can, for instance, begin with a functional language like Lisp and add backtracking and unification.
Reference: [2] <author> Pier Giorgio Bosco, Elio Giovannetti, and Corrado Moiso. </author> <title> Narrowing vs. </title> <journal> SLD-resolution. Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 3-23, </pages> <year> 1988. </year>
Reference-contexts: See [35]. Narrowing [36, 37] is a "linear" restriction of paramodulation akin to the SLD-strategy in Horn-clause logic <ref> [2] </ref>. Whereas paramodulation uses both sides of an equation in the same way, narrowing is more directed| unifying with left-hand sides only|thereby taking the direction of rewriting into account. <p> use "directed" goals of the form e ! ? z, similar to the equations in "normal" conditions, meaning that we are looking for a z that is the normal form of e [9]. 5 Stream Programming The desirability of incorporating infinite structures in a functional-logic language has been widely asserted <ref> [2, 30] </ref>. Unfortunately, we are presented with a tradeoff between the benefits of lazy evaluation of orthogonal, non-terminating rules and those of eager simplification with terminating, non-orthogonal rules. Starting from the lazy approach, one can allow some additional simplification rules.
Reference: [3] <author> P. Deransart. </author> <title> An operational algebraic semantics of PROLOG programs. </title> <type> Internal report, </type> <institution> Institut National Recherche en Informatique et Automatique, Le Chesnay, France, </institution> <year> 1983. </year>
Reference-contexts: Solving the condition c may result in additional variable bindings. Narrowing can be simulated in Prolog by decomposing terms, as first done in <ref> [3] </ref>. A logic-programming language with narrowing-like operational semantics was first suggested in [4], but only unconditional rules were used (conditionals were encoded as equivalences); equational Horn clauses were first used in Eqlog [12], Rite [8, 23], and Slog [10], and have more recently been implemented in Babel [31].
Reference: [4] <author> Nachum Dershowitz. </author> <title> Computing with rewrite systems. </title> <type> Technical Report ATR-83(8478)-1, </type> <institution> Information Sciences Research Office, The Aerospace Corp., El Segundo, </institution> <address> CA, </address> <month> January </month> <year> 1983. </year>
Reference-contexts: Solving the condition c may result in additional variable bindings. Narrowing can be simulated in Prolog by decomposing terms, as first done in [3]. A logic-programming language with narrowing-like operational semantics was first suggested in <ref> [4] </ref>, but only unconditional rules were used (conditionals were encoded as equivalences); equational Horn clauses were first used in Eqlog [12], Rite [8, 23], and Slog [10], and have more recently been implemented in Babel [31]. For additional references and comparisons with other suggestions, see the discussion in [8]. <p> Exactly how much simplification is performed before each narrowing step is a matter of taste, since completeness is not affected by this decision. Narrowing only fully simplified goals has been advocated by <ref> [4, 8, 10, 16, 19] </ref> and others. With a combined language, the need for some "added features" is ameliorated. For example, multi-valued functions can be better modeled by predicates than with nondeterministic rewriting, as in [24]. Goal-solving can then find the different values satisfying the relation. <p> Additional useful completeness results are needed ([28] is one such). * Computing by forward reasoning from the program <ref> [4, 8] </ref> is a possibility that is particularly attractive in a database setting. Better yet, the recent work of [28] allows for both bottom-up and top-down computing. * The language must be typed. An example of a language that also in-corporates higher-order functions is -Prolog [29].
Reference: [5] <author> Nachum Dershowitz. </author> <title> Ordering-based strategies for Horn clauses. </title> <booktitle> In Proceedings of the Twelfth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 118-124, </pages> <address> Sydney, Australia, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Existing methods for establishing termination and confluence are geared to the significantly simpler case of unconditional rules. An alternative would be to use forms of ordered Horn-clause resolution like <ref> [5, 28] </ref>.
Reference: [6] <author> Nachum Dershowitz and Naomi Lindenstrauss. </author> <title> A parallel implementation of equational programming. </title> <booktitle> In Proceedings of the Fifth Jerusalem Conference on Information Technology, </booktitle> <pages> pages 426-435, </pages> <address> Jerusalem, Is-rael, </address> <month> October </month> <year> 1990. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Some of the recent work is discussed in [15]. * Rewriting and narrowing lend themselves, in a natural fashion, to "and-" and "or-" parallelism, respectively. One (simulated) parallel implementation of this combination is reported on in <ref> [6] </ref>.
Reference: [7] <author> Nachum Dershowitz, Subrata Mitra, and G. Sivakumar. </author> <title> Equation solving in conditional AC-theories. </title> <editor> In H. Kirchner and W. Wechler, editors, </editor> <booktitle> Proceedings of the Second Conference on Algebraic and Logic Programming (Nancy, France), volume 463 of Lecture Notes in Computer Science, </booktitle> <pages> pages 283-297, </pages> <address> Berlin, </address> <month> October </month> <year> 1990. </year> <note> Springer-Verlag. </note>
Reference-contexts: This narrowing derivation, however, might itself not be innermost. Slog [10] always chooses the leftmost-innermost narrowing path, and, hence, is complete only in certain situations. The terminating approach to equational programming suggests a "normalizing" narrowing strategy <ref> [7, 8, 16, 19] </ref>. This has the advantage of completeness without strong syntactic restrictions, but termination and ground confluence are undecidable properties; thus, completeness is dependent on the programmer's writing a "correct" program. One need not be afraid to predicate completeness on undecidable properties of programs.
Reference: [8] <author> Nachum Dershowitz and David A. Plaisted. </author> <title> Equational programming. </title> <editor> In J. E. Hayes, D. Michie, and J. Richards, editors, </editor> <booktitle> Machine Intelligence 11: The logic and acquisition of knowledge, chapter 2, </booktitle> <pages> pages 21-56. </pages> <publisher> Oxford Press, Oxford, </publisher> <year> 1988. </year>
Reference-contexts: Narrowing can be simulated in Prolog by decomposing terms, as first done in [3]. A logic-programming language with narrowing-like operational semantics was first suggested in [4], but only unconditional rules were used (conditionals were encoded as equivalences); equational Horn clauses were first used in Eqlog [12], Rite <ref> [8, 23] </ref>, and Slog [10], and have more recently been implemented in Babel [31]. For additional references and comparisons with other suggestions, see the discussion in [8]. <p> For additional references and comparisons with other suggestions, see the discussion in <ref> [8] </ref>. To force conditions to be evaluated (or solved) before the branches of a conditional construct, some authors impose a leftmost strategy (e.g. [34]); for conditional systems, one can let narrowing go through only after establishing that the conditions hold (e.g. [8, 10, 12]). <p> To force conditions to be evaluated (or solved) before the branches of a conditional construct, some authors impose a leftmost strategy (e.g. [34]); for conditional systems, one can let narrowing go through only after establishing that the conditions hold (e.g. <ref> [8, 10, 12] </ref>). Narrowing and many of its variants are complete mechanisms for generating solutions, in that a solution at least as general as any that satisfies the query can always be found (solutions that are provably equal are considered to be the same). <p> This narrowing derivation, however, might itself not be innermost. Slog [10] always chooses the leftmost-innermost narrowing path, and, hence, is complete only in certain situations. The terminating approach to equational programming suggests a "normalizing" narrowing strategy <ref> [7, 8, 16, 19] </ref>. This has the advantage of completeness without strong syntactic restrictions, but termination and ground confluence are undecidable properties; thus, completeness is dependent on the programmer's writing a "correct" program. One need not be afraid to predicate completeness on undecidable properties of programs. <p> We suggest user-defined, unbacktrackable, eager ("don't care") simplification prior to each backtrackable lazy ("don't know") narrowing step. Eager simplification without backtracking has the potential of eliminating many otherwise nondeterministic choice points (by eliminating narrowable variables from goals) and leading to dramatically improved performance of functional-logic programs <ref> [8, 10] </ref>; see [15]. It is, of course, important not to incur heavy costs in searching for applicable rewrites. <p> Exactly how much simplification is performed before each narrowing step is a matter of taste, since completeness is not affected by this decision. Narrowing only fully simplified goals has been advocated by <ref> [4, 8, 10, 16, 19] </ref> and others. With a combined language, the need for some "added features" is ameliorated. For example, multi-valued functions can be better modeled by predicates than with nondeterministic rewriting, as in [24]. Goal-solving can then find the different values satisfying the relation. <p> Goal-solving can then find the different values satisfying the relation. Functional dependency is in the syntax. Negation can be handled by incorporating negative information in the form of rewrite rules, which are then used to simplify subgoals to false <ref> [8, 10, 15] </ref>. This approach allows some unsatisfiable goals to be pruned. The form taken by answers is another issue. Suppose we are given rules for converting a propositional formula e into conjunctive normal form. <p> We could program an explicit predicate, say nf (z), that checked if z is in the desired form, and add it to the goal, or we could impart a "weak" meaning to the equals sign in the goal, namely that they are equal constructor terms <ref> [8, 15] </ref>. Rules for this constructor equality can be generated automatically. <p> Situations in which simplification by terminating rules can be combined with lazy narrowing with nonterminating rules are described in [14]. Starting from a terminating system, one can employ a lazy trick to simulate streams <ref> [8, Section 4.5] </ref> (cf. tricks for forcing strict evaluation), but the semantics of tricks may not be all that clear. <p> Additional useful completeness results are needed ([28] is one such). * Computing by forward reasoning from the program <ref> [4, 8] </ref> is a possibility that is particularly attractive in a database setting. Better yet, the recent work of [28] allows for both bottom-up and top-down computing. * The language must be typed. An example of a language that also in-corporates higher-order functions is -Prolog [29]. <p> An exception may be "fairly" terminating systems like a gcd program with a rule gcd (x; y) ! gcd (y; x). Complete methods are wanting. * Ventures into the realm of non-Horn reasoning are always tempting. Besides negation, limited disjunction may be possible <ref> [8, 27] </ref>. * Constraint programming is an important development and may be a more comfortable setting in which to incorporate reasoning with directed equalities. * In an equational language, it may not be clear how individual equations should be oriented.
Reference: [9] <author> Nachum Dershowitz and G. Sivakumar. </author> <title> Solving goals in equational languages. </title> <editor> In S. Kaplan and J.-P. Jouannaud, editors, </editor> <booktitle> Proceedings of the First International Workshop on Conditional Term Rewriting Systems (Orsay, France), volume 308 of Lecture Notes in Computer Science, </booktitle> <pages> pages 45-55, </pages> <address> Berlin, July 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: There are more general semantic unification methods as well as refinements of narrowing (see [15]). Top-down methods (e.g. <ref> [9, 19] </ref>) are particularly appealing. <p> With (ground confluent and) terminating rules, there is no need for an lazy evaluation strategy to ensure that a value for a term will be reached. Just as an innermost evaluation is appropriate, a narrowing derivation that mimics it suffices <ref> [9] </ref>. This narrowing derivation, however, might itself not be innermost. Slog [10] always chooses the leftmost-innermost narrowing path, and, hence, is complete only in certain situations. The terminating approach to equational programming suggests a "normalizing" narrowing strategy [7, 8, 16, 19]. <p> Rules for this constructor equality can be generated automatically. A similar approach is to use "directed" goals of the form e ! ? z, similar to the equations in "normal" conditions, meaning that we are looking for a z that is the normal form of e <ref> [9] </ref>. 5 Stream Programming The desirability of incorporating infinite structures in a functional-logic language has been widely asserted [2, 30]. Unfortunately, we are presented with a tradeoff between the benefits of lazy evaluation of orthogonal, non-terminating rules and those of eager simplification with terminating, non-orthogonal rules.
Reference: [10] <author> Laurent Fribourg. Slog: </author> <title> A logic programming language interpreter based on clausal superposition and rewriting. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 172-184, </pages> <address> Boston, MA, </address> <month> July </month> <year> 1985. </year> <note> IEEE. </note>
Reference-contexts: A logic-programming language with narrowing-like operational semantics was first suggested in [4], but only unconditional rules were used (conditionals were encoded as equivalences); equational Horn clauses were first used in Eqlog [12], Rite [8, 23], and Slog <ref> [10] </ref>, and have more recently been implemented in Babel [31]. For additional references and comparisons with other suggestions, see the discussion in [8]. <p> To force conditions to be evaluated (or solved) before the branches of a conditional construct, some authors impose a leftmost strategy (e.g. [34]); for conditional systems, one can let narrowing go through only after establishing that the conditions hold (e.g. <ref> [8, 10, 12] </ref>). Narrowing and many of its variants are complete mechanisms for generating solutions, in that a solution at least as general as any that satisfies the query can always be found (solutions that are provably equal are considered to be the same). <p> We take the liberty henceforth of referring to all equation-solving methods that make use of confluence by the generic term "narrowing." Additional superfluous narrowing paths can be avoided by making a distinction between constructor symbols and defined ones (assuming that terms built entirely from constructors are irreducible) <ref> [10, for example] </ref>. Two terms headed by different constructors can never be equal; when headed by the same constructor, they are equal if, and only if, their respective arguments are equal. <p> Just as an innermost evaluation is appropriate, a narrowing derivation that mimics it suffices [9]. This narrowing derivation, however, might itself not be innermost. Slog <ref> [10] </ref> always chooses the leftmost-innermost narrowing path, and, hence, is complete only in certain situations. The terminating approach to equational programming suggests a "normalizing" narrowing strategy [7, 8, 16, 19]. <p> We suggest user-defined, unbacktrackable, eager ("don't care") simplification prior to each backtrackable lazy ("don't know") narrowing step. Eager simplification without backtracking has the potential of eliminating many otherwise nondeterministic choice points (by eliminating narrowable variables from goals) and leading to dramatically improved performance of functional-logic programs <ref> [8, 10] </ref>; see [15]. It is, of course, important not to incur heavy costs in searching for applicable rewrites. <p> Exactly how much simplification is performed before each narrowing step is a matter of taste, since completeness is not affected by this decision. Narrowing only fully simplified goals has been advocated by <ref> [4, 8, 10, 16, 19] </ref> and others. With a combined language, the need for some "added features" is ameliorated. For example, multi-valued functions can be better modeled by predicates than with nondeterministic rewriting, as in [24]. Goal-solving can then find the different values satisfying the relation. <p> Goal-solving can then find the different values satisfying the relation. Functional dependency is in the syntax. Negation can be handled by incorporating negative information in the form of rewrite rules, which are then used to simplify subgoals to false <ref> [8, 10, 15] </ref>. This approach allows some unsatisfiable goals to be pruned. The form taken by answers is another issue. Suppose we are given rules for converting a propositional formula e into conjunctive normal form.
Reference: [11] <author> D. P. Friedman and D. S. Wise. </author> <title> CONS should not evaluate its argu-ments. </title> <editor> In Michaelson and R. Milner, editors, </editor> <booktitle> Proceedings of the Third EATCS International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 257-284, </pages> <address> Edinburgh, Scotland, 1976. </address> <publisher> Edinburgh University Press. </publisher>
Reference-contexts: Thus, an interpreter programmed in a lazy language will terminate whenever the computation it is mimicking terminates. Computation with infinite structures ("streams") is often touted as another advantage of lazy evaluation <ref> [11, 20] </ref>: only that part of the structure that is needed for a particular computation need be evaluated. Equational programming ("rewriting") extends the notion of functional programming by allowing one to use a set of directed equations rather than just function definitions.
Reference: [12] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Eqlog: Equality, types, and generic modules for logic programming. </title> <editor> In D. DeGroot and G. Lind-strom, editors, </editor> <title> Logic Programming: Functions, Relations, </title> <booktitle> and Equations, </booktitle> <pages> pages 295-363. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: Narrowing can be simulated in Prolog by decomposing terms, as first done in [3]. A logic-programming language with narrowing-like operational semantics was first suggested in [4], but only unconditional rules were used (conditionals were encoded as equivalences); equational Horn clauses were first used in Eqlog <ref> [12] </ref>, Rite [8, 23], and Slog [10], and have more recently been implemented in Babel [31]. For additional references and comparisons with other suggestions, see the discussion in [8]. <p> To force conditions to be evaluated (or solved) before the branches of a conditional construct, some authors impose a leftmost strategy (e.g. [34]); for conditional systems, one can let narrowing go through only after establishing that the conditions hold (e.g. <ref> [8, 10, 12] </ref>). Narrowing and many of its variants are complete mechanisms for generating solutions, in that a solution at least as general as any that satisfies the query can always be found (solutions that are provably equal are considered to be the same). <p> An example of a language that also in-corporates higher-order functions is -Prolog [29]. Whether one wants to solve for functional variables needs to be resolved. * The language should have mechanisms for information hiding and in heritance; an "order-sorted" logic underlies Eqlog <ref> [12] </ref>, for example. * Other than for infinite data structures and coding interpreters, it is hard to imagine good uses of nonterminating systems. An exception may be "fairly" terminating systems like a gcd program with a rule gcd (x; y) ! gcd (y; x).
Reference: [13] <author> C. Cordell Green. </author> <title> The Application of Theorem-Proving to Question-Answering. </title> <type> Ph.d., </type> <institution> Department of Computer Science, Stanford University, Stanford, </institution> <address> CA, </address> <year> 1969. </year> <title> Reprinted by Garland, </title> <address> New York [1980]. </address>
Reference-contexts: Adding equality to a Horn-clause logic language is trivial, since the axioms of equality (reflexivity, symmetry, transitivity, and functional reflexivity) are Horn. Depth-first search would be useless in this case, but any complete Horn strategy would do. This is in the spirit of Green's <ref> [13] </ref> original work on extracting answers from resolution proofs. Unfortunately, the axioms for equality lead to hopelessly inefficient computations. To combine a functional or equational programming style with logic programming, one can use an underlying logic of Horn clauses with equality (as an interpreted predicate symbol) and (typed) terms.
Reference: [14] <author> Michael Hanus. </author> <title> Combining lazy narrowing and simplification. </title> <booktitle> In Proceedings of the Fourth International Symposium on Programming Language Implementation and Logic Programming (Madrid, Spain), volume 844 of Lecture Notes in Computer Science, </booktitle> <pages> pages 370-384, </pages> <address> Berlin, 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Situations in which simplification by terminating rules can be combined with lazy narrowing with nonterminating rules are described in <ref> [14] </ref>. Starting from a terminating system, one can employ a lazy trick to simulate streams [8, Section 4.5] (cf. tricks for forcing strict evaluation), but the semantics of tricks may not be all that clear.
Reference: [15] <author> Michael Hanus. </author> <title> The integration of functions into logic programming: From theory to practice. </title> <journal> J. Logic Programming, </journal> 19&20:583-628, 1994. 
Reference-contexts: Whereas the first approach suffers from strong syntactic restriction of orthogonality; the second has the disadvantage of requiring termination, leaving interpreters, streams, and other nonterminating programs behind. For other methods of establishing conditional confluence, see <ref> [15, 26] </ref>. 3 Functional-Logic Programming Various proposals have been set forth for combining features of functional programming and logic (relational) programming; surveys include [1, 15, 35]. Functional notation and an evaluation mechanism are borrowed from functional programming; assignment by unification and goal-solving are borrowed from logic programming. <p> For other methods of establishing conditional confluence, see [15, 26]. 3 Functional-Logic Programming Various proposals have been set forth for combining features of functional programming and logic (relational) programming; surveys include <ref> [1, 15, 35] </ref>. Functional notation and an evaluation mechanism are borrowed from functional programming; assignment by unification and goal-solving are borrowed from logic programming. One can, for instance, begin with a functional language like Lisp and add backtracking and unification. <p> Alternative narrowing derivations must be explored if completeness is to be assured, since deterministically choosing one possible narrowing over others will not guarantee that solutions will be found. Restrictions and variations of narrowing that do preserve completeness are summarized in <ref> [15] </ref>. For example, the idea encompassed by the restriction of narrowing to so-called "basic" positions is that when one is looking for irreducible solutions, one can ignore paths that narrow within what was a variable of the original goal. <p> There are more general semantic unification methods as well as refinements of narrowing (see <ref> [15] </ref>). Top-down methods (e.g. [9, 19]) are particularly appealing. <p> Two terms headed by different constructors can never be equal; when headed by the same constructor, they are equal if, and only if, their respective arguments are equal. See <ref> [15] </ref> for more details and references to more refined methods of detecting unsatisfiable goals. 4 Equational-Logic Programming It would make sense to allow all equational Horn clauses that have computational meaning in a program. <p> We suggest user-defined, unbacktrackable, eager ("don't care") simplification prior to each backtrackable lazy ("don't know") narrowing step. Eager simplification without backtracking has the potential of eliminating many otherwise nondeterministic choice points (by eliminating narrowable variables from goals) and leading to dramatically improved performance of functional-logic programs [8, 10]; see <ref> [15] </ref>. It is, of course, important not to incur heavy costs in searching for applicable rewrites. <p> Goal-solving can then find the different values satisfying the relation. Functional dependency is in the syntax. Negation can be handled by incorporating negative information in the form of rewrite rules, which are then used to simplify subgoals to false <ref> [8, 10, 15] </ref>. This approach allows some unsatisfiable goals to be pruned. The form taken by answers is another issue. Suppose we are given rules for converting a propositional formula e into conjunctive normal form. <p> We could program an explicit predicate, say nf (z), that checked if z is in the desired form, and add it to the goal, or we could impart a "weak" meaning to the equals sign in the goal, namely that they are equal constructor terms <ref> [8, 15] </ref>. Rules for this constructor equality can be generated automatically. <p> For example, given various propositional identities and a definition of conjunctive normal form, the system should push negations down to the literal level and disjunctions down to clauses. * The efficient implementation of combined languages is, of course, of paramount importance. Some of the recent work is discussed in <ref> [15] </ref>. * Rewriting and narrowing lend themselves, in a natural fashion, to "and-" and "or-" parallelism, respectively. One (simulated) parallel implementation of this combination is reported on in [6].
Reference: [16] <author> Michael Hanus. </author> <title> Lazy unification with simplification. </title> <booktitle> In Proc. 5th Eu-ropean Symposium on Programming (Edinburgh, Scotland), volume 788 of Lecture Notes in Computer Science, </booktitle> <pages> pages 272-286, </pages> <address> Berlin, Germany, 1994. </address> <publisher> Springer. </publisher>
Reference-contexts: This narrowing derivation, however, might itself not be innermost. Slog [10] always chooses the leftmost-innermost narrowing path, and, hence, is complete only in certain situations. The terminating approach to equational programming suggests a "normalizing" narrowing strategy <ref> [7, 8, 16, 19] </ref>. This has the advantage of completeness without strong syntactic restrictions, but termination and ground confluence are undecidable properties; thus, completeness is dependent on the programmer's writing a "correct" program. One need not be afraid to predicate completeness on undecidable properties of programs. <p> Exactly how much simplification is performed before each narrowing step is a matter of taste, since completeness is not affected by this decision. Narrowing only fully simplified goals has been advocated by <ref> [4, 8, 10, 16, 19] </ref> and others. With a combined language, the need for some "added features" is ameliorated. For example, multi-valued functions can be better modeled by predicates than with nondeterministic rewriting, as in [24]. Goal-solving can then find the different values satisfying the relation.
Reference: [17] <author> Michael Hanus. </author> <title> On extra variables in (equational) logic programming. </title> <booktitle> In Proc. Twelfth International Conference on Logic Programming, </booktitle> <pages> pages 665-679. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Furthermore, narrowing creates no extra choice points, since there is only one rule for the stream. When streams are used on the right-hand side of other rules, as in g (x; y) ! nth (x; from (y)), extra variables become necessary. These can be eliminated using the method of <ref> [17] </ref>, for example, giving g s (k) (x; y) ! nth (x; from k (y)). <p> The (declarative) meaning of such a statement is that the consequent holds for any value of the extra variable that satisfies the conditions in which it appears. A program can sometimes be transformed to circumvent this problem <ref> [17] </ref> by introducing the extra variable into the "head." Alternatively, we can revise the definition of decreasing rewriting in the extra-variable case, and say to insist that solution to the new variables be in normal form.
Reference: [18] <author> Carl Hewitt. </author> <title> Description and theoretical analysis (using schemata) of planner: A language for proving theorems and manipulating models in a robot. </title> <type> Technical report, </type> <institution> The Artificial Intelligence Laboratory, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1972. </year> <month> AI-TR-258. </month>
Reference-contexts: Functional notation and an evaluation mechanism are borrowed from functional programming; assignment by unification and goal-solving are borrowed from logic programming. One can, for instance, begin with a functional language like Lisp and add backtracking and unification. In fact, some early languages for Artificial Intelligence, like Planner <ref> [18] </ref> and Qlisp [40], had these facilities (and more). One can, alternatively, add set constructs to functional languages [22, 27, 33, and others]. Or one can go in the opposite direction, starting with Prolog and adding function definitions.
Reference: [19] <author> Steffen Holldobler. </author> <title> Foundations of Equational Logic Programming, </title> <booktitle> volume 353 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1989. </year>
Reference-contexts: There are more general semantic unification methods as well as refinements of narrowing (see [15]). Top-down methods (e.g. <ref> [9, 19] </ref>) are particularly appealing. <p> This narrowing derivation, however, might itself not be innermost. Slog [10] always chooses the leftmost-innermost narrowing path, and, hence, is complete only in certain situations. The terminating approach to equational programming suggests a "normalizing" narrowing strategy <ref> [7, 8, 16, 19] </ref>. This has the advantage of completeness without strong syntactic restrictions, but termination and ground confluence are undecidable properties; thus, completeness is dependent on the programmer's writing a "correct" program. One need not be afraid to predicate completeness on undecidable properties of programs. <p> Exactly how much simplification is performed before each narrowing step is a matter of taste, since completeness is not affected by this decision. Narrowing only fully simplified goals has been advocated by <ref> [4, 8, 10, 16, 19] </ref> and others. With a combined language, the need for some "added features" is ameliorated. For example, multi-valued functions can be better modeled by predicates than with nondeterministic rewriting, as in [24]. Goal-solving can then find the different values satisfying the relation.
Reference: [20] <author> Paul Hudak. </author> <title> Conception, evolution, and application of functional programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 359-411, </pages> <year> 1989. </year>
Reference-contexts: Thus, an interpreter programmed in a lazy language will terminate whenever the computation it is mimicking terminates. Computation with infinite structures ("streams") is often touted as another advantage of lazy evaluation <ref> [11, 20] </ref>: only that part of the structure that is needed for a particular computation need be evaluated. Equational programming ("rewriting") extends the notion of functional programming by allowing one to use a set of directed equations rather than just function definitions.
Reference: [21] <author> Jean-Marie Hullot. </author> <title> Canonical forms and unification. </title> <editor> In R. Kowalski, editor, </editor> <booktitle> Proceedings of the Fifth International Conference on Automated Deduction (Les Arcs, France), volume 87 of Lecture Notes in Computer Science, </booktitle> <pages> pages 318-334, </pages> <address> Berlin, July 1980. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: More specifically, with ground confluence, any irreducible solution to a goal can be found by narrowing <ref> [21, 25] </ref>. (An "irreducible" solution assigns normal forms to each variable.) Limiting one to irreducible solutions is justifiable in a functional setting, since the "values" one is looking for are always constructor terms.
Reference: [22] <author> Bharat Jayaraman and Frank S. K. Silbermann. </author> <title> Equations, sets, and reduction semantics for functional and logic programming. </title> <booktitle> In Proceedings of the ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 320-331, </pages> <address> Cambridge, MA, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: One can, for instance, begin with a functional language like Lisp and add backtracking and unification. In fact, some early languages for Artificial Intelligence, like Planner [18] and Qlisp [40], had these facilities (and more). One can, alternatively, add set constructs to functional languages <ref> [22, 27, 33, and others] </ref>. Or one can go in the opposite direction, starting with Prolog and adding function definitions. Such languages normalize terms before attempting unification, but do not use the definitions to instantiate free variables during goal reduction.
Reference: [23] <author> N. Alan Josephson and Nachum Dershowitz. </author> <title> An implementation of narrowing. </title> <journal> J. Logic Programming, </journal> 6(1&2):57-77, January/March 1989. 
Reference-contexts: Narrowing can be simulated in Prolog by decomposing terms, as first done in [3]. A logic-programming language with narrowing-like operational semantics was first suggested in [4], but only unconditional rules were used (conditionals were encoded as equivalences); equational Horn clauses were first used in Eqlog [12], Rite <ref> [8, 23] </ref>, and Slog [10], and have more recently been implemented in Babel [31]. For additional references and comparisons with other suggestions, see the discussion in [8]. <p> It is possible to minimize the overhead involved in various ways, including taking advantage of the fact that rewrites have only local impact and rewrites that fail only because of a mismatch with a free variable signify a potential narrowing <ref> [23] </ref>. Assuming ground confluence and termination, any strategy can be used for simplification. Narrowing, always preceded by simplification, is complete for ground confluent terminating systems (without "extra" variables appearing in the condition or right-hand side of a rule, but not on the left-hand side).
Reference: [24] <author> Stephane Kaplan. </author> <title> Rewriting with a nondeterministic choice operator. </title> <editor> In B. Robiinet and R. Wilhelm, editors, </editor> <booktitle> Proceedings of the European Symposium on Programming (Saarbucken, F.R.G.), volume 213 of Lecture Notes in Computer Science, </booktitle> <address> page 351ff., Berlin, March 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Narrowing only fully simplified goals has been advocated by [4, 8, 10, 16, 19] and others. With a combined language, the need for some "added features" is ameliorated. For example, multi-valued functions can be better modeled by predicates than with nondeterministic rewriting, as in <ref> [24] </ref>. Goal-solving can then find the different values satisfying the relation. Functional dependency is in the syntax. Negation can be handled by incorporating negative information in the form of rewrite rules, which are then used to simplify subgoals to false [8, 10, 15].
Reference: [25] <author> Stephane Kaplan. </author> <title> Simplifying conditional term rewriting systems: Unification, termination and confluence. </title> <journal> J. Symbolic Computation, </journal> <volume> 4(3) </volume> <pages> 295-334, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: More specifically, with ground confluence, any irreducible solution to a goal can be found by narrowing <ref> [21, 25] </ref>. (An "irreducible" solution assigns normal forms to each variable.) Limiting one to irreducible solutions is justifiable in a functional setting, since the "values" one is looking for are always constructor terms.
Reference: [26] <author> Jan Willem Klop. </author> <title> Term rewriting systems. </title> <editor> In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, chapter 1, </volume> <pages> pages 1-117. </pages> <publisher> Oxford University Press, Oxford, </publisher> <year> 1992. </year>
Reference-contexts: Confluence of a rewrite system is a property that ensures that no term has more than one normal form. For a survey of the theory of conditional (and unconditional) rewriting, see <ref> [26] </ref>. There are two approaches to completeness of equational programming, both of which demand confluence for ground terms. In analogy with functional programming, one can insist that left-hand side patterns do not overlap and that no variable appears more than once in a pattern. <p> Orthogonal normal systems are also confluent (see <ref> [26, Theorem 3.0.10] </ref>). The alternative approach requires that all computation strategies terminate in a normal form. <p> Decreasing systems exactly capture the finiteness of recursive evaluation of terms. Uniqueness is ensured if the system passes a "critical pair" test <ref> [26, Definition 3.0.14] </ref>, which states that confluence of (finite) terminating systems can be effectively tested by checking that both sides of each of a finite set of equations have the same normal form, but this is not a necessary condition for ground confluence [26, Theorem 3.0.15]. <p> the system passes a "critical pair" test [26, Definition 3.0.14], which states that confluence of (finite) terminating systems can be effectively tested by checking that both sides of each of a finite set of equations have the same normal form, but this is not a necessary condition for ground confluence <ref> [26, Theorem 3.0.15] </ref>. Without the decreasing condition, the critical pair test is insufficient, though it does apply when no left-hand side unifies with a proper subterm of any left-hand side [26, Theorem 3.0.15]. <p> a finite set of equations have the same normal form, but this is not a necessary condition for ground confluence <ref> [26, Theorem 3.0.15] </ref>. Without the decreasing condition, the critical pair test is insufficient, though it does apply when no left-hand side unifies with a proper subterm of any left-hand side [26, Theorem 3.0.15]. Note that interpreting Horn clauses as conditional rewrite rules (rewriting predicates to true) gives a system satisfying this constraint, because predicate symbols are never nested in the "head" of a clause. Furthermore, all critical pairs pass the test, since all right-hand sides are the same. <p> Whereas the first approach suffers from strong syntactic restriction of orthogonality; the second has the disadvantage of requiring termination, leaving interpreters, streams, and other nonterminating programs behind. For other methods of establishing conditional confluence, see <ref> [15, 26] </ref>. 3 Functional-Logic Programming Various proposals have been set forth for combining features of functional programming and logic (relational) programming; surveys include [1, 15, 35]. Functional notation and an evaluation mechanism are borrowed from functional programming; assignment by unification and goal-solving are borrowed from logic programming. <p> Since S 0 does not destroy any argument x i of f , we must actually have at least one R step. Thus, were the combined system not terminating, there would exist an infinite sequence with R alone. Since the combined system is terminating, by Knuth's Critical Pair Lemma <ref> [26, Lemma 1.4.11] </ref>, it is also confluent. Thus any derivation from s leads to the same normal form, call it t 0 . Since S applies to any subterm headed by an f , the term t, which is in S normal form, cannot contain any f 's.
Reference: [27] <author> John W. Lloyd. </author> <booktitle> Combining functional and logic programming languages. In Proceedings of the 1994 International Logic Programming Symposium, </booktitle> <address> Cambridge, MA, 1994. </address> <publisher> MIT Press. </publisher>
Reference-contexts: One can, for instance, begin with a functional language like Lisp and add backtracking and unification. In fact, some early languages for Artificial Intelligence, like Planner [18] and Qlisp [40], had these facilities (and more). One can, alternatively, add set constructs to functional languages <ref> [22, 27, 33, and others] </ref>. Or one can go in the opposite direction, starting with Prolog and adding function definitions. Such languages normalize terms before attempting unification, but do not use the definitions to instantiate free variables during goal reduction. <p> An exception may be "fairly" terminating systems like a gcd program with a rule gcd (x; y) ! gcd (y; x). Complete methods are wanting. * Ventures into the realm of non-Horn reasoning are always tempting. Besides negation, limited disjunction may be possible <ref> [8, 27] </ref>. * Constraint programming is an important development and may be a more comfortable setting in which to incorporate reasoning with directed equalities. * In an equational language, it may not be clear how individual equations should be oriented.
Reference: [28] <author> Christopher Lynch. </author> <title> Oriented equational logic programming is complete. </title> <type> Unpublished report, </type> <institution> Centre de Recherche en Informatique de Nancy, </institution> <address> Nancy, France, </address> <year> 1995. </year>
Reference-contexts: Additional useful completeness results are needed (<ref> [28] </ref> is one such). * Computing by forward reasoning from the program [4, 8] is a possibility that is particularly attractive in a database setting. Better yet, the recent work of [28] allows for both bottom-up and top-down computing. * The language must be typed. An example of a language that also in-corporates higher-order functions is -Prolog [29]. <p> Existing methods for establishing termination and confluence are geared to the significantly simpler case of unconditional rules. An alternative would be to use forms of ordered Horn-clause resolution like <ref> [5, 28] </ref>.
Reference: [29] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simle unification. </title> <editor> In P. Schroeder-Heister, editor, </editor> <booktitle> Proceedings of the International Workshop on Extensions of Logic Programming (Tubingen, F.R.G.), volume 475 of Lecture Notes in Computer Science, </booktitle> <pages> pages 253-280, </pages> <address> Berlin, </address> <month> December </month> <year> 1989. </year> <note> Springer-Verlag. </note>
Reference-contexts: Better yet, the recent work of [28] allows for both bottom-up and top-down computing. * The language must be typed. An example of a language that also in-corporates higher-order functions is -Prolog <ref> [29] </ref>.
Reference: [30] <author> Juan Jose Moreno-Navarro. </author> <title> Expressivity of functional-logic languages and their implementation. </title> <editor> In M. Alpuente and R. Barbuti, editors, </editor> <booktitle> Joint Conference on Declarative Programming GULP-PRODE'94. </booktitle> <institution> GULP (Italian ALP Chapter), Universidad Politecnica Valencia, Ser-vicio de publicaciones Universidad Politecnica de Valencia, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: use "directed" goals of the form e ! ? z, similar to the equations in "normal" conditions, meaning that we are looking for a z that is the normal form of e [9]. 5 Stream Programming The desirability of incorporating infinite structures in a functional-logic language has been widely asserted <ref> [2, 30] </ref>. Unfortunately, we are presented with a tradeoff between the benefits of lazy evaluation of orthogonal, non-terminating rules and those of eager simplification with terminating, non-orthogonal rules. Starting from the lazy approach, one can allow some additional simplification rules.
Reference: [31] <author> Juan Jose Moreno-Navarro and Mario Rodriguez-Artalejo. </author> <title> Logic programming with functions and predicates: The language Babel. </title> <journal> J. Logic Programming, </journal> <volume> 12 </volume> <pages> 191-223, </pages> <year> 1992. </year>
Reference-contexts: A logic-programming language with narrowing-like operational semantics was first suggested in [4], but only unconditional rules were used (conditionals were encoded as equivalences); equational Horn clauses were first used in Eqlog [12], Rite [8, 23], and Slog [10], and have more recently been implemented in Babel <ref> [31] </ref>. For additional references and comparisons with other suggestions, see the discussion in [8]. <p> The orthogonal approach to equational programming leads to a lazy, outermost narrowing strategy [34], as in the Babel language <ref> [31] </ref>, which is complete in that case. Alternative narrowing derivations must be explored if completeness is to be assured, since deterministically choosing one possible narrowing over others will not guarantee that solutions will be found. Restrictions and variations of narrowing that do preserve completeness are summarized in [15].
Reference: [32] <author> Michael J. O'Donnell. </author> <title> Equational Logic as a Programming Language. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: even for nonterminating sets of rules, and an outermost rewriting strategy is guaranteed to reach a normal form if such exists, for which reason, orthogonal systems are popular in equation-based programming languages [33]. (For efficiency reasons, one may want to impose additional restrictions on the form of left-hand side patterns <ref> [32] </ref>.) A conditional rewrite system is normal if one side of each condition in each rule is a ground normal form (like true). Orthogonal normal systems are also confluent (see [26, Theorem 3.0.10]). The alternative approach requires that all computation strategies terminate in a normal form.
Reference: [33] <author> Michael J. O'Donnell. </author> <title> Equational logic programming. </title> <editor> In Dov Gab-bay, editor, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, volume 5, Logic Programming, chapter 2. </booktitle> <institution> Oxford University Press, </institution> <note> to appear. </note>
Reference-contexts: The gcd program is not orthogonal. Unconditional orthogonal systems are confluent, even for nonterminating sets of rules, and an outermost rewriting strategy is guaranteed to reach a normal form if such exists, for which reason, orthogonal systems are popular in equation-based programming languages <ref> [33] </ref>. (For efficiency reasons, one may want to impose additional restrictions on the form of left-hand side patterns [32].) A conditional rewrite system is normal if one side of each condition in each rule is a ground normal form (like true). <p> One can, for instance, begin with a functional language like Lisp and add backtracking and unification. In fact, some early languages for Artificial Intelligence, like Planner [18] and Qlisp [40], had these facilities (and more). One can, alternatively, add set constructs to functional languages <ref> [22, 27, 33, and others] </ref>. Or one can go in the opposite direction, starting with Prolog and adding function definitions. Such languages normalize terms before attempting unification, but do not use the definitions to instantiate free variables during goal reduction.
Reference: [34] <author> Uday S. Reddy. </author> <title> Narrowing as the operational semantics of functional languages. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 138-151, </pages> <address> Boston, MA, </address> <month> July </month> <year> 1985. </year> <note> IEEE. </note>
Reference-contexts: For additional references and comparisons with other suggestions, see the discussion in [8]. To force conditions to be evaluated (or solved) before the branches of a conditional construct, some authors impose a leftmost strategy (e.g. <ref> [34] </ref>); for conditional systems, one can let narrowing go through only after establishing that the conditions hold (e.g. [8, 10, 12]). <p> The orthogonal approach to equational programming leads to a lazy, outermost narrowing strategy <ref> [34] </ref>, as in the Babel language [31], which is complete in that case. Alternative narrowing derivations must be explored if completeness is to be assured, since deterministically choosing one possible narrowing over others will not guarantee that solutions will be found.
Reference: [35] <author> Uday S. Reddy. </author> <title> On the relationship between logic and functional languages. </title> <editor> In D. DeGroot and G. Lindstrom, editors, </editor> <title> Logic Programming: Functions, Relations, </title> <booktitle> and Equations, </booktitle> <pages> pages 3-36. </pages> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: For other methods of establishing conditional confluence, see [15, 26]. 3 Functional-Logic Programming Various proposals have been set forth for combining features of functional programming and logic (relational) programming; surveys include <ref> [1, 15, 35] </ref>. Functional notation and an evaluation mechanism are borrowed from functional programming; assignment by unification and goal-solving are borrowed from logic programming. One can, for instance, begin with a functional language like Lisp and add backtracking and unification. <p> One can use the "in-then-else" construct of functional languages to capture the implications of Horn clauses and use goal solving for "logic variables." alternatively, conditional systems provide a natural bridge between functional programming, based on equational semantics, and logic-programming, based on Horn clauses. See <ref> [35] </ref>. Narrowing [36, 37] is a "linear" restriction of paramodulation akin to the SLD-strategy in Horn-clause logic [2]. Whereas paramodulation uses both sides of an equation in the same way, narrowing is more directed| unifying with left-hand sides only|thereby taking the direction of rewriting into account.
Reference: [36] <author> J. R. Slagle. </author> <title> Automated theorem-proving for theories with simplifiers, commutativity, and associativity. </title> <journal> J. of the Association for Computing Machinery, </journal> <volume> 21(4) </volume> <pages> 622-642, </pages> <year> 1974. </year>
Reference-contexts: One can use the "in-then-else" construct of functional languages to capture the implications of Horn clauses and use goal solving for "logic variables." alternatively, conditional systems provide a natural bridge between functional programming, based on equational semantics, and logic-programming, based on Horn clauses. See [35]. Narrowing <ref> [36, 37] </ref> is a "linear" restriction of paramodulation akin to the SLD-strategy in Horn-clause logic [2]. Whereas paramodulation uses both sides of an equation in the same way, narrowing is more directed| unifying with left-hand sides only|thereby taking the direction of rewriting into account.
Reference: [37] <author> V. F. Turchin. </author> <title> Equivalent transformation of recursive functions defined in the language Refal. </title> <booktitle> In Sympos Teoria Yazykov i Metody Prostroenia System Programirowania, </booktitle> <pages> pages 31-42. </pages> <address> Alushta-Kiev, </address> <year> 1972. </year> <note> in Russian. </note>
Reference-contexts: One can use the "in-then-else" construct of functional languages to capture the implications of Horn clauses and use goal solving for "logic variables." alternatively, conditional systems provide a natural bridge between functional programming, based on equational semantics, and logic-programming, based on Horn clauses. See [35]. Narrowing <ref> [36, 37] </ref> is a "linear" restriction of paramodulation akin to the SLD-strategy in Horn-clause logic [2]. Whereas paramodulation uses both sides of an equation in the same way, narrowing is more directed| unifying with left-hand sides only|thereby taking the direction of rewriting into account.
Reference: [38] <author> David A. Turner. </author> <title> SASL language manual. </title> <type> Technical report, </type> <institution> University of Kent, Canterbury, U.K., </institution> <year> 1976. </year>
Reference-contexts: The mutual exclusiveness of the different cases in function definitions guarantees that s is equal to at most one constructor term t. It is well known that a "lazy" ("outermost fair", "call by name") evaluation strategy|as employed in Sasl <ref> [38] </ref> or Miranda [39]|is required for completeness, and that an "eager" (innermost, "call by value") strategy|as in Lisp or ML|can lead to an infinite computation, without ever finding t. Thus, an interpreter programmed in a lazy language will terminate whenever the computation it is mimicking terminates.
Reference: [39] <author> David A. Turner. </author> <title> An overview of Miranda. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 158-166, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: else car (x) : inter (y; cdr (x)) In ML, and most modern functional languages, patterns are used to delineate the various cases in a definition; thus one can write instead something like: inter (nil; y) ! y inter (z : x; y) ! z : inter (y; x) Miranda <ref> [39] </ref> allows repeated variables in patterns to indicate that a clause of the definition applies only when two arguments are identical. Functional languages are typically higher-order and allow for functions to be passed as arguments to other functions, but patterns cannot be used to distinguish one functional argument from another.
Reference: [40] <author> B. Michael Wilber. </author> <title> A Qlisp reference manual. </title> <type> Technical note 118, </type> <institution> Artificial Intelligence Center, Stanford Research Institute, </institution> <address> Menlo Park, CA, </address> <month> March </month> <year> 1976. </year>
Reference-contexts: One can, for instance, begin with a functional language like Lisp and add backtracking and unification. In fact, some early languages for Artificial Intelligence, like Planner [18] and Qlisp <ref> [40] </ref>, had these facilities (and more). One can, alternatively, add set constructs to functional languages [22, 27, 33, and others]. Or one can go in the opposite direction, starting with Prolog and adding function definitions.
References-found: 40

