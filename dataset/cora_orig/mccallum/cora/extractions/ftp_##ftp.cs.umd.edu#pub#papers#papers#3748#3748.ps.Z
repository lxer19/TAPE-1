URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3748/3748.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: Automated Computation of Decomposable Synchronization Conditions  
Author: Gilberto Matos James Purtilo Elizabeth White 
Note: This research is Supported by the Office of Naval Research under contract ONR N000149410320  
Address: College Park, MD 20742  
Affiliation: Computer Science Department and Institute for Advanced Computer Studies University of Maryland  Department of Computer Science George Mason University  
Abstract: The most important aspect of concurrent and distributed computation is the interaction between system components. Integration of components into a system requires some synchronization that prevents the components from interacting in ways that may endanger the system users, its correctness or performance. The undesirable interactions are usually described using temporal logic, or safety and liveness assertions. Automated synthesis of synchronization conditions is a portable alternative to the manual design of system synchronization, and it is already widespread in the hardware CAD domain. The automated synchronization for concurrent software systems is hindered by their excessive complexity, because their state spaces can rarely be exhaustively analyzed to compute the synchronization conditions. The analysis of global state spaces is required for liveness and real-time properties, but simple safety rules depend only on the referenced components and not on the rest of the system or its environment. Synchronization conditions for delayable safety critical systems can be computed without the state space analysis, and decomposed into single component synchronization conditions. Automated synthesis of decomposable synchronization conditions provides a solid groundwork for the independent design of system components, and supports reuse and maintenance in concurrent software systems. This approach to integration of concurrent systems is embodied by GenEx, an analysis and synchronization tool that integrates system components to satisfy a given set of safety rules, and produces executable systems. 
Abstract-found: 1
Intro-found: 1
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.J. Dill, and L.J. Hwang. </author> <title> "Symbolic Model Checking: 10 20 States and Beyond". </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This approach is orthogonal to automatic synchronization, and the same abstraction and removal of irrelevant states can be used in GenEx to reduce the complexity of the reachability analysis. Symbolic model checking <ref> [BCM + 90] </ref> relies on the symbolic representation of the state space, where regularities in the state space are exploited to minimize the complexity of the representation. These techniques are very powerful analysis tools, but they require the designer to correct all inconsistencies.
Reference: [BG92] <author> G. Berry and G. Gonthier. </author> <title> "The Esterel Synchronous Programming Language: Design, Semantics, </title> <booktitle> Implementation". Science of Computer Programming, </booktitle> <year> 1992. </year> <month> 32 </month>
Reference-contexts: The effects associated with a given transition are changes in the value of controlled system variables, and calls to data processing segments. GenEx uses the synchronous execution semantics similar to SMV [McM93], Esterel <ref> [BG92] </ref> and LUSTRE [CRR91]. When the transitions are executed, every component updates the values of its controlled variables, and shares that data with all other components. A transition is enabled when the associated combination of events and conditions is true. <p> The performance of the generated code is potentially very high, because our descriptive model is based on deterministic finite state machines that can be naturally mapped into efficient executable code. 26 Several systems have used the code generation to implement synchronized concurrent sys-tems, LUSTRE [CRR91] and Esterel <ref> [BG92] </ref> being based on a similar model of computation as GenEx. These systems use a synchronized model of computation, making them simple to analyze and generate code for. Both LUSTRE and Esterel support the verification of given system properties versus the system behavior. <p> The system will also be compared to systems that are based on the verification of user generated concurrent systems such as Esterel <ref> [BG92] </ref> or SMV [McM93]. 7 Conclusion As described in the previous sections, the process of automatic rule-based synchronization takes a set of system components and system safety requirements, and produces an integrated system consistent with the given requirements.
Reference: [Bro86] <author> Michael C. Browne. </author> <title> "An Improved Algorithm for the Automatic Verification of Finite State Systems Using Temporal Logic". </title> <booktitle> In Proceedings of the Symposium on Logic in Computer Science, </booktitle> <pages> pages 260-266, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Proving correctness of abstract descriptions is of limited use because of the possible discrepancies between the implementation and the description. In general the scalability of this approach is limited by the complexity of the system. When complexity is kept low, mcb <ref> [Bro86, CES86] </ref> can successfully and efficiently check formulas in first order temporal logic CTL. PAL [YY91], [YY93] is a compositional reachability analysis tool that uses algebraic methods to reduce the state space of the problem.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Proving correctness of abstract descriptions is of limited use because of the possible discrepancies between the implementation and the description. In general the scalability of this approach is limited by the complexity of the system. When complexity is kept low, mcb <ref> [Bro86, CES86] </ref> can successfully and efficiently check formulas in first order temporal logic CTL. PAL [YY91], [YY93] is a compositional reachability analysis tool that uses algebraic methods to reduce the state space of the problem.
Reference: [CG95] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency between Implementations and Requirements". </title> <type> Technical report CS-TR-3394, </type> <institution> Dept. of CS, University of Maryland, College Park, </institution> <month> January </month> <year> 1995. </year> <note> (in preparation). </note>
Reference-contexts: Some systems try to extract abstract information from the source and do partial analysis. STeP [ZM + 94] tries to prove the given assertions automatically and when that fails it lets the designer guide the proof by choosing the assertions that are to be proved. Analyzer <ref> [CG95] </ref> requires additional information related to the abstract description to be inserted in the source code, and combines it with the program reachability graph to check the consistency of the program and SCR [Hen80] style specifications.
Reference: [CLM89] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> "Compositional Model Checking". </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 464-475, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Compositional and symbolic model checking are two approaches that try to reduce the complexity of the state space representations. Compositional model checking <ref> [CLM89] </ref>, [FG94] tries to limit the complexity by constructing abstractions that can represent system components in further analysis of the given properties. By eliminating states that are irrelevant to the property, it can achieve significant reduction in the complexity of the analysis.
Reference: [CRR91] <author> N. Halbwachs C. Ratel and P. Raymond. </author> <title> "Programming and veryfying critical systems by means of the synchronous data-flow programming language LUSTRE". </title> <booktitle> Software Engineering Notes, </booktitle> <pages> pages 112-119, </pages> ? <year> 1991. </year>
Reference-contexts: The effects associated with a given transition are changes in the value of controlled system variables, and calls to data processing segments. GenEx uses the synchronous execution semantics similar to SMV [McM93], Esterel [BG92] and LUSTRE <ref> [CRR91] </ref>. When the transitions are executed, every component updates the values of its controlled variables, and shares that data with all other components. A transition is enabled when the associated combination of events and conditions is true. The monitored variables are sampled and all components receive their current value. <p> The performance of the generated code is potentially very high, because our descriptive model is based on deterministic finite state machines that can be naturally mapped into efficient executable code. 26 Several systems have used the code generation to implement synchronized concurrent sys-tems, LUSTRE <ref> [CRR91] </ref> and Esterel [BG92] being based on a similar model of computation as GenEx. These systems use a synchronized model of computation, making them simple to analyze and generate code for. Both LUSTRE and Esterel support the verification of given system properties versus the system behavior.
Reference: [dLSA95] <author> Rogerio de Lemos, Amer Saeed, and Tom Anderson. </author> <title> "Analyzing Safety Requirements for Process-Control Systems". </title> <journal> IEEE Software, </journal> <volume> 12(3), </volume> <month> May </month> <year> 1995. </year>
Reference-contexts: Formal development methods are widely used in the research community [Man96], but their acceptance in development environments is lagging. The main reasons for this are the high level of skill that is generally required for formal verification, its lack of scalability, and its resistance to incremental system evolution <ref> [dLSA95] </ref>. Automated correction of inconsistencies between software systems and requirements is generally undecidable, but there are some domains where this approach is a viable alternative to manual error correction [EC82].
Reference: [EC82] <author> E. Allen Emerson and Edmund M. Clarke. </author> <title> "Using Branching Time Temporal Logic to Synthesize Synchronization Skeletons". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2(3) </volume> <pages> 241-266, </pages> <month> Dec </month> <year> 1982. </year>
Reference-contexts: Automated correction of inconsistencies between software systems and requirements is generally undecidable, but there are some domains where this approach is a viable alternative to manual error correction <ref> [EC82] </ref>. Most current formal approaches to concurrent systems use finite state machines (FSM) to model components, and finite state domains can be effectively analyzed and transformed. Error correction in FSM-based delayable systems is automated by computing the synchronization conditions from the detected requirement violations. <p> Adding the synchronization conditions to the components makes the system comply with the given safety rules. Previous research in the area of automated synchronization was concentrated in two domains. Theorical research discussed the complexity of automated synchronization for temporal logic assertions <ref> [EC82] </ref>. The complexity of system synchronization for temporal logic assertions is exponential, and not all formulas can be satisfied by synchronizing the system components. Attempts at practical synchronization concentrated on constrained systems 2 such as hardware-based systems [Lim96] or a sequential safety kernel [WK95].
Reference: [FG94] <author> Jeffrey Fischer and Richard Gerber. </author> <title> "Compositional Model Checking of Ada Tasking Programs". </title> <type> Technical report, </type> <institution> University of Maryland College Park, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Compositional and symbolic model checking are two approaches that try to reduce the complexity of the state space representations. Compositional model checking [CLM89], <ref> [FG94] </ref> tries to limit the complexity by constructing abstractions that can represent system components in further analysis of the given properties. By eliminating states that are irrelevant to the property, it can achieve significant reduction in the complexity of the analysis.
Reference: [Hen80] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Notation and a Driving Example This section introduces the FSM-based notation for representing the behavior of concurrent systems, and describes the capabilities of automatic synchronization on a client-server access example. 2.1 Finite State Machine Representation in GenEx GenEx uses a FSM notation inspired by the tabular notation used in SCR <ref> [Hen80] </ref>, and functionally equivalent to a subset of the SMV notation [McM93]. Each component is a Mealy finite state machine [JEH79]. <p> Analyzer [CG95] requires additional information related to the abstract description to be inserted in the source code, and combines it with the program reachability graph to check the consistency of the program and SCR <ref> [Hen80] </ref> style specifications. Due to the undecidability of the program behavior, this analysis is either optimistic or pessimistic, and exact analysis is impossible.
Reference: [JEH79] <author> Jeffrey D. Ullman John E. Hopcroft. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: Each component is a Mealy finite state machine <ref> [JEH79] </ref>. The system contains a set of Boolean variables 3 that can be monitored (external) or controlled (internal), and these variables are the inputs and outputs of the components or the environment. <p> Mutual exclusion requires distinct clients to access the server during nonoverlapping intervals. The client accesses can be ordered using a specific access protocol such as priority or FIFO. GenEx accepts the safety rules represented using finite state machines or regular expressions <ref> [JEH79] </ref>. Both representations are functionally equivalent but suitable for different types of safety rules. The FSM representation of safety rules is similar to the component representation with only minor distinctions.
Reference: [JM] <author> Jeff Kramer Jeff Magee, Narankar Dulay. </author> " <title> A constructive Development Environment for Parallel and Distributed Programs </title> ". 
Reference-contexts: Despite this shortcoming, the system is an example of how simple methods can solve complex problems, given the right domain. The decomposition aspect of our method is based on some features introduced by the configuration languages such as Polylith [Pur94] and Darwin <ref> [JM] </ref>. Separation of conceptual description from the implementation is a powerful concept that provides these languages with great flexibility in porting applications between different environments, due to their 27 support for mapping the concepts to a given physical structure.
Reference: [Lim93] <author> Alvin See Sek Lim. </author> `' <title> A State Machine Approach to Reliable and Dynamically Reconfigurable Distributed Systems ". PhD thesis, </title> <institution> University of Wisconsin., Madison, Wisconsin, </institution> <year> 1993. </year> <month> 33 </month>
Reference-contexts: Also the correctness of the abstraction in no way guarantees the correctness of the implementation done by hand, a fact that reduces the practical applicability of those systems. The concept of product state machines, as described in <ref> [Lim93] </ref>, [Lim96] is conceptually very similar to GenEx, and the main difference between them is the scalability. The approach in Lim's system is that the global reachability graph is actually constructed and restricted to eliminate violation states, and the restricted graph is used in the execution. <p> I am currently aware of only two systems that consider the safety requirements in an abstract form and implement them in the executable system, The Safety Kernel concept [WK95], and the State Combination approach by Lim <ref> [Lim93] </ref>.
Reference: [Lim96] <author> Alvin Lim. </author> <title> "Compositional Synchronization". </title> <booktitle> In International Conference on DCS, </booktitle> <year> 1996. </year>
Reference-contexts: Error correction in FSM-based delayable systems is automated by computing the synchronization conditions from the detected requirement violations. The synchronization conditions restrict the system behavior, and the resulting system model satisfies its safety requirements <ref> [Lim96] </ref>. The automated rule-based synchronization process takes the description of a system and its safety rules, and produces a synchronized model that satisfies safety, and an executable implementation of that model (see Figure 1). <p> Theorical research discussed the complexity of automated synchronization for temporal logic assertions [EC82]. The complexity of system synchronization for temporal logic assertions is exponential, and not all formulas can be satisfied by synchronizing the system components. Attempts at practical synchronization concentrated on constrained systems 2 such as hardware-based systems <ref> [Lim96] </ref> or a sequential safety kernel [WK95]. These do-main restrictions provide a limit on the system complexity or make the synchronization trivial as in the safety kernel case. Automated synchronization of concurrent software systems is the primary goal of our research. <p> Also the correctness of the abstraction in no way guarantees the correctness of the implementation done by hand, a fact that reduces the practical applicability of those systems. The concept of product state machines, as described in [Lim93], <ref> [Lim96] </ref> is conceptually very similar to GenEx, and the main difference between them is the scalability. The approach in Lim's system is that the global reachability graph is actually constructed and restricted to eliminate violation states, and the restricted graph is used in the execution.
Reference: [LL95] <author> Claus Lewerentz and Thomas Lindner. </author> <title> "Formal Development of Reactive Systems". </title> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference: [Man96] <author> Toni Mandrioli. </author> <title> COMPASS 1996 Keynote Address, </title> <year> 1996. </year>
Reference-contexts: This level of reliability is not satisfactory for the safety-critical systems. Automated formal verification can verify the absence of errors, assert a system's reliability, and find errors earlier in the development process thus reducing the development cost <ref> [Man96] </ref>. Formal development methods are widely used in the research community [Man96], but their acceptance in development environments is lagging. The main reasons for this are the high level of skill that is generally required for formal verification, its lack of scalability, and its resistance to incremental system evolution [dLSA95]. <p> This level of reliability is not satisfactory for the safety-critical systems. Automated formal verification can verify the absence of errors, assert a system's reliability, and find errors earlier in the development process thus reducing the development cost <ref> [Man96] </ref>. Formal development methods are widely used in the research community [Man96], but their acceptance in development environments is lagging. The main reasons for this are the high level of skill that is generally required for formal verification, its lack of scalability, and its resistance to incremental system evolution [dLSA95].
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: for representing the behavior of concurrent systems, and describes the capabilities of automatic synchronization on a client-server access example. 2.1 Finite State Machine Representation in GenEx GenEx uses a FSM notation inspired by the tabular notation used in SCR [Hen80], and functionally equivalent to a subset of the SMV notation <ref> [McM93] </ref>. Each component is a Mealy finite state machine [JEH79]. The system contains a set of Boolean variables 3 that can be monitored (external) or controlled (internal), and these variables are the inputs and outputs of the components or the environment. <p> The effects associated with a given transition are changes in the value of controlled system variables, and calls to data processing segments. GenEx uses the synchronous execution semantics similar to SMV <ref> [McM93] </ref>, Esterel [BG92] and LUSTRE [CRR91]. When the transitions are executed, every component updates the values of its controlled variables, and shares that data with all other components. A transition is enabled when the associated combination of events and conditions is true. <p> Another source of deadlocks is the circular dependence between synchronized components. GenEx generates a model of the synchronized system in the SMV <ref> [McM93] </ref> notation that allows symbolic checking of very complex systems. The deadlocks can involve components that are not referenced by a single rule, so the full system may have to be checked. <p> The integration of the system requires a front-end interface that analyzes the safety rules and generates a script with the necessary 28 sequence of automatic synchronization operations. Other integration aspects include the interfaces to temporal logic verification tools such as SMV <ref> [McM93] </ref>. 6.1 Static Violation Detection The automatic synchronization based on the construction of combined reachability graphs has one important drawback. The computational complexity of the graph can exceed the available processing capacity or, the time required to compute the synchronization changes can become too large to be acceptable in practice. <p> The system will also be compared to systems that are based on the verification of user generated concurrent systems such as Esterel [BG92] or SMV <ref> [McM93] </ref>. 7 Conclusion As described in the previous sections, the process of automatic rule-based synchronization takes a set of system components and system safety requirements, and produces an integrated system consistent with the given requirements.
Reference: [Pur94] <author> James Purtilo. </author> <title> "The POLYLITH Software Bus". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 151-174, </pages> <month> jan </month> <year> 1994. </year>
Reference-contexts: Despite this shortcoming, the system is an example of how simple methods can solve complex problems, given the right domain. The decomposition aspect of our method is based on some features introduced by the configuration languages such as Polylith <ref> [Pur94] </ref> and Darwin [JM]. Separation of conceptual description from the implementation is a powerful concept that provides these languages with great flexibility in porting applications between different environments, due to their 27 support for mapping the concepts to a given physical structure.
Reference: [WK95] <author> Kevin G. Wika and John C. Knight. </author> <title> "On the Enforcement of Software Safety Policies". </title> <booktitle> In Proceedings of the Tenth Annual Conference on Computer Assurance, </booktitle> <pages> pages 83-93, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The complexity of system synchronization for temporal logic assertions is exponential, and not all formulas can be satisfied by synchronizing the system components. Attempts at practical synchronization concentrated on constrained systems 2 such as hardware-based systems [Lim96] or a sequential safety kernel <ref> [WK95] </ref>. These do-main restrictions provide a limit on the system complexity or make the synchronization trivial as in the safety kernel case. Automated synchronization of concurrent software systems is the primary goal of our research. <p> Although TRACTA reduces the analysis space using compositional verification, the complexity can be an exponential function of the number of components in the system Another related concept is that of Safety Kernel <ref> [WK95] </ref> that is less formal, but involves the code generation capability and automatic safety implementation. This centralized, and more importantly sequential, paradigm makes the code generation trivial by reducing it to a simple runtime check of the desired property. <p> The benefits of using the automatic synchronization method have to be compared to those of other methods for producing concurrent systems. I am currently aware of only two systems that consider the safety requirements in an abstract form and implement them in the executable system, The Safety Kernel concept <ref> [WK95] </ref>, and the State Combination approach by Lim [Lim93].
Reference: [YY91] <author> Michal Young and Wei Jen Yeh. </author> " <title> Compositional reachability analysis using process algebra". </title> <booktitle> In Proceedings of the Symposium on Softvare Testing, Analysis and Verification (TAV 4), </booktitle> <pages> pages 49-59, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In general the scalability of this approach is limited by the complexity of the system. When complexity is kept low, mcb [Bro86, CES86] can successfully and efficiently check formulas in first order temporal logic CTL. PAL <ref> [YY91] </ref>, [YY93] is a compositional reachability analysis tool that uses algebraic methods to reduce the state space of the problem. It allows the checking of more complex problems, but some examples can force it into searches of exponential size.
Reference: [YY93] <author> Michal Young and Wei Jen Yeh. </author> " <title> Compositional reachability analysis of Ada Programs Using Process Algebra". </title> <month> July </month> <year> 1993. </year>
Reference-contexts: In general the scalability of this approach is limited by the complexity of the system. When complexity is kept low, mcb [Bro86, CES86] can successfully and efficiently check formulas in first order temporal logic CTL. PAL [YY91], <ref> [YY93] </ref> is a compositional reachability analysis tool that uses algebraic methods to reduce the state space of the problem. It allows the checking of more complex problems, but some examples can force it into searches of exponential size.
Reference: [ZM + 94] <author> Nikolaj Bjorner Zohar Manna, Anuchit Anuchitanukul et al. </author> " <title> STeP: the Stan-ford Temporal Prover". </title> <month> June </month> <year> 1994. </year> <month> 34 </month>
Reference-contexts: Proofs on real code are rarely used because their complexity is generally unacceptably high, and they are often undecidable. Some systems try to extract abstract information from the source and do partial analysis. STeP <ref> [ZM + 94] </ref> tries to prove the given assertions automatically and when that fails it lets the designer guide the proof by choosing the assertions that are to be proved.
References-found: 23

