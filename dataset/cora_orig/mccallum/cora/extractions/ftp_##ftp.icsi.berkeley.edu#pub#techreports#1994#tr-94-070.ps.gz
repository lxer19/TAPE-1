URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1994/tr-94-070.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1994.html
Root-URL: http://www.icsi.berkeley.edu
Email: phlipp  
Title: Automatic Alignment of Array Data and Processes To Reduce Communication Time on DMPPs  
Phone: (510) 643-9153 FAX (510) 643-7684  
Author: Michael Philippsen 
Note: On leave from  
Date: July 1995  
Web: icsi.berkeley.edu TR-94-070  
Address: I 1947 Center St. Suite 600 Berkeley, California 94704-1198  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  Department of Computer Science, University of Karlsruhe, Germany  
Abstract: This paper investigates the problem of aligning data and processes in a distributed-memory implementation. We present complete algorithms for compile-time analysis, the necessary program restructuring, and subsequent code-generation, and discuss their complexity. We finally evaluate the practical usefulness by quantitative experimentation. The technique presented analyzes complete programs, including branches, loops, and nested parallelism. Alignment is determined with respect to offset, stride, and general axis relations. Both placement of data and processes are computed in a unifying framework based on an extended preference graph and its analysis. Furthermore, dynamic redistribution and replication are considered in the same technique. The experimental results are very encouraging. The optimization algorithms implemented in the Modula-2* compiler improved the execution times of the programs by over 40% on a MasPar MP-1 with 16384 processors. This paper appeared in: Proceedings of the 5th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPoPP, pp. 156-165, Santa Barbara, CA, July 19-21, 1995. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V. Balasundaram, G. Fox, K. Kennedy, and U. Kremer. </author> <title> A static performance estimator to guide data partitioning decisions. </title> <journal> Sigplan Notices 26(7) </journal> <pages> 213-223, </pages> <year> 1991. </year>
Reference-contexts: The programmer not only has to find an optimal placement for code segments, which is itself difficult as explained above, but s/he must find a global optimum that includes the cost of potential redistributions at certain points of the code. The necessary cost considerations are complex <ref> [1, 8] </ref> and in general undecidable since they require knowledge about compiler strategies, about network characteristics etc. Finally, even if the programmer provides explicit placement information for the declared data structures, it remains the task of the compiler to place temporaries.
Reference: [2] <author> Robert Bixby, Ken Kennedy, and Ulrich Kremer. </author> <title> Automatic data layout using 0-1 integer programming. </title> <type> Tech. Report CRPC-TR93349-S, </type> <institution> Rice University, </institution> <year> 1993. </year>
Reference-contexts: He does consider both alignment and distribution and hence uses a more accurate cost estimate than Li and Chen do. The approach by Ramanujam [29] delivers good data placement unless conflicting alignment preferences exist. However, such conflicts occur commonly. Kremer <ref> [2, 19, 20] </ref> takes a different approach. Instead of building placement optimization into a compiler, he develops tools to support the programmer in finding good placements. Although the approach is different, Kremer applies placement optimization techniques based on Li and Chen's Component-Affinity-Graph. <p> A simple basic solution is x i = 1 for all i 2 I. Results by Kremer <ref> [2, 20] </ref> also indicate the usefulness of integer programming for placement problems.
Reference: [3] <author> B. Chapman, H. Herbeck, and H. Zima. </author> <title> Automatic support for data distribution. </title> <booktitle> In 6th Distrib. Memory Computing Conf., </booktitle> <pages> pp. 51-58, </pages> <address> Portland, OR, </address> <year> 1991. </year>
Reference-contexts: Some of those require that data is mapped onto the topology by hand [24, 32], others are user guided and offer sets of directives for the compiler, abstract topologies (so-called templates), or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions <ref> [3, 15, 16] </ref>. Much recent work focuses on static compile-time analysis to automatically find good data decompositions for vector and data-parallel operations. We describe this work in more detail in section 2. Placement optimization is often done in two steps. <p> Finally, section 5 describes the setup and results of the experiments evaluating the effectiveness of our techniques. 2 Related Work The two phase approach to placement (alignment + distribution) is used by Fortran D [10], HPF [16], CM-Fortran [31], and Vienna Fortran <ref> [3] </ref>. Although our work as well is based on the two phase approach, it is different, since it performs both phases automatically. fl On leave from Dept. of Informatics, University of Karlsruhe.
Reference: [4] <author> S. Chatterjee, J. Gilbert, and R. Schreiber. </author> <title> The alignment-distribution graph. </title> <booktitle> In 6th Workshop on Languages and Compilers for Parallelism, </booktitle> <pages> pp. 234-252, </pages> <address> Portland, OR, </address> <year> 1993. </year>
Reference-contexts: He introduced the idea of using 0-1 integer programming for solving placement problems. Most of the groups have two basic approaches in common, both of which result in suboptimal solutions: process placement is derived from data placement and placement of temporaries is not considered. Gilbert, Schreiber, Chatterjee <ref> [4, 5, 12, 30] </ref> base their work on the Alignment-Distribution-Graph. In contrast to the approaches mentioned before, the authors tackle the problem of placing intermediate results. To our knowledge, their model for representing the cost of communication on the underlying topologies is the most advanced.
Reference: [5] <author> S. Chatterjee, J. Gilbert, R. Schreiber, and S.-H. Teng. </author> <title> Automatic array alignment in data-parallel programs. </title> <booktitle> In 20th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 16-28, </pages> <year> 1993. </year>
Reference-contexts: Furthermore, we feel that both process and data alignment must be considered. Simply deriving process placements from data placements is suboptimal as has been shown for the owner-computes rule in <ref> [5, 17] </ref>. There are already approaches to automatic alignment. In comparison to our work see [26, 28] for previous contributions these have some restrictions. Knobe et al. [17, 18] first introduced alignment analysis and the notion of preference graphs. Although they considered dimension, stride, and offset alignment, some problems remained. <p> He introduced the idea of using 0-1 integer programming for solving placement problems. Most of the groups have two basic approaches in common, both of which result in suboptimal solutions: process placement is derived from data placement and placement of temporaries is not considered. Gilbert, Schreiber, Chatterjee <ref> [4, 5, 12, 30] </ref> base their work on the Alignment-Distribution-Graph. In contrast to the approaches mentioned before, the authors tackle the problem of placing intermediate results. To our knowledge, their model for representing the cost of communication on the underlying topologies is the most advanced.
Reference: [6] <author> N. Deo. </author> <title> Graph Theory with Appl. to Engineering and Computer Science. </title> <publisher> Prentice Hall, </publisher> <year> 1974. </year>
Reference-contexts: The problem is to determine which of the edges to cut to 3 If unfamiliar with these terms, see for example <ref> [6] </ref>. achieve minimal cost by cutting all cycles. This prob-lem is another representation of the weighted set covering problem [11] since some edges belong to several cycles.
Reference: [7] <author> N. Deo, M. Prabhu, </author> <title> and M.S. Krishnamoothy. Algorithms for generating fundamental cycles in a graph. </title> <journal> ACM Trans. on Mathem. Software, </journal> <volume> 8(1) </volume> <pages> 26-42, </pages> <year> 1982. </year>
Reference-contexts: Although the sub-problem of finding the minimal set of fundamental cycles is itself NP-complete, good polynomial time approximations are known <ref> [7] </ref>. 4.5.2 Minimal Covering Even if the minimal set of fundamental cycles is known, the remaining sub-problem still is NP-complete. The problem is to determine which of the edges to cut to 3 If unfamiliar with these terms, see for example [6]. achieve minimal cost by cutting all cycles.
Reference: [8] <author> T. Fahringer, R. Blasko, and H. Zima. </author> <title> Static performance prediction to support parallelization of Fortran programs for massively parallel systems. </title> <booktitle> In Int. Conf. on Supercomputing, </booktitle> <pages> pp. 347-356, </pages> <address> Washington, </address> <year> 1992. </year>
Reference-contexts: The programmer not only has to find an optimal placement for code segments, which is itself difficult as explained above, but s/he must find a global optimum that includes the cost of potential redistributions at certain points of the code. The necessary cost considerations are complex <ref> [1, 8] </ref> and in general undecidable since they require knowledge about compiler strategies, about network characteristics etc. Finally, even if the programmer provides explicit placement information for the declared data structures, it remains the task of the compiler to place temporaries.
Reference: [9] <author> J.T. Feo, </author> <title> editor. A Comparative Study of Parallel Programming Languages. </title> <publisher> Elsevier , Holland, </publisher> <year> 1992. </year>
Reference-contexts: As soon as a doctor and a patient are paired, the doctor diagnoses the illness and treats the patient in a random amount of time. After curing a patient, the doctor rejoins the doctor's queue to await another patient (from <ref> [9] </ref>). Approach: The random amounts of time that patients are well and that doctors need to treat illnesses are counted down in parallel. The assignments of doctors to patients is done in parallel. <p> Discussion: See 5.1.12. 5.1.14 Paraffins Problem Problem: Given an integer n, output the chemical structure of all paraffin molecules for i n, without repetition and in order of increasing size. Include all isomers, but no duplicates (from <ref> [9] </ref>). Note: The vertical axis is scaled differently. Discussion: The unavoidable amount of remote communication becomes the predominant cost factor with growing problems.
Reference: [10] <author> G. Fox, S. Hiranandani, K. Kennedy, C. Koelbel, U. Kremer, C.-W. Tseng, and M.-Y. Wu. </author> <title> Fortran D language specification. </title> <type> Tech. Report CRPC-TR90079, </type> <institution> Rice University, </institution> <year> 1990. </year>
Reference-contexts: Section 4 formulates the alignment optimization and discusses its properties. Finally, section 5 describes the setup and results of the experiments evaluating the effectiveness of our techniques. 2 Related Work The two phase approach to placement (alignment + distribution) is used by Fortran D <ref> [10] </ref>, HPF [16], CM-Fortran [31], and Vienna Fortran [3]. Although our work as well is based on the two phase approach, it is different, since it performs both phases automatically. fl On leave from Dept. of Informatics, University of Karlsruhe.
Reference: [11] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability. W.H. </title> <publisher> Freeman, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: The problem is to determine which of the edges to cut to 3 If unfamiliar with these terms, see for example [6]. achieve minimal cost by cutting all cycles. This prob-lem is another representation of the weighted set covering problem <ref> [11] </ref> since some edges belong to several cycles. It can be written as a linear programming problem: For i 2 I numbering the edges in the set of fundamental cycles, let c i be the cost of edge i and x i 2 f0; 1g be integer variables.
Reference: [12] <author> J. Gilbert and R. Schreiber. </author> <title> Optimal expression evaluation for data parallel architectures. </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> 13(1) </volume> <pages> 58-64, </pages> <year> 1991. </year>
Reference-contexts: He introduced the idea of using 0-1 integer programming for solving placement problems. Most of the groups have two basic approaches in common, both of which result in suboptimal solutions: process placement is derived from data placement and placement of temporaries is not considered. Gilbert, Schreiber, Chatterjee <ref> [4, 5, 12, 30] </ref> base their work on the Alignment-Distribution-Graph. In contrast to the approaches mentioned before, the authors tackle the problem of placing intermediate results. To our knowledge, their model for representing the cost of communication on the underlying topologies is the most advanced.
Reference: [13] <author> M. Gupta and P. Banerjee. </author> <title> Automatic data partitioning on distributed memory multiprocessors. </title> <booktitle> In 6th Dis-trib. Memory Computing Conf., </booktitle> <pages> pp. 43-50, </pages> <address> Portland, OR, </address> <year> 1991. </year>
Reference-contexts: Dynamic redistribution is considered only in special cases. Neither dynamic redistribution nor loops or branches are considered by Wholey [35], Li and Chen [21, 22], and Gupta <ref> [13, 14] </ref>. Li and Chen only align dimensions of given arrays to each other. Gupta ignores offset alignment, e.g., communication resulting from an access to not co-located A [i] and B [i+1].
Reference: [14] <author> M. Gupta. </author> <title> Automatic Data Partitioning on Distributed Memory Multicomputers. </title> <type> PhD thesis, </type> <institution> University of Illi-nois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Dynamic redistribution is considered only in special cases. Neither dynamic redistribution nor loops or branches are considered by Wholey [35], Li and Chen [21, 22], and Gupta <ref> [13, 14] </ref>. Li and Chen only align dimensions of given arrays to each other. Gupta ignores offset alignment, e.g., communication resulting from an access to not co-located A [i] and B [i+1].
Reference: [15] <author> S. Hiranandani, K. Kennedy, and C.-W. Tseng. </author> <title> Compiling Fortran D for MIMD distributed-memory machines. </title> <journal> CACM, </journal> <volume> 35(8) </volume> <pages> 66-80, </pages> <year> 1992. </year>
Reference-contexts: Some of those require that data is mapped onto the topology by hand [24, 32], others are user guided and offer sets of directives for the compiler, abstract topologies (so-called templates), or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions <ref> [3, 15, 16] </ref>. Much recent work focuses on static compile-time analysis to automatically find good data decompositions for vector and data-parallel operations. We describe this work in more detail in section 2. Placement optimization is often done in two steps.
Reference: [16] <author> High Performance Fortran: </author> <title> Language specification. </title> <type> Tech. Report, CRPC, </type> <institution> Rice University, </institution> <year> 1992. </year>
Reference-contexts: Some of those require that data is mapped onto the topology by hand [24, 32], others are user guided and offer sets of directives for the compiler, abstract topologies (so-called templates), or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions <ref> [3, 15, 16] </ref>. Much recent work focuses on static compile-time analysis to automatically find good data decompositions for vector and data-parallel operations. We describe this work in more detail in section 2. Placement optimization is often done in two steps. <p> These substitutes get distributed in the second phase with a fixed distribution scheme described elsewhere [25, 26]. The transformation is presented using Modula-2* [33] a high-level, problem-oriented, and machine-independent parallel language but is directly applicable to other languages, like HPF <ref> [16] </ref>. The remainder of the paper is organized as follows. After discussing related work in section 2, we briefly introduce our notation of a forall. Section 4 formulates the alignment optimization and discusses its properties. <p> Section 4 formulates the alignment optimization and discusses its properties. Finally, section 5 describes the setup and results of the experiments evaluating the effectiveness of our techniques. 2 Related Work The two phase approach to placement (alignment + distribution) is used by Fortran D [10], HPF <ref> [16] </ref>, CM-Fortran [31], and Vienna Fortran [3]. Although our work as well is based on the two phase approach, it is different, since it performs both phases automatically. fl On leave from Dept. of Informatics, University of Karlsruhe.
Reference: [17] <author> K. Knobe, J.D. Lukas, and W.J. Dally. </author> <title> Dynamic alignment on distributed memory systems. </title> <booktitle> In 3rd Workshop on Compilers for Parallel Computers, </booktitle> <pages> pp. 394-404, </pages> <address> Vi-enna, Austria, </address> <year> 1992. </year>
Reference-contexts: Furthermore, we feel that both process and data alignment must be considered. Simply deriving process placements from data placements is suboptimal as has been shown for the owner-computes rule in <ref> [5, 17] </ref>. There are already approaches to automatic alignment. In comparison to our work see [26, 28] for previous contributions these have some restrictions. Knobe et al. [17, 18] first introduced alignment analysis and the notion of preference graphs. Although they considered dimension, stride, and offset alignment, some problems remained. <p> Simply deriving process placements from data placements is suboptimal as has been shown for the owner-computes rule in [5, 17]. There are already approaches to automatic alignment. In comparison to our work see [26, 28] for previous contributions these have some restrictions. Knobe et al. <ref> [17, 18] </ref> first introduced alignment analysis and the notion of preference graphs. Although they considered dimension, stride, and offset alignment, some problems remained. Their greedy algorithm for solving alignment conflicts often returns suboptimal solutions since cost estimates are basic and decisions are based on local information.
Reference: [18] <author> K. Knobe, J.D. Lukas, and G.L. Steele. </author> <title> Data optimization: Allocation of arrays to reduce communication on SIMD machines. </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> 8(2) </volume> <pages> 102-118, </pages> <year> 1990. </year>
Reference-contexts: Simply deriving process placements from data placements is suboptimal as has been shown for the owner-computes rule in [5, 17]. There are already approaches to automatic alignment. In comparison to our work see [26, 28] for previous contributions these have some restrictions. Knobe et al. <ref> [17, 18] </ref> first introduced alignment analysis and the notion of preference graphs. Although they considered dimension, stride, and offset alignment, some problems remained. Their greedy algorithm for solving alignment conflicts often returns suboptimal solutions since cost estimates are basic and decisions are based on local information. <p> Nodes of P are array accesses and forall arrays (see 4.2.4) of a given program. The basic idea of a preference graph as introduced by Knobe <ref> [18] </ref> is that edges express alignment preferences. Co-location of arrays that are connected by these edges will result in locality of access. If edge constraints are not obeyed, arrays will be stored differently and communication is necessary at runtime.
Reference: [19] <author> Ulrich Kremer. </author> <title> NP-completeness of dynamic remapping. </title> <type> Tech. Report CRPC-TR93330-S, </type> <institution> Rice University, </institution> <year> 1993. </year>
Reference-contexts: Although our work as well is based on the two phase approach, it is different, since it performs both phases automatically. fl On leave from Dept. of Informatics, University of Karlsruhe. We consider it to be premature to have manual placement in languages; although the optimal placement is NP-complete <ref> [19, 21, 22, 23] </ref>, an automatic solution of the placement problem is necessary for three reasons: First, Wholey has shown in [35] that the best placement depends on three factors: the topology of the network, the number of available processors, and the size of the problem. <p> He does consider both alignment and distribution and hence uses a more accurate cost estimate than Li and Chen do. The approach by Ramanujam [29] delivers good data placement unless conflicting alignment preferences exist. However, such conflicts occur commonly. Kremer <ref> [2, 19, 20] </ref> takes a different approach. Instead of building placement optimization into a compiler, he develops tools to support the programmer in finding good placements. Although the approach is different, Kremer applies placement optimization techniques based on Li and Chen's Component-Affinity-Graph.
Reference: [20] <author> Ken Kennedy and Ulrich Kremer. </author> <title> Automatic data layout for high performance computing. </title> <type> Tech. Report CRPC-TR94498-S, </type> <institution> Rice University, </institution> <year> 1994. </year>
Reference-contexts: He does consider both alignment and distribution and hence uses a more accurate cost estimate than Li and Chen do. The approach by Ramanujam [29] delivers good data placement unless conflicting alignment preferences exist. However, such conflicts occur commonly. Kremer <ref> [2, 19, 20] </ref> takes a different approach. Instead of building placement optimization into a compiler, he develops tools to support the programmer in finding good placements. Although the approach is different, Kremer applies placement optimization techniques based on Li and Chen's Component-Affinity-Graph. <p> A simple basic solution is x i = 1 for all i 2 I. Results by Kremer <ref> [2, 20] </ref> also indicate the usefulness of integer programming for placement problems.
Reference: [21] <author> J. Li and M. Chen. </author> <title> Index domain alignment: Minimizing cost of cross-referencing between distributed arrays. </title> <booktitle> In 3rd Frontiers of Massively Parallel Computation, </booktitle> <pages> pp. 424-433, </pages> <year> 1990. </year>
Reference-contexts: Although our work as well is based on the two phase approach, it is different, since it performs both phases automatically. fl On leave from Dept. of Informatics, University of Karlsruhe. We consider it to be premature to have manual placement in languages; although the optimal placement is NP-complete <ref> [19, 21, 22, 23] </ref>, an automatic solution of the placement problem is necessary for three reasons: First, Wholey has shown in [35] that the best placement depends on three factors: the topology of the network, the number of available processors, and the size of the problem. <p> Their greedy algorithm for solving alignment conflicts often returns suboptimal solutions since cost estimates are basic and decisions are based on local information. Dynamic redistribution is considered only in special cases. Neither dynamic redistribution nor loops or branches are considered by Wholey [35], Li and Chen <ref> [21, 22] </ref>, and Gupta [13, 14]. Li and Chen only align dimensions of given arrays to each other. Gupta ignores offset alignment, e.g., communication resulting from an access to not co-located A [i] and B [i+1].
Reference: [22] <author> J. Li and M. Chen. </author> <title> The data alignment phase in compiling programs for distributed-memory machines. </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 213-221, </pages> <year> 1991. </year>
Reference-contexts: Although our work as well is based on the two phase approach, it is different, since it performs both phases automatically. fl On leave from Dept. of Informatics, University of Karlsruhe. We consider it to be premature to have manual placement in languages; although the optimal placement is NP-complete <ref> [19, 21, 22, 23] </ref>, an automatic solution of the placement problem is necessary for three reasons: First, Wholey has shown in [35] that the best placement depends on three factors: the topology of the network, the number of available processors, and the size of the problem. <p> Their greedy algorithm for solving alignment conflicts often returns suboptimal solutions since cost estimates are basic and decisions are based on local information. Dynamic redistribution is considered only in special cases. Neither dynamic redistribution nor loops or branches are considered by Wholey [35], Li and Chen <ref> [21, 22] </ref>, and Gupta [13, 14]. Li and Chen only align dimensions of given arrays to each other. Gupta ignores offset alignment, e.g., communication resulting from an access to not co-located A [i] and B [i+1].
Reference: [23] <author> M.E. Mace. </author> <title> Memory Storage Patterns in Parallel Processing. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1987. </year>
Reference-contexts: Although our work as well is based on the two phase approach, it is different, since it performs both phases automatically. fl On leave from Dept. of Informatics, University of Karlsruhe. We consider it to be premature to have manual placement in languages; although the optimal placement is NP-complete <ref> [19, 21, 22, 23] </ref>, an automatic solution of the placement problem is necessary for three reasons: First, Wholey has shown in [35] that the best placement depends on three factors: the topology of the network, the number of available processors, and the size of the problem.
Reference: [24] <author> MasPar Computer Corporation. </author> <title> MasPar Parallel Application Language Reference Manual, </title> <year> 1990. </year>
Reference-contexts: A trade-off between the conflicting goals must be found. Whereas the goals are agreed upon, different approaches to reach them have been developed. Some of those require that data is mapped onto the topology by hand <ref> [24, 32] </ref>, others are user guided and offer sets of directives for the compiler, abstract topologies (so-called templates), or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions [3, 15, 16].
Reference: [25] <author> M. Philippsen. </author> <title> Automatic data distribution for nearest neighbor networks. </title> <booktitle> In 4th Frontiers of Massively Parallel Computation, </booktitle> <pages> pp. 178-185, </pages> <year> 1992. </year>
Reference-contexts: This alignment is used in a source-to-source code transformation where user defined arrays are replaced by (possibly several) substitute arrays. These substitutes get distributed in the second phase with a fixed distribution scheme described elsewhere <ref> [25, 26] </ref>. The transformation is presented using Modula-2* [33] a high-level, problem-oriented, and machine-independent parallel language but is directly applicable to other languages, like HPF [16]. The remainder of the paper is organized as follows. After discussing related work in section 2, we briefly introduce our notation of a forall. <p> c nr cost of a parallel network read of data elements c f cost of an asynchronous forall with empty body c s cost of a synchronization barrier As suggested by performance results [27] this simplistic cost model is not too far off for the MasPar when our layout algorithm <ref> [25] </ref> is applied. Better cost estimates are known and could be used instead. In this representation, the problem is to find placements for all nodes minimizing the total cost of all edges that cannot be obeyed.
Reference: [26] <author> M. Philippsen. </author> <title> Optimierungstechniken zur Ubersetzung paralleler Programmiersprachen. </title> <type> PhD thesis, </type> <institution> University of Karlsruhe, Informatics, </institution> <year> 1993. </year>
Reference-contexts: This alignment is used in a source-to-source code transformation where user defined arrays are replaced by (possibly several) substitute arrays. These substitutes get distributed in the second phase with a fixed distribution scheme described elsewhere <ref> [25, 26] </ref>. The transformation is presented using Modula-2* [33] a high-level, problem-oriented, and machine-independent parallel language but is directly applicable to other languages, like HPF [16]. The remainder of the paper is organized as follows. After discussing related work in section 2, we briefly introduce our notation of a forall. <p> Furthermore, we feel that both process and data alignment must be considered. Simply deriving process placements from data placements is suboptimal as has been shown for the owner-computes rule in [5, 17]. There are already approaches to automatic alignment. In comparison to our work see <ref> [26, 28] </ref> for previous contributions these have some restrictions. Knobe et al. [17, 18] first introduced alignment analysis and the notion of preference graphs. Although they considered dimension, stride, and offset alignment, some problems remained.
Reference: [27] <author> M. Philippsen, E.A. Heinz, and P. Lukowicz. </author> <title> Compiling machine-independent parallel programs. </title> <journal> Sigplan Notices, </journal> <volume> 28(8) </volume> <pages> 99-108, </pages> <year> 1993. </year>
Reference-contexts: Our cost model differentiates: c nw cost of a parallel network write of data elements c nr cost of a parallel network read of data elements c f cost of an asynchronous forall with empty body c s cost of a synchronization barrier As suggested by performance results <ref> [27] </ref> this simplistic cost model is not too far off for the MasPar when our layout algorithm [25] is applied. Better cost estimates are known and could be used instead. <p> Otherwise, H [2*i,3] is selected which results in the transformation given in 4.1. Note that replication is not an issue here since the cost of node splitting always surpasses c n . 5 Performance Results At the moment, our benchmark suite consists of 17 problems collected from literature, see <ref> [27] </ref> for details. Here, we only consider those 15 problems whose Modula-2* solutions are not totally aligned right from the beginning. The programs were compiled for a 16K processor MasPar MP-1 (SIMD) by our Modula-2* compiler. <p> Thus, the diagrams show a ratio scale as the vertical axis. Good performance of the alignment optimization is indicated by curves above unity, e.g. a curve around 2 shows that the alignment optimization halved the execution time. 4 Comparisons with hand-coded programs are given in <ref> [27] </ref>. For problem sizes ranging from 2 3 to 2 23 we de-rived the relative performances from our execution time measurements.
Reference: [28] <author> M. Philippsen and M.U. Mock. </author> <title> Data and process alignment in Modula-2*. In Automatic Parallelization: </title> <booktitle> New Approaches, </booktitle> <pages> pp. 177-191. </pages> <publisher> Verlag Vieweg, </publisher> <year> 1994. </year>
Reference-contexts: Furthermore, we feel that both process and data alignment must be considered. Simply deriving process placements from data placements is suboptimal as has been shown for the owner-computes rule in [5, 17]. There are already approaches to automatic alignment. In comparison to our work see <ref> [26, 28] </ref> for previous contributions these have some restrictions. Knobe et al. [17, 18] first introduced alignment analysis and the notion of preference graphs. Although they considered dimension, stride, and offset alignment, some problems remained.
Reference: [29] <author> J. Ramanujam and P. Sadayappan. </author> <title> Access based data decomposition for distributed memory machines. </title> <booktitle> In 6th Distributed Memory Computing Conf., </booktitle> <pages> pp. 196-199, </pages> <address> Portland, OR, </address> <year> 1991. </year>
Reference-contexts: Gupta ignores offset alignment, e.g., communication resulting from an access to not co-located A [i] and B [i+1]. He does consider both alignment and distribution and hence uses a more accurate cost estimate than Li and Chen do. The approach by Ramanujam <ref> [29] </ref> delivers good data placement unless conflicting alignment preferences exist. However, such conflicts occur commonly. Kremer [2, 19, 20] takes a different approach. Instead of building placement optimization into a compiler, he develops tools to support the programmer in finding good placements.
Reference: [30] <author> T. She*er, R. Schreiber, J. Gilbert, and S. Chatterjee. </author> <title> Aligning parallel arrays to reduce communication. </title> <booktitle> In 5th Frontiers of Massively Parallel Computation, </booktitle> <pages> pp. 324-331, </pages> <year> 1995. </year>
Reference-contexts: He introduced the idea of using 0-1 integer programming for solving placement problems. Most of the groups have two basic approaches in common, both of which result in suboptimal solutions: process placement is derived from data placement and placement of temporaries is not considered. Gilbert, Schreiber, Chatterjee <ref> [4, 5, 12, 30] </ref> base their work on the Alignment-Distribution-Graph. In contrast to the approaches mentioned before, the authors tackle the problem of placing intermediate results. To our knowledge, their model for representing the cost of communication on the underlying topologies is the most advanced.
Reference: [31] <institution> Thinking Machines Corporation, Cambridge, Mas-sachusetts. </institution> <note> CM-Fortran Reference Manual, </note> <year> 1989. </year>
Reference-contexts: Section 4 formulates the alignment optimization and discusses its properties. Finally, section 5 describes the setup and results of the experiments evaluating the effectiveness of our techniques. 2 Related Work The two phase approach to placement (alignment + distribution) is used by Fortran D [10], HPF [16], CM-Fortran <ref> [31] </ref>, and Vienna Fortran [3]. Although our work as well is based on the two phase approach, it is different, since it performs both phases automatically. fl On leave from Dept. of Informatics, University of Karlsruhe.
Reference: [32] <institution> Thinking Machines Corporation, </institution> <address> Cambridge, </address> <month> Mas-sachusetts. </month> <title> C* Language Reference Manual, </title> <year> 1991. </year>
Reference-contexts: A trade-off between the conflicting goals must be found. Whereas the goals are agreed upon, different approaches to reach them have been developed. Some of those require that data is mapped onto the topology by hand <ref> [24, 32] </ref>, others are user guided and offer sets of directives for the compiler, abstract topologies (so-called templates), or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions [3, 15, 16].
Reference: [33] <author> W.F. Tichy and C.G. Herter. </author> <title> Modula-2*: An extension of Modula-2 for highly parallel, portable programs. </title> <type> Tech. Report 4/90, </type> <institution> University of Karlsruhe, </institution> <year> 1990. </year>
Reference-contexts: This alignment is used in a source-to-source code transformation where user defined arrays are replaced by (possibly several) substitute arrays. These substitutes get distributed in the second phase with a fixed distribution scheme described elsewhere [25, 26]. The transformation is presented using Modula-2* <ref> [33] </ref> a high-level, problem-oriented, and machine-independent parallel language but is directly applicable to other languages, like HPF [16]. The remainder of the paper is organized as follows. After discussing related work in section 2, we briefly introduce our notation of a forall. <p> The behavior of branches and loops inside synchronous foralls has MSIMD (multiple SIMD) semantics. This means that Modula-2* does not require any synchronization between different branches of synchronous case or if statements. The exact synchronous semantics of all Modula-2* statements, including nested foralls, are defined in <ref> [33] </ref>. 4 Alignment Optimization 4.1 Example VAR G: ARRAY [0..2*N-1] OF INTEGER; H: ARRAY [0..N-1],[0..N-1] OF INTEGER; G [.] := ...
Reference: [34] <author> S. Walukiewicz. </author> <title> Integer Programming. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: min i2I x i c i P Although the simplex algorithm cannot be guaranteed to terminate fast its worst case behavior is in O ( l with l being the length of the longest fundamental cycle it usually terminates in time proportional to the number of equations and variables l <ref> [34] </ref>. A simple basic solution is x i = 1 for all i 2 I. Results by Kremer [2, 20] also indicate the usefulness of integer programming for placement problems.
Reference: [35] <author> S. Wholey. </author> <title> Automatic Data Mapping for Distributed-Memory Parallel Computers. </title> <type> PhD thesis, CMU, </type> <year> 1991. </year>
Reference-contexts: We consider it to be premature to have manual placement in languages; although the optimal placement is NP-complete [19, 21, 22, 23], an automatic solution of the placement problem is necessary for three reasons: First, Wholey has shown in <ref> [35] </ref> that the best placement depends on three factors: the topology of the network, the number of available processors, and the size of the problem. <p> Their greedy algorithm for solving alignment conflicts often returns suboptimal solutions since cost estimates are basic and decisions are based on local information. Dynamic redistribution is considered only in special cases. Neither dynamic redistribution nor loops or branches are considered by Wholey <ref> [35] </ref>, Li and Chen [21, 22], and Gupta [13, 14]. Li and Chen only align dimensions of given arrays to each other. Gupta ignores offset alignment, e.g., communication resulting from an access to not co-located A [i] and B [i+1].
References-found: 35

