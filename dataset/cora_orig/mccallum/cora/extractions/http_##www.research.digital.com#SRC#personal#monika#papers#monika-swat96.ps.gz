URL: http://www.research.digital.com/SRC/personal/monika/papers/monika-swat96.ps.gz
Refering-URL: http://www.research.digital.com/SRC/personal/monika/papers.html
Root-URL: http://www.research.digital.com
Phone: 2  
Title: Faster Algorithms for the Nonemptiness of Streett Automata and for Communication Protocol Pruning  
Author: Monika Rauch Henzinger and Jan Arne Telle 
Note: O( l i m 1:5  
Address: Palo Alto, CA  Norway  
Affiliation: 1 Systems Research Center, Digital Equipment Corporation,  Department of Informatics, University of Bergen,  
Abstract: This paper shows how a general technique, called lock-step search, used in dynamic graph algorithms, can be used to improve the running time of two problems arising in program verification and communication protocol design. (1) We consider the nonemptiness problem for Streett automata: We are given a directed graph G = (V; E) with n = jV j and m = jEj, and a collection of pairs of subsets of vertices, called Streett pairs, hL i ; U i i; i = 1::k. The question is whether G has a cycle (not necessarily simple) which, for each 1 i k, if it contains a vertex from L i then it also contains a vertex of U i . Let b = P i=1::k jL i j + jU i j. The previously best algorithm takes time O((m+b) minfn; kg). We present an algorithm that takes time O(m minf m log n; k; ng + b minflog n; kg). (2) In communication protocol pruning we are given a directed graph G = (V; E) with l special vertices. The problem is to efficiently maintain the strongly-connected components of the special vertices on a restricted set of edge deletions. Let m i be the number of edges in the strongly connected component of the ith special vertex. The previously best algorithm repeatedly recomputes the strongly-connected components which leads to a running time of O( P i ). We present an algorithm with time p
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> E. A. Emerson and C. L. Lei. </author> <title> Modalities for model checking: Branching time strikes back. </title> <booktitle> Science of Computer Programming, 8 (1987), </booktitle> <pages> 275-306. </pages>
Reference-contexts: Let jV j = n; jEj = m and b = i=1::k jL i j + jU i j. The previously best algorithms for this problem take time O ((m + b) minfn; kg) <ref> [1, 3] </ref>. We present an O (m minf p m log n; k; ng + b minflog n; kg) algorithm for the problem. The improved running time is achieved through (1) lock-step search and (2) an efficient data structure for representing the Streett pairs hL i ; U i i. <p> A straightforward implementation, using the linear-time depth-first strongly-connected component algorithm SCC [6], gives a running time of O ((m + b) minfn; kg) <ref> [1, 3] </ref>, for jV j = n; jEj = m and b = P present an O (m minf p m log n; k; ng+b minflog n; kg) algorithm for the problem. 2.1 Data structure for Streett pairs The algorithm maintains a partition of the vertex set.
Reference: 2. <author> S. Even and Y. Shiloach, </author> <title> "An On-Line Edge-Deletion Problem", </title> <editor> J. </editor> <booktitle> ACM 28 (1981), </booktitle> <pages> 1-4. </pages>
Reference-contexts: We present an algorithm with time O ( p P i ). For constant l our algorithm takes time O ( P i ). Lock-Step Search Both improved algorithms use lock-step search. Lock-step search was introduced by Even and Shiloach <ref> [2] </ref> to maintain the connected components of an undirected graph under edge deletions.
Reference: 3. <author> R. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes: The Automata-Theoretic Approach. </title> <publisher> Princeton University Press, Princeton, </publisher> <year> 1994. </year>
Reference-contexts: Let jV j = n; jEj = m and b = i=1::k jL i j + jU i j. The previously best algorithms for this problem take time O ((m + b) minfn; kg) <ref> [1, 3] </ref>. We present an O (m minf p m log n; k; ng + b minflog n; kg) algorithm for the problem. The improved running time is achieved through (1) lock-step search and (2) an efficient data structure for representing the Streett pairs hL i ; U i i. <p> A straightforward implementation, using the linear-time depth-first strongly-connected component algorithm SCC [6], gives a running time of O ((m + b) minfn; kg) <ref> [1, 3] </ref>, for jV j = n; jEj = m and b = P present an O (m minf p m log n; k; ng+b minflog n; kg) algorithm for the problem. 2.1 Data structure for Streett pairs The algorithm maintains a partition of the vertex set.
Reference: 4. <author> D. Lee, A. N. Netravali, K. K. Sabnani. </author> <title> Protocol Pruning, </title> <booktitle> The Proceedings of IEEE, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: Protocol Pruning A communication system defines interactions between different components using exact rules, called protocols. Since protocol standards have become very complex, various approaches try to simplify protocols. A new technique by Lee, Ne-travali, and Sabnani <ref> [4] </ref> models a protocol as a collection of communicating finite state machines, and prunes the protocol without constructing the composite machine. The finite state machines are represented as a directed graph with l special vertices (start states), one per machine. Interactions between machines are modeled as dependencies among edges. <p> Finally, remove vertices in B from the (doubly linked) vertex list of S. The Remove (S; C (S); B) operation takes time O (bits (B) + jBj). 3 Protocol Pruning A new technique called protocol pruning is given in <ref> [4] </ref> to simplify communication protocols. <p> Let m i be the number of edges in the strongly-connected component of a i in the initial graph. The previously best implementation of protocol pruning, see <ref> [4] </ref>, adds all bad or useless edges to D. To determine the useless edges it recomputes the strongly connected component of a vertex a i every time the component lost an edge. Thus, this implementation takes time O ( P i ).
Reference: 5. <author> S. Safra. </author> <title> On the complexity of !-automata. </title> <booktitle> Proc. 29th IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <year> 1988, </year> <pages> 319-327. </pages>
Reference: 6. <author> R.E. Tarjan. </author> <title> Depth-first search and linear graph algorithms, </title> <journal> SIAM Journal on Computing, vol.1, no.2, </journal> <month> June </month> <year> 1972, </year> <pages> 146-160. </pages>
Reference-contexts: Notation For a graph G = (V; E) we denote the induced graph on S V by G [S]. We consider only directed graphs and may refer to a strongly connected component simply as a component. We denote the standard linear-time strongly-connected component algorithm <ref> [6] </ref> by SCC. We describe the algorithm for the Streett automata in Section 2. The protocol pruning algorithm is presented in Section 3. 2 Nonemptiness of Streett automata The best known algorithm for checking nonemptiness of Streett automata dynamically modifies the input graph by deletion of bad vertices. <p> The algorithm computes the strongly-connected components of the graph, halts if a good component is found or if only trivial components remain, otherwise deletes at least one bad vertex and repeats. A straightforward implementation, using the linear-time depth-first strongly-connected component algorithm SCC <ref> [6] </ref>, gives a running time of O ((m + b) minfn; kg) [1, 3], for jV j = n; jEj = m and b = P present an O (m minf p m log n; k; ng+b minflog n; kg) algorithm for the problem. 2.1 Data structure for Streett pairs The
Reference: 7. <author> M. Y. Vardi and P. L. Wolper. </author> <title> An Automata-Theoretic Approach to Automatic Program Verification. </title> <booktitle> Proc. 1st IEEE Symposium on Logic in Computer Science (LICS), </booktitle> <year> 1986, </year> <month> 322-331. </month> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The system A can be modeled as a Streett automaton. The negated specification :OE can be translated into an equivalent Buchi automaton, and therefore Streett automaton, B :OE . Then model checking reduces to checking the nonempti-ness of the product Streett automaton A fi B :OE <ref> [7] </ref>. Let jV j = n; jEj = m and b = i=1::k jL i j + jU i j. The previously best algorithms for this problem take time O ((m + b) minfn; kg) [1, 3].
References-found: 7

