URL: http://www.cs.sunysb.edu/~juliana/sched-strat-full.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fjuliana,tswift,warreng@cs.sunysb.edu  
Title: Beyond Depth-First: Improving Tabled Logic Programs through Alternative Scheduling Strategies  
Author: Juliana Freire Terrance Swift David S. Warren 
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Date: 1997  
Note: To appear in the Journal of Functional and Logic Programming,  
Abstract: Tabled evaluation ensures termination for programs with finite models by keeping track of which subgoals have been called. Given several variant subgoals in an evaluation, only the first one encountered will use program clause resolution; the rest will resolve the answers generated by the first subgoal. This use of answer resolution prevents the infinite looping which sometimes happens in SLD. However, answers that are produced in one path of the computation may be consumed, asynchronously, in another. Tabling systems face an important scheduling choice not present in traditional top-down evaluation: when to schedule answer resolution. This paper investigates alternate scheduling strategies for tabling in a WAM implementation, the SLG-WAM. The original SLG-WAM had a simple mechanism of scheduling answer resolution which was expensive in terms of trailing and choice point creation. We propose here a more sophisticated scheduling strategy, Batched Scheduling, which reduces the overheads of these operations and provides dramatic space reduction as well as speedups for many programs. We also propose a second strategy, Local Scheduling, which has applications to non-monotonic reasoning and when combined with answer subsumption can arbitrarily improve the performance of some programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci. </author> <title> WAM: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: frame is created and a new DFN is assigned to it. 2 Throughout this paper we will distinguish between the SCCs of an SLG system and their (safe) approximation by the completion stack, or ASCCs. 3 Scheduling Strategies 3.1 Single Stack Scheduling The scheduling of program clause resolution in Prolog <ref> [1, 23] </ref> is conceptually simple. The engine performs forward execution for as long as it possibly can.
Reference: [2] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(3) </volume> <pages> 255-299, </pages> <year> 1991. </year>
Reference-contexts: The efficient evaluation of queries to disk-resident data provides a clear instance of how a scheduling strategy can benefit an application. Efficiently accessing disk requires a strategy analogous to the semi-naive evaluation of a magic-transformed <ref> [2] </ref> program. A separate paper [10] showed how this could be done using a breadth-first set-at-a-time tabling strategy for the SLG-WAM [18] of XSB 1 . Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed good performance for disk accesses. <p> This latter step gives good performance for in-memory queries, but makes the Batched Scheduling algorithm differ from traditional deductive database-style evaluations such as the semi-naive evaluation of a Magic-transformed program <ref> [2] </ref>. After all answers are returned, the engine backtracks to the generator choice point of S.
Reference: [3] <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: This behavior might significantly improve the performance of program analyzers such as those based on Bruynooghe's abstract interpretation framework <ref> [3] </ref>. In this framework, after all the clauses for a predicate have been analyzed, the abstract substitution for the predicate is computed by taking the most general substitution among the clauses.
Reference: [4] <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <month> January </month> <year> 1996. </year> <title> 7 Versions 1.7 and higher of XSB can evaluate the well-founded semantics using wither Batched Scheduling or Local Scheduling. </title> <type> 27 </type>
Reference-contexts: In this section we review tabling using the notation of SLG resolution <ref> [4] </ref> reformulated and simplified for definite programs. As preliminary terminology, subgoals and goals are atoms. Predicates can be annotated as either tabled, or non-tabled in which case SLD resolution is used. Evaluations may be modeled by a sequence of systems or forests of SLG trees. <p> For each node with selected literal SL in the tree with root Subg: (a) SL is completed; or (b) SL 2 S and there are no applicable subgoal call, program clause resolution, or answer clause resolution operations for SL. 2 Correctness of SLG was shown in <ref> [4] </ref>, along with the correctness of a restriction of SLG for definite programs. To restate this result we briefly review some terminology. Let F be a system for an SLG evaluation of a program P and query Q. <p> It was shown in [17] that the SLG-WAM's completion stack maintains exact dependencies for local evaluations. Maintaining exact dependencies allows to engine to verify whether loops through negation exist, and to delay literals (to break these loops <ref> [4] </ref>) only when it is necessary. Even though negation handling and scheduling strategies are orthogonal issues, some strategies may be more efficient to evaluate normal programs. The following example shows how a local evaluation can benefit the evaluation of programs with negation.
Reference: [5] <author> M. Codish, B. Demoen, and K. Sagonas. </author> <title> XSB as the natural habitat for general purpose program analysis. </title> <type> Technical report, </type> <institution> KU Leuven, </institution> <year> 1996. </year>
Reference-contexts: This property has led to the use of tabled logic programming for new areas of logic programming. These include not only deductive database style applications, but other fixpoint-style problems, such as program analysis <ref> [7, 5] </ref>, compiler optimization [6] and model checking [15].
Reference: [6] <author> S. Dawson, C. R. Ramakrishnan, S. Skiena, and T. Swift. </author> <title> Principles and practice of unification factoring. </title> <journal> ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <volume> 18(5) </volume> <pages> 528-563, </pages> <year> 1996. </year>
Reference-contexts: This property has led to the use of tabled logic programming for new areas of logic programming. These include not only deductive database style applications, but other fixpoint-style problems, such as program analysis [7, 5], compiler optimization <ref> [6] </ref> and model checking [15]. Ensuring that these new applications run efficiently may require the use of different fl A preliminary version of this paper appeared in Proceedings of the Eigth International Symposium of Programming Languages, Implementations, Logics and Programs, Springer Verlag, 1996, pp. 243-258. scheduling strategies.
Reference: [7] <author> S. Dawson, C.R. Ramakrishnan, and D.S. Warren. </author> <title> Practical Program Analysis Using General Purpose Logic Programming Systems | A Case Study. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 117-125. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: This property has led to the use of tabled logic programming for new areas of logic programming. These include not only deductive database style applications, but other fixpoint-style problems, such as program analysis <ref> [7, 5] </ref>, compiler optimization [6] and model checking [15]. <p> When answer subsumption is seen as taking place over arbitrary lattices (rather than just the lattice of terms), it captures aspects of tabled evaluations for program analyses (see e.g. <ref> [7, 11] </ref>), for deductive database queries that use aggregates [21], and for answers involving constraints [20].
Reference: [8] <author> C. Fan and S. Dietrich. </author> <title> Extension Table Built-ins for Prolog. </title> <journal> Software-Practice and Experience, </journal> <volume> 22(7) </volume> <pages> 573-597, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: that a mixture of strategies may become useful: Batched Scheduling for existential queries, Local Scheduling for queries that involve answer subsumption, while either may evaluate the remaining class of queries. 6 Discussion and Future Directions Batched Scheduling bears some resemblance to two independently developed approaches: the ET fl algorithm from <ref> [8] </ref> and the AMAI from [11]. However, in [8], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers 6 . <p> Batched Scheduling for existential queries, Local Scheduling for queries that involve answer subsumption, while either may evaluate the remaining class of queries. 6 Discussion and Future Directions Batched Scheduling bears some resemblance to two independently developed approaches: the ET fl algorithm from <ref> [8] </ref> and the AMAI from [11]. However, in [8], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers 6 . The extra check for fairness may result in in inefficiencies for in-memory queries such as transitive closure over a chain.
Reference: [9] <author> J. Freire, R. Hu, T. Swift, and D.S. Warren. </author> <title> Exploiting Parallelism in Tabled Evaluations. </title> <booktitle> In 7th International Symposium, </booktitle> <volume> PLILP 95 - LNCS Vol. 982, </volume> <pages> pages 115-132. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Finally, the integration of the action of returning answers into the mechanism of the choice point stack makes Single Stack Scheduling not easily adaptable to a parallel engine <ref> [9] </ref>. 3.2 Batched Scheduling Batched Scheduling can be seen as an attempt to address the problems with Single Stack Scheduling mentioned above. Indeed, versions 1.5 and higher of XSB use this new strategy as a default.
Reference: [10] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The efficient evaluation of queries to disk-resident data provides a clear instance of how a scheduling strategy can benefit an application. Efficiently accessing disk requires a strategy analogous to the semi-naive evaluation of a magic-transformed [2] program. A separate paper <ref> [10] </ref> showed how this could be done using a breadth-first set-at-a-time tabling strategy for the SLG-WAM [18] of XSB 1 . Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed good performance for disk accesses. <p> The predominantly depth-first nature of program clause resolution in the WAM is maintained through all strategies discussed in this paper. However, <ref> [10] </ref> discusses the SLG-WAM implementation of a general breadth-first search that is also suitable for queries to disk-resident data. 24 (a) sp (words,X)(Dist) - 500 iterations (b) sp (there,white)(Dist) - 1000 iterations are nodes in the graph, and each subgoal is the leader of its own SCC.
Reference: [11] <author> G. Janssens, M. Bruynooghe, and V. Dumortier. </author> <title> A Blueprint for an Abstract Machine for Abstract Interpretation of (Constraint) Logic Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 336-350, </pages> <year> 1995. </year>
Reference-contexts: When answer subsumption is seen as taking place over arbitrary lattices (rather than just the lattice of terms), it captures aspects of tabled evaluations for program analyses (see e.g. <ref> [7, 11] </ref>), for deductive database queries that use aggregates [21], and for answers involving constraints [20]. <p> may become useful: Batched Scheduling for existential queries, Local Scheduling for queries that involve answer subsumption, while either may evaluate the remaining class of queries. 6 Discussion and Future Directions Batched Scheduling bears some resemblance to two independently developed approaches: the ET fl algorithm from [8] and the AMAI from <ref> [11] </ref>. However, in [8], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers 6 . The extra check for fairness may result in in inefficiencies for in-memory queries such as transitive closure over a chain. In [11], Janssens et al. <p> the AMAI from <ref> [11] </ref>. However, in [8], Fan and Dietrich do not consider strongly connected components in the fixpoint check, and their strategy is fair for answers 6 . The extra check for fairness may result in in inefficiencies for in-memory queries such as transitive closure over a chain. In [11], Janssens et al. describe an abstract machine specialized for abstract interpretation and use a similar scheduling strategy for their fixpoint iterations. Even though they take SCCs into account, these are detected statically.
Reference: [12] <author> D. E. Knuth. </author> <title> The Stanford GraphBase: A Platform for Combinatorial Computing. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: The speedup of XSB v. 1.5 over XSB v. 1.4 for these examples varies between 11 and 16%. 2 The nodes of these graphs are a subset of the 5757 more common 5-letter English words; there is an arc between two words if they differ in a single character <ref> [12] </ref>. 3 Note that for both Table 3 and 4 we considered only the trailings and untrailings that result from environment switches. 21 Table 3: SLG-WAM execution profile for left-recursive transitive closure on a linear chain with 1024 nodes Instructions/Operations XSB v. 1.4 XSB v. 1.5 Local RetryConsuming 0 1023 1023
Reference: [13] <author> G. Kostler, W. Kiessling, H. Thone, and U. Guntzer. </author> <title> Fixpoint iteration with subsumption in deductive databases. </title> <journal> Journal of Intelligent Information Systems (JIIS), </journal> <volume> 4(2) </volume> <pages> 123-148, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Resolving a call to a negative literal requires completely evaluating the subgoal contained in the literal, along with all other dependent subgoals. In a similar manner, waiting until part of an evaluation has been completely evaluated can also benefit programs that use answer subsumption (e.g. <ref> [13] </ref>), in which only the most general answers need to be maintained and returned to consuming subgoals.
Reference: [14] <author> E. Lusk, R. Butler, T. Disz, R. Olson, R. Ove rbeek, D.H.D. Warren, A. Calderwood, P. Sz-eredi, S. Haridi, P. Br and, M. Carlsson, A. Ciepielewski, and B. Hausman. </author> <title> The Aurora or-parallel Prolog system. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 819-830. </pages> <publisher> ICOT, </publisher> <year> 1988. </year>
Reference-contexts: The SLG-WAM achieves this by freezing the various WAM stacks at the point a new consuming node is created. In fact, the SLG-WAM keeps a linearized version of the search space in its stacks (similar to the cactus stacks of OR-parallel implementations such as Aurora <ref> [14] </ref>). Switching from one environment to another is performed by backtracking to a common ancestor, and then using a forward trail to reconstitute the environments of consuming nodes. The second change arises from the need to approximate the subgoal dependency graph, and thus to provide incremental completion.
Reference: [15] <author> Y. Ramakrishna, C.R. Ramakrishnan, I.V. Ramakrishnan, S. Smolka, T. Swift, and D. Warren. </author> <title> Efficient model checking using tabled resolution. </title> <booktitle> In Proceedings of Computer Aided Verification (CAV), </booktitle> <year> 1997. </year>
Reference-contexts: This property has led to the use of tabled logic programming for new areas of logic programming. These include not only deductive database style applications, but other fixpoint-style problems, such as program analysis [7, 5], compiler optimization [6] and model checking <ref> [15] </ref>. Ensuring that these new applications run efficiently may require the use of different fl A preliminary version of this paper appeared in Proceedings of the Eigth International Symposium of Programming Languages, Implementations, Logics and Programs, Springer Verlag, 1996, pp. 243-258. scheduling strategies.
Reference: [16] <author> I.V. Ramakrishnan, P. Rao, K. Sagonas, T. Swift, and D.S. Warren. </author> <title> Efficient table access mechanisms for logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 697-711, </pages> <year> 1995. </year>
Reference-contexts: If so the instruction fails, otherwise the answer is added to the table. The SLG-WAM represents tables using a trie-like structure <ref> [16] </ref>. Tries provide efficient check and insert of subgoals and answers, good indexing and space savings. More specifically, the SLG-WAM uses a subgoal trie to represent subgoals present in an evaluation.
Reference: [17] <author> T. Swift. </author> <title> Efficient Evaluation of Normal Logic Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, </institution> <year> 1994. </year>
Reference-contexts: The choice point stack thus serves as a scheduling stack for both returning answers and resolving program clauses. Accordingly, we call this scheduling strategy Single Stack Scheduling. The operational semantics of this scheduling strategy was described in detail in <ref> [17] </ref>, and forms the basis of the SLG-WAM as described in [18]. The following example demonstrates how this strategy works. <p> Note that the answer generated for subgoal p (2,Y) in node 10 is only returned to its calling environment (in node 5) after the tree for p (2,Y) is completely evaluated. It was shown in <ref> [17] </ref> that the SLG-WAM's completion stack maintains exact dependencies for local evaluations. Maintaining exact dependencies allows to engine to verify whether loops through negation exist, and to delay literals (to break these loops [4]) only when it is necessary.
Reference: [18] <author> T. Swift and D. S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 633-654, </pages> <year> 1994. </year>
Reference-contexts: Efficiently accessing disk requires a strategy analogous to the semi-naive evaluation of a magic-transformed [2] program. A separate paper [10] showed how this could be done using a breadth-first set-at-a-time tabling strategy for the SLG-WAM <ref> [18] </ref> of XSB 1 . Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed good performance for disk accesses. <p> is a variant of Subg. * S is an independent SCC and there are no applicable subgoal call, program clause resolution, or answer clause resolution operations for Subg. 2 2.3 The SLG-WAM: A Virtual Machine for Tabling The data structures and instruction set used by the SLG-WAM are described in <ref> [18] </ref>; here we briefly summarize aspects of the SLG-WAM needed to describe scheduling strategies. As mentioned in Section 2.1, there are several types of nodes: generator, consuming, interior and answer. <p> Accordingly, we call this scheduling strategy Single Stack Scheduling. The operational semantics of this scheduling strategy was described in detail in [17], and forms the basis of the SLG-WAM as described in <ref> [18] </ref>. The following example demonstrates how this strategy works. Example 3.1 The node numbers in Figure 1 represent the actions of Single Stack Scheduling on the program of Example 2.1, while Figure 3 represents the choice point stack at various phases of the program's evaluation.
Reference: [19] <author> T. Swift and D. S. Warren. </author> <title> Analysis of sequential SLG evaluation. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 219-238, </pages> <year> 1994. </year>
Reference-contexts: Unlike XSB's original tuple-at-a-time engine, the engine based on the breadth-first strategy showed good performance for disk accesses. Of course tabled evaluations must also be efficient for in-memory queries. <ref> [19] </ref> showed that, under several different criteria of measurement, tabled evaluation incurred a minimal execution time overhead compared to Prolog. <p> We also describe the in struction set that is used to implement this strategy. * We provide detailed results of experiments comparing these two strategies with XSB's original Single Stack Scheduling (described in <ref> [19] </ref>).
Reference: [20] <author> D. Toman. </author> <title> Top-down beats bottom-up for constraint extensions of datalog. </title> <booktitle> In Proceedings of the International Logic Programming Symposium (ILPS), </booktitle> <pages> pages 98-115, </pages> <year> 1995. </year>
Reference-contexts: When answer subsumption is seen as taking place over arbitrary lattices (rather than just the lattice of terms), it captures aspects of tabled evaluations for program analyses (see e.g. [7, 11]), for deductive database queries that use aggregates [21], and for answers involving constraints <ref> [20] </ref>. This paper motivates and describes the design and implementation of two new scheduling strategies for tabled logic programs: * We describe Batched Scheduling along with an instruction set which has been used to implement this strategy.
Reference: [21] <author> A. van Gelder. </author> <title> Foundations of Aggregation in Deductive Databases. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 13-34, </pages> <year> 1993. </year>
Reference-contexts: When answer subsumption is seen as taking place over arbitrary lattices (rather than just the lattice of terms), it captures aspects of tabled evaluations for program analyses (see e.g. [7, 11]), for deductive database queries that use aggregates <ref> [21] </ref>, and for answers involving constraints [20]. This paper motivates and describes the design and implementation of two new scheduling strategies for tabled logic programs: * We describe Batched Scheduling along with an instruction set which has been used to implement this strategy.
Reference: [22] <author> A. van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: Local Scheduling can perform asymptotically better than Batched Scheduling when combined with answer subsumption. This can be of use in many different areas such as aggregate selection and program analysis. In addition, Local Scheduling may have an important role to play in evaluating programs under the well-founded semantics <ref> [22] </ref>. Currently in the default scheduling strategy of XSB, the engine may have to construct part of the SDG to check for loops through negation. Since Local Scheduling maintains exact SCCs, it does not require this step as was demonstrated by Example 3.3.
Reference: [23] <author> D.H.D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical Report 309, </type> <institution> SRI, </institution> <year> 1983. </year>
Reference-contexts: frame is created and a new DFN is assigned to it. 2 Throughout this paper we will distinguish between the SCCs of an SLG system and their (safe) approximation by the completion stack, or ASCCs. 3 Scheduling Strategies 3.1 Single Stack Scheduling The scheduling of program clause resolution in Prolog <ref> [1, 23] </ref> is conceptually simple. The engine performs forward execution for as long as it possibly can.
Reference: [24] <author> U. Zukowski and B. Freitag. </author> <title> Adding flexibility to query evaluation for modularly stratified databases. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), </booktitle> <pages> pages 304-318, </pages> <year> 1996. </year> <month> 29 </month>
Reference-contexts: times for the Local engine vary from 0.06 to 15.7 seconds, whereas for XSB v. 1.5, they range between 0.09 and 4007.8 seconds. 6 That is, answers are not returned in the same fixpoint iteration they are created. 26 Local Scheduling resembles the strategy proposed by Zukowski and Freitag in <ref> [24] </ref> where program fragments are evaluated by different fixpoints. The scheduling strategies proposed in this paper can improve the performance | memory usage and execution time of tabled evaluations. Due to its performance, Batched Scheduling is now the default scheduling strategy for XSB.
References-found: 24

