URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1998/GIT-CC-98-03.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.98.html
Root-URL: 
Title: Interactors: Capturing Tradeoffs in Bandwidth versus CPU Usage for Quality of Service Constrained Objects  
Author: Richard West and Karsten Schwan 
Note: This work is supported in part by DARPA contract #B09332478, and by the British Engineering and Physical Sciences Research Council with grant #92600699.  
Address: Atlanta, GA 30332  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: Complex distributed applications, including virtual environments, and real-time multimedia require performance guarantees in the end-to-end transfer of information across a network. To make such guarantees requires the management of processing, memory, and network resources. This paper describes the Dionisys end-system quality of service (QoS) approach to specifying, translating, and enforcing end-to-end, object-level QoS constraints. Dionisys differs from previous work on QoS architectures by supporting QoS constraints on distributed shared objects, as well as multimedia streams. Consequently, we introduce `interactors', which capture the QoS constraints and resource requirements at each stage in the generation, processing, and transfer of information between multiple cooperating objects. Using interactors, Dionisys is able to coordinate both thread and packet-level scheduling, so that information is processed and transmitted at matching rates. However, there are tradeoffs in the use of CPU cycles for scheduling and the need to meet QoS constraints on the information transferred between interacting objects. We show, empirically, the packet scheduling frequency to minimize CPU overheads while maximizing bandwidth usage. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Greenberg and D. Marwood, </author> <title> "Real-time groupware as a distributed system: Concurrency control and its effect on the interface," </title> <booktitle> in Proceedings of the ACM Conference on Cooperative Support for Cooperative Work, </booktitle> <publisher> ACM press, </publisher> <pages> pp. 207-217, </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Researchers are currently investigating system support for complex distributed applications, including groupware applications <ref> [1] </ref>, virtual environments (e.g. DIVE [2]), and distributed interactive simulations (DIS) [3].
Reference: [2] <author> C. Carlsson and O. Hagsand, </author> <title> "Dive-a platform for multi-user virtual environments," </title> <journal> Com--puters and Graphics, </journal> <volume> vol. 17, </volume> <pages> pp. 663-669, </pages> <month> November-December </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Researchers are currently investigating system support for complex distributed applications, including groupware applications [1], virtual environments (e.g. DIVE <ref> [2] </ref>), and distributed interactive simulations (DIS) [3]. A DIS, for example, provides a group of users with the illusion of a single, coherent virtual world, although its computations may actually execute on distributed, heterogeneous hosts, and its data sources may be derived from physically separated real-time sensors.
Reference: [3] <author> S. Singhal, </author> <title> Effective Remote Modeling in Large-Scale Distributed Simulation and Visualization Environments. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Researchers are currently investigating system support for complex distributed applications, including groupware applications [1], virtual environments (e.g. DIVE [2]), and distributed interactive simulations (DIS) <ref> [3] </ref>. A DIS, for example, provides a group of users with the illusion of a single, coherent virtual world, although its computations may actually execute on distributed, heterogeneous hosts, and its data sources may be derived from physically separated real-time sensors.
Reference: [4] <author> R. Kravets, K. Calvert, P. Krishnan, and K. Schwan, </author> <title> "Adaptive variation of reliability," </title> <booktitle> in HPN-97, IEEE, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: Moreover, sensor visibility changes over time, depending on pilot viewpoint, for example. It has become apparent, not only from DIS applications but also our own work on shared virtual worlds <ref> [4] </ref>, distributed games [5], and battlefield simulations, that most such applications exhibit dynamic QoS constraints. These dynamic QoS constraints must be utilized to attain necessary levels of end-to-end performance. <p> These dynamic QoS constraints must be utilized to attain necessary levels of end-to-end performance. For instance, it is neither reasonable nor viable to display continuously all possible sensor readings to all participants in a virtual world simulating rooms in a Navy vessel described in <ref> [4] </ref>. In addition, given the complexity of future battlefield simulations in which terrain, participating actors (like tanks), and sensors must be simulated realistically, it will not remain viable to replicate completely all objects across all participating machines.
Reference: [5] <author> R. West, K. Schwan, I. Tacic, and M. Ahamad, </author> <title> "Exploiting temporal and spatial constraints on distributed shared objects," </title> <booktitle> in Proc. 17th IEEE ICDCS, IEEE, </booktitle> <year> 1997. </year>
Reference-contexts: Moreover, sensor visibility changes over time, depending on pilot viewpoint, for example. It has become apparent, not only from DIS applications but also our own work on shared virtual worlds [4], distributed games <ref> [5] </ref>, and battlefield simulations, that most such applications exhibit dynamic QoS constraints. These dynamic QoS constraints must be utilized to attain necessary levels of end-to-end performance. <p> between information consistency and QoS constraints: (1) a suitable consistency protocol must be used to maintain the correct level of consistency between replicated state information, and (2) timing or quality-of-service (QoS) constraints must be placed on the update and access to distributed shared objects whose state has been partially replicated <ref> [5] </ref>. This linkage has been recognized by other researchers, as well, including work by Yavatkar et al [6]. The interactor abstraction offered by Dionisys captures the end-to-end QoS constraints experienced in the highly dynamic distributed applications targeted by our work. <p> Strict coherence of objects limits scalability in terms of the total number of objects that can be replicated, since more object exchanges are required as the number of replicas increases. The actual format of these constraints could be in terms of some semantic function <ref> [5] </ref>, which specifies the conditions about when and with which objects updates should occur. The specification of these semantic-based consistency requirements can only be made in the context of the application. <p> These two structures enable the consistency management system to control when and with whom updates occur, based on semantic information provided by the application in the form of a semantic function. This is exactly the approach taken in the S-DSO system <ref> [5] </ref>. The buffered update information destined for each process depends on the fidelity constraint f applicable at the time the exchange is due to take place.
Reference: [6] <author> R. Yavatkar, "MCP: </author> <title> A protocol for coordination and temporal synchronization in multimedia collaborative applications," </title> <booktitle> in Proc. 12th IEEE ICDCS, </booktitle> <pages> pp. 606-613, </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: This linkage has been recognized by other researchers, as well, including work by Yavatkar et al <ref> [6] </ref>. The interactor abstraction offered by Dionisys captures the end-to-end QoS constraints experienced in the highly dynamic distributed applications targeted by our work. An interactor is an association between cooperating shared objects spanning a network and all the resources, both communication and computation bound, that support object exchanges.
Reference: [7] <author> D. Ferrari, A. Banerjea, and H. Zhang, </author> <title> "Network support for multimedia a discussion of the tenet approach," </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> vol. 26, </volume> <pages> pp. 1267-1280, </pages> <year> 1993. </year>
Reference-contexts: This is an example of one of the resource tradeoffs experienced in complex applications, where multiple resource types must be allocated and managed to maximize the service level granted to all activities. Traditional QoS research has focussed almost exclusively on the network level (e.g., the Tenet work <ref> [7] </ref>), without also providing support for end-to-end constraints. Recent work in end-to-end QoS support, such as QoS-A (Campbell et al [8]), and the End System QoS Framework at Washington University [9] supports application-specific QoS constraints, and the mapping of these constraints to the network level.
Reference: [8] <author> A. Campbell, </author> <title> "A quality of service architecture," </title> <journal> in ACM SIGCOMM Computer Communication Review, ACM, </journal> <month> April </month> <year> 1994. </year>
Reference-contexts: Traditional QoS research has focussed almost exclusively on the network level (e.g., the Tenet work [7]), without also providing support for end-to-end constraints. Recent work in end-to-end QoS support, such as QoS-A (Campbell et al <ref> [8] </ref>), and the End System QoS Framework at Washington University [9] supports application-specific QoS constraints, and the mapping of these constraints to the network level. However, these architectures are tailored to multimedia video and audio applications.
Reference: [9] <author> G. Gopalakrishna and G. Parulkar, </author> <title> "Efficient quality of service in multimedia computer operating systems," </title> <type> Tech. Rep. </type> <institution> WUCS-TM-94-04, Department of Computer Science, Washington University, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: Traditional QoS research has focussed almost exclusively on the network level (e.g., the Tenet work [7]), without also providing support for end-to-end constraints. Recent work in end-to-end QoS support, such as QoS-A (Campbell et al [8]), and the End System QoS Framework at Washington University <ref> [9] </ref> supports application-specific QoS constraints, and the mapping of these constraints to the network level. However, these architectures are tailored to multimedia video and audio applications.
Reference: [10] <author> D. C. Schmidt, A. Gokhale, T. Harrison, and G. Parulkar, </author> <title> "A high-performance endsystem architecture for real-time corba," </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: Applications such as those described earlier are not fully addressed by current research on real-time object-based systems, which have focussed on 1) how to associate real-time constraints with a single object or a single invocation <ref> [10, 11] </ref>, 2) how to translate or support some object-level constraint on a single invocation to some thread/communication constraints, and then use conventional scheduling techniques to deal with real-time constraints [11, 12], or 3) how to model/control some entire object-based real-time system `from the outside'[12, 13].
Reference: [11] <author> A. Gheith and K. Schwan, </author> <title> "Chaos-arc kernel support for multi-weight objects, invocations, and atomicity in real-time applications," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 11, </volume> <pages> pp. 33-72, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Applications such as those described earlier are not fully addressed by current research on real-time object-based systems, which have focussed on 1) how to associate real-time constraints with a single object or a single invocation <ref> [10, 11] </ref>, 2) how to translate or support some object-level constraint on a single invocation to some thread/communication constraints, and then use conventional scheduling techniques to deal with real-time constraints [11, 12], or 3) how to model/control some entire object-based real-time system `from the outside'[12, 13]. <p> object-based systems, which have focussed on 1) how to associate real-time constraints with a single object or a single invocation [10, 11], 2) how to translate or support some object-level constraint on a single invocation to some thread/communication constraints, and then use conventional scheduling techniques to deal with real-time constraints <ref> [11, 12] </ref>, or 3) how to model/control some entire object-based real-time system `from the outside'[12, 13]. In contrast, Dionisys is a runtime infrastructure that provides the necessary abstractions to maintain QoS constraints in synchrony with each application's execution.
Reference: [12] <author> D. I. Rosu, K. Schwan, S. Yalamanchili, and R. Jha, </author> <title> "On adaptive resource allocation for complex real-time applications," </title> <booktitle> in 18th IEEE Real-Time Systems Symposium, </booktitle> <address> San Fran-cisco, CA, </address> <publisher> IEEE, </publisher> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: object-based systems, which have focussed on 1) how to associate real-time constraints with a single object or a single invocation [10, 11], 2) how to translate or support some object-level constraint on a single invocation to some thread/communication constraints, and then use conventional scheduling techniques to deal with real-time constraints <ref> [11, 12] </ref>, or 3) how to model/control some entire object-based real-time system `from the outside'[12, 13]. In contrast, Dionisys is a runtime infrastructure that provides the necessary abstractions to maintain QoS constraints in synchrony with each application's execution.
Reference: [13] <author> P. Gopinath, T. Bihari, and K. Schwan, </author> <title> "Object-oriented design of real-time software," </title> <booktitle> in 10th International Real-time Systems Symposium, </booktitle> <address> Los Angeles, </address> <pages> pp. 194-201, </pages> <publisher> IEEE, </publisher> <month> Dec. </month> <year> 1989. </year>
Reference: [14] <author> C. Aurrecoechea, A. Campbell, and L. Hauw, </author> <title> "A survey of qos architectures," </title> <journal> Multimedia Systems Journal, Special Issue on QoS Architecture, </journal> <year> 1997. </year>
Reference-contexts: Similarly, the network layer has to perform fragmentation and reassembly of messages, as well as various traffic management functions. Aurrecoechea et al <ref> [14] </ref>, give an excellent summary of the key traffic management mechanisms. Some of these will be described later, in the context of Dionisys. At each level in the system, QoS constraints on the information exchanged between objects are translated to a form suitable for the next layer.
Reference: [15] <author> D. Ferrari, </author> <title> "Client requirements for real-time communication services," </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 28, </volume> <pages> pp. 76-90, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: We now address the issue of translating constraints from the consistency management level to the network level. Translating delay requirements: Ferrari <ref> [15] </ref> states that the method for translating delay bounds has to deal with the effects of delays in the individual layers, and the effects of message fragmentation on the requirements.
Reference: [16] <author> A. Montz, D. Mosberger, S. O'Malley, L. Peterson, T. Proebsting, and J. Hartman, </author> <title> "Scout: A communications-oriented operating system," </title> <type> Tech. Rep. </type> <institution> TR-94-20, The University of Ari-zona, Department of Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference: [17] <author> D. Clark, </author> <title> "The structuring of systems using upcalls," </title> <booktitle> in Proceeedings of Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 171-180, </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1995. </year>
Reference: [18] <author> N. Hutchinson and L. Peterson, </author> <title> "The x-kernel: An architecture for implementing network protocols," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <pages> pp. 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: There are two specific operations the CPU resource manager must perform in controlling the usage of CPU resources: * Binding protocol processing modules to threads: Ivan-Rosu and Schwan [19], and Hutchinson and Peterson <ref> [18] </ref> showed that by `shepherding' modules together to run in a single thread, message latency is reduced, since a message that has been processed by one module can be immediately processed in the next module, executing within the same thread. * Scheduling threads on available CPUs: At every level in the
Reference: [19] <author> D. Ivan-Rosu and K. Schwan, </author> <title> "Improving protocol performance by dynamic control of communication resources," </title> <type> Tech. Rep. </type> <institution> GIT-CC-96-04, Georgia Institute of Technology, College of Computing, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: There are two specific operations the CPU resource manager must perform in controlling the usage of CPU resources: * Binding protocol processing modules to threads: Ivan-Rosu and Schwan <ref> [19] </ref>, and Hutchinson and Peterson [18] showed that by `shepherding' modules together to run in a single thread, message latency is reduced, since a message that has been processed by one module can be immediately processed in the next module, executing within the same thread. * Scheduling threads on available CPUs:
Reference: [20] <author> C. Mercer, S. Savage, and H. Tokuda, </author> <title> "Processor capacity reservation for multimedia operating systems," </title> <booktitle> in IEEE International Conference on Multimedia Computing and Systems, IEEE, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: The resource manager can exist on uni- and multiprocessor machines and must make the best use of available resources at all times. A number of well-known scheduling policies can be used for thread scheduling. Mercer <ref> [20] </ref> has investigated the use of both earliest-deadline first and rate-monotonic scheduling in his work 3 In Dionisys, interactors are specified by a processing signature at the object-level, which describes all the modules in that interactor.
References-found: 20

