URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/92/tr1085a.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/reports/92/
Root-URL: http://www.cs.wisc.edu
Abstract-found: 0
Intro-found: 1
Reference: [Bern83] <author> Bernstein, P. and N. Goodman, </author> <title> "Multiversion Concurrency Control: Theory and Algorithms," </title> <journal> ACM Trans. on Database Sys., </journal> <volume> 8(4), </volume> <month> December </month> <year> 1983. </year> <month> - 31 </month> - 
Reference-contexts: A query is said to see strong consistency [Garc82] if it is seri alizable with respect to all transactions. 2 This form of consistency is characterized by an acyclic serialization graph, and is provided by algorithms that guarantee multiversion serializability <ref> [Bern83, Papa84, Hadz85] </ref>. Since the previous res triction on the commit ordering of update transactions is relaxed here, strong consistency may produce apparent anomalies in query results if users are somehow cognizant of the commit order of update transactions.
Reference: [Bern87] <author> Bernstein, P., V. Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems," </title> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1987. </year>
Reference: [Bobe92] <author> Bober, P. and M. Carey, </author> <title> "On Mixing Queries and Transactions via Multiversion Locking," </title> <booktitle> Proc. of the 1992 IEEE Data Engineering Conf., </booktitle> <year> 1992. </year>
Reference-contexts: The drawback of this approach is that is possible for a long-running query to hold up the garbage-collection of a potentially large number of prior versions, leading to a high storage overhead <ref> [Bobe92] </ref>. As an alternative to the sequential scheme, a sifting garbage collection scheme can be used in conjunction with a heap-based organization for storing prior versions. In this approach, when a update transaction completes, it assigns each prior version that it replaced to the youngest query that requires the version. <p> Both locking and versioning are both supported at the page level. We chose page-level versioning to simplify the implementation of the simulator and to reduce the length of simulation runs. The basic MV2PL and MVQL algorithms are compatible with record-level versioning; schemes for record-level ver-sioning are discussed in <ref> [Bobe92, Moha92] </ref>. The version manager divides the database into two segments: the main segment, containing the current versions of pages, and the version pool, containing prior page versions.
Reference: [Chan82] <author> Chan, A., S. Fox, W. Lin, A. Nori, and Ries, D., </author> <title> "The Implementation of an Integrated Concurrency Control and Recovery Scheme," </title> <booktitle> Proc. 1982 ACM SIGMOD Conf., </booktitle> <year> 1982. </year>
Reference-contexts: This is because 2PL causes queries to lock large regions of data for long periods of time, thus causing update transactions to suffer long delays. A solution that avoids the data contention problem of 2PL is to extend it with versioning. Under multiversion two-phase locking (MV2PL) <ref> [DuBo82, Chan82, Chan85] </ref>, prior versions of data are retained to allow queries to run against past transaction-consistent database states. The presence of versions allows queries to serialize before all concurrent update transactions, and thus queries and update transactions do not conflict. <p> for any of the following reasons: (1) If the current versions of objects are clustered together, accessing an older version of an object will degrade sequential scan performance that would otherwise be available using prefetch. (2) If the versions of an object are chained in reverse chronological order (as in <ref> [Chan82] </ref>), accessing an older ver sion will require additional I/O operations. (3) Using older versions to construct a query's view will require that additional prior versions be retained for the query (thus delaying their garbage collection and increasing storage cost). <p> Both MV2PL and MVQL use two-phase locking for serializing update transactions. MV2PL provides only strict consistency for queries, while MVQL relaxes this by permitting a choice between update, weak, strong, and strict consistency. In the last case, MVQL is equivalent to MV2PL. 3.1. Multiversion Two-Phase Locking (MV2PL) In MV2PL <ref> [DuBo82, Chan82] </ref>, a transaction is classified at startup time as being either a query transaction (read-only) or an update transaction. When an update transaction reads or writes an object (e.g., a page or a tuple), it locks the object, as in traditional 2PL, and then accesses the most recent version. <p> A version is unnecessary if, for every active query, there is a more recent committed version of the object that was created by an update transaction that is not in the query's AFTER set. The first alternative is a sequential garbage collection scheme, as proposed in <ref> [Chan82] </ref>, where prior versions are stored in a sequential log-like version pool; before an object is updated, it is appended to the version pool. In this approach, there are three pointers that mark regions in the version pool. <p> The version manager divides the database into two segments: the main segment, containing the current versions of pages, and the version pool, containing prior page versions. This organization is similar to the one described in <ref> [Chan82] </ref>, except that we arrange the version pool as a heap of disk tracks rather than as a circular (log-like) buffer. <p> The memory-resident index is another departure from the scheme in <ref> [Chan82] </ref>, where prior versions of a page were located by chaining back from the current version. We chose the directory approach in order to present the performance differences of the algorithms relatively conservatively.
Reference: [Chan85] <author> Chan, A., and R. Gray, </author> <title> "Implementing Distributed Read-Only Transactions," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> SE-11(2), </volume> <month> Feb </month> <year> 1985. </year>
Reference-contexts: This is because 2PL causes queries to lock large regions of data for long periods of time, thus causing update transactions to suffer long delays. A solution that avoids the data contention problem of 2PL is to extend it with versioning. Under multiversion two-phase locking (MV2PL) <ref> [DuBo82, Chan82, Chan85] </ref>, prior versions of data are retained to allow queries to run against past transaction-consistent database states. The presence of versions allows queries to serialize before all concurrent update transactions, and thus queries and update transactions do not conflict. <p> To the best of our knowledge, almost all previously proposed multiversion concurrency control algorithms provide only strict consistency for queries. The only exception that we are aware of is distributed MV2PL, where weak con sistency arises among queries at different sites due to inconsistent global state information <ref> [Chan85] </ref>. In contrast, MVQL deliberately introduces weaker forms of consistency among queries by allowing them to read newer versions of data for performance reasons.
Reference: [DeWi90] <author> DeWitt, D., et al., </author> <title> "The Gamma Database Machine Project," </title> <journal> IEEE Trans. on Knowledge and Data Eng., </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: The database is composed of 4 files, each containing 25,000 Wisconsin benchmark-sized records. Each record contains 208 bytes of data and 19 bytes of overhead, for a total of 227 bytes (as is the case in the Gamma system <ref> [DeWi90] </ref>). With this record size, 36 records fit on a page. Each file contains both a clustered and an unclustered B+ tree index, each with a node fanout of 450.
Reference: [DeWi92] <author> DeWitt D., and J. Gray, </author> <title> "Parallel Database Systems: The Future of High Performance Database Processing," </title> <journal> Communications of the ACM, </journal> <volume> 35(6), </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: Distributed MVQL In recent years, shared-nothing parallel database systems have begun to replace centralized mainframe database systems <ref> [DeWi92] </ref>. In this section we discuss a distributed version of MVQL that is applicable to parallel DBMSs. We do not consider at this time more general distributed database systems containing replicated data.
Reference: [DuBo82] <author> DuBourdieu, D., </author> <title> "Implementation of Distributed Transactions," </title> <booktitle> Proc. 6th Berkeley Workshop on Distributed Data Management and Computer Networks, </booktitle> <year> 1982. </year>
Reference-contexts: This is because 2PL causes queries to lock large regions of data for long periods of time, thus causing update transactions to suffer long delays. A solution that avoids the data contention problem of 2PL is to extend it with versioning. Under multiversion two-phase locking (MV2PL) <ref> [DuBo82, Chan82, Chan85] </ref>, prior versions of data are retained to allow queries to run against past transaction-consistent database states. The presence of versions allows queries to serialize before all concurrent update transactions, and thus queries and update transactions do not conflict. <p> An abridged version of this paper will appear in the proceedings of the Eighteenth International Conference on Very Large Data Bases, Van couver, Canada, August 1992. - 1 - MV2PL as an option include Prime's DBMS <ref> [DuBo82] </ref>, DEC's Rdb/VMS product [Ragh91], Interbase, and Object Design. A drawback to MV2PL is the storage cost that it imposes, as well as the additional costs for accessing prior versions and for copying objects before they are updated (if in-place updates are employed). <p> Both MV2PL and MVQL use two-phase locking for serializing update transactions. MV2PL provides only strict consistency for queries, while MVQL relaxes this by permitting a choice between update, weak, strong, and strict consistency. In the last case, MVQL is equivalent to MV2PL. 3.1. Multiversion Two-Phase Locking (MV2PL) In MV2PL <ref> [DuBo82, Chan82] </ref>, a transaction is classified at startup time as being either a query transaction (read-only) or an update transaction. When an update transaction reads or writes an object (e.g., a page or a tuple), it locks the object, as in traditional 2PL, and then accesses the most recent version.
Reference: [Eswa76] <author> Eswaran, K., J. Gray, R. Lorie, I. Traiger, </author> <title> "The Notions of Consistency and Predicate Locks in a Database System," </title> <journal> CACM 19(11), </journal> <year> 1976. </year>
Reference-contexts: Concurrency control techniques for on-line query processing, however, are still lacking. The concurrency control algorithm found in most commercial database systems, two-phase locking (2PL) <ref> [Eswa76] </ref>, does not efficiently support on-line query processing. This is because 2PL causes queries to lock large regions of data for long periods of time, thus causing update transactions to suffer long delays. A solution that avoids the data contention problem of 2PL is to extend it with versioning.
Reference: [Fuji90] <institution> M2266S/H Intelligent Disk Drive Technical Handbook, </institution> <note> publication FS810125-01 rev. </note> <editor> B, </editor> <publisher> Fujitsu America, Inc., </publisher> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: This model was patterned after the Fujitsu M2266 disk drive <ref> [Fuji90] </ref>, which is as an example of a current generation disk drive. With this configuration, typical disk access times were on the order of 15 milliseconds and the system was I/O-bound for all of our experiments. The database is composed of 4 files, each containing 25,000 Wisconsin benchmark-sized records.
Reference: [Garc82] <author> Garcia-Molina, H. and G. Wiederhold, </author> <title> "Read-Only Transactions in a Distributed Database," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2), </volume> <month> June </month> <year> 1982. </year>
Reference-contexts: FORMS OF QUERY CONSISTENCY In the introduction, we argued that performance advantages may be gained by relaxing the level of consistency provided to queries. In this section, we review four forms of consistency which all guarantee that queries see a transaction-consistent database: strict consistency, strong consistency <ref> [Garc82] </ref>, weak consistency [Garc82], and update consistency. In the next section, we review the MV2PL algorithm, which provides only strict consistency, and we then present the MVQL algorithm as a generalization of MV2PL that can provide any of these levels of consistency. <p> FORMS OF QUERY CONSISTENCY In the introduction, we argued that performance advantages may be gained by relaxing the level of consistency provided to queries. In this section, we review four forms of consistency which all guarantee that queries see a transaction-consistent database: strict consistency, strong consistency <ref> [Garc82] </ref>, weak consistency [Garc82], and update consistency. In the next section, we review the MV2PL algorithm, which provides only strict consistency, and we then present the MVQL algorithm as a generalization of MV2PL that can provide any of these levels of consistency. <p> The next form of consistency relaxes strict consistency by eliminating the requirement that the serial order of update transactions be consistent with their commit order. A query is said to see strong consistency <ref> [Garc82] </ref> if it is seri alizable with respect to all transactions. 2 This form of consistency is characterized by an acyclic serialization graph, and is provided by algorithms that guarantee multiversion serializability [Bern83, Papa84, Hadz85]. <p> R (Z 0 ) R (Y 0 ) iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Q 3 R (Z 0 ) R (W 0 ) iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 This definition of strong consistency is slightly different than the one presented in <ref> [Garc82] </ref>. In their definition, a strong consistency query is required to serialize only with the update transactions and other strong consistency queries. <p> A query is said to see weak consistency if it is serializable with respect to update transactions, but possibly not with respect to other queries. This form of consistency, which was first introduced in <ref> [Garc82] </ref> for use in replicated databases, still ensures that queries see transaction-consistent data. However, it permits cycles in the serial ization graph that contain multiple queries plus one or more update transactions (multiple-query cycles).
Reference: [Gray76] <author> Gray, J., R. Lorie, F. Putzolu, and I. Traiger, </author> <title> "Granularity of Locks and Degrees of Consistency in a Shared Data Base," in Modeling in Data Base Systems, </title> <publisher> North Holland Publishing (1976). </publisher>
Reference-contexts: Recall that a transaction-consistent database is assumed to satisfy a set of static integrity constraints, and each update transaction is assumed to take the database from one transaction-consistent state to another (possibly through one or more inconsistent intermediate states) <ref> [Gray76] </ref>. In order to observe a transaction-consistent database, a query must not see the partial effects of any update transactions; for each update transaction, it must see either all of its effects or none of its effects.
Reference: [Gray79] <author> Gray, J., </author> <title> "Notes on Database Operating Systems," in Operating Systems: An Advanced Course, </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: For example, under cursor-stability locking, queries may release locks before acquiring new ones (violating the two-phase rule), and under GO processing [Pira90], queries do not obtain any locks at all (except latches to guarantee page consistency). In the terminology of <ref> [Gray79] </ref>, the former provides degree 2 consistency, and the latter, degree 1. Another example is the class of epsilon-serializability algorithms, which accept inconsistent schedules as long as they are within some number of inversions from a serializable schedule [Wu92]. <p> We choose a more efficient solution, however, which is to piggyback the AFTER set insertions of a given update transaction on the messages exchanged during the transaction's commit processing. We assume that the two-phase commit (2PC) protocol <ref> [Gray79] </ref> (or some other suitable commit protocol) is used to guarantee the atomic commitment of update transactions. 7 Specifically, the vote messages of 2PC are used to inform the coordinator of any local query AFTER set insertions involving the update transaction being committed, and the vote-reply messages are used to propagate
Reference: [Gray81] <author> Gray, J., P. Homan, H. Korth, and Obermarck, R., </author> <title> A Strawman Analysis of the Probability of Waiting and Deadlock in a Database System Research Report RJ3066, </title> <address> IBM San Jose, </address> <month> Feb. </month> <year> 1981. </year>
Reference-contexts: This rise is caused by a decrease in the system resource demands by update transactions due to increased lock waiting; recall that the probability of lock conflict is proportional to the square of the transaction size <ref> [Gray81, Tay85] </ref>. Due to space limitations, we do not show the update transaction throughput here. On the other hand, MVQL query throughput drops initially, and then rises. The rise is also caused by reduced resource competition from the update transactions.
Reference: [Hadz85] <author> Hadzilacos, T. and C. Papadimitriou, </author> <title> "Algorithmic Aspects of Multiversion Concurrency Control," </title> <booktitle> Proceedings of the Fourth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems,, </booktitle> <year> 1985. </year>
Reference-contexts: A query is said to see strong consistency [Garc82] if it is seri alizable with respect to all transactions. 2 This form of consistency is characterized by an acyclic serialization graph, and is provided by algorithms that guarantee multiversion serializability <ref> [Bern83, Papa84, Hadz85] </ref>. Since the previous res triction on the commit ordering of update transactions is relaxed here, strong consistency may produce apparent anomalies in query results if users are somehow cognizant of the commit order of update transactions.
Reference: [Livn89] <author> Livny, M., </author> <note> DeNet User's Guide, Version 1.5, </note> <institution> Computer Sciences Dept., Univ. of Wisconsin-Madison, </institution> <year> 1989. </year>
Reference-contexts: In order to explain the model, we will break it down into two major components, the application model and the system model. Each of these has several subcomponents that will be described in this section. The model was implemented in the DeNet simulation language <ref> [Livn89] </ref>. 4.1. The Application Model The first component of the application model is the database, which is modeled as a collection of files. Each file, in turn, is modeled as a collection of records. One clustered and one unclustered index exist on each file.
Reference: [Moha90] <author> Mohan, C., et al. </author> <title> "Single Table Access Using Multiple Indexes: Optimization, Execution, and Concurrency Control Techniques," </title> <booktitle> Proc. International Conference on Extending Database Technology, </booktitle> <year> 1990. </year>
Reference-contexts: To avoid re-reading pages, medium and large selectivity scans on an unclustered index attribute can be executed by first obtaining a list of the IDs of matching records from the index, sorting the list according to disk address, and then sequentially scanning the data using the record-ID list <ref> [Moha90] </ref>. Our results indicate that MVQL should also provide a lower cost alternative to MV2PL for this sort of work-loads.
Reference: [Moha92] <author> Mohan, C., H. Pirahesh, and R. Lorie, </author> <title> "Efficient and Flexible Methods for Transient Versioning of Records to Avoid Locking by Read-Only Transactions," </title> <booktitle> Proc. 1992 ACM SIGMOD Conf., </booktitle> <year> 1992. </year>
Reference-contexts: Both locking and versioning are both supported at the page level. We chose page-level versioning to simplify the implementation of the simulator and to reduce the length of simulation runs. The basic MV2PL and MVQL algorithms are compatible with record-level versioning; schemes for record-level ver-sioning are discussed in <ref> [Bobe92, Moha92] </ref>. The version manager divides the database into two segments: the main segment, containing the current versions of pages, and the version pool, containing prior page versions.
Reference: [Papa84] <author> Papadimitriou, C. and P. Kanellakis, </author> <title> "On Concurrency Control by Multiple Versions," </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 9(1), </volume> <month> March </month> <year> 1984. </year>
Reference-contexts: A query is said to see strong consistency [Garc82] if it is seri alizable with respect to all transactions. 2 This form of consistency is characterized by an acyclic serialization graph, and is provided by algorithms that guarantee multiversion serializability <ref> [Bern83, Papa84, Hadz85] </ref>. Since the previous res triction on the commit ordering of update transactions is relaxed here, strong consistency may produce apparent anomalies in query results if users are somehow cognizant of the commit order of update transactions.
Reference: [Papa86] <author> Papadimitriou, C. </author> <title> The Theory of Database Concurrency Control, </title> <publisher> Computer Science Press, </publisher> <address> Rockville Maryland, </address> <year> 1986. </year>
Reference: [Pira90] <author> Pirahesh, H., et al, </author> <title> "Parallelism in Relational Database Systems: </title> <booktitle> Architectural Issues and Design Approaches," IEEE 2nd International Symposium on Databases in Parallel and Distributed Systems, </booktitle> <address> Dub-lin, Ireland, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: This is in contrast to approaches that avoid versioning altogether, instead allowing queries to see transaction-inconsistent data. For example, under cursor-stability locking, queries may release locks before acquiring new ones (violating the two-phase rule), and under GO processing <ref> [Pira90] </ref>, queries do not obtain any locks at all (except latches to guarantee page consistency). In the terminology of [Gray79], the former provides degree 2 consistency, and the latter, degree 1.
Reference: [Ragh91] <author> Raghavan, A., and Rengarajan, </author> <title> T.K., "Database Availability for Transaction Processing," </title> <note> Digital Technical Journal 3(1), </note> <month> Winter </month> <year> 1991. </year>
Reference-contexts: An abridged version of this paper will appear in the proceedings of the Eighteenth International Conference on Very Large Data Bases, Van couver, Canada, August 1992. - 1 - MV2PL as an option include Prime's DBMS [DuBo82], DEC's Rdb/VMS product <ref> [Ragh91] </ref>, Interbase, and Object Design. A drawback to MV2PL is the storage cost that it imposes, as well as the additional costs for accessing prior versions and for copying objects before they are updated (if in-place updates are employed).
Reference: [Sarg76] <author> Sargent, R., </author> <title> "Statistical Analysis of Simulation Output Data," </title> <booktitle> Proc. 4th Annual Symposium on the Simulation of Computer Systems, </booktitle> <year> 1976. </year>
Reference-contexts: Additional metrics are used in the analysis of the experimental results. To ensure the statistical validity of our results, we verified that the 90% confidence intervals for response times (computed using batch means <ref> [Sarg76] </ref>) were sufficiently tight. The size of these confidence intervals were within approximately 1% of the mean for update transaction response time and within approximately 5% of the mean for query response time in almost all cases.
Reference: [Tay85] <author> Tay, Y., N. Goodman, and R. Suri, </author> <title> "Locking Performance in Centralized Databases," </title> <journal> ACM Trans. on Database Sys., </journal> <volume> 10(4), </volume> <month> December </month> <year> 1985. </year> <month> - 32 </month> - 
Reference-contexts: This rise is caused by a decrease in the system resource demands by update transactions due to increased lock waiting; recall that the probability of lock conflict is proportional to the square of the transaction size <ref> [Gray81, Tay85] </ref>. Due to space limitations, we do not show the update transaction throughput here. On the other hand, MVQL query throughput drops initially, and then rises. The rise is also caused by reduced resource competition from the update transactions.
Reference: [Teor72] <author> Teorey, T., and T. Pinkerton, </author> <title> "A Comparative Analysis of Disk Scheduling Policies," </title> <journal> Comm. of the ACM, </journal> <volume> (15)3, </volume> <month> March </month> <year> 1972. </year>
Reference-contexts: The disk manager module is designed to model the behavior of a disk controller and driver. The controller schedules disk requests according to the elevator algorithm <ref> [Teor72] </ref>. The total service time is computed as the sum of the seek time, latency, settle time, and transfer time. The seek time of a disk request is computed by multiplying the parameter DiskSeekFactor by the square root of the number of tracks to seek [Bitt88].
Reference: [Wu92] <author> Wu, K.-L., P.S. Yu, and Pu, C., </author> <title> "Divergence Control for Epsilon Serializability," </title> <booktitle> Proc. of the 1992 IEEE Data Engineering Conf., </booktitle> <year> 1992. </year> <month> - 33 </month> - 
Reference-contexts: In the terminology of [Gray79], the former provides degree 2 consistency, and the latter, degree 1. Another example is the class of epsilon-serializability algorithms, which accept inconsistent schedules as long as they are within some number of inversions from a serializable schedule <ref> [Wu92] </ref>. Because MVQL provides weaker consistency than MV2PL, it can allow queries to read more recent versions of objects. Performance savings are gained because it is typically less efficient for queries to read older versions of objects rather than younger (or current) ones.
References-found: 26

