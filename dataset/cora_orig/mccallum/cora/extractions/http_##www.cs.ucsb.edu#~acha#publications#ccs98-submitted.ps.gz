URL: http://www.cs.ucsb.edu/~acha/publications/ccs98-submitted.ps.gz
Refering-URL: http://www.cs.ucsb.edu/~acha/sdi.html
Root-URL: http://www.cs.ucsb.edu
Title: History-based Access Control for Mobile Code  
Author: Guy Edjlali Anurag Acharya Vipin Chaudhary 
Address: Detroit, MI 48202 Santa Barbara, CA 93106 Detroit, MI 48202  
Affiliation: Dept. of ECE Dept. of Computer Science Dept. of ECE Wayne State University University of California Wayne State University  
Abstract: In this paper, we present a history-based access-control mechanism that is suitable for mediating accesses from mobile code. The key idea behind history-based access-control is to maintain a selective history of the access requests made by individual programs and to use this history to improve the differentiation between safe and potentially dangerous requests. What a program is allowed to do depends on its own behavior and identity in addition to currently used discriminators like the location it was loaded from or the identity of its author/provider. History-based access-control has the potential to significantly expand the set of programs that can be executed without compromising security or ease of use. We describe the design and implementation of Deeds, a history-based access-control mechanism for Java. Access-control policies for Deeds are written in Java, and can be updated while the programs whose accesses are being mediated are still executing. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Alexandrov, M. Ibel, K. Schauser, and C. Scheiman. </author> <title> Extending the operating system at the user level: the Ufo global file system. </title> <booktitle> In Proceedings of the 1997 USENIX Annual Technical Conference, </booktitle> <year> 1997. </year>
Reference-contexts: This facility is usually used to implement debuggers and system call tracers. It has also been used to implement a general-purpose code interposition mechanism [24], a secure environment for helper applications used by browsers to display files with different formats [11] and a user-level file system <ref> [1] </ref>. It is also well Number of handlers 0 1 2 3 4 5 6 7 8 9 10 Percent overhead 0.7 1.8 2.6 2.4 2.9 3.5 4.2 3.9 4.3 4.1 4.3 Table 1: Overhead of Deeds security event handlers.
Reference: [2] <author> B. Bershad, S. Savage, P. Pardyak, E. Sirer, D. Becker, M. Fiuczynski, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety and performance in the spin operating system. </title> <booktitle> In Proc of the 15th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 267-84, </pages> <year> 1995. </year>
Reference-contexts: The second limitation of their approach is that it provides a small and fixed number of events. This limits the variety and power of the policies that can be developed. The event model used in Deeds is similar to that used in the SPIN extensible operating system <ref> [2] </ref>. An interesting feature of SPIN is the use of dynamic compilation to improve the performance of event dispatching [5].
Reference: [3] <author> M. Blaze, J. Feigenbaum, and J. Lacy. </author> <title> Decentralized trust management. </title> <booktitle> In Proc of the 17th Symposium on Security and Privacy, </booktitle> <pages> pages 164-73, </pages> <year> 1996. </year>
Reference-contexts: Joint-authorization: Commercial applications, such as contracts and purchase orders, may require multiple authorizations since the organization may wish to reduce the risk of malfesance by dispersing trust over several individuals. History-based access-control policies can be used to implement joint-authorization [37] or k-out-of-n-authorizations <ref> [3] </ref>. For example, a policy may require that three out of five known individuals must make the same request within the last T units of time for the request to be granted; else the request is denied. <p> An important feature of Deeds is its capability to install and compose multiple user-specified policies. Several researchers have proposed languages to allow users to specify access-control policies and frameworks to compose these policies <ref> [3, 13, 18, 19] </ref>. Three of them [13, 18, 19], propose logic-based declarative languages and use inference mechanisms of various sorts to compose policies. <p> Several researchers have proposed languages to allow users to specify access-control policies and frameworks to compose these policies [3, 13, 18, 19]. Three of them [13, 18, 19], propose logic-based declarative languages and use inference mechanisms of various sorts to compose policies. Blaze et al <ref> [3] </ref> propose a language that contains both assertions and procedural filters and use a mechanism similar of that used in Deeds to implement composition. Access-control policies for Deeds are entirely procedural. Furthermore, they can be updated while the programs whose accesses are being controlled are still executing.
Reference: [4] <author> D. Brewer and M. Nash. </author> <title> The Chinese Wall Security Policy. </title> <booktitle> In Proceedings of the 1989 IEEE Symposium on Security and Privacy, </booktitle> <year> 1989. </year>
Reference-contexts: If, however, a program could access both relations, it could combine the relations to acquire (partial) information about treatment histories for individual patients. This example can be seen as an instance of the Chinese Wall Policy <ref> [4] </ref>.
Reference: [5] <author> C. Chambers, S. Eggers, J. Auslander, M. Philipose, M. Mock, and P. Pardyak. </author> <title> Automatic dynamic compilation support for event dispatching in extensible systems. </title> <booktitle> In Workshop on Compiler Support for Systems Software, </booktitle> <year> 1996. </year>
Reference-contexts: Second, we could dynamically modify the bytecode of the downloaded program to insert/delete calls to handlers at the points where the events are generated (as dynamic instrumentation programs <ref> [5, 15] </ref> do). To allow a user to modify an executing policy would require us to update the bytecode of running programs. We believe that the complexity of such an implementation is not commensurate with its advantages. <p> This limits the variety and power of the policies that can be developed. The event model used in Deeds is similar to that used in the SPIN extensible operating system [2]. An interesting feature of SPIN is the use of dynamic compilation to improve the performance of event dispatching <ref> [5] </ref>. If the performance of event dispatching becomes a problem for Deeds (eg. if individual events have a large number of handlers) we can use a similar technique. 7 Current status and future directions Deeds is currently operational and can be used for standalone Java programs.
Reference: [6] <author> B. Christiansen, P. Cappello, M. Ionescu, M. Neary, K. Schauser, and D. Wu. Javelin: </author> <title> Internet-based parallel computing using Java. </title> <booktitle> In Proceedings of the 1997 ACM Workshop on Java for Science and Engineering Computation, </booktitle> <year> 1997. </year>
Reference-contexts: For the programs considered untrusted, these mechanisms can be overly restrictive. Many useful and safe programs, such as a well-behaved editor applet from a lesser-known software company, cannot be used since it cannot open local files. In addition, to implement new resource-sharing models such as global computing <ref> [6] </ref> all communication has to be routed through brokers. This significantly limits the set of problems that can be efficiently handled by such models. For programs considered trusted, these models can be too lax. Errors, not just malice aforethought, can wipe out or leak important data.
Reference: [7] <author> G. Edjlali, A. Acharya, and V. Chaudhary. </author> <title> History-based access control for mobile code. </title> <type> Technical report, </type> <institution> University of California, Santa Barbara, </institution> <year> 1997. </year>
Reference-contexts: These predicates correspond to summaries of event-histories in Deeds terminology. Mehta&Sollins [29] have independently proposed a constraint language for specifying simple history-based access-control policies for Java applets. This work was done in parallel with ours <ref> [7] </ref>. The approach presented in their paper has two major limitations. First, they use the domain name of the server that provides the applet as its identifier. This assigns the same identifier to all applets from the same host. In addition, it is vulnerable to DNS spoofing attacks.
Reference: [8] <author> R. Englander. </author> <title> Developing Java Beans. </title> <publisher> O'Reilly & Associates, </publisher> <year> 1997. </year>
Reference-contexts: We considered three alternatives. First, we could use a general-purpose mechanism (similar to Java Beans <ref> [8] </ref> and X [33]) to register events and handlers.
Reference: [9] <author> J. Fritzinger and M. Mueller. </author> <title> Java security. </title> <type> Technical report, </type> <institution> Sun Microsystems, Inc, </institution> <year> 1996. </year>
Reference-contexts: Depending on its source, mobile code is partitioned into trusted and untrusted code. Code is considered trusted if it is loaded from disk <ref> [9, 12] </ref> or if it is signed by an author/organization deemed trustworthy by the user [12, 30]. <p> Code is considered trusted if it is loaded from disk [9, 12] or if it is signed by an author/organization deemed trustworthy by the user [12, 30]. Untrusted code is confined to a severely restricted execution environment <ref> [9] </ref> (eg, it cannot open local files or sockets, cannot create a subprocess, cannot initiate print requests etc); trusted code is either given access to all available resources [30] or is given selective access based on user-specified access-control lists [12].
Reference: [10] <author> T. </author> <title> Gamble. Implementing execution controls in Unix. </title> <booktitle> In Proceedings of the 7th System Administration Conference, </booktitle> <pages> pages 237-42, </pages> <year> 1993. </year>
Reference-contexts: A similar problem occurs in the context of trojan-horse programs and viruses. To deal with such programs, several researchers have developed mechanisms to limit the privileges of individual programs based on their expected behavior <ref> [10, 25, 26, 27, 28, 39] </ref>. Karger [25] uses information about file extensions and behavior of individual programs to determine the set of files that a program is allowed to access (eg. a compiler invoked on x.c is only allowed to create x.fo,u,outg).
Reference: [11] <author> I. Goldberg, D. Wagner, R. Thomas, and E. Brewer. </author> <title> A secure environment for untrusted helper applications: confining the wily hacker. </title> <booktitle> In Proceedings of the 1996 USENIX Security Symposium, </booktitle> <year> 1996. </year>
Reference-contexts: This facility is usually used to implement debuggers and system call tracers. It has also been used to implement a general-purpose code interposition mechanism [24], a secure environment for helper applications used by browsers to display files with different formats <ref> [11] </ref> and a user-level file system [1]. It is also well Number of handlers 0 1 2 3 4 5 6 7 8 9 10 Percent overhead 0.7 1.8 2.6 2.4 2.9 3.5 4.2 3.9 4.3 4.1 4.3 Table 1: Overhead of Deeds security event handlers.
Reference: [12] <author> L. Gong. </author> <title> New security architectural directions for Java. </title> <booktitle> In Proceedings of IEEE COMPCON'97, </booktitle> <year> 1997. </year>
Reference-contexts: Depending on its source, mobile code is partitioned into trusted and untrusted code. Code is considered trusted if it is loaded from disk <ref> [9, 12] </ref> or if it is signed by an author/organization deemed trustworthy by the user [12, 30]. <p> Depending on its source, mobile code is partitioned into trusted and untrusted code. Code is considered trusted if it is loaded from disk [9, 12] or if it is signed by an author/organization deemed trustworthy by the user <ref> [12, 30] </ref>. <p> Untrusted code is confined to a severely restricted execution environment [9] (eg, it cannot open local files or sockets, cannot create a subprocess, cannot initiate print requests etc); trusted code is either given access to all available resources [30] or is given selective access based on user-specified access-control lists <ref> [12] </ref>. For the programs considered untrusted, these mechanisms can be overly restrictive. Many useful and safe programs, such as a well-behaved editor applet from a lesser-known software company, cannot be used since it cannot open local files. <p> This significantly limits the set of problems that can be efficiently handled by such models. For programs considered trusted, these models can be too lax. Errors, not just malice aforethought, can wipe out or leak important data. Combined with a suitable audit trail, signed programs <ref> [12] </ref> do provide the ability to take legal recourse if need be. In this paper, we present a history-based access-control mechanism that is suitable for mediating accesses from mobile code.
Reference: [13] <author> C. Gunter and T. Jim. </author> <title> Design of an application-level security infrastructure. </title> <booktitle> In DIMACS Workshop on Design and Formal Verification of Security Protocols, </booktitle> <year> 1997. </year>
Reference-contexts: An important feature of Deeds is its capability to install and compose multiple user-specified policies. Several researchers have proposed languages to allow users to specify access-control policies and frameworks to compose these policies <ref> [3, 13, 18, 19] </ref>. Three of them [13, 18, 19], propose logic-based declarative languages and use inference mechanisms of various sorts to compose policies. <p> An important feature of Deeds is its capability to install and compose multiple user-specified policies. Several researchers have proposed languages to allow users to specify access-control policies and frameworks to compose these policies [3, 13, 18, 19]. Three of them <ref> [13, 18, 19] </ref>, propose logic-based declarative languages and use inference mechanisms of various sorts to compose policies. Blaze et al [3] propose a language that contains both assertions and procedural filters and use a mechanism similar of that used in Deeds to implement composition.
Reference: [14] <institution> The HashJava code obfuscator. Available from 4thPass Software,810 32nd Avenue South, </institution> <address> Seattle, WA 98144 4 </address> . 
Reference-contexts: News Server [36] which manages and serves newsgroups local to an organization; (2) jlex, the JLex [23] lexical analyzer; (3) dbase, the Jeevan [22] platform-independent, object-oriented database; (4) jawavedit, the JaWavedit audio file editor [21] with multi-lingual voice synthesis, signal processing, and a graphical user interface; (5) obfuscator, the Hashjava <ref> [14] </ref> obfuscator for Java class files; (6) javacc, the JavaCC [20] parser generator; and (7) editor, the WingDis editor [40]. Table 2 presents results for the latency experiments. As expected, the additional startup latency increases with the number of files as well as the total size of the program.
Reference: [15] <author> J. Hollingsworth, B. Miller, and J. Cargille. </author> <title> Dynamic program instrumentation for scalable performance tools. </title> <booktitle> In SHPCC, </booktitle> <year> 1994. </year>
Reference-contexts: Second, we could dynamically modify the bytecode of the downloaded program to insert/delete calls to handlers at the points where the events are generated (as dynamic instrumentation programs <ref> [5, 15] </ref> do). To allow a user to modify an executing policy would require us to update the bytecode of running programs. We believe that the complexity of such an implementation is not commensurate with its advantages.
Reference: [16] <author> J. Hollingsworth and E. Miller. </author> <title> Using content-derived names for caching and software distribution. </title> <booktitle> In Proceedings of the 1997 ACm Symposium on Software Reusability, </booktitle> <year> 1997. </year> <note> 4 http://www.sbktech.org/hashjava.html </note>
Reference-contexts: For example, the one-out-of-k policy dynamically classifies downloaded programs into one of three classes: browsers, editors and shells. The use of secure hash functions to derive a content-based name for software has been proposed by Hollingsworth et al <ref> [16] </ref>. They propose to use these names for configuration and version management of large applications and application suites (such Microsoft Office). An important feature of Deeds is its capability to install and compose multiple user-specified policies.
Reference: [17] <author> C. Horstmann and G. Cornell. </author> <title> Core Java 1.1, volume I Fundamentals. </title> <publisher> Sun Microsystems Press, </publisher> <address> third edition, </address> <year> 1997. </year>
Reference-contexts: We believe that availability of source code of a policy is important to instill confi dence in its operation and its documentation. 4.2.4 Policy manager The Deeds policy manager makes extensive use of the Java reflection mechanism <ref> [17] </ref>. This mechanism allows Java code to inspect and browse the structure of other classes.
Reference: [18] <author> T. Jaeger, A. Prakash, and A. Rubin. </author> <title> Building systems that flexibly control downloaded executable context. </title> <booktitle> In Proc of the 6th Usenix Security Symposium, </booktitle> <year> 1996. </year>
Reference-contexts: An important feature of Deeds is its capability to install and compose multiple user-specified policies. Several researchers have proposed languages to allow users to specify access-control policies and frameworks to compose these policies <ref> [3, 13, 18, 19] </ref>. Three of them [13, 18, 19], propose logic-based declarative languages and use inference mechanisms of various sorts to compose policies. <p> An important feature of Deeds is its capability to install and compose multiple user-specified policies. Several researchers have proposed languages to allow users to specify access-control policies and frameworks to compose these policies [3, 13, 18, 19]. Three of them <ref> [13, 18, 19] </ref>, propose logic-based declarative languages and use inference mechanisms of various sorts to compose policies. Blaze et al [3] propose a language that contains both assertions and procedural filters and use a mechanism similar of that used in Deeds to implement composition.
Reference: [19] <author> S. Jajodia, P. Samarati, V. Subrahmanian, and E. Bertino. </author> <title> A unified framework for enforcing multiple access control policies. </title> <booktitle> In Proc. ACM SIGMOD Int'l. Conf. on Management of Data, </booktitle> <pages> pages 474-85, </pages> <year> 1997. </year>
Reference-contexts: An important feature of Deeds is its capability to install and compose multiple user-specified policies. Several researchers have proposed languages to allow users to specify access-control policies and frameworks to compose these policies <ref> [3, 13, 18, 19] </ref>. Three of them [13, 18, 19], propose logic-based declarative languages and use inference mechanisms of various sorts to compose policies. <p> An important feature of Deeds is its capability to install and compose multiple user-specified policies. Several researchers have proposed languages to allow users to specify access-control policies and frameworks to compose these policies [3, 13, 18, 19]. Three of them <ref> [13, 18, 19] </ref>, propose logic-based declarative languages and use inference mechanisms of various sorts to compose policies. Blaze et al [3] propose a language that contains both assertions and procedural filters and use a mechanism similar of that used in Deeds to implement composition.
Reference: [20] <institution> The JavaCC parser generator. Available from Sun Mi-crosystems Inc. </institution> <address> 901 San Antonio Road, Palo Alto, CA 94303 USA 5 </address> . 
Reference-contexts: an organization; (2) jlex, the JLex [23] lexical analyzer; (3) dbase, the Jeevan [22] platform-independent, object-oriented database; (4) jawavedit, the JaWavedit audio file editor [21] with multi-lingual voice synthesis, signal processing, and a graphical user interface; (5) obfuscator, the Hashjava [14] obfuscator for Java class files; (6) javacc, the JavaCC <ref> [20] </ref> parser generator; and (7) editor, the WingDis editor [40]. Table 2 presents results for the latency experiments. As expected, the additional startup latency increases with the number of files as well as the total size of the program. Note this does not represent an increase in end-to-end execution time.
Reference: [21] <institution> The JaWavedit Audio File Editor. </institution> <note> Available from Flo-rian Bomers' web site 6 </note> . 
Reference-contexts: The applications we used were: (1) news-server, the Spaniel News Server [36] which manages and serves newsgroups local to an organization; (2) jlex, the JLex [23] lexical analyzer; (3) dbase, the Jeevan [22] platform-independent, object-oriented database; (4) jawavedit, the JaWavedit audio file editor <ref> [21] </ref> with multi-lingual voice synthesis, signal processing, and a graphical user interface; (5) obfuscator, the Hashjava [14] obfuscator for Java class files; (6) javacc, the JavaCC [20] parser generator; and (7) editor, the WingDis editor [40]. Table 2 presents results for the latency experiments.
Reference: [22] <institution> The Jeevan object-oriented database. Available from W3apps Inc., </institution> <address> Ft. Lauderdale, Florida 7 </address> . 
Reference-contexts: For this experiment, we selected seven complete Java applications available on the web. The applications we used were: (1) news-server, the Spaniel News Server [36] which manages and serves newsgroups local to an organization; (2) jlex, the JLex [23] lexical analyzer; (3) dbase, the Jeevan <ref> [22] </ref> platform-independent, object-oriented database; (4) jawavedit, the JaWavedit audio file editor [21] with multi-lingual voice synthesis, signal processing, and a graphical user interface; (5) obfuscator, the Hashjava [14] obfuscator for Java class files; (6) javacc, the JavaCC [20] parser generator; and (7) editor, the WingDis editor [40].
Reference: [23] <institution> The JLex lexical analyzer generator. Available from the Department of Computer Science, Princeton University 8 </institution> . 
Reference-contexts: For this experiment, we selected seven complete Java applications available on the web. The applications we used were: (1) news-server, the Spaniel News Server [36] which manages and serves newsgroups local to an organization; (2) jlex, the JLex <ref> [23] </ref> lexical analyzer; (3) dbase, the Jeevan [22] platform-independent, object-oriented database; (4) jawavedit, the JaWavedit audio file editor [21] with multi-lingual voice synthesis, signal processing, and a graphical user interface; (5) obfuscator, the Hashjava [14] obfuscator for Java class files; (6) javacc, the JavaCC [20] parser generator; and (7) editor, the
Reference: [24] <author> M. Jones. </author> <title> Interposition agents: Transparently interposing user code at the system interface. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating System Principles, </booktitle> <year> 1993. </year>
Reference-contexts: This facility is usually used to implement debuggers and system call tracers. It has also been used to implement a general-purpose code interposition mechanism <ref> [24] </ref>, a secure environment for helper applications used by browsers to display files with different formats [11] and a user-level file system [1].
Reference: [25] <author> P. Karger. </author> <title> Limiting the damage potential of the discretionary trojan horse. </title> <booktitle> In Proceedings of the 1987 IEEE Syposium on Research in Security and Privacy, </booktitle> <year> 1987. </year>
Reference-contexts: While this scheme would require agreement on the labeling scheme, it is no more complex than the MIME-types-based scheme that is already in use for displaying/processing different data formats. This scheme is similar to program-ACLs and related defenses proposed for trojan-horse attacks <ref> [25, 39] </ref>. Joint-authorization: Commercial applications, such as contracts and purchase orders, may require multiple authorizations since the organization may wish to reduce the risk of malfesance by dispersing trust over several individuals. History-based access-control policies can be used to implement joint-authorization [37] or k-out-of-n-authorizations [3]. <p> A similar problem occurs in the context of trojan-horse programs and viruses. To deal with such programs, several researchers have developed mechanisms to limit the privileges of individual programs based on their expected behavior <ref> [10, 25, 26, 27, 28, 39] </ref>. Karger [25] uses information about file extensions and behavior of individual programs to determine the set of files that a program is allowed to access (eg. a compiler invoked on x.c is only allowed to create x.fo,u,outg). <p> A similar problem occurs in the context of trojan-horse programs and viruses. To deal with such programs, several researchers have developed mechanisms to limit the privileges of individual programs based on their expected behavior [10, 25, 26, 27, 28, 39]. Karger <ref> [25] </ref> uses information about file extensions and behavior of individual programs to determine the set of files that a program is allowed to access (eg. a compiler invoked on x.c is only allowed to create x.fo,u,outg).
Reference: [26] <author> M. King. </author> <title> Identifying and controlling undesirable program behaviors. </title> <booktitle> In Proceedings of the 14th National Computer Security Conference, </booktitle> <year> 1992. </year>
Reference-contexts: A similar problem occurs in the context of trojan-horse programs and viruses. To deal with such programs, several researchers have developed mechanisms to limit the privileges of individual programs based on their expected behavior <ref> [10, 25, 26, 27, 28, 39] </ref>. Karger [25] uses information about file extensions and behavior of individual programs to determine the set of files that a program is allowed to access (eg. a compiler invoked on x.c is only allowed to create x.fo,u,outg). <p> Lai [28] replaces the inference mechanism by an explicit list of files accessible by a program. Wichers et al [39] associate program-ACLs with each file thereby limiting the set of programs that can access each file. King <ref> [26] </ref> uses a regular-expression-based language to specify the set of objects each operation can access. Ko et al [27] use a language based on predicate logic and regular expressions to specify the security-relevant behavior of privileged programs and propose to use this specification for intrusion detection.
Reference: [27] <author> C. Ko, G. Fink, and K. Levitt. </author> <title> Automated detection of vulnerabilities in privileged programs by execution monitoring. </title> <booktitle> In Proceedings. 10th Annual Computer Security Applications Conference, </booktitle> <pages> pages 134-44, </pages> <year> 1994. </year>
Reference-contexts: A similar problem occurs in the context of trojan-horse programs and viruses. To deal with such programs, several researchers have developed mechanisms to limit the privileges of individual programs based on their expected behavior <ref> [10, 25, 26, 27, 28, 39] </ref>. Karger [25] uses information about file extensions and behavior of individual programs to determine the set of files that a program is allowed to access (eg. a compiler invoked on x.c is only allowed to create x.fo,u,outg). <p> Wichers et al [39] associate program-ACLs with each file thereby limiting the set of programs that can access each file. King [26] uses a regular-expression-based language to specify the set of objects each operation can access. Ko et al <ref> [27] </ref> use a language based on predicate logic and regular expressions to specify the security-relevant behavior of privileged programs and propose to use this specification for intrusion detection. All these approaches assume that the set of programs to be run are fixed and their behaviors are known.
Reference: [28] <author> N. Lai and T. Gray. </author> <title> Strengthening discretionary access controls to inhibit trojan horses and computer viruses. </title> <booktitle> In Proceedings of the 1988 USENIX Summer Symposium, </booktitle> <year> 1988. </year>
Reference-contexts: A similar problem occurs in the context of trojan-horse programs and viruses. To deal with such programs, several researchers have developed mechanisms to limit the privileges of individual programs based on their expected behavior <ref> [10, 25, 26, 27, 28, 39] </ref>. Karger [25] uses information about file extensions and behavior of individual programs to determine the set of files that a program is allowed to access (eg. a compiler invoked on x.c is only allowed to create x.fo,u,outg). <p> Karger [25] uses information about file extensions and behavior of individual programs to determine the set of files that a program is allowed to access (eg. a compiler invoked on x.c is only allowed to create x.fo,u,outg). Lai <ref> [28] </ref> replaces the inference mechanism by an explicit list of files accessible by a program. Wichers et al [39] associate program-ACLs with each file thereby limiting the set of programs that can access each file.
Reference: [29] <author> N. Mehta and K. Sollins. </author> <title> Extending and expanding the security features of Java. </title> <booktitle> In Proceedings of the 1998 USENIX Security Symposium, </booktitle> <year> 1998. </year>
Reference-contexts: Two research groups have recently proposed constraint languages for specifying security policies temporal aspects. Simon&Zurko [35] propose a language for specifying temporal constraints such as HasDone, NeverDid, NeverUsed and SomeoneFromEach for separation of duty in role-based environments. These predicates correspond to summaries of event-histories in Deeds terminology. Mehta&Sollins <ref> [29] </ref> have independently proposed a constraint language for specifying simple history-based access-control policies for Java applets. This work was done in parallel with ours [7]. The approach presented in their paper has two major limitations.
Reference: [30] <author> Microsoft Corporation. </author> <title> Proposal for Authenticating Code Via the Internet, </title> <month> Apr </month> <year> 1996. </year> <note> http://www.microsoft.com/intdev/security/authcode. </note>
Reference-contexts: Depending on its source, mobile code is partitioned into trusted and untrusted code. Code is considered trusted if it is loaded from disk [9, 12] or if it is signed by an author/organization deemed trustworthy by the user <ref> [12, 30] </ref>. <p> Untrusted code is confined to a severely restricted execution environment [9] (eg, it cannot open local files or sockets, cannot create a subprocess, cannot initiate print requests etc); trusted code is either given access to all available resources <ref> [30] </ref> or is given selective access based on user-specified access-control lists [12]. For the programs considered untrusted, these mechanisms can be overly restrictive. Many useful and safe programs, such as a well-behaved editor applet from a lesser-known software company, cannot be used since it cannot open local files.
Reference: [31] <author> R. Rivest. </author> <title> The MD5 message-digest algorithm. </title> <type> RFC 1321, </type> <institution> Network Working Group, </institution> <year> 1992. </year>
Reference-contexts: Deeds concatenates all non-system-library code for a downloaded program and uses the SHA-1 algorithm [34] to compute a name for it. SHA-1 belongs to the group of algorithms known as secure hash functions <ref> [31, 34] </ref> which take an arbitrary sequence of bytes as input and generate a (relatively) short digest (160-bits for SHA-1). These functions are considered secure because it is computationally hard to construct two byte-sequences which produce the same digest.
Reference: [32] <author> J. Saltzer and M. Schroeder. </author> <title> The protection of information in computer systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 63(9) </volume> <pages> 1278-1308, </pages> <month> Sep </month> <year> 1975. </year>
Reference-contexts: Different classes of programs might have different behaviors all of which are acceptable to the user. It is, therefore, important to provide automatic composition of multiple policies. An important point to note here is that, by default, the access-control mechanism should be fail-safe <ref> [32] </ref> potentially dangerous accesses should be denied unless explicitly granted. 4 Deeds: a history-based security manager for Java In this section we describe the design and implementation of Deeds, a history-based access-control mechanism for Java. We first describe the architecture of Deeds. <p> Policies that are already installed can be modified by changing their parameters. This allows users to make on-the-fly changes to the environment within which mobile code executes. Deeds provides a fail-safe default <ref> [32] </ref> for every security event. Unless overridden, the default handler for an event disallows all requests associated with that event from downloaded programs.
Reference: [33] <author> R. Scheifler and J. Gettys. </author> <title> X Window System : The Complete Reference to Xlib, X Protocol, Icccm, Xlfd. </title> <publisher> Butterworth-Heinemann, </publisher> <year> 1992. </year> <note> 5 http://www.suntest.com/JavaCC 6 http://rummelplatz.uni-mannheim.de/ boemers/JaWavedit 7 http://www.w3apps.com 8 http://www.cs.princeton.edu/ appel/modern/java/JLex </note>
Reference-contexts: We considered three alternatives. First, we could use a general-purpose mechanism (similar to Java Beans [8] and X <ref> [33] </ref>) to register events and handlers.
Reference: [34] <institution> Secure hash standard. Federal Information Processing Standards Publication, </institution> <note> FIPS, PUB 180-1, </note> <month> April </month> <year> 1995. </year>
Reference-contexts: Deeds concatenates all non-system-library code for a downloaded program and uses the SHA-1 algorithm <ref> [34] </ref> to compute a name for it. SHA-1 belongs to the group of algorithms known as secure hash functions [31, 34] which take an arbitrary sequence of bytes as input and generate a (relatively) short digest (160-bits for SHA-1). <p> Deeds concatenates all non-system-library code for a downloaded program and uses the SHA-1 algorithm [34] to compute a name for it. SHA-1 belongs to the group of algorithms known as secure hash functions <ref> [31, 34] </ref> which take an arbitrary sequence of bytes as input and generate a (relatively) short digest (160-bits for SHA-1). These functions are considered secure because it is computationally hard to construct two byte-sequences which produce the same digest.
Reference: [35] <author> R. Simon and M. Zurko. </author> <title> Separation of duty in role-based environments. </title> <booktitle> In Proceedings of the IEEE Computer Security Foundations Workshop'97, </booktitle> <year> 1997. </year>
Reference-contexts: Access-control policies for Deeds are entirely procedural. Furthermore, they can be updated while the programs whose accesses are being controlled are still executing. Two research groups have recently proposed constraint languages for specifying security policies temporal aspects. Simon&Zurko <ref> [35] </ref> propose a language for specifying temporal constraints such as HasDone, NeverDid, NeverUsed and SomeoneFromEach for separation of duty in role-based environments. These predicates correspond to summaries of event-histories in Deeds terminology. Mehta&Sollins [29] have independently proposed a constraint language for specifying simple history-based access-control policies for Java applets.
Reference: [36] <institution> The Spaniel News Server. </institution> <note> Available from Spaniel Software 9 </note> . 
Reference-contexts: In both cases, all the files were local and were in the operating-system file-cache. For this experiment, we selected seven complete Java applications available on the web. The applications we used were: (1) news-server, the Spaniel News Server <ref> [36] </ref> which manages and serves newsgroups local to an organization; (2) jlex, the JLex [23] lexical analyzer; (3) dbase, the Jeevan [22] platform-independent, object-oriented database; (4) jawavedit, the JaWavedit audio file editor [21] with multi-lingual voice synthesis, signal processing, and a graphical user interface; (5) obfuscator, the Hashjava [14] obfuscator for
Reference: [37] <author> V. Varadharajan and P. Allen. </author> <title> Joint actions based authorization schemes. </title> <journal> Operating Systems Review, </journal> <volume> 30(3) </volume> <pages> 32-45, </pages> <year> 1996. </year>
Reference-contexts: Joint-authorization: Commercial applications, such as contracts and purchase orders, may require multiple authorizations since the organization may wish to reduce the risk of malfesance by dispersing trust over several individuals. History-based access-control policies can be used to implement joint-authorization <ref> [37] </ref> or k-out-of-n-authorizations [3]. For example, a policy may require that three out of five known individuals must make the same request within the last T units of time for the request to be granted; else the request is denied.
Reference: [38] <author> D. Wallach, D. Balfanz, D. Dean, and E. Felten. </author> <title> Extensible security architecture for Java. </title> <booktitle> In SOSP 16, </booktitle> <year> 1997. </year>
Reference-contexts: This is important to ensure that a malicious program cannot assume the identity of another program by copying parts or all of the program being spoofed. Efficient maintenance of request-histories: Wallach et al <ref> [38] </ref> mention that a collection of commonly used Java workloads require roughly 30000 crossings between protection domains per CPU-second of execution. Given this request-frequency, it is imperative that access-control checks on individual requests be fast. Simple logging-based techniques are likely to be too expensive.
Reference: [39] <author> D. Wichers, D. Cook, R. Olsson, J. Crossley, P. Kerchen, K. Levitt, and R. Lo. PACL's: </author> <title> an access control list approach to anti-viral security. </title> <booktitle> In USENIX Workshop Proceedings. UNIX SECURITY II, </booktitle> <pages> pages 71-82, </pages> <year> 1990. </year>
Reference-contexts: While this scheme would require agreement on the labeling scheme, it is no more complex than the MIME-types-based scheme that is already in use for displaying/processing different data formats. This scheme is similar to program-ACLs and related defenses proposed for trojan-horse attacks <ref> [25, 39] </ref>. Joint-authorization: Commercial applications, such as contracts and purchase orders, may require multiple authorizations since the organization may wish to reduce the risk of malfesance by dispersing trust over several individuals. History-based access-control policies can be used to implement joint-authorization [37] or k-out-of-n-authorizations [3]. <p> A similar problem occurs in the context of trojan-horse programs and viruses. To deal with such programs, several researchers have developed mechanisms to limit the privileges of individual programs based on their expected behavior <ref> [10, 25, 26, 27, 28, 39] </ref>. Karger [25] uses information about file extensions and behavior of individual programs to determine the set of files that a program is allowed to access (eg. a compiler invoked on x.c is only allowed to create x.fo,u,outg). <p> Lai [28] replaces the inference mechanism by an explicit list of files accessible by a program. Wichers et al <ref> [39] </ref> associate program-ACLs with each file thereby limiting the set of programs that can access each file. King [26] uses a regular-expression-based language to specify the set of objects each operation can access.
Reference: [40] <author> The WingDis Editor. </author> <note> Available from WingSoft Corporation, P.O.Box 7554, Fremont, CA 94537 10 . 9 http://www.searchspaniel.com/newsserver.html 10 http://www.wingsoft.com/javaeditor.shtml </note>
Reference-contexts: (3) dbase, the Jeevan [22] platform-independent, object-oriented database; (4) jawavedit, the JaWavedit audio file editor [21] with multi-lingual voice synthesis, signal processing, and a graphical user interface; (5) obfuscator, the Hashjava [14] obfuscator for Java class files; (6) javacc, the JavaCC [20] parser generator; and (7) editor, the WingDis editor <ref> [40] </ref>. Table 2 presents results for the latency experiments. As expected, the additional startup latency increases with the number of files as well as the total size of the program. Note this does not represent an increase in end-to-end execution time.
References-found: 40

