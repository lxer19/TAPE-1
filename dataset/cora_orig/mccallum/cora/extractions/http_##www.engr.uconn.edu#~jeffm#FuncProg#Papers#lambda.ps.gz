URL: http://www.engr.uconn.edu/~jeffm/FuncProg/Papers/lambda.ps.gz
Refering-URL: http://www.engr.uconn.edu/~jeffm/FuncProg/Papers/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: jeffm@cse.uconn.edu  
Title: Introduction to the Lambda Calculus  
Author: Jeff Meunier 
Address: 6/15/96  
Affiliation: University of Connecticut  
Abstract: The lambda calculus forms the basis for all modern functional programming languages. The concepts of variable renaming, alpha substitution, beta reduction, combinators, and the Church-Rosser theorem are presented in this paper. In order to study the important aspects of the lambda calculus, an interpreter for it was implemented in Scheme, which includes delayed evaluation and function currying. 
Abstract-found: 1
Intro-found: 1
Reference: [Davi92] <author> Davie, A.J.T., </author> <title> An Introduction to Functional Programming Systems Using Haskell, </title> <publisher> Cambridge University Press, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference: [Reve88] <author> Revesz, Grygory E, </author> <title> Lambda Calculus, Combinators, and Functional Programming, </title> <publisher> Cambridge University Press, </publisher> <address> NY, </address> <year> 1988. </year>
Reference-contexts: l expression E, denoted by f (E), is defined by induction on the construction of E as follows: (1) f (c) = - (the empty set) if c is a constant (2) f (x) = -x- for any variable x (3) f ( l x.P) = f (P) - -x <ref> [Reve88, p.17-8] </ref> The list of free variables is needed for alpha substitution. 2.2 Renaming Renaming of variables is the lowest-level operation that actually changes a lambda expression. Within an expression, any occurrence of a specified variable is simply replaced with a different specified variable. <p> by induction on the construction of P as follows: (1) -z/x-x z (3) -z/x-l x.E l z.-z/x-E, for every l expression E (4) -z/x-l y.E l y.-z/x-E, for every l expression E, if not (x y) (5) -z/x-(E )E (-z/x-E )-z/x-E , for any two l expressions E 1 2 <ref> [Reve88, p.19] </ref> Variable renaming is needed for alpha substitution. 2.3 Alpha Substitution Alpha substitution is the mechanism in which actual reduction takes place. Alpha substitution of an expression for a variable can only occur on a free variable in the expression. <p> l y.E @ l z.[Q/x]-z/y-E for any l expression E and for any z with not (x z) and not (z y) which is neither free nor bound in (E)Q, if not (x y) and both x f (E) and y f (Q) hold (6) [Q/x](E )E @ ([Q/x]E )[Q/x]E <ref> [Reve88, p.20] </ref> 2.4 Beta Reduction This is the highest-level operation performed on lambda expressions. <p> an argument is applied to a lambda expression, alpha substitution is used to replace the bound variable with the argument within the body of the expression. (The body of the expression is the expression minus the head (the " l x." part).) ( b ) ( l x.P)Q fi [Q/x]P <ref> [Reve88, p.23] </ref> In the above rule, the ( l x.P)Q term is called a beta redex, and when this type of form is encountered in an expression, it indicates that a reduction can take place. When a beta redex is reduced, the result is called a contractum. [Reve88, p.23] Although it <p> x.P)Q fi [Q/x]P <ref> [Reve88, p.23] </ref> In the above rule, the ( l x.P)Q term is called a beta redex, and when this type of form is encountered in an expression, it indicates that a reduction can take place. When a beta redex is reduced, the result is called a contractum. [Reve88, p.23] Although it is called reduction, reducing some expressions can actually yield larger expressions. For example, the expression (l x.xxx) (l x.xxx) reduces to (l x.xxx) (l x.xxx) (l x.xxx). In fact the reduction of this expression never terminates, and it expands indefinitely. <p> This graph based approach would cause each subexpression to be both stored and evaluated only once. In addition to this, and as a result of the Church-Rosser theorem, given an arbitrary graph, the order in which the subexpressions are evaluated is "irrelevant, as long as the reduction terminates." <ref> [Reve88, p.25] </ref> Thus, a beta-redex can be evaluated as soon as it is available. This is an important fact which is exploited by parallel graph reduction computers, the discussion of which is beyond the scope of this paper. 5. <p> Combinators A combinator is a lambda expression which contains no free variables. "The term 'combinator' refers to their use as higher-order functions which would form new functions by combining given ones." <ref> [Reve88, p.36] </ref> There are three important combinators, I , S , and K . They are defined as: I = l x.x K = l x. l y.x I is an identity combinator. It returns the value given to it. S is a distributive combinator. <p> It returns the value given to it. S is a distributive combinator. It distributes its third argument to its first two. K is a constant combinator, which throws away its second argument. The author in <ref> [Reve88] </ref> describes an operation called bracket abstraction, and then, using bracket abstraction, proves that every lambda expression can be replaced by an equivalent expression consisting solely of the combinators I , S , and K and no variables (either free or bound). 6. <p> The Interpreter An interpreter for the lambda calculus was implemented in Scheme to further study delayed evaluation and function currying. The interpreter was written to model the reduction and substitution rules given in <ref> [Reve88] </ref>. Here is an example of how to evaluate an expression at the Scheme command line using the interpreter: (lam-eval '((lam (x) x) q)) fi q 8.1 Definition List A global association list is used to hold named expressions.
References-found: 2

