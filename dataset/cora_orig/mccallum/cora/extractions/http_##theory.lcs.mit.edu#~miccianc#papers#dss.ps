URL: http://theory.lcs.mit.edu/~miccianc/papers/dss.ps
Refering-URL: http://theory.lcs.mit.edu/~cis/cis-publications.html
Root-URL: 
Email: E-Mail: mihir@cs.ucsd.edu.  E-Mail: shafi@theory.lcs.mit.edu.  E-Mail: miccianc@theory.lcs.mit.edu.  
Title: "Pseudo-Random" Number Generation within Cryptographic Algorithms: the DSS Case  
Author: Mihir Bellare Shafi Goldwasser Daniele Micciancio 
Web: URL: http://www-cse.ucsd.edu/users/mihir.  
Address: San Diego, 9500 Gilman Drive, La Jolla, California 92093, USA.  545 Technology Square, Cambridge, MA 02139, USA.  545 Technology Square, Cambridge, MA 02139, USA.  
Affiliation: Dept. of Computer Science Engineering, University of California at  Science and Engineering. MIT Laboratory for Computer Science,  MIT Laboratory for Computer Science,  
Date: May 1997  
Note: Appears in Advances in Cryptology Crypto 97 Proceedings, Lecture Notes in Computer Science Vol. B. Kaliski ed., Springer-Verlag, 1997.  Supported in part by NSF CAREER Award CCR-9624439 and a 1996 Packard Foundation Fellowship in  Supported in part by DARPA contract DABT63-96-C-0018.  Supported in part by DARPA contract DABT63-96-C-0018.  
Abstract: The DSS signature algorithm requires the signer to generate a new random number with every signature. We show that if random numbers for DSS are generated using a linear congruential pseudorandom number generator (LCG) then the secret key can be quickly recovered after seeing a few signatures. This illustrates the high vulnerability of the DSS to weaknesses in the underlying random number generation process. It also confirms, that a sequence produced by LCG is not only predictable as has been known before, but should be used with extreme caution even within cryptographic applications that would appear to protect this sequence. The attack we present applies to truncated linear congruential generators as well, and can be extended to any pseudo random generator that can be described via modular linear equations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Babai. </author> <title> On Lovasz' lattice reduction and the nearest lattice point problem. </title> <journal> Combinatorica, </journal> <volume> 6(1) </volume> <pages> 1-13, </pages> <year> 1986. </year>
Reference-contexts: Given B and a vector x 2 R n not in L (B), the nearest lattice vector problem asks for a lattice vectors w 2 L (B) such that kw xk = min v2L (B) kv xk. In <ref> [1] </ref>, Babai gave a simple polynomial time algorithm to find an approximate solution to the nearest lattice vector problem: given the basis B and the target vector x, Babai's algorithm returns a lattice vector w such that kw xk c min v2L (B) kv xk, where c = 2 n=2 is <p> L = " 0 and define the vectors ~ X = ~ b # " ~y Notice that ~ X is a lattice vector and k ~ X ~ Y k = u t i=1 i;i u t i=1 c 2 n 1 : Running Babai's nearest lattice vector algorithm <ref> [1] </ref> on lattice L and target vector Y we obtain a lattice vector ~ W such that k ~ W ~ Y k &lt; ck ~ X ~ Y k 1. Since the first m elements of ~ W and ~ Y are integers, they must be the same.
Reference: [2] <author> M. Bellare and P. Rogaway. </author> <title> Random oracles are practical: A paradigm for designing efficient protocols. </title> <booktitle> Proceedings of the First Annual Conference on Computer and Communications Security, ACM, </booktitle> <year> 1993. </year>
Reference-contexts: The hashing serves two purposes. The first is to enable one to sign messages of length longer than 160 bits. Second, it "randomizes" the message to prevent any possible attacks based on the algebraic structure of the scheme. Accordingly, following <ref> [2] </ref>, we treat the hash function as a random oracle. We stress that we are considering attacks. In this context, treating H as a random oracle only strengthens our results.
Reference: [3] <author> M. Blum and S. Micali. </author> <title> How to generate cryptographically strong sequences of pseudo-random bits. </title> <journal> SIAM J. Computing, </journal> <volume> 13(4) </volume> <pages> 850-863, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Thus, an evaluation of the overall security of a cryptographic algorithm should consider and take into account the choice of the pseudorandom generator. It has been well accepted that a good notion of pseudorandomness for cryptographic purposes is unpredictability <ref> [18, 20, 3, 7] </ref>: given an initial sequence produced by a pseudo-random number generator on an unknown seed, it is hard to predict with better probability than guessing at random, the next bit in the sequence output by the generator.
Reference: [4] <author> Joan Boyar. </author> <title> Inferring sequences produced by pseudo-random number generators. </title> <journal> Journal of the ACM, </journal> <volume> 36(1) </volume> <pages> 129-141, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Truncated LCG were suggested by Knuth [12] as a possible way to make a linear congruential generator secure. However these generators have also been shown to be predictable [5, 9, 19] as have more general congruential generators <ref> [4, 13] </ref>. However, as indicated above, this predictability does not directly mean a cryptographic algorithm using the generator is breakable, since it is possible none of the bits of the random numbers used by the algorithm are ever made public.
Reference: [5] <author> A. M. Frieze, R. Kannan, and J. C. Lagarias. </author> <title> Linear congruential generators do not produce random sequences. </title> <booktitle> In Proc. 25th IEEE Symp. on Foundations of Comp. Science, </booktitle> <pages> pages 480-484, </pages> <address> Singer Island, 1984. </address> <publisher> IEEE. </publisher>
Reference-contexts: Truncated LCG were suggested by Knuth [12] as a possible way to make a linear congruential generator secure. However these generators have also been shown to be predictable <ref> [5, 9, 19] </ref> as have more general congruential generators [4, 13]. However, as indicated above, this predictability does not directly mean a cryptographic algorithm using the generator is breakable, since it is possible none of the bits of the random numbers used by the algorithm are ever made public.
Reference: [6] <author> Taher El Gamal. </author> <title> A public key cryptosystem and a signature scheme based on discrete logarithms. </title> <editor> In G. R. Blakley and D. C. Chaum, editors, </editor> <booktitle> Proc. CRYPTO 84, </booktitle> <pages> pages 10-18. </pages> <publisher> Springer, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 196. </note>
Reference-contexts: It is plausible that there are DSA implementations available where the k values are formed by concatenating 5 consecutive outputs from such a generator. Our attack easily extends to this case. 2 Preliminaries 2.1 The Digital Signature Standard The Digital Signature Standard (DSS, see [16]) is an ElGamal-like <ref> [6] </ref> digital signature algorithm based on the hardness of computing the discrete logarithm in some finite fields. The scheme.
Reference: [7] <author> O. Goldreich, S. Goldwasser, and S. Micali. </author> <title> How to construct random functions. </title> <booktitle> In Proc. 25th IEEE Symp. on Foundations of Comp. Science, </booktitle> <pages> pages 464-479, </pages> <address> Singer Island, 1984. </address> <publisher> IEEE. </publisher>
Reference-contexts: Thus, an evaluation of the overall security of a cryptographic algorithm should consider and take into account the choice of the pseudorandom generator. It has been well accepted that a good notion of pseudorandomness for cryptographic purposes is unpredictability <ref> [18, 20, 3, 7] </ref>: given an initial sequence produced by a pseudo-random number generator on an unknown seed, it is hard to predict with better probability than guessing at random, the next bit in the sequence output by the generator.
Reference: [8] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic Encryption. </title> <journal> Journal of Computer and System Sciences 28 </journal> <pages> 270-299, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: requires the choice of a new random number every time a new signature is generated, and CBC encryption, which requires the generation of a new random IV each time a new message is encrypted. (In fact, any secure, stateless encryption scheme must be probabilistic, requiring new randomness for each encryption <ref> [8] </ref>.) In some cases, the random numbers chosen may have to be kept secret (as for DSS, where the leakage of one such random number compromises the secret key), whereas for other cases they can be made public (as in CBC encryption, where the IV may be sent in the clear).
Reference: [9] <author> J. Hastad and A. Shamir. </author> <title> The cryptographic security of truncated linearly related variables. </title> <booktitle> In Proc. 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 356-362, </pages> <address> Providence, 1985. </address> <publisher> ACM. </publisher>
Reference-contexts: Truncated LCG were suggested by Knuth [12] as a possible way to make a linear congruential generator secure. However these generators have also been shown to be predictable <ref> [5, 9, 19] </ref> as have more general congruential generators [4, 13]. However, as indicated above, this predictability does not directly mean a cryptographic algorithm using the generator is breakable, since it is possible none of the bits of the random numbers used by the algorithm are ever made public.
Reference: [10] <author> R. Kannan. </author> <title> Minkowski's convex body theorem and integer programming. </title> <journal> Mathematics of operations research, </journal> <volume> 12(3) </volume> <pages> 415-440, </pages> <year> 1987. </year>
Reference-contexts: implications We extend our techniques to provide a general algorithm for solving a system of simultaneous linear modular equations in different moduli. (Another way of doing this, when the number of equations is constant, is to reduce the problem to integer programming in constant dimension and apply the algorithms of <ref> [14, 10] </ref>. Our alternative solution seems simpler and more direct.) In many cryptographic algorithms, the random numbers used are processed in a way that the public information gives little information about the original numbers. This is the case for the nonces in DSS. <p> Since we have a constant number of equations, they can thus be solved using polynomial time algorithms for integer programming in constant dimensions as given in <ref> [14, 10] </ref>. However these algorithms are relatively complex and slow. Instead, we we want to solve more directly and simply. We now present a simple lattice based algorithm that solves our system using a nearest lattice vector approximation algorithm as a subroutine. The nearest lattice vector problem.
Reference: [11] <author> Donald E. Knuth. </author> <title> Seminumerical Algorithms, </title> <booktitle> volume 2 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1969. </year> <note> Second edition, </note> <year> 1981. </year>
Reference-contexts: The advantage of linear congruential generators is that they are fast, and it has been shown <ref> [11] </ref> that they have good statistical properties for appropriate choices of the parameters a; b; M . On the other hand, their unpredictability properties are known to be quite weak.
Reference: [12] <author> Donald E. Knuth. </author> <title> Deciphering a linear congruential encryption. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-31(1):49-52, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: Plumstead (Boyar) [17] shows that even if the parameters a; b; M are unknown the sequence of numbers produced by a linear congruential generator is still predictable given some of the X i . Truncated LCG were suggested by Knuth <ref> [12] </ref> as a possible way to make a linear congruential generator secure. However these generators have also been shown to be predictable [5, 9, 19] as have more general congruential generators [4, 13].
Reference: [13] <author> H. Krawczyk. </author> <title> How to predict congruential generators. </title> <editor> In G. Brassard, editor, </editor> <booktitle> Proc. CRYPTO 89, </booktitle> <pages> pages 138-153. </pages> <publisher> Springer, </publisher> <year> 1990. </year> <booktitle> Lecture Notes in Computer Science No. </booktitle> <volume> 435. </volume> <pages> 14 </pages>
Reference-contexts: Truncated LCG were suggested by Knuth [12] as a possible way to make a linear congruential generator secure. However these generators have also been shown to be predictable [5, 9, 19] as have more general congruential generators <ref> [4, 13] </ref>. However, as indicated above, this predictability does not directly mean a cryptographic algorithm using the generator is breakable, since it is possible none of the bits of the random numbers used by the algorithm are ever made public.
Reference: [14] <author> H.W. Lenstra. </author> <title> Integer programming with a fixed number of variables. </title> <journal> Mathematics of opera-tions research, </journal> <volume> 8(4) </volume> <pages> 538-548, </pages> <year> 1983. </year>
Reference-contexts: implications We extend our techniques to provide a general algorithm for solving a system of simultaneous linear modular equations in different moduli. (Another way of doing this, when the number of equations is constant, is to reduce the problem to integer programming in constant dimension and apply the algorithms of <ref> [14, 10] </ref>. Our alternative solution seems simpler and more direct.) In many cryptographic algorithms, the random numbers used are processed in a way that the public information gives little information about the original numbers. This is the case for the nonces in DSS. <p> Since we have a constant number of equations, they can thus be solved using polynomial time algorithms for integer programming in constant dimensions as given in <ref> [14, 10] </ref>. However these algorithms are relatively complex and slow. Instead, we we want to solve more directly and simply. We now present a simple lattice based algorithm that solves our system using a nearest lattice vector approximation algorithm as a subroutine. The nearest lattice vector problem.
Reference: [15] <institution> National Institute of Standards and Technology (NIST). </institution> <note> FIPS Publication 180: Secure Hash Standard (SHS), </note> <month> May 11, </month> <year> 1993. </year>
Reference-contexts: Specifically, if m is the actual text to be signed, the standard sets H = SHA-1, the Secure Hash Algorithm of <ref> [15] </ref>. The hashing serves two purposes. The first is to enable one to sign messages of length longer than 160 bits. Second, it "randomizes" the message to prevent any possible attacks based on the algebraic structure of the scheme.
Reference: [16] <institution> National Institute of Standards and Technology (NIST). </institution> <note> FIPS Publication 186: Digital Signature Standard, </note> <month> May 19, </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Randomness is a key ingredient for cryptography. Random bits are necessary not only for generating cryptographic keys, but are also often an integral part of steps of cryptographic algorithms. Examples are the DSS signature algorithm <ref> [16] </ref> which requires the choice of a new random number every time a new signature is generated, and CBC encryption, which requires the generation of a new random IV each time a new message is encrypted. (In fact, any secure, stateless encryption scheme must be probabilistic, requiring new randomness for each <p> In practice, the random bits will be generated by a pseudo random number generation process. For example, the DSS description <ref> [16] </ref> explicitly allows either using random or pseudo-random numbers. When this is done, the security of the scheme of course depends in a crucial way on the quality of the random bits produced by the generator. <p> The intent of our paper is to illustrate the extreme care with which one should choose a pseudo random number generator to use within a particular cryptographic algorithm. Specifically, we consider a concrete algorithm, the Digital Signature Standard <ref> [16] </ref>, and a concrete pseudo random number generator, the linear congruential generator (LCG) or truncated linear congruential pseudo random generator. We then show that if a LCG or truncated LCG is used to produce the pseudo random choices called for in DSS, then DSS becomes completely breakable. <p> We then show that if a LCG or truncated LCG is used to produce the pseudo random choices called for in DSS, then DSS becomes completely breakable. We remark that the Standard <ref> [16] </ref> recommends the use of a pseudo-random generator based on SHA-1 or DES. The attack we describe does not say anything about the use of DSS with such generators, but it does illustrates the high vulnerability of the DSS to the underlying random number generation process. <p> It is plausible that there are DSA implementations available where the k values are formed by concatenating 5 consecutive outputs from such a generator. Our attack easily extends to this case. 2 Preliminaries 2.1 The Digital Signature Standard The Digital Signature Standard (DSS, see <ref> [16] </ref>) is an ElGamal-like [6] digital signature algorithm based on the hardness of computing the discrete logarithm in some finite fields. The scheme.
Reference: [17] <author> J. Plumstead (Boyar). </author> <title> Inferring a sequence generated by a linear congruence. </title> <booktitle> In Proc. 23rd IEEE Symp. on Foundations of Comp. Science, </booktitle> <pages> pages 153-159, </pages> <address> Chicago, 1982. </address> <publisher> IEEE. </publisher>
Reference-contexts: On the other hand, their unpredictability properties are known to be quite weak. Clearly they are predictable in their simplest form: if the parameters a, b and M are known, given X 0 all the other X n can be easily computed. Plumstead (Boyar) <ref> [17] </ref> shows that even if the parameters a; b; M are unknown the sequence of numbers produced by a linear congruential generator is still predictable given some of the X i . Truncated LCG were suggested by Knuth [12] as a possible way to make a linear congruential generator secure.
Reference: [18] <author> Adi Shamir. </author> <title> The generation of cryptographically strong pseudo-random sequences. </title> <editor> In Allen Gersho, editor, </editor> <booktitle> Advances in Cryptology: A Report on CRYPTO 81, </booktitle> <pages> pages 1-1. </pages> <institution> U.C. Santa Barbara Dept. of Elec. and Computer Eng., </institution> <year> 1982. </year> <type> Tech Report 82-04. </type>
Reference-contexts: Thus, an evaluation of the overall security of a cryptographic algorithm should consider and take into account the choice of the pseudorandom generator. It has been well accepted that a good notion of pseudorandomness for cryptographic purposes is unpredictability <ref> [18, 20, 3, 7] </ref>: given an initial sequence produced by a pseudo-random number generator on an unknown seed, it is hard to predict with better probability than guessing at random, the next bit in the sequence output by the generator.
Reference: [19] <author> J. Stern. </author> <title> Secret linear congruential generators are not cryptographically secure. </title> <booktitle> In Proc. 28th IEEE Symp. on Foundations of Comp. Science, </booktitle> <pages> pages 421-426, </pages> <address> Los Angeles, 1987. </address> <publisher> IEEE. </publisher>
Reference-contexts: Truncated LCG were suggested by Knuth [12] as a possible way to make a linear congruential generator secure. However these generators have also been shown to be predictable <ref> [5, 9, 19] </ref> as have more general congruential generators [4, 13]. However, as indicated above, this predictability does not directly mean a cryptographic algorithm using the generator is breakable, since it is possible none of the bits of the random numbers used by the algorithm are ever made public.
Reference: [20] <author> A. C. Yao. </author> <title> Theory and application of trapdoor functions. </title> <booktitle> In Proc. 23rd IEEE Symp. on Foundations of Comp. Science, </booktitle> <pages> pages 80-91, </pages> <address> Chicago, </address> <year> 1982. </year> <journal> IEEE. </journal> <volume> 15 </volume>
Reference-contexts: Thus, an evaluation of the overall security of a cryptographic algorithm should consider and take into account the choice of the pseudorandom generator. It has been well accepted that a good notion of pseudorandomness for cryptographic purposes is unpredictability <ref> [18, 20, 3, 7] </ref>: given an initial sequence produced by a pseudo-random number generator on an unknown seed, it is hard to predict with better probability than guessing at random, the next bit in the sequence output by the generator.
References-found: 20

