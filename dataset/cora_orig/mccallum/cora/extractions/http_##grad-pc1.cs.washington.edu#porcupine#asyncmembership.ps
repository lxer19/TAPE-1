URL: http://grad-pc1.cs.washington.edu/porcupine/asyncmembership.ps
Refering-URL: http://grad-pc1.cs.washington.edu/porcupine/related.htm
Root-URL: 
Title: Agreeing on Processor Group Membership in Timed Asynchronous Distributed Systems  
Author: Flaviu Cristian Frank Schmuck 
Keyword: Agreement, Asynchronous System, Distributed System, Failure Detection, Fault-Tolerance, Leader Election, Mutual Exclusion, Network Partition, Processor Membership, Replicated Data.  
Address: La Jolla, CA 920930114  650 Harry Road San Jose, CA 951206099  
Affiliation: Computer Science and Engineering University of California, San Diego  IBM Almaden Research Center  
Abstract: We introduce the timed asynchronous distributed system model to describe existing asynchronous distributed systems subject to unbounded processing and communication delays, failures and recoveries. We then describe five increasingly strong specifications for processor-group membership services in timed asynchronous systems subject to partitioning. We also propose five distributed protocols that implement these specifications despite arbitrary numbers of crash/performance processor failures and omission/performance communication failures, and prove their correctness. Finally, we show how two of the protocols can be adapted to implement a highly available processor leadership service that ensures the existence of at most one leader at any point in real-time. fl Partially supported by grants from the Air Force Office of Scientific Research, Sun Microsystems, and the Microelectronics Innovation and Computer Research Opportunities in California. UCSD Technical Report CSE95-428, 1995 
Abstract-found: 1
Intro-found: 1
Reference: [ACBMT95] <author> E. Anceaume, B. Charron-Bost, P. Minet, and S. Toueg. </author> <title> On the Formal Specification of Group Membership Services. </title> <type> Technical Report 95-1534, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, New York 14853, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: All (necessarily ambiguous) English protocol descriptions are complemented by unambiguous formal protocol code in the appendix. The appendix also contains proofs that all five protocols satisfy their respective specifications and that the two solutions given for solving the highly available leadership problem are correct. 2 Related Work According to <ref> [CHTCB96, ACBMT95] </ref>, the membership problem was first defined for synchronous systems in [Cri91b]. Since then this problem has also been subject of intense investigation for asynchronous systems. <p> Thus, partitionable membership services resemble our `one-round' and `three-round with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in <ref> [ACBMT95] </ref>, the most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification <p> give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by trivial, useless protocols. <ref> [ACBMT95] </ref> also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified by the authors.
Reference: [ADKM92] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership Algorithms in Broadcast Domains. </title> <type> Technical Report CS92-10, </type> <institution> Computer Science Department, The Hebrew University of Jerusalem, Israel, </institution> <year> 1992. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership <ref> [ADKM92, JFR93, vRBM96, BBDG94, EMS95] </ref>. Some of these membership services explicitly assume a time-free underlying system model (e.g., [RB91, MPS92, HS95, BBDG94]), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model.
Reference: [BBDG94] <author> O. Babaoglu, M. Baker, R. Davoli, and L. Giachini. Relacs: </author> <title> a Communication Infrastructure for Constructing Reliable Applications. </title> <type> Technical Report CS94-15, </type> <institution> Laboratory for Computer Science, The University of Bologna, </institution> <year> 1994. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership <ref> [ADKM92, JFR93, vRBM96, BBDG94, EMS95] </ref>. Some of these membership services explicitly assume a time-free underlying system model (e.g., [RB91, MPS92, HS95, BBDG94]), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model. <p> Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95]. Some of these membership services explicitly assume a time-free underlying system model (e.g., <ref> [RB91, MPS92, HS95, BBDG94] </ref>), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model.
Reference: [Car85] <author> R. Carr. </author> <title> The Tandem Global Update Protocol. </title> <journal> Tandem Systems Review, </journal> <month> Jun </month> <year> 1985. </year>
Reference-contexts: Indeed, when processes cannot distinguish between peer processor failures and communication failures, two correct processes which lose communication with each other may take conflicting actions if each assumes the failure of the other, as illustrated by the membership protocol of <ref> [Car85] </ref>. <p> This will violate the safety condition characteristic of the primary/back-up availability policy, namely that at no point in real-time there should be two primaries. It is precisely because the Tandem membership protocol described in <ref> [Car85] </ref> is an independent assessment protocol, that it is subject to the "split brain behavior" described above. 7 The One Round Protocol In a system in which message delays are random, processor and communication failures occur at random times unknown in advance, and clocks can drift from real-time at actual rates <p> For each service a protocol that implements it was also described and proven correct. The Independent Assessment protocol is perhaps the protocol most frequently implemented in real systems (e.g. <ref> [Car85] </ref>) because of its simplicity. Unfortunately, the protocol exhibits the "split brain" behavior which can have serious consequences on system availability.
Reference: [Car90] <author> R. Carr. </author> <title> The Split Brain Syndrome. </title> <type> Private Communication, </type> <year> 1990. </year>
Reference-contexts: The resulting system behavior, known as "split brains" behavior in Tandem terminology <ref> [Car90] </ref>, can result in total system crashes. We begin by defining what we mean by an asynchronous system and its likely failures.
Reference: [CASD85] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic Broadcast: From Simple Message Diffusion to Byzantine Agreement. </title> <booktitle> In Proceedings of the Fifteenth International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 200-206, </pages> <address> Ann Arbor, MI, </address> <month> Jun </month> <year> 1985. </year>
Reference-contexts: Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous. In previous publications (e.g. [Cri89, Cri91c, Cri91a, CM94]) we called such systems simply asynchronous, as opposed to the synchronous system model investigated in <ref> [CASD85, Cri91b, Cri93] </ref>. This has unfortunately caused some confusion, since other authors (e.g. [FLP85]) use the term `asynchronous system' with a different meaning.
Reference: [CF97] <author> F. Cristian and C. </author> <title> Fetzer. The Timed Asynchronous System Model. </title> <type> Technical Report CS97-519, UCSD, </type> <month> Jan </month> <year> 1997. </year> <note> 11 Conclusion 35 </note>
Reference-contexts: Such programming is not possible in the time-free model augmented with failure detectors, since timers are unavailable above the failure detector layer. Measurements done at the Dependable Systems Lab at UCSD <ref> [CF97] </ref> confirm that the timed asynchronous system model introduced here captures acuratelly what is going on in existing distributed systems built from networked workstations. 4 History-dependent Approach to Communication To implement highly available distributed services, processors are structured into teams.
Reference: [CHT96] <author> T. Chandra, V. Hadzilacos, and S. Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <journal> Journal of the ACM, </journal> <volume> 43(2) </volume> <pages> 225-267, </pages> <year> 1996. </year>
Reference-contexts: Another way to add "synchrony" to the time-free system is to augment it with failure detectors <ref> [CHT96] </ref>.
Reference: [CHTCB96] <author> T. Chandra, V. Hadzilacos, S. Toueg, and B. Charron-Bost. </author> <title> On the Impossibility of Group Membership. </title> <booktitle> In 15th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 322-330, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: All (necessarily ambiguous) English protocol descriptions are complemented by unambiguous formal protocol code in the appendix. The appendix also contains proofs that all five protocols satisfy their respective specifications and that the two solutions given for solving the highly available leadership problem are correct. 2 Related Work According to <ref> [CHTCB96, ACBMT95] </ref>, the membership problem was first defined for synchronous systems in [Cri91b]. Since then this problem has also been subject of intense investigation for asynchronous systems. <p> We hope our specifications and protocols do not suffer from such shortcomings, partly because we assume a timed asynchronous system model. As pointed out in <ref> [CHTCB96] </ref> no useful membership service can be implemented in the time-free asynchronous system model, since a subproblem common to all such services cannot provably be solved in the time-free model. 3 Timed Asynchronous System Model We consider a system consisting of a set of processors P linked by a datagram communication
Reference: [CM94] <author> F. Cristian and S. Mishra. </author> <title> Automatic Service Availability Management in Asynchronous Distributed Systems. </title> <booktitle> In Proc. 2d Int. Workshop on Configurable Distributed Systems, </booktitle> <address> Pittsburgh, PA, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: We call a system of processors and communication services that satisfies the hypotheses listed above a timed asynchronous system. Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous. In previous publications (e.g. <ref> [Cri89, Cri91c, Cri91a, CM94] </ref>) we called such systems simply asynchronous, as opposed to the synchronous system model investigated in [CASD85, Cri91b, Cri93]. This has unfortunately caused some confusion, since other authors (e.g. [FLP85]) use the term `asynchronous system' with a different meaning. <p> This allows users to order all failure and recoveries that occur in time, and contributes to simplify the programming of many higher level applications (see for example the synchronous and asynchronous availability management services described in [Cri93] and <ref> [CM94] </ref>, respectively). <p> Hence requirement (Sld) is satisfied. The problem with the above protocol is its behavior during periods of system instability. During such periods, different processors can disagree on which processors are connected to them and which are not. For example, assume that p and q are two availability managers <ref> [CM94] </ref> responsible for enforcing a primary/back-up availability policy for a group of two database managers fd,d'g running on the same processors as p and q, respectively. <p> This may be a particularly vexing problem if the goal is to build an availability management service <ref> [CM94] </ref>, which must enforce its specified service availability policies for all failures and recoveries that occur in the system. <p> Since the protocol can cause processors to miss certain events of interest and to disagree on the order in which events occur, the One Round protocol is not suitable for sophisticated applications such as system availability management <ref> [Cri93, CM94] </ref>. The Three Round Protocol with Partition Notification stabilizes faster after multiple failures and recoveries and provides a faster promotion time for the continuous leadership problem, at the expense of using 3n messages instead of n for group creation.
Reference: [Cri89] <author> F. Cristian. </author> <title> Probabilistic Clock Synchronization. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 146-158, </pages> <year> 1989. </year>
Reference-contexts: We call a system of processors and communication services that satisfies the hypotheses listed above a timed asynchronous system. Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous. In previous publications (e.g. <ref> [Cri89, Cri91c, Cri91a, CM94] </ref>) we called such systems simply asynchronous, as opposed to the synchronous system model investigated in [CASD85, Cri91b, Cri93]. This has unfortunately caused some confusion, since other authors (e.g. [FLP85]) use the term `asynchronous system' with a different meaning.
Reference: [Cri91a] <author> F. Cristian. </author> <title> Asynchronous Atomic Broadcast. </title> <journal> IBM Technical Disclosure Bulletin, </journal> <volume> 33(9) </volume> <pages> 115-116, </pages> <month> Feb </month> <year> 1991. </year> <booktitle> Also presented at the First IEEE Workshop on Management of Replicated Data, </booktitle> <address> Houston, TX, </address> <month> (Nov </month> <year> 1990). </year>
Reference-contexts: We call a system of processors and communication services that satisfies the hypotheses listed above a timed asynchronous system. Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous. In previous publications (e.g. <ref> [Cri89, Cri91c, Cri91a, CM94] </ref>) we called such systems simply asynchronous, as opposed to the synchronous system model investigated in [CASD85, Cri91b, Cri93]. This has unfortunately caused some confusion, since other authors (e.g. [FLP85]) use the term `asynchronous system' with a different meaning. <p> As an example of a higher level application that needs a membership service satisfying (So), consider an atomic broadcast service that maintains consistent copies of the state of a team of servers by using a train broadcast protocol as described in <ref> [Cri91a] </ref>. The two round train protocol works as follows: A message called the "group train" circulates among group members in a manner similar to the attendance list discussed earlier. <p> In this way updates are never applied in transient, incomplete groups, and branches in the group history are not harmful, because they cannot lead to diverging local views on what the team state is. The two round train protocol achieves "strict consistency" <ref> [Cri91a] </ref> among the local copies of the team state, in that any two team members have at any time prefixes of the history of team updates applied so far. 10 Majority Group Membership Protocols 31 An alternative, stronger specification for a Majority Group Membership Service would not allow branching histories at
Reference: [Cri91b] <author> F. Cristian. </author> <title> Reaching Agreement on Processor-group Membership in Synchronous Distributed Systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year> <note> Early version: FTCS-18, 1988, Kyoto. </note>
Reference-contexts: 1 Introduction Most published distributed algorithms are described in terms of a fixed group of active processes that communicate through messages to achieve a certain goal. In real systems, however, such groups are dynamic, shrinking as failures occur, and growing as communication services and processes recover. An earlier paper <ref> [Cri91b] </ref> has specified and proposed several solutions to the processor group membership problem in synchronous distributed systems in which atomic broadcast guarantees timely communication between any pair of correct processors. Such communication certainty is achieved by using real-time executives to bound communication delays and massive redundancy to avoid physical partitioning. <p> We do not deal with the problem of implementing a process group membership service on top of a processor group membership service, since the solution discussed in <ref> [Cri91b] </ref> can be adapted to an asynchronous communication environment in a straightforward way. Our objective of specifying and solving the membership problem in the presence of communication uncertainty makes the problem much more complex than the synchronous case studied in [Cri91b]. <p> a processor group membership service, since the solution discussed in <ref> [Cri91b] </ref> can be adapted to an asynchronous communication environment in a straightforward way. Our objective of specifying and solving the membership problem in the presence of communication uncertainty makes the problem much more complex than the synchronous case studied in [Cri91b]. Indeed, when processes cannot distinguish between peer processor failures and communication failures, two correct processes which lose communication with each other may take conflicting actions if each assumes the failure of the other, as illustrated by the membership protocol of [Car85]. <p> Another key contribution is the description of a suite of five protocols for implementing the specified services and a description of how two of these services can be used to solve the highly available leadership problem <ref> [Cri91b] </ref>. All (necessarily ambiguous) English protocol descriptions are complemented by unambiguous formal protocol code in the appendix. <p> The appendix also contains proofs that all five protocols satisfy their respective specifications and that the two solutions given for solving the highly available leadership problem are correct. 2 Related Work According to [CHTCB96, ACBMT95], the membership problem was first defined for synchronous systems in <ref> [Cri91b] </ref>. Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95]. <p> Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous. In previous publications (e.g. [Cri89, Cri91c, Cri91a, CM94]) we called such systems simply asynchronous, as opposed to the synchronous system model investigated in <ref> [CASD85, Cri91b, Cri93] </ref>. This has unfortunately caused some confusion, since other authors (e.g. [FLP85]) use the term `asynchronous system' with a different meaning. <p> The main complication introduced by the history-dependent approach is the need for a group membership service. In addition to improving performance, such a service can achieve agreement on the history of groups that exist over time as well as on the membership of each group <ref> [Cri91b] </ref>. This allows users to order all failure and recoveries that occur in time, and contributes to simplify the programming of many higher level applications (see for example the synchronous and asynchronous availability management services described in [Cri93] and [CM94], respectively). <p> The second approach requires fewer messages and leads to faster failure detection. We used this approach in all our earlier synchronous membership protocols <ref> [Cri91b] </ref> and we will also use it in all the protocols of this paper. 5 Detecting System Changes 10 Now consider a system with n&gt;2 processors. <p> This message traffic can be reduced by observing that it is not necessary for all processors to independently detect the failure of another processor. The most message-economical way of doing this is to use either an attendance list or a neighbor surveillance protocol <ref> [Cri91b] </ref>. The attendance list protocol, which we adopt for all (except the first) algorithms of this paper, works as follows. Assume the system is currently stable and consider a physical partition S with more than one processor. <p> If any processor in S detects that the attendance list is lost or late, one of them may have failed. This failure detection method reduces the number of "I-am-alive" messages sent every time units from n (n 1) to n. In <ref> [Cri91b] </ref> this is proven to be the minimum number of messages that must be exchanged to detect member failures in a group with n members. 5.2 Detecting Recoveries Detecting recoveries is simpler than detecting failures. <p> The main difference between the above timeliness properties and those required from the synchronous membership protocols described in <ref> [Cri91b] </ref> is that synchronous protocols are required to detect failures and joins within a bounded delay independently of whether the system P is stable or not. In addition, a membership service should not report any "false" failures or recoveries. <p> As we will show in the next section, the protocol is also useful in implementing a service that is often needed to avoid the "split brain" behavior mentioned earlier: the highly available leadership service <ref> [Cri91b] </ref>. Despite its efficiency in handling single failures and recoveries, its possible use in avoiding the "split brain" behavior, and its power to solve the highly available leadership problem, the One Round Protocol has the following major disadvantages. <p> Thus, p 1 would be unaware that p 4 had failed and recovered. The protocols presented in subsequent sections of this paper will address these issues. 8 The Highly Available Leadership Problem As mentioned above, the One Round Protocol is also useful in implementing a highly available leadership service <ref> [Cri91b] </ref>. We can adapt the requirements proposed for this service in [Cri91b] to an asynchronous environment as follows. (Su) Uniqueness of Leader. At any point in time there is at most one leader. (Te) Bounded Election Delays. <p> The protocols presented in subsequent sections of this paper will address these issues. 8 The Highly Available Leadership Problem As mentioned above, the One Round Protocol is also useful in implementing a highly available leadership service <ref> [Cri91b] </ref>. We can adapt the requirements proposed for this service in [Cri91b] to an asynchronous environment as follows. (Su) Uniqueness of Leader. At any point in time there is at most one leader. (Te) Bounded Election Delays. <p> In a synchronous system, a highly available leadership protocol can be derived in a straightforward way from a membership protocol, by adding a rule for choosing a leader from the members of a group, for example, "the leader should be the processor with the highest id among group members" <ref> [Cri91b] </ref>. Since all processors joined to the same group agree on its membership, they will all agree on who the leader of the group is. <p> In the next two sections we will explore membership protocols that address this problem. 10 Majority Group Membership Protocols To force agreement on the order in which failures and recoveries occur in a team, <ref> [Cri91b] </ref> has proposed to build protocols that guarantee that any two correct processors will join identical sequences (or histories) of groups. <p> Since processors agree on the membership of each group, if they agree on a unique history, they can easily agree on the differences between the memberships of successive groups of the history. The synchronous membership protocols proposed in <ref> [Cri91b] </ref> all satisfy this property, which is named agreement on group histories. Unfortunately, in an asynchronous system two correct processors cannot always join the same groups, simply because there may be times when they are both correct but disconnected.
Reference: [Cri91c] <author> F. Cristian. </author> <title> Understanding Fault-Tolerant Distributed Systems. </title> <journal> Communications of ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: We assume a total order "&lt;" on the set of processor names P. We let p, q, r, . . . denote processors in P. We also assume that each processor has access to a private stable storage service. Processors have crash/performance failure semantics <ref> [Cri91c] </ref>. Performance failures include a processor being slow, as well as its clock running too slow or too fast. Crashes are partial-amnesia crashes: at restart, the state of stable storage is the same as before the crash, while the state of the volatile storage is reinitialized. <p> We call a system of processors and communication services that satisfies the hypotheses listed above a timed asynchronous system. Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous. In previous publications (e.g. <ref> [Cri89, Cri91c, Cri91a, CM94] </ref>) we called such systems simply asynchronous, as opposed to the synchronous system model investigated in [CASD85, Cri91b, Cri93]. This has unfortunately caused some confusion, since other authors (e.g. [FLP85]) use the term `asynchronous system' with a different meaning. <p> The idea is certainly appealing at first glance, but we do not believe it works for practical systems which have (usually) more than two levels of abstraction. Indeed, all the multi-layer systems we know employ timeouts at each abstraction level, because a level that depends <ref> [Cri91c] </ref> on another level must be able to detect and mask by its own means the possible failures of the lower level. In general the timeouts used at different levels are different: the higher the level the larger the timeout. <p> Since the main goal of using server groups is to mask processor failures <ref> [Cri91c] </ref>, when p cannot communicate with q it will have to adopt the only decision that will allow it to mask a real failure of q, which is to proceed as if q had failed.
Reference: [Cri93] <author> F. Cristian. </author> <title> Automatic Reconfiguration in the Presence of Failures. </title> <journal> Software Engineering Journal, </journal> <pages> pages 53-60, </pages> <month> Mar </month> <year> 1993. </year>
Reference-contexts: Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous. In previous publications (e.g. [Cri89, Cri91c, Cri91a, CM94]) we called such systems simply asynchronous, as opposed to the synchronous system model investigated in <ref> [CASD85, Cri91b, Cri93] </ref>. This has unfortunately caused some confusion, since other authors (e.g. [FLP85]) use the term `asynchronous system' with a different meaning. <p> This allows users to order all failure and recoveries that occur in time, and contributes to simplify the programming of many higher level applications (see for example the synchronous and asynchronous availability management services described in <ref> [Cri93] </ref> and [CM94], respectively). <p> Since the protocol can cause processors to miss certain events of interest and to disagree on the order in which events occur, the One Round protocol is not suitable for sophisticated applications such as system availability management <ref> [Cri93, CM94] </ref>. The Three Round Protocol with Partition Notification stabilizes faster after multiple failures and recoveries and provides a faster promotion time for the continuous leadership problem, at the expense of using 3n messages instead of n for group creation.
Reference: [DHS86] <author> D. Dolev, J. Y. Halpern, and R. </author> <title> Strong. On the Possibility and Impossibility of Achieving Clock Synchronization. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 230-250, </pages> <year> 1986. </year>
Reference-contexts: are random, processor and communication failures occur at random times unknown in advance, and clocks can drift from real-time at actual rates that are unknown to processors, it is not realistic to require that connected processors agree on membership at the same real-time, since exact synchronization between processors is precluded <ref> [DHS86] </ref>. Even though such agreement is impossible, some form of agreement on which processors are up and connected is required for programming applications such as the availability manager example discussed previously.
Reference: [DLS88] <author> C. Dwork, N. Lynch, and L. Stockmeywer. </author> <title> Consensus in the Presence of Partial Synchrony. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 288-323, </pages> <year> 1988. </year>
Reference-contexts: Because of the low processor and communication failure (and hence recovery) rates likely to be observed in practice, a well-tuned asynchronous system is likely to alternate between long stability periods and comparatively short instability intervals. The above stability condition is similar to the global stabilization requirement of <ref> [DLS88] </ref> that was proven sufficient for solving consensus.
Reference: [DMS94] <author> D. Dolev, D. Malki, and R. </author> <title> Strong. An Asynchronous Membership Protocol that Tolerates Partitions. </title> <type> Technical Report CS94-6, </type> <institution> Computer Science Department, The Hebrew University of Jerusalem, Israel, </institution> <year> 1994. </year>
Reference-contexts: Thus, partitionable membership services resemble our `one-round' and `three-round with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in [ACBMT95], the most widely-cited papers [RB91] and <ref> [DMS94] </ref> that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by <p> most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of <ref> [DMS94, DMS95] </ref> can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified by the authors.
Reference: [DMS95] <author> D. Dolev, D. Malki, and R. </author> <title> Strong. A Framework for Partionable Membership Services. </title> <type> Technical Report CS95-4, </type> <institution> Computer Science Department, The Hebrew University of Jerusalem, Israel, </institution> <year> 1995. </year>
Reference-contexts: services resemble our `one-round' and `three-round with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in [ACBMT95], the most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions <ref> [Ric93, RB95, DMS95] </ref>, contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified <p> most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of <ref> [DMS94, DMS95] </ref> can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified by the authors.
Reference: [EMS95] <author> P. Ezhilchelvan, R. Macedo, and S. Shrivastava. Newtop: </author> <title> a Fault-Tolerant Group Communication Protocol. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Systems, </booktitle> <address> Vancouver, Canada., </address> <month> May </month> <year> 1995. </year> <note> 11 Conclusion 36 </note>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership <ref> [ADKM92, JFR93, vRBM96, BBDG94, EMS95] </ref>. Some of these membership services explicitly assume a time-free underlying system model (e.g., [RB91, MPS92, HS95, BBDG94]), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model.
Reference: [FC96] <author> C. Fetzer and F. Cristian. </author> <title> Fail-Aware Failure Detectors. </title> <booktitle> In Proceedings of the 15th Symposium on Reliable Distributed Systems, </booktitle> <address> Niagara-on-the-Lake, Canada, </address> <month> Oct </month> <year> 1996. </year>
Reference-contexts: For example, one open question is which failure detectors are implementable in the timed model and which are not. So far, we have proven that a Perfect failure detector is not implementable in a timed system <ref> [FC96] </ref>. Another difference between the two models is more of system design philosophy. Failure detectors aim at hiding from higher levels of abstraction the time-related aspects of a fault-tolerant distributed computation, such as the detection of failures, so that these higher levels do not have to use timeouts.
Reference: [FLP85] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of Distributed Consensus with One Faulty Process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> Apr </month> <year> 1985. </year>
Reference-contexts: The resulting system behavior, known as "split brains" behavior in Tandem terminology [Car90], can result in total system crashes. We begin by defining what we mean by an asynchronous system and its likely failures. While the asynchronous system model used in the theory community <ref> [FLP85] </ref> has no notion of time, our system model assumes that processors have local clocks that allow them to measure the passage of time. To avoid confusion, we refer to the system model of [FLP85] as the time-free asynchronous system model and we call our model the timed asynchronous system model. <p> While the asynchronous system model used in the theory community <ref> [FLP85] </ref> has no notion of time, our system model assumes that processors have local clocks that allow them to measure the passage of time. To avoid confusion, we refer to the system model of [FLP85] as the time-free asynchronous system model and we call our model the timed asynchronous system model. Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous as captured by our definition. <p> Most existing distributed systems based on non-real-time operating systems and communication services, such as Unix and UDP, are timed asynchronous as captured by our definition. The introduction of the timed asynchronous system model, and its comparison to the time-free asynchronous system model discussed in <ref> [FLP85] </ref> are key contributions of our paper. We then proceed by presenting a sequence of five increasingly strong specifications for processor membership in timed asynchronous systems and comment on how they can be used in 2 Related Work 3 practice by different higher level applications. <p> In previous publications (e.g. [Cri89, Cri91c, Cri91a, CM94]) we called such systems simply asynchronous, as opposed to the synchronous system model investigated in [CASD85, Cri91b, Cri93]. This has unfortunately caused some confusion, since other authors (e.g. <ref> [FLP85] </ref>) use the term `asynchronous system' with a different meaning. The difference comes from the fact that the processor and communication services of interest to us are timed, while the processor and communication services investigated in [FLP85] are time-free. Indeed, the service specifications considered in [FLP85] are independent of any notion <p> This has unfortunately caused some confusion, since other authors (e.g. <ref> [FLP85] </ref>) use the term `asynchronous system' with a different meaning. The difference comes from the fact that the processor and communication services of interest to us are timed, while the processor and communication services investigated in [FLP85] are time-free. Indeed, the service specifications considered in [FLP85] are independent of any notion of time: they specify, for each state and input only the next state and output to be produced without imposing any constraint on the real-time it will take that state transition and output to occur. <p> confusion, since other authors (e.g. <ref> [FLP85] </ref>) use the term `asynchronous system' with a different meaning. The difference comes from the fact that the processor and communication services of interest to us are timed, while the processor and communication services investigated in [FLP85] are time-free. Indeed, the service specifications considered in [FLP85] are independent of any notion of time: they specify, for each state and input only the next state and output to be produced without imposing any constraint on the real-time it will take that state transition and output to occur.
Reference: [Gif79] <author> D. K. Gifford. </author> <title> Weighted Voting for Replicated Data. </title> <booktitle> In Proceedings of the Seventh Symposium on Operating Systems Principles, </booktitle> <pages> pages 150-162, </pages> <address> Pacific Grove, CA, </address> <month> Dec </month> <year> 1979. </year>
Reference-contexts: A well known example of a history independent approach is voting <ref> [Gif79] </ref>. To service an update request in a replicated implementation based on voting, p will attempt to communicate with both q and r, even when its last n consecutive attempts at communicating with q or r were unsuccessful.
Reference: [HS95] <author> M. Hiltunen and R. Schlichting. </author> <title> Properties of Membership Services. </title> <booktitle> In Proc. 2d Int. Symp. on Autonomous Decentralized Systems, </booktitle> <address> Phoeniz, AZ, </address> <month> Apr </month> <year> 1995. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership <ref> [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] </ref> and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95]. <p> Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95]. Some of these membership services explicitly assume a time-free underlying system model (e.g., <ref> [RB91, MPS92, HS95, BBDG94] </ref>), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model.
Reference: [JFR93] <author> F. Jahanian, S. Fakhouri, and R Rajkumar. </author> <title> Processor Group Membership Protocols: Specification, </title> <booktitle> Design and Implementation. In Proc. 12th Symposium on Reliable Distributed Systems, </booktitle> <month> Oct </month> <year> 1993. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership <ref> [ADKM92, JFR93, vRBM96, BBDG94, EMS95] </ref>. Some of these membership services explicitly assume a time-free underlying system model (e.g., [RB91, MPS92, HS95, BBDG94]), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model.
Reference: [KB91] <author> P. Stevenson K. Birman, A. Schiper. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Some systems (for example Isis <ref> [KB91] </ref>) solve this problem by associating an incarnation number with every member of a group. This number is incremented each time a processor recovers from a crash.
Reference: [KT91] <author> F. Kaashoek and A. Tanenbaum. </author> <title> Group Communication in the Amoeba Distributed System. </title> <booktitle> In Proc. 11th Int. Conf. on Distributed Computing Systems, </booktitle> <pages> pages 222-230, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership <ref> [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] </ref> and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95].
Reference: [MFSW95] <author> C. P. Malloth, A. Fehler, A. Schiper, and U. Wilhelm. </author> <title> Phoenix: a Toolkit for Building Fault-Tolerant Distributed Aplications in Large-Scale Networks. </title> <booktitle> In Proc. of IEEE Workshop on Parallel and Distributed Platforms in Industrial Products, </booktitle> <address> San Antonio, TX, </address> <month> Oct </month> <year> 1995. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership <ref> [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] </ref> and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95].
Reference: [MPS92] <author> S. Mishra, L. Peterson, and R. Schlichting. </author> <title> A Membership Protocol Based on Partial Order. </title> <editor> In J. F. Meyer and R. D. Schlichting, editors, </editor> <booktitle> Dependable Computing for Critical Applications 2, </booktitle> <pages> pages 309-331. </pages> <publisher> Springer-Verlag, Wien, </publisher> <year> 1992. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership <ref> [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] </ref> and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95]. <p> Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95]. Some of these membership services explicitly assume a time-free underlying system model (e.g., <ref> [RB91, MPS92, HS95, BBDG94] </ref>), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model.
Reference: [MSPMA94] <author> L. E. Melliar-Smith P. M., Moser and V. Agrawala. </author> <title> Processor Membership in Asynchronous Distributed Systems. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 5(5) </volume> <pages> 459-473, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership <ref> [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] </ref> and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95].
Reference: [Nei96] <author> G. Neiger. </author> <title> A New Look at Membership Services. </title> <booktitle> In 15th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 331-340, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership <ref> [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] </ref> and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95].
Reference: [RB91] <author> A. Ricciardi and K. Birman. </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> In 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Canada, </address> <month> Aug </month> <year> 1991. </year> <note> 11 Conclusion 37 </note>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership <ref> [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] </ref> and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95]. <p> Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership [ADKM92, JFR93, vRBM96, BBDG94, EMS95]. Some of these membership services explicitly assume a time-free underlying system model (e.g., <ref> [RB91, MPS92, HS95, BBDG94] </ref>), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model. <p> Thus, partitionable membership services resemble our `one-round' and `three-round with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in [ACBMT95], the most widely-cited papers <ref> [RB91] </ref> and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be <p> with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in [ACBMT95], the most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: <ref> [RB91, Ric93, RB95] </ref> have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified by the authors.
Reference: [RB95] <author> A. Ricciardi and K. Birman. </author> <title> Process Membership in Asynchronous Environments. </title> <type> Technical report, </type> <institution> Computer Science Depmt, Cornell University, </institution> <year> 1995. </year> <note> Available via anonymous ftp from ftp.sc.cornell.edu as /pub/team/asyncmembership.ps.Z. </note>
Reference-contexts: services resemble our `one-round' and `three-round with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in [ACBMT95], the most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions <ref> [Ric93, RB95, DMS95] </ref>, contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified <p> with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in [ACBMT95], the most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: <ref> [RB91, Ric93, RB95] </ref> have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified by the authors. <p> and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of <ref> [RB95] </ref> allow certain executions that violate the safety and liveness requirements specified by the authors. The existence of such faults in widely cited research articles should be taken as an indication of how difficult the problem of specifying and implementing asynchronous membership services really is.
Reference: [Ric93] <author> A. Ricciardi. </author> <title> The Group Membership Problem in Asynchronous Systems. </title> <type> PhD Thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1993. </year>
Reference-contexts: services resemble our `one-round' and `three-round with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in [ACBMT95], the most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions <ref> [Ric93, RB95, DMS95] </ref>, contain specification faults: [RB91, Ric93, RB95] have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified <p> with partition detection' membership services. 3 Timed Asynchronous System Model 4 As pointed out in [ACBMT95], the most widely-cited papers [RB91] and [DMS94] that attempt to give formal specifications for the primary partition and partitionable asynchronous membership services, as well as their updated versions [Ric93, RB95, DMS95], contain specification faults: <ref> [RB91, Ric93, RB95] </ref> have flaws in their logical formalism and allow undesirable executions while the specification of [DMS94, DMS95] can be satisfied by trivial, useless protocols. [ACBMT95] also shows that the protocols of [RB95] allow certain executions that violate the safety and liveness requirements specified by the authors.
Reference: [SSCA87] <author> R. Strong, D. Skeen, F. Cristian, and H. Aghili. </author> <title> Handshake Protocols. </title> <booktitle> In Proceedings of the Seventh International Conference on Distributed Computing Systems, </booktitle> <pages> pages 521-528, </pages> <address> Berlin, </address> <month> Sep </month> <year> 1987. </year>
Reference-contexts: For example, if the operations implemented by team members are inserts in a set, f can be the union of the sets s' and s". If the operations are not commutative, for example both inserts and deletes are allowed, then a conflict detection/resolution rule such as those described in <ref> [SSCA87] </ref> must be considered when defining the merge function f . Note that for the logical partition notification mechanism to be useful, a membership protocol must create new groups only "when necessary".
Reference: [vRBM96] <author> R. van Renesse, K. Birman, and S. Mafeis. Horus: </author> <title> a Flexible Group Communication System. </title> <journal> CACM, </journal> <volume> 39(5) </volume> <pages> 76-83, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Since then this problem has also been subject of intense investigation for asynchronous systems. Two types of asynchronous membership services have been described: primary-partition membership [RB91, KT91, MPS92, MSPMA94, HS95, MFSW95, Nei96] and partitionable membership <ref> [ADKM92, JFR93, vRBM96, BBDG94, EMS95] </ref>. Some of these membership services explicitly assume a time-free underlying system model (e.g., [RB91, MPS92, HS95, BBDG94]), while for others it is not entirely clear whether the underlying system model is time-free or some variant of our timed system model.
References-found: 36

