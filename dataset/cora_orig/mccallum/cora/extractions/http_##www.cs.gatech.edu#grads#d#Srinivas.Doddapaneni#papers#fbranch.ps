URL: http://www.cs.gatech.edu/grads/d/Srinivas.Doddapaneni/papers/fbranch.ps
Refering-URL: http://www.cs.gatech.edu/grads/d/Srinivas.Doddapaneni/pubs.html
Root-URL: 
Title: Hoisting Branch Conditions Improving Super-Scalar Processor Performance  
Author: Bill Appelbe Sri Doddapaneni Reid Harmon Phil May Scott Wills and Maurizio Vitale 
Address: Atlanta, GA 30332  
Affiliation: 1 College of Computing 2 School of Electrical and Computer Engineering Georgia Institute of Technology,  
Abstract: The performance and hardware complexity of super-scalar architectures is hindered by conditional branch instructions. When conditional branches are encountered in a program, the instruction fetch unit must rapidly predict the branch predicate and begin speculatively fetching instructions with no loss of instruction throughput. Speculative execution has a high hardware cost, is limited by dynamic branch prediction accuracies, and does not scale well for increasingly super-scalar architectures. The conditional branch bottleneck would be solved if we could somehow move branch condition evaluation far forward in the instruction stream and provide a new branch instruction that encoded both the source and target address of a branch. This paper summarizes the hardware extensions to support just such a Future Branch, then gives a compiler algorithm for hoisting branch evaluation across many blocks. The algorithm is applicable to other optimizations for parallelism, such as prefetching data.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A. V., Sethi, R., and Ullman, J. D. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: For the current PowerPC 604 die, this future branch implementation would occupy just 3.3% of the die area. 4 Compiler Algorithms for Hoisting Branches Compiling for future branches reduces to the following problem: given a branch instruction br, can we hoist <ref> [1, page 714] </ref> this instruction so that at least N PIPELINE instructions lie between the execution of the future branch and its target. The value of N PIPELINE is chosen so to "almost guarantee" 7 that the future branch instruction will have completed before the branch target is reached. <p> The standard algorithm for hoisting evaluation of an expression is to find a point at which an expression is very busy <ref> [1, page 713] </ref> (the operands of the expression are not subsequently defined). In practice, this needs to be modified for hoisting branches, as a branch may need to hoisted to more than one location. <p> For branch statements that are based upon condition codes, the condition code is an anonymous variable used by the branch, and set by prior statements. Algorithms for determining domination and availability are well known <ref> [1] </ref>. We have had to strengthen the definition of dominance so that the future branch is always at the same loop level as the branch source itself. Also, a future branch can only be issued once (otherwise there will be two future branches pending for the same jump).
Reference: 2. <author> Appelbe, B., Doddapaneni, S., Harmon, R., May, P., Wills, S., and Vitale, M. </author> <title> Future branches beyond speculative execution. </title> <note> In Micro-28 ((submitted)). </note>
Reference-contexts: to hold pending future branches, as they are not necessarily issued in the order that they are taken 4 There is no indication in the object code, at the branch source, that this is the source of a branch! It is possible to implement future branches that are purely advisory <ref> [2] </ref>, but this has a high space overhead. 5 By context switches, we mean process context switches rather than procedure calls 3 Future Branch Hardware An obvious question is whether 16 bits, the usual field size for a branch target, is enough to encode both the source and target address for <p> Hence both the relative source and target address can be encoded in the usual 16 bit displacement 6 The implementation of future branches for the 604 is given in detail in Ap-pelbe et al <ref> [2] </ref>. Intuitively, the hardware maintains a future branch cache, of pending future branches. When the program counter is advanced to fetch instructions, it is compared against branch source addresses in the future branch cache.
Reference: 3. <author> Duvvuru, S., and Arya, S. </author> <title> Evaluation of a Branch Target Address Cache. </title>
Reference-contexts: 1 Introduction Studies have shown that from 1.6% to 22% of instructions executed are branches or conditional branches <ref> [3] </ref>, with most non-scientific programs much closer to 22%. A branch instruction interrupts the instruction pipeline unless the branch target address is known before the branch instruction is decoded, and the direction of a conditional branch is known.
Reference: 4. <author> Goodman, J. R., Hseih, J. T., Liou, K., Pleszkun, A. R., Schechter, P., and Young, H. C. </author> <title> "pipe: A vlsi decoupled architecture". </title> <booktitle> In Proceedings of The Twelfth Annual Symposium on Computer Architecture (1989), </booktitle> <pages> pp. 20-27. </pages>
Reference-contexts: The idea of decoupling the branch decision from the branch itself has been used in many architectures, ranging from those which have separate instructions for computing the branch condition to branch instructions with a variable number of delay slots <ref> [4] </ref>. However, these all have the limitation that the path and number of instructions executed between the computation of a branch condition and the branch itself is fixed and must be known at compile time.
Reference: 5. <author> Gupta, R. </author> <title> Generalized dominators and post-dominators. </title> <booktitle> In Principles of Programming Languages (San Francisco, </booktitle> <address> California, </address> <year> 1992), </year> <note> p. 246. </note>
Reference-contexts: one and only one of the points in fp 0 ; p 1 ; :::p N g . 9 8 Instruction scheduling must be aware of future branches, to try to ensure that no stalls occur due to a future branch that is still in the instruction pipeline 9 Gupta <ref> [5] </ref>, introduced generalized dominators: a set of nodes that dominate a point p. However, our strong dominators are "stronger", as we require uniqueness, and consider paths from p to itself.
Reference: 6. <author> Hennessy, J. L., and Patterson, D. A. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: We have designed hardware implementations for the Motorola 88010 [7], the Power PC 604 [8], and the DLX <ref> [6] </ref>. Future branches bear some superficial similarity to delay slots [6, page 269]: instructions following a branch that are always executed. However, in practice it is hard to fill more than a couple of delay slots, and modern super-scalar microprocessors rely on speculative execution instead of delay slots. <p> We have designed hardware implementations for the Motorola 88010 [7], the Power PC 604 [8], and the DLX [6]. Future branches bear some superficial similarity to delay slots <ref> [6, page 269] </ref>: instructions following a branch that are always executed. However, in practice it is hard to fill more than a couple of delay slots, and modern super-scalar microprocessors rely on speculative execution instead of delay slots. <p> Modify a production quality C compiler to perform program transformations and code generation for future branches 3. Systematic benchmarking, using standard large-scale benchmark programs. These efforts are underway, and the results are encouraging. 5.1 Micro-Architecture Simulator We have acquired a micro-architecture simulator, for the DLX instruction-set <ref> [6] </ref>, from McGill university. The simulator is reconfigurable, and supports speculative execution. We have modifying it to support future branch instructions and instrumentation for these. We have extended the SuperDLX architecture and implementation in several ways, primarily by including support for future branches.
Reference: 7. <author> Sector, M. S. P. </author> <title> MC88110 Second Generation RISC Microprocessor Users Manual. Motorola, </title> <publisher> Inc., </publisher> <address> Phoenix, Arizona, </address> <year> 1991. </year>
Reference-contexts: To be able to predict whether data will be needed, we need to be able to hoist branch decisions. 2 Future Branch Architecture Future branch instructions are applicable as extensions to almost any instruction set. We have designed hardware implementations for the Motorola 88010 <ref> [7] </ref>, the Power PC 604 [8], and the DLX [6]. Future branches bear some superficial similarity to delay slots [6, page 269]: instructions following a branch that are always executed.
Reference: 8. <author> Song, S. P., and Denman, M. </author> <title> The PowerPC 604 Microprocessor. </title> <booktitle> IEEE Micro (October 1994), </booktitle> <pages> 8-17. </pages>
Reference-contexts: A branch instruction interrupts the instruction pipeline unless the branch target address is known before the branch instruction is decoded, and the direction of a conditional branch is known. Branch caches enable the branch target address to be determined with fairly high probability at a modest hardware cost <ref> [8] </ref>. By contrast, determining the direction of a conditional branch is far more difficult. The most common technique is speculative execution, in which the direction of the branch is predicted either statically (a bit in the branch instruction) or dynamically (using a cache of previous branch directions). <p> Most modern microprocessors use dynamic prediction. Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracy of around 90% (e.g., Ultra SPARC [10]: SPECint 88%, SPECfloat 94% [10]; Power 620 <ref> [8] </ref>: SPEC composite 90% [9]). Our simulation studies have shown that a fundamental problem with speculative execution is that the overhead of wasted cycles, due to incorrect prediction limits processor throughput, even assuming no data dependencies and unlimited functional units. <p> To be able to predict whether data will be needed, we need to be able to hoist branch decisions. 2 Future Branch Architecture Future branch instructions are applicable as extensions to almost any instruction set. We have designed hardware implementations for the Motorola 88010 [7], the Power PC 604 <ref> [8] </ref>, and the DLX [6]. Future branches bear some superficial similarity to delay slots [6, page 269]: instructions following a branch that are always executed.
Reference: 9. <author> Thompson, T., and Ryan, B. </author> <title> PowerPC 620 Soars. </title> <journal> BYTE (November 1994), </journal> <pages> 113-120. </pages>
Reference-contexts: Most modern microprocessors use dynamic prediction. Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracy of around 90% (e.g., Ultra SPARC [10]: SPECint 88%, SPECfloat 94% [10]; Power 620 [8]: SPEC composite 90% <ref> [9] </ref>). Our simulation studies have shown that a fundamental problem with speculative execution is that the overhead of wasted cycles, due to incorrect prediction limits processor throughput, even assuming no data dependencies and unlimited functional units. Intuitively, conditional branches present a seemingly insuperable bottleneck to increasing superscalarity.
Reference: 10. <author> Wayner, P. </author> <title> SPARC Strikes Back. BYTE (November 1994), 105-112. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Most modern microprocessors use dynamic prediction. Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracy of around 90% (e.g., Ultra SPARC <ref> [10] </ref>: SPECint 88%, SPECfloat 94% [10]; Power 620 [8]: SPEC composite 90% [9]). Our simulation studies have shown that a fundamental problem with speculative execution is that the overhead of wasted cycles, due to incorrect prediction limits processor throughput, even assuming no data dependencies and unlimited functional units. <p> Most modern microprocessors use dynamic prediction. Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracy of around 90% (e.g., Ultra SPARC <ref> [10] </ref>: SPECint 88%, SPECfloat 94% [10]; Power 620 [8]: SPEC composite 90% [9]). Our simulation studies have shown that a fundamental problem with speculative execution is that the overhead of wasted cycles, due to incorrect prediction limits processor throughput, even assuming no data dependencies and unlimited functional units. <p> Hence, we need an algorithm which can hoist the calculation condition as well as the branch. We need to be able to hoist all statements that contribute to the calculation, while preserving all dependences. Consider the following artificial example: int sum = 0; int list <ref> [10] </ref> for (; i&lt;10; ++i) - if (list [i]) - sum += list [i]; ++i; return sum; - Example 2 We want to hoist the increment of i, test i&lt;10, and future branch to the beginning of the loop iteration 10 .
References-found: 10

