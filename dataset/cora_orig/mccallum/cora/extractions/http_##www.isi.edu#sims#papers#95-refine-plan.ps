URL: http://www.isi.edu/sims/papers/95-refine-plan.ps
Refering-URL: http://www.isi.edu/~knoblock/
Root-URL: 
Title: Planning as Refinement Search: A Unified Framework for Evaluating Design Tradeoffs in Partial-Order Planning  
Author: Subbarao Kambhampati Craig A. Knoblock Qiang Yang 
Address: Tempe, AZ 85287-5406  4676 Admiralty Way, Marina del Rey, CA 90292  Canada N2L 3G1  
Affiliation: Department of Computer Science and Engineering, Arizona State University,  Information Sciences Institute and Department of Computer Science, University of Southern California,  University of Waterloo, Computer Science Department, Waterloo, Ont.  
Abstract: Despite the long history of classical planning, there has been very little comparative analysis of the performance tradeoffs offered by the multitude of existing planning algorithms. This is partly due to the many different vocabularies within which planning algorithms are usually expressed. In this paper we show that refinement search provides a unifying framework within which various planning algorithms can be cast and compared. Specifically, we will develop refinement search semantics for planning, provide a generalized algorithm for refinement planning, and show that planners that search in the space of (partial) plans are specific instantiations of this algorithm. The different design choices in partial order planning correspond to the different ways of instantiating the generalized algorithm. We will analyze how these choices affect the search-space size and refinement cost of the resultant planner, and show that in most cases they trade one for the other. Finally, we will concentrate on two specific design choices, viz., protection strategies and tractability refinements, and develop some hypotheses regarding the effect of these choices on the performance on practical problems. We will support these hypotheses with a series of focused empirical studies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.A. Ambros-Ingerson and S. Steel. </author> <title> Integrating Planning, Execution and Monitoring. </title> <booktitle> In Proc. 7th AAAI, </booktitle> <year> 1988. </year>
Reference-contexts: The PTCs are examples of non-monotonic auxiliary constraints. To see this, consider the operator sequence S : o 1 o 2 . S fails to satisfy the PTC hr@t 1 i of P E (Figure 4) with respect to the mapping M = ft 1 ! S <ref> [1] </ref>; t 2 ! S [2]g. <p> Thus S is a candidate of the partial plan P E . S is however not a minimal candidate since the sequence S 0 : o 1 o 2 is also a candidate of P E (with the mapping function M = ft 1 ! S <ref> [1] </ref>; t 2 ! S [2]g), and S 0 can be obtained by removing elements from S. It can be easily verified that S 0 is a minimal candidate. <p> Figure 6 illustrates P ; and A ; . 13 As noted earlier, the candidate 12 An important exception is the hierarchical task reduction planners, such as SIPE [40], IPEM <ref> [1] </ref> and O-Plan [5]. However, see [17] for a discussion of how Refine-Plan can be extended to cover these planners. 13 Alert readers may note that there is some overlap between the agenda, and the definition of PTCs.
Reference: [2] <author> A. Barrett and D. Weld. </author> <title> Partial Order Planning: Evaluating Possible Efficiency Gains. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 67, No. 1, </volume> <year> 1994. </year>
Reference-contexts: We will 2 The work of Barrett and Weld <ref> [2] </ref> as well as Minton et al. [26,27] are certainly steps in the right direction. However, they do not tell the full story since the comparison there was between a specific partial order and total order planner. The comparison between different partial order planners itself is still largely unexplored. <p> It can also be verified that the IPC would not be 14 Fig. 5. The relation between the various types of auxiliary constraints satisfied with respect to a different mapping, M 0 = ft 1 ! S <ref> [2] </ref>; t 2 ! S [6]g (since S [3] = o 3 deletes p). <p> Constructor Goal Selection Bookkeeping Tractability Refinements Existing Planners TWEAK [3] MTC-based O 4 ) MTC-based O 4 ) None None UA MTC-based O 2 ) MTC-based O 2 ) None Unambiguous ordering Nonlin [39] (Q&A) based Arbitrary O Interval & Goal Protection Conflict Resolution TOCL <ref> [2] </ref> Protection based O Arbitrary O Contributor protection Total ordering Pedestal [23] Protection based O Arbitrary O Interval Protection Total ordering SNLP [24] Protection based Arbitrary Contributor protection Conflict resolution UCPOP [33] (1) (1) MP-I Protection based Arbitrary (Multi) contributor protection Conflict resolution Hybrid Planners (described in Section 5.2) SNLP-UA MTC <p> Further, some implementations of SNLP, such as the popular one by Barrett and Weld <ref> [2] </ref> do conflict resolution one threat per iteration (invocation of Refine-Plan). <p> A third domain that we used in some of our experiments is ART-MD, which is a variant of ART-MD-RD, where the actions do not have hf and he in their preconditions and effects. (ART-MD is identical to the D 1 S 1 domain used in Barret et al.'s experiments <ref> [2] </ref>.) 8.2 Evaluation of Hypotheses about Tractability refinements To evaluate our hypotheses about the effect of tractability refinements on performance (see Hypotheses 1, 2 and 3 in Section 7.1), we conducted two separate experiments: one with the problems from ART-# est -# clob domain and the other with the problems from <p> CPU Time (b) Number Unsolved Fig. 17. Plot showing the effect of misdirection on protection strategies 8.3.2 Misdirection Experiment In this experiment, we compared TWEAK and SNLP-MTC in ART-MD, a variant of ART-MD-RD domain without the hf =he conditions (similar to D m S 1 domain described in <ref> [2] </ref>). Both planners were started off with a mingoals heuristic [27], which ranks a partial plan by the number of preconditions that are not necessarily true according to MTC. <p> As we mentioned earlier, much of the previous work has concentrated on comparing partial order and total order planners. Two representative efforts of this line of research are those of Barrett and Weld <ref> [2] </ref> and Minton et al. [26,27]. Barrett and Weld [2] compare the performance of two plan-space (SNLP and TOCL, in Table 1), and a state-space planner (TOPI), and develop hypotheses regarding the relative performance of these planners. <p> As we mentioned earlier, much of the previous work has concentrated on comparing partial order and total order planners. Two representative efforts of this line of research are those of Barrett and Weld <ref> [2] </ref> and Minton et al. [26,27]. Barrett and Weld [2] compare the performance of two plan-space (SNLP and TOCL, in Table 1), and a state-space planner (TOPI), and develop hypotheses regarding the relative performance of these planners.
Reference: [3] <author> D. Chapman. </author> <title> Planning for conjunctive goals. </title> <journal> Artificial Intelligence, </journal> <volume> 32:333--377, </volume> <year> 1987. </year>
Reference-contexts: Section 4 describes the generalized refinement planning algorithm, Refine-Plan, discusses its various components, and shows how the various ways of instantiating the component steps correspond to the various design choices for partial-order planning. Section 5 shows how the existing plan-space planners, including TWEAK <ref> [3] </ref>, SNLP [24], UA [27] and Nonlin [39] can be seen as instantiations of Refine-Plan. It also discusses how Refine-Plan can be instantiated to give rise to a variety of new planning algorithms with interesting tradeoffs. <p> It can also be verified that the IPC would not be 14 Fig. 5. The relation between the various types of auxiliary constraints satisfied with respect to a different mapping, M 0 = ft 1 ! S [2]; t 2 ! S [6]g (since S <ref> [3] </ref> = o 3 deletes p). <p> The PTC hr@t 1 i is satisfied by S with respect to M since S <ref> [3] </ref> = o 3 adds r and S [4] = o 1 does not delete r. It can be verified that the other two PTCs are also satisfied by S. <p> When this happens, k-sol will also terminate with success on that partial plan. Further, k-sol is guaranteed to terminate the search before All-sol. The termination criteria of All-sol correspond closely to the notion of necessary correctness of a partially ordered plan, first introduced by Chapman <ref> [3] </ref>. Existing planning systems implement All-sol in two different ways: Planners such as Chapman's TWEAK [3,42] use the modal truth criterion to explicitly check that all the safe ground linearizations correspond to solutions (we will call these the MTC-based constructors). <p> When this is done, it is easy to see that all the minimal candidates of the resulting plan will satisfy the PTC hc@si (Section 3.4.2). Different refinements correspond to different steps acting as contributors of c to s. Chapman <ref> [3] </ref> and Pednault [29] provide theories of sound and complete establishment refinement. <p> Constructor Goal Selection Bookkeeping Tractability Refinements Existing Planners TWEAK <ref> [3] </ref> MTC-based O 4 ) MTC-based O 4 ) None None UA MTC-based O 2 ) MTC-based O 2 ) None Unambiguous ordering Nonlin [39] (Q&A) based Arbitrary O Interval & Goal Protection Conflict Resolution TOCL [2] Protection based O Arbitrary O Contributor protection Total ordering Pedestal [23] Protection based O <p> used to select the particular precondition hc; si to be established, (called the goal selection strategy) can be arbitrary, can depend on some ranking based on precondition abstraction [18,34], and/or demand driven (e.g. select a goal only when it is not already necessarily true according to the modal truth criterion <ref> [3] </ref>). <p> Chapman's TWEAK <ref> [3] </ref> is such a planner. However, such a planner is not guaranteed to respect its previous establishment decisions while making new ones, and thus may have a high degree of redundancy. <p> correspond to some well-known existing partial-order planners and then (in Section 5.2) discuss some instantiations of Refine-Plan 34 that have not been previously discussed in the literature. 5.1 Existing Planners In this section we will discuss the instantiations of Refine-Plan corresponding to four well-known planners: SNLP [24], McNONLIN [39], TWEAK <ref> [3] </ref> and UA [27]. <p> Thus it neither uses the bookkeeping step, nor the conflict resolution step. Further, the standard formulation of the TWEAK algorithm <ref> [3] </ref> uses the modal truth criterion (MTC) for goal selection as well as termination. In particular, MTC is used to check if a given precondition hC; si 2 A is necessarily true in the plan. <p> s 0 that interacts with s add , either add the order s 0 s add or the ordering s add s 0 . (Both orderings need to be considered for completeness). 28 It is instructive to note that our formulation of TWEAK is not completely in correspondence with Chapman's <ref> [3] </ref> initial characterization of the algorithm. In particular, Chapman suggests that planning be done by inverting the modal truth criterion. Among other things, this involves using the so-called ``white-knight declobbering' clause during establishment.
Reference: [4] <author> G. Collins and L. Pryor. </author> <title> Achieving the functionality of filter conditions in partial order planner. </title> <booktitle> In Proc. 10th AAAI, </booktitle> <year> 1992. </year>
Reference-contexts: The PTC hr@t 1 i is satisfied by S with respect to M since S [3] = o 3 adds r and S <ref> [4] </ref> = o 1 does not delete r. It can be verified that the other two PTCs are also satisfied by S.
Reference: [5] <author> K. Currie and A. Tate. O-Plan: </author> <title> The Open Planning Architecture. </title> <journal> Artificial Intelligence, </journal> <volume> 51(1), </volume> <year> 1991. </year>
Reference-contexts: Example: Considering our example plan P E in Figure 4, M = ft 1 ! S <ref> [5] </ref>; t 2 ! S [6]g is a mapping function from P E to the operator sequence S : o 3 o 1 o 3 o 1 o 1 o 2 . This is because: (i) S [5] is o 1 which is also ST (t 1 ), and similarly S <p> example plan P E in Figure 4, M = ft 1 ! S <ref> [5] </ref>; t 2 ! S [6]g is a mapping function from P E to the operator sequence S : o 3 o 1 o 3 o 1 o 1 o 2 . This is because: (i) S [5] is o 1 which is also ST (t 1 ), and similarly S [6] is o 2 which is also ST (t 2 ). (ii) There are no ordering relations between t 1 and t 2 in P E and thus S trivially satisfies the ordering relations of P E <p> Example: In our example plan P E , the operator sequence S : o 3 o 1 o 3 o 1 o 1 o 2 will satisfy the IPCs with respect to the mapping function M = ft 1 ! S <ref> [5] </ref>; t 2 ! S [6]g. In particular, the IPC ht 1 ; p; t 1 i is satisfied because all the operators between S [5] and the end of the operator sequence, which in this case is just o 2 , preserve (do not violate) p. <p> 1 o 3 o 1 o 1 o 2 will satisfy the IPCs with respect to the mapping function M = ft 1 ! S <ref> [5] </ref>; t 2 ! S [6]g. In particular, the IPC ht 1 ; p; t 1 i is satisfied because all the operators between S [5] and the end of the operator sequence, which in this case is just o 2 , preserve (do not violate) p. This can be verified from the effects of the operators described in the top right table in Figure 4. <p> Example: Consider once again the example plan P E , the operator sequence S : o 3 o 1 o 3 o 1 o 1 o 2 and the mapping function M = ft 1 ! S <ref> [5] </ref>; t 2 ! S [6]g. The PTC hr@t 1 i is satisfied by S with respect to M since S [3] = o 3 adds r and S [4] = o 1 does not delete r. <p> The PTC hr@t 1 i is satisfied by S with respect to M since S [3] = o 3 adds r and S [4] = o 1 does not delete r. It can be verified that the other two PTCs are also satisfied by S. This is because S <ref> [5] </ref> = o 1 gives p and S [6] = o 2 gives q without deleting p, and thus both p and q are true at the end S. The PTCs are examples of non-monotonic auxiliary constraints. <p> Example: Continuing with our example plan P E , the operator sequence S : o 3 o 1 o 3 o 1 o 1 o 2 and the mapping function M = ft 1 ! S <ref> [5] </ref>; t 2 ! S [6]g, we have already seen that S satisfies the step, ordering and interval preservation constraints with respect to the mapping M. Thus S is a candidate of the partial plan P E . <p> Figure 6 illustrates P ; and A ; . 13 As noted earlier, the candidate 12 An important exception is the hierarchical task reduction planners, such as SIPE [40], IPEM [1] and O-Plan <ref> [5] </ref>. However, see [17] for a discussion of how Refine-Plan can be extended to cover these planners. 13 Alert readers may note that there is some overlap between the agenda, and the definition of PTCs.
Reference: [6] <author> K. Erol, D. Nau and J. Hendler. </author> <title> Toward a general framework for hierarchical task-network planning. </title> <booktitle> In Proc. of AAAI Spring Symp. on Foundations of Automatic Planning. </booktitle> <year> 1993. </year>
Reference-contexts: t 2 ! S <ref> [6] </ref>g is a mapping function from P E to the operator sequence S : o 3 o 1 o 3 o 1 o 1 o 2 . This is because: (i) S [5] is o 1 which is also ST (t 1 ), and similarly S [6] is o 2 which is also ST (t 2 ). (ii) There are no ordering relations between t 1 and t 2 in P E and thus S trivially satisfies the ordering relations of P E . 3.4.2 Auxiliary Constraints Intuitively, the last two clauses of the definition of the <p> It can be verified that the other two PTCs are also satisfied by S. This is because S [5] = o 1 gives p and S <ref> [6] </ref> = o 2 gives q without deleting p, and thus both p and q are true at the end S. The PTCs are examples of non-monotonic auxiliary constraints. To see this, consider the operator sequence S : o 1 o 2 .
Reference: [7] <author> O Etzioni and R Etzioni. </author> <title> Statistical Methods for Analyzing Speedup Learning Experiments. </title> <journal> Machine Learning, </journal> <volume> 14(3), </volume> <year> 1994. </year>
Reference-contexts: We also note that around these middle points both SNLP-MTC and McNONLIN-MTC perform much better than TWEAK. This conforms to Hypothesis 2. Using a signed-rank test <ref> [7] </ref> on cpu times, these results are statistically significant at # clob = 4 with p-values of 0.01 and 0.008, 34 respectively.
Reference: [8] <author> M.G. Georgeff. </author> <title> Planning. In Readings in Planning. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Most classical planning techniques have traditionally concentrated on the attainment of goals <ref> [8] </ref>. These goals can be seen as a sub-class of behavioral constraints, which restricts the agent's attention to behaviors that end in world states satisfying desired properties.
Reference: [9] <author> M. Ginsberg. </author> <title> Approximate Planning. </title> <journal> Artificial Intelligence, Special Issue on Planning, Scheduling and Control. </journal> <year> 1995. </year>
Reference-contexts: The ``immediacy'' constraints, discussed by Ginsberg in <ref> [9] </ref> are an example of such constraints (see Section 9). 8 Fig. 3. A schematic illustration of the relation between a partial plan and its candidate set. The candidate set of a partial plan is all ground operator sequences that are consistent with its constraints. <p> The idea of looking at partial plans not as incomplete solutions, but rather as sets of potential solutions, has also been used in Ginsberg's recent work on approximate planning <ref> [9] </ref>. In particular, his notion of ``linearizations'' of a plan is very close to our notion of candidate set of a partial plan.
Reference: [10] <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of POPL-87, </booktitle> <pages> pages 111--119, </pages> <year> 1987. </year>
Reference-contexts: Instead, the candidate sets are typically implicitly represented as generalized constraint sets associated with search nodes (c.f. <ref> [10] </ref>) such that every candidate that is consistent with the constraints in that constraint set is taken to belong to the candidate set of the search node. Under this representation, the refinement of a search node corresponds to adding new constraints to its constraint set, thereby restricting its candidate set.
Reference: [11] <author> S. Kambhampati. </author> <title> Planning as Refinement Search: A unified framework for comparative analysis of Search Space Size and Performance. </title> <type> Technical Report 93-004, </type> <institution> Arizona State University, </institution> <month> June, </month> <year> 1993. </year> <note> Available via anonymous ftp from enws318.eas.asu.edu:pub/rao/papers.html 78 </note>
Reference-contexts: can have p either added or deleted between operators corresponding to s 0 and s. 20 This contributor protection can be modeled in terms of the twin interval 18 also called causal link protection, or protection intervals in the literature 19 also called exhaustive causal link protection [12] 20 See <ref> [11] </ref> for a reconstruction of the ideas underlying goal protection strategies. 29 preservation constraints hs 0 ; p; si and hs 0 ; :p; si. 21 While most planners use one or the other type of protection strategies exclusively for all conditions, planners like NONLIN and O-Plan [39,5] post different bookkeeping <p> of pre-ordering refinements, they also tend to reduce the cost of goal selection and solution-construction, especially when the latter are based on MTC (thereby reducing the goal selection does not affect completeness, any tractable approximation to the modal truth criterion will be enough. 46 T sol and T est components) <ref> [11] </ref>. In terms of search space size, tractability refine-ments further refine the plans coming out of the establishment stage, increasing the b t component of the branching factor.
Reference: [12] <author> S. Kambhampati. </author> <title> Multi-Contributor Causal Structures for Planning: A Formalization and Evaluation. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 69, </volume> <year> 1994. </year> <pages> pp. 235-278. </pages>
Reference-contexts: Avoids the excessive commitment to contributors inherent in the interval protection and contributor protection strategies. But sacrifices systematicity <ref> [12] </ref>. Table 2 Implementation and properties of some common protection (bookkeeping) strategies in terms of Refine-Plan framework. of the search tree. In the example 8 (b) after having established a PTC hQ@a 1 i, the planner works on the PTC hR@a 1 i. <p> the partial plan can have p either added or deleted between operators corresponding to s 0 and s. 20 This contributor protection can be modeled in terms of the twin interval 18 also called causal link protection, or protection intervals in the literature 19 also called exhaustive causal link protection <ref> [12] </ref> 20 See [11] for a reconstruction of the ideas underlying goal protection strategies. 29 preservation constraints hs 0 ; p; si and hs 0 ; :p; si. 21 While most planners use one or the other type of protection strategies exclusively for all conditions, planners like NONLIN and O-Plan [39,5] <p> Finally, the interval protections and contributor protections can also be generalized to allow for multiple contributors supporting a given condition <ref> [12] </ref>. In particular, a multiple-contributor protection may represent the commitment that the preconditi on p of step s 0 will be given by either s 1 or s 2 .
Reference: [13] <author> S. Kambhampati. </author> <title> On the Utility of Systematicity: Understanding tradeoffs between redundancy and commitment in partial order planning. </title> <booktitle> In Proceedings of IJCAI-93, </booktitle> <year> 1993. </year>
Reference-contexts: Thus, protection strategies have two possible effects on the size of the explored search space <ref> [13] </ref>: -- They reduce the redundancy in the search-space and thus make the overall search space smaller. -- They represent higher commitment to establishment choices, and thus can lead to higher backtracking during search. <p> then there will be no appreciable difference in the relative performance of I sp and I np , unless there is a high probability that the planner will commit to wrong establishments in the beginning of the search (this could happen, for example, when the domain contains many high-frequency conditions <ref> [13] </ref>). Hypothesis 5 If the domain has a low solution density, the planners are forced to explore a large part of their search space. Thus, the redundancy in the search space will become a factor affecting the performance of the planner.
Reference: [14] <author> S. Kambhampati and D.S. Nau. </author> <title> On the Nature and Role of Modal Truth Criteria in Planning. </title> <journal> Artificial Intelligence, </journal> <note> 1994 (to appear). (Available as Tech. Report. </note> <institution> ISR-TR-93-30. University of Maryland, </institution> <month> March, </month> <year> 1993. </year> <note> A shorter version appears in Proc. 12th Natl. Conf. on AI (AAAI-94), </note> <month> July </month> <year> 1994) </year>
Reference-contexts: to limit Refine-Plan to establishment refinements alone and still get a sound and complete (in the sense of Definition 3) planner (using either Some-sol or all-sol described earlier as solution constructors). 17 And it also separates checking the truth of a proposition from planning to make that proposition true, see <ref> [14] </ref>. 25 Planner Soln.
Reference: [15] <author> S. Kambhampati. </author> <title> Refinement search as a unifying framework for analyzing planning algorithms. </title> <booktitle> In Proc. 4th Intl. Conf. on Ppls. of KR & R (KR-94), </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: In particular, given any partial plan P, corresponding to every precondition C of step s in the plan, the partial plan contains a PTC (non-monotonic auxiliary constraint) hC@si. Auxiliary constraints can also be used to model other aspects of refinement planning. In <ref> [15] </ref>, we show that IPC's can be used to model maintenance goals while PTC's can be used to model filter conditions. <p> Although we will be concentrating on goals of attainment, other richer types of behavioral constraints, such as maintenance goals, and intermediate goals, can be handled by invoking Refine-Plan with a plan that contains more initial constraints than P ; described above (see <ref> [15] </ref>). In particular, maintenance goals can be handled by imposing some interval preservation constraints on the initial plan.
Reference: [16] <author> S. Kambhampati. </author> <title> Design Tradeoffs in Partial Order (Plan Space) Planning. </title> <booktitle> In Proc. 2nd Intl. Conf. on AI Planning Systems (AIPS-94), </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: This point should be kept in mind in viewing the various performance plots presented in this section. Finally, most of the experiments described in the following sections have been validated by running them on two largely independent implementations (see <ref> [16] </ref> and [21]). This lends us confidence that the results are not dependent on any idiosyncrasies of a particular implementation. The final data reported in this paper correspond to runs on a SUN SPARC 20 with 96 megabytes of main memory running Lucid Commonlisp.
Reference: [17] <author> S. Kambhampati. </author> <title> A comparative analysis of partial order planning and task reduction planning SIGART Bulletin, Special Section on evaluating plans, </title> <journal> planners and planning agents. </journal> <volume> Vol. 6, No. 1, </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: Figure 6 illustrates P ; and A ; . 13 As noted earlier, the candidate 12 An important exception is the hierarchical task reduction planners, such as SIPE [40], IPEM [1] and O-Plan [5]. However, see <ref> [17] </ref> for a discussion of how Refine-Plan can be extended to cover these planners. 13 Alert readers may note that there is some overlap between the agenda, and the definition of PTCs. <p> Finally, many existing industrial strength planners use task-reduction techniques, which are not modeled by our Refine-Plan algorithm. In <ref> [17] </ref> we show that Refine-Plan can be extended to cover task reduction planners (also called HTN planners) by simply replacing the establishment refinement with another called task-reduction refinement (we also show that this model clarifies several features of HTN planning).
Reference: [18] <author> C. Knoblock. </author> <title> Automatically Generating Abstractions for Planning. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 68, </volume> <year> 1994. </year>
Reference: [19] <author> C. Knoblock and Q. Yang. </author> <title> A Comparison of the SNLP and TWEAK planning algorithms. </title> <booktitle> In Proc. of AAAI Spring Symp. on Foundations of Automatic Planning. </booktitle> <year> 1993. </year>
Reference-contexts: This distinction removes many misunderstandings about plan-space planning algorithms. For example, it clarifies that the only motivation for total ordering plan-space planners is tractability of refinement. Similarly, it has been previously believed ( e.g. <ref> [19] </ref>) that the systematicity of SNLP increases the average depth of the solution.
Reference: [20] <author> C. Knoblock and Q. Yang. </author> <title> Relating the Performance of Partial-order planning algorithms to domain features. </title> <journal> SIGART Bulletin, Special Section on evaluating plans, planners and planning agents. </journal> <volume> Vol. 6, No. 1, </volume> <month> January </month> <year> 1995. </year>
Reference: [21] <author> C. Knoblock and Q. Yang. </author> <title> Evaluating the Tradeoffs in Partial-Order Planning Algorithms. </title> <booktitle> In Proc. Canadian Conference on Artificial Intelligence (AI-94), </booktitle> <month> May, </month> <year> 1994. </year>
Reference-contexts: This point should be kept in mind in viewing the various performance plots presented in this section. Finally, most of the experiments described in the following sections have been validated by running them on two largely independent implementations (see [16] and <ref> [21] </ref>). This lends us confidence that the results are not dependent on any idiosyncrasies of a particular implementation. The final data reported in this paper correspond to runs on a SUN SPARC 20 with 96 megabytes of main memory running Lucid Commonlisp. <p> Acknowledgements This paper is the result of combining and extending two initially independent research efforts, one by Kambhampati [11,15--17] and the other by Knoblock and Yang [19,21,20]. We thank the editors of this special issue for bringing us together. The paper by Knoblock and Yang <ref> [21] </ref> won the CSCSI (Canadian Society for Computational Studies of Intelligence) Best Paper Award in 1994 (sponsored by the Artificial Intelligence Journal).
Reference: [22] <author> R. Korf. </author> <title> Planning as Search: a quantitative approach. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 33, </volume> <year> 1987. </year> <pages> pp. 65-88. </pages>
Reference-contexts: Barrett and Weld [2] compare the performance of two plan-space (SNLP and TOCL, in Table 1), and a state-space planner (TOPI), and develop hypotheses regarding the relative performance of these planners. In particular, they extend the notions of serializability defined in <ref> [22] </ref> to include trivial and laborious serializability, and contend that the partial-order planners yield superior performance because the subgoals in planning domains are trivially serializable for them more frequently than for total order planners.
Reference: [23] <author> D. McDermott. </author> <title> Regression Planning. </title> <journal> Intl. Jour. Intelligent Systems, </journal> <volume> 6 </volume> <pages> 357-416, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction [...] Search is usually given little attention in this field, relegated to a footnote about how ``Backtracking was used when the heuristics didn't work.'' Drew McDermott, <ref> [23, p. 413] </ref> The idea of generating plans by searching in the space of (partially ordered or totally ordered) plans has been around for almost twenty years, and has received a lot of formalization in the past few years. <p> Existing Planners TWEAK [3] MTC-based O 4 ) MTC-based O 4 ) None None UA MTC-based O 2 ) MTC-based O 2 ) None Unambiguous ordering Nonlin [39] (Q&A) based Arbitrary O Interval & Goal Protection Conflict Resolution TOCL [2] Protection based O Arbitrary O Contributor protection Total ordering Pedestal <ref> [23] </ref> Protection based O Arbitrary O Interval Protection Total ordering SNLP [24] Protection based Arbitrary Contributor protection Conflict resolution UCPOP [33] (1) (1) MP-I Protection based Arbitrary (Multi) contributor protection Conflict resolution Hybrid Planners (described in Section 5.2) SNLP-UA MTC based O 2 ) based O 2 ) Contributor protection Unambiguous <p> Suppose the planner just established a condition c at step s with the help of the effects of the step s 0 . For planners using interval protection (e.g., PEDESTAL <ref> [23] </ref>), the bookkeeping constraint requires that no candidate of the partial plan can have p deleted between operators corresponding to s 0 and s. It can thus be modeled in terms of the interval preservation constraint hs 0 ; p; si.
Reference: [24] <author> D. McAllester and D. Rosenblitt. </author> <title> Systematic Nonlinear Planning. </title> <booktitle> In Proc. 9th AAAI, </booktitle> <year> 1991. </year>
Reference-contexts: Section 4 describes the generalized refinement planning algorithm, Refine-Plan, discusses its various components, and shows how the various ways of instantiating the component steps correspond to the various design choices for partial-order planning. Section 5 shows how the existing plan-space planners, including TWEAK [3], SNLP <ref> [24] </ref>, UA [27] and Nonlin [39] can be seen as instantiations of Refine-Plan. It also discusses how Refine-Plan can be instantiated to give rise to a variety of new planning algorithms with interesting tradeoffs. <p> For readers who are familiar with the ``causal link'' notation <ref> [24] </ref>, note that an IPC hs i ; c; s j i does not require that s i give the condition c, but merely that the condition c be preserved (i.e., left unaffected) in the interval between s i and s j . <p> Existing planning systems implement All-sol in two different ways: Planners such as Chapman's TWEAK [3,42] use the modal truth criterion to explicitly check that all the safe ground linearizations correspond to solutions (we will call these the MTC-based constructors). Planners such as SNLP <ref> [24] </ref> and UCPOP [33] depend on protection strategies and conflict resolution (Section 4.5.2) to indirectly guarantee the safety and necessary correctness required by All-sol (we call these protection based constructors). <p> ) None None UA MTC-based O 2 ) MTC-based O 2 ) None Unambiguous ordering Nonlin [39] (Q&A) based Arbitrary O Interval & Goal Protection Conflict Resolution TOCL [2] Protection based O Arbitrary O Contributor protection Total ordering Pedestal [23] Protection based O Arbitrary O Interval Protection Total ordering SNLP <ref> [24] </ref> Protection based Arbitrary Contributor protection Conflict resolution UCPOP [33] (1) (1) MP-I Protection based Arbitrary (Multi) contributor protection Conflict resolution Hybrid Planners (described in Section 5.2) SNLP-UA MTC based O 2 ) based O 2 ) Contributor protection Unambiguous Ordering SNLP-MTC MTC based O 4 ) based O 4 ) <p> In addition to the properties of agenda popping and interval protection, it also ensures that the establishment refinement is sys tematic <ref> [24] </ref> (see Definition 1). <p> Specifically, we have: Proposition 23 (Systematicity of establishment with Contributor Protection <ref> [24] </ref>) Establishment refinement with contributor protection is systematic in that partial plans in different branches of the search tree will have non-overlapping candidate sets (thus = 1). <p> first discuss instantiations that correspond to some well-known existing partial-order planners and then (in Section 5.2) discuss some instantiations of Refine-Plan 34 that have not been previously discussed in the literature. 5.1 Existing Planners In this section we will discuss the instantiations of Refine-Plan corresponding to four well-known planners: SNLP <ref> [24] </ref>, McNONLIN [39], TWEAK [3] and UA [27]. <p> We will start with the instantiation of Refine-Plan that corresponds to SNLP, called Refine-Plan-SNLP, and describe the other three algorithms in terms of the incremental changes that need to be made to the SNLP instantiation. 5.1.1 The SNLP Algorithm The following describes the SNLP algorithm, first described in <ref> [24] </ref>, as an instanti-ation of Refine-Plan. Algorithm Refine-Plan-SNLP (hP : hT; O; B; ST ; Li; Ai) 0. Termination: If A is empty, report success and stop. 1.1. Goal selection: Pick any hp; s need i 2 A. Set A = A hp; s need i 1.2. <p> These can be replaced without affecting the systematicity property. 72 Similarly, our framework not only clarifies the relation between the unambiguous planners such as UA [27] and causal-link based planners such as SNLP <ref> [24] </ref>, it also suggests fruitful ways of integrating the ideas in the two planning techniques (cf. SNLP-UA in Section 5.2.2). 10 Conclusion The primary contribution of this paper is a unified framework for understanding and analyzing the design tradeoffs in partial-order plan-space planning. <p> Candidate Space The space of potential solutions for a problem. Causal Link A concept due to McAllester <ref> [24] </ref>.
Reference: [25] <author> D. McAllester. </author> <title> Private Communication. </title> <month> Spring </month> <year> 1993. </year>
Reference-contexts: The paper by Knoblock and Yang [21] won the CSCSI (Canadian Society for Computational Studies of Intelligence) Best Paper Award in 1994 (sponsored by the Artificial Intelligence Journal). Thanks are due to David McAllester for many enlightening (e-mail) discussions on the nature of refinement search <ref> [25] </ref>; and Bulusu Gopi Kumar, Suresh Katukam, Laurie Ihrig, Mark Drummond, Kutluhan Erol, Nort Fowler, Jonathan Gratch, Dan Weld, and the anonymous reviewers for critical comments on earlier versions of this paper.
Reference: [26] <author> S. Minton, J. Bresina and M. Drummond. </author> <title> Commitment Strategies in Planning: A Comparative Analysis. </title> <booktitle> In Proc. 12th IJCAI, </booktitle> <year> 1991. </year>
Reference-contexts: The examples in Figure 8 illustrate both these behaviors on a planner that only uses establishment refinement. Example 8 (a) (originally from Minton et al. <ref> [26] </ref>) shows that a planner without any form of book-keeping may find the same solution in multiple different search branches. (That is, the candidate sets of the search nodes in different branches overlap.) Specifically, the ground operator sequence o 3 o 2 o 1 belongs to the candidate sets of nodes <p> Two possible pre-ordering techniques are total ordering and unambiguous ordering <ref> [26] </ref>. Total ordering orders every pair of steps in the plan, while unambiguous ordering orders a pair of steps only when one of the steps has an effect c, and the other step either negates c or needs c as a precondition (implying that the two steps may interact). <p> For example, unambiguous plans also allow polynomial check for necessary truth of any condition in the plan. Polynomial necessary truth check can be useful in MTC-based goal selection and termination tests. In fact, unambiguous plans were originally used in UA <ref> [26] </ref> for this purpose. 4.5.2 Conflict Resolution Refinements Conflict resolution refines a given partial plan with the aim of compiling the monotonic auxiliary constraints into the ordering and binding constraints. <p> In particular, our hypotheses regarding the effect of tractability refinements (Section 7.1) should be applicable for both these comparisons. Another interesting relation with Minton et al.'s work concerns the comparison between TWEAK and UA. Minton et al. <ref> [26] </ref> suggest that UA could be more efficient than TWEAK because TWEAK has more redundancy in its search space.
Reference: [27] <author> S. Minton, M. Drummond, J. Bresina and A. Philips. </author> <title> Total Order vs. Partial Order Planning: </title> <booktitle> Factors Influencing Performance In Proc. </booktitle> <address> KR-92, </address> <year> 1992. </year> <month> 79 </month>
Reference-contexts: Section 4 describes the generalized refinement planning algorithm, Refine-Plan, discusses its various components, and shows how the various ways of instantiating the component steps correspond to the various design choices for partial-order planning. Section 5 shows how the existing plan-space planners, including TWEAK [3], SNLP [24], UA <ref> [27] </ref> and Nonlin [39] can be seen as instantiations of Refine-Plan. It also discusses how Refine-Plan can be instantiated to give rise to a variety of new planning algorithms with interesting tradeoffs. <p> well-known existing partial-order planners and then (in Section 5.2) discuss some instantiations of Refine-Plan 34 that have not been previously discussed in the literature. 5.1 Existing Planners In this section we will discuss the instantiations of Refine-Plan corresponding to four well-known planners: SNLP [24], McNONLIN [39], TWEAK [3] and UA <ref> [27] </ref>. <p> is a special case), since it continues to use the establishment refinement as long as there are preconditions of the plan that are not necessarily correct (according to MTC). 5.1.4 The UA Algorithm Another partial-order planning algorithm that received a significant amount of analysis is Minton et al.'s UA planner <ref> [27] </ref>. UA is very similar to TWEAK (in that it uses no bookkeeping constraints) and employs goal-selection and termination strategies similar to TWEAK. The only difference between UA and TWEAK is that UA uses a pre-ordering tractability refinement. <p> Both planners were started off with a mingoals heuristic <ref> [27] </ref>, which ranks a partial plan by the number of preconditions that are not necessarily true according to MTC. We then systematically varied the probability p (called the misdirection parameter) with which both planners will reject the direction recommended by the heuristic and will select the worst ranked branch instead. <p> However, this does not come without a tradeoff. Specifically, when the planner does such partial conflict resolution, the consistency check has to once again test for existence of safe ground 38 Similarly, Minton et al. conjecture <ref> [27] </ref> that addition of causal links (i.e., book-keeping strategies) will increase the the cost of UA. Our empirical comparison of SNLP-UA and UA in ART-MD-RD domain (Section 8.2.2) provide a data point for checking this conjecture. <p> These can be replaced without affecting the systematicity property. 72 Similarly, our framework not only clarifies the relation between the unambiguous planners such as UA <ref> [27] </ref> and causal-link based planners such as SNLP [24], it also suggests fruitful ways of integrating the ideas in the two planning techniques (cf.
Reference: [28] <author> J. Pearl. </author> <title> Heuristics: Intelligent Search Strategies for Computer Problem Solving. </title> <publisher> Addison-Wesley (1984). </publisher>
Reference-contexts: Section 10 summarizes the contributions of the paper Appendix A provides a quick reference for the list of symbols used in the paper, and Appendix B contains a glossary of terms introduced in the paper. 2 Introduction to Refinement Search The refinement search (also called split-and-prune search <ref> [28] </ref>) paradigm is useful for modeling search problems in which it is possible to enumerate all potential solutions (called candidates) and verify if one of them is a solution for the problem.
Reference: [29] <author> E.P.D. Pednault. </author> <title> Synthesizing Plans that contain actions with Context-Dependent Effects. </title> <journal> Computational Intelligence, </journal> <volume> Vol. 4, </volume> <month> 356-372 </month> <year> (1988). </year>
Reference-contexts: Refine-Plan is modular in that its individual steps can be analyzed and instantiated relatively independently. Furthermore, the algorithms do not assume any specific restrictions on action representation, and can be used by any planner using the ADL action representation <ref> [29] </ref>. Although we will be concentrating on goals of attainment, other richer types of behavioral constraints, such as maintenance goals, and intermediate goals, can be handled by invoking Refine-Plan with a plan that contains more initial constraints than P ; described above (see [15]). <p> When this is done, it is easy to see that all the minimal candidates of the resulting plan will satisfy the PTC hc@si (Section 3.4.2). Different refinements correspond to different steps acting as contributors of c to s. Chapman [3] and Pednault <ref> [29] </ref> provide theories of sound and complete establishment refinement. <p> The last strategy, called MTC-based goal selection, involves reasoning about the truth of a condition in a partially-ordered plan, and can be intractable for general partial orderings consisting of ADL <ref> [29] </ref> actions (see Table 1, as well as the discussion of pre-ordering strategies in Section 4.5.1.). 4.3 Bookkeeping and Protecting establishments It is possible to do establishment refinement without bookkeeping step. Chapman's TWEAK [3] is such a planner. <p> Specifically, the partial plan is refined (by adding ordering, binding or secondary preconditions <ref> [29] </ref> to the plan) until each possible violation of the auxiliary candidate constraint (called conflict) is individually resolved. <p> Resolving the conflict involves either making s 0 not intervene between s i and s j (by adding either the ordering s 0 s i or the ordering s j s 0 ), or adding secondary (preservation) preconditions of s 0 , required to make s 0 preserve c <ref> [29] </ref>, as PTCs to the partial plan (and to the agenda). The ordering strategies for resolving conflicts are called promotion and demotion, while the secondary precondition based conflict resolution is called confrontation.
Reference: [30] <author> E.P.D. Pednault. </author> <title> ADL: Exploring the middle ground between STRIPS and the Situation Calculus. </title> <booktitle> Proc. 1st Intl. Conf. on the Ppls. of Knowledge Rep. and Reasoning. </booktitle> <year> 1989. </year>
Reference-contexts: Pednault <ref> [30] </ref> provides a logical representation, called the Action Description Language (ADL) for representing such state transformation functions. We will be assuming that the domain operators are described in the ADL representation with Precondition and Effect formulas.
Reference: [31] <author> E.P.D. Pednault. </author> <title> Generalizing nonlinear planning to handle complex goals and actions with context dependent effects. </title> <booktitle> In Proc. IJCAI-91. </booktitle> , <year> 1991. </year>
Reference: [32] <author> M.A. Peot and D.E. Smith. </author> <title> Threat-Removal Strategies for Nonlinear Planning. </title> <booktitle> In Proc. Eleventh AAAI, </booktitle> <year> 1993. </year>
Reference-contexts: Similarly, we can resolve some conflicts, while leaving others unresolved. Finally, we could either handle the unordered and/or unresolved conflicts by the end of the search, or ignore them all together. Such strategies could be useful in improving performance <ref> [32] </ref>, since as we shall see in Section 6, tractability refinements reduce the cost of consistency check at the expense of increased branching factor (corresponding to additional refinements). This type of selective use of tractability refinements does not in general affect soundness and completeness of the Refine-Plan. <p> This is because each ``causal link'' used by SNLP naturally corresponds to two independent IPCs, and the notion of threat need only be defined with respect to an IPC. 25 The SNLP implementation used by Peot and Smith in their conflict deferment experiments <ref> [32] </ref> corresponds closely to our description above. 36 5.1.2 The McNONLIN Algorithm SNLP is a descendant of NONLIN [39] planning algorithm. There are several differences between NONLIN, which is a hierarchical task reduction planner, and SNLP, which a non-hierarchical partial order planner. <p> similar to McNONLIN-MTC, except that it does not use any tractability refinements, and uses a consistency check that prune any partial plan that has no safe ground linearizations. 31 30 Perceptive readers might note a close relation between the operation of SNLP-CON and the idea of conflict deferment described in <ref> [32] </ref>. In particular, in comparison to SNLP and SNLP-MTC, SNLP-CON can be seen as deferring all threats. However, unlike the implementations of SNLP used in [32], SNLP-CON uses a full consistency check, and thus will never refine an inconsistent plan. <p> safe ground linearizations. 31 30 Perceptive readers might note a close relation between the operation of SNLP-CON and the idea of conflict deferment described in <ref> [32] </ref>. In particular, in comparison to SNLP and SNLP-MTC, SNLP-CON can be seen as deferring all threats. However, unlike the implementations of SNLP used in [32], SNLP-CON uses a full consistency check, and thus will never refine an inconsistent plan. See Section 9. 31 There are several ways of implementing these full consistency checks. <p> An example is the recent work on improving planning performance through selective deferment of conflict resolution <ref> [32] </ref>. <p> The planners with which Peot et al. <ref> [32] </ref> experimented all used ordering and binding consistency checks. Conflict deferment in such situations can lead to refinement of inconsistent plans, thereby reducing d and increasing jF d j, and leading to loss of strong systematicity (Definition 7). <p> In such cases, we would expect that best performance is achieved neither with eager conflict resolution, nor with full conflict deferment. This intuition is consistent with the empirical evidence provided by Peot et al. <ref> [32] </ref>. In particular, they found that deferring any conflict which has more than one way of resolution is better than deferring every conflict. In terms of Refine-Plan, the former strategy reduces the chance that the partial plan with deferred conflicts is inconsistent.
Reference: [33] <author> J.S. Penberthy and D. Weld. UCPOP: </author> <title> A Sound, Complete, Partial Order Planner for ADL. </title> <booktitle> In Proc. </booktitle> <address> KR-92, </address> <year> 1992. </year>
Reference-contexts: Existing planning systems implement All-sol in two different ways: Planners such as Chapman's TWEAK [3,42] use the modal truth criterion to explicitly check that all the safe ground linearizations correspond to solutions (we will call these the MTC-based constructors). Planners such as SNLP [24] and UCPOP <ref> [33] </ref> depend on protection strategies and conflict resolution (Section 4.5.2) to indirectly guarantee the safety and necessary correctness required by All-sol (we call these protection based constructors). <p> O 2 ) None Unambiguous ordering Nonlin [39] (Q&A) based Arbitrary O Interval & Goal Protection Conflict Resolution TOCL [2] Protection based O Arbitrary O Contributor protection Total ordering Pedestal [23] Protection based O Arbitrary O Interval Protection Total ordering SNLP [24] Protection based Arbitrary Contributor protection Conflict resolution UCPOP <ref> [33] </ref> (1) (1) MP-I Protection based Arbitrary (Multi) contributor protection Conflict resolution Hybrid Planners (described in Section 5.2) SNLP-UA MTC based O 2 ) based O 2 ) Contributor protection Unambiguous Ordering SNLP-MTC MTC based O 4 ) based O 4 ) Contributor protection conflict resolution SNLP-CON MTC based O 4 <p> Set A = A hp; s need i. 29 When we consider actions with conditional effects, the consistency check must be changed to prune the plan only when the conflict cannot be confronted <ref> [33] </ref>, i.e., resolved by posting preservation preconditions as additional preconditions of the plan. 40 Specifically, unlike TWEAK which does not remove a condition from A once it is considered for establishment, TWEAK-visit does remove it. It is instructive to note that TWEAK-visit avoids the looping described in Figure 8 (b).
Reference: [34] <author> E. Sacerdoti. </author> <title> Planning in a Hierarchy of Abstraction Spaces. </title> <journal> Artificial Intelligence, </journal> <volume> 5(2), </volume> <year> 1975. </year>
Reference: [35] <author> D.E. Smith and M.A. Peot. </author> <title> Postponing threats in partial-order planning. </title> <booktitle> In Proc. Eleventh AAAI, </booktitle> <year> 1993. </year>
Reference-contexts: Specifically, we have: Proposition 24 Given a partial plan whose monotonic auxiliary constraints contain interval preservation constraints, checking if there exists a safe ground linearization of the plan is NP-hard. This proposition directly follows from a result due to Smith <ref> [35] </ref>, which shows that checking whether there exists a conflict-free ground linearization of a partial plan with interval preservation constraints is NP-hard. 4.5 Tractability refinements Since, as observed above, the consistency check is NP-hard in general, each call to Refine-Plan is also NP-hard. <p> This tends to reduce the fringe size, jF d j. Bookkeeping constraints do however tend to increase the cost of consistency check. In particular, checking the consistency of a partial plan containing interval preservation constraints is NP-hard even for ground plans in TWEAK representation (c.f. <ref> [35] </ref>).
Reference: [36] <author> D.R. Smith. </author> <title> Structure and Design of global search algorithms. </title> <type> Tech. Rep. </type> <institution> KES.U.87.13, Kestrel Institute, </institution> <month> November </month> <year> 1987. </year> <note> To appear in Acta Informatica. </note>
Reference: [37] <author> D.R. Smith and E.A. </author> <title> Parra. Transformational approach to transportation scheduling. </title> <booktitle> In Proc. 8th Knowledge-based software engineering Conference, </booktitle> <year> 1993. </year>
Reference-contexts: His motivation is to attempt to use the global search framework, in conjunction with an interactive software development system (KIDS [38]) to synthesize efficient scheduling algorithms for given problem populations <ref> [37] </ref>. Global search has several similarities with the refinement search framework discussed in this paper. For example, corresponding to our monotonic auxiliary constraints, Smith's global search has the notion of filters. <p> This analysis needs to be validated, as well as extended to cover situations where refinements do not distribute solution candidates randomly among the refined plans. 73 In Section 9, we noted that Smith <ref> [37] </ref> uses a global search based framework to automatically synthesize customized schedulers.
Reference: [38] <author> D.R. </author> <title> Smith KIDS -- a semi-automatic program development system. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. 16, No. 9, </volume> <year> 1990. </year> <pages> pp. 1024-1043. </pages>
Reference-contexts: His motivation is to attempt to use the global search framework, in conjunction with an interactive software development system (KIDS <ref> [38] </ref>) to synthesize efficient scheduling algorithms for given problem populations [37]. Global search has several similarities with the refinement search framework discussed in this paper. For example, corresponding to our monotonic auxiliary constraints, Smith's global search has the notion of filters.
Reference: [39] <author> A. Tate. </author> <title> Generating Project Networks. </title> <booktitle> In Proceedings of IJCAI-77, pages 888--893, </booktitle> <address> Boston, MA, </address> <year> 1977. </year>
Reference-contexts: Section 5 shows how the existing plan-space planners, including TWEAK [3], SNLP [24], UA [27] and Nonlin <ref> [39] </ref> can be seen as instantiations of Refine-Plan. It also discusses how Refine-Plan can be instantiated to give rise to a variety of new planning algorithms with interesting tradeoffs. <p> Constructor Goal Selection Bookkeeping Tractability Refinements Existing Planners TWEAK [3] MTC-based O 4 ) MTC-based O 4 ) None None UA MTC-based O 2 ) MTC-based O 2 ) None Unambiguous ordering Nonlin <ref> [39] </ref> (Q&A) based Arbitrary O Interval & Goal Protection Conflict Resolution TOCL [2] Protection based O Arbitrary O Contributor protection Total ordering Pedestal [23] Protection based O Arbitrary O Interval Protection Total ordering SNLP [24] Protection based Arbitrary Contributor protection Conflict resolution UCPOP [33] (1) (1) MP-I Protection based Arbitrary (Multi) <p> instantiations that correspond to some well-known existing partial-order planners and then (in Section 5.2) discuss some instantiations of Refine-Plan 34 that have not been previously discussed in the literature. 5.1 Existing Planners In this section we will discuss the instantiations of Refine-Plan corresponding to four well-known planners: SNLP [24], McNONLIN <ref> [39] </ref>, TWEAK [3] and UA [27]. <p> to two independent IPCs, and the notion of threat need only be defined with respect to an IPC. 25 The SNLP implementation used by Peot and Smith in their conflict deferment experiments [32] corresponds closely to our description above. 36 5.1.2 The McNONLIN Algorithm SNLP is a descendant of NONLIN <ref> [39] </ref> planning algorithm. There are several differences between NONLIN, which is a hierarchical task reduction planner, and SNLP, which a non-hierarchical partial order planner. <p> The following describes the steps of Refine-Plan where TWEAK 26 Actually, the original NONLIN used different types of protections based on the type of the precondition being protected <ref> [39] </ref> 27 Note, once again, that by using IPCs to model the book-keeping constraints, we avoid having to redefine the notion of a threat. 37 differs from SNLP. 28 0.
Reference: [40] <author> D. Wilkins. </author> <title> Practical Planning. </title> <publisher> Morgan Kaufmann (1988). </publisher>
Reference-contexts: Figure 6 illustrates P ; and A ; . 13 As noted earlier, the candidate 12 An important exception is the hierarchical task reduction planners, such as SIPE <ref> [40] </ref>, IPEM [1] and O-Plan [5]. However, see [17] for a discussion of how Refine-Plan can be extended to cover these planners. 13 Alert readers may note that there is some overlap between the agenda, and the definition of PTCs.
Reference: [41] <author> Q. Yang. </author> <title> Formalizing planning knowledge for hierarchical planning. </title> <journal> Computational Intelligence Journal, </journal> <volume> 6:12--24, </volume> <year> 1990. </year>
Reference-contexts: Intuitively, it would seem 9 This is called a point-protected condition in <ref> [41] </ref>. 15 reasonable to go ahead and say that a candidate is a ground operator sequence that satisfies all the constraints of the plan with respect to the same mapping. This however leads to a technical difficulty.
Reference: [42] <author> Q. Yang, J. Tenenberg, and S. Woods. </author> <title> Abstraction in nonlinear planning. </title> <type> Technical Report CS 91-65, </type> <institution> University of Waterloo, Department of Computer Science, Waterloo, </institution> <address> Ontario, Canada N2L 3G1, </address> <year> 1991. </year>
Reference: [43] <author> Q. Yang and C. Murray. </author> <title> An evaluation of the temporal coherence heuristic in partial-order planning. </title> <journal> Computational Intelligence Journal, </journal> <volume> 10(3), </volume> <year> 1994. </year> <month> 80 </month>
Reference-contexts: The unambiguity of partial plans maintained by UA seems to have less of an effect on the performance. 38 Another recent effort that did a comparative study on partial order planners is that of Yang and Murray <ref> [43] </ref>. They evaluate the utility of applying pruning heuristics to partial-order planners while preserving their completeness.
References-found: 43

