URL: http://www.cs.ucl.ac.uk/teaching/B011a/graph.ps
Refering-URL: http://www.cs.ucl.ac.uk/teaching/B011a/index.html
Root-URL: http://www.cs.ucl.ac.uk
Email: e-mail: fclack,sclaymang@cs.ucl.ac.uk  
Title: Dynamic Cyclic Data Structures in Lazy Functional Languages  
Author: Chris Clack, Stuart Clayman, David Parrott 
Date: October 24, 1995  
Address: College London.  
Affiliation: Department of Computer Science, University  
Abstract: We provide a survey of some of the related work in this area; we then build on this work by presenting methods for both the dynamic construction of complex cyclic structures and their direct manipulation using circular programming techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [All89] <author> L. Allison. </author> <title> Circular programs and self-referential structures. </title> <journal> Software|Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 99-109, </pages> <year> 1989. </year>
Reference: [Bir84] <author> R.S. Bird. </author> <title> Using circular programs to eliminate multiple traversals of data. </title> <journal> Acta Infor-matica, </journal> <volume> 21 </volume> <pages> 239-250, </pages> <year> 1984. </year>
Reference-contexts: In order to construct the graph from its description, it is necessary to use a "circular" programming technique <ref> [Bir84] </ref>. This is a self-referential definition, where the result of the definition is used in the definition itself. <p> We are improving the performance of the graph traversal methods; we aim for a linear time depth-first traversal. 2. The circular programming style used in this paper is necessary in order to create a cyclic structure dynamically, but is admittedly somewhat opaque. Bird <ref> [Bir84] </ref> has shown how circular programs may be derived from their non-circular counterparts via program transformation; this might be a route to simplifying direct manipulation of cyclic structures, but it is not immediately clear how to provide a non-circular version.
Reference: [BY90] <author> F.W. Burton and H-K Yang. </author> <title> Manipulating multilinked data structures in a pure functional language. </title> <journal> Software|Practice and Experience, </journal> 20(11) 1167-1185, 1990. 
Reference-contexts: To follow an index i, an expression such as graph!!i is used to return a value of type Node [Char]. The Indices type will therefore always be a list of Int although a graph might be described with node values of any type. Burton <ref> [BY90] </ref> extends work in this area to show how to simulate a mutable graph, using a virtual heap with "pointers" (which are heap indices, as above). <p> Arrays If a programmer is lucky enough to have access to a lazy functional language which provides arrays (such as Haskell [HPJW + 91]), then it is possible <ref> [BY90] </ref> to create a virtual heap representation which is potentially highly efficient. &gt; type Index = Int &gt; type Graph a = Array Index (a,[Index]) &gt; &gt; buildgraph::[a]-&gt;[[Index]]-&gt;Graph a &gt; buildgraph vals elist &gt; = listArray (0, (length vals)-1) 2 &gt; (zip vals elist) &gt; &gt; nodes = ["A", "B", "C",
Reference: [Cla94] <author> S.Clayman. </author> <title> Developing and Measuring Parallel Rule-Based Systems in a Functional Programming Environment. </title> <type> PhD Thesis, </type> <institution> Dept. Computer Science, University College London, </institution> <year> 1994. </year>
Reference-contexts: However, we will be keen to experiment with any language that implements an experimental version of Klarlund's graph types. Our work in this area was initially motivated by Clayman's PhD research <ref> [Cla94] </ref> over two years ago; our research is showing promise in at least three of the above areas and we hope very soon to report our progress and achievements in subsequent papers.
Reference: [Hol91] <author> I. Holyer. </author> <title> Functional Programming with Mi-randa. </title> <publisher> Pitman, </publisher> <year> 1991. </year>
Reference-contexts: Here are some alternative representations for the graph in Figure 1: Nodes and Edges Graphs may be represented by a list of nodes and a separate list of edges, thus circumventing the problem of physically connecting edges to nodes. For example, in <ref> [Hol91, page 95] </ref> a graph is represented as a pair containing a list of nodes and a list of edges, where an edge is defined by the values of the two nodes which it connects (this representation cannot, of course, be used where two or more 1 nodes have the same
Reference: [HPJW + 91] <author> P. Hudak, S.L. Peyton Jones, P. Wadler, B. Boutel, J. Fairbairn, J. Fasel, M.M. Guzman, K. Hammond, J. Hughes, T. Johns-son, D. Kieburtz, R. Nikhil, W. Partain, and J. Peterson. </author> <title> Report on the Programming Language Haskell. A Non-strict, Purely Functional Language., </title> <note> version 1.1 edition, </note> <month> August </month> <year> 1991. </year>
Reference-contexts: If one were asked to use a functional language to construct the directed graph given in Figure 1 then the resulting code might typically resemble: 1 fl During the course of this work David Parrott was supported by a SERC studentship 1 In this paper we choose the Haskell language <ref> [HPJW + 91] </ref> (version 0.41) for our examples. &gt; data Graph a = Node a [Graph a] &gt; &gt; graph::Graph [Char] &gt; graph = node0 &gt; &gt; node0,node1,node2,node3 :: Graph [Char] &gt; node0 = Node "A" [node2, node1] &gt; node1 = Node "B" [node3] &gt; node2 = Node "C" [node0, node3] <p> Arrays If a programmer is lucky enough to have access to a lazy functional language which provides arrays (such as Haskell <ref> [HPJW + 91] </ref>), then it is possible [BY90] to create a virtual heap representation which is potentially highly efficient. &gt; type Index = Int &gt; type Graph a = Array Index (a,[Index]) &gt; &gt; buildgraph::[a]-&gt;[[Index]]-&gt;Graph a &gt; buildgraph vals elist &gt; = listArray (0, (length vals)-1) 2 &gt; (zip vals elist)
Reference: [KL94] <author> David J. King and John Launchbury. </author> <title> Lazy depth-first search and linear graph algorithms in Haskell. </title> <institution> Research Report FP-94-06, Computing Science Department, University of Glasgow, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: = Array Index (a,[Index]) &gt; &gt; buildgraph::[a]-&gt;[[Index]]-&gt;Graph a &gt; buildgraph vals elist &gt; = listArray (0, (length vals)-1) 2 &gt; (zip vals elist) &gt; &gt; nodes = ["A", "B", "C", "D"] &gt; edges = [[2,1],[3],[0,3],[]] &gt; &gt; graph :: Graph [Char] &gt; graph = buildgraph nodes edges King and Launchbury <ref> [KL94] </ref> use Haskell arrays, extended with update-in-place, to represent a graph which supports linear time depth-first search.
Reference: [KS93] <author> N. Klarlund and M.I. Schwartzbach. </author> <title> Graph types. </title> <booktitle> Proceedings of the 20th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 196-205, </pages> <year> 1993. </year>
Reference-contexts: We are extending our graph metaphor to con sider unconnected components, weighted edges, undirected graphs, and graphs with no (or multiple) roots. 6. We are interested in the work of Klarlund <ref> [KS93] </ref>, who suggests that type systems might in future be extended to encompass general-purpose "graph-shaped" user-defined recursive types which contain both values and routing information, and he provides a logic for expressing properties of such types.
Reference: [Rea89] <author> C. Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: = [Char] &gt; type Edge = (Node, Node) &gt; type Graph = ([Node], [Edge]) &gt; &gt; buildgraph :: [Node]-&gt;[Edge]-&gt;Graph &gt; buildgraph ns es = (ns, es) &gt; &gt; nodes = ["A","B","C","D"] &gt; edges = [("A","B"),("A","C"), &gt; ("B","D"),("C","A"),("C","D")] &gt; graph :: Graph &gt; graph = buildgraph nodes edges Functional representation Reade <ref> [Rea89, page 172] </ref> demonstrates how a graph may be represented as a function which maps from a given node to a list of the successors of that node, i.e. a list of the nodes pointed to by the given node: &gt; data Graph a = Agraph (a -&gt; [a]) &gt; &gt;
Reference: [USE] <author> Archives, comp.lang.functional, </author> <title> USENET news group, </title> <type> 1992-95. 10 </type>
References-found: 10

