URL: ftp://ftp.eecs.umich.edu/groups/gasm/staticlink.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: email: mohnen@informatik.rwth-aachen.de  
Title: A Compiler Correctness Proof for the Static Link Technique by means of Evolving Algebras  
Author: Markus Mohnen 
Address: Ahornstrae 55, 52056 Aachen, Germany  
Affiliation: RWTH Aachen, Lehrstuhl fur Informatik II  
Abstract: The well-known static link technique is used for stack-based implementations of imperative programming languages which admit nested recursive procedure declarations. Its basic idea is to access non-local variables by tracing a static link chain to lower stack elements. Evolving algebras are a new method for defining operational semantics of abstract machines. Based on an appropriate stack machine, defined as an evolving algebra, and a functional description of a compiler for a sample language, we give a complete proof of correctness for this technique using the method of refinement.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. G. Baker. </author> <title> Shallow Binding in Lisp 1.5. </title> <journal> Comm. ACM, </journal> <volume> 21(7):565|569, </volume> <year> 1978. </year>
Reference-contexts: - 0 where 0 is the least solution of ( 0 )( 0 ) = 0 (C [](l; ; 0 )); if E [E]( 0 ) 6= 0 C [begin 1 ; : : : ; n end](l; ; ) := C [ n ](l; ; : : : (C <ref> [ 1 ] </ref>(l; ; )) : : :) * B : PLP-Block fi N 0 fi U fi S ( S B [](l; ; ) := reset ( l ; l; C [](l; D [](l; ; ))) with the auxiliary function reset : S fi N 0 fi S ! S <p> 1 ; P 0;2 = 2 ]))(X 0;1 ) = (reset ([]; 0; 1 ([X 0;1 =z])))(X 0;1 ) = (reset ([]; 0; B [B 1 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z])))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; C <ref> [ 1 ] </ref>(1; D [ 1 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z])))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; C [ 1 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0]))))(X 0;1 ) <p> = 2 ]))(X 0;1 ) = (reset ([]; 0; 1 ([X 0;1 =z])))(X 0;1 ) = (reset ([]; 0; B [B 1 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z])))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; C <ref> [ 1 ] </ref>(1; D [ 1 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z])))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; C [ 1 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0]))))(X 0;1 ) = (reset ([]; 0; <p> 1 ; P 0;2 = 2 ]; [X 0;1 =z])))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; C <ref> [ 1 ] </ref>(1; D [ 1 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z])))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; C [ 1 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0]))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; 2 ([X 0;1 =z; X 1;1 =0])))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; B [B 2 ](1; [P 0;1 = <p> 1 len ["] := 0 len [proc P l;1 ; B 1 ; : : : ; P l;n ; B n ; ] := n X len [B j ] len [P l;o ()] := 1 len [if E then 1 else 2 ] := len [E] + len <ref> [ 1 ] </ref> + len [ 2 ] + 2 len [while E do ] := len [E] + len [] + 2 len [begin 1 ; : : : ; n end] := n X len [ j ] The denotational semantics employs an environment to hold information about identifiers. <p> [P l d ;o ](st; l; a) := CALL (ca; l l d ; t) if st (P l d ;o ) = (proc; ca; t) ct [if E then 1 else 2 ](st; l; a) := 2 6 6 et [E](st; l) JMNC a + len [E] + len <ref> [ 1 ] </ref> + 2 ct [ 1 ](st; l; a + len [E] + 1) ct [ 2 ](st; l; a + len [E] + 1) ct [while E do ](st; l; a) := 2 4 JMNC (a + len [E] + len [] + 2) ct [](st; l; a <p> a) := CALL (ca; l l d ; t) if st (P l d ;o ) = (proc; ca; t) ct [if E then 1 else 2 ](st; l; a) := 2 6 6 et [E](st; l) JMNC a + len [E] + len <ref> [ 1 ] </ref> + 2 ct [ 1 ](st; l; a + len [E] + 1) ct [ 2 ](st; l; a + len [E] + 1) ct [while E do ](st; l; a) := 2 4 JMNC (a + len [E] + len [] + 2) ct [](st; l; a + len [E] + 1) ct <p> len [E] + 1) ct [while E do ](st; l; a) := 2 4 JMNC (a + len [E] + len [] + 2) ct [](st; l; a + len [E] + 1) ct [begin 1 ; : : : ; n end](st; l; a) := 2 6 6 ct <ref> [ 1 ] </ref>(st; l; a) . . . n1 P len [ k ]) et : PLP-Exp fi Tab fi N 0 ( SC-Prog et [z](st; l) := LIT z et [E 1 + E 2 ](st; l) := et [E 1 ](st; l) ADD This translation mapping creates the same <p> They are replaced in the shallow machine A SM s by two components CHI (current values) and SS (save stack). Interestingly, on one hand the machine is an implementation of shallow binding introduced in the Seventies in <ref> [1] </ref> in order to decrease the access time for current values, and on the other hand its is suitable best for a proof of equivalence w.r.t. the denotational semantics. The reason is that both shallow machine and denotational semantics handle variables in the same way. <p> It may be interesting to investigate whether there is an alternative notion of equivalence of evolving algebras without this flaw. Acknowledgements I would like to thank the unknown referees for pointing out the necessity of an additional refinement step and the reference to <ref> [1] </ref>.
Reference: [2] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM | Definition and Compiler Correctness. </title> <type> Technical Report TR-14/92, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: : PLP-Cmd fi N 0 fi U fi S ( S C [X k;o := E](l; ; ) := [X k;o =E [E]()]; if (X k;o ) defined C [P k;o ()](l; ; ) := ((P k;o ))() C [if E then 1 else 2 ](l; ; ) := C <ref> [ 2 ] </ref>(l; ; ); if E [E]() = 0 C [while E do | -z - 0 where 0 is the least solution of ( 0 )( 0 ) = 0 (C [](l; ; 0 )); if E [E]( 0 ) 6= 0 C [begin 1 ; : : : <p> ([X 0;1 =z; X 1;1 =0])))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; B [B 2 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0])))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; reset ([X 1;1 =0]; 1; C <ref> [ 2 ] </ref>(1; D [ 2 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0]))))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; reset ([X 1;1 =0]; 1; C [ 2 ]([P 0;1 = 1 ; P 0;2 = 2 ]; [X <p> 1;1 =0])))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; B [B 2 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0])))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; reset ([X 1;1 =0]; 1; C <ref> [ 2 ] </ref>(1; D [ 2 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0]))))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; reset ([X 1;1 =0]; 1; C [ 2 ]([P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 <p> (reset ([]; 0; reset ([]; 1; reset ([X 1;1 =0]; 1; C <ref> [ 2 ] </ref>(1; D [ 2 ](1; [P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0]))))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; reset ([X 1;1 =0]; 1; C [ 2 ]([P 0;1 = 1 ; P 0;2 = 2 ]; [X 0;1 =z; X 1;1 =0])))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; reset ([X 1;1 =0]; 1; [X 0;1 =z; X 1;1 =1]))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; [X 0;1 =z; X <p> The pair hA; fii satisfies a formula F iff e fi (F ) = 1. In this case, we say that hA; fii is a model for F and we write hA; fii j= F . There are some differences between the definition of evolving algebras in <ref> [2] </ref> and ours: * We only allow function updates for the description of the dynamic behaviour of evolving algebras. We do not consider universe extension or universe contraction to be useful, because in the examples of evolving algebras (Modula-2 fl [6], WAM [2]) these concepts are used for the design of <p> differences between the definition of evolving algebras in <ref> [2] </ref> and ours: * We only allow function updates for the description of the dynamic behaviour of evolving algebras. We do not consider universe extension or universe contraction to be useful, because in the examples of evolving algebras (Modula-2 fl [6], WAM [2]) these concepts are used for the design of memory allocation. In our opinion this should be part of the abstract machine and not part of the meta-language. * Since we use a typed signature, we do not need integrity constraints. <p> First, we have to describe the signature SM = (S SM ; SM ): 2 Note that there is no connection between the initial conditions of an EA and initial algebras. 3 This is different to the behaviour in <ref> [2] </ref>, where non-determinism is achieved by different rules, applicable at the same time. <p> len [proc P l;1 ; B 1 ; : : : ; P l;n ; B n ; ] := n X len [B j ] len [P l;o ()] := 1 len [if E then 1 else 2 ] := len [E] + len [ 1 ] + len <ref> [ 2 ] </ref> + 2 len [while E do ] := len [E] + len [] + 2 len [begin 1 ; : : : ; n end] := n X len [ j ] The denotational semantics employs an environment to hold information about identifiers. <p> (P l d ;o ) = (proc; ca; t) ct [if E then 1 else 2 ](st; l; a) := 2 6 6 et [E](st; l) JMNC a + len [E] + len [ 1 ] + 2 ct [ 1 ](st; l; a + len [E] + 1) ct <ref> [ 2 ] </ref>(st; l; a + len [E] + 1) ct [while E do ](st; l; a) := 2 4 JMNC (a + len [E] + len [] + 2) ct [](st; l; a + len [E] + 1) ct [begin 1 ; : : : ; n end](st; l; a)
Reference: [3] <author> E. Fehr. </author> <title> Semantik von Programmiersprachen (in German). </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: (10.5) to b = a 1 and conclude C [P l i ;o i ()](l; ; ) = l i ;o i = P;a 1 ;a 1 +1 The remaining cases (the induction step, actually) are just proofs of correctness of standard implementations, and can be found for instance in <ref> [3] </ref>. q.e.d. The next aim is to extend this result to the translation of blocks.
Reference: [4] <author> Y. Gurevich. </author> <title> Logic and the Challenge of Computer Science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Trends in Theoretical Computer Science, </booktitle> <pages> 1-57. </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference: [5] <author> Y. Gurevich. </author> <title> Evolving Algebras: A Tutorial Introduction. </title> <journal> Bulletin of the EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year>
Reference-contexts: 1; [X 0;1 =z; X 1;1 =1]))))(X 0;1 ) = (reset ([]; 0; reset ([]; 1; [X 0;1 =z; X 1;1 =0])))(X 0;1 ) = (reset ([]; 0; [X 0;1 =z]))(X 0;1 ) = ([X 0;1 =z])(X 0;1 ) 2 Evolving Algebras The concept of evolving algebras was introduced in <ref> [5] </ref> as a method for describing operational semantics. An evolving algebra is the description of a transition system, where the states are algebras over a (first-order) signature. Each state holds the information for a single step of the computation.
Reference: [6] <author> Y. Gurevich and J. M. Morris. </author> <title> Algebraic Operational Semantics and Modula-2 fl . In E. </title> <editor> Borger, H. Buning, and M. M. Richter, editors, </editor> <booktitle> 1st Workshop on Computer Science Logic, </booktitle> <volume> CSL '87, LNCS 329 </volume> <pages> 81-101. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: We do not consider universe extension or universe contraction to be useful, because in the examples of evolving algebras (Modula-2 fl <ref> [6] </ref>, WAM [2]) these concepts are used for the design of memory allocation. In our opinion this should be part of the abstract machine and not part of the meta-language. * Since we use a typed signature, we do not need integrity constraints.
Reference: [7] <author> W. Henhapl and C. B. Jones. </author> <title> The Block Concept and some Possible Implementations, with Proofs of Equivalence. </title> <type> Technical Report TR 25.104, </type> <institution> IBM Laboratory Vienna, </institution> <year> 1970. </year>
Reference-contexts: But most of it is concerned with the display technique ([9, 10, 11]), which is much easier to be proved correct 1 . A proof of the static-link technique with respect to an operational semantics can be found in <ref> [7] </ref> where the `Twin-Machine' technique is used. The idea is to construct a machine with two independent mechanisms for storage access, representing the operational semantics resp. the static-link technique and to prove that both are equivalent for each state of the machine.
Reference: [8] <author> K. Indermark. </author> <title> Functional Compiler Description. </title> <booktitle> Mathematical Problems in Computation Theory, </booktitle> <volume> 21 </volume> <pages> 257-275, </pages> <publisher> Banach Center Publications, </publisher> <year> 1988. </year>
Reference-contexts: It abstracts from data types and data structures. However, it is block-structured and contains nested procedure declarations. Hence, for static scope semantics the corresponding abstract machine has to deal with static link chains. The proof is based on the functional compiler description in <ref> [8] </ref>. 1 The reason for this is that variables and linking-information are stored in different parts of the storage. Activation records are not linked, but there is a display which contains a direct link to the appropriate activation record for each possible level. <p> The naming restrictions enable us to drop the concept of location, which is otherwise needed to ensure the static scope semantics for variables. In fact, dynamic scope and static scope with these naming conventions. One can prove that this semantics delivers the same results as the semantics given in <ref> [8] </ref>. First, we have to define the semantic domains on which the semantic functions operate: * S := f jj : VIde ( Zg the set of states, which hold the values of variables. <p> It constructs an SC-program from a given PLP-program, i.e. it is a PLP-compiler. We present a slightly modified version of the translation mapping of <ref> [8] </ref>: (i) we do not need to record the current level in the symbol table, because the identifiers themselves contain this information. (ii) we do not use symbolic addresses for jumps, in order to avoid the second compilation phase. <p> . . n1 P len [ k ]) et : PLP-Exp fi Tab fi N 0 ( SC-Prog et [z](st; l) := LIT z et [E 1 + E 2 ](st; l) := et [E 1 ](st; l) ADD This translation mapping creates the same code as the one in <ref> [8] </ref>.
Reference: [9] <author> C. B. Jones and P. Lucas. </author> <title> Proving Correctness of Implementation Techniques. </title> <editor> In B. Eckmann A. Dold, editor, </editor> <booktitle> Symposium on Semantics of Algorithmic Languages, Lecture Notes in Mathematics 188. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference: [10] <author> R. Milne and C. Strachey. </author> <title> A theory of programming language semantics. </title> <publisher> Chapman and Hall, </publisher> <year> 1976. </year>
Reference: [11] <author> W. Polak. </author> <title> Compiler Specification and Verification. </title> <publisher> LNCS 124. Springer-Verlag, </publisher> <year> 1981. </year>
Reference: [12] <author> W. Wechler. </author> <title> Universal Algebra for Computer Scientists, </title> <booktitle> volume 25 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: ]; ); where ( 1 ; : : : ; n ) is the least solution of i = B [B i ](l + 1; [P l;1 = 1 ; : : : ; P l;n = n ]) (1.1) Note, that with the Fixpoint-theorem of Knaster and Tarski (cf. <ref> [12] </ref>), we can give an alternative characterisation of (1.1): ( 1 ; : : : ; n ) = fS k where we define the transformation S : C n ( C n by (S ( 0 n )) i := B [B i ](l + 1; [P l;1 = 0
Reference: [13] <author> N. Wirth. </author> <note> Compilerbau (in German). Teubner Studienbucher Informatik, 3rd edition, </note> <year> 1984. </year>
Reference-contexts: In this paper, we present a proof for the correctness of the static-link technique with respect to a denotational semantics in the context of a subset of PASCAL. We have chosen the subset presented in <ref> [13] </ref>. PLP (Programming Language with Procedures) is simple enough to allow the proof, but not trivial. It abstracts from data types and data structures. However, it is block-structured and contains nested procedure declarations. Hence, for static scope semantics the corresponding abstract machine has to deal with static link chains.
References-found: 13

