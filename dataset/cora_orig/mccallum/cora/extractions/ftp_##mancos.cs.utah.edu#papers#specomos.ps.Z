URL: ftp://mancos.cs.utah.edu/papers/specomos.ps.Z
Refering-URL: ftp://mancos.cs.utah.edu/papers/specomos.html
Root-URL: 
Email: fdbo,lepreau,lawg@cs.utah.edu  
Title: Program Specialization Using the OMOS System  
Author: Douglas B. Orr Jay Lepreau Jeffrey Law 
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah  
Abstract: Technical Report UUCS-95-016 March, 1995 Abstract Abstraction and modularity provide many software engineering benefits. Hiding details of module internals can, however, prevent system implementors from being able to provide anything but a highly general implementation of a given module. We describe OMOS, a programmable linker/loader and system server that manages module implementations. OMOS allows system builders to describe system architectures in high-level terms, via a module construction scripting language. Using scripts, system implementors can provide modules that can test and react to both their static and run time environments. These modules, which we refer to as electric libraries, can produce implementations that are optimized at link or run time, without sacrificing modularity, expanding interfaces, or requiring changes in client programs. We identify and implement three types of specializations that OMOS can perform, and quantify the impact of two of them on a few standard Unix utilities: performance improvements ranged from 6% to 47%. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Bracha. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <pages> 143 pp. </pages>
Reference-contexts: These operations are based on a formal model described in the Jigsaw language <ref> [1, 2] </ref>, that provides a basis for relating modularity and inheritance. Higher-level (and more sophisticated) module manipulation, such as is done in a module specification, are implemented with Scheme scripts. With its extension language, OMOS can perform arbitrary transformations on modules.
Reference: [2] <author> G. Bracha and G. Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, April 20-23 1992. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: These operations are based on a formal model described in the Jigsaw language <ref> [1, 2] </ref>, that provides a basis for relating modularity and inheritance. Higher-level (and more sophisticated) module manipulation, such as is done in a module specification, are implemented with Scheme scripts. With its extension language, OMOS can perform arbitrary transformations on modules.
Reference: [3] <author> P. Cao, E. W. Felten, and K. Li. </author> <title> Implementation and performance of application-controlledfile caching. </title> <booktitle> In Proc. of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 165-177, </pages> <address> Monterey, CA, Nov. 1994. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: In particular, in Cao's work <ref> [3] </ref> on informing the OS so it can use more appropriate buffer management strategies, we have an area where our transparent approach will likely apply and show significant performance benefits. 4 The entire source and binaries for a stable version of OMOS, running on the Mach kernel and Lites Unix server,
Reference: [4] <author> S. Chamberlain. </author> <title> The Binary File Descriptor Library. Cygnus Support, </title> <address> Palo Alto, CA, </address> <year> 1992. </year> <title> In FSF binutils distribution; Copyright Free Software Foundation. </title>
Reference-contexts: OMOS runs on Mach 3.0, with both the OSF/1 and CMU server-based Unix implementations, and on both the HP PA-RISC and Intel x86 platforms. To manipulate object files, OMOS uses the GNU BFD <ref> [4] </ref> object file library to provide it with a high degree of independence from low level object format details. OMOS's abstract persistent store, used to cache linked modules, is currently implemented using the Unix file system.
Reference: [5] <author> J. B. Chen and B. N. Bershad. </author> <title> The impact of operating system structure on memory system performance. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 120-133, </pages> <year> 1993. </year>
Reference-contexts: In the server-based versions of Unix implemented on top of Mach, there is a penalty that is paid for accesses to the Unix server; it has been demonstrated that, on average, system calls in a server-based world require more processing than equivalent system calls in traditional in-kernel implementations <ref> [5] </ref>. Passing information between protection domains in messages involves additional work than when using straightforward trap-based system calls. So, to improve performance, we seek out mechanisms that, among other things, permit us to circumvent the Unix server.
Reference: [6] <editor> W. Clinger and J. Rees. </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <journal> ACM Lisp Pointers, </journal> <volume> 4(3), </volume> <year> 1991. </year>
Reference-contexts: If not, OMOS evaluates the module specification, producing an implementation; typically, it caches the result (on disk) and returns a pointer to that implementation. OMOS uses the STk [8] implementation of Scheme <ref> [6] </ref> as an extension/scripting language.
Reference: [7] <author> P. Druschel. </author> <title> Efficient support for incremental customization of OS services. </title> <booktitle> In Proc. Third Interna--tional Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 186-190, </pages> <address> Asheville, NC, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: One approach to solve the above problems is open implementations systems whose implementations are customizable via external means is an active area of research <ref> [15, 7, 21] </ref>. Different approaches to customization have been taken. Customizing an open implementation can involve such diverse tradeoffs as whether to build implementation-specific information into clients or service providers, expand interfaces, or perform customizations statically or dynamically.
Reference: [8] <author> E. Gallesio. </author> <title> Embedding a Scheme interpreter in the Tk toolkit. </title> <editor> In L. A. Rowe, editor, </editor> <booktitle> First Tcl/Tk Workshop, Berkeley, </booktitle> <pages> pages 103-109, </pages> <month> June </month> <year> 1993. </year> <note> Included in ftp://kaolin.unice.fr/pub/STk-2.1.6.tar.gz. </note>
Reference-contexts: If not, OMOS evaluates the module specification, producing an implementation; typically, it caches the result (on disk) and returns a pointer to that implementation. OMOS uses the STk <ref> [8] </ref> implementation of Scheme [6] as an extension/scripting language.
Reference: [9] <author> R. A. Gingell, M. Lee, X. T. Dang, and M. S. Weeks. </author> <title> Shared libraries in SunOS. </title> <booktitle> In Proc. of the Summer 1987 USENIX Conference, </booktitle> <pages> pages 131-145, </pages> <address> Phoenix, AZ, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: On the SunOS and VR4 operating systems, some crude run time control is available by modifying the LDPATH and LD PRELOAD environment variables to modify the order in which libraries are searched <ref> [9] </ref>. The problems with these approaches are two fold: (i) they offer only a coarse granularity of control, and (ii), the system has been forced to export some knowledge of its implementation to application builders, setting their expectations and constraining system development.
Reference: [10] <author> D. Grunwald and B. Zorn. </author> <title> Customalloc: Efficient synthesized memory allocators. </title> <journal> Software Practice and Experience, </journal> <pages> pages 851-869, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: Weighting allocations towards commonly used block sizes, or towards coalescing, or towards deallocat-ing free blocks, are all examples of optimizations important to some applications. We have found, as have others <ref> [10] </ref>, that adding just a little code to choose effective strategies for malloc clients that don't fit the common case, expands the simple code path and significantly hurts the performance of all other applications.
Reference: [11] <author> Hewlett-Packard. </author> <title> HP-UX Release 8.x Manual Set, </title> <year> 1990. </year>
Reference-contexts: Users specify, at the level of the application build environment, what functionality they want, by choosing implementations from different libraries. HP-UX does this with malloc: they offer an alternate bsdmalloc library which attains speed at the expense of space <ref> [11] </ref>. On the SunOS and VR4 operating systems, some crude run time control is available by modifying the LDPATH and LD PRELOAD environment variables to modify the order in which libraries are searched [9].
Reference: [12] <author> A. V. K. Krueger, D. Loftesness and T. Anderson. </author> <title> Tools for the development of application-specific virtual memory management. </title> <booktitle> In Proc. of ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Some of the most recent VM work, which takes a more incremental approach than, for example, external pagers, is that by Anderson et al <ref> [12] </ref>: the OS makes upcalls to user code which directs the OS how to manage individual pages on its behalf.
Reference: [13] <author> G. Kiczales. </author> <title> Foil for the workshop on open implementation. </title> <address> http://www.xerox.com/PARC/spl/eca/- oi/workshop-94/default.html, </address> <year> 1994. </year>
Reference-contexts: Two important parameters are whether implementation information is couched in imperative or declarative form, and whether that information is directive or merely informative, i.e., whether the application is telling the system what to do to support its needs, or just disclosing what the application is doing <ref> [13] </ref>. Patterson and Gibson [21] make a strong argument that disclosure is superior in the operating system environment.
Reference: [14] <author> G. Kiczales, J. des Rivieres, and D. G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Meta-object Protocols <ref> [14] </ref> take an imperative, directive approach to customizing implementations. That work was first applied in the compiler domain, where the compiler implementation was customizable by users.
Reference: [15] <author> G. Kiczales and J. </author> <title> Lamping. </title> <booktitle> Operating systems: Why object-oriented? In Proc. Third International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 25-30, </pages> <address> Asheville, NC, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: One approach to solve the above problems is open implementations systems whose implementations are customizable via external means is an active area of research <ref> [15, 7, 21] </ref>. Different approaches to customization have been taken. Customizing an open implementation can involve such diverse tradeoffs as whether to build implementation-specific information into clients or service providers, expand interfaces, or perform customizations statically or dynamically. <p> OMOS could do this quite easily, due to its mediating role in program invocation, its active nature, its detailed knowledge of object files, and its powerful module manipulation primitives. 8 Related Work The approach of using open implementations <ref> [15] </ref> to avoid the performance and flexibility limitations of so-called black-box abstractions has recently received a lot of attention. Meta-object Protocols [14] take an imperative, directive approach to customizing implementations. That work was first applied in the compiler domain, where the compiler implementation was customizable by users.
Reference: [16] <author> C. Maeda and B. N. Bershad. </author> <title> Protocol service decomposition for high-performance networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-255, </pages> <year> 1993. </year>
Reference-contexts: The majority of the OS open implementation research has been focused on the operating system proper itself. We believe our approach of specializing the user-space library, extracting semantic information from application's symbolic names, and adding external annotations to the application when needed, is unique. Maeda's work <ref> [16] </ref> on user-space implementation of network protocols is related to our I/O library examples, in that responsibility is shared with the kernel.
Reference: [17] <institution> Open Systems Foundation and Carnegie Mellon Univ. </institution> <note> OSF MACH Kernel Principles, </note> <year> 1993. </year>
Reference-contexts: Should mallopt, or the equivalent, cease to be the correct approach to optimize a service, the provider is free to change its approach as needed. 4 The Design of OMOS The work described in this paper used OMOS running on a Mach 3.0 <ref> [17] </ref> system which provides Unix emulation through a Unix server process. OMOS is used by the Unix server to load programs and shared libraries. OMOS has also run on standard Unix systems, such as HP-UX, where we studied more conventional aspects of OMOS's shared-library service [18].
Reference: [18] <author> D. B. Orr, J. Bonn, J. Lepreau, and R. Mecklenburg. </author> <title> Fast and flexible shared libraries. </title> <booktitle> In Proc. of the Summer 1993 USENIX Conference, </booktitle> <pages> pages 237-251, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Our approach to solve the problems is OMOS, a fully programmable linker/loader and persistent server, that fills the roles taken by the linker, loader, shared library support, and exec operating system service in a traditionally structured system <ref> [20, 19, 18] </ref>. OMOS also provides the means to construct programs that are specialized to their expected operational conditions. This is done in two ways: by inferring operational characteristics from the symbolic names found in modules, or absent from them (implicit disclosure), and by explicit disclosure through annotations. <p> OMOS is used by the Unix server to load programs and shared libraries. OMOS has also run on standard Unix systems, such as HP-UX, where we studied more conventional aspects of OMOS's shared-library service <ref> [18] </ref>. OMOS provides a level of indirection between a module name and its implementation. In most operating systems, programs or dynamically loaded modules are implemented using files. As a result, the system has little or no control over their implementation: their nature is fixed at install time. <p> OMOS currently consists of approximately 17,000 lines of code, excluding STk (11,000 lines) and the BFD library. 4 In prior work in an earlier version of OMOS that lacked a full scripting language, we demonstrated that OMOS's shared library services are fast and flexible <ref> [18] </ref>. Other work demonstrated that OMOS could provide transparent call-graph profiling and re-ordering of executables at the granularity of functions, providing speedup due to improved code locality [20].
Reference: [19] <author> D. B. Orr and R. W. Mecklenburg. </author> <title> OMOS an object server for program execution. </title> <booktitle> In Proc. Second International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 200-209, </pages> <address> Paris, France, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Our approach to solve the problems is OMOS, a fully programmable linker/loader and persistent server, that fills the roles taken by the linker, loader, shared library support, and exec operating system service in a traditionally structured system <ref> [20, 19, 18] </ref>. OMOS also provides the means to construct programs that are specialized to their expected operational conditions. This is done in two ways: by inferring operational characteristics from the symbolic names found in modules, or absent from them (implicit disclosure), and by explicit disclosure through annotations.
Reference: [20] <author> D. B. Orr, R. W. Mecklenburg, P. J. Hoogenboom, and J. Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. </title> <booktitle> In Proc. of the 26th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 232-241, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Our approach to solve the problems is OMOS, a fully programmable linker/loader and persistent server, that fills the roles taken by the linker, loader, shared library support, and exec operating system service in a traditionally structured system <ref> [20, 19, 18] </ref>. OMOS also provides the means to construct programs that are specialized to their expected operational conditions. This is done in two ways: by inferring operational characteristics from the symbolic names found in modules, or absent from them (implicit disclosure), and by explicit disclosure through annotations. <p> Other work demonstrated that OMOS could provide transparent call-graph profiling and re-ordering of executables at the granularity of functions, providing speedup due to improved code locality <ref> [20] </ref>.
Reference: [21] <author> R. H. Patterson and G. A. Gibson. </author> <title> Exposing I/O concurrency with informed prefetching. </title> <booktitle> In Proc. Third Intl. Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 28-30, </pages> <address> Austin, TX, </address> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: One approach to solve the above problems is open implementations systems whose implementations are customizable via external means is an active area of research <ref> [15, 7, 21] </ref>. Different approaches to customization have been taken. Customizing an open implementation can involve such diverse tradeoffs as whether to build implementation-specific information into clients or service providers, expand interfaces, or perform customizations statically or dynamically. <p> Patterson and Gibson <ref> [21] </ref> make a strong argument that disclosure is superior in the operating system environment. <p> By contrast, in the I/O domain, the work on Transparent Informed Prefetching <ref> [21] </ref> uses disclosure of information about an application's pattern of I/O use to allow the underlying system to pre-fetch file data. The majority of the OS open implementation research has been focused on the operating system proper itself.
Reference: [22] <author> J. Rees, P. Levine, N. Mishkin, and P. Leach. </author> <title> An extensible I/O system. </title> <booktitle> In Proc. of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 114-125, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Maeda's work [16] on user-space implementation of network protocols is related to our I/O library examples, in that responsibility is shared with the kernel. The Apollo type manager implementation <ref> [22] </ref> is an example of a file descriptor-based system for doing Unix I/O, implemented largely in user-space, communicating to the OS only when security requirements dictated. 9 Future Work We plan to apply our work to other domains besides reducing copying by user space I/O libraries.
Reference: [23] <author> D. M. Ritchie and K. Thompson. </author> <title> The UNIX time-sharing system. </title> <journal> The Bell System Technical Journal, </journal> <volume> 57(6) </volume> <pages> 1905-1930, </pages> <month> July/August </month> <year> 1978. </year> <month> 16 </month>
Reference-contexts: These interfaces required the application programmer to specify a great deal about the data to be used by their program, rendering it difficult to take advantage of underlying 2 commonalities in different data types. Focus changed as operating systems evolved. The Unix <ref> [23] </ref> operating system was an example of a significant departure in the nature of interfaces, due, in part, to its use of a simple, universal I/O interface. Under Unix, files and devices are both assigned entries in a common namespace and accessed via a small set of operations.
Reference: [24] <author> M. T. Stolarchuk. </author> <title> Faster AFS. </title> <booktitle> In Proc. of the Winter 1993 USENIX Conference, </booktitle> <pages> pages 67-75, </pages> <address> San Diego, CA, </address> <year> 1993. </year> <month> 17 </month>
Reference-contexts: Inserting code in this path (such as would be required for monitoring or metering to intuit application intent) risks significantly affecting the performance of programs that work within the common-case parameters of read <ref> [24] </ref>. 2.2 Example: Memory Allocation Interfaces Storage allocators are also good examples of facilities that must strike a delicate balance. In most implementations of the Unix library storage allocator (malloc), the operation to allocate storage (malloc), takes just a few instructions when an appropriately-sized block is available.
References-found: 24

