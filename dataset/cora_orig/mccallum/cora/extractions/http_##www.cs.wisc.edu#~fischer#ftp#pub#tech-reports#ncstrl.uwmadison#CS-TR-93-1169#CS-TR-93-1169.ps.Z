URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1169/CS-TR-93-1169.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1169/
Root-URL: http://www.cs.wisc.edu
Title: THE USE OF CONTROL-FLOW AND CONTROL DEPENDENCE IN SOFTWARE TOOLS  
Author: by THOMAS JAUDON BALL 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Sciences) at the UNIVERSITY OF WISCONSINMADISON  
Date: 1993  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> A. Aho, R. Sethi, and J. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: INTRODUCTION Program development, debugging, and maintenance can be greatly improved by the use of software tools that provide information about program behavior. This thesis focuses on a number of useful software tools and shows how their efficiency, generality, and precision can be increased through the use of control-flow <ref> [1] </ref> and control dependence analysis [17]. We consider two classes of tools: execution measurement tools, which dynamically collect information about a particular execution of a program; and program analysis tools, which provide information about potential program behavior by statically analyzing the program. <p> First, a depth-first search of the CFG from its root vertex identifies backedges in the CFG. The heuristic uses a topological traversal of the backedge-free graph of the CFG to compute the weighting. The weighting algorithm uses natural loops to identify loops and loop-exit edges <ref> [1] </ref>. The natural loop of a backedge x fi y is defined as follows: 39 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh if ( P && ( Q || R )) R Q EXIT 1 0.5 0.125 0.125 (a) X P EXIT 1 3 5 5 4 3 6 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh edge counter placement (black dots). <p> Our algorithm works for programs with completely arbitrary control-flow, including irreducible control-flow <ref> [1] </ref>. Algorithms for slicing programs with structured control-flow have been defined by Weiser [71] and by the Ottensteins [52]. Neither of these algorithms works correctly for programs with unstructured control-flow. <p> Equivalently, G is reducible iff any depth-first search of G identifies the same set of edges as backedges. There are many other equivalent characterizations of reducibility <ref> [1] </ref>. The second property of normal-form CFGs is that each loop in the CFG must be in the form of a while loop. We use the concept of natural loop [1] to define the structure of a while loop: DEFINITION (natural loop). <p> There are many other equivalent characterizations of reducibility <ref> [1] </ref>. The second property of normal-form CFGs is that each loop in the CFG must be in the form of a while loop. We use the concept of natural loop [1] to define the structure of a while loop: DEFINITION (natural loop). The natural loop of a backedge v fi w is defined to be nat-loop (v fi w) = - w - - x | there is a w-free path from x to v -. <p> Second, procedure OrderByControl adds ordering edges to P M , as necessitated by control dependences (Section 7.2.4.1). Third, procedure OrderByFlow adds ordering edges to hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function Reconstitute (P M : PDG):CFG or FAIL begin <ref> [1] </ref> P M := P M [2] if OrderByControl (P M ) fails then return (FAIL) fi [3] if OrderByFlow (P M ) fails then return (FAIL) fi [4] M := ConstructCFG (P M ) [5] if OPDG (M) P M then return (FAIL) fi [6] return (M) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 129 <p> Furthermore, for any two (a,b) pairs (call them (c,d) and (e, f)) such that c and e are in R i and d and f are in R j , property OrderFixed implies that 133 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure OrderByControl (P: PDG) C: the control dependence subgraph of P begin <ref> [1] </ref> for each pair of regions (R i ,R j ) spanned by an (a,b) pair do [2] apply property OrderFixed to (a,b) to order all (a,b) pairs that span R i and R j [3] od [4] for each region R = - r 1 . . . r n <p> All vertices in R are marked to ensure that hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure OrderByFlow ( P:PDG ) P c : a copy of P C: the control dependence subgraph of P c begin <ref> [1] </ref> unmark all vertices in C [2] for each unmarked vertex v in a bottom-up traversal of C's dominator tree do [3] let R be the region containing v [4] R = R - y | y R and y / DomReach (C) - [5] w = v's parent in C's <p> Recall that the second vertex in the call to DFS is always the immediate postdominator of the first. DFS is initially invoked (line <ref> [1] </ref>) with the call DFS (ENTRY,EXIT). Since CLIST (ENTRY,F) is empty, the edge ENTRY fi F EXIT is made (line [2]). The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line [3]). <p> The edge 1 fi F 4 is added because 4 is the first vertex in CLIST (1,F). iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Some CLISTs Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) <ref> [1] </ref> DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi
Reference: 2. <author> B. Baker, </author> <title> An algorithm for structuring flow graphs, </title> <editor> J. </editor> <booktitle> ACM 24(1) pp. </booktitle> <address> 98-120 New York, NY, </address> <month> (January </month> <year> 1977). </year>
Reference-contexts: For example, given a program P with standard CFG G, one could construct the minimal flow/path-projection of G with respect to some vertex (using backwards-closure in the PDG to identify the required vertices) and then synthesize a program from that CFG using a structuring algorithm such as Baker's <ref> [2] </ref>. However, in a language with unstructured control-flow, there can be many programs with the same CFG. <p> Second, procedure OrderByControl adds ordering edges to P M , as necessitated by control dependences (Section 7.2.4.1). Third, procedure OrderByFlow adds ordering edges to hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function Reconstitute (P M : PDG):CFG or FAIL begin [1] P M := P M <ref> [2] </ref> if OrderByControl (P M ) fails then return (FAIL) fi [3] if OrderByFlow (P M ) fails then return (FAIL) fi [4] M := ConstructCFG (P M ) [5] if OPDG (M) P M then return (FAIL) fi [6] return (M) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 129 P M , as necessitated by <p> and e are in R i and d and f are in R j , property OrderFixed implies that 133 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure OrderByControl (P: PDG) C: the control dependence subgraph of P begin [1] for each pair of regions (R i ,R j ) spanned by an (a,b) pair do <ref> [2] </ref> apply property OrderFixed to (a,b) to order all (a,b) pairs that span R i and R j [3] od [4] for each region R = - r 1 . . . r n do [5] last := - r i | r i / DomReach (C) - [6] if |last| <p> The vertices of the PDG are visited by a bottom up traversal of the control dependence subgraph's dominator tree (line <ref> [2] </ref>). 6 If v is the current vertex in the traversal, then R is the region enclosing v. <p> All vertices in R are marked to ensure that hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure OrderByFlow ( P:PDG ) P c : a copy of P C: the control dependence subgraph of P c begin [1] unmark all vertices in C <ref> [2] </ref> for each unmarked vertex v in a bottom-up traversal of C's dominator tree do [3] let R be the region containing v [4] R = R - y | y R and y / DomReach (C) - [5] w = v's parent in C's dominator tree (i.e., w is v's <p> Recall that the second vertex in the call to DFS is always the immediate postdominator of the first. DFS is initially invoked (line [1]) with the call DFS (ENTRY,EXIT). Since CLIST (ENTRY,F) is empty, the edge ENTRY fi F EXIT is made (line <ref> [2] </ref>). The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line [3]). Since 5 follows 1 in CLIST (ENTRY,T), 5 is passed down as the immediate postdominator of 1 in the call DFS (1,5) (line [4]). <p> edge 1 fi F 4 is added because 4 is the first vertex in CLIST (1,F). iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Some CLISTs Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) <ref> [2] </ref> add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] <p> Ultimately, one would like integration to produce a program (and perhaps one that resembles the source programs as much as possible). One could use a structuring algorithm such as Baker's to produce a program from the CFG <ref> [2] </ref>, but there is no guarantee that this program will resemble the source programs.
Reference: 3. <author> T. Ball, S. Horwitz, and T. Reps, </author> <title> Correctness of an algorithm for reconstituting a program from a dependence graph, </title> <type> Technical Report #947, </type> <institution> Computer Sciences Department, University of Wisconsin - Madison, Madison, </institution> <address> WI (July 1990). </address>
Reference-contexts: We refer to this process as reconstitution. We have shown that a reconstitution algorithm 5 for a language with structured control-flow is correct <ref> [3] </ref>. The difficult part of this algorithm is to order the program statements to preserve data dependences. With the introduction of more complex control-flow into a language, the reconstitution process becomes more complex, as control dependences must be taken into account when ordering the statements of the merged program. <p> Third, procedure OrderByFlow adds ordering edges to hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function Reconstitute (P M : PDG):CFG or FAIL begin [1] P M := P M [2] if OrderByControl (P M ) fails then return (FAIL) fi <ref> [3] </ref> if OrderByFlow (P M ) fails then return (FAIL) fi [4] M := ConstructCFG (P M ) [5] if OPDG (M) P M then return (FAIL) fi [6] return (M) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 129 P M , as necessitated by flow dependences (Section 7.2.4.2). <p> that 133 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure OrderByControl (P: PDG) C: the control dependence subgraph of P begin [1] for each pair of regions (R i ,R j ) spanned by an (a,b) pair do [2] apply property OrderFixed to (a,b) to order all (a,b) pairs that span R i and R j <ref> [3] </ref> od [4] for each region R = - r 1 . . . r n do [5] last := - r i | r i / DomReach (C) - [6] if |last| &gt; 1 then [7] return (FAIL) [8] else if |last| = 1 then [9] let x be the <p> The ordering requirements imposed by flow dependences in the presence of complex control dependence are quite similar to the structured case, in which the control dependence subgraph is a tree <ref> [3] </ref>. To understand the operation of procedure OrderByFlow it is necessary to give some more details about regions of control dependence. Suppose that region R contains the vertices -r 1 . . . r n -. Let R be the subset of vertices in R that are in DomReach (C). <p> in R are marked to ensure that hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure OrderByFlow ( P:PDG ) P c : a copy of P C: the control dependence subgraph of P c begin [1] unmark all vertices in C [2] for each unmarked vertex v in a bottom-up traversal of C's dominator tree do <ref> [3] </ref> let R be the region containing v [4] R = R - y | y R and y / DomReach (C) - [5] w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) [6] in [7] mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R <p> Without this condition, the ordering rule would add the edge d 1 fi or d 2 even though d 2 fi or d 1 already existed, creating a cycle. Procedure PreserveSpans operates in our algorithm exactly as in the algorithm for the structured case <ref> [3] </ref>, but uses our updated rule for ordering dependent spans. <p> If a cycle is introduced in the ordering edges during this process, PreserveSpans backtracks to the most recent choice point and tries the other choice. If all choices lead to a cycle then PreserveSpans fails. Ball, Horwitz, and Reps proved the correctness of this approach <ref> [3] </ref>. 7.2.4.2.3. Procedure ProjectInfo Procedure ProjectInfo projects flow edges with one or more endpoints inside region R to the vertex w in the control dependence subgraph C that dominates the vertices in R. <p> DFS is initially invoked (line [1]) with the call DFS (ENTRY,EXIT). Since CLIST (ENTRY,F) is empty, the edge ENTRY fi F EXIT is made (line [2]). The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line <ref> [3] </ref>). Since 5 follows 1 in CLIST (ENTRY,T), 5 is passed down as the immediate postdominator of 1 in the call DFS (1,5) (line [4]). <p> because 4 is the first vertex in CLIST (1,F). iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Some CLISTs Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT <ref> [3] </ref> add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] <p> In fact, when the control dependence subgraph is a tree there are no ordering constraints imposed by control dependences. The correctness of the simplified reconstitution algorithm was proved correct by Ball, Horwitz, and Reps <ref> [3] </ref>. In contrast, our algorithm must deal with ordering constraints imposed by control dependences as well as flow dependences.
Reference: 4. <author> T. Ball and J. R. Larus, </author> <title> Optimally profiling and tracing programs, </title> <booktitle> Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Albuquerque, NM, </address> <month> January 19-22, </month> <year> 1992), </year> <pages> pp. 59-70 ACM, </pages> <year> (1992). </year>
Reference-contexts: A straightforward approach is to prepend code to each basic block B that increments the event counter by Events (B ) each time that block B executes. This approach can incur high overhead (in the range of 200-300%) for programs with small basic blocks <ref> [4] </ref>. Furthermore, if instrumentation code is dynamically added to and deleted from programs by patching a basic block with a jump to a code stub rather than by rewriting the original code, the over head can increase substantially [39]. <p> RELATED WORK As discussed in Chapter 3, there are a number of works on the related topic of efficiently profiling programs with instrumentation <ref> [4, 24, 40, 41, 55, 63, 64] </ref>. <p> Third, procedure OrderByFlow adds ordering edges to hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function Reconstitute (P M : PDG):CFG or FAIL begin [1] P M := P M [2] if OrderByControl (P M ) fails then return (FAIL) fi [3] if OrderByFlow (P M ) fails then return (FAIL) fi <ref> [4] </ref> M := ConstructCFG (P M ) [5] if OPDG (M) P M then return (FAIL) fi [6] return (M) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 129 P M , as necessitated by flow dependences (Section 7.2.4.2). <p> hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh procedure OrderByControl (P: PDG) C: the control dependence subgraph of P begin [1] for each pair of regions (R i ,R j ) spanned by an (a,b) pair do [2] apply property OrderFixed to (a,b) to order all (a,b) pairs that span R i and R j [3] od <ref> [4] </ref> for each region R = - r 1 . . . r n do [5] last := - r i | r i / DomReach (C) - [6] if |last| &gt; 1 then [7] return (FAIL) [8] else if |last| = 1 then [9] let x be the single vertex <p> procedure OrderByFlow ( P:PDG ) P c : a copy of P C: the control dependence subgraph of P c begin [1] unmark all vertices in C [2] for each unmarked vertex v in a bottom-up traversal of C's dominator tree do [3] let R be the region containing v <ref> [4] </ref> R = R - y | y R and y / DomReach (C) - [5] w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) [6] in [7] mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R ) [9] if PreserveSpans (P c ,R -) <p> The edge ENTRY T fi 1 is added because 1 is the first vertex in CLIST (ENTRY,T) (line [3]). Since 5 follows 1 in CLIST (ENTRY,T), 5 is passed down as the immediate postdominator of 1 in the call DFS (1,5) (line <ref> [4] </ref>). <p> CLIST (1,F). iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Some CLISTs Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 <ref> [4] </ref> DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi
Reference: 5. <author> T. Ball and J. R. Larus, </author> <title> Branch prediction for free, </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation (published in SIGPLAN Notices) 28(6) pp. 300-13 ACM, </booktitle> <month> (June </month> <year> 1993). </year>
Reference-contexts: If branches can be accurately predicted, then instrumentation code can be placed on the less frequently executed branch when a choice is possible. More recent work on branch prediction by the author of this thesis, in association with J. R. Larus, could be used in this application <ref> [5] </ref>. 57 Chapter 4 EFFICIENTLY COUNTING PROGRAM EVENTS WITH SUPPORT FOR ON-LINE QUERIES Many applications require counting how many times certain events occur in a program's execution. For example, instruction counts can be used to determine how much time is spent in a procedure [26]. <p> OrderByFlow adds ordering edges to hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh function Reconstitute (P M : PDG):CFG or FAIL begin [1] P M := P M [2] if OrderByControl (P M ) fails then return (FAIL) fi [3] if OrderByFlow (P M ) fails then return (FAIL) fi [4] M := ConstructCFG (P M ) <ref> [5] </ref> if OPDG (M) P M then return (FAIL) fi [6] return (M) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 129 P M , as necessitated by flow dependences (Section 7.2.4.2). <p> each pair of regions (R i ,R j ) spanned by an (a,b) pair do [2] apply property OrderFixed to (a,b) to order all (a,b) pairs that span R i and R j [3] od [4] for each region R = - r 1 . . . r n do <ref> [5] </ref> last := - r i | r i / DomReach (C) - [6] if |last| &gt; 1 then [7] return (FAIL) [8] else if |last| = 1 then [9] let x be the single vertex in last in [10] "r i x, add r i fi or x to P <p> dependence subgraph of P c begin [1] unmark all vertices in C [2] for each unmarked vertex v in a bottom-up traversal of C's dominator tree do [3] let R be the region containing v [4] R = R - y | y R and y / DomReach (C) - <ref> [5] </ref> w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) [6] in [7] mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R ) [9] if PreserveSpans (P c ,R -) fails then return (FAIL) else TopSort (R ) fi [10] ProjectInfo (P c ,w,R) [11] <p> Some CLISTs Execution of DFS iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii CLIST (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) <ref> [5] </ref> add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS
Reference: 6. <author> T. Ball and J. R. Larus, </author> <title> Optimally profiling and tracing programs, </title> <note> to appear in ACM Transactions on Programming Languages and Systems, ACM, </note> (). 
Reference-contexts: For edge profiling, this means that counters only have to be associated with chord edges, as described in Chapter 3. We have shown that this theorem can also be applied to event counting. Chapter 3 characterized when a set of edge counters is necessary and sufficient for vertex profiling <ref> [6] </ref>. This characterization is structurally equivalent to the characterization for event counting given in Section 4.2.4. Mellor-Crummey and LeBlanc describe what they call a software instruction counter [49]. This term is misleading, since the software instruction counter does not actually count the number of instructions that have executed. <p> : PDG):CFG or FAIL begin [1] P M := P M [2] if OrderByControl (P M ) fails then return (FAIL) fi [3] if OrderByFlow (P M ) fails then return (FAIL) fi [4] M := ConstructCFG (P M ) [5] if OPDG (M) P M then return (FAIL) fi <ref> [6] </ref> return (M) end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 129 P M , as necessitated by flow dependences (Section 7.2.4.2). <p> pair do [2] apply property OrderFixed to (a,b) to order all (a,b) pairs that span R i and R j [3] od [4] for each region R = - r 1 . . . r n do [5] last := - r i | r i / DomReach (C) - <ref> [6] </ref> if |last| &gt; 1 then [7] return (FAIL) [8] else if |last| = 1 then [9] let x be the single vertex in last in [10] "r i x, add r i fi or x to P [12] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh dences. d pd c iff property OrderFixed implies that <p> unmarked vertex v in a bottom-up traversal of C's dominator tree do [3] let R be the region containing v [4] R = R - y | y R and y / DomReach (C) - [5] w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) <ref> [6] </ref> in [7] mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R ) [9] if PreserveSpans (P c ,R -) fails then return (FAIL) else TopSort (R ) fi [10] ProjectInfo (P c ,w,R) [11] add ordering edges between vertices in R to PDG P [12] ni end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh <p> (ENTRY,F) = () CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 <ref> [6] </ref> DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c <p> (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c 144 Since 4 is also the last vertex in CLIST (1,F), 5 is passed down as the immediate postdominator of 4 in the call DFS (4,5) (line <ref> [6] </ref>). Because 4 is a fall-through vertex, the edge 4 fi 5 is added (line [7]). At this point, we return to process CLIST (1,T) in the active call DFS (1,5). 7.3. PROOFS This section contains the proofs of the results stated in this chapter.
Reference: 7. <author> U. Banerjee, </author> <title> Dependence Analysis for Supercomputing, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Bos-ton, Massachusetts (1988). </address>
Reference-contexts: Slicing, differencing, and integration tools have been developed for languages with scalar variables, structured control-flow, and multiple procedures [8, 30]. Related work in the area of alias and dependence analysis can aid in extending slicing to programs with arrays and pointers <ref> [7, 43, 56] </ref>. Other differencing and integration tools are not semantics-based. For example, the tools diff [35] and diff3 are text-based and can be applied to any programs (or arbitrary text files, for that matter). <p> to (a,b) to order all (a,b) pairs that span R i and R j [3] od [4] for each region R = - r 1 . . . r n do [5] last := - r i | r i / DomReach (C) - [6] if |last| &gt; 1 then <ref> [7] </ref> return (FAIL) [8] else if |last| = 1 then [9] let x be the single vertex in last in [10] "r i x, add r i fi or x to P [12] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh dences. d pd c iff property OrderFixed implies that f pd e. <p> v in a bottom-up traversal of C's dominator tree do [3] let R be the region containing v [4] R = R - y | y R and y / DomReach (C) - [5] w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) [6] in <ref> [7] </ref> mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R ) [9] if PreserveSpans (P c ,R -) fails then return (FAIL) else TopSort (R ) fi [10] ProjectInfo (P c ,w,R) [11] add ordering edges between vertices in R to PDG P [12] ni end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 That <p> add ordering edges between vertices in R to PDG P [12] ni end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 That is, a vertex v in the tree is not visited until all of its descendents in the tree have been visited. 137 they are not visited a second time in the traversal (line <ref> [7] </ref>). The procedures PreserveEx-posedUsesAndDefs and PreserveSpans (described in Sections 7.2.4.2.1-2) add ordering edges between the vertices in region R to force an ordering of the vertices consistent with the flow dependences (lines [8-9]). <p> CLIST (ENTRY,T) = (1,5,6,14) CLIST (1,F) = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) <ref> [7] </ref> add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c <p> Because 4 is a fall-through vertex, the edge 4 fi 5 is added (line <ref> [7] </ref>). At this point, we return to process CLIST (1,T) in the active call DFS (1,5). 7.3. PROOFS This section contains the proofs of the results stated in this chapter. Section 7.3.1 reviews some basic results about control dependence.
Reference: 8. <author> D. Binkley, </author> <title> Multi-procedure program integration, </title> <type> Ph.D. dissertation, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI (1991). </institution>
Reference-contexts: Slicing, differencing, and integration tools have been developed for languages with scalar variables, structured control-flow, and multiple procedures <ref> [8, 30] </ref>. Related work in the area of alias and dependence analysis can aid in extending slicing to programs with arrays and pointers [7, 43, 56]. Other differencing and integration tools are not semantics-based. <p> It is easy to generalize our techniques to handle languages with N-way branch constructs, such as case statements, and other looping constructs. The problems of slicing, differencing, and integration in the presence of multiple procedures <ref> [8, 32, 34, 36] </ref>, non-scalar variables, and other language features [10] are orthogonal to the problems introduced by complex control-flow. Section 5.1 reviews the control-flow graph representation that is used in the succeeding chapters and its execution semantics. <p> order all (a,b) pairs that span R i and R j [3] od [4] for each region R = - r 1 . . . r n do [5] last := - r i | r i / DomReach (C) - [6] if |last| &gt; 1 then [7] return (FAIL) <ref> [8] </ref> else if |last| = 1 then [9] let x be the single vertex in last in [10] "r i x, add r i fi or x to P [12] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh dences. d pd c iff property OrderFixed implies that f pd e. <p> C's dominator tree do [3] let R be the region containing v [4] R = R - y | y R and y / DomReach (C) - [5] w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) [6] in [7] mark all vertices in R <ref> [8] </ref> PreserveExposedUsesAndDefs (P c ,R ) [9] if PreserveSpans (P c ,R -) fails then return (FAIL) else TopSort (R ) fi [10] ProjectInfo (P c ,w,R) [11] add ordering edges between vertices in R to PDG P [12] ni end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 That is, a vertex v in the <p> = (4) CLIST (1,T) = (2) CLIST (2,F) = () CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 <ref> [8] </ref> add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c <p> This will allow the HPR algorithm to succeed in some cases where our algorithm will fail. Binkley extended integration to handle programs with multiple procedures <ref> [8] </ref> and Yang developed a new integration algorithm that is able to accommodate semantics-preserving transformations on programs [73]. Both of these algorithms assume structured control-flow within a procedure or program. 7.4.3.
Reference: 9. <author> D. Binkley, </author> <title> Using semantic differencing to reduce the cost of regression testing, </title> <booktitle> Proceedings of the 1992 Conference on Software Maintenance, </booktitle> <pages> pp. </pages> <month> 41-50 </month> <year> (1992). </year>
Reference-contexts: i and R j [3] od [4] for each region R = - r 1 . . . r n do [5] last := - r i | r i / DomReach (C) - [6] if |last| &gt; 1 then [7] return (FAIL) [8] else if |last| = 1 then <ref> [9] </ref> let x be the single vertex in last in [10] "r i x, add r i fi or x to P [12] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh dences. d pd c iff property OrderFixed implies that f pd e. <p> R be the region containing v [4] R = R - y | y R and y / DomReach (C) - [5] w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) [6] in [7] mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R ) <ref> [9] </ref> if PreserveSpans (P c ,R -) fails then return (FAIL) else TopSort (R ) fi [10] ProjectInfo (P c ,w,R) [11] add ordering edges between vertices in R to PDG P [12] ni end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 That is, a vertex v in the tree is not visited until all <p> (2,F) = () CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 <ref> [9] </ref> DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c <p> Although this algorithm is able to find more cases where components have equivalent behavior, it is still limited 166 to programs with structured control-flow. Binkley describes how to perform semantics-based differencing on multi-procedure programs with applications to regression testing <ref> [ 9] </ref>. 7.4.2. Related Work on Integration The first semantics-based integration algorithm (the HPR algorithm) was developed by Horwitz, Prins and Reps [30]. Yang and Reps proved that when this integration algorithm succeeds it will produce a program meeting the semantic criteria of integration [62].
Reference: 10. <author> J. Cheng, </author> <title> Slicing concurrent programs, </title> <booktitle> Proceedings of the 1st International Workshop on Automated and Algorithmic Debugging, </booktitle> <month> (May </month> <year> 1993). </year>
Reference-contexts: It is easy to generalize our techniques to handle languages with N-way branch constructs, such as case statements, and other looping constructs. The problems of slicing, differencing, and integration in the presence of multiple procedures [8, 32, 34, 36], non-scalar variables, and other language features <ref> [10] </ref> are orthogonal to the problems introduced by complex control-flow. Section 5.1 reviews the control-flow graph representation that is used in the succeeding chapters and its execution semantics. Section 5.2 discusses the dependence relationships in the control-flow graph that form the foundation of our algorithms. <p> R = - r 1 . . . r n do [5] last := - r i | r i / DomReach (C) - [6] if |last| &gt; 1 then [7] return (FAIL) [8] else if |last| = 1 then [9] let x be the single vertex in last in <ref> [10] </ref> "r i x, add r i fi or x to P [12] fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh dences. d pd c iff property OrderFixed implies that f pd e. Thus, to order all the (a,b) pairs that span the same two regions requires only one application of property OrderFixed. <p> y / DomReach (C) - [5] w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) [6] in [7] mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R ) [9] if PreserveSpans (P c ,R -) fails then return (FAIL) else TopSort (R ) fi <ref> [10] </ref> ProjectInfo (P c ,w,R) [11] add ordering edges between vertices in R to PDG P [12] ni end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 That is, a vertex v in the tree is not visited until all of its descendents in the tree have been visited. 137 they are not visited a second <p> CLIST (2,T) = (3,4) [1] DFS (ENTRY,EXIT) [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) <ref> [10] </ref> add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c 144 Since 4
Reference: 11. <author> J. D. Choi, B. P. Miller, and R. H. B. Netzer, </author> <title> Techniques for debugging parallel programs with flowback analysis, </title> <journal> ACM Transactions on Programming Languages and Systems 13(4) pp. </journal> <month> 491-530 (October </month> <year> 1991). </year>
Reference-contexts: Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging <ref> [11, 44, 66] </ref>. Both techniques have been implemented in a wide variety of systems. In this chapter, we describe algorithms for placing profiling and tracing code that greatly reduce the cost of measuring programs, compared to previously implemented approaches. <p> [5] w = v's parent in C's dominator tree (i.e., w is v's immediate dominator) [6] in [7] mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R ) [9] if PreserveSpans (P c ,R -) fails then return (FAIL) else TopSort (R ) fi [10] ProjectInfo (P c ,w,R) <ref> [11] </ref> add ordering edges between vertices in R to PDG P [12] ni end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 That is, a vertex v in the tree is not visited until all of its descendents in the tree have been visited. 137 they are not visited a second time in the traversal (line <p> Procedure ProjectInfo projects flow edge information onto the vertex w that is the immediate dominator of the vertices in R (Section 7.2.4.2.3). Finally, the ordering edges added to region R in P c are copied to PDG P (line <ref> [11] </ref>). 7.2.4.2.1. Procedure PreserveExposedUsesAndDefs Procedure PreserveExposedUsesAndDefs uses flow edges of graph P c having only one endpoint inside region R and loop-carried edges with both endpoints inside R to identify exposed uses and definitions. <p> [2] add edge ENTRY fi F EXIT [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 <ref> [11] </ref> add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c 144 Since 4 is also the last vertex in CLIST
Reference: 12. <author> J. D. Choi and J. Ferrante, </author> <title> What is in a slice, </title> <type> Unpublished draft, </type> <institution> IBM T.J. Watson Research Center (December 1992). </institution>
Reference-contexts: last := - r i | r i / DomReach (C) - [6] if |last| &gt; 1 then [7] return (FAIL) [8] else if |last| = 1 then [9] let x be the single vertex in last in [10] "r i x, add r i fi or x to P <ref> [12] </ref> fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh dences. d pd c iff property OrderFixed implies that f pd e. Thus, to order all the (a,b) pairs that span the same two regions requires only one application of property OrderFixed. Lines [1-3] of procedure OrderByControl reflect this observation. <p> is v's immediate dominator) [6] in [7] mark all vertices in R [8] PreserveExposedUsesAndDefs (P c ,R ) [9] if PreserveSpans (P c ,R -) fails then return (FAIL) else TopSort (R ) fi [10] ProjectInfo (P c ,w,R) [11] add ordering edges between vertices in R to PDG P <ref> [12] </ref> ni end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 6 That is, a vertex v in the tree is not visited until all of its descendents in the tree have been visited. 137 they are not visited a second time in the traversal (line [7]). <p> [3] add edge ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 <ref> [12] </ref> DFS (3,4) [13] add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c 144 Since 4 is also the last vertex in CLIST (1,F), 5 is passed down as the
Reference: 13. <author> R. F. Cmelik, S. I. Kong, D. R. Ditzel, and E. J. Kelly, </author> <title> An analysis of MIPS and SPARC instruction set utilization on the SPEC benchmarks, </title> <booktitle> ASPLOS-IV Proceedings (SIGARCH 175 Computer Architecture News) 19(2) pp. </booktitle> <month> 290-302 (April </month> <year> 1991). </year>
Reference-contexts: Program profiling counts the number of times that each basic block or control-flow edge in a program executes. It is widely used to measure instruction set utilization, identify program bottlenecks, and estimate program execution times for code optimization <ref> [13, 19, 26, 48, 50, 53, 64] </ref>. Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging [11, 44, 66]. <p> ENTRY fi T 1 [4] DFS (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) <ref> [13] </ref> add edge 3 fi 4 [14] DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c 144 Since 4 is also the last vertex in CLIST (1,F), 5 is passed down as the immediate postdominator of
Reference: 14. <institution> Systems Performance Evaluation Cooperative, </institution> <note> SPEC Newsletter (K. Mendoza, editor) 1(1)(1989). </note>
Reference-contexts: Qpt instruments object code and can either insert counters in every basic block in a program (redundant mode) or along the subset of edges identified by the 41 spanning tree algorithm (optimal mode). We used the SPEC benchmark suite to test qpt <ref> [14] </ref>. This is a collection of 10 moderately large Fortran and C programs that is widely used to evaluate computer system performance. The programs were compiled at a high level of optimization (either -O2 or -O3, which does interpro-cedural register allocation). <p> The FORTRAN program doduc, while it has a dynamic block size of 12.4 instructions, has an abundance of short branches <ref> [14] </ref> that accounts for its reduction in counter increments. The decrease in run time overhead for doduc was substantial (38% to 5%). The fpppp benchmark produced an interesting result. <p> (1,5) [5] add edge 1 fi F 4 [6] DFS (4,5) [7] add edge 4 fi 5 [8] add edge 1 fi T 2 [9] DFS (2,5) [10] add edge 2 fi F 5 [11] add edge 2 fi T 3 [12] DFS (3,4) [13] add edge 3 fi 4 <ref> [14] </ref> DFS (4,5) .... iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c c c c c 144 Since 4 is also the last vertex in CLIST (1,F), 5 is passed down as the immediate postdominator of 4 in the call DFS (4,5)
Reference: 15. <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck, </author> <title> Efficiently computing static single assignment form and the control dependence graph, </title> <journal> ACM Transactions on Programming Languages and Systems 13(4) pp. </journal> <note> 451-490 (October 1991 TOPLAS). </note>
Reference-contexts: Yang, Horwitz, and Reps defined a different algorithm for determining components with equivalent behavior across programs that uses a representation called the program representation graph [73], which has some similarities to static single assignment form <ref> [15] </ref>. Although this algorithm is able to find more cases where components have equivalent behavior, it is still limited 166 to programs with structured control-flow. Binkley describes how to perform semantics-based differencing on multi-procedure programs with applications to regression testing [ 9]. 7.4.2.
Reference: 16. <author> J. Ferrante and M. Mace, </author> <title> On linearizing parallel code, pp. </title> <booktitle> 179-189 in Conference Record of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (New Orleans, LA, </address> <month> January 14-16, </month> <year> 1985), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1985). </address>
Reference-contexts: Therefore, all the CFGs that could be created from P M by reconstitution have equivalent behavior (at each corresponding vertex). Previous work on PDG reconstitution has been done by Ferrante and Mace <ref> [16] </ref>, Ferrante, Mace and Simons [18], and Simons, Alpern and Ferrante [65]. In these works, the PDG is viewed as a representation of a parallel program and the goal is to translate this program to a sequential program.
Reference: 17. <author> J. Ferrante, K. Ottenstein, and J. Warren, </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(5) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: This thesis focuses on a number of useful software tools and shows how their efficiency, generality, and precision can be increased through the use of control-flow [1] and control dependence analysis <ref> [17] </ref>. We consider two classes of tools: execution measurement tools, which dynamically collect information about a particular execution of a program; and program analysis tools, which provide information about potential program behavior by statically analyzing the program. <p> The program dependence graph (PDG) is a graph that contains the same vertex set as the CFG (except for the EXIT vertex) <ref> [17] </ref>. The edges of the PDG are the control and flow dependences, as defined above. 2 Given a CFG G, let PDG (G) denote G's program dependence graph. <p> program component c and a set of variables V, the goal of slicing (as defined by Weiser) is to create a projection of the program (by eliminating some hhhhhhhhhhhhhhhhhhhhhhhhhhh 2 In addition to control and flow dependences, program dependence graphs usually include either def-order dependences [29] or output and anti-dependences <ref> [17] </ref>. These additional edges are not needed for slicing, and so are omitted from the definition given here. We also do not need to distinguish between loop-independent and loop-carried dependences (which are ill-defined for irreducible control-flow).
Reference: 18. <author> J. Ferrante, M. Mace, and B. Simons, </author> <title> Generating sequential code from parallel code, </title> <booktitle> Proceedings of the ACM 1988 International Conference on Supercomputing, </booktitle> <pages> pp. </pages> <month> 582-592 (July </month> <year> 1988). </year>
Reference-contexts: Therefore, all the CFGs that could be created from P M by reconstitution have equivalent behavior (at each corresponding vertex). Previous work on PDG reconstitution has been done by Ferrante and Mace [16], Ferrante, Mace and Simons <ref> [18] </ref>, and Simons, Alpern and Ferrante [65]. In these works, the PDG is viewed as a representation of a parallel program and the goal is to translate this program to a sequential program.
Reference: 19. <author> J. A. Fisher, J. R. Ellis, J. C. Ruttenberg, and A. Nicolau, </author> <title> Parallel processing: A smart compiler and a dumb machine, </title> <booktitle> Proc. of the ACM SIGPLAN 1984 Symposium on Compiler Construction (SIGPLAN Notices) 19(6) pp. </booktitle> <month> 37-47 (June </month> <year> 1984). </year>
Reference-contexts: Program profiles have many uses: they are used during program testing to determine which parts of a program have been exercised and, in program performance tuning, to point to "hot spots" in program execution, where improvements can be made [26]. Profile information also assists many compiler optimizations <ref> [19, 48, 53] </ref>. Tracing tools record the sequence of events in a program's execution [45]. Traces are often used for performance analysis, simulation, and debugging. <p> Program profiling counts the number of times that each basic block or control-flow edge in a program executes. It is widely used to measure instruction set utilization, identify program bottlenecks, and estimate program execution times for code optimization <ref> [13, 19, 26, 48, 50, 53, 64] </ref>. Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging [11, 44, 66]. <p> Other authors have presented heuristics that are similar to ours, usually for the purpose of aiding code optimization. For example, Fisher, Ellis, Ruttenberg, and Nicolau use loop nesting level and programmer-supplied hints to estimate block execution frequency for trace scheduling <ref> [19] </ref>. However, few of these heuristics have the goal of producing edge frequencies satisfying the flow law. None of the heuristics mentioned above nor our heuristic attempts to predict branch directions.
Reference: 20. <author> I. R. Forman, </author> <title> On the time overhead of counters and traversal markers, </title> <booktitle> Proceedings of the 5th International Conference on Software Engineering, </booktitle> <pages> pp. </pages> <month> 164-169 (March </month> <year> 1981). </year>
Reference-contexts: The other edges form a maximum spanning tree. As mentioned before, our heuristic will generate the weighting in case (a). Forman discusses the problem of minimizing counter overhead with the spanning tree approach from a graph theoretic perspective <ref> [20] </ref>.
Reference: 21. <author> K. B. Gallagher, </author> <title> Using program slicing in software maintenance, </title> <type> Ph. D. Thesis (Technical Report CS-90-05), </type> <institution> University of Maryland, Baltimore County, </institution> <note> Maryland (January 1990). </note>
Reference-contexts: Neither of these algorithms works correctly for programs with unstructured control-flow. Lyle developed an ad-hoc algorithm for slicing programs in the presence of arbitrary control-flow but his algorithm is overly conservative, as described by Gallagher <ref> [21] </ref>. Gallagher refined Lyle's algorithm to produce smaller slices but his algorithm contains some errors that cause it to produce semantically incorrect program projections [21]. We focus on the Ottensteins' algorithm and consider the problems that arise if one tries to apply this algorithm to programs with unstructured control-flow. <p> Lyle developed an ad-hoc algorithm for slicing programs in the presence of arbitrary control-flow but his algorithm is overly conservative, as described by Gallagher <ref> [21] </ref>. Gallagher refined Lyle's algorithm to produce smaller slices but his algorithm contains some errors that cause it to produce semantically incorrect program projections [21]. We focus on the Ottensteins' algorithm and consider the problems that arise if one tries to apply this algorithm to programs with unstructured control-flow. The Ottensteins' algorithm makes use of the control-flow graph and program dependence graph representations. <p> RELATED WORK As mentioned previously, Weiser defined the first program slicing algorithm [71]. The Otten-steins defined a more efficient program slicing algorithm using the program dependence graph [52]. Neither algorithm handles unstructured control-flow correctly. Lyle defined an algorithm to slice programs containing gotos, which is summarized by Gallagher <ref> [21] </ref>, but it is quite conservative (i.e., produces projections that are larger than necessary), as we show below. <p> His algorithm forms a projection that is identical to the original program. However, the following program is an acceptable projection (which our slicing algorithm will produce): x := 1 Gallagher made a refinement to Lyle's algorithm to address this imprecision <ref> [21] </ref>, but his algorithm, as defined in his thesis, may produce semantically incorrect projections. Basically, Gallagher's algorithm includes goto L only if a control dependence predecessor of the goto is in the slice and the statement labelled L is included in the slice.
Reference: 22. <author> K. B. Gallagher, </author> <title> private communication. </title> <month> July </month> <year> 1993. </year>
Reference-contexts: Gallagher's algorithm does not include the goto because the statement (a:=2) is not in the slice. Gallagher has modified his slicing algorithm since the publication of his thesis <ref> [22] </ref>. However, although his updated algorithm seems to be an improvement over the algorithm given in his 115 thesis, he has no proof that it is correct and there still seem to be cases in which it fails to produce a semantically correct slice.
Reference: 23. <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <address> San Francisco (1979). </address>
Reference-contexts: all directed cycles is an NP-complete 30 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Undirected Cycles Piped Cycles Pipeless Cycles Directed Cycles DiamondsOther NP NP ?? Trace (Ewit) Eprof (Ecnt) Vprof (Ecnt) ?? hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh ty for breaking all cycles of a given type (P = polynomial; NP = NP-complete; ?? = unknown). problem (Feedback Arc Set <ref> [23] </ref>). Maheshwari showed that finding a minimum size set of edges that breaks diamonds is also NP-complete (Uniconnected Subgraph [23, 47]). Minimizing with respect to a weighting (that satisfies Kirchoff's flow law) does not make either of these problems easier. <p> Maheshwari showed that finding a minimum size set of edges that breaks diamonds is also NP-complete (Uniconnected Subgraph <ref> [23, 47] </ref>). Minimizing with respect to a weighting (that satisfies Kirchoff's flow law) does not make either of these problems easier. Furthermore, it is easy to show that optimally breaking both directed cycles and diamonds is no easier than either problem in isolation. <p> This problem shares some characteristics with other NP-complete cycle-breaking problems such as Feedback 71 Arc Set and Uniconnected Subgraph <ref> [23] </ref>. Not surprisingly, the condition that every simple cycle in E -E is pipeless also is necessary for event counting. <p> DEFINITION (the difference of New with respect to Old). Diff (New,Old) = - v V (New) | v has no corresponding vertex in Old - - v V (New) | FPP (New,v) FPP (Old,v) - While isomorphism of general graphs appears to be a hard problem to answer efficiently <ref> [23] </ref>, isomorphism of CFGs can be determined in linear time because the outgoing edges of each vertex in a CFG are uniquely labelled.
Reference: 24. <author> A. Goldberg, </author> <title> Reducing overhead in counter-based execution profiling, </title> <type> Technical Report CSL-TR-91-495, </type> <institution> Stanford University, Stanford, </institution> <address> CA (October, </address> <year> 1991). </year>
Reference-contexts: Both Sarkar and Goldberg have successfully implemented this approach in profiling tools <ref> [24, 64] </ref>. For example, Goldberg reports that for eqntott the reduction in increments increased from 4.3 to 7.7 after adding induction variable analysis. Some scientific codes benefitted greatly from this analysis (a 33-fold decrease in instrumentation code executed for matrix300). <p> Knuth describes how to use the spanning tree for profiling in [40]. Other authors that have written about the application of the spanning tree to profiling include Gold-berg <ref> [24] </ref>, Samples [63], and Probert [55]. As far as we know, Goldberg and Samples are the only other researchers that have implemented the spanning tree approach and performed 53 significant experimentation with real programs. Their work occurred concurrently with ours. Goldberg implemented edge profiling by instrumenting executable files [24]. <p> include Gold-berg <ref> [24] </ref>, Samples [63], and Probert [55]. As far as we know, Goldberg and Samples are the only other researchers that have implemented the spanning tree approach and performed 53 significant experimentation with real programs. Their work occurred concurrently with ours. Goldberg implemented edge profiling by instrumenting executable files [24]. His profiler was built as part of a system to analyze the memory performance of programs [25]. Goldberg optimized his instrumentation in two ways that we do not consider. <p> Goldberg developed a heuristic for his profiling tool that uses a post-order numbering of the vertices in the CFG (as determined by a depth-first search from the root vertex) to assign edge weights <ref> [24] </ref>. He defines an edge's weight to be the post-order number of its source vertex. However, if an edge is a loop backedge then it is given a weight larger than the number of vertices in the graph. <p> RELATED WORK As discussed in Chapter 3, there are a number of works on the related topic of efficiently profiling programs with instrumentation <ref> [4, 24, 40, 41, 55, 63, 64] </ref>.
Reference: 25. <author> A. J. Goldberg and J. L. Hennessy, </author> <title> Mtool: An integrated system for performance debugging shared memory multiprocessor applications, </title> <journal> IEEE Transactions on Parallel and Distributed Systems 4(1) pp. </journal> <month> 28-40 (January </month> <year> 1993). </year>
Reference-contexts: Their work occurred concurrently with ours. Goldberg implemented edge profiling by instrumenting executable files [24]. His profiler was built as part of a system to analyze the memory performance of programs <ref> [25] </ref>. Goldberg optimized his instrumentation in two ways that we do not consider. First, his tool selected the two statically least-used registers in the executable and eliminated all uses by inserting loads and stores around existing uses of these registers.
Reference: 26. <author> S. L. Graham, P. B. Kessler, and M. K. McKusick, </author> <title> An execution profiler for modular programs, </title> <note> SoftwarePractice and Experience 13 pp. 671-685 (1983). 176 </note>
Reference-contexts: Program profiles have many uses: they are used during program testing to determine which parts of a program have been exercised and, in program performance tuning, to point to "hot spots" in program execution, where improvements can be made <ref> [26] </ref>. Profile information also assists many compiler optimizations [19, 48, 53]. Tracing tools record the sequence of events in a program's execution [45]. Traces are often used for performance analysis, simulation, and debugging. <p> Program profiling counts the number of times that each basic block or control-flow edge in a program executes. It is widely used to measure instruction set utilization, identify program bottlenecks, and estimate program execution times for code optimization <ref> [13, 19, 26, 48, 50, 53, 64] </ref>. Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging [11, 44, 66]. <p> For example, instruction counts can be used to determine how much time is spent in a procedure <ref> [26] </ref>. Event counting can be used to implement countdown timers for debugger break-points or execution-driven simulators so that control returns from the executing program to the debugger or simulator after a certain number of events [49, 59].
Reference: 27. <author> J. K. Hollingsworth and B. P. Miller, </author> <title> Dynamic control of performance monitoring on large scale parallel systems, </title> <type> Technical Report #1133, </type> <institution> University of WisconsinMadison (Janu-ary 1993). </institution>
Reference-contexts: Counts of synchronization events, I/O events, and system calls also can be used to measure the performance of parallel programs <ref> [27] </ref>. Furthermore, many of these applications require the capability to query the event count on-line, while the program executes, rather than off-line, after the program has terminated. For example, interactive performance measurement tools need to make such queries in order to update displays in a timely fashion.
Reference: 28. <author> S. Horwitz, J. Prins, and T. Reps, </author> <title> Integrating non-interfering versions of programs, </title> <type> Report 690, </type> <institution> Department of Computer Sciences, University of WisconsinMadison (March, </institution> <year> 1987). </year>
Reference-contexts: Although it appears that an arbitrary choice can be made, there are examples in which choosing one way leads to a cycle in the set of ordering edges. As shown by Horwitz, Prins, and Reps, the problem of determining the correct choice in this situation is NP-complete <ref> [28] </ref>. In practice, a simple backtracking algorithm appears to suffice.
Reference: 29. <author> S. Horwitz, J. Prins, and T. Reps, </author> <title> On the adequacy of program dependence graphs for representing programs, pp. </title> <booktitle> 146-157 in Conference Record of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York (1988). </address>
Reference-contexts: Given a program component c and a set of variables V, the goal of slicing (as defined by Weiser) is to create a projection of the program (by eliminating some hhhhhhhhhhhhhhhhhhhhhhhhhhh 2 In addition to control and flow dependences, program dependence graphs usually include either def-order dependences <ref> [29] </ref> or output and anti-dependences [17]. These additional edges are not needed for slicing, and so are omitted from the definition given here. We also do not need to distinguish between loop-independent and loop-carried dependences (which are ill-defined for irreducible control-flow). <p> Both of these algorithms assume structured control-flow within a procedure or program. 7.4.3. Related Work on Reconstitution Horwitz, Prins, and Reps were the first to formalize that program dependence graphs are an adequate program representation <ref> [29] </ref>. They proved that PDGs distinguish between nonequivalent 168 structured programs. That is, any two structured programs with inequivalent behavior have non-isomorphic PDGs.
Reference: 30. <author> S. Horwitz, J. Prins, and T. Reps, </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: An integration tool takes three programs as input, an original program and two variants, and determines whether the programs can be merged in such a way as to preserve the changed computations in each variant with respect to the original program <ref> [30] </ref>. A main application of program integration is reconciling divergent lines of program development in a multi-programmer project. Other uses are described by Horwitz and Reps [34]. In both differencing and integration, slicing is used to conservatively determine when two points in different programs have equivalent behavior. <p> Slicing, differencing, and integration tools have been developed for languages with scalar variables, structured control-flow, and multiple procedures <ref> [8, 30] </ref>. Related work in the area of alias and dependence analysis can aid in extending slicing to programs with arrays and pointers [7, 43, 56]. Other differencing and integration tools are not semantics-based. <p> The control dependence subgraph of PDG (G), denoted by CDG (G), contains only control dependence edges. control dependences and dashed edges are flow dependences. 5.3. SLICING PROGRAMS Program slicing, a program transformation originally defined by Mark Weiser [71], is useful in program debugging [42], program maintenance <ref> [30] </ref>, and other applications that involve understanding program behavior [31]. <p> There are several ways in which a correspondence may be established: g A language-based editor may be used to tag program components and track them over edit ing changes in order to maintain the correspondence, as suggested by Horwitz, Prins, and Reps <ref> [30] </ref>. 85 g The correspondence can be computed directly from the two programs. For example, Horwitz suggests a number of approaches for computing a correspondence based on pro gram dependences [31], while Yang gives an algorithm that finds a maximal syntactic match between two programs by dynamic programming [72]. <p> In particular, BASE, A and B must be reducible CFGs whose loops must be in a normal form that we call while loops. Section 7.2.1 describes this class of CFGs. Following the integration algorithm of Horwitz, Prins and Reps (the HPR algorithm) <ref> [30] </ref>, our integration algorithm has three main steps (Section 7.4 compares our algorithm to the HPR algorithm): (1) Determine the vertices of A and B that have different behavior than their corresponding vertices in BASE (using differencing, as defined in the previous section), and create a merged program dependence graph P <p> It is clear that for any vertex v in Equiv (A,BASE) Equiv (B,BASE), OPDG (A)/v = OPDG (B)/v. Therefore, P M /v = OPDG (A)/v = OPDG (B)/v. If there is interference as defined above then the integration algorithm fails. Horwitz, Prins, and Reps call this Type I interference <ref> [30] </ref>. Reps and Bricker describe how the results of interference can be used to guide the programmer to code in variants A and B that introduces the conflict [61]. 127 7.2.4. <p> Binkley describes how to perform semantics-based differencing on multi-procedure programs with applications to regression testing [ 9]. 7.4.2. Related Work on Integration The first semantics-based integration algorithm (the HPR algorithm) was developed by Horwitz, Prins and Reps <ref> [30] </ref>. Yang and Reps proved that when this integration algorithm succeeds it will produce a program meeting the semantic criteria of integration [62]. The HPR algorithm is restricted to programs with structured control-flow.
Reference: 31. <author> S. Horwitz, </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation (published as SIGPLAN Notices) 25(6) pp. 234-245 ACM, </booktitle> <month> (June 20-22, </month> <year> 1990). </year>
Reference-contexts: The operation of slicing is also important to differencing and integrating. A differencing tool compares two programs and determines those points at which the programs may compute different values <ref> [31] </ref>. An integration tool takes three programs as input, an original program and two variants, and determines whether the programs can be merged in such a way as to preserve the changed computations in each variant with respect to the original program [30]. <p> SLICING PROGRAMS Program slicing, a program transformation originally defined by Mark Weiser [71], is useful in program debugging [42], program maintenance [30], and other applications that involve understanding program behavior <ref> [31] </ref>. <p> For example, Horwitz suggests a number of approaches for computing a correspondence based on pro gram dependences <ref> [31] </ref>, while Yang gives an algorithm that finds a maximal syntactic match between two programs by dynamic programming [72]. We will not concern ourselves here with how a correspondence is established, relying on one of the above techniques to provide the mapping between programs. 5.5.
Reference: 32. <author> S. Horwitz, T. Reps, and D. Binkley, </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Transactions on Programming Languages and Systems 12(1) pp. </journal> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: It is easy to generalize our techniques to handle languages with N-way branch constructs, such as case statements, and other looping constructs. The problems of slicing, differencing, and integration in the presence of multiple procedures <ref> [8, 32, 34, 36] </ref>, non-scalar variables, and other language features [10] are orthogonal to the problems introduced by complex control-flow. Section 5.1 reviews the control-flow graph representation that is used in the succeeding chapters and its execution semantics.
Reference: 33. <author> S. Horwitz and T. Reps, </author> <title> Efficient comparison of program slices, </title> <note> Acta Informatica 28 pp. </note> <month> 713-732 </month> <year> (1991). </year>
Reference-contexts: Horwitz and Reps gave an efficient procedure for determining the isomorphism of these PDG subgraphs <ref> [33] </ref>. We have extended the former result to show how ordered program dependence graphs can be used to compare the behavior of components in programs with arbitrary control-flow.
Reference: 34. <author> S. Horwitz and T. Reps, </author> <title> The use of program dependence graphs in software engineering, pp. </title> <booktitle> 392-411 in Proceedings of the Fourteenth International Conference on Software Engineering, </booktitle> <address> (May 11-15, 1992, Melbourne, Australia), </address> <publisher> ACM, </publisher> <address> New York, NY (1992). </address>
Reference-contexts: A main application of program integration is reconciling divergent lines of program development in a multi-programmer project. Other uses are described by Horwitz and Reps <ref> [34] </ref>. In both differencing and integration, slicing is used to conservatively determine when two points in different programs have equivalent behavior. In integration, slicing is also used to extract relevant code from the input programs to form the merged program. <p> It is easy to generalize our techniques to handle languages with N-way branch constructs, such as case statements, and other looping constructs. The problems of slicing, differencing, and integration in the presence of multiple procedures <ref> [8, 32, 34, 36] </ref>, non-scalar variables, and other language features [10] are orthogonal to the problems introduced by complex control-flow. Section 5.1 reviews the control-flow graph representation that is used in the succeeding chapters and its execution semantics.
Reference: 35. <author> J.W. Hunt and M.D. McIlroy, </author> <title> An algorithm for differential file comparison, </title> <type> Report 41, </type> <institution> Bell Laboratories, </institution> <address> Murray Hill, N.J. </address> (). 
Reference-contexts: Related work in the area of alias and dependence analysis can aid in extending slicing to programs with arrays and pointers [7, 43, 56]. Other differencing and integration tools are not semantics-based. For example, the tools diff <ref> [35] </ref> and diff3 are text-based and can be applied to any programs (or arbitrary text files, for that matter). However, no semantic guarantees can be made about the results of such tools (diff3 may not even produce programs that are syntactically correct). <p> RELATED WORK 7.4.1. Related Work on Differencing There are many techniques for determining the difference between two programs. Some of these techniques are based solely on program text and others take program semantics into account. The Unix TM utility diff computes the textual difference between two files <ref> [35] </ref>. An extension of this tool, called spiff, is a differential comparator that uses lexical parsing of files to provide comparisons at the level of tokens [51].
Reference: 36. <author> J. C. Hwang, M. W. Du, and C. R. Chou, </author> <title> Finding program slices for recursive procedures, </title> <booktitle> Proceedings of IEEE COMPSAC 88, </booktitle> <address> (Chicago, IL, </address> <month> Oct. </month> <pages> 3-7, </pages> <year> 1988), </year> <pages> pp. </pages> <publisher> 220-227 IEEE Computer Society, </publisher> <year> (1988). </year>
Reference-contexts: It is easy to generalize our techniques to handle languages with N-way branch constructs, such as case statements, and other looping constructs. The problems of slicing, differencing, and integration in the presence of multiple procedures <ref> [8, 32, 34, 36] </ref>, non-scalar variables, and other language features [10] are orthogonal to the problems introduced by complex control-flow. Section 5.1 reviews the control-flow graph representation that is used in the succeeding chapters and its execution semantics.
Reference: 37. <author> J. L. Kennington and R. V. Helgason, </author> <title> Algorithms for Network Programming, </title> <publisher> Wiley-Interscience, John Wiley and Sons, </publisher> <address> New York (1980). </address>
Reference-contexts: RELATED WORK 3.5.1. Edge Profiling The spanning tree solution to Eprof (Ecnt) has been known for a long time. In the area of network programming, the problem is known as the specialization of the simplex method to the network program <ref> [37] </ref>. Knuth describes how to use the spanning tree for profiling in [40]. Other authors that have written about the application of the spanning tree to profiling include Gold-berg [24], Samples [63], and Probert [55].
Reference: 38. <author> B. W. Kernighan and D. M. Ritchie, </author> <title> The C Programming Language, </title> <booktitle> Prentice-Hall Software Series, </booktitle> <address> Englewood Cliff, NJ (1978. </address> <note> Second edition, 1988). 177 </note>
Reference-contexts: Determining whether or not such an interpro cedural edge needs to be instrumented would require interprocedural analysis that we did not per form. A problem arises with dynamically computed interprocedural jumps such as setjmp/longjmp in the C language <ref> [38] </ref>, or early program termination, as may be caused by a hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 For the purposes of determining the frequencies of intraprocedural control-flow edges, it does not matter whether procedures and functions are first class objects.
Reference: 39. <author> P. B. Kessler, </author> <title> Fast breakpoints: </title> <booktitle> Design and implementation, Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation (SIG-PLAN Notices) 25(6) pp. 78-84 ACM, </booktitle> <month> (June, </month> <year> 1990). </year>
Reference-contexts: Furthermore, if instrumentation code is dynamically added to and deleted from programs by patching a basic block with a jump to a code stub rather than by rewriting the original code, the over head can increase substantially <ref> [39] </ref>. This chapter defines a new approach to event counting that is similar to (2) above; however, our approach involves instrumenting control-flow edges (rather than basic blocks) in a procedure's control-flow graph.
Reference: 40. <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 1: </volume> <booktitle> Fundamental Algorithms, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1968. </address> <note> Second Edition: </note> <year> 1973). </year>
Reference-contexts: An edge profile determines a vertex profile, but the converse does not always hold. Knuth has published efficient algorithms for finding the minimum number of vertex counters necessary and sufficient for vertex profiling [41], denoted by Vprof (Vcnt), and the minimum number of edge counters for edge profiling <ref> [40] </ref>, denoted by Eprof (Ecnt). <p> However, this placement uses more counters than necessary. Knuth describes how it follows from Kirchoff's law that an edge-counter placement Ecnt solves Eprof (Ecnt ) for CFG G = (V,E) iff (E - Ecnt) contains no (undirected) cycle <ref> [40] </ref>. Since a spanning tree of a CFG represents a maximum subset of edges without a cycle, it follows that Ecnt is a minimum size solution to Eprof (Ecnt) iff (E - Ecnt) is a spanning tree of G. <p> Edge Profiling The spanning tree solution to Eprof (Ecnt) has been known for a long time. In the area of network programming, the problem is known as the specialization of the simplex method to the network program [37]. Knuth describes how to use the spanning tree for profiling in <ref> [40] </ref>. Other authors that have written about the application of the spanning tree to profiling include Gold-berg [24], Samples [63], and Probert [55]. <p> Section 4.3 shows how the results of Section 4.2 can easily be extended to count events interprocedurally. Section 4.4 discusses related work. 4.1. ADDITIONAL BACKGROUND Let G be a CFG and let T be a spanning tree of G. Knuth <ref> [40] </ref> has proved a theorem about directed cycles that we will make use of here. <p> RELATED WORK As discussed in Chapter 3, there are a number of works on the related topic of efficiently profiling programs with instrumentation <ref> [4, 24, 40, 41, 55, 63, 64] </ref>.
Reference: 41. <author> D. E. Knuth and F. R. Stevenson, </author> <title> Optimal measurement points for program frequency counts, </title> <note> BIT 13 pp. </note> <month> 313-322 </month> <year> (1973). </year>
Reference-contexts: An edge profile counts the number of times each control-flow edge executes. An edge profile determines a vertex profile, but the converse does not always hold. Knuth has published efficient algorithms for finding the minimum number of vertex counters necessary and sufficient for vertex profiling <ref> [41] </ref>, denoted by Vprof (Vcnt), and the minimum number of edge counters for edge profiling [40], denoted by Eprof (Ecnt). <p> Vertex Profiling Knuth and Stevenson exactly characterize when a set of vertices Vcnt solves Vprof (Vcnt) and show how to efficiently compute a minimum size Vcnt that solves Vprof (Vcnt) <ref> [41] </ref>. The authors note that their algorithm can be modified to compute a minimum cost solution to Vprof (Vcnt) given a set of measured or estimated vertex frequencies. Our work shows that it is less costly to measure vertex frequency by instrumenting edges rather than vertices. 3.5.3. <p> RELATED WORK As discussed in Chapter 3, there are a number of works on the related topic of efficiently profiling programs with instrumentation <ref> [4, 24, 40, 41, 55, 63, 64] </ref>.
Reference: 42. <author> B. Korel, </author> <title> PELASProgram Error-Locating Assistant System, </title> <journal> IEEE Transactions on Software Engineering SE-14(9) pp. </journal> <month> 1253-1260 (September </month> <year> 1988). </year>
Reference-contexts: The control dependence subgraph of PDG (G), denoted by CDG (G), contains only control dependence edges. control dependences and dashed edges are flow dependences. 5.3. SLICING PROGRAMS Program slicing, a program transformation originally defined by Mark Weiser [71], is useful in program debugging <ref> [42] </ref>, program maintenance [30], and other applications that involve understanding program behavior [31].
Reference: 43. <author> W. Landi, B. G. Ryder, and S. Zhang, </author> <title> Interprocedural modification side effect analysis with pointer aliasing, </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation (published in SIGPLAN Notices) 28(6) pp. 56-67 ACM, </booktitle> <month> (June </month> <year> 1993). </year>
Reference-contexts: Slicing, differencing, and integration tools have been developed for languages with scalar variables, structured control-flow, and multiple procedures [8, 30]. Related work in the area of alias and dependence analysis can aid in extending slicing to programs with arrays and pointers <ref> [7, 43, 56] </ref>. Other differencing and integration tools are not semantics-based. For example, the tools diff [35] and diff3 are text-based and can be applied to any programs (or arbitrary text files, for that matter).
Reference: 44. <author> J. R. Larus, </author> <title> Abstract execution: A technique for efficiently tracing programs, </title> <journal> Software Practice and Experience 20(12) pp. </journal> <month> 1241-1258 (December, </month> <year> 1990). </year>
Reference-contexts: Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging <ref> [11, 44, 66] </ref>. Both techniques have been implemented in a wide variety of systems. In this chapter, we describe algorithms for placing profiling and tracing code that greatly reduce the cost of measuring programs, compared to previously implemented approaches. <p> In this case, the trace file need only be read to regenerate the execution. A more efficient method is to write a witness only at basic blocks that are targets of predicates <ref> [44] </ref>. <p> No-Jump Edges shows the number of profiled edges that do not require the insertion of an unconditional jump. 3.4.2. Tracing Performance The witness placement algorithm was implemented in the AE program-tracing system <ref> [44] </ref>, which has since been incorporated as part of the qpt tool. AE originally recorded the outcome of each conditional branch and used this record to regenerate a full control-flow trace.
Reference: 45. <author> J. R. Larus, </author> <title> Efficient program tracing, </title> <journal> IEEE Computer 26(5) pp. </journal> <month> 52-61 (May </month> <year> 1993). </year>
Reference-contexts: Profile information also assists many compiler optimizations [19, 48, 53]. Tracing tools record the sequence of events in a program's execution <ref> [45] </ref>. Traces are often used for performance analysis, simulation, and debugging. Finally, event counting is a special form of profiling that maintains an aggregate count of the number of events that have occurred in a program's execution. <p> The algorithms reduce measurement overhead in two ways: by inserting less instrumentation code and by placing the code where it is less likely to be executed. The algorithms have been implemented in a widely-distributed profiling/tracing tool called qpt <ref> [45] </ref>, which instruments executable files, and performs very well in practice. The algorithms in this chapter produce an exact basic block profile or trace, contrasted with statistical tools such as the Unix TM prof command, which samples the program counter during program execution. <p> Section 3.4.3 considers some optimizations that can further decrease the overhead of profiling and tracing. Section 3.4.4 examines the effectiveness of the heuristic weighting algorithm. 3.4.1. Profiling Performance We implemented the profiling counter placement algorithm in qpt <ref> [45] </ref>, which is a basic block profiler similar to MIPS's pixie [67]. Qpt instruments object code and can either insert counters in every basic block in a program (redundant mode) or along the subset of edges identified by the 41 spanning tree algorithm (optimal mode).
Reference: 46. <author> J. R. Larus and T. Ball, </author> <title> Rewriting executable files to measure program behavior, </title> <note> to appear in SoftwarePractice and Experience, </note> (). 
Reference-contexts: For example, in the control-flow fragment of Figure 3.17 (a) there are two instrumented incoming edges to a vertex. Because we hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (a) (b) hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 5 We discuss the problems of register scavenging and instrumenting object files in greater detail else where <ref> [46] </ref>. 50 use the general rule that the instrumentation code associated with an edge is placed just before the code associated with the vertex that is the target of the edge, this fragment will require at least one unconditional jump (in order to jump over the instrumention code associated with the
Reference: 47. <author> S. Maheshwari, </author> <title> Traversal marker placement problems are NP-complete, </title> <type> Report No. </type> <institution> CU-CS-092-76, Dept. of Computer Science, University of Colorado, Boulder, </institution> <address> CO (1976). </address>
Reference-contexts: Maheshwari showed that finding a minimum size set of edges that breaks diamonds is also NP-complete (Uniconnected Subgraph <ref> [23, 47] </ref>). Minimizing with respect to a weighting (that satisfies Kirchoff's flow law) does not make either of these problems easier. Furthermore, it is easy to show that optimally breaking both directed cycles and diamonds is no easier than either problem in isolation. <p> The authors do not give an algorithm for reconstructing an execution from a trace or consider how to trace multi-procedure programs. Further, they are interested in finding a minimal size solution to the tracing problem, an NP-complete problem <ref> [47] </ref>. However, a minimum size solution does not necessarily yield a minimum cost solution. 3.5.4. Minimizing instrumentation overhead A CFG has many spanning trees, each of which induces a counter placements with an associated run-time overhead cost.
Reference: 48. <author> S. McFarling, </author> <title> Procedure merging with instruction caches, </title> <booktitle> Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(6) pp. </journal> <month> 71-91 (June, </month> <year> 1991). </year>
Reference-contexts: Program profiles have many uses: they are used during program testing to determine which parts of a program have been exercised and, in program performance tuning, to point to "hot spots" in program execution, where improvements can be made [26]. Profile information also assists many compiler optimizations <ref> [19, 48, 53] </ref>. Tracing tools record the sequence of events in a program's execution [45]. Traces are often used for performance analysis, simulation, and debugging. <p> Program profiling counts the number of times that each basic block or control-flow edge in a program executes. It is widely used to measure instruction set utilization, identify program bottlenecks, and estimate program execution times for code optimization <ref> [13, 19, 26, 48, 50, 53, 64] </ref>. Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging [11, 44, 66].
Reference: 49. <author> J. M. Mellor-Crummey and T. J. LeBlanc, </author> <title> A software instruction counter, </title> <booktitle> Third ASPLOS Proceedings (SIGARCH Computer Arch. </booktitle> <pages> News) 17(2) pp. 78-86 (April 3-6, </pages> <year> 1989). </year>
Reference-contexts: Event counting can be used to implement countdown timers for debugger break-points or execution-driven simulators so that control returns from the executing program to the debugger or simulator after a certain number of events <ref> [49, 59] </ref>. Counts of synchronization events, I/O events, and system calls also can be used to measure the performance of parallel programs [27]. Furthermore, many of these applications require the capability to query the event count on-line, while the program executes, rather than off-line, after the program has terminated. <p> Chapter 3 characterized when a set of edge counters is necessary and sufficient for vertex profiling [6]. This characterization is structurally equivalent to the characterization for event counting given in Section 4.2.4. Mellor-Crummey and LeBlanc describe what they call a software instruction counter <ref> [49] </ref>. This term is misleading, since the software instruction counter does not actually count the number of instructions that have executed.
Reference: 50. <author> W. G. Morris, CCG: </author> <title> A prototype coagulating code generator, </title> <booktitle> Proceedings of the SIG-PLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(6) pp. </journal> <month> 45-58 (June, </month> <year> 1991). </year>
Reference-contexts: Program profiling counts the number of times that each basic block or control-flow edge in a program executes. It is widely used to measure instruction set utilization, identify program bottlenecks, and estimate program execution times for code optimization <ref> [13, 19, 26, 48, 50, 53, 64] </ref>. Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging [11, 44, 66].
Reference: 51. <author> D. Nachbar, </author> <title> SPIFF A program for making controlled approximate comparisons of files, </title> <booktitle> Summer '88 Usenix Conference, </booktitle> (). 
Reference-contexts: The Unix TM utility diff computes the textual difference between two files [35]. An extension of this tool, called spiff, is a differential comparator that uses lexical parsing of files to provide comparisons at the level of tokens <ref> [51] </ref>. For example, spiff can be told to ignore whitespace and comments when examining files or to ignore the differences between floating point numbers up to some threshold (this can be useful for comparing the output of floating point calculations in the presence of roundoff errors).
Reference: 52. <author> K.J. Ottenstein and L.M. Ottenstein, </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> April 23-25, 178 </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May, </month> <year> 1984). </year>
Reference-contexts: Our algorithm works for programs with completely arbitrary control-flow, including irreducible control-flow [1]. Algorithms for slicing programs with structured control-flow have been defined by Weiser [71] and by the Ottensteins <ref> [52] </ref>. Neither of these algorithms works correctly for programs with unstructured control-flow. Lyle developed an ad-hoc algorithm for slicing programs in the presence of arbitrary control-flow but his algorithm is overly conservative, as described by Gallagher [21]. <p> RELATED WORK As mentioned previously, Weiser defined the first program slicing algorithm [71]. The Otten-steins defined a more efficient program slicing algorithm using the program dependence graph <ref> [52] </ref>. Neither algorithm handles unstructured control-flow correctly. Lyle defined an algorithm to slice programs containing gotos, which is summarized by Gallagher [21], but it is quite conservative (i.e., produces projections that are larger than necessary), as we show below.
Reference: 53. <author> K. Pettis and R. C. Hanson, </author> <title> Profile guided code positioning, </title> <booktitle> Proceedings of the ACM SIG-PLAN '90 Conference on Programming Language Design and Implementation (SIGPLAN Notices) 25(6) pp. 16-27 ACM, </booktitle> <month> (June, </month> <year> 1990). </year>
Reference-contexts: Program profiles have many uses: they are used during program testing to determine which parts of a program have been exercised and, in program performance tuning, to point to "hot spots" in program execution, where improvements can be made [26]. Profile information also assists many compiler optimizations <ref> [19, 48, 53] </ref>. Tracing tools record the sequence of events in a program's execution [45]. Traces are often used for performance analysis, simulation, and debugging. <p> Program profiling counts the number of times that each basic block or control-flow edge in a program executes. It is widely used to measure instruction set utilization, identify program bottlenecks, and estimate program execution times for code optimization <ref> [13, 19, 26, 48, 50, 53, 64] </ref>. Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging [11, 44, 66].
Reference: 54. <author> S. Pottle, </author> <title> private communication. </title> <month> October </month> <year> 1991. </year>
Reference-contexts: Furthermore, it is easy to show that optimally breaking both directed cycles and diamonds is no easier than either problem in isolation. Solving the tracing problem so that the cost of the instrumented edges is minimized is an NP-complete problem, as shown in an unpublished result by S. Pottle <ref> [54] </ref>. The reduction is similar to that used by Maheshwari but is complicated by the requirement that a weighting satisfies Kirchoff's flow law. We believe that optimally solving Vprof (Ecnt) (minimizing the size or cost of Ecnt) is an NP-complete problem, but do not have a proof as of yet.
Reference: 55. <author> R. L. Probert, </author> <title> Optimal insertion of software probes in well-delimited programs, </title> <journal> IEEE Transactions on Software Engineering SE-8(1) pp. </journal> <month> 34-42 (January, </month> <year> 1975). </year>
Reference-contexts: Combined with the two profiling problems, this yields six possibilities. We do not consider Eprof (Vcnt), since there are CFGs for which there are no solutions to this problem <ref> [55] </ref>. That is, it is not always possible to determine edge frequencies from vertex frequencies. <p> Knuth describes how to use the spanning tree for profiling in [40]. Other authors that have written about the application of the spanning tree to profiling include Gold-berg [24], Samples [63], and Probert <ref> [55] </ref>. As far as we know, Goldberg and Samples are the only other researchers that have implemented the spanning tree approach and performed 53 significant experimentation with real programs. Their work occurred concurrently with ours. Goldberg implemented edge profiling by instrumenting executable files [24]. <p> RELATED WORK As discussed in Chapter 3, there are a number of works on the related topic of efficiently profiling programs with instrumentation <ref> [4, 24, 40, 41, 55, 63, 64] </ref>.
Reference: 56. <author> W. Pugh, </author> <title> A practical algorithm for exact array dependence analysis, </title> <journal> Communications of the ACM 35(8) pp. </journal> <month> 102-114 (August </month> <year> 1993). </year>
Reference-contexts: Slicing, differencing, and integration tools have been developed for languages with scalar variables, structured control-flow, and multiple procedures [8, 30]. Related work in the area of alias and dependence analysis can aid in extending slicing to programs with arrays and pointers <ref> [7, 43, 56] </ref>. Other differencing and integration tools are not semantics-based. For example, the tools diff [35] and diff3 are text-based and can be applied to any programs (or arbitrary text files, for that matter).
Reference: 57. <author> C. V. Ramamoorthy, K. H. Kim, and W. T. Chen, </author> <title> Optimal placement of software monitors aiding systematic testing, </title> <journal> IEEE Transactions on Software Engineering SE-1(4) pp. </journal> <month> 403-410 (December, </month> <year> 1975). </year>
Reference-contexts: However, such a solution is not necessarily optimal. Ramamoorthy, Kim, and Chen have given a necessary and sufficient condition for when a set of edges solves the tracing problem for single procedure programs <ref> [57] </ref>. However, this condition does not work for multi-procedure programs. We reformulate this condition in a more intuitive manner and show how it can be extended to apply to multi-procedure programs. <p> Tracing Ramamoorthy, Kim, and Chen consider how to instrument a single-procedure program with a minimal number of monitors, so the traversal of any directed path through the program may be ascertained after an execution <ref> [57] </ref>. This is equivalent to the tracing problem for single-procedure programs discussed here. The authors do not give an algorithm for reconstructing an execution from a trace or consider how to trace multi-procedure programs.
Reference: 58. <author> M. V. S. Ramanath and M. Solomon, </author> <title> Optimal Code for Control Structures, pp. </title> <booktitle> 82-94 in Conference Record of the Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Albuquerque, NMP, </address> <publisher> ACM, </publisher> <address> New York (1982). </address>
Reference-contexts: On the other hand, placing instrumentation code in vertices simply expands the extent of the original basic blocks, and does not require insertion of jumps. It is possible to rearrange the placement of basic blocks to minimize the number of unconditional jumps needed, as discussed by Ramanath and Solomon <ref> [58] </ref>. However, our algorithms do not perform such an optimization, as they respect the original linearization. 15 (2) A characterization of when a set of edges Ecnt is necessary and sufficient for Eprof (Ecnt), and an algorithm to solve Eprof (Ecnt) optimally.
Reference: 59. <author> S. K. Reinhardt, M. D. Hill, J. R. Larus, A. R. Lebeck, J. C. Lewis, and D. A. Wood, </author> <title> The Wisconsin Wind Tunnel: Virtual prototyping of parallel computers, </title> <booktitle> Proceedings of the 1993 ACM SIGMETRICS Conference, </booktitle> <month> (May </month> <year> 1993). </year>
Reference-contexts: Event counting can be used to implement countdown timers for debugger break-points or execution-driven simulators so that control returns from the executing program to the debugger or simulator after a certain number of events <ref> [49, 59] </ref>. Counts of synchronization events, I/O events, and system calls also can be used to measure the performance of parallel programs [27]. Furthermore, many of these applications require the capability to query the event count on-line, while the program executes, rather than off-line, after the program has terminated.
Reference: 60. <author> T. Reps and T. Teitelbaum, </author> <title> The Synthesizer Generator: A system for constructing language-based editors, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference-contexts: The grammar is given in the style used in <ref> [60] </ref>, in which the underlying context free grammar defines a program's abstract (rather than concrete) syntax. Operator names are used to identify productions uniquely.
Reference: 61. <author> T. Reps and T. Bricker, </author> <title> Illustrating interference in interfering versions of programs, </title> <booktitle> Proceedings of the Second International Workshop on Software Configuration Management, </booktitle> <address> (Princeton, NJ, </address> <month> Oct. </month> <pages> 24-27, </pages> <year> 1989), </year> <note> ACM SIGSOFT Engineering Notes 17(7) pp. </note> <month> 46-55 (November </month> <year> 1989). </year>
Reference-contexts: If there is interference as defined above then the integration algorithm fails. Horwitz, Prins, and Reps call this Type I interference [30]. Reps and Bricker describe how the results of interference can be used to guide the programmer to code in variants A and B that introduces the conflict <ref> [61] </ref>. 127 7.2.4. Reconstitution of a CFG from P M As stated before, the goal of reconstitution is to find a CFG M that includes all of the vertices of P M , such that for every vertex v in OPDG (M), OPDG (M)/v = P M /v.
Reference: 62. <author> T. Reps and W. Yang, </author> <title> The semantics of program slicing and program integration, </title> <booktitle> in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, NY (March 1989). </address>
Reference-contexts: We consider a slightly restricted version of slicing in which the set of variables V includes only variables used or defined at component c. However, following the example of Reps and Yang <ref> [62] </ref>, we strengthen the goal of slicing by requiring that each component of the program projection have equivalent behavior to its corresponding component in the original program. <p> Reps and Yang gave the first formal proof that the program slices formed by using the program dependence graph have the desired semantic property <ref> [62] </ref>. Furthermore, they showed that slicing using the program dependence graph guarantees equivalent behavior at every point in the slice (not just at the slicing vertex). However, they proved this only for programs with structured control-flow. <p> Yang and Reps showed that the isomorphism of subgraphs induced by backwards-closure in the program dependence graph (a slightly different form of graph from the one defined in Chapter 5) can be used to compare the behavior of components in different (structured) programs <ref> [62] </ref>. Horwitz and Reps gave an efficient procedure for determining the isomorphism of these PDG subgraphs [33]. We have extended the former result to show how ordered program dependence graphs can be used to compare the behavior of components in programs with arbitrary control-flow. <p> Related Work on Integration The first semantics-based integration algorithm (the HPR algorithm) was developed by Horwitz, Prins and Reps [30]. Yang and Reps proved that when this integration algorithm succeeds it will produce a program meeting the semantic criteria of integration <ref> [62] </ref>. The HPR algorithm is restricted to programs with structured control-flow.
Reference: 63. <author> A. D. Samples, Profile-driven compilation, Ph. D. </author> <type> Thesis (Report No. </type> <institution> UCB/CSD 91/627), University of California at Berkeley (April 1991). </institution>
Reference-contexts: In this case, there is questionable benefit from mixed placements. In fact, Samples has shown that mixed placements provide little benefit over edge placements on a machine in which the increment and branch costs were comparable, and were worse in some cases <ref> [63] </ref>. Furthermore, as shown in Section 3.4.1, for all the benchmarks we examined, less than half of the instrumented edges (which is about one quarter of the total number of control-flow edges) required unconditional jumps when profiling with edge counters. For these reasons, we do not consider mixed counter placements. <p> Knuth describes how to use the spanning tree for profiling in [40]. Other authors that have written about the application of the spanning tree to profiling include Gold-berg [24], Samples <ref> [63] </ref>, and Probert [55]. As far as we know, Goldberg and Samples are the only other researchers that have implemented the spanning tree approach and performed 53 significant experimentation with real programs. Their work occurred concurrently with ours. Goldberg implemented edge profiling by instrumenting executable files [24]. <p> RELATED WORK As discussed in Chapter 3, there are a number of works on the related topic of efficiently profiling programs with instrumentation <ref> [4, 24, 40, 41, 55, 63, 64] </ref>.
Reference: 64. <author> V. Sarkar, </author> <title> Determining average program execution times and their variance, </title> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation (SIGPLAN Notices) 24(7) pp. 298-312 ACM, </booktitle> <month> (June 21-23, </month> <year> 1989). </year> <month> 179 </month>
Reference-contexts: Program profiling counts the number of times that each basic block or control-flow edge in a program executes. It is widely used to measure instruction set utilization, identify program bottlenecks, and estimate program execution times for code optimization <ref> [13, 19, 26, 48, 50, 53, 64] </ref>. Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging [11, 44, 66]. <p> Both Sarkar and Goldberg have successfully implemented this approach in profiling tools <ref> [24, 64] </ref>. For example, Goldberg reports that for eqntott the reduction in increments increased from 4.3 to 7.7 after adding induction variable analysis. Some scientific codes benefitted greatly from this analysis (a 33-fold decrease in instrumentation code executed for matrix300). <p> Probert discusses how to find a minimal number of vertex measurement points as opposed to a minimal cost set of measurement points. 54 Sarkar describes how to choose profiling points using control dependence and has implemented a profiling tool for the PTRAN system <ref> [64] </ref>. His algorithm finds a minimum sized solution to Eprof (Ecnt) based on a variety of rules about control dependence, as opposed to the spanning tree approach. <p> RELATED WORK As discussed in Chapter 3, there are a number of works on the related topic of efficiently profiling programs with instrumentation <ref> [4, 24, 40, 41, 55, 63, 64] </ref>. <p> RELATED WORK As discussed in Chapter 3, there are a number of works on the related topic of efficiently profiling programs with instrumentation [4, 24, 40, 41, 55, 63, 64]. All of these (except <ref> [64] </ref>) use the spanning tree to determine a (small) set of points in a control-flow graph at which to place counters so 75 that full and accurate vertex (basic block) profiles or edge profiles can be derived from the measured points.
Reference: 65. <author> B. Simons, B. Alpern, and J. Ferrante, </author> <title> A foundation for sequentializing parallel code, </title> <booktitle> Proceedings of the Symposium on Parallel Algorithms and Architectures, </booktitle> <month> (July </month> <year> 1990). </year>
Reference-contexts: Therefore, all the CFGs that could be created from P M by reconstitution have equivalent behavior (at each corresponding vertex). Previous work on PDG reconstitution has been done by Ferrante and Mace [16], Ferrante, Mace and Simons [18], and Simons, Alpern and Ferrante <ref> [65] </ref>. In these works, the PDG is viewed as a representation of a parallel program and the goal is to translate this program to a sequential program. <p> All three works consider control dependence that may not be tree-shaped. The first two works were incomplete and contained some errors that were corrected in <ref> [65] </ref>, which takes the most formal approach to PDG reconstitution. We discuss the similarities and differences between that work and our work on PDG reconstitution. Both works handle essentially the same class of PDGs, as we discuss later. <p> Furthermore, we present a much more complete description of how flow dependences order vertices within a region. Simons et al. do not address the issue of upwards-exposed uses, downwards-exposed definitions, or dependent and independent x-spans, as we do. Two aspects of the work of <ref> [65] </ref> that appear different but that are actually only superficially so, have to do with the class of control dependence graphs that can be handled. Both the algorithm presented in this chapter and the algorithms of [65] handle restricted classes of feasible CDGs. 169 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh T T ENTRY b a ENTRY <p> Two aspects of the work of <ref> [65] </ref> that appear different but that are actually only superficially so, have to do with the class of control dependence graphs that can be handled. Both the algorithm presented in this chapter and the algorithms of [65] handle restricted classes of feasible CDGs. 169 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh T T ENTRY b a ENTRY F a EXIT T F T EXIT FA ENTRY F (a) (b) T ENTRY T (c) T ENTRY T T T FA hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh (b) The CDG of this CFG. (c) The CDG, as transformed by Simons <p> In <ref> [65] </ref> these restrictions are defined directly in terms of properties of the CDGs. In contrast, we define the restrictions indirectly by saying that we handle only those CDGs that correspond to normal-form CFGs. <p> In this way, we arrive at the same class of CDGs. Another aspect of the question of what CDGs are handled has to do with region vertices (also called forall vertices), which are assumed in <ref> [65] </ref> to have been added explicitly to the CDG (region vertices are added to a CDG to gather all vertices with the same set of control conditions together).
Reference: 66. <author> A. J. Smith, </author> <title> Cache memories, </title> <journal> ACM Computing Surveys 14(3) pp. </journal> <month> 473-530 </month> <year> (1982). </year>
Reference-contexts: Instruction tracing records the sequence of basic blocks traversed in a program execution. It is the basis for trace-driven architectural simulation and analysis and is also used in trace-driven debugging <ref> [11, 44, 66] </ref>. Both techniques have been implemented in a wide variety of systems. In this chapter, we describe algorithms for placing profiling and tracing code that greatly reduce the cost of measuring programs, compared to previously implemented approaches.
Reference: 67. <institution> MIPS Computer Systems, Inc., UMIPS-V Reference Manual (pixie and pixstats), MIPS Computer Systems, </institution> <address> Sunnyvale, CA (1990). </address>
Reference-contexts: PROGRAM PROFILING In order to determine how many times each basic block in a program executes, the program can be instrumented with counting code. The simplest approach places a counter at every basic block (pixie and other instrumentation tools use this method <ref> [67] </ref>). There are two drawbacks to such an approach: (1) too many counters are used and (2) the total number of increments during an execution is larger than necessary. <p> Section 3.4.3 considers some optimizations that can further decrease the overhead of profiling and tracing. Section 3.4.4 examines the effectiveness of the heuristic weighting algorithm. 3.4.1. Profiling Performance We implemented the profiling counter placement algorithm in qpt [45], which is a basic block profiler similar to MIPS's pixie <ref> [67] </ref>. Qpt instruments object code and can either insert counters in every basic block in a program (redundant mode) or along the subset of edges identified by the 41 spanning tree algorithm (optimal mode). We used the SPEC benchmark suite to test qpt [14]. <p> This allows every counting code sequence to use these registers without saving and restoring them. A similar approach is used by MIPS's pixie profiling tool <ref> [67] </ref>. As a result, the number of instructions needed to increment a counter in memory can be cut roughly in half. Our tool only looks for free registers to scavenge and often must save and restore registers in the counter increment code sequence. Second, Goldberg identifies simple loop induction variables.
Reference: 68. <author> R. E. Tarjan, </author> <title> Data Structures and Network Algorithms, </title> <institution> Society for industrial and applied mathematics, </institution> <address> Philadelphia, PA (1983). </address>
Reference-contexts: A maximum spanning tree of a weighted graph is one such that the cost of the tree edges is maximal. The maximum spanning tree for a graph can be computed efficiently (linear time) by a variety of algorithms <ref> [68] </ref>. has been given a weighting. The second graph is a maximum spanning tree of the first graph. Note that any vertex in a spanning tree can serve as a root and that the direction of the edges in the tree is unimportant. <p> The above approach can be applied to each tree separately to determine the frequencies for the edges in E - Ecnt. Any of the well-known maximum spanning tree algorithms described by Tarjan <ref> [68] </ref> will efficiently find a maximum spanning tree of CFG G with respect to weighting W. The edges that are not in the spanning tree solve Eprof (Ecnt) and minimize the cost of Ecnt. As a result, counters are placed in areas of lower execution frequency in the CFG.
Reference: 69. <author> D. W. Wall, </author> <title> Predicting program behavior using real or estimated profiles, </title> <booktitle> Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(6) pp. </journal> <month> 59-70 (June, </month> <year> 1991). </year>
Reference-contexts: In the example of Figure 3.15 (b), the maximum spanning tree for the given weighting (determined by his heuristic) induces a sub-optimal counter placement. Wall experimented with a number of heuristics for estimating basic block and procedure profiles solely from program text, reporting poor results <ref> [69] </ref>. Wall's heuristics use information about loop nesting and call graph structure to predict basic block and procedure profiles, but do not take into account conditional control-flow (i.e., predicting that code that is more deeply nested in conditionals is executed less frequently), as our heuristic does.
Reference: 70. <author> M. Weiser, </author> <title> Programmers use slices when debugging, </title> <journal> Communications of the ACM 25(7) pp. </journal> <month> 446-452 (July </month> <year> 1982). </year>
Reference-contexts: We consider three such semantics-based software tools: slicing, differencing, and integration tools. A slicing tool computes a projection (slice) of a program that preserves the behavior of the original program at a particular program statement <ref> [70] </ref>. Such a tool is clearly useful for debugging, since a slice ignores those parts of a program that cannot contribute to a 2 particular computation. The operation of slicing is also important to differencing and integrating.
Reference: 71. <author> M. Weiser, </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July, </month> <year> 1984). </year>
Reference-contexts: The control dependence subgraph of PDG (G), denoted by CDG (G), contains only control dependence edges. control dependences and dashed edges are flow dependences. 5.3. SLICING PROGRAMS Program slicing, a program transformation originally defined by Mark Weiser <ref> [71] </ref>, is useful in program debugging [42], program maintenance [30], and other applications that involve understanding program behavior [31]. <p> Our algorithm works for programs with completely arbitrary control-flow, including irreducible control-flow [1]. Algorithms for slicing programs with structured control-flow have been defined by Weiser <ref> [71] </ref> and by the Ottensteins [52]. Neither of these algorithms works correctly for programs with unstructured control-flow. Lyle developed an ad-hoc algorithm for slicing programs in the presence of arbitrary control-flow but his algorithm is overly conservative, as described by Gallagher [21]. <p> RELATED WORK As mentioned previously, Weiser defined the first program slicing algorithm <ref> [71] </ref>. The Otten-steins defined a more efficient program slicing algorithm using the program dependence graph [52]. Neither algorithm handles unstructured control-flow correctly.
Reference: 72. <author> W. Yang, </author> <title> Identifying syntactic differences between two programs, </title> <journal> Software-Practice & Experience 21(7) pp. </journal> <month> 739-755 (July </month> <year> 1991). </year>
Reference-contexts: For example, Horwitz suggests a number of approaches for computing a correspondence based on pro gram dependences [31], while Yang gives an algorithm that finds a maximal syntactic match between two programs by dynamic programming <ref> [72] </ref>. We will not concern ourselves here with how a correspondence is established, relying on one of the above techniques to provide the mapping between programs. 5.5. <p> Yang developed a tool called cdiff that computes the syntactic difference of two C programs <ref> [72] </ref>. This tool goes a step beyond spiff by representing programs as abstract syntax trees rather than a stream of tokens and comparing the abstract syntax trees.

References-found: 72

