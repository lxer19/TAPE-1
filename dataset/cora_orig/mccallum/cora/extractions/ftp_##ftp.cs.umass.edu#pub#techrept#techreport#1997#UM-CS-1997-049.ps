URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1997/UM-CS-1997-049.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/97-049.html
Root-URL: 
Title: Property Specification Patterns for Finite-State Verification  
Author: Matthew B. Dwyer George S. Avrunin James C. Corbett 
Affiliation: Kansas State University  University of Massachusetts  University of Hawaii  
Abstract: Finite-state verification (e.g., model checking) provides a powerful means to detect errors that are often subtle and difficult to reproduce. Nevertheless, the transition of this technology from research to practice has been slow. While there are a number of potential causes for reluctance in adopting such formal methods in practice, we believe that a primary cause rests with the fact that practitioners are unfamiliar with specification processes, notations, and strategies. Recent years have seen growing success in leveraging experience with design and coding patterns. We propose a pattern-based approach to the presentation, codification and reuse of property specifications for finite-state verification.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Anderson, P. Beame, S. Burns, W. Chan, F. Modugno, D. Notkin, and J. Reese. </author> <title> Model checking large software specifications. </title> <journal> Software Engineering Notes, </journal> <volume> 21(6) </volume> <pages> 156-166, </pages> <month> Nov. </month> <year> 1996. </year> <booktitle> Proceedings of the Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering. </booktitle>
Reference: [2] <author> B. Appleton. </author> <title> Patterns and Software: Essential Concepts and Terminology. </title> <note> http://www.enteract.com/~bradapp/docs/patterns-intro.html, 1997. </note>
Reference-contexts: Patterns seek to generalize experience across multiple specific problems. Care must be taken, however, to keep patterns from being too abstract or removed from practice. A well-defined design pattern has the following characteristics <ref> [2] </ref>: It Solves a Specific Problem, or class of problems, rather than being an abstract principle or strategy. It is a Proven Concept that has been demonstrated to be effective in prac <p>- tice. The Solution isn't Obvious and is not a direct application of basic princi <br>- ples.
Reference: [3] <author> G. Avrunin, U. Buy, J. Corbett, L. Dillon, and J. Wileden. </author> <title> Automated anal-ysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Tool support is available for a variety of verification techniques including, for example, techniques based on model checking [23], bisimulation [8], language containment [18], flow analysis [15], and inequality necessary conditions <ref> [3] </ref>. In contrast to mechanical theorem proving, which often requires guidance by an expert, most finite-state verification techniques can be fully automated, thus relieving the user of the need to understand the inner workings of the verification process.
Reference: [4] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal. </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons Ltd., </publisher> <year> 1996. </year>
Reference-contexts: We plan on using the pattern system again and gathering additional anecdotal evidence while teaching the course a second time in the Fall of 1997. 6 Conclusions Patterns and the people who define them are characterized by an "aggressive disregard for originality" <ref> [4] </ref>. Patterns are not research; they are an expression of best-practice in a software domain. A pattern system does not belong to an individual, but to the community of experts and practitioners who contribute to and use it.
Reference: [5] <author> B. G. Cain, J. O. Coplien, and N. B. Harrison. </author> <title> Social Patterns in Productive Software Organizations. </title> <journal> Annals of Software Engineering, </journal> <volume> 2 </volume> <pages> 259-286, </pages> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: For example, the idea of patterns has been applied to describe data models [19], system level analysis and modeling information [16], software process and organizational structures <ref> [5] </ref>, and curricula for educating software developers [22].
Reference: [6] <author> A. Chamillard. </author> <title> An Empirical Comparison of Static Concurrency Analysis Techniques. </title> <type> PhD thesis, </type> <institution> University of Massachusetts at Amherst, </institution> <month> May </month> <year> 1996. </year>
Reference: [7] <author> E. Clarke, E. Emerson, and A. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> Apr. </month> <year> 1986. </year>
Reference-contexts: Some specification formalisms (e.g., quantified regular expressions (QRE) [25]) are event-based, while others (e.g., various temporal logics, such as LTL and computation tree logic (CTL) <ref> [7] </ref>) are state-based. In our patterns, capital letters (e.g., P , Q, R, S) stand for events or disjunctions of events in event-based formalisms and stand for state formulas in state-based formalisms.
Reference: [8] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The concurrency workbench: A semantics based tool for the verification of concurrent systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Properties are typically specified with temporal logics or regular expressions, while systems are specified as finite-state transition systems of some kind. Tool support is available for a variety of verification techniques including, for example, techniques based on model checking [23], bisimulation <ref> [8] </ref>, language containment [18], flow analysis [15], and inequality necessary conditions [3]. In contrast to mechanical theorem proving, which often requires guidance by an expert, most finite-state verification techniques can be fully automated, thus relieving the user of the need to understand the inner workings of the verification process. <p> The full patterns will contain additional examples, explanation of pattern relationships, and mappings in other formalisms including Graphical Interval Logic (GIL) [12], the INCA query language [11], automata, and various process algebra formalisms (e.g., CCS and CSP) <ref> [8] </ref>. Here we give the intent of some common patterns. Occurrence Patterns include Absence A given state/event does not occur within a scope. This pattern is also known as Never. Figure 1 gives the key elements of the pattern. Existence A given state/event must occur within a scope.
Reference: [9] <author> J. Coplien. </author> <title> Organizational Patterns. </title> <address> http://www.bell-labs.com/ cgi-user/OrgPatterns/OrgPatterns?Organizationa%lPatterns, </address> <year> 1997. </year>
Reference-contexts: For these reasons, the system described in this paper should only be viewed as a starting point. If it is to become useful it must grow through a process of open dialog and critical review. There are efforts underway in other pattern domains (e.g., <ref> [9] </ref>) to provide a web-based mechanism for such collaborative development of pattern systems.
Reference: [10] <author> J. Coplien and D. Schmidt, </author> <title> editors. Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: It Describes Relationships between solution components rather than iso <br>- lated components of a solution. It is Generative in that it demonstrates how to construct a solution. 3 An active community has grown up around the idea of design patterns, as evidenced by the formation of numerous workshops (e.g., <ref> [10] </ref>) and recently the notion of patterns has been spreading to other software related endeavors. For example, the idea of patterns has been applied to describe data models [19], system level analysis and modeling information [16], software process and organizational structures [5], and curricula for educating software developers [22].
Reference: [11] <author> J. C. Corbett and G. S. Avrunin. </author> <title> Using integer programming to verify general safety and liveness properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 6 </volume> <pages> 97-123, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: The full patterns will contain additional examples, explanation of pattern relationships, and mappings in other formalisms including Graphical Interval Logic (GIL) [12], the INCA query language <ref> [11] </ref>, automata, and various process algebra formalisms (e.g., CCS and CSP) [8]. Here we give the intent of some common patterns. Occurrence Patterns include Absence A given state/event does not occur within a scope. This pattern is also known as Never. Figure 1 gives the key elements of the pattern.
Reference: [12] <author> L. K. Dillon, G. Kutty, L. E. Moser, P. M. Melliar-Smith, and Y. S. Ramakrishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(2):131165, </volume> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: The full patterns will contain additional examples, explanation of pattern relationships, and mappings in other formalisms including Graphical Interval Logic (GIL) <ref> [12] </ref>, the INCA query language [11], automata, and various process algebra formalisms (e.g., CCS and CSP) [8]. Here we give the intent of some common patterns. Occurrence Patterns include Absence A given state/event does not occur within a scope. This pattern is also known as Never.
Reference: [13] <author> M. Dwyer, G. Avrunin, and J. Corbett. </author> <title> A System of Specification Patterns. </title> <note> http://www.cis.ksu.edu/~dwyer/spec-patterns.html, 1997. </note>
Reference-contexts: In our experience, only a small fraction of the possible constraints that can be specified using logics or regular 7 expressions commonly occur in practice. 4.1 The Patterns Space limitations prohibit description of the patterns in full detail; for that we have set up a web-site <ref> [13] </ref>. The full patterns will contain additional examples, explanation of pattern relationships, and mappings in other formalisms including Graphical Interval Logic (GIL) [12], the INCA query language [11], automata, and various process algebra formalisms (e.g., CCS and CSP) [8]. Here we give the intent of some common patterns. <p> We believe that specification patterns would flourish if a similar collaboration were undertaken by the formal specification community and towards this end we have set up a web-site <ref> [13] </ref> to store the current and future versions of the specification patterns system.
Reference: [14] <author> M. Dwyer, V. Carr, and L. Hines. </author> <title> Model checking graphical user inter-faces using abstractions. </title> <booktitle> In Proceedings of the Sixth Software Engineering Conference together with the Fifth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <month> Sept. </month> <year> 1997. </year> <note> to appear. </note>
Reference-contexts: We believe this group is representative of a broad class of practicing software developers who are clearly not experts in formal methods. The course involved development of a significant collection of formal specifications for selected realistic systems including graphical user interfaces <ref> [14] </ref>, transactional processing in an inventory control system, an automobile control system, and a home security system. These specifications were derived from informal English language statements of system requirements, 9 which had been refined into a stylized structured English. The specifications were subsequently verified using model-checking.
Reference: [15] <author> M. Dwyer and L. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <journal> Software Engineering Notes, </journal> <volume> 19(5) </volume> <pages> 62-75, </pages> <month> Dec. </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering. </booktitle>
Reference-contexts: Properties are typically specified with temporal logics or regular expressions, while systems are specified as finite-state transition systems of some kind. Tool support is available for a variety of verification techniques including, for example, techniques based on model checking [23], bisimulation [8], language containment [18], flow analysis <ref> [15] </ref>, and inequality necessary conditions [3]. In contrast to mechanical theorem proving, which often requires guidance by an expert, most finite-state verification techniques can be fully automated, thus relieving the user of the need to understand the inner workings of the verification process.
Reference: [16] <author> M. Fowler, </author> <title> editor. Analysis Patterns: Reusable Object Models. </title> <address> AddisonWesley, </address> <year> 1997. </year>
Reference-contexts: For example, the idea of patterns has been applied to describe data models [19], system level analysis and modeling information <ref> [16] </ref>, software process and organizational structures [5], and curricula for educating software developers [22].
Reference: [17] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We propose to capture this experience base and enable the transfer of that experience between practitioners by way of a specification pattern system. Patterns were originally developed to capture recurring solutions to design and coding problems <ref> [17] </ref>. Design and coding languages are rich expressive formalisms that provide for a wide-variety of solutions to a given problem, but the full range of possible solutions is is usually much wider than is necessary or useful. Patterns are successful because practitioners want to solve naturally occurring domain problems. <p> Section 4 describes an initial specification pattern system for finite-state verification. We then evaluate and discuss the usefulness of the pattern system and mechanisms through which this system can mature and grow. Section 6 summarizes and concludes. 2 Design and Other Patterns Design patterns were introduced <ref> [17] </ref> as a means of leveraging the experience of expert system designers. Patterns are intended to capture not only a description of recurring solutions to software design problems, but also the requirements addressed by the solution, the means by which the requirements are satisfied, and examples of the solution. <p> A property specification pattern describes the essential structure of some aspect of a system's behavior and provides expressions of this behavior in a range of common formalisms. Example specification patterns are given in Figures 1 and 2 (we use a variant of the "gang-of-four" pattern format <ref> [17] </ref>). A pattern comprises a name or names, a precise statement of the pattern's intent (i.e., the structure of the behavior described), mappings into common specification formalisms, examples of known uses, and relationships to other patterns.
Reference: [18] <author> Z. Har'El and R. P. Kurshan. </author> <title> Software for analytical devleopment of com-munication protocols. </title> <journal> AT&T Technical Journal, </journal> <volume> 69(1) </volume> <pages> 44-59, </pages> <year> 1990. </year>
Reference-contexts: Properties are typically specified with temporal logics or regular expressions, while systems are specified as finite-state transition systems of some kind. Tool support is available for a variety of verification techniques including, for example, techniques based on model checking [23], bisimulation [8], language containment <ref> [18] </ref>, flow analysis [15], and inequality necessary conditions [3]. In contrast to mechanical theorem proving, which often requires guidance by an expert, most finite-state verification techniques can be fully automated, thus relieving the user of the need to understand the inner workings of the verification process.
Reference: [19] <author> D. Hay, </author> <title> editor. Data Model Patterns: Conventions of Thought. </title> <publisher> Dorset House Publishing, </publisher> <year> 1995. </year>
Reference-contexts: For example, the idea of patterns has been applied to describe data models <ref> [19] </ref>, system level analysis and modeling information [16], software process and organizational structures [5], and curricula for educating software developers [22].
Reference: [20] <author> L. Lamport. </author> <title> Proving the correctness of multiprocess programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-3(2):125-143, </volume> <year> 1977. </year>
Reference-contexts: These patterns outline how boolean combinations can be applied in different cases. 4.2 Related Work There have been some attempts at describing taxonomies for property specifications. The most popular and long-lived of these distinguishes safety and liveness properties <ref> [20] </ref>. While this provides a very high-level intuitive understanding of classes of specifications, i.e., "nothing bad will ever happen" vs. "something good will eventually happen" it is much too coarse to be of practical use in constructing particular specifications.
Reference: [21] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: For example, a user who wants to verify that "Between process A updating a value and process B reading the value, the value must be flushed from process A's cache" using a linear temporal logic (LTL) <ref> [21] </ref> model checker would have to translate this prose into the formula: 2 ((UpdateA ^ 3ReadB) ! :ReadB U FlushA) Although the property and the formula are relatively simple, writing the LTL formula requires knowledge of several standard LTL idioms. <p> While this provides a very high-level intuitive understanding of classes of specifications, i.e., "nothing bad will ever happen" vs. "something good will eventually happen" it is much too coarse to be of practical use in constructing particular specifications. Manna and Pnueli <ref> [21] </ref> describe a finer taxonomy based on the syntactic structure of LTL formulae. This taxonomy is defined in terms of canonical forms. Some of these forms do not match the way that specifications are typically encoded in LTL, so they provide some alternate codings for canonical forms.
Reference: [22] <author> M. Manns, H. Sharp, P. McLaughlin, and M. Prieto. </author> <title> Pedagogical Patterns: Successes in Teaching Object Technology. </title> <address> http://www.cs.unca. edu/~manns/oopsla.html, </address> <year> 1997. </year> <month> 12 </month>
Reference-contexts: For example, the idea of patterns has been applied to describe data models [19], system level analysis and modeling information [16], software process and organizational structures [5], and curricula for educating software developers <ref> [22] </ref>.
Reference: [23] <author> K. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Properties are typically specified with temporal logics or regular expressions, while systems are specified as finite-state transition systems of some kind. Tool support is available for a variety of verification techniques including, for example, techniques based on model checking <ref> [23] </ref>, bisimulation [8], language containment [18], flow analysis [15], and inequality necessary conditions [3].
Reference: [24] <author> G. Naumovich, L. Clarke, and L. Osterweil. </author> <title> Verification of communication protocols using data flow analysis. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <month> Oct. </month> <year> 1996. </year>
Reference: [25] <author> K. Olender and L. Osterweil. Cecil: </author> <title> A sequencing constraint language for automatic static analysis generation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: A pattern comprises a name or names, a precise statement of the pattern's intent (i.e., the structure of the behavior described), mappings into common specification formalisms, examples of known uses, and relationships to other patterns. Some specification formalisms (e.g., quantified regular expressions (QRE) <ref> [25] </ref>) are event-based, while others (e.g., various temporal logics, such as LTL and computation tree logic (CTL) [7]) are state-based. In our patterns, capital letters (e.g., P , Q, R, S) stand for events or disjunctions of events in event-based formalisms and stand for state formulas in state-based formalisms.
Reference: [26] <author> D. Rosenblum. </author> <title> Formal methods and testing: Why the state-of-the-art is not the state-of-the-practice (ISSTA'96/FMSP'96 panel summary). </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 21(4), </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: In addition to a lack of definitive evidence in support of the cost- saving benefits of formal methods, a number of more pragmatic barriers to adoption of formal methods have been identified <ref> [26] </ref> including the lack of good tool support, expertise in organizations, good training materials, and process support for formal methods. We believe that the recent availability of tool support for finite-state verification provides an opportunity to overcome some of these barriers.
Reference: [27] <author> J. Wing and M. Vaziri-Farahani. </author> <title> Model checking software systems: A case study. </title> <journal> Software Engineering Notes, </journal> <volume> 20(4) </volume> <pages> 128-139, </pages> <month> Oct. </month> <year> 1995. </year> <booktitle> Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering. </booktitle> <pages> 13 </pages>
References-found: 27

