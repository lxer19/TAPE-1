URL: http://www.win.tue.nl/inf/onderzoek/csr/abs/95.02.ps
Refering-URL: http://www.win.tue.nl/inf/onderzoek/publicaties.html
Root-URL: http://www.win.tue.nl
Title: Formalizing Process Algebraic Verifications in the Calculus of Constructions  
Author: Marc Bezem Jan Friso Groote Roland Bol 
Keyword: formal verification, process algebra, ACP, CRL, Coq Calculus of Constructions, Alternating Bit Protocol.  
Address: Heidelberglaan 8  The Netherlands  P.O.Box 325 S-751 05 Uppsala Sweden  
Affiliation: Utrecht University  Utrecht  Department of Computer Systems Uppsala University  
Pubnum: NL-3584 CS  
Email: Email: fMarc.Bezem, JanFriso.Grooteg@phil.ruu.nl  Email: rolandb@docs.uu.se  
Degree: Department of Philosophy  
Abstract: This paper reports on the first steps towards the formal verification of correctness proofs of real-life protocols in process algebra. We show that proofs can be verified, and partly constructed, by a general purpose proof checker. The process algebra we use is CRL, ACP o augmented with data, which is small enough to make the verification feasible, and at the same time expressive enough for the specification of real-life protocols. The proof checker we use is Coq, which is based on the Calculus of Constructions, an extension of simply typed lambda calculus. The focus is on the translation of the proof theory of CRL and CRL-specifications to Coq. As a case study, we verified the Alternating Bit Protocol. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar92] <author> H.P. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <pages> pages 117-309. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Errors in the underlying theory of the proof checker. This theory should be stable and well-understood. For Coq, simply typed lambda calculus <ref> [Bar92] </ref> is basic and the Calculus of Constructions [CH88] is well-understood. The theory of inductive types ([CP90, PM93], see Section 2.4) requires more study. 3. Programming errors in the proof checker. Indeed, the correctness of the proof checker must be checked thoroughly.
Reference: [BB92] <author> J.C.M. Baeten and J.A. Bergstra. </author> <title> Discrete time process algebra. </title> <editor> In W.R. Cleaveland, editor, </editor> <booktitle> Proceedings Concur'92, </booktitle> <volume> LNCS 630, </volume> <pages> pages 401-420. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Moreover, it requires the concistency of Coq, a result which is outside the scope of process algebra. * Verification of other protocols, probably developing new proof techniques at the same time, see e.g. [BG94a, KS93, GP93a]. * Extending CRL with (discrete) real time <ref> [BB92] </ref> and translating the resulting formalism to Coq in order to verify timed protocols [KP93, Klu91]. * Investigate if other proof checkers, or perhaps even theorem provers, are more suitable than Coq for the verification of protocols.
Reference: [BG93] <editor> M. Bezem and J.F. Groote. </editor> <title> A formal verification of the alternation bit protocol in the calculus of constructions. </title> <type> Technical Report 88, </type> <institution> Logic Group Preprint Series, Utrecht University, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: As a case study, we verified the Alternating Bit Protocol (ABP) [BSW69]. We chose this protocol, not because there was any doubt about its correctness, but because it is small, well-known, and numerous correctness proofs are available in the literature <ref> [BW90, BK86b, BG93, Dro94, Kam93] </ref>. The process algebra we use is based on the Algebra of Communicating Processes (ACP) of Bergstra and Klop [BK86a].
Reference: [BG94a] <editor> M. Bezem and J.F. Groote. </editor> <title> A correctness proof of a one-bit sliding window protocol in CRL. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 289-307, </pages> <year> 1994. </year>
Reference-contexts: In this stage of the development of the field it is very difficult to establish the relative merit of each of the results above, since their diversity makes comparison practically impossible. However, recent experience shows that the algebraic method discussed in this paper can handle larger protocols as well <ref> [BG94a, KS93, GP93a] </ref>. In the next section, we give an overview of CRL and the ABP. Then we formalize the ABP in CRL and sketch roughly the proof of its correctness. An introduction to Coq concludes this section. <p> Moreover, it requires the concistency of Coq, a result which is outside the scope of process algebra. * Verification of other protocols, probably developing new proof techniques at the same time, see e.g. <ref> [BG94a, KS93, GP93a] </ref>. * Extending CRL with (discrete) real time [BB92] and translating the resulting formalism to Coq in order to verify timed protocols [KP93, Klu91]. * Investigate if other proof checkers, or perhaps even theorem provers, are more suitable than Coq for the verification of protocols.
Reference: [BG94b] <editor> M. Bezem and J.F. Groote. </editor> <title> Invariants in process algebra with data. </title> <editor> In B. Jonsson and J. Parrow, editors, </editor> <booktitle> Proceedings Concur'94, </booktitle> <volume> LNCS 836, </volume> <pages> pages 401-416. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: First, we consider the case of a single recursive equation. Such an equation, written as X (d) = G (X; d), can be seen as the definition of the process operator G of type (D-&gt;proc)->D->proc. (This is a generalization of the linear process operators of <ref> [BG94b] </ref>, where G must be in a particular normal form.) A solution of the recursive equation is then a fixed point of G, and has type D-&gt;proc. <p> (neg true)))) =(hide Hiding (sum Dtype (First true))) Replacing (neg (neg true)) by true and then (ABP nohide true) by (sum Dtype (First true)) concludes the proof. 48 6 Future Work A number of directions for future research are immediately obvious: * Improving the proof theory of CRL, see e.g. <ref> [BG94b] </ref>. * Improving the proof techniques of this paper, in particular linearization and the verification of the premisses of CFAR. * Proving the soundness of the translation w.r.t. CRL. This is a moving target, as changes to Coq are still made, and changes to CRL are proposed, e.g. in [GW94].
Reference: [BG94c] <editor> M. Bezem and J.F. Groote. </editor> <title> Proving a graph well founded using resolution. </title> <type> Technical Report 113, </type> <institution> Logic Group Preprint Series, Utrecht University, </institution> <month> May </month> <year> 1994. </year> <month> 49 </month>
Reference-contexts: R must be well-founded for the system to be guarded. 10 Rather than writing an axiomatization that tries to compute R, we let the user provide R. Then we check that R is well-founded (see also <ref> [BG94c] </ref>) and that for all process variables X and data e of the type for X, the body of the equation for X (e) is safe w.r.t.
Reference: [BK86a] <author> J.A. Bergstra and J.W. Klop. </author> <title> Process algebra: specification and verification in bisimulation semantics. </title> <editor> In M. Hazewinkel, J.K. Lenstra, and L.G.L.T. Meertens, editors, </editor> <booktitle> Mathematics and Computer Science II, CWI Monograph 4, </booktitle> <pages> pages 61-94. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1986. </year>
Reference-contexts: The process algebra we use is based on the Algebra of Communicating Processes (ACP) of Bergstra and Klop <ref> [BK86a] </ref>. More precisely, we use CRL, ACP o augmented with data [GP94, GP93b], which is small enough to make the verification feasible, and at the same time expressive enough for the specification of real-life protocols.
Reference: [BK86b] <author> J.A. Bergstra and J.W. Klop. </author> <title> Verification of an alternating bit protocol by means of process algebra. </title> <editor> In W. Bibel and K.P Jantke, editors, </editor> <title> Math. Methods of Spec. </title> <booktitle> and Synthesis of Software Systems 1985, </booktitle> <volume> LNCS 215, </volume> <pages> pages 9-23. </pages> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: As a case study, we verified the Alternating Bit Protocol (ABP) [BSW69]. We chose this protocol, not because there was any doubt about its correctness, but because it is small, well-known, and numerous correctness proofs are available in the literature <ref> [BW90, BK86b, BG93, Dro94, Kam93] </ref>. The process algebra we use is based on the Algebra of Communicating Processes (ACP) of Bergstra and Klop [BK86a].
Reference: [BSW69] <author> K.A. Bartlett, R.A. Scantlebury, and P.T. Wilkinson. </author> <title> A note on reliable full-duplex transmission over half-duplex links. </title> <journal> Communications of the ACM, </journal> <volume> 12 </volume> <pages> 260-261, </pages> <year> 1969. </year>
Reference-contexts: We show that proofs can be verified, and partly constructed, by a general purpose proof checker. The focus is on the translation of process algebra (specifications and proof theory) to the language of the proof checker. As a case study, we verified the Alternating Bit Protocol (ABP) <ref> [BSW69] </ref>. We chose this protocol, not because there was any doubt about its correctness, but because it is small, well-known, and numerous correctness proofs are available in the literature [BW90, BK86b, BG93, Dro94, Kam93].
Reference: [BW90] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra, </title> <booktitle> volume 18 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: As a case study, we verified the Alternating Bit Protocol (ABP) [BSW69]. We chose this protocol, not because there was any doubt about its correctness, but because it is small, well-known, and numerous correctness proofs are available in the literature <ref> [BW90, BK86b, BG93, Dro94, Kam93] </ref>. The process algebra we use is based on the Algebra of Communicating Processes (ACP) of Bergstra and Klop [BK86a]. <p> Consider for example the correctness proof of the ABP given in Sections 4.7 and 5.7 of <ref> [BW90] </ref>. It consists of a series of steps so small that the reader is convinced of the correctness of each step. Indeed, the proof in [BW90] is more detailed than most other verifications, because the intended reader is an undergraduate student. <p> Consider for example the correctness proof of the ABP given in Sections 4.7 and 5.7 of <ref> [BW90] </ref>. It consists of a series of steps so small that the reader is convinced of the correctness of each step. Indeed, the proof in [BW90] is more detailed than most other verifications, because the intended reader is an undergraduate student. For centuries, this form of verification was the best there was. <p> The research on the topic of this paper is only just beginning; therefore we conclude the paper with a list of directions for future research. 3 2 Preliminaries 2.1 CRL CRL is a specification formalism, combining the process algebra ACP o <ref> [BW90] </ref> with data. <p> By convention, binds strongest and + weakest. We refer to <ref> [BW90] </ref> for an explanation of these operators. The operator j is an extension of another parameter of ACP o , the communication function fl. This is a partial function which, given two atomic actions, returns an atomic action: their communication. fl must be associative and commutative. <p> For the same reasons, it is preferable that such details need not be provided to the proof checker explicitly. 2 For processes, CRL inherited the axioms A1-A7, CM1-CM9, D1-D4, T1 (called B1 in <ref> [BW90] </ref>) and TI1-TI4 from ACP o , listed in Table 2 (CM6 is derivable). All closed instances without process variables of the axioms SC1-SC5, DC1, TC1, and Handshaking are derivable. SC3 and SC4 directly reflect the properties of the communication function fl (corresponding axioms for k are mentioned also in [BW90], <p> <ref> [BW90] </ref>) and TI1-TI4 from ACP o , listed in Table 2 (CM6 is derivable). All closed instances without process variables of the axioms SC1-SC5, DC1, TC1, and Handshaking are derivable. SC3 and SC4 directly reflect the properties of the communication function fl (corresponding axioms for k are mentioned also in [BW90], but these are derivable). The handshaking assumption similarly results in the axiom Handshaking. SC4, CM5, CM6, and CM9 are derivable. The axioms for the communication merge are more complicated than those of ACP o , because of the presence of data. <p> RDP, the Recursive Definition Principle, states that such a specification has at least one solution. RSP, the Recursive Specification Principle, states that two processes are equal, if they are both solutions of the same guarded recursive specification. The Cluster Fair Abstraction Rule CFAR <ref> [BW90] </ref> can be paraphrased informally as: `Any process will eventually leave a o -cluster'. <p> It follows closely the definition of the ABP in <ref> [BW90] </ref>, except that now data is treated more formally (which also involved some renamings). We make no difference between a bit and a boolean. Therefore we have no separate sort bit, but use Bool instead. <p> For additional details we refer to Sections 4.7 and 5.7 of <ref> [BW90] </ref>. We use H to abbreviate fr 2 ; s 2 ; r 3 ; s 3 ; r 5 ; s 5 ; r 6 ; s 6 g and I to abbreviate fc 2 ; c 3 ; c 5 ; c 6 ; ig. <p> If we fill in all parameters of X, we obtain a state of the protocol, and the equation then gives all possible actions with their resulting states. This linearization is depicted in Figure 22 of <ref> [BW90] </ref>; Figure 3 and 4 constitute the same figure somewhat simplified. In these definitions, we use the syntax hX j Ei from [BW90] to denote the process defined by the process variable X in the recursive specification E. <p> This linearization is depicted in Figure 22 of <ref> [BW90] </ref>; Figure 3 and 4 constitute the same figure somewhat simplified. In these definitions, we use the syntax hX j Ei from [BW90] to denote the process defined by the process variable X in the recursive specification E. The advantage of this notation over CRL is that we can distinguish various (sub)systems of equations. <p> The first two properties are that delta and tau do not communicate. The third is that the communication of two actions is not o (allowing this would complicate defining guardedness, see Section 3.6). The fourth is that gamma is commutative, as is required in <ref> [BW90] </ref>. It is also required there that gamma is associative, but we assumed handshaking, the fifth property, which is stronger. Goal (a :act) &lt;act&gt;(gamma delta a )=delta. Goal (a :act) &lt;act&gt;(gamma tau a )=delta. Goal (a,b :act)~&lt;act&gt;(gamma a b )=tau. Goal (a,b :act) &lt;act&gt;(gamma a b )=(gamma b a). <p> For example, following the notation of <ref> [BW90] </ref>, we could have E = fX = a hX 0 j E 0 X ig, with E 0 X = fX 0 = X + b X 0 g. <p> This assumption was translated into process algebra in various ways, most notably in the form of fair abstraction rules. For an overview we refer to Section 5.6 of <ref> [BW90] </ref>. We chose to translate CFAR b into Coq (Cluster Fair Abstraction Rule for branching bisimulation, we omit the superscript b further on).
Reference: [CAB + 86] <author> R.L. Constable, S.F. Allen, H.M. Bromley, W.R. Cleave land, J.F. Cremer, R.W. Harper, D.J. Howe, T.B. Knoblock, N.P. Me ndler, P. Panangaden, J.T. Sasaki, and S.F. Smith. </author> <title> Implementing Mathematics with the NuPrl Development System. </title> <publisher> Prentice-Hall, inc., </publisher> <address> Englewood Cliffs, New Jersey, first edition, </address> <year> 1986. </year>
Reference-contexts: Earlier attempts to automatic verification of propositions of process theory are from Cleaveland and Panangaden [CP88], who gave an implementation of Milner's Calculus of Communicating Systems [Mil80] in the NuPrl system <ref> [CAB + 86] </ref> and from Engberg, Gronning and Lamport, who developed the Temporal Logic of Actions (TLA), which is a logic for specifying and reasoning about concurrent systems [EGL92]. A particularly impressive achievement is the assertional verification of wait-free linearization in [Hes94] and its formal elaboration [Hes95].
Reference: [CH88] <author> T. Coquand and G. Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Control, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: Errors in the underlying theory of the proof checker. This theory should be stable and well-understood. For Coq, simply typed lambda calculus [Bar92] is basic and the Calculus of Constructions <ref> [CH88] </ref> is well-understood. The theory of inductive types ([CP90, PM93], see Section 2.4) requires more study. 3. Programming errors in the proof checker. Indeed, the correctness of the proof checker must be checked thoroughly.
Reference: [Cou93] <editor> C. Courcoubetis, editor. </editor> <booktitle> Proceedings of the 5th International Conference on Computer Aided Verification, </booktitle> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: When we deviate from the original definitions, we do so explicitly and with motivation. If possible, we prove formally that the deviation is correct. Formal verification is not limited to algebraic verification of protocols. In principle, it can be used for any formalism <ref> [Cou93] </ref>, for example I/O-automata [LMWF94, HSV94] and temporal logic [MP82, OL82, Hoo91].
Reference: [CP88] <author> R. Cleaveland and P. Panangaden. </author> <title> Type theory and concurrency. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 17 </volume> <pages> 153-206, </pages> <year> 1988. </year>
Reference-contexts: Formal verification is not limited to algebraic verification of protocols. In principle, it can be used for any formalism [Cou93], for example I/O-automata [LMWF94, HSV94] and temporal logic [MP82, OL82, Hoo91]. Earlier attempts to automatic verification of propositions of process theory are from Cleaveland and Panangaden <ref> [CP88] </ref>, who gave an implementation of Milner's Calculus of Communicating Systems [Mil80] in the NuPrl system [CAB + 86] and from Engberg, Gronning and Lamport, who developed the Temporal Logic of Actions (TLA), which is a logic for specifying and reasoning about concurrent systems [EGL92].
Reference: [CP90] <author> T. Coquand and C. Paulin. </author> <title> Inductively Defined Types. </title> <editor> In P. Martin-Lof and G. Mints, editors, COLOG-88, </editor> <volume> LNCS 417, </volume> <pages> pages 50-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The obvious problem with this approach is of course its soundness (and completeness). However, the soundness of the encoding approach is also not immediate, as it is not even proved yet that Coq is consistent <ref> [CP90, PM93] </ref>, i.e., False might be derivable. In fact, the problem lies in the inductive sets and definitions, on which the encoding relies much more than our embedding approach.
Reference: [DFH + 93] <author> G. Dowek, A. Felty, H. Herbelin, G. Huet, C. Murthy, C. Parent, C. Paulin-Mohring, and B. Werner. </author> <title> The Coq Proof Assistant User's Guide, version 5.8. </title> <type> Technical report, </type> <institution> INRIA-Rocquencourt and CNRS - ENS Lyon, </institution> <year> 1993. </year>
Reference-contexts: More precisely, we use CRL, ACP o augmented with data [GP94, GP93b], which is small enough to make the verification feasible, and at the same time expressive enough for the specification of real-life protocols. The proof checker we use is Coq <ref> [DFH + 93] </ref>, which is based on the Calculus of Constructions, an extension of simply typed lambda calculus. fl While carrying out this research, this author was employed by Eindhoven University of Technology, P.O.Box 513, NL-5600 MB Eindhoven, The Netherlands. 1 The word `verification' usually refers to a mathematical proof in <p> I (ABP nohide (T )), and Buffer both satisfy the equation X = ( d:D X r 1 (e) s 4 (e)) X: So, a final application of RSP concludes the proof. 2 2.4 The Coq Proof Checker For a complete overview of the Coq proof checker, we refer to <ref> [DFH + 93] </ref>.
Reference: [Dro94] <author> N.J. Drost. </author> <title> Process Theory and Equation Solving. </title> <type> PhD thesis, </type> <institution> University of Amster-dam, </institution> <month> February </month> <year> 1994. </year> <note> (Section 2.5.1). </note>
Reference-contexts: As a case study, we verified the Alternating Bit Protocol (ABP) [BSW69]. We chose this protocol, not because there was any doubt about its correctness, but because it is small, well-known, and numerous correctness proofs are available in the literature <ref> [BW90, BK86b, BG93, Dro94, Kam93] </ref>. The process algebra we use is based on the Algebra of Communicating Processes (ACP) of Bergstra and Klop [BK86a].
Reference: [EGL92] <author> U. Engberg, P. Gronning, and L. Lamport. </author> <title> Mechanical verification of concurrent systems with TLA. </title> <editor> In G. v. Bochmann and D.K. Probst, editors, </editor> <booktitle> Proceedings of the 4th International Workshop on Computer Aided Verification, Montreal, Canada, volume 663 of Lecture Notes in Computer Science, </booktitle> <pages> pages 44-55. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: theory are from Cleaveland and Panangaden [CP88], who gave an implementation of Milner's Calculus of Communicating Systems [Mil80] in the NuPrl system [CAB + 86] and from Engberg, Gronning and Lamport, who developed the Temporal Logic of Actions (TLA), which is a logic for specifying and reasoning about concurrent systems <ref> [EGL92] </ref>. A particularly impressive achievement is the assertional verification of wait-free linearization in [Hes94] and its formal elaboration [Hes95]. A recent approach to the ABP can be found in [Gim95], where the behaviour af processes is modelled by streams encoded as co-inductive types of Coq.
Reference: [Gim95] <author> E. Gimenez. </author> <title> Co-Inductive Types in Coq : An Experiment with the Alternating Bit Protocol. Submitted for the proceedings of the BRA Workshop on Types for Proofs and Programs. </title> <note> Also available by ftp at ftp.ens-lyon.fr/pub/users/LIP/ABP.ps.Z, </note> <month> June </month> <year> 1995. </year> <month> 50 </month>
Reference-contexts: A particularly impressive achievement is the assertional verification of wait-free linearization in [Hes94] and its formal elaboration [Hes95]. A recent approach to the ABP can be found in <ref> [Gim95] </ref>, where the behaviour af processes is modelled by streams encoded as co-inductive types of Coq. In this stage of the development of the field it is very difficult to establish the relative merit of each of the results above, since their diversity makes comparison practically impossible.
Reference: [GP93a] <author> J.F. Groote and J. van de Pol. </author> <title> A bounded retransmission protocol for large data packets. </title> <type> Technical Report 100, </type> <institution> Logic Group Preprint Series, Utrecht University, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: In this stage of the development of the field it is very difficult to establish the relative merit of each of the results above, since their diversity makes comparison practically impossible. However, recent experience shows that the algebraic method discussed in this paper can handle larger protocols as well <ref> [BG94a, KS93, GP93a] </ref>. In the next section, we give an overview of CRL and the ABP. Then we formalize the ABP in CRL and sketch roughly the proof of its correctness. An introduction to Coq concludes this section. <p> Moreover, it requires the concistency of Coq, a result which is outside the scope of process algebra. * Verification of other protocols, probably developing new proof techniques at the same time, see e.g. <ref> [BG94a, KS93, GP93a] </ref>. * Extending CRL with (discrete) real time [BB92] and translating the resulting formalism to Coq in order to verify timed protocols [KP93, Klu91]. * Investigate if other proof checkers, or perhaps even theorem provers, are more suitable than Coq for the verification of protocols.
Reference: [GP93b] <author> J.F. Groote and A. Ponse. </author> <title> Proof theory for CRL: a language for processes with data. In D.J. Andrews, </title> <editor> J.F. Groote, and C.A. Middelburg, editors, </editor> <booktitle> Proceedings of the International Workshop on Semantics of Specification Languages, </booktitle> <address> Utrecht, The Netherlands, </address> <pages> pages 231-250. </pages> <publisher> Workshops in Computer Science, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The process algebra we use is based on the Algebra of Communicating Processes (ACP) of Bergstra and Klop [BK86a]. More precisely, we use CRL, ACP o augmented with data <ref> [GP94, GP93b] </ref>, which is small enough to make the verification feasible, and at the same time expressive enough for the specification of real-life protocols. <p> We give a brief and informal introduction here; for a complete description of its syntax and semantics we refer to [GP94], for its proof theory to <ref> [GP93b] </ref>. 2.1.1 Syntax and Semantics An algebra is usually a set, together with a number of operations on that set, in principle axiom-atized by an equational theory. ACP o complies with this tradition. <p> boolean preserving [GP94], that is, T 6= F and for all booleans b: b = T _ b = F , thus in particular eq D (d; e) 6= T ! eq D (d; e) = F . 2 2.1.2 Proof Theory The proof theory of CRL is given in <ref> [GP93b] </ref> in a `natural deduction' format. The formulae deduced (`CRL property formulae') are mostly equations, and logical combinations of those. The axioms and rules can be divided into four parts: data, ACP o , process constructs relating processes with data and logical connectives. <p> CRL has no explicit quantification; the rule SUB enforces that each variable is implicitly universally quantified. Its application is only allowed when x does not occur in any hypothesis needed for deriving OE. For the precise definitions of substitutions and induction rules we refer to <ref> [GP93b] </ref>. An induction rule for a sort is based on a set of constructors for that sort. Which functions form a constructor set of a sort is not part of the CRL-specification (but see [GW94]). <p> For the logical connectives, CRL has a large number of inference rules. For those, we refer to <ref> [GP93b] </ref> (see also the proof below), except that we mention the rule RAA (reductio ad absurdum), stating that if falsum (?) is derivable from :OE, then OE can be derived. As usual :OE abbreviates OE !?, thus negation and implication behave classically. <p> The handshaking assumption similarly results in the axiom Handshaking. SC4, CM5, CM6, and CM9 are derivable. The axioms for the communication merge are more complicated than those of ACP o , because of the presence of data. The presentation here differs slightly from <ref> [GP93b] </ref>, where actions without parameters are treated as a special case. See also Section 3. The axioms for the conditional and sum operators are mostly obvious. For SUM8 and SUM9, recall that encapsulation and hiding are carried out at the level of action names. In [GP93b], SUM10 states that renaming distributes <p> presentation here differs slightly from <ref> [GP93b] </ref>, where actions without parameters are treated as a special case. See also Section 3. The axioms for the conditional and sum operators are mostly obvious. For SUM8 and SUM9, recall that encapsulation and hiding are carried out at the level of action names. In [GP93b], SUM10 states that renaming distributes over summation; we have omitted renaming here. The rules REFL, REPL, and SUB also apply to processes. The counterpart of FACT is called REC: p = q if p = q is a process equation. <p> A large number of lemmas about the conditional operator can also be derived by a case analysis on the condition being true or false. See Table 5. Proofs are still only a few lines. SUMmand occurs as Lemma 4.3.2 in <ref> [GP93b] </ref>. EXP bool SUM is an instance of the final remark of the same lemma. * Expansions of the merge, which are a special kind of derived axioms. They are used to determine the first actions of a process defined as the parallel composition of several components.
Reference: [GP94] <author> J.F. Groote and A. Ponse. </author> <title> The syntax and semantics of CRL. </title> <editor> In A. Ponse, C. Ver-hoef, and S.F.M van Vlijmen, editors, </editor> <booktitle> Algebra of Communicating Processes (Proceedings ACP'94), </booktitle> <pages> pages 26-62, </pages> <year> 1994. </year>
Reference-contexts: The process algebra we use is based on the Algebra of Communicating Processes (ACP) of Bergstra and Klop [BK86a]. More precisely, we use CRL, ACP o augmented with data <ref> [GP94, GP93b] </ref>, which is small enough to make the verification feasible, and at the same time expressive enough for the specification of real-life protocols. <p> We give a brief and informal introduction here; for a complete description of its syntax and semantics we refer to <ref> [GP94] </ref>, for its proof theory to [GP93b]. 2.1.1 Syntax and Semantics An algebra is usually a set, together with a number of operations on that set, in principle axiom-atized by an equational theory. ACP o complies with this tradition. <p> A proof via the formal proof theory is given in the next section.) 1,!) d = if D (T; d; e) = if D (eq D (d; e); d; e) = e. 2,$) From 1, as the intended models are boolean preserving <ref> [GP94] </ref>, that is, T 6= F and for all booleans b: b = T _ b = F , thus in particular eq D (d; e) 6= T ! eq D (d; e) = F . 2 2.1.2 Proof Theory The proof theory of CRL is given in [GP93b] in a <p> It is clear that future research must concentrate on improving the linearization technique, in order to verify larger protocols. It must become much more efficient, and (almost) completely independent of the protocol. This seems ambitious at first, but for effective CRL-specifications <ref> [GP94] </ref>, all that is needed is an efficient encoding of term-rewriting in Coq. On the other hand, it must be investigated whether proof checkers based on term-rewriting are capable of also handling the other parts of the verification.
Reference: [GW94] <author> J.F. Groote and J.J. van Wamel. </author> <title> Algebraic data types and induction in CRL. </title> <type> Technical Report P9409, </type> <institution> University of Amsterdam, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: For the precise definitions of substitutions and induction rules we refer to [GP93b]. An induction rule for a sort is based on a set of constructors for that sort. Which functions form a constructor set of a sort is not part of the CRL-specification (but see <ref> [GW94] </ref>). Given a CRL-specification, one can prove that a certain set is a constructor set only on the metalevel, using structural induction on closed terms. <p> This turns out to be unnecessary cumbersome, but raises an interesting question. Suppose that we have sets as a sort in the specification of the protocol. Then the CRL-specification contains an algebraic specification of sets based on lists, such as the one given by Groote and Van Wamel <ref> [GW94] </ref> (a function D ! Bool can be declared in CRL, but not used as a sort). <p> CRL. This is a moving target, as changes to Coq are still made, and changes to CRL are proposed, e.g. in <ref> [GW94] </ref>.
Reference: [Hes94] <author> W.H. Hesselink. </author> <title> Wait-free linearization with an assertional proof. </title> <journal> Distributed Computing, </journal> <volume> 8 </volume> <pages> 65-80, </pages> <year> 1994. </year>
Reference-contexts: A particularly impressive achievement is the assertional verification of wait-free linearization in <ref> [Hes94] </ref> and its formal elaboration [Hes95]. A recent approach to the ABP can be found in [Gim95], where the behaviour af processes is modelled by streams encoded as co-inductive types of Coq.
Reference: [Hes95] <author> W.H. Hesselink. </author> <title> Wait-free linearization with a mechanical proof. </title> <journal> Distributed Computing, </journal> <note> 9:(to appear), </note> <year> 1995. </year>
Reference-contexts: A particularly impressive achievement is the assertional verification of wait-free linearization in [Hes94] and its formal elaboration <ref> [Hes95] </ref>. A recent approach to the ABP can be found in [Gim95], where the behaviour af processes is modelled by streams encoded as co-inductive types of Coq.
Reference: [Hoo91] <author> J. Hooman. </author> <title> Specification and Compositional Verification of Real-Time Systems, </title> <type> LNCS 558. PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1991. </year>
Reference-contexts: If possible, we prove formally that the deviation is correct. Formal verification is not limited to algebraic verification of protocols. In principle, it can be used for any formalism [Cou93], for example I/O-automata [LMWF94, HSV94] and temporal logic <ref> [MP82, OL82, Hoo91] </ref>.
Reference: [HSV94] <author> L. Helmink, M.P.A. Sellink, and F.W. Vaandrager. </author> <title> Proof-checking a data link protocol. </title> <booktitle> In Proceedings Workshop Esprit BRA Types for Proofs and Programs, </booktitle> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1993, </year> <note> LNCS 806. Springer-Verlag, </note> <year> 1994. </year>
Reference-contexts: When we deviate from the original definitions, we do so explicitly and with motivation. If possible, we prove formally that the deviation is correct. Formal verification is not limited to algebraic verification of protocols. In principle, it can be used for any formalism [Cou93], for example I/O-automata <ref> [LMWF94, HSV94] </ref> and temporal logic [MP82, OL82, Hoo91].
Reference: [Kam93] <author> G. Kamsteeg. </author> <title> A formal verification of the Alternating Bit Protocol in CRL. </title> <type> Technical Report 93-37, </type> <institution> Dept. of Comp. Sci., Leiden University, Netherlands, </institution> <year> 1993. </year>
Reference-contexts: As a case study, we verified the Alternating Bit Protocol (ABP) [BSW69]. We chose this protocol, not because there was any doubt about its correctness, but because it is small, well-known, and numerous correctness proofs are available in the literature <ref> [BW90, BK86b, BG93, Dro94, Kam93] </ref>. The process algebra we use is based on the Algebra of Communicating Processes (ACP) of Bergstra and Klop [BK86a]. <p> In contrast to a `classical' verification, a formal verification is a proof formulated completely in a formal language; each step in it consists of the application of a formal proof rule. Theoretically, a formal verification could be done completely by hand, but on the basis of our experience (e.g. <ref> [Kam93] </ref>) we claim that, for real-life protocols, it can only be done using a computer. Such a verification is, by the nature of computers, a formal verification. To stress these observations, and also because a great deal of human input is still needed, we avoid the phrase `automatic verification'.
Reference: [Klu91] <author> A.S. Klusener. </author> <title> Abstraction in real time process algebra. </title> <editor> In J.W. de Bakker, C. Huiz-ing, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings of the REX workshop "Real-Time: Theory in Practice", </booktitle> <publisher> LNCS 600. Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: a result which is outside the scope of process algebra. * Verification of other protocols, probably developing new proof techniques at the same time, see e.g. [BG94a, KS93, GP93a]. * Extending CRL with (discrete) real time [BB92] and translating the resulting formalism to Coq in order to verify timed protocols <ref> [KP93, Klu91] </ref>. * Investigate if other proof checkers, or perhaps even theorem provers, are more suitable than Coq for the verification of protocols. It appears that the proofs consist for a significant part of term rewriting, which is not easy to do in Coq.
Reference: [KP93] <author> M. Kaart and I. Polak. </author> <title> Het alternating bit protocol met time-out in discrete tijd. </title> <type> Technical Report P9323, </type> <institution> Programming Research Group, University of Amsterdam, </institution> <month> September </month> <year> 1993. </year> <note> (in Dutch). </note>
Reference-contexts: a result which is outside the scope of process algebra. * Verification of other protocols, probably developing new proof techniques at the same time, see e.g. [BG94a, KS93, GP93a]. * Extending CRL with (discrete) real time [BB92] and translating the resulting formalism to Coq in order to verify timed protocols <ref> [KP93, Klu91] </ref>. * Investigate if other proof checkers, or perhaps even theorem provers, are more suitable than Coq for the verification of protocols. It appears that the proofs consist for a significant part of term rewriting, which is not easy to do in Coq.
Reference: [KS93] <author> H. Korver and J. Springintveld. </author> <title> A computer-checked verification of Milner's Sched-uler. </title> <type> Technical Report 101, </type> <institution> Logic Group Preprint Series, Utrecht University, </institution> <month> Novem-ber </month> <year> 1993. </year>
Reference-contexts: In this stage of the development of the field it is very difficult to establish the relative merit of each of the results above, since their diversity makes comparison practically impossible. However, recent experience shows that the algebraic method discussed in this paper can handle larger protocols as well <ref> [BG94a, KS93, GP93a] </ref>. In the next section, we give an overview of CRL and the ABP. Then we formalize the ABP in CRL and sketch roughly the proof of its correctness. An introduction to Coq concludes this section. <p> Moreover, it requires the concistency of Coq, a result which is outside the scope of process algebra. * Verification of other protocols, probably developing new proof techniques at the same time, see e.g. <ref> [BG94a, KS93, GP93a] </ref>. * Extending CRL with (discrete) real time [BB92] and translating the resulting formalism to Coq in order to verify timed protocols [KP93, Klu91]. * Investigate if other proof checkers, or perhaps even theorem provers, are more suitable than Coq for the verification of protocols.
Reference: [LMWF94] <author> N. Lynch, M. Merritt, W. Weihl, and A. Fekete. </author> <title> Atomic Transactions. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1994. </year>
Reference-contexts: When we deviate from the original definitions, we do so explicitly and with motivation. If possible, we prove formally that the deviation is correct. Formal verification is not limited to algebraic verification of protocols. In principle, it can be used for any formalism [Cou93], for example I/O-automata <ref> [LMWF94, HSV94] </ref> and temporal logic [MP82, OL82, Hoo91].
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: In principle, it can be used for any formalism [Cou93], for example I/O-automata [LMWF94, HSV94] and temporal logic [MP82, OL82, Hoo91]. Earlier attempts to automatic verification of propositions of process theory are from Cleaveland and Panangaden [CP88], who gave an implementation of Milner's Calculus of Communicating Systems <ref> [Mil80] </ref> in the NuPrl system [CAB + 86] and from Engberg, Gronning and Lamport, who developed the Temporal Logic of Actions (TLA), which is a logic for specifying and reasoning about concurrent systems [EGL92].
Reference: [MP82] <author> Z. Manna and A. Pnueli. </author> <title> Verification of concurrent programs, a temporal proof system. </title> <booktitle> In Foundations of Computer Science IV, Distributed Systems: Part 2 Mathematical Centre Tracts 159, </booktitle> <pages> pages 163-255, </pages> <year> 1982. </year> <month> 51 </month>
Reference-contexts: If possible, we prove formally that the deviation is correct. Formal verification is not limited to algebraic verification of protocols. In principle, it can be used for any formalism [Cou93], for example I/O-automata [LMWF94, HSV94] and temporal logic <ref> [MP82, OL82, Hoo91] </ref>.
Reference: [OL82] <author> S. Owicki and L. Lamport. </author> <title> Proving liveness properties of concurrent programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 455-495, </pages> <year> 1982. </year>
Reference-contexts: If possible, we prove formally that the deviation is correct. Formal verification is not limited to algebraic verification of protocols. In principle, it can be used for any formalism [Cou93], for example I/O-automata [LMWF94, HSV94] and temporal logic <ref> [MP82, OL82, Hoo91] </ref>.
Reference: [PM93] <author> C. Paulin-Mohring. </author> <title> Inductive definitions in the system Coq. In Typed Lambda Calculi and Applications, </title> <publisher> LNCS 664, </publisher> <pages> pages 328-345, </pages> <year> 1993. </year>
Reference-contexts: The obvious problem with this approach is of course its soundness (and completeness). However, the soundness of the encoding approach is also not immediate, as it is not even proved yet that Coq is consistent <ref> [CP90, PM93] </ref>, i.e., False might be derivable. In fact, the problem lies in the inductive sets and definitions, on which the encoding relies much more than our embedding approach.
Reference: [PS93] <author> J. van de Pol and M.P.A. </author> <title> Sellink. </title> <type> Personal communication, </type> <year> 1993. </year>
Reference-contexts: Another disadvantage is that an expansion makes many copies of the constituing components x 1 : : : x n . A different proof technique avoiding both disadvantages is being developed by Van de Pol <ref> [PS93] </ref>. * Axioms restated as rules. The axioms as they are support simplification `inside out': for proving y x = ffi, we first rewrite y to ffi and then apply A7: ffi x = ffi.
Reference: [Sel93] <author> M.P.A. </author> <title> Sellink. Verifying process algebra proofs in type theory. In D.J. Andrews, </title> <editor> J.F. Groote, and C.A. Middelburg, editors, </editor> <booktitle> Proceedings of the International Workshop on Semantics of Specification Languages, </booktitle> <address> Utrecht, The Netherlands, </address> <pages> pages 315-339. </pages> <publisher> Workshops in Computer Science, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Thus we define the function goodset, which, given a set of actions, returns the same set without delta and tau. Definition ehset = act-&gt;Prop. Definition goodset : ehset-&gt;ehset = [L:ehset] [a:act] (~(&lt;act&gt;a=delta))/"(~(<act>a=tau))/"(L a). 8 Sellink <ref> [Sel93] </ref> suggests to represent the sets for hiding and encapsulation as lists. This turns out to be unnecessary cumbersome, but raises an interesting question. Suppose that we have sets as a sort in the specification of the protocol.
Reference: [Wer94] <author> B. Werner. </author> <title> Une theorie des Constructions Inductives. </title> <type> PhD thesis, </type> <institution> Universite de Paris 7, </institution> <month> May </month> <year> 1994. </year> <month> 52 </month>
Reference-contexts: From a practical point of view, the approach makes proofs much harder to read because the 5 We have been informed recently that the required result was obtained in <ref> [Wer94] </ref> for a subset of Coq that includes the techniques used in this paper. 16 names of the axioms are lost. There are some obvious mismatches between Coq and CRL to take care of.
References-found: 39

