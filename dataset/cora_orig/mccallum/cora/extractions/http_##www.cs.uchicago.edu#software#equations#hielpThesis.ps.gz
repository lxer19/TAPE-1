URL: http://www.cs.uchicago.edu/software/equations/hielpThesis.ps.gz
Refering-URL: http://www.cs.uchicago.edu/html/groups/systems/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: HIELP, A FAST INTERACTIVE LAZY FUNCTIONAL LANGUAGE SYSTEM  
Author: STEPHEN WILSON BAILEY 
Degree: A DISSERTATION SUBMITTED TO THE FACULTY OF THE DIVISION OF PHYSICAL SCIENCES IN CANDIDACY FOR THE DEGREE OF DOCTOR OF PHILOSOPHY DEPARTMENT OF COMPUTER SCIENCE BY  
Date: JUNE 1995  
Affiliation: CHICAGO, ILLINOIS  
Note: THE UNIVERSITY OF CHICAGO  
Abstract-found: 0
Intro-found: 1
Reference: [AJ89] <author> A. Appel and T. Jim. </author> <title> "Continuation-Passing, Closure-Passing Style." </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 293-302. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year> <note> Cited p. 86. </note>
Reference-contexts: It may be implemented in the heap. This technique gained renown in Standard ML of New Jersey <ref> [AJ89] </ref>. Andrew Appel argued, on a theoretical level, that for an arbitrarily large heap, the efficiency of managing storage in a heap is greater than that of managing 5.6. Handling The Stack 87 a stack [App87].
Reference: [App92] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year> <note> Cited p. 141. </note>
Reference-contexts: Not coincidentally, it was the cost of this extra movement of data to and from the stack which prompted Appel to adopt a stackless model in SML-NJ <ref> [App92] </ref>. He observed that closures are created frequently enough even in the strict SML language that it may be more efficient to start with all the arguments in the heap.
Reference: [App87] <author> Andrew W. Appel. </author> <title> "Garbage collection can be faster than stack allocation." </title> <journal> Information Processing Letters, </journal> <volume> 25(4) </volume> <pages> 275-279, </pages> <note> January 87. Cited p. 87. </note>
Reference-contexts: This technique gained renown in Standard ML of New Jersey [AJ89]. Andrew Appel argued, on a theoretical level, that for an arbitrarily large heap, the efficiency of managing storage in a heap is greater than that of managing 5.6. Handling The Stack 87 a stack <ref> [App87] </ref>. Wilson and others point out that this analysis does not allow for the poor cache behavior of a large semispace collected heap, and the excellent cache behavior of a stack [WLM92].
Reference: [Ass93] <author> Claus Assmann. </author> <title> "A RISC Processor Architecture with a Versatile Stack System." </title> <journal> Computer Architecture News, </journal> <volume> 21(5) </volume> <pages> 63-70, </pages> <year> 1993. </year> <note> Cited p. 113. </note>
Reference: [Aug87] <author> L. Augustsson. </author> <title> Compiling Lazy Functional Languages, Part II. </title> <type> Ph.D. thesis, </type> <institution> Chalmers University of Technology, Goteborg, SE, </institution> <year> 1987. </year> <pages> Cited pp. 87, 135. </pages>
Reference: [Aug93] <author> L. Augustsson. </author> <title> "The Interactive Lazy ML System." </title> <journal> Journal of Functional Programming, </journal> <volume> 3(1) </volume> <pages> 77-92, </pages> <year> 1993. </year> <note> Cited p. 124. </note>
Reference-contexts: The hbc system has been tested with and without the use of the -O optimization flag, to empirically assess the scope and impact of whatever optimizations it performs|tests with optimization will appear under the heading hbcopt. There is also an interactive version of Hbc <ref> [Aug93] </ref>, but it 6.6. Other System Comparison Measurements 125 is essentially an interpreter with the ability to also load code which has been compiled by the batch system, so it was not tested. Clean V0.84 A batch compiler for a lazy language similar to, but not as baroque as Haskell.
Reference: [Bak94] <author> Henry G. Baker. </author> <title> "Minimizing Reference Count Updating with Deferred and Anchored Pointers for Functional Data Structures." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(9) </volume> <pages> 38-43, </pages> <month> September </month> <year> 1994. </year> <note> Cited p. 59. </note>
Reference: [BHY88] <author> A. Bloss, P. R. Hudak, and J. H. Young. </author> <title> "Code Optimizations for Lazy Evaluation." </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1 </volume> <pages> 147-164, </pages> <year> 1988. </year> <note> Cited p. 65. </note>
Reference-contexts: Each additional recursive evaluation would waste time discovering that no equations apply to the supplied subject term. This technique is used in Elp [SS90], the predecessor to Hielp and by Bloss, Hudak and Young <ref> [BHY88] </ref>. Hielp was implemented with and without stable flags to explore the overhead and benefits. For a system which permits more general definitions than those using a functor/constructor discipline, the mere test that no patterns match a subterm can require an arbitrary amount of computation.
Reference: [BW88] <author> Richard Bird and Philip Wadler. </author> <title> Introduction to Functional Programming. </title> <booktitle> Series in Computer Science. Prentice-Hall International, </booktitle> <address> Engle-wood Cliffs, NJ, </address> <year> 1988. </year> <note> Cited p. 1. </note>
Reference-contexts: INTRODUCTION This dissertation describes a lazy functional language system, Haskellesque Interactive Equational Logic Programming, Hielp. The reader is assumed to be familiar with the basics of lazy functional programming. For an introduction, see any of the books by Bird and Wadler <ref> [BW88] </ref>, Field and Harrison [FH88], or for a modern, implementation oriented view, Peyton Jones and Lester [PL92].
Reference: [CH92] <author> G. Cane and J. Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall Inc., </publisher> <address> Englewood Cliffs, NJ 07632, </address> <year> 1992. </year> <editor> Cited p. </editor> <volume> 23. 179 180 References </volume>
Reference-contexts: In other words, the code generation process employs a very basic macro expansion technique. The code generated for the two instructions is illustrated below in the pseudo assembly language of a generic load-store register architecture, which can be easily adapted to most currently popular architectures ([Leo87], [Spa92], <ref> [CH92] </ref>, [Sit92], etc.). 2.4.1 branch Code Assume that the symbol : has a tag value of 2, and the symbol [] has a tag value of 4. The branch instruction: branch R1 R3 2 [(:, B1:...) ([], B2:...)] produces the machine code shown in Figure 2.6.
Reference: [Che80] <author> Leslie Paul Chew. </author> <title> "An Improved Algorithm for Computing with Equations." </title> <booktitle> In 21st Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1980. </year> <note> Cited p. 51. </note>
Reference: [DB78] <author> L. Peter Deutsch and Daniel G. Bobrow. </author> <title> "An Efficient Incremental, Automatic Garbage Collector." </title> <journal> Communications of the ACM, </journal> <volume> 19(9) </volume> <pages> 522-526, </pages> <month> September </month> <year> 1978. </year> <note> Cited p. 59. </note>
Reference: [DS91] <author> Irene Durand and Robert Strandh. </author> <title> "A Simple Characterization of the Class of Forward-Branching Equational Programs." </title> <type> Technical Report 04-91, GRECO Programmation, </type> <year> 1991. </year> <note> Cited p. 17. </note>
Reference-contexts: However, it is valid for equation languages which adhere to the functor/constructor discipline, and some others. Strandh et al. call this class of equation languages forward branching and the technique of evaluating children before they are inspected is called stabilize before inspection <ref> [DS91] </ref>. Haskell separates constructors, which are legal final values from the evaluation of an expression, syntactically from functors, or function symbols, which are not, so the stabilize before inspect strategy works for Haskell.
Reference: [FH88] <author> Anthony J. Field and Peter G. Harrison. </author> <title> Functional Programming. </title> <booktitle> International Computer Science Series. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Wokingham, Eng-land, </address> <year> 1988. </year> <note> Cited p. 1. </note>
Reference-contexts: INTRODUCTION This dissertation describes a lazy functional language system, Haskellesque Interactive Equational Logic Programming, Hielp. The reader is assumed to be familiar with the basics of lazy functional programming. For an introduction, see any of the books by Bird and Wadler [BW88], Field and Harrison <ref> [FH88] </ref>, or for a modern, implementation oriented view, Peyton Jones and Lester [PL92]. For background on Equational Logic Programming, Elp, the ancestor of Hielp, see [O'D85]. 1.1 Motivation Making programming language systems better for serious, substantial projects has been the subject of the overwhelming majority of practical programming language research.
Reference: [FW87] <author> John Fairbairn and Stuart Wray. "Tim: </author> <title> A Simple, Lazy Abstract Machine to Execute Supercombinators." </title> <editor> In Gilles Kahn (editor), </editor> <booktitle> Functional Programming Languages and Computer Architecture, volume 274 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 34-45, </pages> <address> Portland, Oregon, USA, September 14-16, 1987. </address> <publisher> Springer, </publisher> <address> Berlin. Cited p. </address> <month> 135. </month>
Reference-contexts: The Spineless, Tagless G-machine (STGM) [PJ92], Gofer [Jon94], the Three Instruction Machine (TIM) <ref> [FW87] </ref>, the G-machine [Joh87][Aug87], and Clean's ABC machine [SNvGP91], are all stack machines. This means that the abstract machine instructions operate directly on values stored a stack or, in the case of STGM, ABC and the G-Machine, several stacks.
Reference: [Har94] <author> P. H. Hartel. </author> <title> "Benchmarking implementations of lazy functional languages II Two years later." </title> <type> Technical report Cs-94-21, </type> <institution> Dept. of Comp. Sys, Univ. of Amsterdam, </institution> <month> Dec </month> <year> 1994. </year> <pages> Cited pp. 92, 125. </pages>
Reference: [HJ94] <author> Paul Hudak and Mark P. Jones. </author> <title> "Haskell vs. Ada vs. C++ vs. Awk vs. ... An Experiment in Software Prototyping Productivity." </title> <institution> Research Report YALEU/DCS/RR-1049, Department of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> Oct </month> <year> 1994. </year> <pages> Cited pp. 3, 133. </pages>
Reference-contexts: Hudak and Jones offer some anecdotal evidence for this in their paper which compares Haskell to other languages as a prototyping system <ref> [HJ94] </ref>. A programming system based upon Haskell built as illustrated in Figure 1.1 offers considerable advantages for the hack and slash programmer: * The read-eval-print loop of the compiler subsystem permits rapid testing and debugging of program components. It also also provides an adequate input/output interface for many simple tasks. <p> An embedded Haskell might permit easy development of portions of a system whose speed is not critical, and excellent method for prototyp-ing subsystems until their design is finalized. Hudak and Jones present compelling evidence for Haskell's suitability as a software system prototyping language <ref> [HJ94] </ref>. 134 Measurements CHAPTER 7 COMPARISON WITH OTHER SYSTEMS There are a prodigious variety of compilation techniques and abstract machines for lazy functional programming languages. Many of these systems have been developed in isolation, giving rise to an equally diverse collection of goals, terminology and approach.
Reference: [HL93] <author> Pieter Hartel and Koen Langendoen. </author> <title> "Benchmarking implementations of lazy functional languages." </title> <booktitle> In Proceedings of Sixth International Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 341-349, </pages> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year> <pages> Cited pp. 92, 125. </pages>
Reference: [HPW92] <editor> Paul Hudak, Simon Peyton Jones, and Phil Wadler (editors). </editor> <title> "Report on the Programming Language Haskell, A Non-Strict, Purely Functional Language, Version 1.2." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year> <note> Cited p. 6. </note>
Reference-contexts: Finally, the HAM is compared to other current lazy functional abstract machines in a way which highlights the strengths and weaknesses of each. 1.3 The Source Language The source language accepted by Hielp is essentially a small, untyped subset of Haskell V1.2 <ref> [HPW92] </ref>. In particular, Hielp's language is missing the following major Haskell features: * Arrays. * Nested scoping. * Guard and comprehension syntaxes. * Type checking. * Modules. 1.3.
Reference: [Hud95] <author> Paul Hudak. </author> <title> "Dear Haskellians|Happy New Year!" The Haskell Mailing List (haskell-request@cs.yale.edu), </title> <month> January </month> <year> 1995. </year> <note> Cited p. 5. References 181 </note>
Reference-contexts: Current compilers are simply not designed nor are they suitable for this purpose. Hudak also recognized a need for a fast, interactive compiler in his "Happy New Year" 1995 address to the Haskell community <ref> [Hud95] </ref>: Although our implementations have improved tremendously over the past few years, there is still LOTS of room for improvement. The best implementations in terms of performance, such as GHC, still have problems common to all of them: compile-time is slow, they are memory hogs, and debugging tools are minimal.
Reference: [Joh87] <author> Thomas Johnsson. </author> <title> Compiling Lazy Functional Languages, Part I. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Chalmers University of Technology, Goteborg, Sweden, </institution> <year> 1987. </year> <pages> Cited pp. 87, 135. </pages>
Reference: [Jon94] <author> Mark P. Jones. </author> <title> "The Implementation of the Gofer Functional Programming System." </title> <institution> Research Report YALEU/DCS/RR-1020, Department of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> May </month> <year> 1994. </year> <note> Cited p. 135. </note>
Reference-contexts: The Spineless, Tagless G-machine (STGM) [PJ92], Gofer <ref> [Jon94] </ref>, the Three Instruction Machine (TIM) [FW87], the G-machine [Joh87][Aug87], and Clean's ABC machine [SNvGP91], are all stack machines. This means that the abstract machine instructions operate directly on values stored a stack or, in the case of STGM, ABC and the G-Machine, several stacks.
Reference: [Lav91] <author> Alain Laville. </author> <title> "Comparison of Priority Rules in Pattern Matching and Term Rewriting." </title> <journal> Journal of Symbolic Computation, </journal> <volume> 11(4), </volume> <month> April </month> <year> 1991. </year> <note> Cited p. 7. </note>
Reference-contexts: Although this model has some slight semantic incompatibilities with Haskell's text order model, a compatible extension to these models using as little text order priority information as necessary can be implemented which generates code as efficient as that generated for the Elp model <ref> [Lav91] </ref>. Hielp distinguishes two different types of input to the system: Program function definitions and other declarations. Initial subject term the expression or expressions to be evaluated with respect to the program defined so far. In logic programming terminology, the initial subject term would be called the query.
Reference: [Leo87] <editor> Timothy E. Leonard (editor). </editor> <title> VAX Architecture Reference Manual. </title> <note> DEC Books, 1987. Cited p. 23. </note>
Reference: [O'D85] <author> Michael J. O'Donnell. </author> <title> Equational Logic as a Programming Language. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year> <journal> Cited pp. </journal> <volume> 1, 7, 18, </volume> <pages> 22. </pages>
Reference-contexts: For an introduction, see any of the books by Bird and Wadler [BW88], Field and Harrison [FH88], or for a modern, implementation oriented view, Peyton Jones and Lester [PL92]. For background on Equational Logic Programming, Elp, the ancestor of Hielp, see <ref> [O'D85] </ref>. 1.1 Motivation Making programming language systems better for serious, substantial projects has been the subject of the overwhelming majority of practical programming language research. The earliest work on programming languages|the first assemblers and primitive compilers|was to permit larger programs to be written manageably. <p> In addition, Hielp adopts Elp's pattern matching model, where there is no implied sequencing or priority among alternative function definitions. O'Donnell describes the details of this pattern matching model in his monograph <ref> [O'D85] </ref>. Although this model has some slight semantic incompatibilities with Haskell's text order model, a compatible extension to these models using as little text order priority information as necessary can be implemented which generates code as efficient as that generated for the Elp model [Lav91]. <p> For example, builtin functions are provided for integer and floating point arithmetic operations. 18 The Abstract Machine 2.3 Compilation Given the restrictions on the patterns in input language described in O'Donnell's monograph <ref> [O'D85] </ref>, compiling an equation becomes the task of merging a depth-first traversal of the equation's pattern with the existing HAM program, with a build for the equation's result as the target instruction of the final branch's arc. 2.3.1 Register Assignment The task of assigning HAM registers to nodes as pattern matching <p> One possible solution, adopted by O'Donnell in the earliest implementations of Elp, is to use an Aho-Corasick style failure function to communicate the pattern matching state to the calling invocation of the HAM program upon failure <ref> [O'D85] </ref>. The main problem with this technique for Hielp is that it requires substantial additional compile time and compiler complexity. Functor/constructor systems do not have this problem with user patterns, so implementing it in general just to handle the AP function would be overkill.
Reference: [Ous90] <author> J. K. Ousterhout. </author> <title> "Tcl: An Embeddable Command Language." </title> <booktitle> In Proceedings of the USENIX Winter 1990 Technical Conference, </booktitle> <pages> pp. 133-146, </pages> <address> Washington, DC USA, </address> <year> 1990. </year> <institution> USENIX Association , Berkeley, </institution> <address> CA , USA. Cited p. </address> <month> 133. </month>
Reference-contexts: Once Hielp is extended to this level, it will probably be about the same size. 6.6. Other System Comparison Measurements 133 The small size of the entire Hielp system suggests that it might function usefully as an embedded language in a larger system. A widely accepted embedded language, TCL <ref> [Ous90] </ref>, is 176K in size, which is quite comparable to the size of the Hielp. Embedded languages should provide a substantially different programming abstraction from the system in which they are embedded, something which Hielp can offer to an Algol-like host language.
Reference: [PJ92] <author> Simon L. Peyton Jones. </author> <title> "Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine." JFP, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> July 92. </month> <journal> Cited pp. </journal> <volume> 56, 87, 135, </volume> <pages> 144. </pages>
Reference-contexts: Peyton Jones has also suggested this improvement and observed that some additional sharing of global nodes can be discovered dynamically by the garbage collector <ref> [PJ92] </ref>. In Hielp it is unclear if the added overhead of discovering such occurrences in the garbage collector would be worth the savings, since all zeroary constructors, not including values of builtin types, begin life in the program text, and, thus, are already handled by the static sharing technique. <p> The Spineless, Tagless G-machine (STGM) <ref> [PJ92] </ref>, Gofer [Jon94], the Three Instruction Machine (TIM) [FW87], the G-machine [Joh87][Aug87], and Clean's ABC machine [SNvGP91], are all stack machines. This means that the abstract machine instructions operate directly on values stored a stack or, in the case of STGM, ABC and the G-Machine, several stacks. <p> These advantages are very similar to those that Peyton Jones describes for his tiny interpreter, which is a small piece of code which he uses to implemented the STGM in C <ref> [PJ92, p. 45] </ref>. 7.2.1 Compiling To C As a footnote to the relative inefficency of the HAM function dispatching mechanism, the STGM's implementation in C given by Peyton Jones actually requires an extra C function call for each function dispatch, which brings its dispatching performance in line with the HAM.
Reference: [PL92] <author> Simon L. Peyton Jones and David R. Lester. </author> <title> Implementing Functional Languages: A Tutorial. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year> <note> Electronic preprint, available via anonymous ftp from nebula.cs.yale.edu. Cited p. 1. </note>
Reference-contexts: The reader is assumed to be familiar with the basics of lazy functional programming. For an introduction, see any of the books by Bird and Wadler [BW88], Field and Harrison [FH88], or for a modern, implementation oriented view, Peyton Jones and Lester <ref> [PL92] </ref>. For background on Equational Logic Programming, Elp, the ancestor of Hielp, see [O'D85]. 1.1 Motivation Making programming language systems better for serious, substantial projects has been the subject of the overwhelming majority of practical programming language research.
Reference: [PS82] <author> D. A. Patterson and C. H. Sequin. </author> <title> "A VLSI RISC." </title> <journal> IEEE Computer, </journal> <volume> 15(9):8, </volume> <month> September </month> <year> 1982. </year> <pages> Cited pp. 73, 79. </pages>
Reference-contexts: A large register file would only be an advantage for programs whose results have many variables which are used more than once. 5.4 Register Windows Register windows are a central, somewhat controversial feature of the SPARC and some other RISC architectures, including one of the original RISC architectures <ref> [PS82] </ref>. A register window permits machine code to use different subsets of the register file in a uniform way. For example, the SPARC's register window contains twenty-four register names. Each register name refers to only one of a number of possible hardware registers at any particular time. <p> a program which runs poorly with register windows and well without is about a factor of three and the reverse worst case slowdown is a factor of slightly less than two. * Patterson claimed, in the original Berkeley RISC paper, that window traps occurred with a frequency of about 1% <ref> [PS82] </ref> , which is much smaller than the anticipated frequency for HAM programs. * Only one of the four main benchmark programs, sieve, actually slowed down with the non-windowed code. * Nonwindowed code makes other optimizations developed on the SPARC imple mentation equally applicable to other implementations.
Reference: [PvE93] <author> R. Plasmeijer and M. van Eekelen. </author> <title> Functional Programming and Parallel Graph Rewriting. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1993. </year> <journal> Cited pp. </journal> <volume> 12, 21, 141, </volume> <pages> 150. </pages>
Reference-contexts: This is the same definition used by the Plasmeijer and van Eekelen <ref> [PvE93] </ref>. Other functional programming literature may call these applications higher order programming, or call the use of f x a higher order application and the use of map in mapAlias a curried application. <p> There are a wide variety of implementation techniques to handle these situations but they all involve a special apply node which is used to group unresolved function applications. Hielp uses a solution to curried application handling which is similar in form to that used by Clean <ref> [PvE93, pp. 259, 354, 385] </ref>. Specifically, Hielp uses a binary apply node, AP, with a builtin operation to handle function dispatches on AP nodes. <p> Figure 7.5 shows the machine code generated by the Clean system for innermost fragment of the definition: length n (hd : tl) = length (n+1) tl For consistency, this code has been translated from MC68000 code, the form in which it was given by Plasmeijer and Van Eekelen <ref> [PvE93, p. 397] </ref> to SPARC assembler, but it is a nearly literal translation, with no attempt to reorder the code to fill delay slots. The ABC machine has three stacks. <p> It appears that the designers of the ABC machine paid too great a cost to eliminate indirections. Their view is <ref> [PvE93, p. 349] </ref>: For a machine without variable-sized [fixed part/variable part] nodes the place-holder node is usually overwritten by an indirection node: a special node that fits in any node which points to the actual node.
Reference: [Rak93] <author> Verma M. Rakesh. "Smaran: </author> <title> a Congruence-closure Based System for Equational Computations." </title> <editor> In Claude Kirchner (editor), </editor> <booktitle> Proceedings of the 3rd International Conference on Rewriting Techniques and Applications, volume 690 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 457-461. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> Cited p. 51. 182 References </note>
Reference-contexts: Chew, Sherman, and Rakesh have explored run time techniques to discover sharing independent of the textual structure of the program [Che80][She90] <ref> [Rak93] </ref>. Unfortunately the overhead of the run time machin 52 Build Instruction Improvements 4.3.
Reference: [Reb91] <author> Samuel A. Rebelsky. </author> <title> "An Introduction To Tours, A Protocol for Demand-Driven Communication of Terms." </title> <type> Technical Report CS91-28, </type> <institution> University of Chicago Department of Computer Science, </institution> <month> November </month> <year> 1991. </year> <note> Cited p. 4. </note>
Reference-contexts: In addition, the Tour Interface referred to in Figure 1.1 is a mechanism for communicating terms and computational demand lazily invented by Rebelsky which permits an even more flexible coroutine relationship between the input/output and algorithmic components of the program than Cobol or Smalltalk <ref> [Reb91] </ref>.
Reference: [Reb93] <author> Samuel A. Rebelsky. </author> <title> Lazy Term-based Communication: Issues, Observations, and Applications. </title> <type> PhD thesis, </type> <institution> University Of Chicago, </institution> <month> June </month> <year> 1993. </year> <note> Cited p. 57. </note>
Reference-contexts: There are some notable exceptions. Functions which are the result of lambda lifting can have large arity, and Rebelsky's I/O functors have an argument for each possible element of the character set|typically 128, or 256 <ref> [Reb93] </ref>. The use of doubleword stores in code which overwrites redex root nodes would be another motivation for doubleword aligning all redex roots, as described in Section 4.1.
Reference: [RS93] <author> Gordon Russell and Paul Shaw. </author> <title> "A Stack-Based Register Set." </title> <type> Technical Report ARCH-9-93+, </type> <institution> University of Strathclyde, </institution> <year> 1993. </year> <note> Cited p. 113. </note>
Reference: [She90] <author> David J. Sherman. </author> <title> "Lazy Directed Congruence Closure." </title> <type> Technical Report 90-028, </type> <institution> University of Chicago Department of Computer Science, </institution> <year> 1990. </year> <note> Cited p. 51. </note>
Reference: [She94] <author> David J. Sherman. </author> <title> Run-time and Compile-time Improvements to Equational Programs. </title> <type> PhD thesis, </type> <institution> University Of Chicago, </institution> <month> June </month> <year> 1994. </year> <note> Cited p. 51. </note>
Reference-contexts: Unfortunately, this is an inevitable consequence of the HAM's simple computation model, where every computational step results in writing a result to memory. Partial evaluation in the manner described by Sherman promises a reduction in memory writes at the cost of additional control flow <ref> [She94] </ref>, which may aleviate a memory write bottleneck somewhat.
Reference: [Sit92] <author> R. L. </author> <title> Sites (editor). Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <year> 1992. </year> <pages> Cited pp. 23, 50. </pages>
Reference-contexts: In other words, the code generation process employs a very basic macro expansion technique. The code generated for the two instructions is illustrated below in the pseudo assembly language of a generic load-store register architecture, which can be easily adapted to most currently popular architectures ([Leo87], [Spa92], [CH92], <ref> [Sit92] </ref>, etc.). 2.4.1 branch Code Assume that the symbol : has a tag value of 2, and the symbol [] has a tag value of 4. The branch instruction: branch R1 R3 2 [(:, B1:...) ([], B2:...)] produces the machine code shown in Figure 2.6. <p> Avoiding consecutive stores Rearrange code to reduce the incidence of consecutive store operations. On machines in which the memory system has shallow store buffers, this can increase throughput. The DEC Alpha architecture guide has some very similar suggestions <ref> [Sit92] </ref>. Satisfying these constraints within each build instruction is relatively easy because a the code for each build contains a large number of both store and non-store instructions, most of which are independent.
Reference: [Sit93] <author> Richard L. </author> <title> Sites. "Alpha AXP Architecture." </title> <journal> Communications of the ACM, </journal> <volume> 36(2) </volume> <pages> 33-44, </pages> <month> February </month> <year> 1993. </year> <note> Cited p. 32. </note>
Reference-contexts: Most of the first generation of RISC architectures incorporated branch delay slots, but some newer ones, such as the Alpha, do not, because they seem to hinder superscalar execution <ref> [Sit93] </ref>. While some architectures do not include branch delay slots, there are other, similar relationships among instructions which must still be satisfied for best performance.
Reference: [SNvGP91] <author> Sjaak Smesters, Erick Nocker, Jon van Gronigen, and Rinus Plasmeijer. </author> <title> "Generating Efficient Code for Lazy Functional Languages." </title> <booktitle> In Proceedings of Third International Workshop on Implementation of Functional Languages on Parallel Architectures, </booktitle> <pages> pp. 592-617, </pages> <year> 1991. </year> <pages> Cited pp. 87, 135. </pages>
Reference-contexts: The Spineless, Tagless G-machine (STGM) [PJ92], Gofer [Jon94], the Three Instruction Machine (TIM) [FW87], the G-machine [Joh87][Aug87], and Clean's ABC machine <ref> [SNvGP91] </ref>, are all stack machines. This means that the abstract machine instructions operate directly on values stored a stack or, in the case of STGM, ABC and the G-Machine, several stacks. On the other hand, the HAM uses a stack in its implementation.
Reference: [Spa92] <author> Sparc International, Inc. </author> <title> The SPARC Reference Manual. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ 07632, </address> <year> 1992. </year> <pages> Cited pp. 23, 49. </pages>
Reference-contexts: In other words, the code generation process employs a very basic macro expansion technique. The code generated for the two instructions is illustrated below in the pseudo assembly language of a generic load-store register architecture, which can be easily adapted to most currently popular architectures ([Leo87], <ref> [Spa92] </ref>, [CH92], [Sit92], etc.). 2.4.1 branch Code Assume that the symbol : has a tag value of 2, and the symbol [] has a tag value of 4. The branch instruction: branch R1 R3 2 [(:, B1:...) ([], B2:...)] produces the machine code shown in Figure 2.6. <p> Organizing the storage of a build result this way would require additional compile time, but pairing odd sized constructors with odd sized functors could be done with a simple linear algorithm, which would not appreciably slow compilation. 4.2 Satisfying Instruction Ordering Constraints The SPARC Architecture Manual <ref> [Spa92] </ref> makes the following recommendations for scheduling instructions in a way which will execute the fastest on most implementations: 50 Build Instruction Improvements Making consecutive instructions independent It is preferable for each instruction to be independent of the instruction that executes immediately before it.
Reference: [SS90] <author> Linda Sellie and David J. Sherman. </author> <title> "Preliminary Notes on Version 4.1 of the Equational Compiler." </title> <type> Technical Report 90-013, </type> <institution> University of Chicago Department of Computer Science, </institution> <year> 1990. </year> <note> Cited p. 65. </note>
Reference-contexts: Each additional recursive evaluation would waste time discovering that no equations apply to the supplied subject term. This technique is used in Elp <ref> [SS90] </ref>, the predecessor to Hielp and by Bloss, Hudak and Young [BHY88]. Hielp was implemented with and without stable flags to explore the overhead and benefits.
Reference: [Sys87] <institution> Systems Performance Evaluation Cooperative, c/o Waterside Associates, Freemont, California. </institution> <note> The SPEC Benchmark Report, January 1987. Cited pp. 77, 91. References 183 </note>
Reference-contexts: The main performance emphasis in the design of commercial workstation architecture is on fairly traditional Fortran and C programs, with rela 5.4. Register Windows 77 tively large functions, a substantial amount of live data, and little recursion <ref> [Sys87] </ref>. Even for this type of application, there is conflicting evidence about the effectiveness of register windows [Wal88]. Functional language programs, on the other hand, are usually written with recursion replacing loops and small functions with little live data. <p> They may still represent a skewed distribution of operations, which can mislead an implementor or user. For example, the SPEC benchmark suite has become the most common way for users to compare workstation performance <ref> [Sys87] </ref>. As such, system designers are using it almost exclusively in their design studies. While SPEC fairly represents many common work-loads, there are others which are not well represented, and are largely neglected by system and compiler design.
Reference: [vGNS91] <author> John van Groningen, Eric Nocker, and Sjaak Smetsers. </author> <title> "Efficient Heap Management in the Concrete ABC Machine." </title> <booktitle> In Proceedings of Third International Workshop on Implementation of Functional Languages on Parallel Architectures. </booktitle> <institution> University of Southampton, </institution> <type> Technical Report Series CSTR91-07, </type> <year> 1991. </year> <pages> Cited pp. 61, 150. </pages>
Reference-contexts: The developers of the Clean system make a similar observation about the tradeoffs between implementing a simple garbage collector in assembly language and a complicated one in a higher order language <ref> [vGNS91] </ref>. 4.5.3 Exploiting Referential Transparency in the Evaluation Heap Collector The garbage collector in Hielp takes advantage of the referential transparency property of the source language by discarding all outstanding recursive invocations of the HAM program, and restarting from scratch after each garbage collection. <p> Furthermore, this spacial locality will be restored after every garbage collection of a semispace copying collector. The Clean implementation actually implements both a semispace collector, when the heap is relatively empty, and a non-copying mark/sweep collector, when the heap gets full <ref> [vGNS91] </ref>, so spacial locality will only be restored when the copying collector is in use. It appears that the designers of the ABC machine paid too great a cost to eliminate indirections.
Reference: [Wal88] <author> David W. Wall. </author> <title> "Register Windows vs. Register Allocation." </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 67-78, </pages> <address> Atlanta, Georgia, USA, </address> <month> June </month> <year> 1988. </year> <note> Cited p. 77. </note>
Reference-contexts: Register Windows 77 tively large functions, a substantial amount of live data, and little recursion [Sys87]. Even for this type of application, there is conflicting evidence about the effectiveness of register windows <ref> [Wal88] </ref>. Functional language programs, on the other hand, are usually written with recursion replacing loops and small functions with little live data. For this reason, it is generally held that register windows would slow down a fast functional language implementation, so the register window features are not used.
Reference: [Wil92] <author> Paul R. Wilson. </author> <title> "Uniprocessor Garbage Collection Techniques." </title> <booktitle> In International Workshop on Memory Management, </booktitle> <pages> pp. 1-42, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag Lecture Notes in Computer Science no. 637. Cited p. 60. </note>
Reference-contexts: This copying overhead could also be largely avoided by employing a generation scavenging technique, but at the cost of a more complex collector, with greater collection overhead, and, in most cases, some additional runtime overhead to keep track of intergenerational pointers <ref> [Wil92] </ref>. A generation scavenger would quickly retire the relatively static machine code to an older generation where it would no longer be copied and, thus not degrade the performance of the evaluation.
Reference: [WLM92] <author> P. R. Wilson, M. S. Lam, and T. G. Moher. </author> <title> "Caching Considerations for Generational Garbage Collection." </title> <journal> ACM LISP Pointers, </journal> <volume> 5(1) </volume> <pages> 32-42, </pages> <year> 1992. </year> <booktitle> Proceedings of the 1992 ACM Conference on LISP and Functional Programming. </booktitle> <pages> Cited pp. 87, 143. 184 References </pages>
Reference-contexts: Handling The Stack 87 a stack [App87]. Wilson and others point out that this analysis does not allow for the poor cache behavior of a large semispace collected heap, and the excellent cache behavior of a stack <ref> [WLM92] </ref>. To use a semispace heap for a stack: push requires an increment of the free space pointer, and a store of a back pointer to the previous stack frame. This is slower by the cost of the memory store. pop requires a fetch from the back pointer. <p> Code Representation 143 on caches for performance improvement. It is hard to beat the cache behavior of a stack <ref> [WLM92] </ref> 7.2 Code Representation Superficially, the form of the HAM's compiled code seems substantially different from that of its stack-based competitors. One major difference is the overall structure of the program graph: * The HAM's code is a single tree of branch instructions with build instruction leaves.
References-found: 46

