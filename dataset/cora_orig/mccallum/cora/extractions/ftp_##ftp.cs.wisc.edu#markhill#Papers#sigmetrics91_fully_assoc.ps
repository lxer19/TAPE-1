URL: ftp://ftp.cs.wisc.edu/markhill/Papers/sigmetrics91_fully_assoc.ps
Refering-URL: http://www.cs.wisc.edu/~markhill/
Root-URL: 
Title: Implementing Stack Simulation for Highly-Associative Memories  
Author: Yul H. Kim, Mark D. Hill, David A. Wood 
Keyword: KEY WORDS: trace-driven simulation, stack simulation, caches, memory systems, file systems.  
Address: 1210 West Dayton St.  Wisconsin, Madison, WI 53706  
Affiliation: Computer Sciences Dept.,  Univ. of  
Abstract: Prior to this work, all implementations of stack simulation [MGS70] required more than linear time to process an address trace. In particular these implementations are often slow for highly-associative memories and traces with poor locality, as can be found in simulations of file systems. We describe a new implementation of stack simulation where the referenced block and its stack distance are found using a hash table rather than by traversing the stack. The key to this implementation is that designers are rarely interested in a continuum of memory sizes, but instead desire metrics for only a discrete set of alternatives (e.g., powers of two). Our experimental evaluation shows the run-time of the new implementation to be linear in address trace length and independent of trace locality. Kim, et al., [KHW91] present the results of this research in more detail. 
Abstract-found: 1
Intro-found: 1
Reference: [BeK75] <author> B. T. Bennett and V. J. Kruskal, </author> <title> LRU Stack Processing, </title> <journal> IBM Journal of R & D, </journal> <month> July </month> <year> 1975, </year> <pages> 353-357. </pages>
Reference-contexts: D), where N is the trace length and D is the mean stack distance. This implementation is commonly-used for CPU cache simulations, where the limited associativity restricts D and traces exhibit good locality [Tho87]. Others have developed tree-based implementations <ref> [BeK75, Olk81] </ref> with asymptotic running times O (N log D) and used hashing to determine when a block is not in the stack [BeK75, Tho87]. The performance of these implementations, however, is still sensitive to trace locality [Tho87]. <p> This implementation is commonly-used for CPU cache simulations, where the limited associativity restricts D and traces exhibit good locality [Tho87]. Others have developed tree-based implementations [BeK75, Olk81] with asymptotic running times O (N log D) and used hashing to determine when a block is not in the stack <ref> [BeK75, Tho87] </ref>. The performance of these implementations, however, is still sensitive to trace locality [Tho87]. In the next section we develop an implementation that uses hashing to achieve asymptotic running times that are independent of trace locality. We then present key results from our experimental evaluation. 2.
Reference: [BKW90] <author> A. Borg, R. E. Kessler and D. W. Wall, </author> <title> Generation and Analysis of Very Long Address Traces, </title> <booktitle> Proceedings Seventeenth International Symposium on Computer Architecture, </booktitle> <address> Seattle, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Discussion We have implemented hashing-based and linked-list stack simulation in C and have evaluated them with some CPU address traces <ref> [BKW90] </ref>. We synthesized various mean stack distances using stack deletion [Smi77]. Results show that the performance of hashing-based stack simulation is (1) insensitive to mean stack distance, and (2) faster than linked-list stack simulation for mean stack distances greater than five.
Reference: [KHW91] <author> Y. H. Kim, M. D. Hill and D. A. Wood, </author> <title> Implementing Stack Simulation for Highly-Associative Memories, </title> <type> Computer Sciences Technical Report #997, </type> <institution> Univ. of Wisconsin, </institution> <month> February </month> <year> 1991. </year>
Reference: [MGS70] <author> R. L. Mattson, J. Gecsei, D. R. Slutz and I. L. Traiger, </author> <title> Evaluation techniques for storage hierarchies, </title> <journal> IBM Systems Journal 9, </journal> <volume> 2 (1970), 78 - 117. </volume>
Reference-contexts: A key approach to reducing these resource demands is to evaluate multiple alternative memories with a single pass through an address trace. Mattson, et al., <ref> [MGS70] </ref> describe a single-pass technique called stack simulation that can efficiently simulate multiple alternative memories with the same block size (line, page), the same number of sets, and using the least-recently-used (LRU) replacement policy. Since stack simulation handles each set independently, we will hereafter assume fully-associative memories (a single set).
Reference: [Olk81] <author> F. Olken, </author> <title> Efficient Methods for Calculating the Success Function of Fixed Space Replacement Policies, </title> <type> Masters Report, </type> <institution> Lawrence Berkeley Laboratory LBL-12370, University of California, Berkeley, </institution> <month> May </month> <year> 1981. </year>
Reference-contexts: D), where N is the trace length and D is the mean stack distance. This implementation is commonly-used for CPU cache simulations, where the limited associativity restricts D and traces exhibit good locality [Tho87]. Others have developed tree-based implementations <ref> [BeK75, Olk81] </ref> with asymptotic running times O (N log D) and used hashing to determine when a block is not in the stack [BeK75, Tho87]. The performance of these implementations, however, is still sensitive to trace locality [Tho87].
Reference: [RoD90] <author> J. T. Robinson and M. V. Devarakonda, </author> <title> Data Cache Management Using Frequency-Based Replacement, </title> <booktitle> Proceedings SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Boulder, Colorado, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: The stack is implemented with a doubly-linked list, hash table, and discard pointers (which point to the first block not in a memory) . Figure 1a shows the stack before processing a reference to block 94, while Figure 1b shows it afterward. hhhhhhhhhhhhhhhhhh Robinson and Devarakonda <ref> [RoD90] </ref> use similar data structures to implement frequency-based replacement in a disk cache. Using the simulation steps defined in Section 1, a reference to block 94 is processed as follows. INPUT ``94'' is read from the trace.
Reference: [Smi77] <author> A. J. Smith, </author> <title> Two Methods for the Efficient Analysis of Memory Address Trace Data, </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> SE-3, </volume> <month> 1 (January </month> <year> 1977), </year> <pages> 94-101. </pages>
Reference-contexts: Discussion We have implemented hashing-based and linked-list stack simulation in C and have evaluated them with some CPU address traces [BKW90]. We synthesized various mean stack distances using stack deletion <ref> [Smi77] </ref>. Results show that the performance of hashing-based stack simulation is (1) insensitive to mean stack distance, and (2) faster than linked-list stack simulation for mean stack distances greater than five. Thus our implementation should be superior for disk and file-system traces, which have mean stack distances in the hundreds [Tho87].
Reference: [Tho87] <author> J. G. Thompson, </author> <title> Efficient Analysis of Caching Systems, </title> <institution> Computer Science Division Technical Report UCB/Computer Science Dept. 87/374, University of California, Berkeley, </institution> <month> October </month> <year> 1987. </year> - -- 
Reference-contexts: D), where N is the trace length and D is the mean stack distance. This implementation is commonly-used for CPU cache simulations, where the limited associativity restricts D and traces exhibit good locality <ref> [Tho87] </ref>. Others have developed tree-based implementations [BeK75, Olk81] with asymptotic running times O (N log D) and used hashing to determine when a block is not in the stack [BeK75, Tho87]. The performance of these implementations, however, is still sensitive to trace locality [Tho87]. <p> This implementation is commonly-used for CPU cache simulations, where the limited associativity restricts D and traces exhibit good locality [Tho87]. Others have developed tree-based implementations [BeK75, Olk81] with asymptotic running times O (N log D) and used hashing to determine when a block is not in the stack <ref> [BeK75, Tho87] </ref>. The performance of these implementations, however, is still sensitive to trace locality [Tho87]. In the next section we develop an implementation that uses hashing to achieve asymptotic running times that are independent of trace locality. We then present key results from our experimental evaluation. 2. <p> restricts D and traces exhibit good locality <ref> [Tho87] </ref>. Others have developed tree-based implementations [BeK75, Olk81] with asymptotic running times O (N log D) and used hashing to determine when a block is not in the stack [BeK75, Tho87]. The performance of these implementations, however, is still sensitive to trace locality [Tho87]. In the next section we develop an implementation that uses hashing to achieve asymptotic running times that are independent of trace locality. We then present key results from our experimental evaluation. 2. <p> Results show that the performance of hashing-based stack simulation is (1) insensitive to mean stack distance, and (2) faster than linked-list stack simulation for mean stack distances greater than five. Thus our implementation should be superior for disk and file-system traces, which have mean stack distances in the hundreds <ref> [Tho87] </ref>.
References-found: 8

