URL: http://cs.uni-bonn.de/~marek/publications/seq_and_par_subquadr.ps.Z
Refering-URL: http://cs.uni-bonn.de/~marek/index-en.html
Root-URL: http://cs.uni-bonn.de
Title: Sequential and Parallel Subquadratic Work Algorithms for Constructing Approximately Optimal Binary Search Trees  
Author: Marek Karpinski Lawrence L. Larmore Wojciech Rytter 
Abstract: A sublinear time subquadratic work parallel algorithm for construction of an optimal binary search tree, in a special case of practical interest, namely where the frequencies of items to be stored are not too small, is given. A sublinear time subquadratic work parallel algorithm for construction of an approximately optimal binary search tree in the general case is also given. Sub-quadratic work and sublinear time are achieved using a fast parallel algorithm for the column minima problem for Monge matrices developed by Atallah and Kosaraju. The algorithms given in this paper take O(n 0:6 ) time with n processors in the CREW PRAM model. Our algorithms work well if every subtree of the optimal binary search tree of depth (log n) has o(n) leaves. We prove that there is a sequential algorithm with subquadratic average-case complexity, by demonstrating that the "small subtree" condition holds with very high probability for a randomly permuted weight sequence. This solves the conjecture posed in [11] and breaks the quadratic time "barrier" of Knuth's algorithm [10]. This algorithm can also be parallelized to run in average sublinear time with n processors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aggarwal, M. Klawe, S. Moran, P. Shor, and R. Wilber, </author> <title> Geometric applications of a matrix-searching algorithm, </title> <booktitle> Algorithmica 2 (1987), </booktitle> <pages> pp. 195-208. </pages>
Reference-contexts: The following result is by Aggarwal, Klawe, Morey, Shor, and Wilber <ref> [1] </ref>. The algorithm developed in that paper is whimsically known as the "SMAWK" algorithm, using a permutation of the authors' initials. Lemma 1.3. If M is an n fi m Monge matrix, all column minima of M can be found in O (n + m) sequential time.
Reference: [2] <author> B. Allen, </author> <title> Optimal and near-optimal binary search trees, </title> <journal> Acta Inform. </journal> <volume> 18 (1982), </volume> <pages> pp. 255-263. </pages>
Reference-contexts: 1 Introduction The problem of developing a subquadratic time sequential algorithm computing opt imal binary search trees (the OBST problem) appears to be very hard. Algorithm for finding approximately optimal binary search trees have been found by Allen, Mehlhorn and Unter-auer <ref> [2, 13, 14] </ref>. The results of this paper are largely based on the algorithm for approximately optimal binary search trees given by Larmore [11]. We show that there is a sequential algorithm with subquadratic average-case complexity, where weights are randomly permuted.
Reference: [3] <author> M. J. Atallah, S. R. Kosaraju, </author> <title> Parallel computation of row minima for monotone matrices, </title> <booktitle> Journal of Algorithms 13 (1992), </booktitle> <pages> pp. 394-413. </pages>
Reference-contexts: Lemma 1.3. If M is an n fi m Monge matrix, all column minima of M can be found in O (n + m) sequential time. In the parallel case, we have the following result by Atallah and Kosaraju <ref> [3] </ref>. Lemma 1.4. <p> of the tree T d are listed in in-order v 1 ; : : : ; v m . for k = 1 to m do for each i = 1 : : : n do in parallel compute partial cost (v k ; i) using the parallel algorithm of <ref> [3] </ref> for the corresponding column minima problem.
Reference: [4] <author> M. J. Atallah, S. R. Kosaraju, L. L. Larmore, G. L. Miller, and S-H. Teng, </author> <title> Constructing trees in parallel, </title> <booktitle> Proc. 1 st ACM Symposium on Parallel Algorithms and Architectures (1989), </booktitle> <pages> pp. 499-533. </pages>
Reference-contexts: Partially supported by National Science Foundation grants CCR-9112067 and CCR-9503441. Email:larmore@cs.unlv.edu z Institute of Informatics, Warsaw University, 02-097 Warszawa. Partially supported by DFG Grant Bo 56/142-1. Email:rytter@mimuw.edu.pl which solves that problem efficiently, and the problem of finding such a parallel algorithm appears to be very hard <ref> [4] </ref>. There is an N C algorithm for the special case of alphabetic trees using n 2 processors [12]. The best known N C algorithms require O (n 6 ) work for optimal binary search trees and O (n 2 ) work for approximately optimal binary search trees [4, 15]. <p> There is an N C algorithm for the special case of alphabetic trees using n 2 processors [12]. The best known N C algorithms require O (n 6 ) work for optimal binary search trees and O (n 2 ) work for approximately optimal binary search trees <ref> [4, 15] </ref>. Sublinear time parallel algorithms sometimes have much lower total work than N C algorithms. In [8] a sublinear time algorithm for the OBST problem whose work is very close to quadratic is given.
Reference: [5] <author> P. J. Bayer, </author> <title> Improved bounds on the costs of optimal and balanced binary search trees, Project MAC Technical Memorandum 69, </title> <publisher> MIT (1975). </publisher>
Reference-contexts: This generalizes the notion of min-max tree introduced by Bayer <ref> [5] </ref>, which is essentially a 1 2 -tree. Lemma 5.1. Let x = x 1 ; : : : x n be a sequence of positive real numbers, where n = jxj, and let ~x be a random permutation of x.
Reference: [6] <author> R. Guttler, K. Mehlhorn, and W. Schneider, </author> <title> Binary search trees: average and worst case behavior, </title> <booktitle> Elektr. Informationsverarb Kybernetik 16 (1980), </booktitle> <pages> pp. 579-591. </pages>
Reference-contexts: Let F 1 = 1, F 2 = 1, F 3 = 2, etc., be the Fibonacci numbers. By Theorem 2 of [7], similar to results of <ref> [6] </ref>, a subtree whose root is at level h can have weight at most 2=F h+2 .
Reference: [7] <author> D. S. Hirschberg, L. L. Larmore, and M. Molodowitch, </author> <title> Subtree weight ratios for optimal binary search trees, </title> <type> TR 86-02, </type> <institution> ICS Department, University of California, </institution> <address> Irvine (1986). </address>
Reference-contexts: Let F 1 = 1, F 2 = 1, F 3 = 2, etc., be the Fibonacci numbers. By Theorem 2 of <ref> [7] </ref>, similar to results of [6], a subtree whose root is at level h can have weight at most 2=F h+2 . <p> The result follows. By Theorem 2 of <ref> [7] </ref>, we have: Lemma 5.4. Assume we have an optimal binary search tree whose list of items is z, and y is the list of items of a subtree rooted at a node of depth 2.
Reference: [8] <author> M. Karpinski and W. Rytter, </author> <title> On a sublinear time parallel construction of optimal binary search trees, </title> <booktitle> Pro ceedings of the 19 th International Symposium on Mathematical Foundations of Computer Science, </booktitle> <publisher> LNCS 841 (ed. </publisher> <editor> I. Privara, B. Rovan, P. </editor> <month> Ruzicka) </month> <year> (1994), </year> <pages> pp. 453-461. </pages>
Reference-contexts: The best known N C algorithms require O (n 6 ) work for optimal binary search trees and O (n 2 ) work for approximately optimal binary search trees [4, 15]. Sublinear time parallel algorithms sometimes have much lower total work than N C algorithms. In <ref> [8] </ref> a sublinear time algorithm for the OBST problem whose work is very close to quadratic is given. The fastest known sequential algorithm for the OBST problem is the classical algorithm by Knuth [10], which takes quadratic time. <p> Knuth's algorithm can be easily parallelized by computing all entries on a given diagonal of the array in parallel. The following lemma was essentially shown in <ref> [8] </ref>. It says that costs of all optimal subtrees of width at most ` can be efficiently computed in parallel. Lemma 1.1. All values cost (i; j) for jj ij ` can be computed in O (` log (`)) time with O (n= log (`)) processors.
Reference: [9] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <publisher> Addison-Wesley (1973). </publisher>
Reference-contexts: Furthermore, there exists an O (n 0:6 )- time parallel algorithm using n processors which computes an *-approximately optimal binary search tree for any sequence, where * = o (1). We use terminology from <ref> [9] </ref>, pages 434-435. Let K 1 ; : : : K n be a sequence of n weighted items (keys), which are to be placed in a binary search tree. <p> By Theorem 2 of [7], similar to results of [6], a subtree whose root is at level h can have weight at most 2=F h+2 . F n &gt; 2OE n4 (see <ref> [9] </ref> exercise 4, pg. 18), which proves the claim and the lemma. 4 The proof of our main results related to parallel constructions In this section we prove our main results related to sublinear time parallel computations, as two separate theorems.
Reference: [10] <author> D. E. Knuth, </author> <title> Optimum binary search trees, </title> <journal> Acta Informatica 1 (1971), </journal> <pages> pp. 14-25. </pages>
Reference-contexts: Sublinear time parallel algorithms sometimes have much lower total work than N C algorithms. In [8] a sublinear time algorithm for the OBST problem whose work is very close to quadratic is given. The fastest known sequential algorithm for the OBST problem is the classical algorithm by Knuth <ref> [10] </ref>, which takes quadratic time. The main theorem of [10] uses, without stating it in those terms, the Monge property of the matrix of subtree costs. <p> In [8] a sublinear time algorithm for the OBST problem whose work is very close to quadratic is given. The fastest known sequential algorithm for the OBST problem is the classical algorithm by Knuth <ref> [10] </ref>, which takes quadratic time. The main theorem of [10] uses, without stating it in those terms, the Monge property of the matrix of subtree costs. <p> Let cost (i; i) = weight (i; i) = q i . The values of cost (i; j) are tabulated in an array. The time to compute all values of cost is O (n 2 ), using Knuth's Theorem <ref> [10] </ref>, essentially making use of the Monge property of cost , considered as a matrix. Knuth's algorithm can be easily parallelized by computing all entries on a given diagonal of the array in parallel. The following lemma was essentially shown in [8].
Reference: [11] <author> L. L. Larmore, </author> <title> A subquadratic algorithm for constructing approximately optimal binary search trees, </title> <booktitle> Journal of Algorithms 8 (1987), </booktitle> <pages> pp. 579-591. </pages>
Reference-contexts: Algorithm for finding approximately optimal binary search trees have been found by Allen, Mehlhorn and Unter-auer [2, 13, 14]. The results of this paper are largely based on the algorithm for approximately optimal binary search trees given by Larmore <ref> [11] </ref>. We show that there is a sequential algorithm with subquadratic average-case complexity, where weights are randomly permuted. The OBST problem is especially interesting in a parallel setting, since there is no known N C algorithm fl Dept. of Computer Science, University of Bonn, 53117 Bonn. <p> Proof. (1) By Lemma 2.1 of <ref> [11] </ref>, the matrix fcost (i 1; j)g has the Monge property. It is simple to verify that fweight (i 1; j)g is also Monge. The other two terms are trivially Monge since they depend on only one component. <p> For the sake of simplicity, we assume that every search is successful, i.e., q i = 0. We shall address the general question where the q i can be positive in the full paper. In this section, we prove the following, addressing a conjecture of <ref> [11] </ref>. Theorem 5.1. Let probabilities p 1 ; p 2 ; p 3 ; : : : ; p n be given, where the fp i g are randomly permuted.
Reference: [12] <author> L. L. Larmore, T. M. Przytycka, and W. Rytter, </author> <title> Parallel construction of optimal alphabetic trees, </title> <booktitle> Proceed ings of the 5 th ACM Symposium on Parallel Algorithms and Architectures (1993), </booktitle> <pages> pp. 214-223. </pages>
Reference-contexts: Partially supported by DFG Grant Bo 56/142-1. Email:rytter@mimuw.edu.pl which solves that problem efficiently, and the problem of finding such a parallel algorithm appears to be very hard [4]. There is an N C algorithm for the special case of alphabetic trees using n 2 processors <ref> [12] </ref>. The best known N C algorithms require O (n 6 ) work for optimal binary search trees and O (n 2 ) work for approximately optimal binary search trees [4, 15]. Sublinear time parallel algorithms sometimes have much lower total work than N C algorithms.
Reference: [13] <author> K. Mehlhorn, </author> <title> Nearly optimal binary search trees, </title> <journal> Acta Informatica 5 (1975), </journal> <pages> pp. 287-295. </pages>
Reference-contexts: 1 Introduction The problem of developing a subquadratic time sequential algorithm computing opt imal binary search trees (the OBST problem) appears to be very hard. Algorithm for finding approximately optimal binary search trees have been found by Allen, Mehlhorn and Unter-auer <ref> [2, 13, 14] </ref>. The results of this paper are largely based on the algorithm for approximately optimal binary search trees given by Larmore [11]. We show that there is a sequential algorithm with subquadratic average-case complexity, where weights are randomly permuted.
Reference: [14] <author> K. Unterauer, </author> <title> Dynamic weighted binary search trees, </title> <journal> Acta Informatica 11 (1979), </journal> <pages> pp. 341-362. </pages>
Reference-contexts: 1 Introduction The problem of developing a subquadratic time sequential algorithm computing opt imal binary search trees (the OBST problem) appears to be very hard. Algorithm for finding approximately optimal binary search trees have been found by Allen, Mehlhorn and Unter-auer <ref> [2, 13, 14] </ref>. The results of this paper are largely based on the algorithm for approximately optimal binary search trees given by Larmore [11]. We show that there is a sequential algorithm with subquadratic average-case complexity, where weights are randomly permuted.
Reference: [15] <author> W. Rytter, </author> <title> Efficient parallel computations for some dynamic programming problems, </title> <journal> Theoretical Comp. Sci. </journal> <volume> 59 (1988), </volume> <pages> pp. 297-307. </pages>
Reference-contexts: There is an N C algorithm for the special case of alphabetic trees using n 2 processors [12]. The best known N C algorithms require O (n 6 ) work for optimal binary search trees and O (n 2 ) work for approximately optimal binary search trees <ref> [4, 15] </ref>. Sublinear time parallel algorithms sometimes have much lower total work than N C algorithms. In [8] a sublinear time algorithm for the OBST problem whose work is very close to quadratic is given.
Reference: [16] <author> F. F. Yao, </author> <title> Efficient dynamic programming using quad rangle inequalities, </title> <booktitle> Proceedings of the 12 th ACM Symposium on Theory of Computing (1980), </booktitle> <pages> pp. 429-435. </pages>
Reference-contexts: This is essentially the same as the quadrangle inequality introduced by Yao <ref> [16] </ref> which allowed speedup of certain dynamic programming algorithms. We consider the problem in a parallel setting, using the CREW PRAM model of computation.
References-found: 16

