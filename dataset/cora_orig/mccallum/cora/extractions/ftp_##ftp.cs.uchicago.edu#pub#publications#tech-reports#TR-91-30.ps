URL: ftp://ftp.cs.uchicago.edu/pub/publications/tech-reports/TR-91-30.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Title: Gap-Definable Counting Classes  
Author: Stephen A. Fenner Lance J. Fortnow Stuart A. Kurtz 
Note: Work done while the first author was a graduate student at the University of Chicago Computer Science Depart ment, supported in part by a University of Chicago Fellowship. Supported by NSF Grant CCR-9009936  
Date: July 12, 1992  
Address: 96 Falmouth Street Portland, Maine 04103  1100 East Fifty-eighth Street Chicago, Illinois 60637  
Affiliation: Computer Science Department University of Southern Maine  Computer Science Department University of Chicago  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. W. Allender. </author> <title> The complexity of sparse sets in P. In Structure in Complexity Theory, </title> <booktitle> volume 223 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-11. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: This class was defined by Papadimitriou & Zachos [20] and by Goldschlager & Parberry [10] (see [4] for details). The following two classes will also be of interest to us: Definition 2.4 * (Allender <ref> [1] </ref>) For any language L, L 2 FewP if and only if there exist a CM M and a polynomial p such that for all x 2 fl , #M (x) p (jxj) and x 2 L () #M (x) &gt; 0: * (Cai & Hemachandra [7]) For any language L,
Reference: [2] <author> L. Babai and L. Fortnow. Arithmetization: </author> <title> A new method in structural complexity theory. </title> <journal> Computational Complexity, </journal> <volume> 1(1) </volume> <pages> 41-67, </pages> <year> 1991. </year> <booktitle> A previous version appeared in Proceedings of the 31st annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 26-34, </pages> <year> 1990. </year>
Reference-contexts: 2 fl , f (x) = 2 fi n o fi fi fi n o fi fi : Proof: Immediate by lemma 4.3. 2 There is yet another characterization of GapP as the class of functions computed by uniform families of retarded arithmetic programs as described by Babai and Fortnow <ref> [2, section 3] </ref>. 14 Subtraction has been quite useful in simplifying many existing proofs about counting classes.
Reference: [3] <author> R. Beigel. </author> <title> Perceptrons, PP and the polynomial hierarchy. </title> <booktitle> In Proceedings of the 7th Structure in Complexity Theory Conference, </booktitle> <pages> pages 14-19, </pages> <year> 1992. </year>
Reference-contexts: further evidence that SPP is not as hard as PH, we now show that there is an oracle relative to which NP 6 d BP SPP. (An observation in [28] implies that d BP SPP = BP SPP since SPP is closed under majority-tt-reductions.) In fact, the oracle constructed in <ref> [3] </ref> will do. Proposition 6.1 There exists an oracle A such that NP A 6 ( d BP SPP) A . <p> Proof: The following implications all relativize: NP d BP SPP =) P NP P d BPSPP =) P NP P BPP SPP 21 =) P NP PP SPP The last implication follows from corollary 5.7. Beigel <ref> [3] </ref> constructed an oracle relative to which P NP 6 PP. Relative to this same oracle then, NP 6 d BP SPP. 2 The most we can say at present is that the statement PH SPP is "almost" true.
Reference: [4] <author> R. Beigel and J. Gill. </author> <title> Counting classes: Thresholds, parity, mods, and fewness. </title> <type> Unpublished manuscript, </type> <month> October </month> <year> 1990. </year>
Reference-contexts: We now define some of the usual counting classes. These are not always the original definitions, but can easily be shown to be equivalent to them. See <ref> [4] </ref> for more details. <p> This class was defined by Papadimitriou & Zachos [20] and by Goldschlager & Parberry [10] (see <ref> [4] </ref> for details). <p> Proof: Immediate from theorem 5.4 and corollary 5.10. 2 Corollary 5.11 also follows from related work of Beigel, Gill, & Hertrampf [5]: Few P CP Q (ff) for any predicate Q such that Q (0) = 0 and Q (1) = 1. See <ref> [4] </ref> for a definition of P CP Q (ff) . The next corollary subsumes all the lowness results in [15]. Corollary 5.12 Few is low for any uniformly gap-definable class. In particular, Few is low for each of the classes PP, C = P, and P ([15]).
Reference: [5] <author> R. Beigel, J. Gill, and U. Hertrampf. </author> <title> Counting classes: Thresholds, parity, </title> <booktitle> mods, and fewness. In Proceedings of the Seventh Annual Symposium on Theoretical Aspects of Computer Science, volume 415 of Lecture Notes in Computer Science, </booktitle> <pages> pages 49-57. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: function f is the threshold of M . 6 * (Wagner [30]) C = P is the class of all languages L such that there exists M and an FP function f such that, for all x, x 2 L () #M (x) = f (x): * (Beigel, Gill, Hertrampf <ref> [5] </ref>) For k 2, define Mod k P to be the class of all languages L such that there exists M such that, for all x, x 2 L () #M (x) 6 0 mod k: The class Mod 2 P is also called P (`Parity P'). <p> In particular, * Few C = P ([15, 5, 4]). Proof: Immediate from theorem 5.4 and corollary 5.10. 2 Corollary 5.11 also follows from related work of Beigel, Gill, & Hertrampf <ref> [5] </ref>: Few P CP Q (ff) for any predicate Q such that Q (0) = 0 and Q (1) = 1. See [4] for a definition of P CP Q (ff) . The next corollary subsumes all the lowness results in [15].
Reference: [6] <author> R. Beigel, N. Reingold, and D. Spielman. </author> <title> PP is closed under intersection. </title> <booktitle> In Proceedings of the 23rd annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1991. </year>
Reference-contexts: This class, introduced in section 3, is exactly the closure of #P under subtraction. GapP also has all the other nice closure properties of #P, such as addition, multiplication, and binomial coefficients. Beigel, Reingold, & Spielman first used gaps to great advantage in <ref> [6] </ref> to show that PP is closed under intersection. Toda and Ogiwara have also formulated their results in [28] using GapP instead of #P (see section 3). We will argue that GapP is the right way to think about #P-like functions. <p> We define the natural gap analog of the function class #P: Definition 3.2 GapP df = fgap M j M is a CMg: This class was defined independently in [12] and named Z#P. From now on in this chapter, we follow the spirit of <ref> [6] </ref> and work almost exclusively with gaps. The advantages are that gap functions can take on positive and negative values, and we can subtract gaps without introducing the large offsets that we get when we are counting accepting paths only.
Reference: [7] <author> J. Cai and L. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Mathematical Systems Theory, </journal> <volume> 23(2) </volume> <pages> 95-106, </pages> <year> 1990. </year>
Reference-contexts: Definition 2.4 * (Allender [1]) For any language L, L 2 FewP if and only if there exist a CM M and a polynomial p such that for all x 2 fl , #M (x) p (jxj) and x 2 L () #M (x) &gt; 0: * (Cai & Hemachandra <ref> [7] </ref>) For any language L, L 2 Few if and only if there exist a CM M , a polynomial p, and a polynomial-time computable predicate A (x; y) such that for all x 2 fl , #M (x) p (jxj) and Clearly, FewP NP.
Reference: [8] <author> S. Fenner, L. Fortnow, and L. Li. </author> <title> Gap-definability as a closure property. </title> <type> Unpublished, </type> <year> 1992. </year>
Reference-contexts: Proof: Let L be any language. We have L 2 SPP PH A () L 2 GapP PH A for a.e. A () L 2 GapP A for a.e. A 23 by proposition 6.3. 2 Subsequent research <ref> [8] </ref> implies that Almost (SPP) is also nonuniformly gap-definable. For the next corollary, a natural way to relativize Almost (C) to an oracle A is to say that L 2 (Almost (C)) A if and only if Pr R [L 2 C RA ] = 1. <p> Let N be a CM such that gap N (x) = i=1 w i (gap M (f (x)))w n i : By arguments similar to those for theorem 8.3, we get f 1 [L] = L A D ;R D (N ). 2 Subsequent research <ref> [8] </ref> has shown that GapCl also preserves closure under union, intersection, join, and finite difference.
Reference: [9] <author> J. Gill. </author> <title> Computational complexity of probabilistic complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6 </volume> <pages> 675-695, </pages> <year> 1977. </year>
Reference-contexts: We now define some of the usual counting classes. These are not always the original definitions, but can easily be shown to be equivalent to them. See [4] for more details. Definition 2.3 * (Valiant [29]) #P df * (Gill <ref> [9] </ref>) PP is the class of all languages L such that there exists M and an FP function f such that, for all x, x 2 L () #M (x) &gt; f (x): The function f is the threshold of M . 6 * (Wagner [30]) C = P is the
Reference: [10] <author> L. M. Goldschlager and I. Parberry. </author> <title> On the construction of parallel computers form various bases of Boolean functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 43-58, </pages> <year> 1986. </year>
Reference-contexts: This class was defined by Papadimitriou & Zachos [20] and by Goldschlager & Parberry <ref> [10] </ref> (see [4] for details).
Reference: [11] <author> R. L. Graham, D. E. Knuth, and O. Patashnik. </author> <title> Concrete Mathematics. </title> <publisher> Addison-Wesley Publishing House, </publisher> <year> 1989. </year>
Reference-contexts: We define the binomial coefficient as follows: y df x (x 1)(x 2) (x y + 1) ; which makes sense for all real numbers x and all nonnegative integers y. (If y = 0 then x df by convention.) Lemma 3.7 is proved using Vandermonde's convolution <ref> [11, page 174] </ref>, which states that for integers a; b and k 0, k = i=0 a k i : An intuition behind this equality is that choosing a committee of k people from a group of a women and b men is the same as first choosing i women then <p> Lemma 3.7 For all integers r; j; k with k 0, k = i=0 i r + j + 1 Proof: Negate the first binomial coefficient on the right hand side (see <ref> [11, page 174] </ref>) to get (right hand side) = k X i r + j + 1 Now apply Vandermonde's convolution to get k X i r + j + 1 k : It is important to note that the identity of lemma 3.7 holds for all integers j and nonnegative
Reference: [12] <author> S. Gupta. </author> <title> The power of witness reduction. </title> <booktitle> In Proceedings of the 6th Annual IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 43-59, </pages> <year> 1991. </year>
Reference-contexts: In particular, in section 5 we study a class SPP, alluded to but not specifically named in [15]. This class has also been studied independently by Ogiwara & Hemachandra [19] under the name XP, and by Gupta <ref> [12] </ref> under the name ZUP. We show that SPP, the gap analog of UP, is the smallest of all reasonable gap-definable classes. <p> In section 7, we consider the possibility that GapP is closed under certain operations stronger than those discussed in section 3. We show that such closure is equivalent to certain unlikely complexity theoretic collapses. Similar, more extensive results were obtained independently for GapP and #P in <ref> [19, 12] </ref>. In section 8, we determine structural properties of the collection of all gap-definable classes. We define GapCl, a simple, albeit nonconstructive, closure operation on sets (the `gap-closure'). From this we show that any countable set of languages C has a unique minimum gap-definable class GapCl (C) containing it. <p> We define the natural gap analog of the function class #P: Definition 3.2 GapP df = fgap M j M is a CMg: This class was defined independently in <ref> [12] </ref> and named Z#P. From now on in this chapter, we follow the spirit of [6] and work almost exclusively with gaps. <p> class of all languages L such that there exists M such that, for all x, x 62 L =) gap M (x) = 0: An SPP-like machine was first described in [15], and as mentioned earlier, SPP is the same class as XP and ZUP, studied independently in [19] and <ref> [12] </ref> respectively. These papers study closure properties of #P and GapP. Recently, Kobler, Schoning, & Toran [17] showed that the Graph Automorphism problem (does a given graph have any nontrivial automorphisms) is in SPP. <p> Ogiwara & Hemachandra [19] have studied closure questions such as these in detail, primarily for the class #P. They and Gupta <ref> [12] </ref> also address closure properties of GapP. We obtained theorem 7.1 independently of their work. See [19] for a nice, unified treatment of these questions. <p> where f 1 ; f 2 2 #P, then [f (x) = 0] = [f 1 (x) = f 2 (x)]. 3 =) 9: Follows from the fact that FP GapP. 9 =) 1: Follows from the fact that ffi 2 FP. 2 Ogiwara & Hemachandra [19] and independently Gupta <ref> [12] </ref> show further that statements 6 and 7 are equivalent to the polynomial counting hierarchy collapsing to SPP (see either source for definitions). 25 8 Structure of the Gap-Definable Classes In this section we examine the collection G of all gap-definable classes, partially ordered by inclusion.
Reference: [13] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: We also assume that the reader has basic knowledge of computable functions and recursively enumerable (r.e.) sets. There are a number of good textbooks covering these subjects, including <ref> [13] </ref>. We use P and FP to denote the classes of all polynomial-time computable languages and functions respectively. We use NP to denote the class of all languages computable in nondeterministic polynomial time, and PH denotes the polynomial hierarchy (see [25]).
Reference: [14] <author> J. Kobler. Strukturelle Komplexitat von Anzahlproblemen. </author> <type> PhD thesis, </type> <institution> Universitat Stuttgart, </institution> <year> 1989. </year> <pages> Page 62. </pages>
Reference-contexts: This is not known for Few, but it is well-known that Few P NP [log] , and in fact, Few P FewP <ref> [14] </ref>. 3 Gaps Definition 3.1 If M is a CM, define the function gap M : fl ! Z as follows: gap M = #M #M : The function gap M represents the "gap" between the number of accepting and the number of rejecting paths of M .
Reference: [15] <author> J. Kobler, U. Schoning, S. Toda, and J. Toran. </author> <title> Turing machines with few accepting computations and low sets for PP. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 44(2) </volume> <pages> 272-286, </pages> <year> 1992. </year>
Reference-contexts: Some classes such as PP, C = P, and P have very simple characterizations in this manner. In particular, in section 5 we study a class SPP, alluded to but not specifically named in <ref> [15] </ref>. This class has also been studied independently by Ogiwara & Hemachandra [19] under the name XP, and by Gupta [12] under the name ZUP. We show that SPP, the gap analog of UP, is the smallest of all reasonable gap-definable classes. <p> We say L is low for C if C L = C. 5 A class of languages is low for C if every language in the class is low for C. This notion was borrowed from recursion theory and was applied to complexity classes in, for example, <ref> [15] </ref> (see [15] for further references). We now define the machines we will be considering. Definition 2.1 A counting machine (CM) is a nondeterministic Turing machine running in polynomial time with two halting states: accepting and rejecting, and every computation path must end in one of these states. <p> We say L is low for C if C L = C. 5 A class of languages is low for C if every language in the class is low for C. This notion was borrowed from recursion theory and was applied to complexity classes in, for example, <ref> [15] </ref> (see [15] for further references). We now define the machines we will be considering. Definition 2.1 A counting machine (CM) is a nondeterministic Turing machine running in polynomial time with two halting states: accepting and rejecting, and every computation path must end in one of these states. <p> We will be interested chiefly in the following class: Definition 5.1 SPP is the class of all languages L such that there exists M such that, for all x, x 62 L =) gap M (x) = 0: An SPP-like machine was first described in <ref> [15] </ref>, and as mentioned earlier, SPP is the same class as XP and ZUP, studied independently in [19] and [12] respectively. These papers study closure properties of #P and GapP. <p> Also, the class WPP, defined later in this section, is low for PP ([26]), and we don't believe that SPP = WPP. The same is true for BPP, defined in the remark following definition 4.6 (see later in this section). Kobler et al. <ref> [15] </ref> showed that BPP is low for PP, and it is unlikely that BPP SPP. We now generalize [15] to theorem 5.9 below regarding gaps. Theorem 5.9 SPP = Gap-Few: Proof: Clearly SPP Gap-Few. <p> The same is true for BPP, defined in the remark following definition 4.6 (see later in this section). Kobler et al. <ref> [15] </ref> showed that BPP is low for PP, and it is unlikely that BPP SPP. We now generalize [15] to theorem 5.9 below regarding gaps. Theorem 5.9 SPP = Gap-Few: Proof: Clearly SPP Gap-Few. Let L be in Gap-Few as witnessed by the CM M , the polynomial time predicate A (x; k), and the polynomial q. <p> See [4] for a definition of P CP Q (ff) . The next corollary subsumes all the lowness results in <ref> [15] </ref>. Corollary 5.12 Few is low for any uniformly gap-definable class. In particular, Few is low for each of the classes PP, C = P, and P ([15]).
Reference: [16] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> On counting and approximation. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 363-379, </pages> <year> 1989. </year>
Reference-contexts: The next theorem says that SPP consists of exactly those languages which are low for GapP. Theorem 5.5 SPP = fL j GapP L = GapPg: Remark: It is unlikely that #P SPP = #P, or even that #P UP = #P. It follows imme diately from arguments in <ref> [16] </ref> that the latter equality implies UP = coUP. Proof of Theorem 5.5: We first show that SPP contains all GapP-low languages. Suppose L is a language such that GapP L = GapP. Let M be an OCM that, on input x, queries the oracle on x.
Reference: [17] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> Graph Isomorphism is low for PP. </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Theoretical Aspects of Computer Science, volume 577 of Lecture Notes in Computer Science, </booktitle> <pages> pages 401-411. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: These papers study closure properties of #P and GapP. Recently, Kobler, Schoning, & Toran <ref> [17] </ref> showed that the Graph Automorphism problem (does a given graph have any nontrivial automorphisms) is in SPP. They also showed that the Graph Isomorphism problem is in the class LWPP, defined at the end of this section. Clearly SPP C = P " co-C = P. <p> Proof: SPP P SPP SPP SPP SPP by corollary 5.7. Thus SPP = P SPP . 2 It should be noted that there may be languages not in SPP which are low for some particular gap-definable classes. For example, Kobler, et al. <ref> [17] </ref> showed that Graph Isomorphism (GI) is low for PP and C = P (see below), and it is not known that GI 2 SPP. As another example, all P sets are low for P ([20]), and it is not likely that SPP = P. <p> We'll call this class LWPP. 20 It appears that SPP 6= LWPP as well. The proof of theorem 5.5 can be modified easily to show that LWPP is low for PP and C = P. Kobler, et al. <ref> [17] </ref> show that GI and other related problems are low for these classes by showing that GI 2 LWPP. Unfortunately, we cannot modify the proof of theorem 5.5 to show that LWPP is low for WPP or for LWPP. The reason lies in the way these classes are relativized.
Reference: [18] <author> M. Li and P. M. B. Vitanyi. </author> <title> Applications of Kolmogorov complexity in the theory of computation. </title> <editor> In A. L. Selman, editor, </editor> <title> Complexity Theory Retrospective, </title> <booktitle> chapter 6, </booktitle> <pages> pages 147-203. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: W has no infinite recursively enumerable subsets. It is well-known that such sets exist (see [21, 24]); for example, we can take W = fx 2 fl j K (x) jxj=2g; where K (x) is the Kolmogorov complexity of x with respect to some fixed universal DTM (see <ref> [18] </ref>). We let W = fw 1 ; w 2 ; w 3 ; : : :g, where w 1 &lt; w 2 &lt; w 3 &lt; : : : .
Reference: [19] <author> M. Ogiwara and L. A. Hemachandra. </author> <title> A complexity theory of feasible closure properties. </title> <booktitle> In Proceedings of the 6th Annual IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 16-29, </pages> <year> 1991. </year>
Reference-contexts: Some classes such as PP, C = P, and P have very simple characterizations in this manner. In particular, in section 5 we study a class SPP, alluded to but not specifically named in [15]. This class has also been studied independently by Ogiwara & Hemachandra <ref> [19] </ref> under the name XP, and by Gupta [12] under the name ZUP. We show that SPP, the gap analog of UP, is the smallest of all reasonable gap-definable classes. <p> In section 7, we consider the possibility that GapP is closed under certain operations stronger than those discussed in section 3. We show that such closure is equivalent to certain unlikely complexity theoretic collapses. Similar, more extensive results were obtained independently for GapP and #P in <ref> [19, 12] </ref>. In section 8, we determine structural properties of the collection of all gap-definable classes. We define GapCl, a simple, albeit nonconstructive, closure operation on sets (the `gap-closure'). From this we show that any countable set of languages C has a unique minimum gap-definable class GapCl (C) containing it. <p> is the class of all languages L such that there exists M such that, for all x, x 62 L =) gap M (x) = 0: An SPP-like machine was first described in [15], and as mentioned earlier, SPP is the same class as XP and ZUP, studied independently in <ref> [19] </ref> and [12] respectively. These papers study closure properties of #P and GapP. Recently, Kobler, Schoning, & Toran [17] showed that the Graph Automorphism problem (does a given graph have any nontrivial automorphisms) is in SPP. <p> Is GapP also closed under left composition with the "unbounded" delta function ffi (x) = 1 if x = 0, 0 otherwise, defined for all x 2 Z? The answer to all of these questions is no, unless certain unlikely complexity theoretic identities hold. Ogiwara & Hemachandra <ref> [19] </ref> have studied closure questions such as these in detail, primarily for the class #P. They and Gupta [12] also address closure properties of GapP. We obtained theorem 7.1 independently of their work. See [19] for a nice, unified treatment of these questions. <p> Ogiwara & Hemachandra <ref> [19] </ref> have studied closure questions such as these in detail, primarily for the class #P. They and Gupta [12] also address closure properties of GapP. We obtained theorem 7.1 independently of their work. See [19] for a nice, unified treatment of these questions. In theorem 7.1 below, if P (~x) is any predicate, we define the function [P (~x)] = 1 if P (~x) is true, 0 otherwise. 24 For example, [x = 0] = ffi (x) as defined above. <p> f 1 f 2 where f 1 ; f 2 2 #P, then [f (x) = 0] = [f 1 (x) = f 2 (x)]. 3 =) 9: Follows from the fact that FP GapP. 9 =) 1: Follows from the fact that ffi 2 FP. 2 Ogiwara & Hemachandra <ref> [19] </ref> and independently Gupta [12] show further that statements 6 and 7 are equivalent to the polynomial counting hierarchy collapsing to SPP (see either source for definitions). 25 8 Structure of the Gap-Definable Classes In this section we examine the collection G of all gap-definable classes, partially ordered by inclusion.
Reference: [20] <author> C. H. Papadimitriou and S. K. Zachos. </author> <title> Two Remarks on the Power of Counting, </title> <booktitle> pages 269-276. Lecture Notes in Computer Science 145. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: This class was defined by Papadimitriou & Zachos <ref> [20] </ref> and by Goldschlager & Parberry [10] (see [4] for details). <p> we show that if M is an OCM and L is a language in SPP, there is a CM N (without an oracle) such that gap N = gap M L : This part of the proof has the same flavor as the proof that P P = P in <ref> [20] </ref>. Let M 1 be an SPP machine recognizing L. We may assume without loss of generality that for any oracle A and input x of length n, M A (x) makes exactly k (1 n ) oracle queries on each path, where k 2 FP.
Reference: [21] <author> H. Rogers. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <address> 1967. </address> <publisher> Reprinted. MIT Press. </publisher> <year> 1987. </year>
Reference-contexts: W is infinite. 2. W has no infinite recursively enumerable subsets. It is well-known that such sets exist (see <ref> [21, 24] </ref>); for example, we can take W = fx 2 fl j K (x) jxj=2g; where K (x) is the Kolmogorov complexity of x with respect to some fixed universal DTM (see [18]).
Reference: [22] <author> U. Schoning. </author> <title> Probabilistic complexity classes and lowness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 39 </volume> <pages> 84-100, </pages> <year> 1988. </year> <booktitle> Also appeared in Proceedings of the 2nd Annual IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 2-8, </pages> <year> 1987. </year> <month> 33 </month>
Reference-contexts: Define GapIn [Q] df Thus GapIn [Q] identifies those gap-definable classes where the accepting and rejecting sets partition fl fi Z and the acceptance criterion is independent of the input. Next, we define the d BP operator from [28], which is a modification of the BP operator of Schoning <ref> [22] </ref>: Definition 4.6 ([28], Definition 2.1) Let K be any class of languages.
Reference: [23] <author> J. Simon. </author> <title> On Some Central Problems in Computational Complexity. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <note> Ithaca, </note> <author> N. Y., </author> <month> January </month> <year> 1975. </year> <note> Available as Cornell Department of Computer Science Technical Report TR75-224. </note>
Reference-contexts: P as witnessed by f 2 GapP, define g (x) = 1 [f (x)] 2 : Clearly, g 2 GapP, and for all x, x 2 L () g (x) &gt; 0: Thus L 2 PP. 2 The reader may wish to compare the proof above with the one in <ref> [23] </ref>. More significantly, Toda and Ogiwara [28] have simplified their results using GapP. We state their main results here, using slightly altered notation. We first define a subfamily of the gap-definable classes. Definition 4.5 Let Q Z be any set.
Reference: [24] <author> R. Soare. </author> <title> Recursively Enumerable Sets and Degrees. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: W is infinite. 2. W has no infinite recursively enumerable subsets. It is well-known that such sets exist (see <ref> [21, 24] </ref>); for example, we can take W = fx 2 fl j K (x) jxj=2g; where K (x) is the Kolmogorov complexity of x with respect to some fixed universal DTM (see [18]).
Reference: [25] <author> L. Stockmeyer. </author> <title> The polynomial-time hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference-contexts: We use P and FP to denote the classes of all polynomial-time computable languages and functions respectively. We use NP to denote the class of all languages computable in nondeterministic polynomial time, and PH denotes the polynomial hierarchy (see <ref> [25] </ref>). We say informally that a class of languages or functions is relativizable if its definition refers| explicitly or implicitly|to computation and/or computing machines.
Reference: [26] <author> S. Toda, </author> <year> 1990. </year> <title> Private communication. </title>
Reference: [27] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(5) </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction In 1979, Valiant [29] defined the class #P, the class of functions definable as the number of accepting computations of some polynomial-time nondeterministic Turing machine. Valiant showed many natural problems complete for this class, including the permanent of a zero-one matrix. Toda <ref> [27] </ref> showed that these functions have more power than previously believed; he showed how to reduce any problem in the polynomial-time hierarchy to a single value of a #P function. The class #P has its shortcomings, however.
Reference: [28] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(2) </volume> <pages> 316-328, </pages> <year> 1992. </year>
Reference-contexts: GapP also has all the other nice closure properties of #P, such as addition, multiplication, and binomial coefficients. Beigel, Reingold, & Spielman first used gaps to great advantage in [6] to show that PP is closed under intersection. Toda and Ogiwara have also formulated their results in <ref> [28] </ref> using GapP instead of #P (see section 3). We will argue that GapP is the right way to think about #P-like functions. Many complexity classes, such as NP, UP, BPP, PP, C = P, and P, have definitions based on the number of accepting paths of an NP machine. <p> From containment and lowness considerations, we further conclude that P, UP, NP, and BPP are unlikely to be gap-definable. In section 6 we address the question, first asked in <ref> [28] </ref>, of whether the polynomial hierarchy (PH) is randomly reducible to SPP. <p> We also show that some classes which are not obviously gap-definable in fact have this property. Finally, we look at alternatives to the notion of gap-definability in section 9. Narrower notions of gap-definability can be advantageous, especially in light of the results in <ref> [28] </ref>. We define nice gap-definable classes|those for which the proofs in [28] go through. Nice classes have several other desirable properties, and most of the usual gap-definable classes are nice. <p> Finally, we look at alternatives to the notion of gap-definability in section 9. Narrower notions of gap-definability can be advantageous, especially in light of the results in <ref> [28] </ref>. We define nice gap-definable classes|those for which the proofs in [28] go through. Nice classes have several other desirable properties, and most of the usual gap-definable classes are nice. <p> The last equality holds since #P #P is closed under negation. 2 8 We might just as well have taken the first equality in proposition 3.5 as the definition of GapP, and altered the proofs below accordingly. This route was indeed taken in <ref> [28] </ref>. We nonetheless prefer to use our original definition in this chapter, if only for the conceptual ease of associating a single machine to every GapP function. We now list the closure properties of GapP, deferring the proofs until afterwards. <p> More significantly, Toda and Ogiwara <ref> [28] </ref> have simplified their results using GapP. We state their main results here, using slightly altered notation. We first define a subfamily of the gap-definable classes. Definition 4.5 Let Q Z be any set. <p> Definition 4.5 Let Q Z be any set. Define GapIn [Q] df Thus GapIn [Q] identifies those gap-definable classes where the accepting and rejecting sets partition fl fi Z and the acceptance criterion is independent of the input. Next, we define the d BP operator from <ref> [28] </ref>, which is a modification of the BP operator of Schoning [22]: Definition 4.6 ([28], Definition 2.1) Let K be any class of languages. <p> as above, thus the accepting set depends on the oracle. 6 Randomized Counting One might wonder whether theorem 4.8 holds for a class such as SPP, i.e., is it true that SPP PH d BP SPP, or even that PH d BP SPP? Toda & Ogiwara address this question in <ref> [28] </ref> and conclude that this is probably not the case since the definition of any SPP language includes a promise that the gap of some machine is either 0 or 1, and the proof of theorem 4.8 relies on there being no such promise for a language in GapIn [Q]. <p> As further evidence that SPP is not as hard as PH, we now show that there is an oracle relative to which NP 6 d BP SPP. (An observation in <ref> [28] </ref> implies that d BP SPP = BP SPP since SPP is closed under majority-tt-reductions.) In fact, the oracle constructed in [3] will do. Proposition 6.1 There exists an oracle A such that NP A 6 ( d BP SPP) A . <p> The first two conditions taken together yield the classes GapIn [Q] (see definition 4.5) considered by Toda & Ogiwara <ref> [28] </ref>, which we will call nice classes. As well as having all the properties mentioned above, nice classes also have complete sets (under polynomial time m-reductions). Despite these restrictions, all the well-known gap-definable classes|PP, C = P, and Mod k P|are nice, and have simple acceptance/rejection criteria.
Reference: [29] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pages 189-201, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction In 1979, Valiant <ref> [29] </ref> defined the class #P, the class of functions definable as the number of accepting computations of some polynomial-time nondeterministic Turing machine. Valiant showed many natural problems complete for this class, including the permanent of a zero-one matrix. <p> We now define some of the usual counting classes. These are not always the original definitions, but can easily be shown to be equivalent to them. See [4] for more details. Definition 2.3 * (Valiant <ref> [29] </ref>) #P df * (Gill [9]) PP is the class of all languages L such that there exists M and an FP function f such that, for all x, x 2 L () #M (x) &gt; f (x): The function f is the threshold of M . 6 * (Wagner [30])
Reference: [30] <author> K. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representation. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year> <month> 34 </month>
Reference-contexts: [29]) #P df * (Gill [9]) PP is the class of all languages L such that there exists M and an FP function f such that, for all x, x 2 L () #M (x) &gt; f (x): The function f is the threshold of M . 6 * (Wagner <ref> [30] </ref>) C = P is the class of all languages L such that there exists M and an FP function f such that, for all x, x 2 L () #M (x) = f (x): * (Beigel, Gill, Hertrampf [5]) For k 2, define Mod k P to be the class
References-found: 30

