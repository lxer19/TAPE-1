URL: http://www.cs.ucsd.edu/users/mihir/papers/dprg.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/complexity-papers.html
Root-URL: http://www.cs.ucsd.edu
Email: E-mail: mihir@cs.ucsd.edu.  E-mail: garay@cwi.nl, garay@watson.ibm.com.  
Title: Distributed Pseudo-Random Bit Generators| A New Way to Speed-Up Shared Coin Tossing  
Author: Mihir Bellare Juan A. Garay Tal Rabin 
Web: URL: //www-cse.ucsd.edu/users/mihir.  URLs: //www.cwi.nl, //www.research.ibm.com/security.  
Address: San Diego, 9500 Gilman Drive, La Jolla, CA 92093.  Kruislaan 413, 1098 SJ Amsterdam, The Netherlands,  PO Box 704, Yorktown Heights, New York 10598.  
Affiliation: Department of Computer Science Engineering, Mail Code 0114, University of California at  CWI,  and IBM T.J. Watson Research Center,  
Date: 1996  February 1996  
Note: Appears in Proceedings of the 15th Annual ACM Symposium on the Principles of Distributed Computing,  
Abstract: A shared coin is one which n players "simultaneously" hold and can later reveal, but no sufficiently small coalition can influence or a priori predict the outcome. Such coins are expensive to produce, yet many distributed protocols (including broadcast and Byzantine agreement) need them in bulk. We introduce a new paradigm for obtaining shared coins. We suggest distributed, pseudorandom bit generators (D-PRBGs). Analogous to a pseudo-random bit generator, which is an efficient algorithm to expand a short random seed into a long random looking sequence, a D-PRBG is a protocol which "expands" a "distributed seed," consisting of shared coins, into a longer "sequence" of shared coins, at low amortized cost per coin produced. Our main result is the construction of a D-PRBG in which this amortized cost (computation and communication) is significantly lower than the cost of any "from-scratch" shared coin generation protocol. Furthermore, for applications which are executed repeatedly, we suggest bootstrapping: each run of the D-PRBG produces not only the coins for the current execution but also the seed for the next execution. Since the cost of the initial seed can now effectively be neglected, we get very fast coin generation. Underlying these constructions are some techniques of independent interest. We consider batch Verifiable Secret Sharing (VSS), where we need to do a large number of VSSs simultaneously. We provide a method in which the amortized cost per VSS is significantly lower than the cost of a VSS for any known VSS protocol. z MIT Laboratory for Computer Science, 545 Technology Square, Cambridge, MA 02139, USA. E-mail: talr@theory.lcs.mit.edu. Work supported by an NSF Postdoctoral Fellowship. Part of this work was done when the author was visiting the IBM T.J. Watson Research Center. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bar-Noy, X. Deng, J. Garay, , and T. Kameda. </author> <title> Optimal Amortized Distributed Consensus . In Proc. </title> <booktitle> 5th International Workshop on Distributed Algorithms, volume 579 of Lecture notes in computer Science, </booktitle> <pages> pages 95-107. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Attempts of this nature already exist in the literature, (e.g., <ref> [1] </ref> for the specific case of deterministic agreement; [13] for the construction of a Brachia assignment; etc.). However, these amortization efforts work subject to the proviso that the set of faulty players remain (relatively) fixed. In contrast, this is not required by our method.
Reference: [2] <author> D. Beaver and N. </author> <title> So. Global, Unpredictable Bit Generation without Broadcast. </title> <booktitle> In Advances in Cryptology - Eurocrypt 93, Lecture Notes in Computer Science Vol. </booktitle> <volume> 765, </volume> <pages> pages 424-434. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 13 </month>
Reference-contexts: The global coin protocol of Beaver and So <ref> [2] </ref> only needs a majority a good players, but relies on complexity assumptions (specifically, the intractability of factoring), which in turn makes it inefficient. Furthermore, the generation of bits is limited to a pre-set size. <p> In addition, our coin will be unanimous except for a probability of error less than M n2 k . And the generation process is endless, as bits are generated upon demand. As in <ref> [2] </ref>, our scheme also provides "random access" to the bits. Finally, Blum [6] considered the case of n = 2 players, whereas our focus is on n 4. VSS. The verifiability in [10] was implemented via zero-knowledge proofs and thus was expensive. This paradigm continued in several later works.
Reference: [3] <author> M. Bellare, J. Garay, and T. Rabin. </author> <title> Batch Verification- A way to speed-up protocols, </title> <note> 1996. In preparation. </note>
Reference-contexts: History and existing implementations are discussed in more detail in Section 1.4. 4 Batch verifications. The problem we consider is to efficiently verify the distribution of many secrets. We draw from the ideas of batch instance verification <ref> [3] </ref>, whose main goal is to be more efficient than the naive way of verifying each instance individually.
Reference: [4] <author> M. Ben-Or, S. Goldwasser, and A. Wigderson. </author> <title> Completeness Theorems for Noncryptographic Fault-Tolerant Distributed Computations. </title> <booktitle> In Proceeding 20th Annual Symposium on the Theory of Computing, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: Their protocol has a probability of error of 2 k . The VSS protocol of Ben-Or, Gold-wasser, and Wigderson <ref> [4] </ref> is less efficient than this. Feldman's protocol [12] relies on the unproven assumption of the hardness of discrete log. <p> The commonly known solutions to this problem are given in <ref> [9, 12, 4] </ref>. The method presented in [9] is a cut-and-choose protocol. Roughly speaking, the dealer who shared the secret is asked to share k additional polynomials, g 1 (x); : : : ; g k (x).
Reference: [5] <author> E. Berlekamp and L. Welch. </author> <title> Error correction of algebraic block codes. </title> <type> US Patent 4,633,470. </type>
Reference-contexts: So an implementation should be careful about which method it uses. In some parts we consider the interpolation of a polynomial as a basic step. Methods such as the Berlekamp-Welch decoder <ref> [5] </ref> can be used to implement this operation. 3 Batch Verifiable Secret Sharing We start off with a VSS protocol for a single secret that compares favorably with existing protocols. <p> This enables us to use the Berlekamp-Welch <ref> [5] </ref> decoder to compute the desired polynomial. 2 The following theorem states the cost of generating the shared coins.
Reference: [6] <author> M. Blum. </author> <title> Coin Flipping by Telephone- A protocol for solving impossible problems. </title> <booktitle> In IEEE Spring Compcon, </booktitle> <pages> pages 133-137. </pages> <publisher> IEEE, </publisher> <year> 1982. </year>
Reference-contexts: In addition, our coin will be unanimous except for a probability of error less than M n2 k . And the generation process is endless, as bits are generated upon demand. As in [2], our scheme also provides "random access" to the bits. Finally, Blum <ref> [6] </ref> considered the case of n = 2 players, whereas our focus is on n 4. VSS. The verifiability in [10] was implemented via zero-knowledge proofs and thus was expensive. This paradigm continued in several later works. We skip to more direct methods.
Reference: [7] <author> M. Blum and S. Micali. </author> <title> How to generate cryptographically strong sequences of pseudo-random bits. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 </volume> <pages> 850-864, </pages> <year> 1984. </year>
Reference-contexts: In comparison to the usual (non-distributed) PRBGs, we note that unlike the cryptographic generators of <ref> [7, 19] </ref>, we do not rely on complexity assumptions. (We do assume that the parties can locally produce random bits as needed. Perhaps they will do this using cryptographic pseudorandom generators, in which case complexity assumptions appear.
Reference: [8] <author> R. Canetti and A. Herzberg. </author> <title> Maintaining security in the presence of transient faults . In Advances in Cryptology - CRYPTO '94 proceeding, </title> <booktitle> volume 839 of Lecture notes in computer Science, </booktitle> <pages> pages 425-438. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: However, these amortization efforts work subject to the proviso that the set of faulty players remain (relatively) fixed. In contrast, this is not required by our method. In fact, one of the motivations and applications of our work is pro-active security (e.g., <ref> [8, 16] </ref>), which deals with settings where intruders are allowed to move over time. Our solution to multiple-coin generation can be easily adapted to this scenario. 1.3 Batch VSS One of the techniques underlying our fast D-PRBG is of independent interest.
Reference: [9] <author> D. Chaum, C. Crepau, and I. Damgard. </author> <title> Multiparty Unconditionally Secure Protocols. </title> <booktitle> In Proceeding 20th Annual Symposium on the Theory of Computing, </booktitle> <pages> pages 11-19. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: Its computation cost is n 2 k operations per player, and the communication is 2n messages each of size k for a total of 2nk bits of communication. Our solution is comparable to the one of <ref> [9] </ref> in computation, although slightly better in communication. It assumes the existence of a k-ary secret coin; this is a realistic assumption in the presence of a D-PRBG, and in particular under the "bootstrapping" setting we are considering here. 1.4 History and comparisons Shared coins. <p> VSS. The verifiability in [10] was implemented via zero-knowledge proofs and thus was expensive. This paradigm continued in several later works. We skip to more direct methods. Assuming a broadcast channel and a security parameter k, the method of Chaum, Crepeau, and Damg-ard <ref> [9] </ref> requires n 2 k log 2 n computation and communication (total number of bits) of O (nk log n). Their protocol has a probability of error of 2 k . The VSS protocol of Ben-Or, Gold-wasser, and Wigderson [4] is less efficient than this. <p> The commonly known solutions to this problem are given in <ref> [9, 12, 4] </ref>. The method presented in [9] is a cut-and-choose protocol. Roughly speaking, the dealer who shared the secret is asked to share k additional polynomials, g 1 (x); : : : ; g k (x). <p> The commonly known solutions to this problem are given in [9, 12, 4]. The method presented in <ref> [9] </ref> is a cut-and-choose protocol. Roughly speaking, the dealer who shared the secret is asked to share k additional polynomials, g 1 (x); : : : ; g k (x). <p> A consequence of this is that both the dealer and the players have to carry out t exponentiations (i.e., t log p multiplications). See <ref> [9, 12] </ref> for details. The VSS protocol we present here computes a single polynomial interpolation in a field GF (2 k ), and achieves a probability of error less than 1 2 k . Note that this achieves the same probability of error as in [9]. <p> See [9, 12] for details. The VSS protocol we present here computes a single polynomial interpolation in a field GF (2 k ), and achieves a probability of error less than 1 2 k . Note that this achieves the same probability of error as in <ref> [9] </ref>. The number of required computations is 2n 2 k, and the communication required by our protocol is 2n messages, each of size k, resulting in a total bit complexity of 2nk. Protocol VSS is shown in Figure 2. The code is self-explanatory.
Reference: [10] <author> B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. </author> <title> Verifiable Secret Sharing and Achieving Simultaneity in the Presence of Faults. </title> <booktitle> In Proceeding 26th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 383-395. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: This is batch Verifiable Secret Sharing (VSS), where we do many verifiable sharings of secrets with a small amortized cost per sharing. Verifiable Secret Sharing. The Verifiable Secret Sharing (VSS) problem <ref> [10] </ref> can be roughly stated as follows. <p> And the generation process is endless, as bits are generated upon demand. As in [2], our scheme also provides "random access" to the bits. Finally, Blum [6] considered the case of n = 2 players, whereas our focus is on n 4. VSS. The verifiability in <ref> [10] </ref> was implemented via zero-knowledge proofs and thus was expensive. This paradigm continued in several later works. We skip to more direct methods.
Reference: [11] <author> C. Dwork, D. Shmoys, and L. Stockmeyer. </author> <title> Fliping Presuasively in Constant Expected Time. </title> <booktitle> In Proceeding 27th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 222-232. </pages> <publisher> IEEE, </publisher> <year> 1986. </year>
Reference-contexts: In that setting, the common coin was pre-generated by a trusted party, and could be revealed at a later time by the participants. There have been many protocols in the literature for the generation of distributed random coins; we shall discuss a few of them. In <ref> [11] </ref> a coin is achieved which can tolerate n= log n faults, it runs in constant expected time, and has an additional drawback in that not all the players "see" the coin.
Reference: [12] <author> P. Feldman. </author> <title> A Practical Scheme for Non-Interactive Verifiable Secret Sharing. </title> <booktitle> In Proceeding 28th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 427-437. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: Their protocol has a probability of error of 2 k . The VSS protocol of Ben-Or, Gold-wasser, and Wigderson [4] is less efficient than this. Feldman's protocol <ref> [12] </ref> relies on the unproven assumption of the hardness of discrete log. <p> The commonly known solutions to this problem are given in <ref> [9, 12, 4] </ref>. The method presented in [9] is a cut-and-choose protocol. Roughly speaking, the dealer who shared the secret is asked to share k additional polynomials, g 1 (x); : : : ; g k (x). <p> Thus, in this approach k polynomial interpolations are computed in order to achieve a probability of error less than 1 2 k . Feldman's protocol <ref> [12] </ref> depends on the unproven assumption of the hardness of the discrete log problem. After defining the polynomial (a la Shamir) and computing all the private shares f (i) of the players, the dealer generates public information which aids in the verification. <p> A consequence of this is that both the dealer and the players have to carry out t exponentiations (i.e., t log p multiplications). See <ref> [9, 12] </ref> for details. The VSS protocol we present here computes a single polynomial interpolation in a field GF (2 k ), and achieves a probability of error less than 1 2 k . Note that this achieves the same probability of error as in [9].
Reference: [13] <author> P. Felman and S. Micali. </author> <title> Byzantine Agreement in Constant Expected Time (and trusting no one). </title> <booktitle> In Proceeding 26th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 267-276. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: Attempts of this nature already exist in the literature, (e.g., [1] for the specific case of deterministic agreement; <ref> [13] </ref> for the construction of a Brachia assignment; etc.). However, these amortization efforts work subject to the proviso that the set of faulty players remain (relatively) fixed. In contrast, this is not required by our method.
Reference: [14] <author> P. Felman and S. Micali. </author> <title> An Optimal Algorithm for Synchronous Byzantine Agreement . In Proceeding 20th Annual Symposium on the Theory of Computing, </title> <address> pages 148-161. </address> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: In [11] a coin is achieved which can tolerate n= log n faults, it runs in constant expected time, and has an additional drawback in that not all the players "see" the coin. Feldman and Micali's protocol <ref> [14] </ref> is resilient against a third of the players, the computations comprise O (n 4 log 2 n) steps per player, the communication is O (n 5 ) messages, and there exists a non-negligible probability that not all players will see the coin. <p> A confidence of 2 indicates that all other honest players have seen the value . See <ref> [14] </ref> for details. We now turn to arguing the correctness of Coin-Gen. For simplicity, we assume that n = 6t + 1. Recall that, upon termination, the output of the protocol consists of a set of players.
Reference: [15] <author> M. R. Garey and D. S.Johnson. </author> <title> Computers and Intractability: a guide to NP-Completeness. </title> <editor> W. H. Freeman, ed. </editor> <address> N.Y., </address> <year> 1979. </year>
Reference: [16] <author> A. Herzberg, S. Jarecki, H. Krawczyk, and M. Yung. </author> <title> Proactive Secret Sharing. </title> <booktitle> In Advances in Cryptology - CRYPTO '95 proceeding, volume 963 of Lecture notes in computer Science, </booktitle> <pages> pages 339-352. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: However, these amortization efforts work subject to the proviso that the set of faulty players remain (relatively) fixed. In contrast, this is not required by our method. In fact, one of the motivations and applications of our work is pro-active security (e.g., <ref> [8, 16] </ref>), which deals with settings where intruders are allowed to move over time. Our solution to multiple-coin generation can be easily adapted to this scenario. 1.3 Batch VSS One of the techniques underlying our fast D-PRBG is of independent interest.
Reference: [17] <author> M. Rabin. </author> <title> Randomized Byzantine Generals. </title> <booktitle> In Proceeding 24th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 403-409. </pages> <publisher> IEEE, </publisher> <year> 1983. </year>
Reference-contexts: For simplicity, we shall assume in this presentation that deterministic BA is carried out. The initial set of coins can be obtained from a trusted third party, as in the case of Rabin <ref> [17] </ref>, or through other pre-processing methods (for example, the interpolation of a number m of polynomials, where m is at least as big as the number of faulty players to be tolerated). <p> Regarding the former, we remark that in our approach the services of a trusted dealer would be used only once, and for a small number of coins. In contrast, as the coins are "expendable," the approach of <ref> [17] </ref> requires the dealer to continuously provide them. <p> It assumes the existence of a k-ary secret coin; this is a realistic assumption in the presence of a D-PRBG, and in particular under the "bootstrapping" setting we are considering here. 1.4 History and comparisons Shared coins. The concept of a shared coin was introduced by Rabin <ref> [17] </ref>, who also gave the first implementation. In that setting, the common coin was pre-generated by a trusted party, and could be revealed at a later time by the participants.
Reference: [18] <author> A. Shamir. </author> <title> How to Share a Secret. </title> <journal> Communications of the ACM, </journal> <volume> 22 </volume> <pages> 612-613, </pages> <year> 1979. </year>
Reference-contexts: The most common way of achieving this is to employ the secret sharing scheme proposed by Shamir <ref> [18] </ref>, in which the secret is the value of a polynomial at the origin, while the players' shares are the values of the polynomial evaluated at the players' id's.

References-found: 18

