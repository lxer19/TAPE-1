URL: file://ftp.cc.gatech.edu/pub/coc/tech_reports/1994/GIT-CC-94-04.ps.Z
Refering-URL: http://www.cs.gatech.edu/grads/m/Scott.McCrickard/Scott.Mccrickard.html
Root-URL: 
Title: A Study of Wait-Free Hierarchies in Concurrent Systems  
Author: D. Scott McCrickard 
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Date: February 15, 1994  
Pubnum: GIT-CC-94/04  
Abstract: An assignment of wait-free consensus numbers to object types results in a wait-free hierarchy. Herlihy was the first to propose such a hierarchy, but Jayanti noted that Herlihy's hierarchy was not robust. Jayanti posed as open questions the robustness of a hierarchy he defined and the existence of a robust, wait-free hierarchy. In this paper, we examine a number of object parameters that may impact on a hierarchy's robustness. In addition, we study a subset of Jayanti's hierarchy introduced by Afek, Weisberger, and Weisman called common2 and extend this subset to include the seemingly powerful 2-bounded peek-queue. Finally, we introduce a property called commonness and examine its applications to wait-free hierarchies and their robustness. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Yehuda Afek, Hagit Attiya, Danny Dolev, Eli Gafni, Michael Merritt, and Nir Shavit. </author> <title> Atomic snapshots of shared memory. </title> <journal> Journal of the ACM, </journal> <volume> 40(4) </volume> <pages> 873-890, </pages> <month> September </month> <year> 1993. </year>
Reference: [2] <author> Yehuda Afek, Eytan Weisberger, and Hanan Weisman. </author> <title> A completeness theorem for a class of synchronization objects. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 159-170. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: While Afek, Weisberger, and Weisman defined a specific set of objects as common2, they proved that our definitive property applies to all of its object types <ref> [2] </ref>. They conclude with a challenge to readers to extend common2 to include more or all of the objects at level 2 of Jayanti's hierarchy. Section 3 of this paper extends common2 to include a seemingly powerful object, the 2-bounded peek-queue.
Reference: [3] <author> James H. Anderson. </author> <title> Composite registers. </title> <journal> Distributed Computing, </journal> <volume> 6(3) </volume> <pages> 141-154, </pages> <month> April </month> <year> 1993. </year>
Reference: [4] <author> Hagit Attiya, Maurice Herlihy, and Ophir Rachman. </author> <title> Efficient atomic snapshots using lattice agreement. </title> <editor> In A. Segall and S. Zaks, editors, </editor> <booktitle> Proceedings of the Sixth International 12 Workshop on Distributed Algorithms, number 647 in Lecture Notes on Computer Science, </booktitle> <pages> pages 35-53. </pages> <publisher> Springer-Verlag, </publisher> <month> November </month> <year> 1992. </year>
Reference: [5] <author> Hagit Attiya and Ophir Rachman. </author> <title> Atomic snapshots in O(n log n) operations. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 29-40. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1993. </year>
Reference: [6] <author> Bard Bloom. </author> <title> Constructing two-writer atomic registers. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 249-259. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1987. </year>
Reference: [7] <author> Elizabeth Borowsky and Eli Gafni. </author> <title> Generalized FLP impossibility result for t-resilient asynchronous computations. </title> <booktitle> In Proceedings of the Twenty-Fifth ACM Symposium on Theory of Computing, </booktitle> <pages> pages 91-100. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1993. </year>
Reference: [8] <author> Elizabeth Borowsky and Eli Gafni. </author> <title> Immediate atomic snapshots and fast renaming. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 41-52. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1993. </year>
Reference: [9] <author> James E. Burns and Gary L. Peterson. </author> <title> Constructing multi-reader atomic values from nonatomic values. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 222-231. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1987. </year>
Reference: [10] <author> Soma Chaudhuri. </author> <title> Agreement is harder than consensus: Set consensus problems in totally asynchronous systems. </title> <journal> Information and Computation, </journal> <volume> 103(1) </volume> <pages> 132-158, </pages> <month> July </month> <year> 1993. </year>
Reference: [11] <author> Soma Chaudhuri, Maurice Herlihy, Nancy Lynch, and Mark R. Tuttle. </author> <title> A tight lower bound for k-set agreement. </title> <booktitle> In Proceedings of the Thirty-Fourth Symposium on Foundations of Computer Science, </booktitle> <pages> pages 206-215. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1993. </year>
Reference: [12] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: These parameters are discussed in Section 2 of this paper. Herlihy discovered that the existence of a wait-free implementation using a given object is related to the object's ability to be used in achieving consensus <ref> [12] </ref>. A set of processes achieves consensus when all of the processes agree on a single value. In order to achieve consensus, the processes must communicate using shared objects. <p> initialization of objects, and would handle breakability in a deterministic manner, this paper will consider objects with respect to these parameters. 2.1 Initialization, Breakability, and Consensus for Queues Herlihy proved that a queue initialized to contain 0 in the first slot and 1 in the second could achieve 2-process consensus <ref> [12] </ref>. Such a queue could be dequeued by each of two processes: the process that is returned the 0 is the winner and the process returned the 1 is the loser and knows the other process won. This is enough to implement consensus.
Reference: [13] <author> Maurice Herlihy and Nir Shavit. </author> <title> The asynchronous computability theorem for t-resilient tasks. </title> <booktitle> In Proceedings of the Twenty-Fifth ACM Symposium on Theory of Computing, </booktitle> <pages> pages 111-120. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1993. </year>
Reference-contexts: Consider types that support such wait-free solutions. At what level must they be in a hierarchy such as h r m ? Interestingly, Herlihy and Shavit <ref> [13] </ref> showed that knowing type T can achieve k-set consensus is not sufficient to show that h r m (T ) &gt; 1. <p> If objects are not initializable and are nondeterministically specified, a very simple and general specification of a 2-set consensus object can be given. It follows from the results of Herlihy and Shavit <ref> [13] </ref> that this object is at level 1 of h r m . However, their results also show that it cannot be implemented by registers in systems with 3 processes. Thus, this object is not common.
Reference: [14] <author> Maurice P. Herlihy and Jeannette M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Since no system could provide every type of object, implementations of objects using other objects may be required. In order for an object implementation to be correct, the method of implementation must be linearizable: operations on the object by concurrent processes must appear to occur in some legal sequence <ref> [14] </ref>. The traditional method, ensuring linearizability using critical sections, is ill-suited for fault-tolerant systems; a process could crash inside a critical section and prevent the other processes from accessing that object.
Reference: [15] <author> Prasad Jayanti. </author> <title> On the robustness of Herlihy's hierarchy. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 145-158. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: Since the consensus number of an object type depends on the number of objects and the number of registers that can be used in the implementation <ref> [15] </ref>, different consensus numbers could be assigned to a single type resulting in different hierarchies. Herlihy's hierarchy, which Jayanti referred to as h r 1 , and Jayanti's hierarchy h r m differ in the number of objects that can be used to implement consensus. <p> Jayanti asserted that a desirable hierarchy would be fully-refined and robust <ref> [15] </ref>. A hierarchy is fully-refined if there is some type at every level f1; 2; : : :; 1g of the hierarchy.
Reference: [16] <author> Prasad Jayanti and Sam Toueg. </author> <title> Some results on the impossibility, universality, and decidability of consensus. </title> <editor> In A. Segall and S. Zaks, editors, </editor> <booktitle> Proceedings of the Sixth International Workshop on Distributed Algorithms, number 647 in Lecture Notes on Computer Science, </booktitle> <pages> pages 69-84. </pages> <publisher> Springer-Verlag, </publisher> <month> November </month> <year> 1992. </year>
Reference-contexts: This is enough to implement consensus. Jayanti and Toueg proved that an initially empty queue could not achieve 2-process consensus <ref> [16] </ref>. Their proof is based on the observation that each enq by a process could be A Study of Wait-Free Hierarchies in Concurrent Systems 3 matched with a deq by the same process; thus, neither process would learn from the other and the processes would never reach consensus. <p> Jayanti and Toueg showed that every level N contains the N -bounded peek-queue, a queue of size N that, instead of a dequeue operation, supports a peek operation which returns the values currently in the queue <ref> [16] </ref>. This result suggests that the N -bounded peek-queue may be the strongest object at level N . If the 2-bounded peek-queue is in common2, then it is no stronger than any other object.
References-found: 16

