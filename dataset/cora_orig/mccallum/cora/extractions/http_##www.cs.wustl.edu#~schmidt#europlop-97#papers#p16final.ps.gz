URL: http://www.cs.wustl.edu/~schmidt/europlop-97/papers/p16final.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/europlop-97/workshops.html
Root-URL: 
Email: Email: koethe@egd.igd.fhg.de  
Title: Requested Interface Make reuse of services more attractive than reimplementation by providing independent components that
Author: Ullrich Kthe 
Note: Purpose  
Address: Rostock, Germany Joachim-Jungius-Str. 9, 18059 Rostock  
Affiliation: Fraunhofer Institute for Computer Graphics,  
Abstract: This paper introduces the Requested Interface pattern which describes ways to implement truly independent software components that can be plugged together as needed in order to make reuse more attractive than reimplementation. It encourages components to delegate subtasks to collaborating servers so that they can be adapted to a new context by simply exchanging those subtask servers. The delegating objects must specify minimal and abstract requested interfaces that describe the subtasks independ - ently of existing server interfaces. An adaptation layer mediates between the requested Although highly desirable, software reuse is still much less customary than it could be. Programmers often choose to reimplement a service because this is much easier than reusing any existing one. For a service to be reusable, two fundamental requirements must be met: 1. It must be easy to extract a reusable service from its old context. In particular, the service must not interface of a client and the offered interface of a server implementing the subtask.
Abstract-found: 1
Intro-found: 1
Reference: [BR97] <author> D. Bumer, D. Riehle: </author> <title> Product Trader, </title> <editor> in: R. Martin, D. Riehle, F. Buschmann (eds.): </editor> <booktitle> Pattern Languages of Program Design 3, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1997 </year>
Reference-contexts: Patterns from [GHJV94]: As has been shown in the previous section, several patterns from this book (most importantly Bridge, Adapter, and Mediator) may be used to implement the adaptation layer of the Requested Interface pattern. Trader (see for example <ref> [BR97] </ref>): The trader concept may be regarded as a consequence of the Requested Interface pattern. Given a requested interface, the Trader tries to find matching servers automatically by comparing the offered interfaces with the request. Different adaptation variants may be supported to improve chances for finding a suitable server.
Reference: [FOW96] <author> M. Fowler: </author> <title> Reusable Object Models, </title> <publisher> Addison-Wesley, </publisher> <year> 1996 </year>
Reference-contexts: Also, subtasks that might be reusable by many other clients are primary candidates for separation. A very detailed discussion on how to identify subtask servers can be found in [MART94]. Three tiered architectures, which are widely used in business applications, provide a nice example <ref> [FOW96] </ref>: The user interacts with the user services tier. All computations are delegated to the business services tier which may consist of any number of exchangeable servers containing the application logic.
Reference: [GARL95] <author> D. Garlan, R. Allen, L. Ockerbloom: </author> <title> Architectural Mismatch or Why its hard to build systems out of existing parts, </title> <booktitle> 17 th Intl. Conf. on Software Engineering, </booktitle> <year> 1995 </year>
Reference: [GHJV94] <author> E. Gamma, R. Helm, R. Johnson, J. Vlissides: </author> <title> Design Patterns, </title> <publisher> Addison-Wesley, </publisher> <year> 1994 </year>
Reference-contexts: It is, however, the appropriate solution if speed of access is of utmost concern, e.g. if the requested interface is an iterator whos inlined functions are frequently called within a loop. Generic Bridge: This approach is a variation of the Bridge pattern from <ref> [GHJV94] </ref>. <p> Several patterns from <ref> [GHJV94] </ref> are among the implementation choices. The Adapter pattern is applied if one server semantically fulfills the requested interface but the generic methods above are not applicable (e.g., the function signatures differ). <p> The STL iterators are clearly applications of Requested Interface, in conjunction with the particular implementation technique as described above. Patterns from <ref> [GHJV94] </ref>: As has been shown in the previous section, several patterns from this book (most importantly Bridge, Adapter, and Mediator) may be used to implement the adaptation layer of the Requested Interface pattern.
Reference: [KEL93] <author> A. Keller, R. Jensen, S. Agarwal: </author> <title> Persistence Software: Bridging ObjectOriented Programming and Relational Databases, </title> <booktitle> ACM SIGMOD, </booktitle> <year> 1993 </year>
Reference-contexts: However, this is not required, and you can always use a hand-coded bridge for the more difficult adaptation cases. Object-Relational Mapping: Sometimes an application that uses an objectoriented database for data storage must later be modified to use a relational database. Tools for object-relational mapping <ref> [KEL93] </ref> are designed to automatically generate the necessary adapters: By analyzing the definition of the objects to be stored (the Requested Interface of the application) they produce code to translate between the objectoriented and relational representations (in the applications language) and to store and retrieve the translated data (usually SQL).
Reference: [KTH97] <author> U. Kthe: </author> <title> Reusable Algorithms in Image Processing, </title> <note> submitted </note>
Reference-contexts: VIGRA <ref> [KTH97] </ref>: Our own framework for image processing, analysis, and visualization tries to translate the ideas of the STL into these fields. One of the main problems here is the existence of many different image formats and pixel data types.
Reference: [LIEB96] <author> K. Lieberherr: </author> <title> Adaptive ObjectOriented Software: The Demeter Method with Propagation Patterns, </title> <publisher> PWS Publishing Company, </publisher> <year> 1996 </year>
Reference-contexts: Often, cooperation of several servers is necessary to meet the clients needs. Then the Mediator pattern is a good implementation choice. If the appropriate server to respond depends on the request itself you may also use Chain-of-Responsibility. Another interesting option is offered by Adaptive Programming <ref> [LIEB96] </ref>, although its original purpose is different, namely the enforcement of the Law of Demeter (see below). Adaptive programming is based on a graph representation of the relationships between cooperating servers. <p> This programming style encourages reuse by strongly reducing coupling between different parts of a software system towards really self-contained components that can be freely combined together. Law of Demeter <ref> [LIEB96] </ref>: This law makes a statement about which collaborators a client is allowed to use: namely objects that it contains or created itself, and objects that are explicitly passed as function arguments.
Reference: [MART94] <author> R. Martin: </author> <title> Designing ObjectOriented C++ Applications using the Booch Method, </title> <publisher> Prentice Hall, </publisher> <year> 1994 </year>
Reference-contexts: It must be easy to adapt the service to the new context. In particular, it should not be necessary to touch the source code of the service (Open-Closed Principle, see [MAY94], <ref> [MART94] </ref>). We will discuss these requirements using an algorithm that transforms an RGB image into a corresponding gray level image as a running example. <p> Also, subtasks that might be reusable by many other clients are primary candidates for separation. A very detailed discussion on how to identify subtask servers can be found in <ref> [MART94] </ref>. Three tiered architectures, which are widely used in business applications, provide a nice example [FOW96]: The user interacts with the user services tier. All computations are delegated to the business services tier which may consist of any number of exchangeable servers containing the application logic.
Reference: [MEY94] <author> B. Meyer: </author> <title> ObjectOriented Software Construction, </title> <publisher> Prentice Hall, </publisher> <year> 1994 </year>
Reference-contexts: Therefore, we should restrict ourselves to the necessary when writing reusable clients, but should be splendid when writing server interfaces. Extended Design by Contract: In the light of Design by Contract <ref> [MEY94] </ref> the Requested Interface may be seen as a promise of the client not to use any services and functions except those specified.
Reference: [MS94] <author> D.Musser, A. Stepanov: </author> <title> Algorithm Oriented Generic Libraries, in: </title> <journal> Software - Practice and Experience, </journal> <volume> vol. 24, no. 7, </volume> <pages> pp. 623-642, </pages> <year> 1994 </year>
Reference-contexts: Both of the fundamental requirements for reuse are met. Related Patterns and Design Principles Generic Programming <ref> [MS94] </ref>: Generic Programming, and in particular the Standard Template Library, was one of the main inspirations for writing down this pattern (see the Known Uses section below). The STL iterators are clearly applications of Requested Interface, in conjunction with the particular implementation technique as described above. <p> Known Uses Standard Template Library [SL94]: To my knowledge, this is the best example for the application of the Requested Interface pattern to date. As Musser and Stepanov explain in section Outline of the algorithm oriented approach of their paper <ref> [MS94] </ref>: Start with the most efficient known algorithms and data structures, identify container access operations [...] on which the algorithms depend and abstract [...] those operations by determining the minimal behavior they must exhibit in order for the algorithm to perform a useful operation.
Reference: [ORB96] <institution> Orbix 2 Programming Guide, IONA Technologies Inc. </institution> <year> 1996 </year>
Reference-contexts: CORBA [OMG95]: This standard enables, among other things, component based programming . Its core component is an Interface Definition Languages (IDL) which is used to specify interoperable interfaces between clients and servers. Orbix TIE approach for the implementation of CORBA conforming components <ref> [ORB96] </ref> is a nice example for the Requested Interface pattern: First, you specify the clients requested interface using IDL.
Reference: [OMG95] <author> Object Management Group: </author> <title> The Common Object Request Broker: Architecture and Specification, Revision 2.0, </title> <year> 1995 </year>
Reference-contexts: Writing Requested Interfaces There are several possibilities to write requested interfaces depending on the implementation environment: In mixed language and distributed environments you should use a dedicated interface description language such as CORBAs IDL <ref> [OMG95] </ref>. In objectoriented languages the requested interface is often specified as an abstract base class from which the adapters can be derived (cf. Generic Bridge below). <p> This approach is, for example, taken by CORBA <ref> [OMG95] </ref> where a code generator (misleadingly called IDL compiler) translates the IDL specification into source code for the implementation language selected. (2) Requested and offered interfaces do not fit: Here the solution depends largely on the type of misfit. Several patterns from [GHJV94] are among the implementation choices. <p> This is, however, by no means necessary: By writing appropriate adapters, one can easily use STL algorithms for other data structures (e.g. persistent containers as provided by an objectoriented database system) that define different access methods than the STL. CORBA <ref> [OMG95] </ref>: This standard enables, among other things, component based programming . Its core component is an Interface Definition Languages (IDL) which is used to specify interoperable interfaces between clients and servers.
Reference: [REEN95] <author> T. Reenskaug, P. Wold, O.A. Lehne: </author> <title> Working with Objects, </title> <publisher> Prentice Hall, </publisher> <year> 1995 </year>
Reference-contexts: Different adaptation variants may be supported to improve chances for finding a suitable server. The Object Management Group (OMG) is currently working on a standardized trading service for the CORBA environment. Roles <ref> [REEN95] </ref>: Role based design is quite close to the Requested Interface pattern. The main difference lies in the fact that in the latter the clients play an active part by specifying the requested interfaces, while a Role is actively taken on by a server.
Reference: [SM94] <author> A. Stepanov, M. Lee: </author> <title> The Standard Template Library, </title> <type> Hewlett-Packard Laboratories Technical Report HPL-94-34, </type> <year> 1994 </year>
References-found: 14

