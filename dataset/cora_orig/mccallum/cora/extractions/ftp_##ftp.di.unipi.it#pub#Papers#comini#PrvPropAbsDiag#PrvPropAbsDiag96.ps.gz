URL: ftp://ftp.di.unipi.it/pub/Papers/comini/PrvPropAbsDiag/PrvPropAbsDiag96.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: Proving Properties of Logic Programs by  
Abstract: Diagnosis 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aiken and T. K. Lakshman. </author> <title> Directional type checking of logic programs. </title> <editor> In B. Le Charlier, editor, </editor> <booktitle> Proc. Static Analysis Symposium, SAS'94, volume 864 of Lecture Notes in Computer Science, </booktitle> <pages> pages 43-60. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Examples of useful operators are the reduced product [23,20,11,10], the disjunctive completion [26,33,36] and the functional dependencies [23,35]. For example, directional types <ref> [1] </ref> can systematically be derived from atomic types, by refining the domain by means of a functional dependencies operator. The above mentioned use of POS for handling the simple case of natural numbers does indeed model directional types.
Reference: 2. <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier and The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The relation between the two approaches is discussed in Section 10. 2 Preliminaries In the following sections, we assume familiarity with the standard notions of logic programming as introduced in <ref> [2] </ref> and [39]. 2.1 Logic programming Throughout the paper we assume programs and goals being defined on a first order language given by a signature consisting of a finite set F of function symbols, a finite set of predicate symbols and a denumerable set V of variable symbols.
Reference: 3. <author> K. R. Apt. </author> <title> Program verification and Prolog. </title> <editor> In E. Borger, editor, </editor> <title> Specification and validation methods for programming languages and systems. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference: 4. <author> K. R. Apt, M. Gabbrielli, and D. Pedreschi. </author> <title> A closer look to declarative interpretations. </title> <journal> Journal of Logic Programming, </journal> <volume> 28(2) </volume> <pages> 147-180, </pages> <year> 1996. </year>
Reference: 5. <author> K. R. Apt and E. Marchiori. </author> <title> Reasoning about Prolog programs: from modes through types to assertions. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6A):743-765, </volume> <year> 1994. </year>
Reference-contexts: Moreover, correctness w.r.t. the concrete semantics is guaranteed. The persistency conditions developed for verification techniques (see, for example the definitions of well-typedness and well-modedness <ref> [5] </ref>) have a similar structure, which looks like the application of an immediate consequences operator. However, they are different ad-hoc definitions, not explicitly related to the concrete semantics.
Reference: 6. <author> K. R. Apt and D. Pedreschi. </author> <title> Reasoning about termination of pure PROLOG programs. </title> <journal> Information and Computation, </journal> <volume> 106(1) </volume> <pages> 109-157, </pages> <year> 1993. </year>
Reference-contexts: Hence our incompleteness symptoms are exactly the insufficiency symptoms in [30]. The requirement on P ff [[P ]] seems to be very strong. However, this property holds for a large class of programs, i.e., for acceptable programs as defined in <ref> [6] </ref>. Acceptable programs are the left-terminating programs, i.e., those programs for which the SLD -derivations of ground goals (via the leftmost selection rule) are finite. Most interesting programs are acceptable (all the pure PROLOG programs in [46] are reported in [6] to be acceptable). <p> class of programs, i.e., for acceptable programs as defined in <ref> [6] </ref>. Acceptable programs are the left-terminating programs, i.e., those programs for which the SLD -derivations of ground goals (via the leftmost selection rule) are finite. Most interesting programs are acceptable (all the pure PROLOG programs in [46] are reported in [6] to be acceptable). The same property holds for the wrong versions of acceptable programs provided that the errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fix-point [6]. <p> PROLOG programs in [46] are reported in <ref> [6] </ref> to be acceptable). The same property holds for the wrong versions of acceptable programs provided that the errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fix-point [6]. The same property holds for all the immediate consequences operators P ff [[P ]], corresponding to denotational observables. Theorem 23 (fixpoint uniqueness). [16] Let P be an acceptable program and ff be a denotational observable.
Reference: 7. <author> T. Armstrong, K. Marriott, P. Schachte, and H. Stndergaard. </author> <title> Boolean func-tions for dependency analysis: Algebraic properties and efficient representation. </title> <editor> In B. Le Charlier, editor, </editor> <booktitle> Proc. Static Analysis Symposium, SAS'94, volume 864 of Lecture Notes in Computer Science, </booktitle> <pages> pages 266-280. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: On the other hand, the class of semi-denotational observables includes several domains proposed for type, mode and groundness analysis. We will just consider the domain POS <ref> [7] </ref>. In Section 7 we give the basic definitions of abstract diagnosis, which are a straightforward adaptation of those given for declarative diagnosis, and the theorems on which the abstract diagnosis algorithms are based, for the case of denotational and semi-denotational observables. <p> Note that there exist observables, which are interesting for program analysis and which are not even semi-denotational (for example, the domain depth (l) [44] and the domain of groundness dependencies DEF <ref> [7] </ref> are not condensing). 5 Denotational observables First of all recall that any observable is precise w.r.t. the union operation since for any Galois insertion, ff ( f E i g i2I ) = ff ( f (fl ffi ff)E i g i2I ): Definition 5.
Reference: 8. <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <volume> 19-20:149-197, </volume> <year> 1994. </year>
Reference: 9. <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference: 10. <author> C. Click and K. D. Cooper. </author> <title> Combining analyses, combining optimizations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 181-196, </pages> <year> 1995. </year>
Reference: 11. <author> M. Codish, A. Mulkers, M. Bruynooghe, M. Garca de la Banda, and M. Hermenegildo. </author> <title> Improving abstract interpretations by combining domains. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(1) </volume> <pages> 28-44, </pages> <year> 1995. </year>
Reference: 12. <author> P. Codognet and G. </author> <title> File. Computations, Abstractions and Constraints. </title> <booktitle> In Proc. Fourth IEEE Int'l Conference on Computer Languages. </booktitle> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference: 13. <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 172-186. </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference: 14. <author> M. Comini, G. Levi, and M. C. Meo. </author> <title> Compositionality of SLD-derivations and their abstractions. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proceedings of the 1995 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 561-575. </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference: 15. <author> M. Comini, G. Levi, and M. C. Meo. </author> <title> A theory of observables for logic programs. </title> <note> Submitted for publication, </note> <year> 1996. </year>
Reference: 16. <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Abstract debugging of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. Logic Program Synthesis and Transformation and Metaprogramming in Logic 1994, volume 883 of Lecture Notes in Computer Science, </booktitle> <pages> pages 440-450. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fix-point [6]. The same property holds for all the immediate consequences operators P ff [[P ]], corresponding to denotational observables. Theorem 23 (fixpoint uniqueness). <ref> [16] </ref> Let P be an acceptable program and ff be a denotational observable. Then lfp P ff [[P ]] is the unique fixpoint of P ff [[P ]].
Reference: 17. <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Declarative diagnosis revisited. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proceedings of the 1995 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 275-287. </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Remember that denotational observables are also semi-denotational. Moreover the computed answers observable is also denotational. We will then define the theory for semi-denotational observables. Some stronger results will hold for denotational observables only. The diagnosis w.r.t. computed answers <ref> [17] </ref> is obtained as an instance of the scheme. Definition 10. Let P be a program and ff be a semi-denotational observable. 1. P is partially correct w.r.t. I ff if ff (F [[P ]]) I ff . 2. P is complete w.r.t. <p> Incorrect clauses and uncovered A -elements can be detected by means of very simple bottom-up and top-down algorithms, without actually computing the abstract semantics (e.g. no fixpoint computation is required). Rather strong results hold for denotational observables, which allow us to handle the diagnosis w.r.t. computed answers <ref> [17] </ref> and to reconstruct the declarative diagnosis methods based on the least Herbrand model and on the c-semantics. <p> In order to make the diagnosis effective, we need finite approximations. A first solution was suggested in <ref> [17] </ref> for the diagnosis w.r.t. computed answers, by introducing partial specifications. A more elegant solution can be found by handling approximation via abstract interpretation techniques, i.e., widening [25] or Galois insertions.
Reference: 18. <author> M. Comini, G. Levi, and G. Vitiello. </author> <title> Efficient detection of incompleteness errors in the abstract debugging of logic programs. </title> <editor> In M. Ducasse, editor, </editor> <booktitle> Proc. 2nd International Workshop on Automated and Algorithmic Debugging, </booktitle> <address> AADEBUG'95, </address> <year> 1995. </year>
Reference: 19. <author> M. Comini and M. C. Meo. </author> <title> Compositionality properties of SLD-derivations. </title> <note> Submitted for publication, </note> <year> 1996. </year>
Reference-contexts: The same properties allow us to naturally relate bottom-up and top-down diagnosis algorithms. The theory of abstract diagnosis is built on an algebraic semantic framework for positive logic programs [13,14], based on the formalization of observables as Galois insertions. The collecting semantics <ref> [19] </ref> is a "traces semantics", defined in terms of SLD -derivations. In this paper we are mainly concerned with observables which are abstractions of the computed answers semantics.
Reference: 20. <author> A. Cortesi, G. File, R. Giacobazzi, C. Palamidessi, and F. Ranzato. </author> <title> Complementation in abstract interpretation. </title> <editor> In A. Mycroft, editor, </editor> <booktitle> Proceedings of the 2nd International Static Analysis Symposium (SAS '95), volume 983 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-117. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference: 21. <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional Formula as Abstract Domain for Groundness Analysis. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 322-327. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference: 22. <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference: 23. <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference: 24. <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation and Applications to Logic Pro--grams. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):103-179, 1992. 
Reference: 25. <author> P. Cousot and R. Cousot. </author> <title> Comparing the Galois Connection and Widening/Narrowing Approaches to Abstract Interpretation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proc. of PLILP'92, volume 631 of Lecture Notes in Computer Science, </booktitle> <pages> pages 269-295. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In order to make the diagnosis effective, we need finite approximations. A first solution was suggested in [17] for the diagnosis w.r.t. computed answers, by introducing partial specifications. A more elegant solution can be found by handling approximation via abstract interpretation techniques, i.e., widening <ref> [25] </ref> or Galois insertions. The latter is exactly what we obtain by using semi-denota-tional observables, which are usually defined by finite (or noetherian) abstract domains. On one side, we make the diagnosis effective. On the other side, as one might expect, the results are weaker, just because of approximation.
Reference: 26. <author> P. Cousot and R. Cousot. </author> <title> Higher-order abstract interpretation (and application to comportment analysis generalizing strictness, termination, projection and per analysis of functional languages). </title> <booktitle> In Proceedings of the IEEE International Conference on Computer Languages (ICCL '94), </booktitle> <pages> pages 95-112. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference: 27. <author> E. Eder. </author> <title> Properties of substitutions and unifications. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 1 </volume> <pages> 31-46, </pages> <year> 1985. </year>
Reference-contexts: If a set E is solvable then it has an equivalent solved form which is unique up to renaming. There exists an algorithm [37] which transforms any solvable equation set into an equivalent solved form equation set. The lattice structure on idempotent substitutions <ref> [27] </ref> is isomorphic to the lattice structure on equations introduced in [37]. Therefore we can indifferently use idempotent mgus or equations.
Reference: 28. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference: 29. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Reconstruction of the Operational Semantics of Logic Programs. </title> <journal> Information and Computation, </journal> <volume> 102(1) </volume> <pages> 86-113, </pages> <year> 1993. </year>
Reference: 30. <author> G. Ferrand. </author> <title> Error Diagnosis in Logic Programming, an Adaptation of E. Y. Shapiro's Method. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 177-198, </pages> <year> 1987. </year>
Reference-contexts: Declarative diagnosis is concerned with model-theoretic properties. The related declarative semantics is the least Herbrand model in [45], the set of program completion models in [38] and the set of atomic logical consequences in <ref> [30] </ref>. Abstract diagnosis [16,18] is a generalization of declarative diagnosis, where we consider operational properties, i.e., observables, which are properties which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees. <p> The most natural observable for the abstract diagnosis of positive logic programs is computed answers, which leads to a more precise verification than the declarative diagnoses in [45] and <ref> [30] </ref>, which can be reconstructed in terms of the more abstract observables ground instances of computed answers and correct answers. Less abstract observables, such as call patterns, can be useful to verify the control and data flow between different procedures, as we usually do in interactive debugging. <p> Note that a totally correct program has no incorrectness and no incompleteness symptoms. Our incompleteness symptoms are related to the insufficiency symptoms in <ref> [30] </ref>, which are defined by taking gfp P ff [[P ]] instead of F ff [[P ]] = lfp P ff [[P ]] as program semantics. The two definitions, even if different, turn out to be the same for the class of programs we are interested in (see Section 7). <p> If there are no uncovered elements, then P is complete w.r.t. I ff . The converse does not hold. Note that, if P [[P ]] has a unique fixpoint, lfp P [[P ]] = gfp P [[P ]]. Hence our incompleteness symptoms are exactly the insufficiency symptoms in <ref> [30] </ref>. The requirement on P ff [[P ]] seems to be very strong. However, this property holds for a large class of programs, i.e., for acceptable programs as defined in [6].
Reference: 31. <author> G. Ferrand. </author> <title> The notions of symptom and error in declarative diagnosis of logic programs. </title> <editor> In P. A. Fritzson, editor, </editor> <booktitle> Automated and Algorithmic Debugging, Proc. AADEBUG '93, volume 749 of Lecture Notes in Computer Science, </booktitle> <pages> pages 40-57. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Ferrand's choice is motivated by the fact that gfp P ff [[P ]] is related to finite failures. The approach of using two different semantics for reasoning about incorrectness and incompleteness has been pursued in <ref> [31] </ref>, leading to an elegant uniform (yet non-effective) characterization of correctness and completeness. It is straightforward to realize that an A -element may sometimes be an incorrectness or incompleteness symptom, just because of another symptom. Example 13.
Reference: 32. <author> G. File, R. Giacobazzi, and F. Ranzato. </author> <title> A unifying view on abstract domain design. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(2) </volume> <pages> 333-336, </pages> <year> 1996. </year>
Reference-contexts: However, they are different ad-hoc definitions, not explicitly related to the concrete semantics. Abstract diagnosis can exploit several general-purpose techniques developed by abstract interpretation theory to improve the precision of the property domains (domain composition [23,24] and domain refinement operators <ref> [32] </ref>). Examples of useful operators are the reduced product [23,20,11,10], the disjunctive completion [26,33,36] and the functional dependencies [23,35]. For example, directional types [1] can systematically be derived from atomic types, by refining the domain by means of a functional dependencies operator.
Reference: 33. <author> G. File and F. Ranzato. </author> <title> Improving abstract interpretations by systematic lifting to the powerset. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 International Logic Programming Symposium (ILPS '94), </booktitle> <pages> pages 655-669. </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference: 34. <author> R. Giacobazzi, S.K. Debray, and G. Levi. </author> <title> Generalized Semantics and Abstract Interpretation for Constraint Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 25(3) </volume> <pages> 191-247, </pages> <year> 1995. </year>
Reference: 35. <author> R. Giacobazzi and F. Ranzato. </author> <title> Functional dependencies and Moore-set completions of abstract interpretations and semantics. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proceedings of the 1995 Interantional Symposium on Logic Programming (ILPS '95), </booktitle> <pages> pages 321-335. </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference: 36. <author> R. Giacobazzi and F. Ranzato. </author> <title> Compositional optimization of disjunctive abstract interpretations. </title> <editor> In H.R. Nielson, editor, </editor> <booktitle> Proc. of the 1996 European Symposium on Programming, volume 1058 of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-155. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: 37. <author> J. L. Lassez, M. J. Maher, and K. Marriott. </author> <title> Unification Revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: In the following, given a set of solved form equation sets E, by elim (E) we denote S E2E elim (E). If a set E is solvable then it has an equivalent solved form which is unique up to renaming. There exists an algorithm <ref> [37] </ref> which transforms any solvable equation set into an equivalent solved form equation set. The lattice structure on idempotent substitutions [27] is isomorphic to the lattice structure on equations introduced in [37]. Therefore we can indifferently use idempotent mgus or equations. <p> There exists an algorithm <ref> [37] </ref> which transforms any solvable equation set into an equivalent solved form equation set. The lattice structure on idempotent substitutions [27] is isomorphic to the lattice structure on equations introduced in [37]. Therefore we can indifferently use idempotent mgus or equations.
Reference: 38. <author> J. W. Lloyd. </author> <title> Declarative error diagnosis. </title> <journal> New Generation Computing, </journal> <volume> 5(2) </volume> <pages> 133-154, </pages> <year> 1987. </year>
Reference-contexts: I, and to determine the "errors" and the program components which are sources of errors, whenever S [[P ]] 6= I. Declarative diagnosis is concerned with model-theoretic properties. The related declarative semantics is the least Herbrand model in [45], the set of program completion models in <ref> [38] </ref> and the set of atomic logical consequences in [30]. Abstract diagnosis [16,18] is a generalization of declarative diagnosis, where we consider operational properties, i.e., observables, which are properties which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees.
Reference: 39. <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: The relation between the two approaches is discussed in Section 10. 2 Preliminaries In the following sections, we assume familiarity with the standard notions of logic programming as introduced in [2] and <ref> [39] </ref>. 2.1 Logic programming Throughout the paper we assume programs and goals being defined on a first order language given by a signature consisting of a finite set F of function symbols, a finite set of predicate symbols and a denumerable set V of variable symbols.
Reference: 40. <author> E. Marchiori. </author> <title> Prime factorizations of abstract domains using first order logic. </title> <editor> In M. Hanus and M. Rodriguez-Artalejo, editors, </editor> <booktitle> Algebraic and Logic Program ming, volume 1139 of Lecture Notes in Computer Science, </booktitle> <pages> pages 209-223. </pages> <publisher> Springer--Verlag, </publisher> <year> 1996. </year>
Reference-contexts: A similar set of results to be used for the systematic design of property domains does not exist yet for verification techniques, even if some of the results in <ref> [40] </ref> are strongly related to this problem.
Reference: 41. <author> K. Marriott and H. Stndergaard. </author> <title> Precise and efficient groundness analysis for logic programs. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):181-196, </volume> <year> 1993. </year>
Reference: 42. <author> L. Naish. </author> <title> Declarative diagnosis of missing answers. </title> <journal> New Generation Computing, </journal> <volume> 10 </volume> <pages> 255-285, </pages> <year> 1991. </year>
Reference-contexts: Rather we are concerned with the problem of specifying I ff by means of an oracle, as first suggested in [45]. The oracle is usually implemented by querying the user. Several oracles have been used in declarative debugging (see the discussion in <ref> [42] </ref>). We will use one oracle only, directly related to the property we are concerned with, namely abstractions of computed answers. Definition 29.
Reference: 43. <author> L. M. Pereira. </author> <title> Rational debugging in logic programming. </title> <editor> In E. Y. Shapiro, editor, </editor> <booktitle> Proceedings of the 3rd International Conference on Logic Programming, volume 225 of Lecture Notes in Computer Science, </booktitle> <pages> pages 203-210. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference: 44. <author> T. Sato and H. Tamaki. </author> <title> Enumeration of Success Patterns in Logic Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 227-240, </pages> <year> 1984. </year>
Reference-contexts: Note that there exist observables, which are interesting for program analysis and which are not even semi-denotational (for example, the domain depth (l) <ref> [44] </ref> and the domain of groundness dependencies DEF [7] are not condensing). 5 Denotational observables First of all recall that any observable is precise w.r.t. the union operation since for any Galois insertion, ff ( f E i g i2I ) = ff ( f (fl ffi ff)E i g i2I
Reference: 45. <author> E. Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <booktitle> In Proc. Ninth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 412-531. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: I, and to determine the "errors" and the program components which are sources of errors, whenever S [[P ]] 6= I. Declarative diagnosis is concerned with model-theoretic properties. The related declarative semantics is the least Herbrand model in <ref> [45] </ref>, the set of program completion models in [38] and the set of atomic logical consequences in [30]. <p> Other examples come from program analysis, e.g. depth (l)-answers (i.e., answers containing terms whose depth is l), types, modes and ground dependencies. The most natural observable for the abstract diagnosis of positive logic programs is computed answers, which leads to a more precise verification than the declarative diagnoses in <ref> [45] </ref> and [30], which can be reconstructed in terms of the more abstract observables ground instances of computed answers and correct answers. Less abstract observables, such as call patterns, can be useful to verify the control and data flow between different procedures, as we usually do in interactive debugging. <p> We are not concerned, for the time being, with the problem of effectivity (i.e., finiteness of I ff ). Rather we are concerned with the problem of specifying I ff by means of an oracle, as first suggested in <ref> [45] </ref>. The oracle is usually implemented by querying the user. Several oracles have been used in declarative debugging (see the discussion in [42]). We will use one oracle only, directly related to the property we are concerned with, namely abstractions of computed answers. Definition 29. <p> Definition 29. The abstract oracle A ff is A ff = p (x): ~ [f D j D is an abstract answer of p (x) according to the intended semantics g. Once we have the oracle, we can define the abstract oracle simulation, following <ref> [45] </ref>. The oracle simulation allows us to express in a compact way new top-down diagnosis conditions. The oracle simulation performs one step of abstract goal rewriting by using the program clauses and then gets the abstract answers for the resulting abstract goal from the oracle. Definition 30.
Reference: 46. <author> L. Sterling and E. Y. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Acceptable programs are the left-terminating programs, i.e., those programs for which the SLD -derivations of ground goals (via the leftmost selection rule) are finite. Most interesting programs are acceptable (all the pure PROLOG programs in <ref> [46] </ref> are reported in [6] to be acceptable). The same property holds for the wrong versions of acceptable programs provided that the errors do not affect the left-termination property. One relevant technical property of acceptable programs is that the ground immediate consequences operator has a unique fix-point [6].
Reference: 47. <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: j p (x) : E; A 1 ; : : : ; A n is a renamed clause of P , E = ( (f E g) " i=1 I (A i ))j x g. 5.2 The least Herbrand model We show how to obtain the least Herbrand model semantics <ref> [47] </ref>. The least Her-brand model gives the ground correct answers. This corresponds to the solutions of the corresponding equations sets. Any E 2 E is grounding if and only if, for any E 2 E, var (E) = elim (E).
References-found: 47

