URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1070/CS-TR-92-1070.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1070/
Root-URL: http://www.cs.wisc.edu
Email: fsrinivas, careyg@cs.wisc.edu  
Title: Compensation-Based On-Line Query Processing  
Author: V. Srinivasan Michael J. Carey 
Address: Madison, WI 53706  
Affiliation: Department of Computer Sciences University of Wisconsin  
Abstract: It is well known that using conventional concurrency control techniques for obtaining seri-alizable answers to long-running queries leads to an unacceptable drop in system performance. As a result, most current DBMSs execute such queries under a reduced degree of consistency, thus providing non-serializable answers. In this paper, we present a new and highly concurrent approach for processing large decision support queries in relational databases. In this new approach, called compensation-based query processing, concurrent updates to any data participating in a query are communicated to the query's on-line query processor, which then compensates for these updates so that the final answer reflects changes caused by the updates. Very high concurrency is achieved by locking data only briefly, at the tuple-level, while still delivering transaction-consistent answers to queries. Compensation-based query processing can co-exist with conventional query processing, and a cost model similar to that used for optimizing conventional queries can be used for optimizing queries in the new model as well. Finally, it appears that compensation-based query processing can be implemented efficiently in a DBMS.
Abstract-found: 1
Intro-found: 1
Reference: [Agra89] <author> Agrawal, D. and Sengupta, S., </author> <title> "Modular Synchronization in Multiversion Databases: Version Control and Concurrency Control", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: This is quite similar to the way that queries execute in the compensation-based model in order to generate transaction-consistent answers. Concurrency control algorithms based on transient versioning (e.g., <ref> [Chan82, Agra89, Bobe92] </ref>) are also related to compensation-based query processing. In transient versioning algorithms, prior versions of data are retained to allow queries to see slightly outdated but transaction-consistent database snapshots.
Reference: [Blak86a] <author> Blakeley, J., Larson, P. and Tompa, F., </author> <title> "Efficiently Updating Materialized Views", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: In the compensation phase, one would then try to get a transaction-consistent answer by applying the update-list to the intermediate answer. This third strategy has characteristics similar to keeping materialized views up-to-date when the base relations are updated <ref> [Blak86a, Blak86b] </ref>; this is a hard problem for arbitrary join queries, even when an initial transaction-consistent copy of the view exists, so we will not consider the third strategy further. 5 This sorting strategy is chosen because of the condition in the ORDER BY-clause. 19 5.1 Optimizing Compensation-Based Queries While executing
Reference: [Blak86b] <author> Blakeley, J., Coburn, N. and Larson, P., </author> <title> "Updating Derived Relations: Detecting Irrelevant and Autonomously Computable Updates", </title> <booktitle> Proc. 12th VLDB Conf., </booktitle> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: In the compensation phase, one would then try to get a transaction-consistent answer by applying the update-list to the intermediate answer. This third strategy has characteristics similar to keeping materialized views up-to-date when the base relations are updated <ref> [Blak86a, Blak86b] </ref>; this is a hard problem for arbitrary join queries, even when an initial transaction-consistent copy of the view exists, so we will not consider the third strategy further. 5 This sorting strategy is chosen because of the condition in the ORDER BY-clause. 19 5.1 Optimizing Compensation-Based Queries While executing
Reference: [Bobe92] <author> Bober, P. and Carey, M., </author> <title> "On Mixing Queries and Transactions Via Multiversion Locking", </title> <booktitle> Proc. 8th IEEE Data Eng. Conf., </booktitle> <month> Feb. </month> <year> 1992, </year> <note> to appear. </note>
Reference-contexts: This is quite similar to the way that queries execute in the compensation-based model in order to generate transaction-consistent answers. Concurrency control algorithms based on transient versioning (e.g., <ref> [Chan82, Agra89, Bobe92] </ref>) are also related to compensation-based query processing. In transient versioning algorithms, prior versions of data are retained to allow queries to see slightly outdated but transaction-consistent database snapshots.
Reference: [Chan82] <author> Chan, A. et al, </author> <title> "The Implementation of an Integrated Concurrency Control and Recovery Scheme", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1982. </year>
Reference-contexts: This is quite similar to the way that queries execute in the compensation-based model in order to generate transaction-consistent answers. Concurrency control algorithms based on transient versioning (e.g., <ref> [Chan82, Agra89, Bobe92] </ref>) are also related to compensation-based query processing. In transient versioning algorithms, prior versions of data are retained to allow queries to see slightly outdated but transaction-consistent database snapshots.
Reference: [Dewi90] <author> DeWitt, D. J. and Gray, J., </author> <title> "Parallel Database Systems: The Future of Database Processing or a Passing Fad?", </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(4), </volume> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Examples of such 24fi7 systems include database management for multinational companies with a global reach, hospital management systems, a round-the-clock shopping service, etc. In order to service such applications, next generation databases will be required to keep their data on-line all of the time <ref> [Dewi90, Silb90] </ref>.
Reference: [Epst79] <author> Epstein, R., </author> <title> "Techniques For Processing of Aggregates in Relational Database Systems", </title> <note> Memorandum No. </note> <institution> UCB/ERL M79/8, Electronics Research Laboratory, U.C. Berkeley, </institution> <year> 1979. </year>
Reference-contexts: Since the compensation-based model is particularly well suited to executing aggregate queries efficiently, we consider several examples of aggregate queries first. Techniques for processing aggregate queries in relational database systems have been discussed earlier <ref> [Epst79] </ref>; our work employs some of those techniques as well as extensions needed in the context of our compensation-based model. Aggregate queries come in two types, scalar aggregates and aggregate functions. Scalar aggregates compute a single scalar value, like the aggregate AVG in query Q1 of Section 1. <p> The following steps are needed for processing a general scalar aggregate <ref> [Epst79] </ref>: 1. Allocate two variables, one for storing the aggregate result and another for storing a count. Initialize both to zero. 2. For each tuple that satisfies the qualification, update the aggregate result and increment the counter. <p> This query computes the average of the salary values over all tuples of the EMPLOYEE relation. In each approach, the scan performed by the query can be either a relation scan or an index-only scan <ref> [Epst79] </ref>. One way to execute query Q1 is similar to the execution of the consistent-copy query of Figure 2, with minor differences. The query process first scans the EMPLOYEE relation collecting [SALARY, tuple-id] pairs. <p> SQL has a GROUP BY-clause for this 13 purpose. Aggregate functions require the maintenance of an aggregate value, a count field, and the actual BY-list attribute value for each different value of the BY-list attribute. There are two basic algorithms that are commonly used to compute aggregate functions <ref> [Epst79] </ref>: 1. The first technique scans the base relation, maintaining a temporary relation which has attributes for the count field, the aggregate value, and the BY-list attribute value. <p> Furthermore, 16 given that the leaf page of the index stores [SALARY, rid] pairs, the relation does not have to be accessed at all; an index-only scan is sufficient <ref> [Epst79] </ref>. (Note that the rid will be used to lock the tuple while its SALARY attribute is being read from the index in this case.) Concurrent update transactions can either be required to apply the filter as well, thereby restricting their appends to the update-list, or they can simply append all
Reference: [Gray79] <author> Gray, J., </author> <title> "Notes On Database Operating Systems", in Operating Systems: An Advanced Course, </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Since each of these ways of executing Q1 involves significant concurrency restrictions for other transactions, DBMSs currently tend to execute queries like Q1 under a weakened degree of consistency. For example, IBM's System R and DB2 offer the concept of cursor stability <ref> [Gray79] </ref>, where a query like Q1 looks only at committed updates of other transactions, but holds locks on tuples only while their values are actually being read. <p> During 1 It should be noted that this scan does not necessarily need to be a simple relation-scan; other efficient access 7 the scan, the query process locks a tuple in Share mode only while the tuple is being read, using the same mechanism that is used in cursor stability <ref> [Gray79] </ref>. For each tuple it encounters in the scan, the query process extracts the data that it needs for query execution. <p> In our discussions thus far, we have assumed that the query process executes under cursor stability (also called level 2 consistency) <ref> [Gray79] </ref>, in which case it reads only committed data from other transactions. This form of execution is sufficient for producing transaction-consistent answers, but is not strictly necessary. <p> Compared to that work, the method described here is more general and handles arbitrarily complex queries. The process of scanning the base relations in the compensation-based method is also akin to taking a fuzzy dump of the relations <ref> [Gray79] </ref>. After the dump is taken, the log generated during the fuzzy dump is merged with the fuzzy dump to produce a sharp dump. This is quite similar to the way that queries execute in the compensation-based model in order to generate transaction-consistent answers.
Reference: [Moha90] <author> Mohan, C., "ARIES/KVL: </author> <title> A Key-Value Locking Method for Concurrency Control of Multi-action Transactions Operating on B-tree Indexes", </title> <booktitle> Proc. 16th VLDB Conf., </booktitle> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Such selective locking of attributes may be possible, for example, in a system that 2 uses key-value locking of the type described in <ref> [Moha90] </ref> if an index exists on the SALARY attribute. Still, locking the SALARY attribute would rule out inserts and deletes of new EMPLOYEE tuples, and would block updates to the SALARY attribute of the existing tuples.
Reference: [Moha91] <author> Mohan, C. and Narang, I., </author> <title> "Algorithms for Creating Indexes for Very Large Tables Without Quiescing Updates", </title> <journal> IBM Research Report, </journal> <volume> No. RJ 8016, </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: Since database management systems currently perform many of these operations off-line, there has been quite a bit of research in the area of on-line utilities, much of which is relatively recent. On-line index construction is discussed in <ref> [Moha91, Srin91, Srin92b] </ref>, concurrent database reorganization in [Salz91, Sock78, Sock79, Sode81a, Sode81b], and on-line checkpointing is discussed in [Rose78, Pu85, Pu88]. <p> In order to find an on-line way to execute decision support queries like Q1, we turn to recent work on on-line index construction algorithms <ref> [Moha91, Srin91] </ref>. <p> Section 8 compares and contrasts our work with other related work. Finally, in Section 9 we present our conclusions and our plans for future work. 2 On-Line Index Construction Earlier work on on-line index construction <ref> [Moha91, Srin91] </ref> has led to the design of a number of alternative algorithms. <p> A similar optimization has been suggested for on-line index construction <ref> [Moha91] </ref> as well as for on-line checkpointing of databases [Pu85]. If updaters follow the approach just outlined, then the query process no longer has to store individual [SALARY, tuple-id] pairs; instead it can directly compute a count and a running average value in the scan phase itself. <p> until the time pre-specified in the query, the query process can also perform some or all of any pre-processing that it needs to do on the scanned data. 8 Related Work The work that is most closely related to compensation-based query processing is the work on on-line index construction algorithms <ref> [Srin91, Moha91, Srini92b] </ref>. In fact, it was our work on techniques for incrementally building an index that led us to discover the techniques described in this paper. Compared to that work, the method described here is more general and handles arbitrarily complex queries.
Reference: [Omie89] <author> E. Omiecinski, </author> <title> "Concurrent File Conversion Between B+ Tree and Linear Hash Files", </title> <journal> Info. Syst., </journal> <volume> 14(5), </volume> <year> 1989. </year>
Reference: [Omie92] <author> E. Omiecinski, L. Lee, and P. Scheuermann, </author> <title> "Performance Analysis of a Concurrent File Reorganization Algorithm for Record Clustering", </title> <booktitle> Proc. 8th IEEE Data Eng. Conf., </booktitle> <month> Feb. </month> <year> 1992, </year> <note> to appear. </note>
Reference: [Pu85] <author> Pu, C., </author> <title> "On-the-Fly, Incremental, Consistent Reading of Entire Databases", </title> <booktitle> Proc. 11th VLDB Conf., </booktitle> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: On-line index construction is discussed in [Moha91, Srin91, Srin92b], concurrent database reorganization in [Salz91, Sock78, Sock79, Sode81a, Sode81b], and on-line checkpointing is discussed in <ref> [Rose78, Pu85, Pu88] </ref>. Since it is inevitable that commercial database systems have to implement on-line utilities in the near future, primitives are bound to appear in these systems to enable such on-line operation. <p> A similar optimization has been suggested for on-line index construction [Moha91] as well as for on-line checkpointing of databases <ref> [Pu85] </ref>. If updaters follow the approach just outlined, then the query process no longer has to store individual [SALARY, tuple-id] pairs; instead it can directly compute a count and a running average value in the scan phase itself.
Reference: [Pu88] <author> Pu, C., Hong, C. H. and Wha, J.M., </author> <title> "Performance Evaluation of Global Reading of Entire Databases", </title> <booktitle> Proc. Int'l. Symp. on Databases in Parallel and Dist. Sys., </booktitle> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: On-line index construction is discussed in [Moha91, Srin91, Srin92b], concurrent database reorganization in [Salz91, Sock78, Sock79, Sode81a, Sode81b], and on-line checkpointing is discussed in <ref> [Rose78, Pu85, Pu88] </ref>. Since it is inevitable that commercial database systems have to implement on-line utilities in the near future, primitives are bound to appear in these systems to enable such on-line operation.
Reference: [Rose78] <author> D. Rosenkrantz, </author> <title> "Dynamic Database Dumping", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> May </month> <year> 1978. </year>
Reference-contexts: On-line index construction is discussed in [Moha91, Srin91, Srin92b], concurrent database reorganization in [Salz91, Sock78, Sock79, Sode81a, Sode81b], and on-line checkpointing is discussed in <ref> [Rose78, Pu85, Pu88] </ref>. Since it is inevitable that commercial database systems have to implement on-line utilities in the near future, primitives are bound to appear in these systems to enable such on-line operation.
Reference: [Salz91] <author> B. Salzberg and A. Dimock, </author> <title> "Record Level Concurrent Reorganization", </title> <type> Tech. Rep. </type> <institution> NU-CCS-91-6, College of Computer Science, Northeastern U., </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Since database management systems currently perform many of these operations off-line, there has been quite a bit of research in the area of on-line utilities, much of which is relatively recent. On-line index construction is discussed in [Moha91, Srin91, Srin92b], concurrent database reorganization in <ref> [Salz91, Sock78, Sock79, Sode81a, Sode81b] </ref>, and on-line checkpointing is discussed in [Rose78, Pu85, Pu88]. Since it is inevitable that commercial database systems have to implement on-line utilities in the near future, primitives are bound to appear in these systems to enable such on-line operation.
Reference: [Seli79] <author> Selinger, P., et al, </author> <title> "Access Path Selection in a Relational Database Management System", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1979. </year> <month> 29 </month>
Reference-contexts: For ease paths may be used as well to perform the scan. For example, if a suitable index exists that matches a predicate in the query <ref> [Seli79] </ref>, an index scan can be used to efficiently retrieve only those tuples from the relation that actually satisfy the predicate. 8 of discussion, we assume that transactions collect all of their updates and perform the associated special actions in a critical section at commit time. <p> This filter only lets through those tuples that satisfy the condition (s) specified in the WHERE-clause. Of course, further optimizations can be applied in the initial scan if an index that matches a predicate <ref> [Seli79] </ref> exists on an attribute. For example, an index on the SALARY attribute matches the predicate (SALARY &gt; 40,000), and in the presence of such a predicate in the WHERE-clause, an index on SALARY can be used to scan the data efficiently.
Reference: [Shap86] <author> Shapiro, L., </author> <title> "Join Processing in Database Systems with Large Main Memories", </title> <journal> ACM Trans. on Database Sys., </journal> <month> 11(3) Sept. </month> <year> 1986. </year>
Reference-contexts: A proof of this assertion follows from 2 A record modify is deposited in the update-list as a delete followed by an insert. 3 Typically, one can optimize this strategy by concurrently merging several runs in parallel instead of completely sorting down to two runs before merging <ref> [Shap86] </ref>. We assume that this optimization will be done in any implementation, but retain the simpler description in our discussion for clarity. <p> As we will see next, we can do even better in case of sort-merge and hash joins, where the cost for compensation-based execution more closely approaches that of conventional execution. 5.3 Sort-Merge Join In order to execute a sort-merge join, we extend the efficient strategy described in <ref> [Shap86] </ref>. The first step is to scan R and S, creating sorted runs of size 2 fi M where M is the size of memory in pages. <p> model is almost as efficient as the basic strategy, as the main extra work required is the creation of sorted runs from the (presumably small) update-lists. 5.4 Hash Join There are three common types of hash join: the simple hash join, the GRACE hash join, and the hybrid hash join <ref> [Shap86] </ref>. Here we demonstrate how to adapt the GRACE hash join algorithm to the compensation-based model. The GRACE algorithm first scans R and partitions it into roughly equal subsets such that the hash table for each partition of R will fit in memory.
Reference: [Silb90] <author> Silberschatz, A., Stonebraker, M. and Ullman, J. D., </author> <title> "Database Systems: Achievements and Opportunities", </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(4), </volume> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Examples of such 24fi7 systems include database management for multinational companies with a global reach, hospital management systems, a round-the-clock shopping service, etc. In order to service such applications, next generation databases will be required to keep their data on-line all of the time <ref> [Dewi90, Silb90] </ref>.
Reference: [Sock78] <author> G. H. Sockut, </author> <title> "A Performance Model for Computer Data-Base Reorganization Performed Concurrently with Usage", </title> <journal> Operations Research, </journal> <volume> Sept.-Oct. </volume> <year> 1978. </year>
Reference-contexts: Since database management systems currently perform many of these operations off-line, there has been quite a bit of research in the area of on-line utilities, much of which is relatively recent. On-line index construction is discussed in [Moha91, Srin91, Srin92b], concurrent database reorganization in <ref> [Salz91, Sock78, Sock79, Sode81a, Sode81b] </ref>, and on-line checkpointing is discussed in [Rose78, Pu85, Pu88]. Since it is inevitable that commercial database systems have to implement on-line utilities in the near future, primitives are bound to appear in these systems to enable such on-line operation.
Reference: [Sock79] <author> G. H. Sockut and R. P. Goldberg, </author> <title> "Database Reorganization Principles and Practice", </title> <journal> ACM Comp. Surveys, </journal> <volume> 11(4), </volume> <month> Dec. </month> <year> 1979. </year>
Reference-contexts: Since database management systems currently perform many of these operations off-line, there has been quite a bit of research in the area of on-line utilities, much of which is relatively recent. On-line index construction is discussed in [Moha91, Srin91, Srin92b], concurrent database reorganization in <ref> [Salz91, Sock78, Sock79, Sode81a, Sode81b] </ref>, and on-line checkpointing is discussed in [Rose78, Pu85, Pu88]. Since it is inevitable that commercial database systems have to implement on-line utilities in the near future, primitives are bound to appear in these systems to enable such on-line operation.
Reference: [Sode81a] <author> L. Soderlund, </author> <title> "Concurrent Database Reorganization Assessment of a Powerful Technique through Modeling", </title> <booktitle> Proc. 7th VLDB Conf., </booktitle> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: Since database management systems currently perform many of these operations off-line, there has been quite a bit of research in the area of on-line utilities, much of which is relatively recent. On-line index construction is discussed in [Moha91, Srin91, Srin92b], concurrent database reorganization in <ref> [Salz91, Sock78, Sock79, Sode81a, Sode81b] </ref>, and on-line checkpointing is discussed in [Rose78, Pu85, Pu88]. Since it is inevitable that commercial database systems have to implement on-line utilities in the near future, primitives are bound to appear in these systems to enable such on-line operation.
Reference: [Sode81b] <author> L. Soderlund, </author> <title> "Evaluation of Concurrent Physical Database Reorganization through Simulation Modeling", </title> <booktitle> Proc. ACM SIGMETRICS Conf., </booktitle> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: Since database management systems currently perform many of these operations off-line, there has been quite a bit of research in the area of on-line utilities, much of which is relatively recent. On-line index construction is discussed in [Moha91, Srin91, Srin92b], concurrent database reorganization in <ref> [Salz91, Sock78, Sock79, Sode81a, Sode81b] </ref>, and on-line checkpointing is discussed in [Rose78, Pu85, Pu88]. Since it is inevitable that commercial database systems have to implement on-line utilities in the near future, primitives are bound to appear in these systems to enable such on-line operation.
Reference: [Srin91] <author> V. Srinivasan and M. J. Carey, </author> " <title> On-line Index Construction Algorithms", </title> <booktitle> Proc. High Performance Transaction Systems Workshop, </booktitle> <address> Pacific Grove, CA, </address> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Since database management systems currently perform many of these operations off-line, there has been quite a bit of research in the area of on-line utilities, much of which is relatively recent. On-line index construction is discussed in <ref> [Moha91, Srin91, Srin92b] </ref>, concurrent database reorganization in [Salz91, Sock78, Sock79, Sode81a, Sode81b], and on-line checkpointing is discussed in [Rose78, Pu85, Pu88]. <p> In order to find an on-line way to execute decision support queries like Q1, we turn to recent work on on-line index construction algorithms <ref> [Moha91, Srin91] </ref>. <p> Section 8 compares and contrasts our work with other related work. Finally, in Section 9 we present our conclusions and our plans for future work. 2 On-Line Index Construction Earlier work on on-line index construction <ref> [Moha91, Srin91] </ref> has led to the design of a number of alternative algorithms. <p> This form of execution is sufficient for producing transaction-consistent answers, but is not strictly necessary. Note that the build process in the on-line index construction algorithms of <ref> [Srin91] </ref> performed dirty reads (level 1 consistency) and yet was still able to build a consistent index. A similar execution strategy can be used for the query process in compensation-based query processing. <p> until the time pre-specified in the query, the query process can also perform some or all of any pre-processing that it needs to do on the scanned data. 8 Related Work The work that is most closely related to compensation-based query processing is the work on on-line index construction algorithms <ref> [Srin91, Moha91, Srini92b] </ref>. In fact, it was our work on techniques for incrementally building an index that led us to discover the techniques described in this paper. Compared to that work, the method described here is more general and handles arbitrarily complex queries.
Reference: [Srin92a] <author> V. Srinivasan, </author> <title> "On-Line Processing in Large-Scale Transaction Systems", </title> <type> Ph.D. Thesis, </type> <institution> Comp. Sci. Dept., U. of Wisconsin, Madison, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Performing sorting and merging in the above manner ensures that the intermediate index at the end of the build phase reflects the relation's transaction-consistent state as of the end of the scan phase. See <ref> [Srin92a] </ref> for a proof of this assertion as well as a proof of correctness for the overall algorithm. 2.3 Generalization Compensation based query processing uses techniques from the on-line index construction algorithm to evaluate queries in a manner that makes them serializable with other transactions in the system. <p> Similarly, for all queries, it should be possible to execute the query itself during this final merge step. 9 the proof of a similar property of on-line index construction algorithms <ref> [Srin92a] </ref>. The above strategy for sorting and merging can be optimized in two ways. First, sorting the scanned entries can be eliminated entirely if the relation was scanned in the order of its tuple-ids. <p> In the compensation phase, 4 The proof of this assertion again follows from similar proofs for on-line index construction algorithms that are outlined in <ref> [Srin92a] </ref>. 12 the query process first performs an optimistic check to see if the correct maximum can be found without actually scanning the update-list. The query process executes the following three steps in order: 1.
Reference: [Srin92b] <author> V. Srinivasan and M. J. Carey, </author> <title> "Performance of On-Line Index Construction Algorithms", </title> <booktitle> Proc. EDBT Conf., </booktitle> <address> Vienna, Austria, </address> <month> March </month> <year> 1992, </year> <note> to appear. 30 </note>
Reference-contexts: Since database management systems currently perform many of these operations off-line, there has been quite a bit of research in the area of on-line utilities, much of which is relatively recent. On-line index construction is discussed in <ref> [Moha91, Srin91, Srin92b] </ref>, concurrent database reorganization in [Salz91, Sock78, Sock79, Sode81a, Sode81b], and on-line checkpointing is discussed in [Rose78, Pu85, Pu88]. <p> In a recent study of the performance of such algorithms, we found that on-line index construction can indeed be done in an efficient manner with minimal interference and little increased overhead for the concurrent transaction workload <ref> [Srin92b] </ref>. In this paper, we adapt and extend the techniques used for on-line index construction to process queries like Q1, as well as more complex queries, in a correct (i.e., serializable) and efficient manner. <p> Here we will describe only the best among them in terms of performance; see <ref> [Srin92b] </ref> for a performance study of the various algorithms. 4 2.1 Algorithm Overview In an on-line index construction algorithm, the index is built by a build process while updaters can concurrently modify the data on which the index is being built. <p> The trade-offs involved in increasing the work of the query process versus increasing the path length of updaters have to be studied in more detail. Such path length increases can have a significant impact on performance, as evidenced by the behavior of the index-based on-line index construction algorithms in <ref> [Srin92b] </ref>. Any implementation of compensation-based query processing therefore has to ensure a minimal increase to the path length of the concurrent transaction workload. 2.
References-found: 26

