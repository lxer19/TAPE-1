URL: file://ftp.cis.upenn.edu/pub/papers/kannan/reg_alloc.ps.Z
Refering-URL: http://www.cis.upenn.edu/~kannan/home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Register Allocation in Structured Programs  
Author: Sampath Kannan Todd Proebsting 
Note: Supported in part by NSF Grant CCR-91-08969  
Address: Philadelphia, PA 19104  Tucson, Arizona 85721  
Affiliation: Department of Computer and Information Science University of Pennsylvania  Department of Computer Science University of Arizona  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aho, J. Hopcroft, and J. Ullman. </author> <title> The Design and Analysis of Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachussetts, </address> <year> 1974. </year>
Reference: [2] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: The concept of liveness of a variable plays a part in the register allocation problem <ref> [2] </ref>. Informally, a variable is live in the range of instructions between its definition and its possible uses. More formally, in the graph-theoretic formulation the live range of a variable is a connected subgraph of the control-flow graph. <p> In particular it is often assumed that the control flow graph is a reducible flow graph <ref> [2] </ref>. Even with this restriction it turns out that arbitrary register allocation graphs can arise and the problem of register allocation does not in general have a solution with a good theoretical guarantee. 4 In this paper we focus our attention on structured programs.
Reference: [3] <author> P. Briggs, K. Cooper, and L. Torczon. </author> <title> Aggressive live range splitting. </title> <type> Technical report, </type> <institution> Rice University, </institution> <year> 1991. </year>
Reference-contexts: Spilling in a structured way will improve program performance, and should be simpler than previously proposed techniques for spilling live ranges <ref> [3, 5, 7, 8] </ref>. 6 Conclusions and Open Problems Series-parallel graphs seem like a good model for control-flow graphs in structured programs. However, one common program segment causes the resulting graph to be not series-parallel.
Reference: [4] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284, </pages> <year> 1989. </year>
Reference-contexts: Since loading and storing from registers is far faster than reading and writing from RAM a good register allocation strategy greatly speeds up the execution time of the compiled code. There is a standard graph-theoretic formulation of the register allocation problem <ref> [6, 4] </ref>. In this formulation, we first consider the control flow graph or simply flow graph of a program. <p> A more formal description of this heuristic and its properties is currently open. 5 Spill Heuristics and Implementation Experience Currently, we are experimenting with these heuristics in order to compare their efficiency and effectiveness against the general graph coloring techniques used in other register allocation systems <ref> [6, 4] </ref>. Our system proceeds by compiling a FORTRAN program into an arbitrary control-flow graph that is processed into a series-parallel decomposition. Heuristics are 13 employed to create series-parallel graphs from arbitrary flow graphs as needed.
Reference: [5] <author> David Callahan and Brian Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Spilling in a structured way will improve program performance, and should be simpler than previously proposed techniques for spilling live ranges <ref> [3, 5, 7, 8] </ref>. 6 Conclusions and Open Problems Series-parallel graphs seem like a good model for control-flow graphs in structured programs. However, one common program segment causes the resulting graph to be not series-parallel.
Reference: [6] <author> G. J. Chaitin. </author> <title> Register allocation & spilling via graph coloring. </title> <booktitle> In Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 98-101, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: Since loading and storing from registers is far faster than reading and writing from RAM a good register allocation strategy greatly speeds up the execution time of the compiled code. There is a standard graph-theoretic formulation of the register allocation problem <ref> [6, 4] </ref>. In this formulation, we first consider the control flow graph or simply flow graph of a program. <p> A more formal description of this heuristic and its properties is currently open. 5 Spill Heuristics and Implementation Experience Currently, we are experimenting with these heuristics in order to compare their efficiency and effectiveness against the general graph coloring techniques used in other register allocation systems <ref> [6, 4] </ref>. Our system proceeds by compiling a FORTRAN program into an arbitrary control-flow graph that is processed into a series-parallel decomposition. Heuristics are 13 employed to create series-parallel graphs from arbitrary flow graphs as needed.
Reference: [7] <author> Fred C. Chow and John L. Hennessy. </author> <title> The priority-based coloring approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <month> October </month> <year> 1990. </year> <month> 15 </month>
Reference-contexts: Spilling in a structured way will improve program performance, and should be simpler than previously proposed techniques for spilling live ranges <ref> [3, 5, 7, 8] </ref>. 6 Conclusions and Open Problems Series-parallel graphs seem like a good model for control-flow graphs in structured programs. However, one common program segment causes the resulting graph to be not series-parallel.
Reference: [8] <author> Rajiv Gupta, Mary Lou Soffa, and Tim Steele. </author> <title> Register allocation via clique separators. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> 264-274, </pages> <year> 1989. </year>
Reference-contexts: Spilling in a structured way will improve program performance, and should be simpler than previously proposed techniques for spilling live ranges <ref> [3, 5, 7, 8] </ref>. 6 Conclusions and Open Problems Series-parallel graphs seem like a good model for control-flow graphs in structured programs. However, one common program segment causes the resulting graph to be not series-parallel.
Reference: [9] <author> J. Hopcroft and R.M. Karp. </author> <title> O(n 5=2 ) Algorithm for Maximum Matching in Bipartite Graphs. </title> <journal> SIAM J. Comput., </journal> <volume> vol. 2, </volume> <pages> 225-231, </pages> <year> 1973. </year>
Reference: [10] <author> P. Kelsen and V. Ramachandran. </author> <title> On Finding Minimal Two-Connected Subgraphs. </title> <journal> Journal of Algorithms, </journal> <volume> vol. 18, </volume> <year> 1995. </year>
Reference-contexts: Unless it can be improved to solve the problem in a single min-cut computation this approach will probably be prohibitively expensive in practice. For finding k-articulation points for small k (such as k = 1 or 2) techniques based on ear decompositions of graphs (See for example <ref> [10] </ref>) yield linear time algorithms. If there are no 1 or 2-articulation points, we use various heuristics based on depth-first search.
Reference: [11] <author> J. Naor, M. Naor, and A. Schaffer. </author> <title> Fast Parallel Algorithms for Chordal Graphs. </title> <booktitle> 19th ACM STOC, </booktitle> <address> New York, 355-364, </address> <month> May 25-27, </month> <year> 1987. </year>
Reference-contexts: Such graphs have been considered in the literature and have been named bicliques <ref> [11] </ref>. The algorithm which achieves a factor of 3 approximation colors each vertex of a biclique with its own color. This may be far from optimal. In fact bicliques can be optimally colored efficiently.
Reference: [12] <author> C.H. Papadimitriou and M. Yannakakis. </author> <title> Optimization, Approximation, and Complexity Classes. </title> <booktitle> 20th ACM STOC, </booktitle> <address> Chicago 229-234, </address> <month> May 2-4, </month> <year> 1988. </year>
Reference-contexts: In fact, by using more than one vertex per clause and using the same types of edges, we can make this reduction an L-reduction <ref> [12] </ref> thereby showing that KSP is Max SNP-hard. Lemma 11 KSP is Max SNP-hard. 4.1 A Heuristic to Solve KSP: Since KSP is NP-hard we will explore a reasonable heuristic to solve it. Our heuristic is based on the idea of approximate articulation points.
Reference: [13] <author> Shlomit Pinter. </author> <title> Register Allocation with Instruction Scheduling: a New Approach. </title> <booktitle> Proc. </booktitle> <address> ACM-SIGPLAN-PLDI, Albuquerque, Albuquerque, 248-257, </address> <month> June </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: On the other hand if register allocation is performed before instruction scheduling this may constrain what instructions can be rescheduled. An integrated approach based on heuristics performing both tasks simultaneously has been proposed by Pinter <ref> [13] </ref>. Developing an algorithm for this task that provides performance guarantees is an important open problem. 7 Acknowledgements We would like to acknowledge several helpful discussions with Mudita Jain. Thanks are also due to Brady Montz for his implementation efforts.
References-found: 13

