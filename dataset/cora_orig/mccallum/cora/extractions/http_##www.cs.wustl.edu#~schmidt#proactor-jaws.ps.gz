URL: http://www.cs.wustl.edu/~schmidt/proactor-jaws.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: 
Email: fschmidt,jxh,irfang@cs.wustl.edu  
Title: Applying the Proactor Pattern to High-Performance Web Servers systems provide multiple concurrency mechanisms to develop
Author: Douglas C. Schmidt, James Hu, and Irfan Pyarali 
Note: Modern operating  This work was supported in part by Siemens Med and Siemens Corporate Research.  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper has been submitted to the 10th International Conference on Parallel and Distributed Computing and Systems, Las Vegas, Nevada, October 28-31, 1998. Abstract This paper provides two contributions to the study of high-performance Web servers. First, it examines how synchronous and asynchronous event dispatching mechanisms impact the design and performance of JAWS, which is our high-performance Web server framework. The results reveal significant performance improvements when a proactive concur-rency model is used to combine lightweight concurrency with asynchronous event dispatching. In general, however, the complexity of the proactive con-currency model makes it harder to program applications that can utilize asynchronous concurrency mechanisms effectively. Therefore, the second contribution of this paper describes how to reduce the software complexity of asynchronous concurrent applications by applying the Proactor pattern. This pattern describes the steps required to structure object-oriented applications that seamlessly combine concurrency with asynchronous event dispatching. The Proactor pattern simplifies concurrent programming and improves performance by allowing concurrent application to have multiple operations running simultaneously without requiring a large number of threads. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt and J. Hu, </author> <title> Developing Flexible and High-performance Web Servers with Frameworks and Patterns, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 30, </volume> <year> 1998. </year>
Reference-contexts: Thus, it is increasingly important to alleviate common Web server bottlenecks, such as inappropriate choice of concurrency and dispatching strategies, excessive filesystem access, and unnecessary data copying. Our research vehicle for exploring the performance impact of applying various Web server optimization techniques is JAWS <ref> [1] </ref>. JAWS is both an adaptive Web server and a development framework for Web servers that runs on multiple OS platforms including Win32, most versions of UNIX, and MVS Open Edition. <p> design; Section 3 discusses alternative event dispatching strategies and their performance impacts; Section 4 explores how to leverage the gains of asynchronous event dispatching through application of the Proactor pattern; and Section 5 presents concluding remarks. 2 JAWS Framework Overview patterns that comprise the JAWS Adaptive Web Server (JAWS) framework <ref> [1] </ref>. JAWS is designed to allow the customization of various Web server strategies in response to environmental factors. <p> By virtue of the Service Configurator pattern, the Tilde Expander can be unlinked and relinked dynamically into the server when a new user is added to the system. Our previous work on high-performance Web servers has focused on (1) the design of the JAWS framework <ref> [1] </ref> and (2) detailed measurements on the performance implications of alternative Web server optimization techniques [2]. In our earlier work, we discovered that a concurrent proactive Web server can achieve substantial performance gains [15].
Reference: [2] <author> J. Hu, S. Mungee, and D. C. Schmidt, </author> <title> Principles for Developing and Measuring High-performance Web Servers over ATM, </title> <booktitle> in Proceeedings of INFOCOM '98, </booktitle> <month> March/April </month> <year> 1998. </year>
Reference-contexts: JAWS is both an adaptive Web server and a development framework for Web servers that runs on multiple OS platforms including Win32, most versions of UNIX, and MVS Open Edition. Our experience <ref> [2] </ref> building Web servers on multiple OS platforms demonstrates that the effort required to optimize performance can be simplified significantly by leveraging OS-specific features. For example, an optimized file I/O system that automatically caches open files in main memory via mmap greatly reduces latency on Solaris. <p> Our previous work on high-performance Web servers has focused on (1) the design of the JAWS framework [1] and (2) detailed measurements on the performance implications of alternative Web server optimization techniques <ref> [2] </ref>. In our earlier work, we discovered that a concurrent proactive Web server can achieve substantial performance gains [15]. This paper focuses on a previously unexamined point in the high-performance Web server design space: the application of the Proactor pattern to simplify Web server software development, while maintaining high-performance.
Reference: [3] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This paper describes how the Proactor pattern can be applied to improve both the performance and the design of high-performance communication applications, such as Web servers. A pattern represents a recurring solution to a software de 1 velopment problem within a particular context <ref> [3] </ref>. Patterns identify the static and dynamic collaborations and interactions between software components. In general, applying patterns to complex object-oriented concurrent applications can significantly improve software quality, increase software maintainability, and support broad reuse of components and architectural designs [4]. <p> As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy. JAWS ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [3] </ref>. Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [3] or pre-determined at initialization-time. The Service Configurator pattern [7] is used to configure a particular concurrency strategy into a Web server at run-time. <p> JAWS ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [3] </ref>. Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [3] or pre-determined at initialization-time. The Service Configurator pattern [7] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [8]. <p> Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern [9], while reactive I/O is accomplished through the Reactor pattern [10]. These I/O strategies may utilize the Memento <ref> [3] </ref> and Asynchronous Completion Token [11] patterns to capture and externalize the state of a request so that it can be restored at a later time. Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. <p> Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. A Protocol Handler is parameterized by a concurrency strategy and an I/O strategy. These strategies are decoupled from the protocol handler using the Adapter pattern <ref> [3] </ref>. In JAWS, this component implements the parsing and handling of HTTP/1.0 request methods. The abstraction allows for other protocols (such as HTTP/1.1, DICOM, and SFP [12]) to be incorporated easily into JAWS. <p> Pipeline components can be linked dynamically at run-time using the Service Configurator pattern. Cached Virtual Filesystem: This component improves Web server performance by reducing the overhead of filesystem access. Various caching strategies, such as LRU, LFU, Hinted, and Structured, can be selected following the Strategy pattern <ref> [3] </ref>. This allows different caching strategies to be profiled and selected based on their performance. Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern. The cache for each Web server is instantiated using the Singleton pattern [3]. <p> and Structured, can be selected following the Strategy pattern <ref> [3] </ref>. This allows different caching strategies to be profiled and selected based on their performance. Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern. The cache for each Web server is instantiated using the Singleton pattern [3]. Tilde Expander: This component is another cache component that uses a perfect hash table [14] that maps abbreviated user login names (e.g., ~schmidt) to user home directories (e.g., /home/cs/faculty/schmidt).
Reference: [4] <author> D. C. Schmidt, </author> <title> Experience Using Design Patterns to Develop Reuse-able Object-Oriented Communication Software, </title> <journal> Communications of the ACM (Special Issue on Object-Oriented Experiences), </journal> <volume> vol. 38, </volume> <month> Oc-tober </month> <year> 1995. </year>
Reference-contexts: Patterns identify the static and dynamic collaborations and interactions between software components. In general, applying patterns to complex object-oriented concurrent applications can significantly improve software quality, increase software maintainability, and support broad reuse of components and architectural designs <ref> [4] </ref>. In particular, applying the Proactor pattern to JAWS simplifies asynchronous application development by structuring the demultiplexing of completion events and the dispatching of their corresponding completion routines.
Reference: [5] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Massachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: JAWS is structured as a framework of frameworks. The overall JAWS framework contains the following components and frameworks: an Event Dispatcher, Concurrency Strategy, I/O Strategy, Protocol Pipeline, Protocol Handlers, and Cached Virtual Filesystem. Each framework is structured as a set of collaborating objects implemented using components in ACE <ref> [5] </ref>. The collaborations among JAWS components and frameworks are guided by a family of patterns, which are listed along the borders in Figure 1. <p> concurrently; * Increased synchronization complexity: Threading can increase the complexity of synchronization mechanisms necessary to serialize access to a server's shared resources (such as cached files and logging of Web page hits); * Increased performance overhead: Threading can perform poorly due to context switching, synchronization, and data movement among CPUs <ref> [5] </ref>; * Non-portability: Threading may not be available on all OS platforms. Moreover, OS platforms differ widely in terms of their support for preemptive and non-preemptive threads. Consequently, it is hard to build multi-threaded servers that behave uniformly across OS platforms. <p> The operating system is the Asynchronous Operation Processor. Results of the operations are queued up at the I/O completion port (which plays the role of the Completion Dispatcher). ACE Proactor: The Adaptive Communications Environment (ACE) <ref> [5] </ref> implements a Proactor component that encapsulates I/O Completion Ports on Windows NT. The ACE Proactor abstraction provides an OO interface to the standard C APIs supported by Windows NT. The source code for this implementation can be acquired from the ACE website at www.cs.wustl.edu/~schmidt/ACE.html.
Reference: [6] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The passive establishment of connection events with Web clients follows the Acceptor pattern <ref> [6] </ref>. New incoming HTTP request events are serviced by a concurrency strategy. As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy.
Reference: [7] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration of Services, </title> <booktitle> in Proceedings of the 3 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern [3] or pre-determined at initialization-time. The Service Configurator pattern <ref> [7] </ref> is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [8]. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O.
Reference: [8] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The Service Configurator pattern [7] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern <ref> [8] </ref>. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern [9], while reactive I/O is accomplished through the Reactor pattern [10].
Reference: [9] <author> T. Harrison, I. Pyarali, D. C. Schmidt, and T. Jordan, </author> <title> Proactor An Object Behavioral Pattern for Dispatching Asynchronous Event Handlers, </title> <booktitle> in The 4 th Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-34), </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [8]. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern <ref> [9] </ref>, while reactive I/O is accomplished through the Reactor pattern [10]. These I/O strategies may utilize the Memento [3] and Asynchronous Completion Token [11] patterns to capture and externalize the state of a request so that it can be restored at a later time. <p> De tailed coverage of implementation and sample code are available in <ref> [9] </ref>. * An application will perform poorly or fail to meet its performance requirements when utilizing either the multi threaded approach or the reactive dispatching approach. 4.3 Structure and Participants The structure of the Proactor pattern is illustrated in Figure 11 using OMT notation.
Reference: [10] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern [9], while reactive I/O is accomplished through the Reactor pattern <ref> [10] </ref>. These I/O strategies may utilize the Memento [3] and Asynchronous Completion Token [11] patterns to capture and externalize the state of a request so that it can be restored at a later time. <p> When applications invoke Asynchronous Operations, the operations are performed without borrowing the application's thread of control. 4 Therefore, from the application's perspective, the operations are performed asynchronously. 4 In contrast, the reactive event dispatching model <ref> [10] </ref> steals the applica tion's thread of control to perform the operation synchronously. 8 When Asynchronous Operations complete, the Asynchronous Operation Processor delegates application notifications to a Completion Dispatcher. Asynchronous Operation Processor (the Operating System): * Asynchronous Operations are run to completion by the Asynchronous Operation Processor.
Reference: [11] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Asynchronous Completion Token: an Object Behavioral Pattern for Efficient Asynchronous Event Handling, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Proactor pattern [9], while reactive I/O is accomplished through the Reactor pattern [10]. These I/O strategies may utilize the Memento [3] and Asynchronous Completion Token <ref> [11] </ref> patterns to capture and externalize the state of a request so that it can be restored at a later time. Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications.
Reference: [12] <institution> Object Management Group, Control and Management of Audio/Video Streams: OMG RFP Submission, 1.2 ed., </institution> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: These strategies are decoupled from the protocol handler using the Adapter pattern [3]. In JAWS, this component implements the parsing and handling of HTTP/1.0 request methods. The abstraction allows for other protocols (such as HTTP/1.1, DICOM, and SFP <ref> [12] </ref>) to be incorporated easily into JAWS. To add a new 1 Due to space limitations it is not possible to describe all the patterns mentioned below in detail.
Reference: [13] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: Protocol Pipeline: This framework allows filter operations to be incorporated easily with the data being processed by the Protocol Handler. This integration is achieved by employing the Adapter pattern. Pipelines follow the Pipes and Filters pattern <ref> [13] </ref> for input processing. Pipeline components can be linked dynamically at run-time using the Service Configurator pattern. Cached Virtual Filesystem: This component improves Web server performance by reducing the overhead of filesystem access.
Reference: [14] <author> D. C. Schmidt, GPERF: </author> <title> A Perfect Hash Function Generator, </title> <booktitle> in Proceedings of the 2 nd C++ Conference, </booktitle> <address> (San Francisco, California), </address> <pages> pp. 87102, </pages> <publisher> USENIX, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern. The cache for each Web server is instantiated using the Singleton pattern [3]. Tilde Expander: This component is another cache component that uses a perfect hash table <ref> [14] </ref> that maps abbreviated user login names (e.g., ~schmidt) to user home directories (e.g., /home/cs/faculty/schmidt).
Reference: [15] <author> J. Hu, I. Pyarali, and D. C. Schmidt, </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks, </title> <booktitle> in Proceedings of the 2 nd Global Internet Conference, IEEE, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: In our earlier work, we discovered that a concurrent proactive Web server can achieve substantial performance gains <ref> [15] </ref>. This paper focuses on a previously unexamined point in the high-performance Web server design space: the application of the Proactor pattern to simplify Web server software development, while maintaining high-performance. <p> Completion Handlers can be written as if they existed in a conventional single-threaded environment. For instance, a Web server's HTTP GET Handler can access the disk through an Async Read operation (such as the Windows NT TransmitFile function <ref> [15] </ref>). 4.5.2 Drawbacks The Proactor pattern has the following drawbacks: Hard to debug: Applications written with the Proactor pattern can be hard to debug since the inverted flow of control oscillates between the framework infrastructure and the method callbacks on application-specific handlers.
Reference: [16] <author> J. C. </author> <title> Mogul, </title> <booktitle> The Case for Persistent-connection HTTP, in Proceedings of ACM SIGCOMM '95 Conference in Computer Communication Review, </booktitle> <address> (Boston, MA, USA), </address> <pages> pp. 299314, </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: high-performance Web server like JAWS requires the resolution of the following forces: * Concurrency: The server must perform multiple client requests simultaneously; * Efficiency: The server must minimize latency, maximize throughput, and avoid utilizing the CPU (s) unnecessarily. * Adaptability: Integrating new or improved transport protocols (such as HTTP 1.1 <ref> [16] </ref>) should incur minimal enhancement and maintenance costs. * Programming simplicity: The design of the server should simplify the use of various concurrency strategies, which may differ in performance on different OS platforms; The JAWS Web server can be implemented using several concurrency strategies, such as multiple synchronous threads, reactive synchronous
Reference: [17] <author> Gene Trent and Mark Sake, WebSTONE: </author> <title> The First Generation in HTTP Server Benchmarking. Silicon Graphics, </title> <publisher> Inc. </publisher> <address> whitepaper, </address> <month> Febru-ary </month> <year> 1995. </year> <note> Available from http://www.sgi.com/. </note>
Reference-contexts: The two workstations were connected via an ATM network running through a FORE Systems ASX-200BX, with a maximum bandwidth of 622 Mbps. However, due to limitations of LAN emulation mode, the peak bandwidth of our testbed is approximately 120 Mbps. 3.3.2 Software Request Generator We used the WebSTONE <ref> [17] </ref> v2.0 benchmarking software to collect client- and server-side metrics. These metrics included average server throughput, and average client latency. Web-STONE is a standard benchmarking utility, capable of generating load requests that simulate typical Web server file access patterns.
Reference: [18] <author> A. Carlton, </author> <title> An Explanation of the SPECweb96 Benchmark. Standard Performance Evaluation Corporation whitepaper, </title> <note> 1996. Available from http://www.specbench.org/. </note>
Reference-contexts: This table represents actual load conditions on popular Document Size Frequency 500 bytes 35% 5 Kbytes 50% 50 Kbytes 14% 5 Mbytes 1% Table 1: File Access Patterns servers, based on a study of file access patterns conducted by SPEC <ref> [18] </ref>. 3.3.3 Experimental Results The results presented below compare the performance of several different adaptations of the JAWS Web server. We discuss the effect of different event dispatching and I/O models on throughput and latency. Throughput is defined as the average number of bits received per second by the client.
Reference: [19] <institution> Information Technology Portable Operating System Interface (POSIX) Part 1: System Application: Program Interface (API) [C Language], </institution> <year> 1995. </year>
Reference-contexts: These system calls detect and report the events that may occur simultaneously on multiple event sources. Event sources may include I/O ports, timers, synchronization objects, signals, etc. On real-time POSIX platforms, the asynchronous I/O functions are provided by the aio family of APIs <ref> [19] </ref>. In Windows NT, I/O completion ports and overlapped I/O are used to implement asynchronous I/O [20]. <p> The source code for this implementation can be acquired from the ACE website at www.cs.wustl.edu/~schmidt/ACE.html. The UNIX AIO Family of Asynchronous I/O Operations: On some real-time POSIX platforms, the Proactor pattern is implemented by the aio family of APIs <ref> [19] </ref>. These OS features are very similar to the ones described above for Windows NT.
Reference: [20] <institution> Microsoft Developers Studio, Version 4.2 Software Development Kit, </institution> <year> 1996. </year>
Reference-contexts: Event sources may include I/O ports, timers, synchronization objects, signals, etc. On real-time POSIX platforms, the asynchronous I/O functions are provided by the aio family of APIs [19]. In Windows NT, I/O completion ports and overlapped I/O are used to implement asynchronous I/O <ref> [20] </ref>. The Completion Dispatcher encapsulates the concurrency mechanism: A benefit of decoupling the Completion Dispatcher from the Asynchronous Operation Processor is that applications can configure Completion Dispatchers with various concurrency strategies without affecting other participants.
References-found: 20

