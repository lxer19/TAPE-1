URL: http://www.cs.umd.edu/~rich/courses/cmsc710-f97/papers/kaashoek_sosp97.ps.gz
Refering-URL: http://www.cs.umd.edu/~rich/courses/cmsc710-f97/resources.html
Root-URL: 
Title: Application Performance and Flexibility on Exokernel Systems  
Author: M. Frans Kaashoek, Dawson R. Engler, Gregory R. Ganger, H ector M. Brice no, Russell Hunt, David Mazi eres, Thomas Pinckney, Robert Grimm, John Jannotti, and Kenneth Mackenzie 
Web: http://www.pdos.lcs.mit.edu/  
Address: Cambridge, MA 02139, U.S.A  
Affiliation: M.I.T. Laboratory for Computer Science  
Note: To appear in the Proceedings of the 16th Symposium on Operating Systems Principles (SOSP),October, 1997.  
Abstract: The exokernel operating system architecture safely gives untrusted software efficient control over hardware and software resources by separating management from protection. This paper describes an exokernel system that allows specialized applications to achieve high performance without sacrificing the performance of unmodified UNIX programs. It evaluates the exokernel architecture by measuring end-to-end application performance on Xok, an exo-kernel for Intel x86-based computers, and by comparing Xok's performance to the performance of two widely-used 4.4BSD UNIX systems (FreeBSD and OpenBSD). The results show that common unmodified UNIX applications can enjoy the benefits of exoker-nels: applications either perform comparably on Xok/ExOS and the BSD UNIXes, or perform significantly better. In addition, the results show that customized applications can benefit substantially from control over their resources (e.g., a factor of eight for a Web server). This paper also describes insights about the exokernel approach gained through building three different exokernel systems, and presents novel approaches to resource multiplexing. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Anderson. </author> <title> The case for application-specific operating systems. </title> <booktitle> In Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 9294, </pages> <year> 1992. </year>
Reference-contexts: An interface designed to accommodate every application must anticipate all possible needs. The implementation of such an interface would need to resolve all tradeoffs and anticipate all ways the interface could be used. Experience suggests that such anticipation is infeasible and that the cost of mistakes is high <ref> [1, 4, 8, 11, 21, 39] </ref>. The exokernel architecture [11] solves this problem by giving untrusted applications as much control over resources as possible. It does so by dividing responsibilities differently from the way conventional systems do. Exokernels separate protection from management: they protect resources but delegate management to applications.
Reference: [2] <author> J. Barrera. </author> <title> Invocation chaining: manipulating light-weight objects across heavy-weight boundaries. </title> <booktitle> In Proc. of 4th IEEE Workshop on Workstation Operating Systems, </booktitle> <pages> pages 191193, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Techniques to reduce the cost of shared servers by improving IPC performance, moving code from servers into libraries, mapping read-only shared data structures, and batching system calls <ref> [2, 18, 28, 30] </ref> can also be successfully applied in an exokernel system. Virtual machines [5, 12, 17] (VMs) are an OS structure in which a privileged virtual machine monitor (VMM) isolates less privileged software in emulated copies of the underlying hardware. Unfortunately, emulation hides information.
Reference: [3] <author> B.N. Bershad, D.D. Redell, and J.R. Ellis. </author> <title> Fast mutual exclusion for uniprocessors. </title> <booktitle> In Proc. of the Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 223237, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Wakeup predicates can ensure that a buggy or crashed process will not hang a correctly behaved one. Fourth, the exokernel provides robust critical sections: inexpensive critical sections that are implemented by disabling software interrupts <ref> [3] </ref>. Using critical sections instead of locks eliminates the need to trust other processes. Three levels of trust determine what optimizations can be used by the implementation of a shared abstraction. Optimize for the common case: Mutual trust. <p> We heavily tuned Aegis to achieve excellent mi-crobenchmark performance. Xok, on the other hand, is completely untuned. Nevertheless, applications perform well. Inexpensive critical sections are useful for LibOSes. In traditional OSes, inexpensive critical sections can be implemented by disabling interrupts <ref> [3] </ref>. ExOS implements such critical sections by disabling software interrupts (e.g., time slice termination upcalls).
Reference: [4] <author> B.N. Bershad, S. Savage, P. Pardyak, E.G. Sirer, M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267284, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: An interface designed to accommodate every application must anticipate all possible needs. The implementation of such an interface would need to resolve all tradeoffs and anticipate all ways the interface could be used. Experience suggests that such anticipation is infeasible and that the cost of mistakes is high <ref> [1, 4, 8, 11, 21, 39] </ref>. The exokernel architecture [11] solves this problem by giving untrusted applications as much control over resources as possible. It does so by dividing responsibilities differently from the way conventional systems do. Exokernels separate protection from management: they protect resources but delegate management to applications. <p> In many systems only trusted users can download code, either through dynamically-loaded kernel extensions or static configuration [13, 21]. In the SPIN and Vino systems, any user can safely download code into the kernel <ref> [4, 39] </ref>. Safe downloading of code through type-safety [4, 37] and software fault-isolation [39, 42] is complementary to the exokernel approach of separating protection from management. Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11]. <p> In many systems only trusted users can download code, either through dynamically-loaded kernel extensions or static configuration [13, 21]. In the SPIN and Vino systems, any user can safely download code into the kernel [4, 39]. Safe downloading of code through type-safety <ref> [4, 37] </ref> and software fault-isolation [39, 42] is complementary to the exokernel approach of separating protection from management. Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11].
Reference: [5] <author> E. Bugnion, S. Devine, and M. Rosenblum. </author> <title> Disco: running commodity operating systems on scalable multiprocessors. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating Systems Principles, </booktitle> <year> 1997. </year>
Reference-contexts: Techniques to reduce the cost of shared servers by improving IPC performance, moving code from servers into libraries, mapping read-only shared data structures, and batching system calls [2, 18, 28, 30] can also be successfully applied in an exokernel system. Virtual machines <ref> [5, 12, 17] </ref> (VMs) are an OS structure in which a privileged virtual machine monitor (VMM) isolates less privileged software in emulated copies of the underlying hardware. Unfortunately, emulation hides information.
Reference: [6] <author> P. Cao, E.W. Felten, and K. Li. </author> <title> Implementation and performance of application-controlled file caching. </title> <booktitle> In Proceedings of the First 13 Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 165178, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: In addition to these structural approaches, much work has been done on better OS abstractions that give more control to applications, such as user-level networking [40, 41], lottery scheduling [43], application-controlled virtual memory [22, 27] and file systems <ref> [6, 35] </ref>. All of this work is directly applicable to libOSes. 3 Exokernel Background This section briefly summarizes the exokernel architecture.
Reference: [7] <author> A. Chankhunthod, P.B. Danzig, C. Neerdaels, M.F. Schwartz, and K.J. Worrell. </author> <title> A hierarchical Internet object cache. </title> <booktitle> In Proceedings of 1996 USENIX Technical Conference, </booktitle> <pages> pages 153163, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: This library is designed to allow application writers to exploit domain-specific knowledge and to simplify the construction of high-performance servers by removing the need to trick the operating system into doing what the application requires (e.g., Harvest <ref> [7] </ref> stores cached pages in multiple directories to achieve fast name lookup). An HTTP server's task is simple: given a client request, it finds the appropriate document and sends it. The Cheetah Web server performs the following set of optimizations as well as others not listed here. <p> When the file cache does not capture the majority of client requests, this extension can improve HTTP throughput by up to a factor of two. running on OpenBSD 2.0, the Harvest cache <ref> [7] </ref> running on Open-BSD 2.0, the base socket-based server running on OpenBSD 2.0 (i.e., our HTTP server without any optimizations), the base socket-based server running on the Xok exokernel system (i.e., our HTTP server without any optimizations with vanilla socket and file descriptor implementations layered over XIO), and the Cheetah server
Reference: [8] <author> D. Cheriton and K. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 179193, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: An interface designed to accommodate every application must anticipate all possible needs. The implementation of such an interface would need to resolve all tradeoffs and anticipate all ways the interface could be used. Experience suggests that such anticipation is infeasible and that the cost of mistakes is high <ref> [1, 4, 8, 11, 21, 39] </ref>. The exokernel architecture [11] solves this problem by giving untrusted applications as much control over resources as possible. It does so by dividing responsibilities differently from the way conventional systems do. Exokernels separate protection from management: they protect resources but delegate management to applications. <p> Whether monolithic or microkernel-based, the goal of an exokernel system remains for privileged software to provide interfaces that do not limit the ability of unprivileged applications to manage their own resources. Some newer microkernels push the kernel interface closer to the hardware <ref> [8, 20, 36] </ref>, obtaining better performance and robustness than previous microkernels and allowing for a greater degree of flexibility, since shared monolithic servers can be broken into several servers.
Reference: [9] <author> J.B. Dennis and E.C. Van Horn. </author> <title> Programming semantics for multipro-grammed computations. </title> <journal> Communications of the ACM, </journal> <volume> 9(3):143155, </volume> <month> March </month> <year> 1966. </year>
Reference-contexts: The composition of multiple predicates allows atomic checking of disjoint data structures. Access control Unlike Aegis, Xok performs access control through hierarchically-named capabilities [31]; despite the name, these capabilities more closely resemble a generalized form of UNIX user and group ID than traditional capabilities <ref> [9] </ref>. All Xok calls require explicit credentials.
Reference: [10] <author> D.R. Engler and M.F. Kaashoek. DPF: </author> <title> fast, flexible message demul-tiplexing using dynamic code generation. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIGCOMM) 1996, </booktitle> <pages> pages 5359, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: Environments provide the hardware-specific state needed to run a process (e.g., an exception stack) and to respond to any event occurring during process execution (e.g., interrupts and exceptions). The network is multiplexed with dynamic packet filters <ref> [10] </ref>. This subsection briefly describes the differences between Aegis and Xok. Physical memory. Unlike the MIPS architecture, the x86 architecture defines the page-table structure. Since x86 TLB refills are handled in hardware, this structure cannot be overridden by applications.
Reference: [11] <author> D.R. Engler, M.F. Kaashoek, and J. O'Toole Jr. Exokernel: </author> <title> an operating system architecture for application-specific resource management. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251266, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: An interface designed to accommodate every application must anticipate all possible needs. The implementation of such an interface would need to resolve all tradeoffs and anticipate all ways the interface could be used. Experience suggests that such anticipation is infeasible and that the cost of mistakes is high <ref> [1, 4, 8, 11, 21, 39] </ref>. The exokernel architecture [11] solves this problem by giving untrusted applications as much control over resources as possible. It does so by dividing responsibilities differently from the way conventional systems do. Exokernels separate protection from management: they protect resources but delegate management to applications. <p> The implementation of such an interface would need to resolve all tradeoffs and anticipate all ways the interface could be used. Experience suggests that such anticipation is infeasible and that the cost of mistakes is high [1, 4, 8, 11, 21, 39]. The exokernel architecture <ref> [11] </ref> solves this problem by giving untrusted applications as much control over resources as possible. It does so by dividing responsibilities differently from the way conventional systems do. Exokernels separate protection from management: they protect resources but delegate management to applications. <p> We discuss the disk subsystem, XN, and explain how unprivileged applications can define new file systems and how these file systems can safely multiplex the same disk at a fine granularity. Finally, we summarize what we have learned from building three complete exokernel systems (Xok, Aegis <ref> [11] </ref> for DECstations, and Glaze [29] for the Fugu multiprocessor). The rest of the paper is organized as follows. Section 2 discusses related work. Section 3 summarizes the exokernel architecture. Section 4 provides a detailed example of reconciling application control with protection by presenting the disk system XN. <p> Section 8 investigates global performance on an exokernel system. Section 9 discusses our experiences with building three different exokernel systems. Section 10 concludes. 2 Related Work The exokernel architecture was proposed in <ref> [11] </ref>, which described a research prototype that performed significantly better than Ultrix on microbenchmarks. While the paper provided evidence that the exo-kernel approach was promising, it left many questions unanswered. <p> Safe downloading of code through type-safety [4, 37] and software fault-isolation [39, 42] is complementary to the exokernel approach of separating protection from management. Exokernels use downloading of code to let the kernel leave decisions to untrusted software <ref> [11] </ref>. In addition to these structural approaches, much work has been done on better OS abstractions that give more control to applications, such as user-level networking [40, 41], lottery scheduling [43], application-controlled virtual memory [22, 27] and file systems [6, 35]. <p> Applications communicate with the kernel using low-level physical names (e.g., block numbers); the kernel interface is as close to the hardware as possible. LibOSes handle higher-level names (e.g., file descriptors) and supply abstractions. We briefly describe the exokernel principles, motivated in <ref> [11] </ref>. These principles illustrate the mechanics of exokernel systems and provide important motivation for many design decisions discussed later in this paper. <p> To prevent unauthorized access, every operation on disk data must be guarded. For speed, XN uses secure bindings <ref> [11] </ref> to move access checks to bind time rather than checking at every access. For example, the permission to read a cached disk block is checked when the page is inserted into the page table of the libFS's environment, rather than on every access. 2. <p> This section describes both Xok and ExOS. 5.1 Xok Xok safely multiplexes the physical resources on Intel x86-based computers. Xok performs this task in a manner similar to the Aegis exokernel, which runs on MIPS-based DECstations <ref> [11] </ref>. The CPU is multiplexed by dividing time into round-robin-scheduled slices with explicit notification of the beginning and the end of a time slice. <p> Another example is the use of downloaded code for metadata interpretation: since the kernel can ensure that UDFs are deterministic and do not change, it can trust their output without having to understand what they do. 10 Conclusion This paper evaluates the exokernel architecture proposed in <ref> [11] </ref>. It shows how we built an exokernel system that separates protection from management to give untrusted software control over resource management. Our exokernel system gives significant performance advantages to aggressively-specialized applications while maintaining competitive performance on unmodified UNIX applications, even under heavily multitasked workloads.
Reference: [12] <author> B. Ford, M. Hibler, J. Lepreau, P. Tullman, G. Back, and S. Clawson. </author> <title> Microkernels meet recursive virtual machines. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 137152, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Techniques to reduce the cost of shared servers by improving IPC performance, moving code from servers into libraries, mapping read-only shared data structures, and batching system calls [2, 18, 28, 30] can also be successfully applied in an exokernel system. Virtual machines <ref> [5, 12, 17] </ref> (VMs) are an OS structure in which a privileged virtual machine monitor (VMM) isolates less privileged software in emulated copies of the underlying hardware. Unfortunately, emulation hides information.
Reference: [13] <author> B. Ford, K. Van Maren, J. Lepreau, S. Clawson, B. Robinson, and Jeff Turner. </author> <title> The FLUX OS toolkit: Reusable components for OS implementation. </title> <booktitle> In Proc. of Sixth Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pages 1419, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: In many systems only trusted users can download code, either through dynamically-loaded kernel extensions or static configuration <ref> [13, 21] </ref>. In the SPIN and Vino systems, any user can safely download code into the kernel [4, 39]. Safe downloading of code through type-safety [4, 37] and software fault-isolation [39, 42] is complementary to the exokernel approach of separating protection from management.
Reference: [14] <author> B. Ford and S.R. Susarla. </author> <title> CPU inheritance scheduling. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 91106, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: In all cases, this information was already provided by the kernel data structures. The CPU interface. The combination of time slices, initiation/termination upcalls, and directed yields has proven its value repeatedly. (Subsequent to our work, others have found these primitives useful <ref> [14] </ref>.) We have used the primitives for inter-process communication optimization (e.g., two applications communicating through a shared message queue can yield to each other), global gang-scheduling, and robust critical sections (see below). Libraries are simpler than kernels.
Reference: [15] <author> G. Ganger and M.F. Kaashoek. </author> <title> Embedded inodes and explicit grouping: Exploiting disk bandwidth for small files. </title> <booktitle> In Proceedings of the 1997 USENIX Technical Conference, </booktitle> <pages> pages 118, </pages> <year> 1997. </year>
Reference-contexts: First, we describe XN, Xok's extensible, low-level in-kernel stable storage system. We also describe the general interface between XN and libFSes and present one particular libFS, C-FFS, the co-locating fast file system <ref> [15] </ref>. 4.1 Overview of XN Designing a flexible exokernel stable storage system has proven difficult: XN is our fourth design. This section provides an overview of UDFs, the cornerstone of XN; the following sections describe some earlier approaches (and why they failed), and aspects of XN in greater depth. <p> The cost of low-level multiplexing is negligible. 6.2 Invisible optimization using C-FFS These comparisons concentrate on I/O intensive operations that exploit the C-FFS library file system <ref> [15] </ref>. We again use the I/O-intensive benchmarks described in Table 1, but now compare Xok/C-FFS with OpenBSD and FreeBSD. As Figure 2 shows, unaltered UNIX applications can run significantly faster on top of Xok/ExOS. Xok/ExOS completes all benchmarks in 41 seconds, 19 seconds faster than FreeBSD and OpenBSD.
Reference: [16] <author> G. Ganger and Y. Patt. </author> <title> Metadata update performance in file systems. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 4960, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: XN controls only what is necessary to enforce these protection rules. All other abilitiesI/O initiation, disk block layout and allocation policies, recovery semantics, and consistency guarantees are left to untrusted libFSes. 4.3.2 Ordered disk writes Another difficulty XN must face is guaranteeing the rules Ganger and Patt <ref> [16] </ref> give for achieving strict file system integrity across crashes: First, never reuse an on-disk resource before nullifying all previous pointers to it. Second, never create persistent pointers to structures before they are initialized.
Reference: [17] <author> R.P. Goldberg. </author> <title> Survey of virtual machine research. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 3445, </pages> <month> June </month> <year> 1974. </year>
Reference-contexts: Techniques to reduce the cost of shared servers by improving IPC performance, moving code from servers into libraries, mapping read-only shared data structures, and batching system calls [2, 18, 28, 30] can also be successfully applied in an exokernel system. Virtual machines <ref> [5, 12, 17] </ref> (VMs) are an OS structure in which a privileged virtual machine monitor (VMM) isolates less privileged software in emulated copies of the underlying hardware. Unfortunately, emulation hides information.
Reference: [18] <author> D. Golub, R. Dean, A. Forin, and R. Rashid. </author> <title> UNIX as an application program. </title> <booktitle> In USENIX 1990 Summer Conference, </booktitle> <pages> pages 8795, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: We discuss each in turn. The principal goal of an exokernelgiving applications con-trolis orthogonal to the question of monolithic versus microkernel organization. If applications are restricted to inadequate interfaces, it makes little difference whether the implementations reside in the kernel or privileged user-level servers <ref> [20, 18] </ref>; in both cases applications lack control. For example, it is difficult to change the buffer management policy of a shared file server. In many ways, servers can be viewed as fixed kernel subsystems that happen to run in user space. <p> Techniques to reduce the cost of shared servers by improving IPC performance, moving code from servers into libraries, mapping read-only shared data structures, and batching system calls <ref> [2, 18, 28, 30] </ref> can also be successfully applied in an exokernel system. Virtual machines [5, 12, 17] (VMs) are an OS structure in which a privileged virtual machine monitor (VMM) isolates less privileged software in emulated copies of the underlying hardware. Unfortunately, emulation hides information.
Reference: [19] <author> P. Brinch Hansen. </author> <title> The nucleus of a multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 13(4):238241, </volume> <month> April </month> <year> 1970. </year>
Reference-contexts: While the paper provided evidence that the exo-kernel approach was promising, it left many questions unanswered. There is a large literature on extensible operating systems, starting with the classic rationales by Lampson and Brinch Hansen <ref> [19, 25, 26] </ref>. Previous approaches to extensibility can be coarsely classified in three groups: better microkernels, virtual machines, and downloading untrusted code into the kernel. We discuss each in turn. The principal goal of an exokernelgiving applications con-trolis orthogonal to the question of monolithic versus microkernel organization.
Reference: [20] <author> H. Hartig, M. Hohmuth, J. Liedtke, and S. Sch onberg. </author> <title> The performance of -kernel-based systems. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating Systems Principles, </booktitle> <year> 1997. </year>
Reference-contexts: We discuss each in turn. The principal goal of an exokernelgiving applications con-trolis orthogonal to the question of monolithic versus microkernel organization. If applications are restricted to inadequate interfaces, it makes little difference whether the implementations reside in the kernel or privileged user-level servers <ref> [20, 18] </ref>; in both cases applications lack control. For example, it is difficult to change the buffer management policy of a shared file server. In many ways, servers can be viewed as fixed kernel subsystems that happen to run in user space. <p> Whether monolithic or microkernel-based, the goal of an exokernel system remains for privileged software to provide interfaces that do not limit the ability of unprivileged applications to manage their own resources. Some newer microkernels push the kernel interface closer to the hardware <ref> [8, 20, 36] </ref>, obtaining better performance and robustness than previous microkernels and allowing for a greater degree of flexibility, since shared monolithic servers can be broken into several servers.
Reference: [21] <author> J.H. Hartman, A.B. Montz, D. Mosberger, S.W. O'Malley, L.L. Peter-son, and T.A. Proebsting. </author> <title> Scout: A communication-oriented operating system. </title> <type> Technical Report TR 94-20, </type> <institution> University of Arizona, </institution> <address> Tucson, AZ, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: An interface designed to accommodate every application must anticipate all possible needs. The implementation of such an interface would need to resolve all tradeoffs and anticipate all ways the interface could be used. Experience suggests that such anticipation is infeasible and that the cost of mistakes is high <ref> [1, 4, 8, 11, 21, 39] </ref>. The exokernel architecture [11] solves this problem by giving untrusted applications as much control over resources as possible. It does so by dividing responsibilities differently from the way conventional systems do. Exokernels separate protection from management: they protect resources but delegate management to applications. <p> In many systems only trusted users can download code, either through dynamically-loaded kernel extensions or static configuration <ref> [13, 21] </ref>. In the SPIN and Vino systems, any user can safely download code into the kernel [4, 39]. Safe downloading of code through type-safety [4, 37] and software fault-isolation [39, 42] is complementary to the exokernel approach of separating protection from management.
Reference: [22] <author> K. Harty and D. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Fifth International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 187199, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11]. In addition to these structural approaches, much work has been done on better OS abstractions that give more control to applications, such as user-level networking [40, 41], lottery scheduling [43], application-controlled virtual memory <ref> [22, 27] </ref> and file systems [6, 35]. All of this work is directly applicable to libOSes. 3 Exokernel Background This section briefly summarizes the exokernel architecture.
Reference: [23] <author> D. Hitz. </author> <title> An NFS file server appliance. </title> <type> Technical Report 3001, </type> <institution> Network Applicance Corporation, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Server performance is crucial to client/server applications <ref> [23] </ref>, and the I/O-centric nature of servers makes operating system-based optimizations profitable. We have developed an extensible I/O library (XIO) for fast servers and a sample application that uses it, the Cheetah HTTP server.
Reference: [24] <author> M.F. Kaashoek, D.R. Engler, D.H. Wallach, and G. Ganger. </author> <title> Server operating systems. </title> <booktitle> In SIGOPS European Workshop, </booktitle> <pages> pages 141148, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: The extensibility of ExOS's default unprivileged TCP/IP and file system implementations made it possible to achieve these performance improvements incrementally and with low complexity. The optimizations performed by Cheetah are architecture independent. In Aegis, Cheetah obtained similar performance improvements over Ultrix web servers <ref> [24] </ref>. 8 Global Performance Xok/ExOS's decentralization of resource management allows the performance of individual applications to be improved, but Xok/ ExOS must also guarantee good global performance when running multiple applications concurrently.
Reference: [25] <author> B.W. Lampson. </author> <title> On reliable and extendable operating systems. State of the Art Report, </title> <journal> Infotech, </journal> <volume> 1, </volume> <year> 1971. </year>
Reference-contexts: While the paper provided evidence that the exo-kernel approach was promising, it left many questions unanswered. There is a large literature on extensible operating systems, starting with the classic rationales by Lampson and Brinch Hansen <ref> [19, 25, 26] </ref>. Previous approaches to extensibility can be coarsely classified in three groups: better microkernels, virtual machines, and downloading untrusted code into the kernel. We discuss each in turn. The principal goal of an exokernelgiving applications con-trolis orthogonal to the question of monolithic versus microkernel organization.
Reference: [26] <author> B.W. Lampson and R.F. Sproull. </author> <title> An open operating system for a single-user machine. </title> <booktitle> Proceedings of the Seventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 98105, </pages> <month> December </month> <year> 1979. </year>
Reference-contexts: While the paper provided evidence that the exo-kernel approach was promising, it left many questions unanswered. There is a large literature on extensible operating systems, starting with the classic rationales by Lampson and Brinch Hansen <ref> [19, 25, 26] </ref>. Previous approaches to extensibility can be coarsely classified in three groups: better microkernels, virtual machines, and downloading untrusted code into the kernel. We discuss each in turn. The principal goal of an exokernelgiving applications con-trolis orthogonal to the question of monolithic versus microkernel organization. <p> While caching can mitigate this problem to a degree, we are nervous about its overhead on disk-intensive work-loads. An alternative approach is to co-locate capabilities with disk blocks by placing them immediately before a disk block's data <ref> [26] </ref>. Unfortunately, on common hardware, reserving space for a capability would prevent blocks from being multiples of the page size, adding overhead and complexity to disk operations. Self-descriptive metadata. Our first serious attempt at efficient disk multiplexing provided a means for each instance of metadata to describe itself.
Reference: [27] <author> C.H. Lee, M.C. Chen, and R.C. Chang. </author> <title> HiPEC: high performance external virtual memory caching. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 153164, </pages> <year> 1994. </year>
Reference-contexts: Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11]. In addition to these structural approaches, much work has been done on better OS abstractions that give more control to applications, such as user-level networking [40, 41], lottery scheduling [43], application-controlled virtual memory <ref> [22, 27] </ref> and file systems [6, 35]. All of this work is directly applicable to libOSes. 3 Exokernel Background This section briefly summarizes the exokernel architecture.
Reference: [28] <author> J. Liedtke. </author> <title> On micro-kernel construction. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 237250, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Techniques to reduce the cost of shared servers by improving IPC performance, moving code from servers into libraries, mapping read-only shared data structures, and batching system calls <ref> [2, 18, 28, 30] </ref> can also be successfully applied in an exokernel system. Virtual machines [5, 12, 17] (VMs) are an OS structure in which a privileged virtual machine monitor (VMM) isolates less privileged software in emulated copies of the underlying hardware. Unfortunately, emulation hides information.
Reference: [29] <author> K. Mackenzie, J. Kubiatowicz, M. Frank, W. Lee, V. Lee, A. Agarwal, and M.F. Kaashoek. UDM: </author> <title> user direct messaging for general-purpose multiprocessing. </title> <note> Technical Memo MIT/LCS/TM-556, </note> <month> March </month> <year> 1996. </year>
Reference-contexts: Finally, we summarize what we have learned from building three complete exokernel systems (Xok, Aegis [11] for DECstations, and Glaze <ref> [29] </ref> for the Fugu multiprocessor). The rest of the paper is organized as follows. Section 2 discusses related work. Section 3 summarizes the exokernel architecture. Section 4 provides a detailed example of reconciling application control with protection by presenting the disk system XN. <p> Glaze, the Fugu exokernel, has the additional complication that it cannot distinguish such uses from the physical pages used for buffering messages <ref> [29] </ref>. Frequently-used information can often be derived with little effort. For example, if page tables are managed by the application, the exokernel can approximate LRU page ordering by tracking the insertion of translations into the TLB. However, at the very least, this 12 inference requires thought. Self-paging libOSes.
Reference: [30] <author> C. Maeda and B.N. Bershad. </author> <title> Protocol service decomposition for high-performance networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244255, </pages> <year> 1993. </year>
Reference-contexts: Techniques to reduce the cost of shared servers by improving IPC performance, moving code from servers into libraries, mapping read-only shared data structures, and batching system calls <ref> [2, 18, 28, 30] </ref> can also be successfully applied in an exokernel system. Virtual machines [5, 12, 17] (VMs) are an OS structure in which a privileged virtual machine monitor (VMM) isolates less privileged software in emulated copies of the underlying hardware. Unfortunately, emulation hides information.
Reference: [31] <author> D. Mazi eres and M.F. Kaashoek. </author> <title> Secure applications need flexibile operating systems. </title> <booktitle> In Proc of 6th Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pages 5661, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: First, software regions, areas of memory that can only be read or written through system calls, provide sub-page protection and fault isolation. Second, the exokernel allows on the-fly-creation of hierarchically-named capabilities and requires that these capabilities be specified explicitly on each system call <ref> [31] </ref>. Thus, a buggy child process accidentally requesting write access to a page or software region of its parent will likely provide the wrong capability and be denied permission. <p> To bound the amount of time a predicate sleeps, it can compare against the system clock. The composition of multiple predicates allows atomic checking of disjoint data structures. Access control Unlike Aegis, Xok performs access control through hierarchically-named capabilities <ref> [31] </ref>; despite the name, these capabilities more closely resemble a generalized form of UNIX user and group ID than traditional capabilities [9]. All Xok calls require explicit credentials.
Reference: [32] <institution> NCSA, University of Illinois, Urbana-Champaign. </institution> <note> NCSA HTTPd. http://hoohoo.ncsa.uiuc.edu/index.html. </note>
Reference: [33] <author> J.K. Ousterhout. </author> <booktitle> Why aren't operating systems getting faster as fast as hardware? In Proceedings of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 247256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: On eight of the eleven benchmarks Xok/ExOS performs better than Free/OpenBSD (in one case by over a factor of four). ExOS's performance improvements are due to its C-FFS file system. We also ran the Modified Andrew Benchmark (MAB) <ref> [33] </ref>.
Reference: [34] <author> V. Pai, P. Druschel, and W. Zwaenepoel. I/O-lite: </author> <title> a unified I/O buffering and caching system. </title> <note> Technical Report http:// www.cs.rice.edu/vivek/IO-lite.html, Rice University, </note> <year> 1997. </year>
Reference-contexts: Data are transmitted (and retransmitted, if necessary) to the client directly from the file cache without CPU copy operations. (Pai et al. have also used this technique <ref> [34] </ref>.) Knowledge-based Packet Merging. Cheetah exploits knowledge of its per-request state transitions to reduce the number of I/O actions it initiates. For example, it avoids sending redundant control packets by delaying ACKs on client HTTP requests, since it knows it will be able to piggy-back them on the response.
Reference: [35] <author> R.H. Patterson, G.A. Gibson, E. Ginting, D. Stodolsky, and J. Zelenka. </author> <title> Informed prefetching and caching. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 7995, </pages> <month> De-cember </month> <year> 1995. </year>
Reference-contexts: In addition to these structural approaches, much work has been done on better OS abstractions that give more control to applications, such as user-level networking [40, 41], lottery scheduling [43], application-controlled virtual memory [22, 27] and file systems <ref> [6, 35] </ref>. All of this work is directly applicable to libOSes. 3 Exokernel Background This section briefly summarizes the exokernel architecture.
Reference: [36] <author> D. Probert, J.L. Bruno, and M. Karzaorman. </author> <title> SPACE: a new approach to operating system abstraction. </title> <booktitle> In International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 133137, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Whether monolithic or microkernel-based, the goal of an exokernel system remains for privileged software to provide interfaces that do not limit the ability of unprivileged applications to manage their own resources. Some newer microkernels push the kernel interface closer to the hardware <ref> [8, 20, 36] </ref>, obtaining better performance and robustness than previous microkernels and allowing for a greater degree of flexibility, since shared monolithic servers can be broken into several servers.
Reference: [37] <author> D.D. Redell, Y.K. Dalal, T.R. Horsley, H.C. Lauer, W.C. Lynch, P.R. McJones, H.G. Murray, </author> <title> and S.C. Purcell. Pilot: an operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2):8192, </volume> <month> February </month> <year> 1980. </year>
Reference-contexts: In many systems only trusted users can download code, either through dynamically-loaded kernel extensions or static configuration [13, 21]. In the SPIN and Vino systems, any user can safely download code into the kernel [4, 39]. Safe downloading of code through type-safety <ref> [4, 37] </ref> and software fault-isolation [39, 42] is complementary to the exokernel approach of separating protection from management. Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11].
Reference: [38] <author> R. Sandberg, D. Goldberg, S. Kleiman, D. Walsh, and B. Lyon. </author> <title> Design and implementation of the Sun network filesystem. </title> <booktitle> In Proc. of the 1985 Summer USENIX conference, </booktitle> <pages> pages 119130, </pages> <year> 1985. </year>
Reference-contexts: However, unlike UNIX, ExOS allows applications to install their own methods. Files. Local files are accessed through C-FFS, which uses XN to protect file metadata; remote files are accessed through the Network File System protocol (NFS) <ref> [38] </ref>. Both file systems are library based. ExOS uses XN's buffer cache registry to safely share both C-FFS and NFS disk blocks. UNIX allows different file systems to be attached to its hierarchical name space.
Reference: [39] <author> M. Seltzer, Y. Endo, C. Small, and K. Smith. </author> <title> Dealing with disaster: Surviving misbehaved kernel extensions. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 213228, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: An interface designed to accommodate every application must anticipate all possible needs. The implementation of such an interface would need to resolve all tradeoffs and anticipate all ways the interface could be used. Experience suggests that such anticipation is infeasible and that the cost of mistakes is high <ref> [1, 4, 8, 11, 21, 39] </ref>. The exokernel architecture [11] solves this problem by giving untrusted applications as much control over resources as possible. It does so by dividing responsibilities differently from the way conventional systems do. Exokernels separate protection from management: they protect resources but delegate management to applications. <p> In many systems only trusted users can download code, either through dynamically-loaded kernel extensions or static configuration [13, 21]. In the SPIN and Vino systems, any user can safely download code into the kernel <ref> [4, 39] </ref>. Safe downloading of code through type-safety [4, 37] and software fault-isolation [39, 42] is complementary to the exokernel approach of separating protection from management. Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11]. <p> In many systems only trusted users can download code, either through dynamically-loaded kernel extensions or static configuration [13, 21]. In the SPIN and Vino systems, any user can safely download code into the kernel [4, 39]. Safe downloading of code through type-safety [4, 37] and software fault-isolation <ref> [39, 42] </ref> is complementary to the exokernel approach of separating protection from management. Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11].
Reference: [40] <author> C.A. Thekkath, H.M. Levy, and E.D. Lazowska. </author> <title> Separating data and control transfer in distributed operating systems. </title> <booktitle> In Sixth International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 211, </pages> <address> San Francisco, CA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11]. In addition to these structural approaches, much work has been done on better OS abstractions that give more control to applications, such as user-level networking <ref> [40, 41] </ref>, lottery scheduling [43], application-controlled virtual memory [22, 27] and file systems [6, 35]. All of this work is directly applicable to libOSes. 3 Exokernel Background This section briefly summarizes the exokernel architecture.
Reference: [41] <author> T. von Eicken, A. Basu, V. Buch, and W. Vogels. U-Net: </author> <title> a user-level network interface for parallel and distributed computing. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 4053, </pages> <year> 1995. </year>
Reference-contexts: Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11]. In addition to these structural approaches, much work has been done on better OS abstractions that give more control to applications, such as user-level networking <ref> [40, 41] </ref>, lottery scheduling [43], application-controlled virtual memory [22, 27] and file systems [6, 35]. All of this work is directly applicable to libOSes. 3 Exokernel Background This section briefly summarizes the exokernel architecture.
Reference: [42] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, pages 203216, </booktitle> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: In many systems only trusted users can download code, either through dynamically-loaded kernel extensions or static configuration [13, 21]. In the SPIN and Vino systems, any user can safely download code into the kernel [4, 39]. Safe downloading of code through type-safety [4, 37] and software fault-isolation <ref> [39, 42] </ref> is complementary to the exokernel approach of separating protection from management. Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11].
Reference: [43] <author> C.A. Waldspurger and W.E. Weihl. </author> <title> Lottery scheduling: Flexible proportional-share resource management. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 111, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Exokernels use downloading of code to let the kernel leave decisions to untrusted software [11]. In addition to these structural approaches, much work has been done on better OS abstractions that give more control to applications, such as user-level networking [40, 41], lottery scheduling <ref> [43] </ref>, application-controlled virtual memory [22, 27] and file systems [6, 35]. All of this work is directly applicable to libOSes. 3 Exokernel Background This section briefly summarizes the exokernel architecture.
Reference: [44] <author> D.A. Wallach, D.R. Engler, and M.F. Kaashoek. ASHs: </author> <title> Application-specific handlers for high-performance messaging. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIGCOMM '96), </booktitle> <pages> pages 4052, </pages> <month> August </month> <year> 1996. </year> <month> 14 </month>
Reference-contexts: User-level page tables made the implementation of libOSes tricky on Aegis; since the x86 has hardware page tables, this issue disappeared on Xok/ExOS. Downloaded interrupt handlers are of questionable utility on exokernels. Aegis used downloaded code extensively in interrupt servicing <ref> [44] </ref>. The two main benefits are elimination of kernel crossings and fast upcalls to unscheduled processes, thereby reducing processing latency (e.g., of send-response style network messages). On current generation chips, however, the latency of I/O devices is large compared to the overhead of kernel crossings, making the first benefit negligible.
References-found: 44

