URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1296/CS-TR-95-1296.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1296/
Root-URL: http://www.cs.wisc.edu
Title: Program Specialization via Program Slicing  
Author: Thomas Reps and Todd Turnidge 
Keyword: General Terms: Algorithms, Theory Additional Key Words and Phrases: program projection, program slicing, program specialization, projection function, partially needed structures  
Affiliation: University of Wisconsin  
Abstract: This paper concerns the use of program slicing to perform a certain kind of program-specialization operation. The specialization operation that slicing performs is different from the specialization operations performed by algorithms for partial evaluation, supercompilation, bifurcation, and deforestation. In particular, we present an example in which the specialized program that we create via slicing could not be created as the result of applying partial evaluation, supercompilation, bifurcation, or deforestation to the original unspecialized program. Specialization via slicing also possesses an interesting property that partial evaluation, supercompilation, and bifurcation do not possess: The latter operations are somewhat limited in the sense that they support tailoring of existing software only according to the ways in which parameters of functions and procedures are used in a program. Because parameters to functions and procedures represent the range of usage patterns that the designer of a piece of software has anticipated, partial evaluation, supercompilation, and bifurcation support specialization only in ways that have already been foreseen by the software's author. In contrast, the specialization operation that slicing supports permits programs to be specialized in ways that do not have to be anticipated by the author of the original program. CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and Techniques - computer-aided software engineering (CASE), programmer workbench; D.2.6 [Software Engineering]: Programming Environments; D.2.7 [Software Engineering]: Distribution and Maintenance restructuring; D.2.m [Software Engineering]: Miscellaneous reusable software; D.3.2 [Programming Languages]: Language Classifications applicative languages; D.3.3 [Programming Languages]: Language Constructs and Features procedures, functions, and subroutines, recursion; D.3.4 [Programming Languages]: Processors; F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs functional constructs, program and recursion schemes 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ballance, R.A., Maccabe, A.B., and Ottenstein, K.J., </author> <title> The program dependence web: A representation supporting control-, data-, and demand-driven interpretation of imperative languages, </title> <booktitle> Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIGPLAN Notices 25(6) pp. </journal> <month> 257-271 (June </month> <year> 1990). </year>
Reference-contexts: Consequently, in this framework the semantics of a slice approximates the semantics of the full program (and never vice versa). - 16 - (Other approaches to lazy semantics for program dependence graphs include [30], [4], and <ref> [1] </ref>.) ` For readers who are uncomfortable with the semantic anomaly that a slice does not preserve the termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems
Reference: 2. <author> Bates, S. and Horwitz, S., </author> <title> Incremental program testing using program dependence graphs, pp. </title> <booktitle> 384-396 in Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Charleston, SC, </address> <month> January 10-13, </month> <year> 1993), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1993). </address>
Reference-contexts: In the slice, the starting point for the slice is shown in italics, and the empty boxes indicate where program elements have been removed from the original program. In the dependence graph, the edges shown in boldface are the edges in the slice. maintenance [8, 9], debugging [21], testing <ref> [3, 2] </ref>, differencing [11,13], reuse [24], and merging [11]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and related operations. <p> A with respect to Base, all changed behavior of B with respect to Base, and all behavior that is common to all three [27]. g Bates and Horwitz proposed to use slicing to avoid redoing the part of a test suite that is unaffected by a change to a program <ref> [2] </ref>. g Andersen Consulting's interactive Cobol System Renovation Environment (Cobol/SRE) is a system for re-engineering legacy systems written in Cobol [24]. It uses slicing as the fundamental operation that users employ to select program fragments of interest. Operations are provided for combining slices (i.e., union, intersection, and difference).
Reference: 3. <author> Binkley, D., </author> <title> Using semantic differencing to reduce the cost of regression testing, </title> <booktitle> Proceedings of the 1992 Conference on Software Maintenance (Orlando, </booktitle> <address> FL, </address> <month> November 9-12, </month> <year> 1992), </year> <pages> pp. </pages> <month> 41-50 </month> <year> (1992). </year>
Reference-contexts: In the slice, the starting point for the slice is shown in italics, and the empty boxes indicate where program elements have been removed from the original program. In the dependence graph, the edges shown in boldface are the edges in the slice. maintenance [8, 9], debugging [21], testing <ref> [3, 2] </ref>, differencing [11,13], reuse [24], and merging [11]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and related operations.
Reference: 4. <author> Cartwright, R. and Felleisen, M., </author> <title> The semantics of program dependence, </title> <booktitle> Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> ACM SIGPLAN Notices 24(7) pp. </journal> <month> 13-27 (July </month> <year> 1989). </year>
Reference-contexts: Consequently, in this framework the semantics of a slice approximates the semantics of the full program (and never vice versa). - 16 - (Other approaches to lazy semantics for program dependence graphs include [30], <ref> [4] </ref>, and [1].) ` For readers who are uncomfortable with the semantic anomaly that a slice does not preserve the termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the
Reference: 5. <author> Das, M., Reps, T., and Van Hentenryck, P., </author> <title> Semantic foundations of binding-time analysis for imperative programs, pp. </title> <booktitle> 100-110 in Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM 95), </booktitle> <address> (La Jolla, California, June 21-23, 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference-contexts: However, there is a non-standard setting in which the hoped-for relationships do hold. Ramalingam and Reps have defined an equational value-sequence-oriented semantics (as opposed to a conventional state-oriented semantics) for a variant of the program dependence graph [26] (see also <ref> [5] </ref>). Rather than treating each program point as a state-to-state transformer, the value-sequence semantics treats each program point as a value-sequence transformer that takes (possibly infinite) argument sequences from dependence predecessors to a (possibly infinite) output sequence. <p> would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems with non-termination of partial evaluators in the presence of static-infinite computations ([16, pp. 265-266], [31, pp. 501-502], [22, pp. 337], [17, pp. 299], and <ref> [5] </ref>), partial evaluation can introduce divergence. That is, the specializer itself can diverge on programs that would not diverge on all dynamic inputs if executed in their unspecialized form. <p> Another kind of relationship between slicing and partial evaluation has been established by Das, Reps, and Van Hentenryck who showed how three variants of forward slicing can be used to carry out binding-time analysis for imperative programs <ref> [5] </ref>. This paper has been greatly influenced by the literature on partial evaluation and related operations, particularly by Mogensen's paper on program bifurcation [23].
Reference: 6. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 9(3) pp. </pages> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: Program slicing has been studied primarily in the context of imperative programming languages [32]. In such languages, slic ing is typically carried out using program dependence graphs <ref> [18, 25, 6, 12] </ref>.
Reference: 7. <author> Futamura, Y. and Nogi, K., </author> <title> Generalized partial computation, pp. 133-152 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference-contexts: Program Specialization: Program Slicing Versus Partial Evaluation In some circles, the terms program specialization and partial evaluation are treated almost as synonyms, although sometimes program specialization carries the nuance of expressing a broader per spective that encompasses a number of kindred techniques, such as generalized partial evaluation <ref> [7] </ref>, supercompilation [33], bifurcation [23], and deforestation [35]. However, this overlooks an often unappreciated fact, namely that program slicing can also be used to perform a kind of program specializationand one that is different from the kinds of specializations that partial evaluation and its close relatives are capable of performing.
Reference: 8. <author> Gallagher, </author> <title> K.B., Using program slicing in software maintenance, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> CS-90-05, Computer Science Department, University of Maryland, Baltimore Campus, Baltimore, </institution> <note> MD (January 1990). </note>
Reference-contexts: In the slice, the starting point for the slice is shown in italics, and the empty boxes indicate where program elements have been removed from the original program. In the dependence graph, the edges shown in boldface are the edges in the slice. maintenance <ref> [8, 9] </ref>, debugging [21], testing [3, 2], differencing [11,13], reuse [24], and merging [11]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and related operations.
Reference: 9. <author> Gallagher, K.B. and Lyle, J.R., </author> <title> Using program slicing in software maintenance, </title> <journal> IEEE Transactions on Software Engineering SE-17(8) pp. </journal> <month> 751-761 (August </month> <year> 1991). </year>
Reference-contexts: In the slice, the starting point for the slice is shown in italics, and the empty boxes indicate where program elements have been removed from the original program. In the dependence graph, the edges shown in boldface are the edges in the slice. maintenance <ref> [8, 9] </ref>, debugging [21], testing [3, 2], differencing [11,13], reuse [24], and merging [11]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and related operations.
Reference: 10. <author> Horwitz, S., Pfeiffer, P., and Reps, T., </author> <title> Dependence analysis for pointer variables, </title> <booktitle> Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> ACM SIGPLAN Notices - 20 - 24(7) pp. </journal> <month> 28-40 (July </month> <year> 1989). </year>
Reference: 11. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: In the dependence graph, the edges shown in boldface are the edges in the slice. maintenance [8, 9], debugging [21], testing [3, 2], differencing [11,13], reuse [24], and merging <ref> [11] </ref>. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and related operations. <p> Each thread computes a portion of what is computed by the original program. g Horwitz, Reps, and Prins proposed an algorithm for merging two variants A and B of a program Base <ref> [11] </ref>. The algorithm breaks down Base, A, and B into their constituent slices and chooses among them to create the merged program.
Reference: 12. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: 1. Introduction Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not textually contiguous <ref> [37, 25, 12] </ref>. Program slicing has been studied primarily in the context of imperative programming languages [32]. In such languages, slic ing is typically carried out using program dependence graphs [18, 25, 6, 12]. <p> Program slicing has been studied primarily in the context of imperative programming languages [32]. In such languages, slic ing is typically carried out using program dependence graphs <ref> [18, 25, 6, 12] </ref>. <p> elements S con sists of all program elements that might affect (either directly or transitively) the values of the variables used at members of S; (ii) a forward slice with respect to S consists of all program elements that might be affected by the computations performed at members of S <ref> [12] </ref>. For example, a C program and one of its backward slices is shown in Figure 1.
Reference: 13. <author> Horwitz, S., </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proceedings of the ACM SIG-PLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIG-PLAN Notices 25(6) pp. </journal> <month> 234-245 (June </month> <year> 1990). </year>
Reference: 14. <author> Hughes, J., </author> <title> Backwards analysis of functional programs, pp. 187-208 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference-contexts: However, for slicing, we need to propagate projection functions backwardsfrom function outputs to function arguments. Thus, the slicing problem has similarities with the algorithms that propagate projection functions backwards to perform strictness analysis of lazy functional languages [14,34]. Instead of the fixed, finite domain of projection functions used in <ref> [14] </ref> and [34], we will use regular tree grammars (see below), which can be viewed as (representations of) projection functions. <p> The context analysis that we have used to define the slicing algorithm is related to the neededness analysis defined by Hughes <ref> [14] </ref> and also to the strictness analysis of Wadler and Hughes, which is also capable of identifying whether the value of a subexpression is ignored [34, pp. 392]. Our analysis is somewhat different from these two and, in general, incomparable to them.
Reference: 15. <editor> Jones, N.D. and Muchnick, S.S., </editor> <title> Flow analysis and optimization of Lisp-like structures, pp. 102-131 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: In particular, we identify two different goals for what we mean by slicing a functional program and give slicing algorithms that correspond to each of them. g We adapt techniques from shape analysis <ref> [15] </ref>, strictness analysis [34], and program bifurcation [23] so that our slicing algorithms can handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). <p> There are other benefits as well: Past work on shape analysis <ref> [15] </ref>, strictness analysis [34], and program bifurcation [23] for functional programs has developed techniques to handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). We will use similar techniques to formulate a slicing algorithm that can handle programs that use (heap-allocated) lists, trees, and dags. <p> For example, one alternative definition has only singleton nonterminals in each branch of each pair that occurs on the right-hand side of a grammar rule, but allows there to be more than one such pair in each right-hand side <ref> [15] </ref>. This yields a more powerful tree-definition formalism. <p> .N 2 ciic N 3 .N 4 = N 1 .N 2 | N 3 .N 4 - N 1 -.- N 2 - ciic - N 3 -.- N 4 - = - N 1 , N 3 -.- N 2 , N 4 - (a) Jones and Muchnick <ref> [15] </ref> (b) Mogensen [23] Approach (a) forms a right-hand side with multiple alternatives; this preserves the links between N 1 and N 2 and between N 3 and N 4 . <p> In particular, the variant of regular tree grammars that we have used is based on Mogensen's work (as opposed to the version of regular tree grammars used by Jones and Muchnick <ref> [15] </ref> and the normalized set equations used by Reynolds [29]).
Reference: 16. <author> Jones, </author> <title> N.D., Automatic program specialization: A reexamination from basic principles, pp. 225-282 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference: 17. <author> Jones, N.D., Gomard, C.K., and Sestoft, P., </author> <title> Partial Evaluation and Automatic Program Generation, </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, NJ (1993). </address>
Reference-contexts: the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems with non-termination of partial evaluators in the presence of static-infinite computations ([16, pp. 265-266], [31, pp. 501-502], [22, pp. 337], <ref> [17, pp. 299] </ref>, and [5]), partial evaluation can introduce divergence. That is, the specializer itself can diverge on programs that would not diverge on all dynamic inputs if executed in their unspecialized form.
Reference: 18. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference-contexts: Program slicing has been studied primarily in the context of imperative programming languages [32]. In such languages, slic ing is typically carried out using program dependence graphs <ref> [18, 25, 6, 12] </ref>.
Reference: 19. <author> Launchbury, J., </author> <title> Projection Factorizations in Partial Evaluation, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK (1991). </address>
Reference: 20. <author> Liu, Y.A. and Teitelbaum, T., </author> <title> Caching intermediate results for program improvement, </title> <booktitle> in Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM 95), </booktitle> <address> (La Jolla, California, June 21-23, 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference-contexts: Most work on slicing has concerned imperative programming languages. In the context of functional languages, a slicing-like operation is used by Liu and Teitelbaum as a cleanup step in their transformational methodology for deriving incremental versions of functional programs from non-incremental functional programs <ref> [20] </ref>. In their work, slices can be taken only with respect to projection functions that express finite-depth access patterns in a tree. In contrast, the method we have presented uses regular-tree grammars to express projection functions that have arbitrary-depth (but regular) access patterns.
Reference: 21. <author> Lyle, J. and Weiser, M., </author> <title> Experiments on slicing-based debugging tools, </title> <booktitle> in Proceedings of the First Conference on Empirical Studies of Programming, </booktitle> <address> (June 1986), </address> <publisher> Ablex Publishing Co. </publisher> <year> (1986). </year>
Reference-contexts: In the slice, the starting point for the slice is shown in italics, and the empty boxes indicate where program elements have been removed from the original program. In the dependence graph, the edges shown in boldface are the edges in the slice. maintenance [8, 9], debugging <ref> [21] </ref>, testing [3, 2], differencing [11,13], reuse [24], and merging [11]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and related operations.
Reference: 22. <author> Mogensen, T., </author> <title> Partially static structures in a self-applicable partial evaluator, pp. 325-347 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Den-mark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference-contexts: termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems with non-termination of partial evaluators in the presence of static-infinite computations ([16, pp. 265-266], [31, pp. 501-502], <ref> [22, pp. 337] </ref>, [17, pp. 299], and [5]), partial evaluation can introduce divergence. That is, the specializer itself can diverge on programs that would not diverge on all dynamic inputs if executed in their unspecialized form.
Reference: 23. <author> Mogensen, T., </author> <title> Separating binding times in language specifications, pp. </title> <booktitle> 12-25 in Fourth International Conference on Functional Programming and Computer Architecture, </booktitle> <address> (London, UK, </address> <month> Sept. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM Press, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: In particular, we identify two different goals for what we mean by slicing a functional program and give slicing algorithms that correspond to each of them. g We adapt techniques from shape analysis [15], strictness analysis [34], and program bifurcation <ref> [23] </ref> so that our slicing algorithms can handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). <p> Specialization: Program Slicing Versus Partial Evaluation In some circles, the terms program specialization and partial evaluation are treated almost as synonyms, although sometimes program specialization carries the nuance of expressing a broader per spective that encompasses a number of kindred techniques, such as generalized partial evaluation [7], supercompilation [33], bifurcation <ref> [23] </ref>, and deforestation [35]. However, this overlooks an often unappreciated fact, namely that program slicing can also be used to perform a kind of program specializationand one that is different from the kinds of specializations that partial evaluation and its close relatives are capable of performing. Example. <p> There are other benefits as well: Past work on shape analysis [15], strictness analysis [34], and program bifurcation <ref> [23] </ref> for functional programs has developed techniques to handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). We will use similar techniques to formulate a slicing algorithm that can handle programs that use (heap-allocated) lists, trees, and dags. <p> Specifically, we - 6 - will use the variant of regular tree grammars that Mogensen used in his work on program bifurcation <ref> [23] </ref>. 1 A finite tree (or dag) T can be treated formally as a finite prefix-closed set of strings L (T), where L (T) consists of the set of access paths in T. <p> N 3 .N 4 = N 1 .N 2 | N 3 .N 4 - N 1 -.- N 2 - ciic - N 3 -.- N 4 - = - N 1 , N 3 -.- N 2 , N 4 - (a) Jones and Muchnick [15] (b) Mogensen <ref> [23] </ref> Approach (a) forms a right-hand side with multiple alternatives; this preserves the links between N 1 and N 2 and between N 3 and N 4 . <p> That is, our intention is to use regular tree grammars as a way to define sets of access paths, one set per nonterminal. For this purpose, type-(a) grammars are no sharper than type-(b) grammars. In addition, it is computation-ally more expensive to use and manipulate type-(a) grammars <ref> [23] </ref>. (To take advantage of the sharper information of type-(a) grammars, we would have to switch to a scheme in which each projection function corresponds to a set of sets of access paths.) ` 3.2. <p> While no reasonable programming languages have hyper-strict semantics, there do exist programming languages with lazy semantics. 5. A Re-Examination of Program Bifurcation In <ref> [23] </ref>, Mogensen describes a method to perform program bifurcation. <p> This paper has been greatly influenced by the literature on partial evaluation and related operations, particularly by Mogensen's paper on program bifurcation <ref> [23] </ref>. In particular, the variant of regular tree grammars that we have used is based on Mogensen's work (as opposed to the version of regular tree grammars used by Jones and Muchnick [15] and the normalized set equations used by Reynolds [29]).
Reference: 24. <author> Ning, J.Q., Engberts, A., and Kozaczynski, W., </author> <title> Automated support for legacy code understanding, </title> <journal> Commun. of the ACM 37(5) pp. </journal> <month> 50-57 (May </month> <year> 1994). </year>
Reference-contexts: In the dependence graph, the edges shown in boldface are the edges in the slice. maintenance [8, 9], debugging [21], testing [3, 2], differencing [11,13], reuse <ref> [24] </ref>, and merging [11]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and related operations. <p> to all three [27]. g Bates and Horwitz proposed to use slicing to avoid redoing the part of a test suite that is unaffected by a change to a program [2]. g Andersen Consulting's interactive Cobol System Renovation Environment (Cobol/SRE) is a system for re-engineering legacy systems written in Cobol <ref> [24] </ref>. It uses slicing as the fundamental operation that users employ to select program fragments of interest. Operations are provided for combining slices (i.e., union, intersection, and difference). These fragments are then used to reorganize the program by extracting the code fragments and repackaging them into independent modules.
Reference: 25. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: 1. Introduction Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not textually contiguous <ref> [37, 25, 12] </ref>. Program slicing has been studied primarily in the context of imperative programming languages [32]. In such languages, slic ing is typically carried out using program dependence graphs [18, 25, 6, 12]. <p> Program slicing has been studied primarily in the context of imperative programming languages [32]. In such languages, slic ing is typically carried out using program dependence graphs <ref> [18, 25, 6, 12] </ref>.
Reference: 26. <author> Ramalingam, G. and Reps, T., </author> <title> Semantics of program representation graphs, </title> <institution> TR-900, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (December 1989). </note>
Reference-contexts: However, there is a non-standard setting in which the hoped-for relationships do hold. Ramalingam and Reps have defined an equational value-sequence-oriented semantics (as opposed to a conventional state-oriented semantics) for a variant of the program dependence graph <ref> [26] </ref> (see also [5]). Rather than treating each program point as a state-to-state transformer, the value-sequence semantics treats each program point as a value-sequence transformer that takes (possibly infinite) argument sequences from dependence predecessors to a (possibly infinite) output sequence.
Reference: 27. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing and program integration, pp. </title> <booktitle> 360-374 in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 352, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: By selecting appropriate slices, the algorithm guarantees that the merged program exhibits all changed behavior of A with respect to Base, all changed behavior of B with respect to Base, and all behavior that is common to all three <ref> [27] </ref>. g Bates and Horwitz proposed to use slicing to avoid redoing the part of a test suite that is unaffected by a change to a program [2]. g Andersen Consulting's interactive Cobol System Renovation Environment (Cobol/SRE) is a system for re-engineering legacy systems written in Cobol [24].
Reference: 28. <author> Reps, T., </author> <title> Shape analysis as a generalized path problem, pp. </title> <booktitle> 1-11 in Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM 95), </booktitle> <address> (La Jolla, California, June 21-23, 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference: 29. <author> Reynolds, </author> <title> J.C., Automatic computation of data set definitions, pp. </title> <booktitle> 456-461 in Information Processing 68: Proceedings of the IFIP Congress 68, </booktitle> <publisher> North-Holland, </publisher> <address> New York, NY (1968). </address>
Reference-contexts: In particular, the variant of regular tree grammars that we have used is based on Mogensen's work (as opposed to the version of regular tree grammars used by Jones and Muchnick [15] and the normalized set equations used by Reynolds <ref> [29] </ref>). The context analysis that we have used to define the slicing algorithm is related to the neededness analysis defined by Hughes [14] and also to the strictness analysis of Wadler and Hughes, which is also capable of identifying whether the value of a subexpression is ignored [34, pp. 392].
Reference: 30. <author> Selke, </author> <title> R.P, A rewriting semantics for program dependence graphs, pp. </title> <booktitle> 12-24 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: Consequently, in this framework the semantics of a slice approximates the semantics of the full program (and never vice versa). - 16 - (Other approaches to lazy semantics for program dependence graphs include <ref> [30] </ref>, [4], and [1].) ` For readers who are uncomfortable with the semantic anomaly that a slice does not preserve the termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to
Reference: 31. <author> Sestoft, P., </author> <title> Automatic call unfolding in a partial evaluator, pp. 485-506 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference-contexts: not preserve the termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems with non-termination of partial evaluators in the presence of static-infinite computations ([16, pp. 265-266], <ref> [31, pp. 501-502] </ref>, [22, pp. 337], [17, pp. 299], and [5]), partial evaluation can introduce divergence. That is, the specializer itself can diverge on programs that would not diverge on all dynamic inputs if executed in their unspecialized form.
Reference: 32. <author> Tip, F., </author> <title> A survey of program slicing techniques, </title> <journal> Journal of Programming Languages 3 pp. </journal> <month> 121-181 </month> <year> (1995). </year>
Reference-contexts: 1. Introduction Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not textually contiguous [37, 25, 12]. Program slicing has been studied primarily in the context of imperative programming languages <ref> [32] </ref>. In such languages, slic ing is typically carried out using program dependence graphs [18, 25, 6, 12].
Reference: 33. <author> Turchin, </author> <title> V.F., The concept of a supercompiler, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 8(3) pp. </pages> <month> 292-325 (July </month> <year> 1986). </year>
Reference-contexts: Program Specialization: Program Slicing Versus Partial Evaluation In some circles, the terms program specialization and partial evaluation are treated almost as synonyms, although sometimes program specialization carries the nuance of expressing a broader per spective that encompasses a number of kindred techniques, such as generalized partial evaluation [7], supercompilation <ref> [33] </ref>, bifurcation [23], and deforestation [35]. However, this overlooks an often unappreciated fact, namely that program slicing can also be used to perform a kind of program specializationand one that is different from the kinds of specializations that partial evaluation and its close relatives are capable of performing. Example.
Reference: 34. <author> Wadler, P. and Hughes, R.J.M., </author> <title> Projections for strictness analysis, pp. </title> <booktitle> 385-407 in Third Conference on Functional Programming and Computer Architecture, </booktitle> <address> (Portland, OR, </address> <month> Sept. </month> <pages> 14-16, </pages> <year> 1987), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 274, </volume> <editor> ed. G. Kahn,Springer-Verlag, </editor> <address> New York, NY (1987). </address>
Reference-contexts: In particular, we identify two different goals for what we mean by slicing a functional program and give slicing algorithms that correspond to each of them. g We adapt techniques from shape analysis [15], strictness analysis <ref> [34] </ref>, and program bifurcation [23] so that our slicing algorithms can handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). <p> There are other benefits as well: Past work on shape analysis [15], strictness analysis <ref> [34] </ref>, and program bifurcation [23] for functional programs has developed techniques to handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). We will use similar techniques to formulate a slicing algorithm that can handle programs that use (heap-allocated) lists, trees, and dags. <p> Thus, the slicing problem has similarities with the algorithms that propagate projection functions backwards to perform strictness analysis of lazy functional languages [14,34]. Instead of the fixed, finite domain of projection functions used in [14] and <ref> [34] </ref>, we will use regular tree grammars (see below), which can be viewed as (representations of) projection functions. <p> The context analysis that we have used to define the slicing algorithm is related to the neededness analysis defined by Hughes [14] and also to the strictness analysis of Wadler and Hughes, which is also capable of identifying whether the value of a subexpression is ignored <ref> [34, pp. 392] </ref>. Our analysis is somewhat different from these two and, in general, incomparable to them. For instance, the latter analyses are both formulated in terms of a fixed, finite set of projection functions for characterizing neededness patterns of list-manipulation programs.
Reference: 35. <author> Wadler, P., </author> <title> Deforestation: Transforming programs to eliminate trees, </title> <note> Theoretical Computer Science 73 pp. </note> <month> 231-248 </month> <year> (1990). </year>
Reference-contexts: Versus Partial Evaluation In some circles, the terms program specialization and partial evaluation are treated almost as synonyms, although sometimes program specialization carries the nuance of expressing a broader per spective that encompasses a number of kindred techniques, such as generalized partial evaluation [7], supercompilation [33], bifurcation [23], and deforestation <ref> [35] </ref>. However, this overlooks an often unappreciated fact, namely that program slicing can also be used to perform a kind of program specializationand one that is different from the kinds of specializations that partial evaluation and its close relatives are capable of performing. Example.
Reference: 36. <author> Weiser, M., </author> <title> Reconstructing sequential behavior from parallel behavior projections, </title> <note> Information Processing Letters 17 pp. </note> <month> 129-135 (October </month> <year> 1983). </year> <month> - 21 </month> - 
Reference-contexts: This is done merely to give the simplest possible example of the differences between BifS and BifS. - 18 - g Weiser proposed using slicing to decompose programs into separate threads that can be run in parallel <ref> [36] </ref>. Each thread computes a portion of what is computed by the original program. g Horwitz, Reps, and Prins proposed an algorithm for merging two variants A and B of a program Base [11].
Reference: 37. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: 1. Introduction Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not textually contiguous <ref> [37, 25, 12] </ref>. Program slicing has been studied primarily in the context of imperative programming languages [32]. In such languages, slic ing is typically carried out using program dependence graphs [18, 25, 6, 12]. <p> We can actually identify two different goals for what we mean by slicing a functional program, which we call Type I and Type II slices. In Weiser's original definition of slicing for imperative programs, a slice is obtained from the original program by deleting zero or more statements <ref> [37, pp. 353] </ref>. Type I slicing is the analogue for functional programs of Weiser's slicing operation: subexpressions of the program, rather than statements, are deleted.
References-found: 37

