URL: http://simon.cs.cornell.edu/Info/People/pientka/note1.ps
Refering-URL: http://simon.cs.cornell.edu/Info/People/pientka/
Root-URL: 
Email: fpientka,kreitzg@cs.cornell.edu  
Title: Instantiation of existentially quantified variables in inductive specification proofs  
Author: Brigitte Pientka and Christoph Kreitz 
Address: Ithaca, NY 14853-7501, U.S.A.  
Affiliation: Department of Computer Science, Cornell University  
Abstract: We present an automatic approach for instantiating existentially quantified variables in inductive specifications proofs. Our approach uses first-order meta-variables in place of existentially quantified variables and combines logical proof search with rippling techniques. We can avoid the non-termination problems which usually occur in the presence of existentially quantified variables. Moreover, we are able to synthesize conditional substitutions for the meta-variables. We illustrate our approach by discussing the specification of the integer square root. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Armando, A. Smaill, and I. Green. </author> <title> Automatic synthesis of recursive programs: The proof-planning paradigm. </title> <booktitle> In Proceedings of the twelfth IEEE International Automated Software Engineering Conference, </booktitle> <address> Incline Village, Nevada, </address> <pages> pages 2-9. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1997. </year>
Reference-contexts: This does not matter if we are just interested in provabil-ity. In program synthesis, however, the identity of the existential witness plays a vital role of defining the program to be synthesized. Other approaches <ref> [1, 12, 18] </ref> use meta-annotations; the existentially quantified variable x is replaced by F (X) where capital letters indicate meta-variables. Middle-out reasoning [11] is used in order to instantiate the function F and its argument X. This problem requires a computationally expensive higher-order unification.
Reference: 2. <author> David Basin and Toby Walsh. </author> <title> A calculus for and termination of rippling. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 16(2) </volume> <pages> 147-180, </pages> <year> 1996. </year>
Reference-contexts: Rippling terminates unsuccessfully if the rewriting process is blocked, i.e. no wave-rule is applicable anymore and the induction hypothesis (given) does not match the induction conclusion (goal). In Basin & Walsh <ref> [2] </ref>, a calculus for rippling is presented and well-founded measure, called wave measure is defined, under which rippling terminates if no meta-variables occur in the goal. The wave measure associates weights to the wave-fronts to measure the width and the size of the wave-front.
Reference: 3. <author> Joseph L. Bates and Robert L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: A program meeting this specification can be extracted from its proof via the proofs-as-programs principle <ref> [3] </ref>. This style is widely advocated [15] and supported in a number of implementations such as NuPRL [10]. The application of such systems however is limited by its low degree of automation. In order to overcome this drawback, we suggest incorporating techniques from inductive theorem proving.
Reference: 4. <author> Wolfgang Bibel, Daniel Korn, Christoph Kreitz, Ferenc Kurucz, Jens Otten, Stephan Schmitt, and Gerd Stolpmann. </author> <title> A multi-level approach to program synthesis. </title> <booktitle> In Seventh International Workshop on Logic Program Synthesis and Transformation (LOPSTR'97), </booktitle> <address> Leuven, Belgium, </address> <month> July </month> <year> 1997, </year> <booktitle> Lecture Notes in Artificial Intelligence, </booktitle> <year> 1998. </year>
Reference-contexts: Y R R R R R R formula C i . Thirdly, an extended matching procedure returns an instantiation for the meta-variables and a sequence of rippling steps by reasoning backwards from the induction hypothesis towards C i . For rippling we use the rippling-distance strategy <ref> [13, 4] </ref>. Each wave-front is mapped to a selected (goal)-sink. The distance between a wave-front and its assigned (goal) sink in the term tree is called distance measure.
Reference: 5. <author> Susanne Biundo. </author> <title> Automated synthesis of recursive algorithms as a theorem proving tool. </title> <booktitle> In Proceedings of the 8th European Conference on Artificial Intelligence, </booktitle> <address> Munchen, Germany, </address> <year> 1988. </year>
Reference-contexts: prove the specification of the integer square root and log 2 by using non-standard induction schemes allowing us to synthesize while loops and binary search algorithms for these two specifications. 7 Related Work One of the first approaches to automate the instantiation of existentially quantified variables has been by Biundo <ref> [5] </ref>. Existentially quantified variables are replaced by Skolem functions which describe the program which is to be synthesized. After induction the formula in the step case is put into clausal form. The synthesis proceeds by clause-set translations (e.g. rewriting and case splitting) which induce an AND/OR search space. <p> This approach builds on higher-order embeddings and higher-order rippling. Middle-out reasoning and higher order embeddings have the disadvantage of a big search space, as rippling in the presence of higher-order function variables does not terminate. As the underlying theory in the approaches from Biundo <ref> [5] </ref> and Kraan et al. [12] does not guarantee that the synthesized program is correct, it has to be verified after the synthesis. We believe that constructive type theory provides a firmer mathematical foundation than is found in these systems.
Reference: 6. <author> Alan Bundy, Andrew Stevens, Frank van Harmelen, Alan Smaill, and Andrew Ireland. Rippling: </author> <title> A heuristic for guiding inductive proofs. </title> <journal> Artificial Intelligence, </journal> <volume> 62(2) </volume> <pages> 185-253, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Both expressions are equal after some rewriting steps. The crucial question is how can we find a chain of rewriting steps, such that both expressions can be made equal by rewriting in the presence of meta-variables. In inductive theorem proving, an annotated rewriting technique, called rippling <ref> [9, 6] </ref>, has been used successfully in order to control the rewriting process. However, only little focus has been devoted to the automatic instantiation of existentially quantified variables. <p> Rewriting is restricted such that each application of a wave-rule is skeleton preserving and measure decreasing according to the defined wave measure. For instantiating existentially quantified variables via rippling, mainly two approaches have been suggested in the literature. In Bundy et al. <ref> [6] </ref> special existential wave-rules are suggested. Existential wave-rules can be derived from non-existential wave-rules.
Reference: 7. <author> Alan Bundy, Frank van Harmelen, Jane Hesketh, Alan Smail, and Andrew Stevens. </author> <title> A rational reconstruction and extension of recursion analysis. </title> <booktitle> In Proceedings of the 11th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 359-365. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1989. </year>
Reference-contexts: Different induction schemes result in algorithms which differ in their complexity. The base cases of the induction correspond to the base cases in the recursive program while the step cases correspond to the recursive cases. Recursion analysis <ref> [7, 20] </ref> identifies automatically appropriate induction schemes. However there has not much work been done to determine automatically induction schemes which result in efficient algorithms. In this paper we focus on the second crucial step during a specification proof, the instantiation of the existentially quantified variables.
Reference: 8. <author> Alan Bundy, Frank van Harmelen, C. Horn, and Alan Smaill. </author> <title> The Oyster-Clam system. </title> <booktitle> In Proceedings of the 10th International Conference on Automated Deduction, Kaiserslautern, </booktitle> <pages> pages 647-648. </pages> <publisher> Springer, </publisher> <address> 1990. </address> <publisher> LNAI 449. </publisher>
Reference-contexts: Because rippling is a highly goal directed rewriting technique with only little search involved, our approach is more controlled. From the systems which rely on the programs-as-proofs paradigm, only a few systems support automation. The closest system to NuPRL is the Oyster/Clam system <ref> [8] </ref> which started out as a re-implementation of NuPRL. Two major approaches evolved from this work. In Kraan et al.[12], also existentially quantified variables are replaced by Skolem functions for the synthesis of logical programs. Middle-out reasoning [11] is used to construct predicate definitions from specifications in classical logic.
Reference: 9. <author> Alan Bundy, Frank van Harmelen, Alan Smaill, and Andrew Ireland. </author> <title> Extensions to the rippling-out tactic for guiding inductive proofs. </title> <booktitle> In Proceedings of the 10th International Conference on Automated Deduction, Kaiserslautern, </booktitle> <pages> pages 132-146. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: Both expressions are equal after some rewriting steps. The crucial question is how can we find a chain of rewriting steps, such that both expressions can be made equal by rewriting in the presence of meta-variables. In inductive theorem proving, an annotated rewriting technique, called rippling <ref> [9, 6] </ref>, has been used successfully in order to control the rewriting process. However, only little focus has been devoted to the automatic instantiation of existentially quantified variables. <p> In each iteration y is incremented until (y + 1) 2 &gt; x. This example illustrates that the conventional approach <ref> [9] </ref> to instantiate uni-versally quantified variables in the induction hypothesis by rippling-in is not expressive enough. Moreover, it supports the strength of our approach.
Reference: 10. <author> R. L. Constable, S. F. Allen, H. M. Bromley, and et al. </author> <title> Implementing Meta-Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <pages> 1086. </pages>
Reference-contexts: A program meeting this specification can be extracted from its proof via the proofs-as-programs principle [3]. This style is widely advocated [15] and supported in a number of implementations such as NuPRL <ref> [10] </ref>. The application of such systems however is limited by its low degree of automation. In order to overcome this drawback, we suggest incorporating techniques from inductive theorem proving. The first difficult step within a proof is the choice of the appropriate induction scheme.
Reference: 11. <author> Jane T. Hesketh. </author> <title> Using Middle-Out Reasoning to Guide Inductive Theorem Proving. </title> <type> PhD thesis, </type> <institution> Dept. of Artificial Intelligence, University of Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: In program synthesis, however, the identity of the existential witness plays a vital role of defining the program to be synthesized. Other approaches [1, 12, 18] use meta-annotations; the existentially quantified variable x is replaced by F (X) where capital letters indicate meta-variables. Middle-out reasoning <ref> [11] </ref> is used in order to instantiate the function F and its argument X. This problem requires a computationally expensive higher-order unification. The presence of higher-order variables also leads to non-termination of rippling, as the width and the size of the wave-front cannot be determined. <p> The closest system to NuPRL is the Oyster/Clam system [8] which started out as a re-implementation of NuPRL. Two major approaches evolved from this work. In Kraan et al.[12], also existentially quantified variables are replaced by Skolem functions for the synthesis of logical programs. Middle-out reasoning <ref> [11] </ref> is used to construct predicate definitions from specifications in classical logic. In Smail & Green [18], an approach for the synthesis of functional programs within the framework of Oyster/Clam is suggested. This approach builds on higher-order embeddings and higher-order rippling.
Reference: 12. <author> I. Kraan, D. Basin, and A. Bundy. </author> <title> Logic program synthesis via proof planning. </title> <editor> In K. K. Lau and T. Clement, editors, </editor> <booktitle> Logic Program Synthesis and Transformation, </booktitle> <pages> pages 1-14. </pages> <publisher> Springer, </publisher> <year> 1993. </year> <note> also available as Max-Planck Institut fur Informatik Report MPI-I-92-244 and Edinburgh DAI Research Report 603. </note>
Reference-contexts: This does not matter if we are just interested in provabil-ity. In program synthesis, however, the identity of the existential witness plays a vital role of defining the program to be synthesized. Other approaches <ref> [1, 12, 18] </ref> use meta-annotations; the existentially quantified variable x is replaced by F (X) where capital letters indicate meta-variables. Middle-out reasoning [11] is used in order to instantiate the function F and its argument X. This problem requires a computationally expensive higher-order unification. <p> This approach builds on higher-order embeddings and higher-order rippling. Middle-out reasoning and higher order embeddings have the disadvantage of a big search space, as rippling in the presence of higher-order function variables does not terminate. As the underlying theory in the approaches from Biundo [5] and Kraan et al. <ref> [12] </ref> does not guarantee that the synthesized program is correct, it has to be verified after the synthesis. We believe that constructive type theory provides a firmer mathematical foundation than is found in these systems. Moreover, our approach is much more controlled because of the rippling and extended matching strategy. <p> By combining logical proof search methods with rippling techniques, we are able to synthesize case splits which cannot be derived by other comparable systems. In approaches from Kraan et al. <ref> [12] </ref> and Smaill & Green [18], the aim is to ripple the whole induction conclusion and aim for a match of the whole induction conclusion with the entire induction hypothesis. The underlying logical calculus is not used to decompose the step case during proof search.
Reference: 13. <author> Ferenc Kurucz. </author> <title> Realisierung verschiedender Induktionsstrategien basierend auf dem Rippling-Kalkul. </title> <type> Master's thesis, </type> <institution> Technical University Darmstadt, </institution> <year> 1997. </year>
Reference-contexts: Y R R R R R R formula C i . Thirdly, an extended matching procedure returns an instantiation for the meta-variables and a sequence of rippling steps by reasoning backwards from the induction hypothesis towards C i . For rippling we use the rippling-distance strategy <ref> [13, 4] </ref>. Each wave-front is mapped to a selected (goal)-sink. The distance between a wave-front and its assigned (goal) sink in the term tree is called distance measure. <p> The tactic exL decomposes the existential quantifier on the left hand side. Applications of andL resp. andR eliminate the conjunction on the left resp. right hand side. The generated rippling sequence is translated back into sequent proof by cut, substitution and lemma applications as described in <ref> [13] </ref>. Other examples, that can be solved by our method include the specification of quotient remainder, append, half, or last. These examples do not require any case splits. We also can prove the specification for log 2 which results in a similar proof to the integer square root example.
Reference: 14. <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In 6-th International Congress for Logic, Methodology and Philosophy of Science, </booktitle> <year> 1979, </year> <pages> pages 153-175. </pages> <publisher> North-Holland, </publisher> <year> 1982. </year>
Reference-contexts: 1 Introduction Constructive type theory <ref> [14] </ref> offers the unique advantage of total correctness of synthesized programs. In this setting a specification is of the form 8input: 9output: spec (input; output) where input is a vector of arguments, output is a result and spec is a proposition describing the required relation between them.
Reference: 15. <author> Bengt Nordstrom, Kent Petersson, and Jan M. Smith. </author> <title> Programming in Martin-Lofs Type Theory. An introduction. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1990. </year>
Reference-contexts: A program meeting this specification can be extracted from its proof via the proofs-as-programs principle [3]. This style is widely advocated <ref> [15] </ref> and supported in a number of implementations such as NuPRL [10]. The application of such systems however is limited by its low degree of automation. In order to overcome this drawback, we suggest incorporating techniques from inductive theorem proving.
Reference: 16. <author> Jens Otten and Christoph Kreitz. </author> <title> A Uniform Proof Procedure for Classical and Non-classical Logics. </title> <editor> In G. G rz & S. H lldobler, editor, KI-96: </editor> <booktitle> Advances in Artificial Intelligence, volume 1137 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 307-319. </pages> <publisher> Springer, </publisher> <year> 1996. </year> <note> Also technical report AIDA-96-02. </note>
Reference-contexts: This approach allows us to treat meta-variables uniformly. We plan to extend and refine our method in this direction. Moreover, we plan to explore the use of specially tailored logical proof search methods such as connection method <ref> [16] </ref> or resolution [19] instead of direct proof search in the sequent calculus. These proof methods are more goal directed. For future research we aim to combine these techniques with rippling and our extended matching algorithm.
Reference: 17. <author> Brigitte Pientka. </author> <title> Automatic instantiation of meta-variables in specification proofs. </title> <type> Technical report, </type> <institution> Cornell University, </institution> <year> 1998. </year>
Reference-contexts: Moreover, by a simple heuristic, which is integrated in check subgoals we are able to synthesize conditional substitutions. These conditions form a case split in the proof. For a more detailed version we refer to <ref> [17] </ref>. 6 Integrating in NuPRL In this section we discuss the integration of our proof method into NuPRL, an interactive, tactic based theorem prover. The described proof procedure is embedded within the tactic Ripple.
Reference: 18. <author> Allan Smaill and Ian Green. </author> <title> Automating the synthesis of functional programs. </title> <type> Research paper 777, </type> <institution> Dept. of Artificial Intelligence, University of Edinburgh, </institution> <year> 1995. </year>
Reference-contexts: This does not matter if we are just interested in provabil-ity. In program synthesis, however, the identity of the existential witness plays a vital role of defining the program to be synthesized. Other approaches <ref> [1, 12, 18] </ref> use meta-annotations; the existentially quantified variable x is replaced by F (X) where capital letters indicate meta-variables. Middle-out reasoning [11] is used in order to instantiate the function F and its argument X. This problem requires a computationally expensive higher-order unification. <p> Two major approaches evolved from this work. In Kraan et al.[12], also existentially quantified variables are replaced by Skolem functions for the synthesis of logical programs. Middle-out reasoning [11] is used to construct predicate definitions from specifications in classical logic. In Smail & Green <ref> [18] </ref>, an approach for the synthesis of functional programs within the framework of Oyster/Clam is suggested. This approach builds on higher-order embeddings and higher-order rippling. <p> By combining logical proof search methods with rippling techniques, we are able to synthesize case splits which cannot be derived by other comparable systems. In approaches from Kraan et al. [12] and Smaill & Green <ref> [18] </ref>, the aim is to ripple the whole induction conclusion and aim for a match of the whole induction conclusion with the entire induction hypothesis. The underlying logical calculus is not used to decompose the step case during proof search.
Reference: 19. <author> T. Tammet. </author> <title> A resolution theorem prover for intuitionistic logic. </title> <booktitle> In Proceedings of the 13th International Conference on Automated Deduction, </booktitle> <address> New Brunswick, NJ, </address> <month> July </month> <year> 1996, </year> <booktitle> volume 1104 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 2-16, </pages> <year> 1996. </year>
Reference-contexts: This approach allows us to treat meta-variables uniformly. We plan to extend and refine our method in this direction. Moreover, we plan to explore the use of specially tailored logical proof search methods such as connection method [16] or resolution <ref> [19] </ref> instead of direct proof search in the sequent calculus. These proof methods are more goal directed. For future research we aim to combine these techniques with rippling and our extended matching algorithm.
Reference: 20. <author> Christoph Walther. </author> <title> Computing induction axioms. </title> <booktitle> In Proceedings of the Conference on Logic Programming and Automated Reasoning, </booktitle> <address> St. Petersburg, </address> <publisher> LNAI 624. Springer, </publisher> <year> 1992. </year>
Reference-contexts: Different induction schemes result in algorithms which differ in their complexity. The base cases of the induction correspond to the base cases in the recursive program while the step cases correspond to the recursive cases. Recursion analysis <ref> [7, 20] </ref> identifies automatically appropriate induction schemes. However there has not much work been done to determine automatically induction schemes which result in efficient algorithms. In this paper we focus on the second crucial step during a specification proof, the instantiation of the existentially quantified variables.
References-found: 20

