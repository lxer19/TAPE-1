URL: http://osl.cs.uiuc.edu/Papers/wpc.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Parallel.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: f agha j houck j panwarg@cs.uiuc.edu  
Title: Distributed Execution of Actor Programs  
Author: Gul Agha, Chris Houck and Rajendra Panwar 
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Abstract: A number of programming language models, including actors, provide inherent con-currency. We are developing high-level language constructs using actors and studying their implementation on multiprocessor architectures. This report describes our experience with programming in actors by means of a specific example of scientific computation. We also discuss work in progress on language annotations and compilation technology for efficient program execution on multiprocessors.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: This allows concurrent execution of actions specified within the body of the actor. The concept of actors was originally proposed by Hewitt in [9]. The actor model was formally characterized by means of power domain semantics in [6], by a transition system in <ref> [1] </ref>, and by Colored Petri Nets in [13]. Complexity measures for actor programs have been studied in [5]. The model has also been proposed as a basis for multiparadigm programming in [2] and has been used as a programming model for multicomputers in [4] and [7]. <p> Once a4 a7 are created, there is at least one actor in each processor and subsequent actors are created locally on each processor. The final value of the sum of the array elements is returned to a1 because of the implicit continuations provided by the function call mechanism <ref> [1] </ref>. 4 Cholesky Decomposition of an SPD Matrix We now discuss an example, the Cholesky Decomposition (CD) of a Symmetric Positive Definite (SPD) matrix, to illustrate how the actor model enables us to represent different ways of solving the problem in parallel. <p> An actor's behavior specifies new tasks to create and communications to send as a function of its local state and the message being processed. Upon receipt of a message, an actor may replace its current behavior with a new behavior that is used to process all subsequent messages <ref> [1] </ref>. In Rosette, this is done with the become primitive. It is assumed that if an actor does not specify a replacement behavior with a become , its behavior is the same as its current behavior.
Reference: [2] <author> G. Agha. </author> <title> Supporting multiparadigm programming on actor architectur es. </title> <booktitle> In Proceedings of Parallel Architectures and Langua ges Europe, Vol. II: Parallel Languages (PARLE '89), </booktitle> <pages> pages 1-19. </pages> <address> Espirit, </address> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> LNCS 366. </note>
Reference-contexts: Complexity measures for actor programs have been studied in [5]. The model has also been proposed as a basis for multiparadigm programming in <ref> [2] </ref> and has been used as a programming model for multicomputers in [4] and [7]. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors [16]. The following code-fragment gives a flavor of the Rosette language.
Reference: [3] <author> G. Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Replacement is a serialization mechanism which supports a trivial pipelining of the replacement actions: the aggregation of changes allows an easy determination of when we have finished computing the state of an actor and are ready to take the next action <ref> [3] </ref>. For example, as soon as the bank account actor has computed the new balance in the account, it is free to process the next request even if other actions implied by the withdrawal request are still being carried out.
Reference: [4] <author> W. Athas and C. Seitz. </author> <title> Multicomputers: Message-passing concurrent computers. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 9-23, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Complexity measures for actor programs have been studied in [5]. The model has also been proposed as a basis for multiparadigm programming in [2] and has been used as a programming model for multicomputers in <ref> [4] </ref> and [7]. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors [16]. The following code-fragment gives a flavor of the Rosette language.
Reference: [5] <author> F. Baude and G Vidal-Naquet. </author> <title> Actors as a parallel programming model. </title> <booktitle> In Proceedings of 8th Symposium on Theoretical Aspects of Computer Science, </booktitle> <year> 1991. </year> <note> LNCS 480. </note>
Reference-contexts: The concept of actors was originally proposed by Hewitt in [9]. The actor model was formally characterized by means of power domain semantics in [6], by a transition system in [1], and by Colored Petri Nets in [13]. Complexity measures for actor programs have been studied in <ref> [5] </ref>. The model has also been proposed as a basis for multiparadigm programming in [2] and has been used as a programming model for multicomputers in [4] and [7]. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors [16].
Reference: [6] <author> W. D. Clinger. </author> <title> Foundations of actor semantics. </title> <type> AI-TR- 633, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1981. </year>
Reference-contexts: This allows concurrent execution of actions specified within the body of the actor. The concept of actors was originally proposed by Hewitt in [9]. The actor model was formally characterized by means of power domain semantics in <ref> [6] </ref>, by a transition system in [1], and by Colored Petri Nets in [13]. Complexity measures for actor programs have been studied in [5].
Reference: [7] <author> W. Dally. </author> <title> A VLSI Architecture for Concurrent Data Structures. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: Complexity measures for actor programs have been studied in [5]. The model has also been proposed as a basis for multiparadigm programming in [2] and has been used as a programming model for multicomputers in [4] and <ref> [7] </ref>. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors [16]. The following code-fragment gives a flavor of the Rosette language.
Reference: [8] <author> G. Golub and C. Van Loan. </author> <title> Matrix Computations. </title> <publisher> The Johns Hopkins University Press, </publisher> <year> 1983. </year>
Reference-contexts: Assume A is a symmetric positive definite matrix of size n fi n. The following algorithm computes a lower triangular matrix G, of size n fi n such that A = GG T <ref> [8] </ref>. Since A is a symmetric matrix, it can be stored as a lower triangular matrix. <p> We discuss ways of computing CD of dense matrices in parallel. at hand. With a two dimensional mesh of n 2 processors <ref> [8] </ref>, the algorithm takes O (n 2 ) time if all the steps of one iteration are completed before starting the next one. Pipelining the execution of different iterations gives an O (n) time parallel implementation.
Reference: [9] <author> C. E. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3) </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference-contexts: This allows concurrent execution of actions specified within the body of the actor. The concept of actors was originally proposed by Hewitt in <ref> [9] </ref>. The actor model was formally characterized by means of power domain semantics in [6], by a transition system in [1], and by Colored Petri Nets in [13]. Complexity measures for actor programs have been studied in [5].
Reference: [10] <author> P. Hudak. </author> <title> Para-functional programming. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 60-70, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: In our current work, we provide the programmer with the ability to abstractly annotate actor programs to govern actor placement and their migration. This is similar to the notation used in the language Logo and later incorporated in other languages such as ParAlfl <ref> [10] </ref>. The syntax for providing annotations to actor programs is: &lt;expr1&gt; @ &lt;expr2&gt; where &lt;expr1&gt; represents a message send (or function application) or an expression that creates a new actor, and &lt; expr2 &gt; evaluates to a processor number PID.
Reference: [11] <author> Intel Corporation, </author> <title> Beaverton, Oregon. iPSC/2 C Programmers reference manual, </title> <booktitle> 1988. Order Number: </booktitle> <pages> 311017-002. </pages>
Reference-contexts: The intel iPSC also provides the ability to choose specific (tagged) messages out of the mail 13 box <ref> [11] </ref>, thus allowing a user to handle arrival order non-determinism efficiently. However, programmers have to specify explicit processor addresses with every message that is sent across nodes.
Reference: [12] <author> Carl Manning. Acore: </author> <title> The design of a core actor language and its compil er. </title> <type> Master's thesis, </type> <institution> MIT, Artificial Intelligence Laboratory, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Actors as Records. An alternative scheme which addresses these problems represents each actor as a record containing a local variable bound to the address of its current behavior and the actor's current local variables. This representation is used in actor languages such as Acore <ref> [12] </ref>. Each behavior type is represented by a different process. The execution of an actor system is controlled by drivers which maintain lists of local actors and the messages 12 to them. All messages to an individual actor are sent to the driver which is responsible for that actor.
Reference: [13] <author> Y. Sami and G. </author> <title> Vidal-Naquet. Formalisation of the behaviour of actors by colored petri nets and some applications. </title> <booktitle> In Proceedings of Parallel Architectures and Languages Europe, (PARLE '91), </booktitle> <year> 1991. </year>
Reference-contexts: The concept of actors was originally proposed by Hewitt in [9]. The actor model was formally characterized by means of power domain semantics in [6], by a transition system in [1], and by Colored Petri Nets in <ref> [13] </ref>. Complexity measures for actor programs have been studied in [5]. The model has also been proposed as a basis for multiparadigm programming in [2] and has been used as a programming model for multicomputers in [4] and [7].
Reference: [14] <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and synchronization with enabled-sets. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: We use a mechanism called enabled sets in Rosette for imposing order on the processing of messages <ref> [14] </ref>. The following code uses the block construct which packages a set of expressions which are evaluated concurrently. <p> While there are typically few behavior redefinitions in practice, this method can entail a significant performance loss if the network gets filled with messages getting forwarded from previous behaviors to new ones. Furthermore, it is not clear how to implement enabled-sets and inheritance under such a scheme <ref> [14] </ref>. Actors as Records. An alternative scheme which addresses these problems represents each actor as a record containing a local variable bound to the address of its current behavior and the actor's current local variables. This representation is used in actor languages such as Acore [12].
Reference: [15] <author> P. Vaidya. </author> <title> Solving linear equations with symmetric diagonally dominant matrices by constructing good preconditioners. </title> <type> Technical report, </type> <institution> University of Illinois Department of Computer Science, </institution> <note> In Preparation. </note>
Reference-contexts: Most of the problems involving large systems of equations have very few non-zero elements in the matrices and require methods for solving sparse linear systems. But some of the methods used for solving sparse systems of equations (e.g. <ref> [15] </ref>) require solution of a dense block of equations as an intermediate step. Depending on the size and structure of the original systems of equations, this dense block may be huge and sequential solution of such a block may reduce the overall speedup significantly.
Reference: [16] <author> C. Tomlinson W. Kim M. Schevel V. Singh B. Will and G. Agha. Rosette: </author> <title> An object oriented concurrent system architecture. </title> <journal> Sigplan Notices, </journal> <volume> 24(4) </volume> <pages> 91-93, </pages> <year> 1989. </year> <month> 15 </month>
Reference-contexts: The model has also been proposed as a basis for multiparadigm programming in [2] and has been used as a programming model for multicomputers in [4] and [7]. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors <ref> [16] </ref>. The following code-fragment gives a flavor of the Rosette language. It defines a class of actors, Add-Counter which accept two types of messages and has an acquaintance (cf. local variable) called count , initially set to zero.
References-found: 16

