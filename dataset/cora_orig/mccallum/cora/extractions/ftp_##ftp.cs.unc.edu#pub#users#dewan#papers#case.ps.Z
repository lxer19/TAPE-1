URL: ftp://ftp.cs.unc.edu/pub/users/dewan/papers/case.ps.Z
Refering-URL: http://www.cs.unc.edu/~dewan/res.html
Root-URL: http://www.cs.unc.edu
Title: Designing and Implementing Multi-User Applications: A Case Study  
Author: PRASUN DEWAN 
Keyword: Key Words: CSCW, distributed objects, groupware, office automation, mail systems, user interfaces, views.  
Address: W. Lafayette, IN 47907  
Affiliation: Department of Computer Sciences, Purdue University,  
Abstract: We have developed a new multi-user application that integrates and extends the concepts in a variety of current multi-user applications. It allows multiple users to store, retrieve, and browse through information, communicate information both synchronously and asynchronously, create ``pipes'' of consistent, editable, and persistent views, and interactively specify handlers for events. It has been implemented using the experimental technologies of distributed objects and multi-user editor generation. Our work on this application suggests a new and practical model for designing and implementing multi-user applications. In this paper, we describe the user interface and implementation of the application, give the rationale for our design choices, describe our experience with the tools and techniques used in the implementation, and present conclusions and directions for future work. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.T. Almes, A.P Black, E.D. Lazowska, and J.D. Noe, </author> <title> ``The Eden System: A Technical Overview,'' </title> <journal> IEEE Transactions on Software Engineering 11:1 (January 1985), </journal> <pages> pp. 43-59. </pages>
Reference-contexts: We have implemented the visitor application using the experimental technologies of distributed objects and multi-user editor generation offered by Suite [6, 8]. Both technologies are relatively untested. The only reported applications of distributed objects known to us are the Eden <ref> [1] </ref> and Clouds [4] distributed operating systems, the Edmas distributed mail system [2], the CES multi-user document editor [12], and the simple object-based Suite applications described in [7]. <p> Moreover, they are persistent, are automatically activated and passivated, serialize execution of methods, communicate with each other using a high-level RPC interface, and have protected hierarchical names in a network file system. The Suite object model is closely related to the Argus [19], Eden <ref> [1] </ref>, and Clouds [4] distributed-object models. Its distinguishing feature is that it has been designed to be compatible with conventional (UNIX-like) operating systems [6]. Suite objects seemed ideal for encapsulating visitor information since they did not have the problems of files and relations.
Reference: [2] <author> G. T. Almes and C. L. Holman, ``Edmas: </author> <title> An Object-Oriented, Locally Distributed Mail System,'' </title> <journal> IEEE Transactions on Software Engineering 13:9 (September 1987), </journal> <pages> pp. 1001-1009. </pages>
Reference-contexts: Both technologies are relatively untested. The only reported applications of distributed objects known to us are the Eden [1] and Clouds [4] distributed operating systems, the Edmas distributed mail system <ref> [2] </ref>, the CES multi-user document editor [12], and the simple object-based Suite applications described in [7]. Moreover, to the best of our knowledge, generation of multi-user editors is unique to Suite and has so far been used to generate only simple demonstration applications such as the ones mentioned in [8].
Reference: [3] <author> L. Brothers, V. Sembugamoorthy, and M. Muller, ``ICICLE: </author> <title> Groupware for Code Inspection,'' </title> <booktitle> Proceedings of the ACM Conference on Computer Supported Cooperative Work, </booktitle> <month> October </month> <year> 1990, </year> <pages> pp. 169-181. </pages>
Reference-contexts: Recent experimental multi-user applications include synchronous meeting schedulers such as RTCAL [26], synchronous document editors such as Cognoter [28], CES [12], Mercury [13], MACE [22], and GROVE [10], asynchronous multi-user document editors such as PREP [21], and synchronous code browsers such as ICICLE <ref> [3] </ref>.
Reference: [4] <author> P. Dasgupta, R. C. Chen, S. Menon, M. P. Pearson, R. Ananthanarayanan, U. Ramachandran, M. Ahamad, R. J. LeBlanc, W. F. Appelbe, J. M. Bernabeu-Auban, P. W. Hutto, M. Y. A. Khalidi, and C. J. Wilkenloh, </author> <booktitle> ``The Design and Implementation of the Clouds Distributed Operating System ,'' Usenix Computing Systems 3:1 (Winter 1990), </booktitle> <pages> pp. 11-46. </pages> <note> P. Dewan Multi-User Applications d 18 </note>
Reference-contexts: We have implemented the visitor application using the experimental technologies of distributed objects and multi-user editor generation offered by Suite [6, 8]. Both technologies are relatively untested. The only reported applications of distributed objects known to us are the Eden [1] and Clouds <ref> [4] </ref> distributed operating systems, the Edmas distributed mail system [2], the CES multi-user document editor [12], and the simple object-based Suite applications described in [7]. <p> Moreover, they are persistent, are automatically activated and passivated, serialize execution of methods, communicate with each other using a high-level RPC interface, and have protected hierarchical names in a network file system. The Suite object model is closely related to the Argus [19], Eden [1], and Clouds <ref> [4] </ref> distributed-object models. Its distinguishing feature is that it has been designed to be compatible with conventional (UNIX-like) operating systems [6]. Suite objects seemed ideal for encapsulating visitor information since they did not have the problems of files and relations.
Reference: [5] <author> T. DeMarco and T. Lister, Peopleware: </author> <title> Productive Projects and Teams, </title> <publisher> Dorset House Publishing Co., </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: INTRODUCTION Multi-user applications offer the opportunity to automate the large number of group activities carried out by people <ref> [5] </ref>. However, few traditional or experimental multi-user applications have been developed so far. Traditional multi-user applications include command and query interpreters allowing users to store and retrieve shared information, and talk and mail programs allowing users to exchange information synchronously and asynchronously, respectively.
Reference: [6] <author> Prasun Dewan and Eric Vasilik, </author> <title> ``An Object Model for Conventional Operating Systems,'' </title> <booktitle> Usenix Computing Systems 3:4 (Dec 1990), </booktitle> <pages> pp. 517-549. </pages>
Reference-contexts: The application offers varying degrees of computer support for the group task, thereby allowing current users to incrementally learn and use the various aspects of the application. We have implemented the visitor application using the experimental technologies of distributed objects and multi-user editor generation offered by Suite <ref> [6, 8] </ref>. Both technologies are relatively untested. The only reported applications of distributed objects known to us are the Eden [1] and Clouds [4] distributed operating systems, the Edmas distributed mail system [2], the CES multi-user document editor [12], and the simple object-based Suite applications described in [7]. <p> The Suite object model is closely related to the Argus [19], Eden [1], and Clouds [4] distributed-object models. Its distinguishing feature is that it has been designed to be compatible with conventional (UNIX-like) operating systems <ref> [6] </ref>. Suite objects seemed ideal for encapsulating visitor information since they did not have the problems of files and relations. Therefore, we decided to experiment with using them for building our application. <p> The hierarchical approach allows a source to be aware of only its immediate dependents. Persistence and Editing Suite provides automatic support for persistence of the data structures of an object. The object simply specifies which data structures are persistent and Suite automatically saves/restores them when the object is passivated/activated <ref> [6] </ref>. Suite also provides near-automatic support for collaborative editing of the data structures of an object. The object indicates which of its data structures are to be displayed to the users and the editing properties of these data structures [8]. <p> In practice, these simple techniques, while usable for the small databases created by the application, have been quiet inconvenient to use. This problem has diminished as the design of the application has stabilized and the major bugs removed. Module Decomposition Suite provides the abstraction of a class module <ref> [6] </ref>, which is similar to an Ada package. A class module defines a set of data structures and methods that manipulate them. It is independently compiled to create server and client parts for the module.
Reference: [7] <author> Prasun Dewan and Rajiv Choudhary, </author> <title> ``Experience with the Suite Distributed Object Model,'' </title> <booktitle> Proceedings of IEEE Workshop on Experimental Distributed Systems, </booktitle> <month> October </month> <year> 1990, </year> <pages> pp. 57-63. </pages>
Reference-contexts: Both technologies are relatively untested. The only reported applications of distributed objects known to us are the Eden [1] and Clouds [4] distributed operating systems, the Edmas distributed mail system [2], the CES multi-user document editor [12], and the simple object-based Suite applications described in <ref> [7] </ref>. Moreover, to the best of our knowledge, generation of multi-user editors is unique to Suite and has so far been used to generate only simple demonstration applications such as the ones mentioned in [8]. Our implementation effort has demonstrated the usefulness of these technologies. <p> Moreover, there was no straightforward way to combine them. Our solution uses the experimental technologies of distributed-objects and multi-user editor generators. Both technologies were crucial to making our implementation task tractable. While we had some experience with these technologies <ref> [7, 8] </ref>, we had not used them to build an application of this complexity. In this section, we motivate our choice of these technologies and the ways in which we used them. Data Model Our first task was to choose a data model for describing the information. <p> Two extreme approaches are: (1) store all information in a single global object and (2) make every unit of information an object. Both approaches had important drawbacks. A global object would be a central bottleneck and hard to change. Moreover, the cost of activating it would be high <ref> [7] </ref>, since the complete visitor information would have to be read into memory. Making every unit of information an object would be inefficient since Suite objects are heavyweight each active object is associated with a process. <p> Making every unit of information an object would be inefficient since Suite objects are heavyweight each active object is associated with a process. The costs of invoking operations on objects and local data structures differ widely, especially if the objects are passive <ref> [7] </ref>. Therefore, we chose an intermediate approach, which uses user-interface information to group data structures into objects. We create an object for each set of date structures that an editor displays together, which we refer to as an edit set. <p> We have used this approach in applications that consist of small static numbers of objects <ref> [7] </ref>.
Reference: [8] <author> Prasun Dewan and Rajiv Choudhary, </author> <title> ``Primitives for Programming Multi-User Interfaces,'' </title> <booktitle> Proceedings of the 4th ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <month> November </month> <year> 1991, </year> <pages> pp. 69-78. </pages>
Reference-contexts: The application offers varying degrees of computer support for the group task, thereby allowing current users to incrementally learn and use the various aspects of the application. We have implemented the visitor application using the experimental technologies of distributed objects and multi-user editor generation offered by Suite <ref> [6, 8] </ref>. Both technologies are relatively untested. The only reported applications of distributed objects known to us are the Eden [1] and Clouds [4] distributed operating systems, the Edmas distributed mail system [2], the CES multi-user document editor [12], and the simple object-based Suite applications described in [7]. <p> Moreover, to the best of our knowledge, generation of multi-user editors is unique to Suite and has so far been used to generate only simple demonstration applications such as the ones mentioned in <ref> [8] </ref>. Our implementation effort has demonstrated the usefulness of these technologies. It has also helped us identify new methods for using them. <p> Moreover, there was no straightforward way to combine them. Our solution uses the experimental technologies of distributed-objects and multi-user editor generators. Both technologies were crucial to making our implementation task tractable. While we had some experience with these technologies <ref> [7, 8] </ref>, we had not used them to build an application of this complexity. In this section, we motivate our choice of these technologies and the ways in which we used them. Data Model Our first task was to choose a data model for describing the information. <p> Suite objects seemed ideal for encapsulating visitor information since they did not have the problems of files and relations. Therefore, we decided to experiment with using them for building our application. User Interface Tools We decided to use the Suite user interface primitives <ref> [8] </ref> for implementing the form and view editors. Several other user interface tools also address some of our implementation needs. These tools include multi-user window systems such as VConf [18], shared toolkits such as DistEdit [14], and shared user-interface architectures such as Rendezvous [23]. <p> Suite also provides near-automatic support for collaborative editing of the data structures of an object. The object indicates which of its data structures are to be displayed to the users and the editing properties of these data structures <ref> [8] </ref>. Suite takes care of the details of displaying the data structures, providing a collaborative interface for editing them, and invoking callbacks in the object. A problem with persistent objects is that the persistent state of an object is not valid if the structure of this state changes.
Reference: [9] <author> Prasun Dewan and Rajiv Choudhary, </author> <title> ``Flexible User Interface Coupling in Collaborative Systems,'' </title> <booktitle> Proceedings of the ACM CHI'91 Conference, </booktitle> <month> April </month> <year> 1991, </year> <pages> pp. 41-49. </pages>
Reference-contexts: Users and objects can customize several aspects of the user interface including how data are displayed, the kind of feedback given in response to user input, and how changes made by multiple users to a data structure are synchronized <ref> [9] </ref>. P. Dewan Multi-User Applications d 11 Objects as Edit Sets Once we had committed ourselves to the distributed-object and editor-generation technologies, we had to determine appropriate ways to use them for building the application. Our first task was to determine how to distribute the visitor information among objects.
Reference: [10] <author> Clarence A. Ellis, Simon J. Gibbs, and Gail L. Rein, </author> <title> ``Groupware: Some Issues and Experiences,'' </title> <journal> CACM 34:1 (January 1991), </journal> <pages> pp. 38-58. </pages>
Reference-contexts: Recent experimental multi-user applications include synchronous meeting schedulers such as RTCAL [26], synchronous document editors such as Cognoter [28], CES [12], Mercury [13], MACE [22], and GROVE <ref> [10] </ref>, asynchronous multi-user document editors such as PREP [21], and synchronous code browsers such as ICICLE [3].
Reference: [11] <author> Adele Goldberg, </author> <title> Smalltalk-80: The Interactive Programming Environment, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1984. </year>
Reference-contexts: To automate this communication, like recent programming environments such as Smalltalk <ref> [11] </ref> and Field [24], the visitor application supports ``active views'', that is, views that are automatically updated in response to changes to the underlying information.
Reference: [12] <author> Irene Greif, Robert Seliger, and William Weihl, </author> <title> ``Atomic Data Abstractions in a Distributed Collaborative Editing System,'' </title> <booktitle> Conference record of POPL, </booktitle> <month> January </month> <year> 1986. </year>
Reference-contexts: Recent experimental multi-user applications include synchronous meeting schedulers such as RTCAL [26], synchronous document editors such as Cognoter [28], CES <ref> [12] </ref>, Mercury [13], MACE [22], and GROVE [10], asynchronous multi-user document editors such as PREP [21], and synchronous code browsers such as ICICLE [3]. <p> Both technologies are relatively untested. The only reported applications of distributed objects known to us are the Eden [1] and Clouds [4] distributed operating systems, the Edmas distributed mail system [2], the CES multi-user document editor <ref> [12] </ref>, and the simple object-based Suite applications described in [7]. Moreover, to the best of our knowledge, generation of multi-user editors is unique to Suite and has so far been used to generate only simple demonstration applications such as the ones mentioned in [8].
Reference: [13] <author> Gail E. Kaiser, Simon M. Kaplan, and Josephine Micallef, </author> <title> ``Multiuser, Distributed Language-Based Environments,'' </title> <journal> IEEE Software 4:6 (November 1987), </journal> <pages> pp. 58-69. </pages>
Reference-contexts: Recent experimental multi-user applications include synchronous meeting schedulers such as RTCAL [26], synchronous document editors such as Cognoter [28], CES [12], Mercury <ref> [13] </ref>, MACE [22], and GROVE [10], asynchronous multi-user document editors such as PREP [21], and synchronous code browsers such as ICICLE [3].
Reference: [14] <author> Michael J. Knister and Atul Prakash, ``DistEdit: </author> <title> A Distributed Toolkit for Supporting Multiple Group Editors,'' </title> <booktitle> Proceedings of ACM Conference on Computer Supported Cooperative Work, </booktitle> <month> October </month> <year> 1990, </year> <pages> pp. 343-356. </pages>
Reference-contexts: User Interface Tools We decided to use the Suite user interface primitives [8] for implementing the form and view editors. Several other user interface tools also address some of our implementation needs. These tools include multi-user window systems such as VConf [18], shared toolkits such as DistEdit <ref> [14] </ref>, and shared user-interface architectures such as Rendezvous [23]. However, these tools either provided low-level support for building the editors or did not address all our needs. Suite supports near-automatic generation of multi-user structure-editors.
Reference: [15] <author> Henry F. Korth and Abraham Silberschatz, </author> <title> ``A User-Friendly Operating System Interface based on the Relational Data Model,'' </title> <booktitle> Proceedings of the International Symposium on New Directions in Computing, </booktitle> <month> August </month> <year> 1985, </year> <pages> pp. 302-310. </pages>
Reference-contexts: These languages offer users a uniform and powerful interface for manipulation of data. Moreover, they support automation in that they relieve application developers from the effort of implementing query interfaces to their applications. For these reasons, some researchers have proposed using these languages for general interaction with the system <ref> [15] </ref>. Nonetheless, we decided to define a specialized query language embedded in the UNIX-based command languages P.
Reference: [16] <author> Glenn E. Krasner and Stephen T. Pope, </author> <title> ``A Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80,'' </title> <journal> Journal of Object-Oriented Programming 1:3 (August/September 1988 ), pp. </journal> <pages> 26-49. </pages>
Reference-contexts: Each view object that changes a data structure updates the central object, which then asks all view objects to recompute the view. This approach is used by the Smalltalk Model-View-Controller paradigm <ref> [16] </ref>. While it is appropriate for programming-in-the-small, it is not suitable for our application since it has the problems of the global-object approach. (3) Selective Broadcasting: A central matcher object keeps the dependencies among the various views.
Reference: [17] <author> Balachander Krishnamurthy and David S. Rosenblum, </author> <title> ``An Event-Action Model of Computer-Supported Cooperative Work: </title> <booktitle> Design and Implementaion,'' International Workshop on CSCW, </booktitle> <address> Informatik Informationen-Reporte 4, </address> <year> 1991, </year> <pages> pp. 132-145. </pages>
Reference-contexts: It would be useful to explore alternate methods for designing and implementing a user interface that overcomes these problems. In particular, it would be useful to explore implementation of the applications using alternate technologies and techniques including event-action systems such as YEAST <ref> [17] </ref>, selective broadcasting [24], Mediators [30], and ``next-generation'' database management systems such as Postgres [29]. ACKNOWLEDGMENTS Wayne Dyksen and Tim Korb suggested the idea of a visitor application.
Reference: [18] <author> Keith A. Lantz, </author> <title> ``An Experiment in Integrated Multimedia Conferencing,'' </title> <booktitle> Proceedings of Conference on Computer-Supported Cooperative Work, </booktitle> <month> December </month> <year> 1986, </year> <pages> pp. 267-275. </pages>
Reference-contexts: User Interface Tools We decided to use the Suite user interface primitives [8] for implementing the form and view editors. Several other user interface tools also address some of our implementation needs. These tools include multi-user window systems such as VConf <ref> [18] </ref>, shared toolkits such as DistEdit [14], and shared user-interface architectures such as Rendezvous [23]. However, these tools either provided low-level support for building the editors or did not address all our needs. Suite supports near-automatic generation of multi-user structure-editors.
Reference: [19] <author> B. Liskov and R. Scheifler, </author> <title> ``Guardians and Actions: Linguistic Support for Distributed Programs,'' </title> <journal> ACM Transactions on Programming Languages and Systems 5:3 (July, </journal> <year> 1983), </year> <pages> pp. 381-404. </pages>
Reference-contexts: Moreover, they are persistent, are automatically activated and passivated, serialize execution of methods, communicate with each other using a high-level RPC interface, and have protected hierarchical names in a network file system. The Suite object model is closely related to the Argus <ref> [19] </ref>, Eden [1], and Clouds [4] distributed-object models. Its distinguishing feature is that it has been designed to be compatible with conventional (UNIX-like) operating systems [6]. Suite objects seemed ideal for encapsulating visitor information since they did not have the problems of files and relations.
Reference: [20] <author> M. Morgenstern, </author> <title> ``Active Databases as a Paradigm for Enhanced Computing Environments,'' </title> <booktitle> Proceedings of the 9th International Conference of Very Large Data Bases , 1983, </booktitle> <pages> pp. 34-42. </pages>
Reference-contexts: This inconsistency has lead to dissemination of inaccurate information and scheduling of multiple talks at the same time. Some of these problems of manual management of group activities are well known and mechanisms such as active databases <ref> [20] </ref> and ``next-generation databases'' [29] have been proposed to build applications that address the problems. However, we know of no application built using these mechanisms that addresses all of these problems.
Reference: [21] <author> Christine M. Neuwirth, David S. Kaufer, Ravinder Chandok, and James H. Morris, </author> <booktitle> ``Issues in the Design of Computer Support for Co-authoring and Commenting,'' Proceedings of ACM Conference on Computer Supported Cooperative Work, </booktitle> <month> October </month> <year> 1990, </year> <pages> pp. 183-195. </pages> <note> P. Dewan Multi-User Applications d 19 </note>
Reference-contexts: Recent experimental multi-user applications include synchronous meeting schedulers such as RTCAL [26], synchronous document editors such as Cognoter [28], CES [12], Mercury [13], MACE [22], and GROVE [10], asynchronous multi-user document editors such as PREP <ref> [21] </ref>, and synchronous code browsers such as ICICLE [3].
Reference: [22] <author> R.E. Newman-Wolfe and H. Pelimuhandiram,, </author> <title> ``The MACE Fine-grained Concurrent Text Editor,'' </title> <booktitle> Proceedings of ACM/IEEE Conference on Organizational Computing Systems (COCS 91), </booktitle> <month> November </month> <year> 1991, </year> <pages> pp. </pages> <month> 240-254,. </month>
Reference-contexts: Recent experimental multi-user applications include synchronous meeting schedulers such as RTCAL [26], synchronous document editors such as Cognoter [28], CES [12], Mercury [13], MACE <ref> [22] </ref>, and GROVE [10], asynchronous multi-user document editors such as PREP [21], and synchronous code browsers such as ICICLE [3].
Reference: [23] <author> John F. Patterson, Ralph D. Hill, Steven L. Rohall, and W. Scott Meeks, </author> <title> ``Rendezvous: An Architecture for Synchronous Multi-User Applications,'' </title> <booktitle> Proceedings of the Conference on Computer-Supported Cooperative Work, </booktitle> <month> October </month> <year> 1990, </year> <pages> pp. 317-328. </pages>
Reference-contexts: Several other user interface tools also address some of our implementation needs. These tools include multi-user window systems such as VConf [18], shared toolkits such as DistEdit [14], and shared user-interface architectures such as Rendezvous <ref> [23] </ref>. However, these tools either provided low-level support for building the editors or did not address all our needs. Suite supports near-automatic generation of multi-user structure-editors.
Reference: [24] <author> Steven P. Reiss, </author> <title> ``Connecting Tools Using Message Passing in the Field Environment,'' </title> <booktitle> IEEE Software 7:4 (July 1990), </booktitle> <pages> pp. 57-66. </pages>
Reference-contexts: To automate this communication, like recent programming environments such as Smalltalk [11] and Field <ref> [24] </ref>, the visitor application supports ``active views'', that is, views that are automatically updated in response to changes to the underlying information. <p> The matcher forwards the message to all views that have registered patterns that match the message. This approach requires code for pattern matching and coding and decoding of messages, which is analogous to file parsing and unparsing. It is a general approach and is supported by Field <ref> [24] </ref>. It is appropriate when the objects have been coded independently since the cost of writing this code can be considered a necessary integration cost. However, we did not wish P. <p> It would be useful to explore alternate methods for designing and implementing a user interface that overcomes these problems. In particular, it would be useful to explore implementation of the applications using alternate technologies and techniques including event-action systems such as YEAST [17], selective broadcasting <ref> [24] </ref>, Mediators [30], and ``next-generation'' database management systems such as Postgres [29]. ACKNOWLEDGMENTS Wayne Dyksen and Tim Korb suggested the idea of a visitor application.
Reference: [25] <author> Lawrence A. Rowe and Kurt A. Shoens, </author> <title> ``A Form Application Development System,'' </title> <booktitle> Proceedings of the ACM-SIGMOD International Conference on the Management of Data, </booktitle> <year> 1982, </year> <pages> pp. 28-38. </pages>
Reference-contexts: We can use the setvis command for this purpose setvis -create -host "Tim Korb" ... -dates "Fri/4/19/91" Krishnamurthy but it provides an awkward interface for entering a large number of data items. Therefore, the application also provides a FADS-like form interface <ref> [25] </ref>, which lets a user edit a template and then commit it to enter information about a new visitor (Figure 1). The form interface also supports modification of existing visitor records.
Reference: [26] <author> Sunil Sarin and Irene Greif, </author> <title> ``Computer-Based Real-Time Conferencing Systems,'' </title> <booktitle> IEEE Computer 18:10 (October 1985), </booktitle> <pages> pp. 33-49. </pages>
Reference-contexts: Traditional multi-user applications include command and query interpreters allowing users to store and retrieve shared information, and talk and mail programs allowing users to exchange information synchronously and asynchronously, respectively. Recent experimental multi-user applications include synchronous meeting schedulers such as RTCAL <ref> [26] </ref>, synchronous document editors such as Cognoter [28], CES [12], Mercury [13], MACE [22], and GROVE [10], asynchronous multi-user document editors such as PREP [21], and synchronous code browsers such as ICICLE [3].
Reference: [27] <author> Honghai Shen and Prasun Dewan, </author> <title> ``Access Control for Collaborative Environments,'' </title> <booktitle> Proceedings of the ACM Conference on Computer Supported Cooperative Work, to appear in November 1992. </booktitle>
Reference-contexts: Clearly, this approach will work only as long as our environment remains perfectly cooperative. Flexible access control in a collaborative environment is an open research issue and we are investigating schemes that give the ease-of-use and flexibility of the current approach without assuming that all users are cooperative <ref> [27] </ref>. Our experience shows that the visitor application cannot make all the decisions regarding the handling of the events supported by itsome of these decisions need to made by users of the application. To illustrate, consider what P.
Reference: [28] <author> Mark Stefik, Gregg Foster, Daniel G. Bobrow, Kenneth Kahn, Stan Lanning, and Lucy Suchman, </author> <title> ``Beyond the Chalkboard: Computer Support for Collaboration and Problem Solving in Meetings,'' </title> <journal> CACM 30:1 (Janu-ary 1987), </journal> <pages> pp. 32-47. </pages>
Reference-contexts: Traditional multi-user applications include command and query interpreters allowing users to store and retrieve shared information, and talk and mail programs allowing users to exchange information synchronously and asynchronously, respectively. Recent experimental multi-user applications include synchronous meeting schedulers such as RTCAL [26], synchronous document editors such as Cognoter <ref> [28] </ref>, CES [12], Mercury [13], MACE [22], and GROVE [10], asynchronous multi-user document editors such as PREP [21], and synchronous code browsers such as ICICLE [3].
Reference: [29] <author> Michael Stonebraker and Lawrence A. Rowe, </author> <title> ``The Implementation of Postgres,'' </title> <journal> IEEE Transactions on Knowledge and Data Engineering 2:1 (March 1990), </journal> <pages> pp. 125-142. </pages>
Reference-contexts: This inconsistency has lead to dissemination of inaccurate information and scheduling of multiple talks at the same time. Some of these problems of manual management of group activities are well known and mechanisms such as active databases [20] and ``next-generation databases'' <ref> [29] </ref> have been proposed to build applications that address the problems. However, we know of no application built using these mechanisms that addresses all of these problems. <p> In particular, it would be useful to explore implementation of the applications using alternate technologies and techniques including event-action systems such as YEAST [17], selective broadcasting [24], Mediators [30], and ``next-generation'' database management systems such as Postgres <ref> [29] </ref>. ACKNOWLEDGMENTS Wayne Dyksen and Tim Korb suggested the idea of a visitor application. Michal Young increased the usability of the application by building a program for automatically creating graphical paper schedules from the on-line version of the visitor information.
Reference: [30] <author> Kevin J. Sullivan and David Notkin, </author> <title> ``Reconciling Environment Integration and Component Independence,'' </title> <booktitle> Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <month> December </month> <year> 1990, </year> <pages> pp. 22-33. </pages>
Reference-contexts: It would be useful to explore alternate methods for designing and implementing a user interface that overcomes these problems. In particular, it would be useful to explore implementation of the applications using alternate technologies and techniques including event-action systems such as YEAST [17], selective broadcasting [24], Mediators <ref> [30] </ref>, and ``next-generation'' database management systems such as Postgres [29]. ACKNOWLEDGMENTS Wayne Dyksen and Tim Korb suggested the idea of a visitor application. Michal Young increased the usability of the application by building a program for automatically creating graphical paper schedules from the on-line version of the visitor information.
Reference: [31] <author> M. M. Zloof, </author> <title> ``Query by Example, The Invocation and Definition of Tables and Forms,'' </title> <booktitle> Proceedings of the International Conference on Very Large Databases, </booktitle> <month> September </month> <year> 1975, </year> <pages> pp. 1-24. </pages>
Reference-contexts: The global view displays records of all the visitors scheduled so far (Figure 2, top window) and filter views show the records of subsets of these visitors (Figure 3). Filter views combine features of QBE <ref> [31] </ref>, UNIX ``wildcards'', and UNIX pipes.
References-found: 31

