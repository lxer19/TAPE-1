URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1997/UM-CS-1997-054.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/process.html
Root-URL: 
Title: The Design of a Next-Generation Process Language  
Author: Stanley M. Sutton, Jr. and Leon J. Osterweil 
Address: Amherst, MA 01003-4610  
Affiliation: Department of Computer Science University of Massachusetts  
Abstract: Process languages remain a vital area of software process research. Among the important issue for process languages are semantic richness, ease of use, appropriate abstractions, process composability, visualization, and support for multiple paradigms. The need to balance semantic richness with ease of use is particularly critical. JIL addresses these issues in a number of innovative ways. It models processes in terms of steps with a rich variety of semantic attributes. The JIL control model combines proactive and reactive control, conditional control, and more simple means of control-flow modeling via step composition and execution constraints. JIL facilitates ease of use through semantic factoring, the accommodation of incomplete step specifications, the fostering of simple sub-languages, and the ability to support visualizations. This approach allows processes to be programmed in a variety of terms, and to a variety of levels of detail, according to the needs of particular processes, projects, and programmers. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Baker, D. Fisher, and J. Shultis. </author> <title> The Gardens of Iris. Incremental Systems Corporation, </title> <address> Pittsburgh, PA, </address> <year> 1988. </year>
Reference-contexts: The JIL definition has progressed to a stable initial version with which we are continuing development of process programs, language support technology, and environment infrastructure. We have defined the BNF for the JIL grammar and generated a parser that translates JIL source code into an IRIS <ref> [1] </ref> internal representation. We are developing an interpreter and a JIL-to-Ada command translator. We are also developing visual language (implemented in Java) for a subset of JIL.
Reference: 2. <author> R. Balzer. </author> <title> Tolerating inconsistency. </title> <booktitle> In Proc. of the 13th International Conference on Software Engineering, </booktitle> <pages> pages 158 - 165. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: This would allow the process to continue normally but with the product in need of some repair (this is somewhat analogous to the approach to handling inconsistency described in <ref> [2] </ref>). The coding of such approaches is done in the exception handlers (Section 3.3). At present, we are using Pleiades [35] as our product definition language and Pleiades constraints as our primary form of preconditions and postconditions. Pleiades generates an Ada package specification and the constraints represent arbitrary Ada functions.
Reference: 3. <author> S. Bandinelli and A. Fuggetta. </author> <title> Computational reflection in software process modeling: the SLANG approach. </title> <booktitle> In Proc. of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 144-154. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Composition is also recognized as important in the subject-oriented view of object-oriented programming [17]. 2.5 Clarity through Visualization Many first-generation process languages are textual. A few process languages support graphical representations of process control (e.g., Slang <ref> [3] </ref>, Melmac [13], Process Weaver [16], and Hakoniwa [20]). Visual process representations greatly aid understanding and communication of some processes. Simple ideas are often most simply represented visually, and this can aid greatly in process design and verification. <p> We believe that this model will be more general than those typically used in software systems and software processes to date. Process state has been recognized as an important consideration in process control, management, and evaluation <ref> [18, 3, 10] </ref>. We plan to have the JIL runtime system maintain key components of the process state automatically.
Reference: 4. <author> S. Bandinelli, A. Fuggetta, and S. Grigolli. </author> <title> Process modeling in-the-large with SLANG. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 75-83. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Second, first-generation languages generally have obvious limitations. This is in part because many of these languages were based on existing paradigms that were not particularly well adapted to the domain of software process <ref> [9, 22, 31, 24, 13, 4, 23] </ref>. Finally, research in other areas of software process has affected our ideas about what can and should be done with process languages.
Reference: 5. <author> N. Belkhatir, J. Estublier, and M. L. Walcelio. ADELE-TEMPO: </author> <title> An environment to support process modeling and enaction. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 187 - 222. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management. These issues have been the focus of much previous work (e.g., <ref> [29, 21, 9, 22, 5, 10, 31] </ref>), and they should continue to be addressed by second-generation process languages. Our focus here, however, is on the issues outlined below. 2.1 Semantic Richness Software processes are multi-faceted and technically challenging applications.
Reference: 6. <author> G. Booch. </author> <title> Object-Oriented Analysis and Design with Applications. </title> <publisher> The Ben-jamin/Cummings Publishing Company, Inc., </publisher> <address> second edition, </address> <year> 1994. </year>
Reference-contexts: Examples are based on a process for software design following the principles of Booch Object-Oriented Design <ref> [6] </ref>. 3.1 Process Steps The central construct in JIL is the step. A JIL step is intended to represent a step in a software process. <p> This specification represents the first step in a (simplified) Booch Object-Oriented Design process <ref> [6] </ref>. The step specification has a template-like syntax (i.e., it is composed of various fields). The substeps are listed within the specification. The proactive control specification (Section 3.2), reactive control specification (Section 3.2), and exception handlers (Section 3.3) are all contained in separate, named subunits. <p> We are developing an interpreter and a JIL-to-Ada command translator. We are also developing visual language (implemented in Java) for a subset of JIL. Our primary process programming efforts are directed at a design process based on Booch Object Oriented Design <ref> [6] </ref> and a dataflow-analysis process based on iterative, incremental improvement of analytic accuracy [14]. Acknowledgments The Julia/JIL project reflects the work of many people. The Julia-to-IRIS translator was built by Peri Tarr. The resource model has been developed by Rodion Podorozhny. The agenda-management system has been programmed by Eric Mc-Call.
Reference: 7. <author> R. H. Campbell and A. N. Haberman. </author> <title> The Specification of Process Synchroniza--tion by Path Expressions. </title> <booktitle> In Operating Systems Proc. of an Int. Symposium, Rocquencourt, France, volume 16 of Lecture Notes in Computer Science, </booktitle> <pages> pages 89-102. </pages> <publisher> Springer, </publisher> <year> 1974. </year>
Reference-contexts: If appropriate, simple control relations among the substeps of a step can be specified using the step constraint functions. These are comparable to the control specifications of ALF [8], which represent path expressions <ref> [7] </ref>. An example of a step constraint specification is shown in Figure 3.
Reference: 8. <author> G. Canals, N. Boudjlida, J.-C. Derniame, C. Godart, and J. Lonchamp. </author> <title> ALF: A framework for building process-centred software engineering environments. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 153 - 185. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: We relied heavily on this combination of proactive and reactive control in our process programming. Some combination of these two types of control is also found in many other process languages (e.g., Adele [5],AP5 [9], EPOS [11], HFSP [24, 34], Marvel [22], Merlin [21], and ProcessWeaver [16]). ALF <ref> [8] </ref> is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35]. And multiple paradigms have also been found useful in requirements specification [12]. <p> If appropriate, simple control relations among the substeps of a step can be specified using the step constraint functions. These are comparable to the control specifications of ALF <ref> [8] </ref>, which represent path expressions [7]. An example of a step constraint specification is shown in Figure 3.
Reference: 9. <author> D. Cohen. </author> <title> AP5 Manual. </title> <institution> Univ. of Southern California, Information Sciences Institute, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Second, first-generation languages generally have obvious limitations. This is in part because many of these languages were based on existing paradigms that were not particularly well adapted to the domain of software process <ref> [9, 22, 31, 24, 13, 4, 23] </ref>. Finally, research in other areas of software process has affected our ideas about what can and should be done with process languages. <p> Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management. These issues have been the focus of much previous work (e.g., <ref> [29, 21, 9, 22, 5, 10, 31] </ref>), and they should continue to be addressed by second-generation process languages. Our focus here, however, is on the issues outlined below. 2.1 Semantic Richness Software processes are multi-faceted and technically challenging applications. <p> We relied heavily on this combination of proactive and reactive control in our process programming. Some combination of these two types of control is also found in many other process languages (e.g., Adele [5],AP5 <ref> [9] </ref>, EPOS [11], HFSP [24, 34], Marvel [22], Merlin [21], and ProcessWeaver [16]). ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35]. <p> It is cumbersome, though, when the exception must be handled in a uniform way, regardless of where it arises. The alternative model is rule-based exception handling, in which exceptions trigger exception-handling rules. The consistency rules of AP5 <ref> [9] </ref> and Marvel [22] are examples. This approach is ideally suited to the case in which an exception can be handled uniformly regardless of where it originates, but it is much more cumbersome when exceptions must be handled according to the context in which they arise.
Reference: 10. <author> R. Conradi, C. Fernstrom, and A. Fuggetta. </author> <title> Concepts for evolving software processes. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 9 - 31. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management. These issues have been the focus of much previous work (e.g., <ref> [29, 21, 9, 22, 5, 10, 31] </ref>), and they should continue to be addressed by second-generation process languages. Our focus here, however, is on the issues outlined below. 2.1 Semantic Richness Software processes are multi-faceted and technically challenging applications. <p> We believe that this model will be more general than those typically used in software systems and software processes to date. Process state has been recognized as an important consideration in process control, management, and evaluation <ref> [18, 3, 10] </ref>. We plan to have the JIL runtime system maintain key components of the process state automatically.
Reference: 11. <author> R. Conradi, M. Hagaseth, J.-O. Larsen, M. N. Nguy^en, B. P. Munch, P. H. Westby, W. Zhu, M. L. Jaccheri, and C. Liu. EPOS: </author> <title> Object-oriented cooperative process modelling. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 33 - 70. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: We relied heavily on this combination of proactive and reactive control in our process programming. Some combination of these two types of control is also found in many other process languages (e.g., Adele [5],AP5 [9], EPOS <ref> [11] </ref>, HFSP [24, 34], Marvel [22], Merlin [21], and ProcessWeaver [16]). ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35].
Reference: 12. <author> R. Darimont and A. van Lamsweerde. </author> <title> Formal refinement patterns for goal-driven requirements elaboration. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 179-190, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35]. And multiple paradigms have also been found useful in requirements specification <ref> [12] </ref>. In most process languages, however, one control paradigm typically predominates while the other is secondary. Thus, many languages primarily support one style of pro-gramming (such as rule-based programming in Merlin or Marvel, or functional programming in HFSP, among others).
Reference: 13. <author> W. Deiters and V. Gruhn. </author> <title> Managing software processes in the environment mel-mac. </title> <booktitle> In Proc. of the Fourth ACM SIGSOFT Symposium on Practical Software Development Environments, </booktitle> <pages> pages 193-205. </pages> <publisher> ACM Press, </publisher> <address> 1990. Irvine, California. </address>
Reference-contexts: Second, first-generation languages generally have obvious limitations. This is in part because many of these languages were based on existing paradigms that were not particularly well adapted to the domain of software process <ref> [9, 22, 31, 24, 13, 4, 23] </ref>. Finally, research in other areas of software process has affected our ideas about what can and should be done with process languages. <p> Composition is also recognized as important in the subject-oriented view of object-oriented programming [17]. 2.5 Clarity through Visualization Many first-generation process languages are textual. A few process languages support graphical representations of process control (e.g., Slang [3], Melmac <ref> [13] </ref>, Process Weaver [16], and Hakoniwa [20]). Visual process representations greatly aid understanding and communication of some processes. Simple ideas are often most simply represented visually, and this can aid greatly in process design and verification.
Reference: 14. <author> M. B. Dwyer and L. A. Clarke. </author> <title> Data Flow Analysis for Verifying Properties of Concurrent Programs. </title> <booktitle> In Proceedings of the Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <address> New Orleans, </address> <pages> pages 62-75. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: We are also developing visual language (implemented in Java) for a subset of JIL. Our primary process programming efforts are directed at a design process based on Booch Object Oriented Design [6] and a dataflow-analysis process based on iterative, incremental improvement of analytic accuracy <ref> [14] </ref>. Acknowledgments The Julia/JIL project reflects the work of many people. The Julia-to-IRIS translator was built by Peri Tarr. The resource model has been developed by Rodion Podorozhny. The agenda-management system has been programmed by Eric Mc-Call.
Reference: 15. <author> W. Emmerich, S. Bandinelli, L. Lavazza, and J. Arlow. </author> <title> Fine grained process mod-elling: An experiment at british airways. </title> <booktitle> In Proc. of the Fourth International Conference on the Software Process, </booktitle> <pages> pages 2-12. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Thus, strictly visual representations are likely to be unsuitable for complex processes in general (especially if they are complex enough to support process execution <ref> [15] </ref>).
Reference: 16. <author> C. Fernstrom. </author> <title> PROCESS WEAVER: Adding process support to UNIX. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 12 - 26, </pages> <year> 1993. </year>
Reference-contexts: Process programming languages should provide built-in concepts and constructs that map naturally into the software process domain. (Languages that do this with varying degrees of success include MVP-L [28], ProcessWeaver <ref> [16] </ref>, LOTOS [29], and Oikos [25].) 2.4 Composability Programming of software processes in general is difficult. Thus it is important to be able to readily compose larger processes out of smaller components and to support reuse-based process programming. <p> Composition is also recognized as important in the subject-oriented view of object-oriented programming [17]. 2.5 Clarity through Visualization Many first-generation process languages are textual. A few process languages support graphical representations of process control (e.g., Slang [3], Melmac [13], Process Weaver <ref> [16] </ref>, and Hakoniwa [20]). Visual process representations greatly aid understanding and communication of some processes. Simple ideas are often most simply represented visually, and this can aid greatly in process design and verification. <p> We relied heavily on this combination of proactive and reactive control in our process programming. Some combination of these two types of control is also found in many other process languages (e.g., Adele [5],AP5 [9], EPOS [11], HFSP [24, 34], Marvel [22], Merlin [21], and ProcessWeaver <ref> [16] </ref>). ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35]. And multiple paradigms have also been found useful in requirements specification [12].
Reference: 17. <author> W. Harrison and H. Ossher. </author> <title> Subject-Oriented Programming: A Critique of Pure Objects. </title> <booktitle> In Proceedings of the Eighth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 411-428, </pages> <month> October </month> <year> 1993. </year> <note> Published as ACM SIGPLAN Notices 28(10). </note>
Reference-contexts: Also, the ability to program processes by composing elements having different language paradigms or representing different semantic aspects would introduce additional flexibility and incrementality into process program development. Composition is also recognized as important in the subject-oriented view of object-oriented programming <ref> [17] </ref>. 2.5 Clarity through Visualization Many first-generation process languages are textual. A few process languages support graphical representations of process control (e.g., Slang [3], Melmac [13], Process Weaver [16], and Hakoniwa [20]). Visual process representations greatly aid understanding and communication of some processes.
Reference: 18. <author> D. Heimbigner. </author> <title> Experiences with an Object-Manager for A Process-Centered Environment. </title> <booktitle> In Proceedings of the Eighteenth International Conf. on Very Large Data Bases, </booktitle> <address> Vancouver, B.C., </address> <month> 24-27 August </month> <year> 1992. </year>
Reference-contexts: We believe that this model will be more general than those typically used in software systems and software processes to date. Process state has been recognized as an important consideration in process control, management, and evaluation <ref> [18, 3, 10] </ref>. We plan to have the JIL runtime system maintain key components of the process state automatically.
Reference: 19. <author> D. Heimbigner. </author> <title> The ProcessWall: A Process State Server Approach to Process Programming. </title> <booktitle> In Proc. Fifth ACM SIGSOFT/SIGPLAN Symposium on Software Development Environments, </booktitle> <pages> pages 159-168, </pages> <address> Washington, D.C., </address> <month> 9-11 Decem-ber </month> <year> 1992. </year>
Reference-contexts: Additionally we expect to support visualizations of process execution state (such as those provided by the ProcessWall <ref> [19] </ref>), resource usage, and other runtime concerns. Multiple Paradigms JIL is especially rich in alternative control paradigms. It accommodates both simple and completely programmed representations of process control. It combines proactive and reactive mechanisms, and incorporates conditional control.
Reference: 20. <author> H. Iida, K.-I. Mimura, K. Inoue, and K. Torii. Hakoniwa: </author> <title> Monitor and navigation system for cooperative development based on activity sequence model. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 64 - 74. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Composition is also recognized as important in the subject-oriented view of object-oriented programming [17]. 2.5 Clarity through Visualization Many first-generation process languages are textual. A few process languages support graphical representations of process control (e.g., Slang [3], Melmac [13], Process Weaver [16], and Hakoniwa <ref> [20] </ref>). Visual process representations greatly aid understanding and communication of some processes. Simple ideas are often most simply represented visually, and this can aid greatly in process design and verification.
Reference: 21. <author> G. Junkermann, B. Peuschel, W. Schafer, and S. Wolf. MERLIN: </author> <title> Supporting co-operation in software development through a knowledge-based environment. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 103 - 129. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management. These issues have been the focus of much previous work (e.g., <ref> [29, 21, 9, 22, 5, 10, 31] </ref>), and they should continue to be addressed by second-generation process languages. Our focus here, however, is on the issues outlined below. 2.1 Semantic Richness Software processes are multi-faceted and technically challenging applications. <p> We relied heavily on this combination of proactive and reactive control in our process programming. Some combination of these two types of control is also found in many other process languages (e.g., Adele [5],AP5 [9], EPOS [11], HFSP [24, 34], Marvel [22], Merlin <ref> [21] </ref>, and ProcessWeaver [16]). ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35].
Reference: 22. <author> G. E. Kaiser, N. S. Barghouti, and M. H. Sokolsky. </author> <title> Experience with process modeling in the marvel software development environment kernel. </title> <editor> In B. Shriver, editor, </editor> <booktitle> 23rd Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 131-140, </pages> <address> Kona HI, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Second, first-generation languages generally have obvious limitations. This is in part because many of these languages were based on existing paradigms that were not particularly well adapted to the domain of software process <ref> [9, 22, 31, 24, 13, 4, 23] </ref>. Finally, research in other areas of software process has affected our ideas about what can and should be done with process languages. <p> Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management. These issues have been the focus of much previous work (e.g., <ref> [29, 21, 9, 22, 5, 10, 31] </ref>), and they should continue to be addressed by second-generation process languages. Our focus here, however, is on the issues outlined below. 2.1 Semantic Richness Software processes are multi-faceted and technically challenging applications. <p> We relied heavily on this combination of proactive and reactive control in our process programming. Some combination of these two types of control is also found in many other process languages (e.g., Adele [5],AP5 [9], EPOS [11], HFSP [24, 34], Marvel <ref> [22] </ref>, Merlin [21], and ProcessWeaver [16]). ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35]. <p> It is cumbersome, though, when the exception must be handled in a uniform way, regardless of where it arises. The alternative model is rule-based exception handling, in which exceptions trigger exception-handling rules. The consistency rules of AP5 [9] and Marvel <ref> [22] </ref> are examples. This approach is ideally suited to the case in which an exception can be handled uniformly regardless of where it originates, but it is much more cumbersome when exceptions must be handled according to the context in which they arise.
Reference: 23. <author> G. E. Kaiser, S. S. Popovich, and I. Z. Ben-Shaul. </author> <title> A bi-level language for software process modeling. </title> <editor> In W. F. Tichy, editor, </editor> <booktitle> Configuration Management, number 2 in Trends in Software, chapter 2, </booktitle> <pages> pages 39-72. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: Second, first-generation languages generally have obvious limitations. This is in part because many of these languages were based on existing paradigms that were not particularly well adapted to the domain of software process <ref> [9, 22, 31, 24, 13, 4, 23] </ref>. Finally, research in other areas of software process has affected our ideas about what can and should be done with process languages.
Reference: 24. <author> T. Katayama. </author> <title> A hierarchical and functional software process description and its enaction. </title> <booktitle> In Proc. of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 343 - 353. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: Second, first-generation languages generally have obvious limitations. This is in part because many of these languages were based on existing paradigms that were not particularly well adapted to the domain of software process <ref> [9, 22, 31, 24, 13, 4, 23] </ref>. Finally, research in other areas of software process has affected our ideas about what can and should be done with process languages. <p> We relied heavily on this combination of proactive and reactive control in our process programming. Some combination of these two types of control is also found in many other process languages (e.g., Adele [5],AP5 [9], EPOS [11], HFSP <ref> [24, 34] </ref>, Marvel [22], Merlin [21], and ProcessWeaver [16]). ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35].
Reference: 25. <editor> C. Montangero and V. Ambriola. OIKOS: Constructing process-centered sdes. In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 33 - 70. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: Process programming languages should provide built-in concepts and constructs that map naturally into the software process domain. (Languages that do this with varying degrees of success include MVP-L [28], ProcessWeaver [16], LOTOS [29], and Oikos <ref> [25] </ref>.) 2.4 Composability Programming of software processes in general is difficult. Thus it is important to be able to readily compose larger processes out of smaller components and to support reuse-based process programming.
Reference: 26. <author> L. J. Osterweil. </author> <title> A Process-Object Centered View of Software Environment Architecture. </title> <editor> In R. Conradi, D. T, and D. Wanvik, editors, </editor> <booktitle> Advanced Programming Environments, </booktitle> <pages> pages 156-174, </pages> <address> Trondheim, 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: An assessment of the JIL approach is presented in Section 5, and our status is discussed in Section 6. 2 Language Design Goals Process programming proposes that it is feasible and valuable to represent software processes using programs written in compilable, executable coding languages <ref> [26, 27] </ref>. Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management.
Reference: 27. <author> L. J. Osterweil. </author> <title> Software processes are software, too. </title> <booktitle> In Proc. Ninth International Conference on Software Engineering, </booktitle> <pages> pages 2-13. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> 1987. Monterey, CA, March 30 - April 2, </address> <year> 1987. </year>
Reference-contexts: An assessment of the JIL approach is presented in Section 5, and our status is discussed in Section 6. 2 Language Design Goals Process programming proposes that it is feasible and valuable to represent software processes using programs written in compilable, executable coding languages <ref> [26, 27] </ref>. Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management.
Reference: 28. <author> H. D. Rombach and M. Verlage. </author> <title> How to assess a software process modeling formalism from a project member's point of view. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 147 - 159. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Process programming languages should provide built-in concepts and constructs that map naturally into the software process domain. (Languages that do this with varying degrees of success include MVP-L <ref> [28] </ref>, ProcessWeaver [16], LOTOS [29], and Oikos [25].) 2.4 Composability Programming of software processes in general is difficult. Thus it is important to be able to readily compose larger processes out of smaller components and to support reuse-based process programming.
Reference: 29. <author> M. Saeki, T. Kaneko, and M. Sakamoto. </author> <title> A method for software process modeling and description using LOTOS. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 90 - 104. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management. These issues have been the focus of much previous work (e.g., <ref> [29, 21, 9, 22, 5, 10, 31] </ref>), and they should continue to be addressed by second-generation process languages. Our focus here, however, is on the issues outlined below. 2.1 Semantic Richness Software processes are multi-faceted and technically challenging applications. <p> Process programming languages should provide built-in concepts and constructs that map naturally into the software process domain. (Languages that do this with varying degrees of success include MVP-L [28], ProcessWeaver [16], LOTOS <ref> [29] </ref>, and Oikos [25].) 2.4 Composability Programming of software processes in general is difficult. Thus it is important to be able to readily compose larger processes out of smaller components and to support reuse-based process programming.
Reference: 30. <author> S. M. Sutton, Jr. </author> <title> Preconditions, postconditions, and provisional execution in software processes. </title> <type> Technical Report CMPSCI TR 95-77, </type> <institution> University of Massachusetts at Amherst, Computer Science Department, </institution> <address> Amherst, Massachusetts 01003, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Variances may be granted in cases where the conditions cannot be evaluated (e.g., due to contention for objects or other resources) or where there is good reason for overriding the programmed condition <ref> [30] </ref>. The granting of variances is supported through a runtime service. A second generalization is that alternative responses may be made when violations occur. For example, when a step violates a postcondition the step may be aborted and its inconsistent results discarded.
Reference: 31. <author> S. M. Sutton, Jr., D. Heimbigner, and L. J. Osterweil. APPL/A: </author> <title> A language for software-process programming. </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 4(3) </volume> <pages> 221-286, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Second, first-generation languages generally have obvious limitations. This is in part because many of these languages were based on existing paradigms that were not particularly well adapted to the domain of software process <ref> [9, 22, 31, 24, 13, 4, 23] </ref>. Finally, research in other areas of software process has affected our ideas about what can and should be done with process languages. <p> Our experience with APPL/A <ref> [31] </ref> has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management. <p> Our experience with APPL/A [31] has validated this proposal. We now take many properties of coding languages as fundamental to representing software processes, including formal syntax, well-defined semantics, executabil-ity, analyzability, object management, and consistency management. These issues have been the focus of much previous work (e.g., <ref> [29, 21, 9, 22, 5, 10, 31] </ref>), and they should continue to be addressed by second-generation process languages. Our focus here, however, is on the issues outlined below. 2.1 Semantic Richness Software processes are multi-faceted and technically challenging applications. <p> Example of step-ordering constraints. 3.3 Exception Handling Two main models of exception handling have been used in first-generation process programming languages (and in programming languages generally). These may be characterized as block-oriented and rule-based. The block-oriented model is represented by Ada and C++ and was used in APPL/A <ref> [31] </ref>. In this approach, an exception handling block is attached to the scope in which the exception may occur. This approach is especially appropriate for process-specific exception handling, where different occurrences of the exception should be handled in context sensitive ways.
Reference: 32. <author> S. M. Sutton, Jr. and L. J. Osterweil. </author> <title> The design of a next-generation process language. </title> <type> Technical Report CMPSCI Technical Report 96-30, </type> <institution> University of Mas-sachusetts at Amherst, Computer Science Department, </institution> <address> Amherst, Massachusetts 01003, </address> <month> May </month> <year> 1996. </year> <note> revised January, </note> <year> 1997. </year>
Reference-contexts: Using that, we plan to program more sophisticated and flexible interpreters in JIL. This will provide us with a basis for experimentation with alternative interpretation strategies and also with alternative language semantics. A full treatment of Julia is beyond the scope of this paper (but see <ref> [32] </ref>). To illustrate the Julia philosophy and approach, we elaborate here on one key issue in the interpretation of JIL, namely multi-modal interpretation. JIL offers great flexibility in specifying process control flow, particularly for substep invocation. Such flexibility imposes a corresponding requirement for flexibility on the JIL interpreter.
Reference: 33. <author> S. M. Sutton, Jr. and L. J. Osterweil. </author> <booktitle> Programming parallel workflows in JIL. In Proceedings of the 9th International Conference on Parallel and Distributed Computing and Systems, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The syntax of the imperative code is based on Ada, including loop and conditional commands, entry-call accept statements, and a new parallel command with mandatory and optional branches. (Space limitations preclude presentation of an extensive example here, but see <ref> [33] </ref>). An explicit "invoke" command is used to distinguish substep invocation from ordinary procedure invocation.
Reference: 34. <author> M. Suzuki and T. Katayama. </author> <title> Meta-operations in the process model HFSP for the dynamics and flexibility of software processes. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 202 - 217. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: We relied heavily on this combination of proactive and reactive control in our process programming. Some combination of these two types of control is also found in many other process languages (e.g., Adele [5],AP5 [9], EPOS [11], HFSP <ref> [24, 34] </ref>, Marvel [22], Merlin [21], and ProcessWeaver [16]). ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management [35].
Reference: 35. <author> P. L. Tarr and L. A. Clarke. PLEIADES: </author> <title> An Object Management System for Software Engineering Environments. </title> <booktitle> In Proceedings of the First ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 56-70. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: ALF [8] is another process project that is explicitly multi-paradigmatic in combining proactive and reactive control along with preconditions and postconditions, and Pleiades demonstrates that multiple paradigms are also important in software object management <ref> [35] </ref>. And multiple paradigms have also been found useful in requirements specification [12]. In most process languages, however, one control paradigm typically predominates while the other is secondary. <p> This would allow the process to continue normally but with the product in need of some repair (this is somewhat analogous to the approach to handling inconsistency described in [2]). The coding of such approaches is done in the exception handlers (Section 3.3). At present, we are using Pleiades <ref> [35] </ref> as our product definition language and Pleiades constraints as our primary form of preconditions and postconditions. Pleiades generates an Ada package specification and the constraints represent arbitrary Ada functions. Other invokable functions (e.g., independently defined functions in Ada) may also be used as preconditions or postconditions. <p> As with the variety of control models, the combination of local and global exception handling contributes to semantic richness and availability of alternative paradigms. It also allows flexibility that can contribute to ease of use. 3.4 Other Features As noted, we are using the Pleiades <ref> [35] </ref> language to define our products and product consistency conditions. Pleiades provides several high-level type constructors that are especially appropriate for software products, including graphs, relations and relationships, and sequences. A resource model and resource specification language are under development.
References-found: 35

