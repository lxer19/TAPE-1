URL: http://choices.cs.uiuc.edu/2k/papers/MS-naming.ps.gz
Refering-URL: http://choices.cs.uiuc.edu/2k/
Root-URL: http://www.cs.uiuc.edu
Note: c Copyright by Muhammad Ziauddin Hydari, 1999  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Steven Bernstein. </author> <note> Inferno Namespaces. Available from: http://www.lucent-inferno.com/Pages/Developers/Documentation/WhitePapers/namespace.html, 1997. </note>
Reference-contexts: The uniformity of objects in 2K provide an opportunity for a uniform naming service. Thus all 2K objects are part of one single naming hierarchy, and their names can be resolved using a uniform mechanism. 2K is not the first system to use uniform names; Spring [23] and Inferno <ref> [1] </ref> also use uniform naming. We have used a hierarchic name space with a global root. Every client sees the entire system as the same tree of named objects. A global name is interpreted by following the named branches in this tree starting from the global root. <p> The foundations are built on few concepts: a per-user name space that is customizable, a transparent communication protocol 51 called Styx and the familiar file model (open, read, and write). Bernstein <ref> [1] </ref> cites this as a strength of Inferno claiming that representing resources by a common interface is a step to control complexity. In the author's view, requiring all resources and services to support the file model would only make the system unnatural and awkward.
Reference: [2] <author> D. R. Boggs. </author> <title> Internet Broadcasting. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1983. </year>
Reference-contexts: Storing the names of all objects in the system implies that large storage requirements, so for large systems this solution does not scale very well. The Pup name service <ref> [2] </ref> and the DDLCN system [16] use this approach. Distributed Local Approach No information is distributed. Each node maintains only information for local names.
Reference: [3] <author> Christian J. Callsen. </author> <title> Open Heterogeneous Distributed Computing. </title> <type> PhD thesis, </type> <institution> Aalborg University, </institution> <month> August </month> <year> 1994. </year> <note> Available at: http://www-osl.cs.uiuc.edu/. </note>
Reference-contexts: Capabilities may be implemented in several ways, and may be visible or invisible to the user. The advantage of capabilities is that they provide protection against incorrect or malicious behavior; only authorized objects may carry out important operations. Acknowledgment This chapter builds on the presentations in <ref> [3] </ref> and [36]. 30 Chapter 3 The 2K Naming Service "Oh, that's the name of the song, is it?" Alice said, trying to feel interested. "No, you don't understand," the knight said, looking a little vexed. "That's what the name is called.
Reference: [4] <author> Roy H. Campbell. </author> <booktitle> Lecture 1: New Generation Choices in Operating Systems Design. </booktitle> <address> http://www-courses.cs.uiuc.edu/ cs423/lectures/1/ppframe.htm, </address> <month> September </month> <year> 1998. </year>
Reference-contexts: For an example of such an application, see Nicol [20]. This progress has also spawned a number of problems that are not adequately addressed in present operating systems. Some of the problems that the computing community is facing now are <ref> [4] </ref>: * Using a group of machine for performing distributed computation. * Migration of data, computation and users. * Maintenance and updating of software, dependencies between components and porta bility. * Scalability and reliability of systems and software. * Distributed administration of the system. * Security.
Reference: [5] <author> V. G. Cerf and E. Cain. </author> <title> The DoD Internet Architecture Model. </title> <booktitle> In Computer Networks, </booktitle> <pages> pages 307-318, </pages> <year> 1983. </year>
Reference-contexts: As there is no replication of the name server data, all information is lost in case of failure on the central node unless the data is persistently stored and a backup server is maintained. The early DARPA Domain Name System <ref> [17, 5] </ref> is an example of such a system. 20 Fully Distributed Approach All information is distributed. Each node maintains a local name server for managing names. All information is shared among all name servers in the system, and all updates must be propagated to all other name servers.
Reference: [6] <author> David R. Cheriton and Timothy P. Mann. </author> <title> Decentralizing a Global Naming Service for Improved Performance and Fault Tolerance. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(2) </volume> <pages> 147-183, </pages> <year> 1989. </year>
Reference-contexts: The efficiency of the system depends highly on having a high cache hit rate. This is one of the most frequently used methods in distributed systems. It is used in Chorus [25], DOMAIN [15] and the V system <ref> [6] </ref>. 7. Embedding Server Address Within the Identifier: In this approach, object identifiers embed address of the server that knows their current address. The clients contact this server to obtain the address of the object. If the object wishes to migrate, it informs the server which updates the object address. <p> Resolving names by broadcasting to all nodes in the system may become a bottleneck in case of large systems with many nodes. Resolving names cannot be done in parallel on all nodes simultaneously, as broadcasting is a serializing factor. The V naming system <ref> [6] </ref> somewhat follows this approach. 21 Partially Distributed Approach Only necessary information is distributed. This solution is a compromise between the fully distributed and the distributed local approach. <p> In fact, Sheltzer [34] observes just this. Hence it is very desirable to be able to cache results and re-use them if possible. 24 Work done by Sheltzer [34] and by Cheriton and Mann <ref> [6] </ref> has shown that a distributed name cache does actually improves performance. The following characteristics of naming related operation explain why it might be helpful. 1. <p> This approach works well with hierarchical name-spaces. With time, all the upper level contexts will be cached, that will be resolved locally through the cache in the future. Variations and details can be found in <ref> [6] </ref> and [42]. 2. Full Name Cache: In this type of cache, each cache entry consists of a full name of object and its location. Thus this type of caches can be used with both structured and 25 flat name-spaces. <p> Also the life of the cache is the life of the process. When the process terminates, the cache also vanishes. When a process, starts up it has an empty cache and thus has to bear the cost of cache start misses. The V System <ref> [6] </ref> solves this problem by making each process inherit the cache of its parent. Yet another problem is the duplication of information that might exist in each process' cache. <p> Note that various levels of the name tree may have different consistency requirements. 50 Chapter 4 Case studies of Naming Systems In the author's opinion, the most important designs of naming services in the last decade were Butler Lampson's Global Naming Service <ref> [6] </ref> and Cheriton and Mann's naming service [13] for the V distributed system. These have been widely reported and scrutinized in the literature so we will not talk about it here. A succinct introduction can be found in [19].
Reference: [7] <institution> Microsoft Corporation. </institution> <note> Active Directory Technical Summary : White Paper. Available from Microsoft Website. </note>
Reference-contexts: If Steve.Engineering.Acme exists it is an error to try to create Steve.Sales.Acme. This is because each name is mapped to a flat name-space and both the above create Acme"Steve as that name. For further details please see Microsoft's White Papers <ref> [7, 8] </ref>. For a critique, see [9]. 4.3 Globe Naming and Location Service The Globe system is a research project at the Vrije University, Netherlands. The goal of the project is to discover unifying paradigm for the construction of large-scale wide area distributed system.
Reference: [8] <institution> Microsoft Corporation. </institution> <note> Windows NT 5.0 Namespace Desgin : White Paper. Available from Microsoft Website. </note>
Reference-contexts: If Steve.Engineering.Acme exists it is an error to try to create Steve.Sales.Acme. This is because each name is mapped to a flat name-space and both the above create Acme"Steve as that name. For further details please see Microsoft's White Papers <ref> [7, 8] </ref>. For a critique, see [9]. 4.3 Globe Naming and Location Service The Globe system is a research project at the Vrije University, Netherlands. The goal of the project is to discover unifying paradigm for the construction of large-scale wide area distributed system.
Reference: [9] <author> Novell Corporation. </author> <title> The NDS Advantage Comparing to Active Directory. Available from the Novell Website. </title> <type> 59 </type>
Reference-contexts: ACLs determine who can see the object and what actions each user can perform on the object. The existence of an object is never revealed to a user who is not allowed to see it. Active Directory does not provide true hierarchical naming in a directory <ref> [9] </ref>. Consider the following example: The ACME domain has two organizational units: Engineering and Sales. If Steve.Engineering.Acme exists it is an error to try to create Steve.Sales.Acme. This is because each name is mapped to a flat name-space and both the above create Acme"Steve as that name. <p> If Steve.Engineering.Acme exists it is an error to try to create Steve.Sales.Acme. This is because each name is mapped to a flat name-space and both the above create Acme"Steve as that name. For further details please see Microsoft's White Papers [7, 8]. For a critique, see <ref> [9] </ref>. 4.3 Globe Naming and Location Service The Globe system is a research project at the Vrije University, Netherlands. The goal of the project is to discover unifying paradigm for the construction of large-scale wide area distributed system.
Reference: [10] <author> Andrzej Goscinski. </author> <title> Distributed Operating Systems : The Logical Design. </title> <publisher> Addison--Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Schroeder [33] has recognized global names as a fundamental property and naming service as a fundamental service for a distributed system. Yet it has been the most frequently overlooked area of computer science. <ref> [10] </ref> 1 1.1 2K : An Operating System for the Next Millennium This decade has produced huge technological advances in computing. <p> Capabilities are unforgeable tickets specifying one or more permissions, which allow their holder to access a named object. Capabilities may allow reading or updating parts of an object's state, or to receive from or send to a port. Capabilities have the following properties <ref> [10] </ref>: 1. Possession of a capability gives the holder authority to access the object in question. 2. Capabilities allow objects to be shared among several clients. All clients that have capabilities to the object, can share it. 3. Capabilities must be unforgeable and be protected from disclosure by the system.
Reference: [11] <author> Michi Henning. </author> <title> Binding, Migration and Scalability in CORBA. </title> <journal> In Communications of the ACM, </journal> <volume> volume 41. </volume> <publisher> ACM, </publisher> <month> October </month> <year> 1998. </year>
Reference-contexts: The problems with this approach is that the server performance goes down as the number of objects it serves increases. Moreover, an object may be inaccessible because the server is down or unreachable even though the object is reachable. Henning <ref> [11] </ref> discusses these and other problems in detail and some of the proposed solutions. Further details on some of these techniques can be found in [36]. 2.4 Name Space The complete set of names provided by a system form a name space (or a name domain). <p> For applications, the IOR is opaque i.e. applications present the IOR to ORBs as is and do not try to interpret or look into their contents. There are two types of IORs in CORBA <ref> [11] </ref>: 1. Transient IORs: A transient IOR continues to work only for as long as its associated server process remains available. Once the server is shut down, a transient reference becomes permanently nonfunctional (it never works again, even if the server is restarted). 2. <p> Before explaining the actual binding process of persistent IOR, we briefly describe the implementation repository here. The implementation repository is used for registration and activation of objects. Its primary responsibilities are <ref> [11] </ref>: * To maintain a registry of known servers. * To record which server is currently running on what host and which port number. * It starts servers on demand if they are registered for automatic activation. 36 The implementation repository is typically implemented as a process running on a fixed
Reference: [12] <author> Fabio Kon, Ashish Singhai, Roy H. Campbell, Dulcineia Carvalho, Robert Moore, and Francisco J. Ballesteros. </author> <title> 2K: A Reflective, Component-Based Operating System for Rapidly Changing Environments. </title> <booktitle> In Proceedings of the ECOOP'98 Workshop on Reflective Object-Oriented Programming and Systems, </booktitle> <address> Brussels, Belgium, </address> <month> July </month> <year> 1998. </year>
Reference-contexts: They do not have self-adapting components that try to optimize performance in response to these changes. To tackle these problems, the Systems Research Group is working on 2K, a reflective, network-centric, architecture aware distributed operating system <ref> [12] </ref>. 2 Network Centric: Present systems are machine-centric in which users login to "machines". 2K aims to build abstraction of entities on the network and provide a model for the management and mapping of these entities to resources.
Reference: [13] <author> Butler Lampson. </author> <title> Designing a Global Name Service. </title> <booktitle> In Proceedings of the Fifth ACM Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-10, </pages> <address> Calgary, Canada, </address> <year> 1986. </year>
Reference-contexts: Note that various levels of the name tree may have different consistency requirements. 50 Chapter 4 Case studies of Naming Systems In the author's opinion, the most important designs of naming services in the last decade were Butler Lampson's Global Naming Service [6] and Cheriton and Mann's naming service <ref> [13] </ref> for the V distributed system. These have been widely reported and scrutinized in the literature so we will not talk about it here. A succinct introduction can be found in [19].
Reference: [14] <author> Butler Lampson. </author> <note> 6.286 Principles of Computer Systems. Lecture on Naming. Available at: http://www.research.microsoft.com/lampson/48-POCScourse/Abstract.html, March 1997. </note>
Reference-contexts: At a given level of abstraction, we tend to identify objects at that level by "names", the lower level objects that implement them by "addresses" and paths at the lower level by routes <ref> [14] </ref>. For example, choices.cs.uiuc.edu &gt; 128.174.240.21 &gt; (router output port, 8:0:20:9a:9a:bc ethernet address) So a name can be viewed as a logical object that is bound to a particular low level object from a collection of such objects. <p> A name is always interpreted relative to a context [26] Other synonymous terms are closure, directory, folder, environment and dictionary <ref> [14] </ref>. indirect entry in a naming network, an entry in the catalog that binds a name, instead to an object, to the path name of some catalog entry elsewhere in the naming network [26]. junction a junction bridges the global name-space with some other name-space. location independence The name of an
Reference: [15] <author> P. J. Leach, P. H. Levine, B. P. Douros, D. L. Nelson J. A. Hamilton, and B. L. Stumpf. </author> <title> The Architecture of an Integrated Local Network. </title> <journal> IEEE Journal on Selected Areas in Communication, </journal> <pages> pages 842-857, </pages> <year> 1983. </year>
Reference-contexts: If the cache entry does not resolve correctly to the object, broadcasting is used. The efficiency of the system depends highly on having a high cache hit rate. This is one of the most frequently used methods in distributed systems. It is used in Chorus [25], DOMAIN <ref> [15] </ref> and the V system [6]. 7. Embedding Server Address Within the Identifier: In this approach, object identifiers embed address of the server that knows their current address. The clients contact this server to obtain the address of the object.
Reference: [16] <author> M. T. Lin, D. P. Tsoy, and R. C. Lian. </author> <title> Design of a Network Operating System for the Distributed Double-Loop Computer Network. Local Computer Networks, 1982. </title> <publisher> North Holland Company, IFIP. </publisher>
Reference-contexts: Storing the names of all objects in the system implies that large storage requirements, so for large systems this solution does not scale very well. The Pup name service [2] and the DDLCN system <ref> [16] </ref> use this approach. Distributed Local Approach No information is distributed. Each node maintains only information for local names.
Reference: [17] <author> P. V. Mockapetris and K. J. Dunlap. </author> <title> Developement of the Domain Name System. </title> <booktitle> In Proceedings of the SIGCOMM '88 Symposium on Communications Architectures and Protocols, </booktitle> <pages> pages 123-133, </pages> <year> 1988. </year> <month> 60 </month>
Reference-contexts: As there is no replication of the name server data, all information is lost in case of failure on the central node unless the data is persistently stored and a backup server is maintained. The early DARPA Domain Name System <ref> [17, 5] </ref> is an example of such a system. 20 Fully Distributed Approach All information is distributed. Each node maintains a local name server for managing names. All information is shared among all name servers in the system, and all updates must be propagated to all other name servers.
Reference: [18] <author> Sape J. Mullender and Andrew S. Tanenbaum. </author> <title> The Design of a Capability Based Distributed Operating System. </title> <journal> The Computer Journal, </journal> <volume> 23(5) </volume> <pages> 289-300, </pages> <year> 1986. </year>
Reference-contexts: Some of the techniques used for object location, are enumerated below: 1. Broadcasting: As the name implies, in this method a client broadcast's the request to an object. It is processed by every node but only the actual object sends a reply. This method, used in Amoeba, <ref> [18] </ref> is not very scalable and can only be used in a small network of computer with a high speed link. 2. Expanding Ring Broadcast: This technique might be used in a system composed of several LANs.
Reference: [19] <author> Roger Needham. </author> <title> Distributed Systems, </title> <booktitle> chapter 12: Names, </booktitle> <pages> pages 315-328. </pages> <note> Addison-Wesley, second edition, 1993. Sape Mullender (Editor). </note>
Reference-contexts: If the set of possible names is very large while the names that actually refer to objects is very small, the chance of anybody guessing a name correctly is quite small. In this case, names can be used as tickets of permission to access other objects <ref> [19] </ref> System oriented names may be flat and thus contain no information about the object. Alternatively, they may be structured, with one field, for example, consisting of the address of the node where the object is found. Generation of system names is an important issue as they must be unique. <p> However, they are not pure names <ref> [19] </ref>. Although 33 the names do not contain any information on where an object can be found, they do contain information on where they can be looked up to be resolved. <p> These have been widely reported and scrutinized in the literature so we will not talk about it here. A succinct introduction can be found in <ref> [19] </ref>. Here we describe some recent work on naming such as Globe Naming Service, Naming Service for Inferno and the Windows NT Active Directory. The exposition is brief and interested readers are referred to the cited references for details.
Reference: [20] <author> John R. Nicol and Others. </author> <title> How the Internet Helps Build Collaborative Multimedia Applications. </title> <booktitle> In Communications of ACM, </booktitle> <pages> pages 79-85. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1999. </year>
Reference-contexts: The networks connecting computers are offering higher and higher bandwidths. It is now possible to build distributed multimedia applications, which can stream real-time audio and video content. For an example of such an application, see Nicol <ref> [20] </ref>. This progress has also spawned a number of problems that are not adequately addressed in present operating systems.
Reference: [21] <author> OMG. </author> <title> Naming Service Specification, </title> <type> chapter 3. OMG, </type> <month> March </month> <year> 1995. </year>
Reference-contexts: The design principles that have guided the design of the CORBA naming service are reproduced below from <ref> [21] </ref>: 1. The design imparts no semantics or interpretation of the names themselves; this is up to higher-level software. The naming service provides only a structural convention for names, e.g. compound names. 2. The design supports distributed, heterogeneous implementation and administration of names and name contexts. 3. <p> The exceptions thrown by each operation are not shown also. For complete definition please see <ref> [21] </ref>. Overview of the Implementation of the Naming Service in TAO [37] As mentioned earlier, TAO is an open source CORBA compliant ORB developed at the Washington University. It is being used as the preferred ORB for implementing 2K.
Reference: [22] <author> Larry L. Peterson and Bruce S. Davie. </author> <title> Computer Networks: A Systems Approach, </title> <booktitle> chapter 5: Internetworking, </booktitle> <pages> pages 267-275. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1996. </year>
Reference-contexts: A resolution mechanism transforms an object's name, to the corresponding object reference. A name server is a particular implementation of a resolution mechanism that is available on the network and that can be queried by sending a message <ref> [22] </ref>. Schroeder [33] has recognized global names as a fundamental property and naming service as a fundamental service for a distributed system.
Reference: [23] <author> Sanjay Radia, Michael N. Nelson, and Michael L. Powell. </author> <title> The Spring Name Service. </title> <type> Technical report, </type> <institution> Sun Microsystems Laboratories, Inc., </institution> <month> November </month> <year> 1993. </year> <note> SMLI TR-93-16. </note>
Reference-contexts: Names and name services are segregated by type so that a file cannot be bound as an environment variable. Also it is not possible to compose one single naming tree incorporating all these name-spaces <ref> [23] </ref>. The uniformity of objects in 2K provide an opportunity for a uniform naming service. Thus all 2K objects are part of one single naming hierarchy, and their names can be resolved using a uniform mechanism. 2K is not the first system to use uniform names; Spring [23] and Inferno [1] <p> all these name-spaces <ref> [23] </ref>. The uniformity of objects in 2K provide an opportunity for a uniform naming service. Thus all 2K objects are part of one single naming hierarchy, and their names can be resolved using a uniform mechanism. 2K is not the first system to use uniform names; Spring [23] and Inferno [1] also use uniform naming. We have used a hierarchic name space with a global root. Every client sees the entire system as the same tree of named objects. A global name is interpreted by following the named branches in this tree starting from the global root. <p> The solution creates some problem as mentioned earlier. 2K uses the solutions provided by CORBA such as persistent IORs to tackle issues like mobility and replication. 56 Appendix A Glossary bind an operation on a context to associate a name with a particular object <ref> [23] </ref>. component an object that is contained by another object [26]. compound name a sequence of names, relative to some context, that can be used to refer to an object [23]. context an object that contains a set of name-to-object associations or name bindings [23]. <p> and replication. 56 Appendix A Glossary bind an operation on a context to associate a name with a particular object <ref> [23] </ref>. component an object that is contained by another object [26]. compound name a sequence of names, relative to some context, that can be used to refer to an object [23]. context an object that contains a set of name-to-object associations or name bindings [23]. <p> a name with a particular object <ref> [23] </ref>. component an object that is contained by another object [26]. compound name a sequence of names, relative to some context, that can be used to refer to an object [23]. context an object that contains a set of name-to-object associations or name bindings [23]. <p> Abstractly, an element of a context [26]. 57 name space The naming graph spanned by a context, which includes all the bindings of names and objects that accessible directly or indirectly through that context <ref> [23] </ref>. naming graph a context system in which a context may contain the name of any object, including another context. <p> For a given starting context, a given path name selects at most one object from the hierarchy. [26] resolve an operation on a context to obtain the object denoted by a name <ref> [23] </ref>. root the starting context of a naming hierarchy [26]. search abstractly, to examine several contexts looking for one that can successfully resolve a name. <p> In practice, the systematic examination of several contexts of a naming graph, looking for an entry that matches a name presented by some object [26]. simple name a name with a single component <ref> [23] </ref>. unique identifier a name, associated with an object at its creation, that differs from the corresponding name of every other object that has ever been created by this system. user dependent binding binding of names in a shared object to different components depending on the identity of the user of
Reference: [24] <author> Dale Rogerson. </author> <title> Inside COM : Microsoft's Component Object Model. </title> <publisher> Microsoft Press, </publisher> <year> 1997. </year>
Reference-contexts: The real-time timestamp may serve as a unique identifier within each node. These two concatenated together will form a globally unique identifier. A sophisticated version of this approach is used in generating Globally Unique Identifiers (GUID) in Microsoft's COM <ref> [24] </ref>. Note that this scheme requires that the real-time clock rate be higher than the rate at which objects are created. The advantage of this approach is the simplicity with which names can be created. The disadvantage is that such names are location dependent.
Reference: [25] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Guillemont M. Gien, F. Herrmann, C. Kaiser, P. Leonard, S Langlois, and W. Neuhauser. </author> <title> Chorus Distributed Operating System. </title> <booktitle> Computing Systems, </booktitle> <pages> pages 305-379, </pages> <year> 1988. </year>
Reference-contexts: If the cache entry does not resolve correctly to the object, broadcasting is used. The efficiency of the system depends highly on having a high cache hit rate. This is one of the most frequently used methods in distributed systems. It is used in Chorus <ref> [25] </ref>, DOMAIN [15] and the V system [6]. 7. Embedding Server Address Within the Identifier: In this approach, object identifiers embed address of the server that knows their current address. The clients contact this server to obtain the address of the object.
Reference: [26] <author> Jerome H. </author> <title> Saltzer. </title> <booktitle> Lecture Notes in Computer Science, volume 60, chapter Naming and Binding Of Objects, </booktitle> <pages> pages 99-208. </pages> <publisher> Springer Verlag, </publisher> <year> 1978. </year> <editor> R. Bayer, R. M. Graham, and G. </editor> <publisher> Seeguller (Editors). </publisher>
Reference-contexts: Group Naming: A naming system must allow for many objects to be identified by the same name. Such a facility is required for multi casting a request to a number of different objects. 11 2.2 Names According to Saltzer <ref> [26] </ref>, a name can be defined as follows: A character or bit-string identifier that is used to refer to an object on which computation is performed. <p> problem as mentioned earlier. 2K uses the solutions provided by CORBA such as persistent IORs to tackle issues like mobility and replication. 56 Appendix A Glossary bind an operation on a context to associate a name with a particular object [23]. component an object that is contained by another object <ref> [26] </ref>. compound name a sequence of names, relative to some context, that can be used to refer to an object [23]. context an object that contains a set of name-to-object associations or name bindings [23]. A name is always interpreted relative to a context [26] Other synonymous terms are closure, directory, <p> that is contained by another object <ref> [26] </ref>. compound name a sequence of names, relative to some context, that can be used to refer to an object [23]. context an object that contains a set of name-to-object associations or name bindings [23]. A name is always interpreted relative to a context [26] Other synonymous terms are closure, directory, folder, environment and dictionary [14]. indirect entry in a naming network, an entry in the catalog that binds a name, instead to an object, to the path name of some catalog entry elsewhere in the naming network [26]. junction a junction bridges the global <p> always interpreted relative to a context <ref> [26] </ref> Other synonymous terms are closure, directory, folder, environment and dictionary [14]. indirect entry in a naming network, an entry in the catalog that binds a name, instead to an object, to the path name of some catalog entry elsewhere in the naming network [26]. junction a junction bridges the global name-space with some other name-space. location independence The name of an object does not need to be changed if an object changes its location [35]. location transparency The name of the object does not reveal any hint about its location [27, 35]. name in <p> Abstractly, an element of a context <ref> [26] </ref>. 57 name space The naming graph spanned by a context, which includes all the bindings of names and objects that accessible directly or indirectly through that context [23]. naming graph a context system in which a context may contain the name of any object, including another context. <p> An object is located by a multi- component path name relative to some context <ref> [26] </ref>. naming hierarchy a naming graph that is constrained to a tree structured form [26]. object a software (or hardware) structure that is considered to be worthy of a distinct name [26]. path name a multiple component name of an object in a naming network. <p> An object is located by a multi- component path name relative to some context <ref> [26] </ref>. naming hierarchy a naming graph that is constrained to a tree structured form [26]. object a software (or hardware) structure that is considered to be worthy of a distinct name [26]. path name a multiple component name of an object in a naming network. Successive components of the path name are used to select entries in successive contexts. <p> An object is located by a multi- component path name relative to some context <ref> [26] </ref>. naming hierarchy a naming graph that is constrained to a tree structured form [26]. object a software (or hardware) structure that is considered to be worthy of a distinct name [26]. path name a multiple component name of an object in a naming network. Successive components of the path name are used to select entries in successive contexts. The entry selected is taken as the context for use with the next component of the path name. <p> Successive components of the path name are used to select entries in successive contexts. The entry selected is taken as the context for use with the next component of the path name. For a given starting context, a given path name selects at most one object from the hierarchy. <ref> [26] </ref> resolve an operation on a context to obtain the object denoted by a name [23]. root the starting context of a naming hierarchy [26]. search abstractly, to examine several contexts looking for one that can successfully resolve a name. <p> For a given starting context, a given path name selects at most one object from the hierarchy. <ref> [26] </ref> resolve an operation on a context to obtain the object denoted by a name [23]. root the starting context of a naming hierarchy [26]. search abstractly, to examine several contexts looking for one that can successfully resolve a name. In practice, the systematic examination of several contexts of a naming graph, looking for an entry that matches a name presented by some object [26]. simple name a name with a single component [23]. unique <p> name [23]. root the starting context of a naming hierarchy <ref> [26] </ref>. search abstractly, to examine several contexts looking for one that can successfully resolve a name. In practice, the systematic examination of several contexts of a naming graph, looking for an entry that matches a name presented by some object [26]. simple name a name with a single component [23]. unique identifier a name, associated with an object at its creation, that differs from the corresponding name of every other object that has ever been created by this system. user dependent binding binding of names in a shared object to different
Reference: [27] <author> Mahadev Satyanarayanan. </author> <title> Distributed Systems, </title> <booktitle> chapter 14: Distributed File Systems, </booktitle> <pages> pages 353-384. </pages> <note> Addison-Wesley, second edition, 1993. </note> <editor> Sape Mullender (Editor). </editor> <volume> 61 </volume>
Reference-contexts: the naming network [26]. junction a junction bridges the global name-space with some other name-space. location independence The name of an object does not need to be changed if an object changes its location [35]. location transparency The name of the object does not reveal any hint about its location <ref> [27, 35] </ref>. name in practice, a character or bit-string identifier that is used to refer to an object on which computation is performed.
Reference: [28] <author> R. E. Schantz, R. H. Thomas, and G. Bono. </author> <booktitle> The Architecture of the Cronus Distributed Operating System. In Proceedings of the 6th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 250-259, </pages> <year> 1986. </year>
Reference-contexts: If however, they are not found in the creator node, a broadcast is done to find them. The scheme is very efficient if migration is indeed very rare. The Cronus system <ref> [28] </ref> uses this method for locating objects. 5. Using Forward Location Pointer: In this scheme, an object leaves a forwarding pointer at its present location before migration. The client starts from the creator node and follows forwarding pointer until it reaches the object.
Reference: [29] <author> Douglas Schmidt and Steve Vinoski. </author> <title> Object Adapter : Concepts and Terminology. In C++ Report. </title> <address> SIGS, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: Server: The term server is overloaded. It is used for the CORBA object which provides certain services. It is also used to refer to the process, thread or any execution envi ronment in which several servants execute. Object Adapter provide the following functionality <ref> [29] </ref>: Object Reference Generation: Object Adapters are responsible for generating object references for CORBA objects. The object reference contain addressing and protocol information which can be used by ORBs to locate objects. 6 Activation and Deactivation: Object Adapters can activate and deactivate CORBA ob- jects. <p> Building functionality into the ORB to support different implementation will cause the size of the ORB to increase immensely. The Portable Object Adapter (POA) provides transient and persistent object references and the ability to specify various policies for servant. Further details can be found in <ref> [29, 31, 30, 32] </ref> 1.2.2 CORBA Services The CORBA services provide system level services to distributed object applications. They are domain-independent and generally useful for all applications. Examples of CORBA services are: Naming Service: Which allows clients to find the reference of the object from user-friendly names. <p> Rather, it refers to the fact that the lifetimes of such CORBA objects "persist" across server process activation and deactivation cycles <ref> [29, 32] </ref>. Whether an IOR is persistent or transient, is determined by the application at object creation time. A persistent IOR is created by using a Portable Object Adapter with a PERSISTENT lifespan policy. <p> The server side ORB uses the the object key to get the adapter name and the object name. The adapter name is used to identify a table called the Active Object Map <ref> [29] </ref>. The object name is then used as an index in this table to obtain the physical address of the object. 3. The server sends back a reply to the client. The reply may be the result of a successful completion of the operation.
Reference: [30] <author> Douglas Schmidt and Steve Vinoski. </author> <title> C++ Servant Managers for Portable Object Adapter. In C++ Report. </title> <address> SIGS, </address> <month> September </month> <year> 1998. </year>
Reference-contexts: Building functionality into the ORB to support different implementation will cause the size of the ORB to increase immensely. The Portable Object Adapter (POA) provides transient and persistent object references and the ability to specify various policies for servant. Further details can be found in <ref> [29, 31, 30, 32] </ref> 1.2.2 CORBA Services The CORBA services provide system level services to distributed object applications. They are domain-independent and generally useful for all applications. Examples of CORBA services are: Naming Service: Which allows clients to find the reference of the object from user-friendly names. <p> We used the file interface that comes with a TAO example program to access files. A POA with a USE_DEFAULT_SERVANT request processing policy must be used to register the default servant. Implementation details can be looked up in our program and in <ref> [30] </ref>. 3.3.3 Clerk 2K clients access the naming service through a clerk. The clerk exports a logically centralized, logically local service to the client program even though the underlying naming service implementation is distributed, replicated and remote.
Reference: [31] <author> Douglas Schmidt and Steve Vinoski. </author> <title> Developing C++ Servant Classes Using Portable Object Adapter. In C++ Report. </title> <address> SIGS, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Building functionality into the ORB to support different implementation will cause the size of the ORB to increase immensely. The Portable Object Adapter (POA) provides transient and persistent object references and the ability to specify various policies for servant. Further details can be found in <ref> [29, 31, 30, 32] </ref> 1.2.2 CORBA Services The CORBA services provide system level services to distributed object applications. They are domain-independent and generally useful for all applications. Examples of CORBA services are: Naming Service: Which allows clients to find the reference of the object from user-friendly names.
Reference: [32] <author> Douglas Schmidt and Steve Vinoski. </author> <title> Using Portable Object Adapter for Transient and Persistent CORBA Objects. In C++ Report. </title> <address> SIGS, </address> <month> April </month> <year> 1998. </year>
Reference-contexts: Building functionality into the ORB to support different implementation will cause the size of the ORB to increase immensely. The Portable Object Adapter (POA) provides transient and persistent object references and the ability to specify various policies for servant. Further details can be found in <ref> [29, 31, 30, 32] </ref> 1.2.2 CORBA Services The CORBA services provide system level services to distributed object applications. They are domain-independent and generally useful for all applications. Examples of CORBA services are: Naming Service: Which allows clients to find the reference of the object from user-friendly names. <p> Rather, it refers to the fact that the lifetimes of such CORBA objects "persist" across server process activation and deactivation cycles <ref> [29, 32] </ref>. Whether an IOR is persistent or transient, is determined by the application at object creation time. A persistent IOR is created by using a Portable Object Adapter with a PERSISTENT lifespan policy. <p> A persistent IOR is created by using a Portable Object Adapter with a PERSISTENT lifespan policy. The object name (see below) must be provided by the user and the servant must be registered explicitly with the persistent POA <ref> [32] </ref>. Objects such as the root naming context in a system like 2K are good candidate for persistence. An IOR has three major pieces of information: 1. Type Name: The type name identifies the most derived type of the object associated with the IOR when the IOR was created.
Reference: [33] <author> Michael D. Schroeder. </author> <title> Distributed Systems, chapter 1: A State-of-the-Art Distributed System: </title> <booktitle> Computing with BOB, </booktitle> <pages> pages 1-16. </pages> <note> Addison-Wesley, second edition, 1993. Sape Mullender (Editor). </note>
Reference-contexts: A resolution mechanism transforms an object's name, to the corresponding object reference. A name server is a particular implementation of a resolution mechanism that is available on the network and that can be queried by sending a message [22]. Schroeder <ref> [33] </ref> has recognized global names as a fundamental property and naming service as a fundamental service for a distributed system.
Reference: [34] <author> A. B. Sheltzer, R. Lindell, and G. J. Popek. </author> <title> Name Service Locality and Cache Design in a Distributed Computing System. </title> <booktitle> In Proceeding of the Sixth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 512-522. </pages> <publisher> IEEE Press, </publisher> <year> 1986. </year>
Reference-contexts: A clerk per process 2. A clerk per node Clerks may also implement caching which can significantly improve performance. 2.6 Name Caches Names being the primary mechanism through which objects are shared, it is obvious that a lot of network traffic will be naming related. In fact, Sheltzer <ref> [34] </ref> observes just this. Hence it is very desirable to be able to cache results and re-use them if possible. 24 Work done by Sheltzer [34] and by Cheriton and Mann [6] has shown that a distributed name cache does actually improves performance. <p> In fact, Sheltzer <ref> [34] </ref> observes just this. Hence it is very desirable to be able to cache results and re-use them if possible. 24 Work done by Sheltzer [34] and by Cheriton and Mann [6] has shown that a distributed name cache does actually improves performance. The following characteristics of naming related operation explain why it might be helpful. 1.
Reference: [35] <author> Abraham Silberschatz and Peter B. Galvin. </author> <booktitle> Operating System Concepts, </booktitle> <pages> pages 525-569. </pages> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: a name, instead to an object, to the path name of some catalog entry elsewhere in the naming network [26]. junction a junction bridges the global name-space with some other name-space. location independence The name of an object does not need to be changed if an object changes its location <ref> [35] </ref>. location transparency The name of the object does not reveal any hint about its location [27, 35]. name in practice, a character or bit-string identifier that is used to refer to an object on which computation is performed. <p> the naming network [26]. junction a junction bridges the global name-space with some other name-space. location independence The name of an object does not need to be changed if an object changes its location [35]. location transparency The name of the object does not reveal any hint about its location <ref> [27, 35] </ref>. name in practice, a character or bit-string identifier that is used to refer to an object on which computation is performed.
Reference: [36] <author> Pradeep K. Sinha. </author> <title> Distributed Operating Systems : Concepts and Design. </title> <publisher> IEEE Computer Society, </publisher> <month> December </month> <year> 1996. </year>
Reference-contexts: The other technique is to have a server is each domain, which generates unique identifiers within that domains. The concatenation of the server identifier with the unique identifier that the server generates results in a globally unique identifier for the object. Sinha <ref> [36] </ref> presents ways to ensure that the server generates unique identifiers across server crashes. 2.3 Object Locating Mechanisms Object locating is the process of mapping an object's system identifier to the location of the object. Some of the techniques used for object location, are enumerated below: 1. <p> Moreover, an object may be inaccessible because the server is down or unreachable even though the object is reachable. Henning [11] discusses these and other problems in detail and some of the proposed solutions. Further details on some of these techniques can be found in <ref> [36] </ref>. 2.4 Name Space The complete set of names provided by a system form a name space (or a name domain). <p> Capabilities may be implemented in several ways, and may be visible or invisible to the user. The advantage of capabilities is that they provide protection against incorrect or malicious behavior; only authorized objects may carry out important operations. Acknowledgment This chapter builds on the presentations in [3] and <ref> [36] </ref>. 30 Chapter 3 The 2K Naming Service "Oh, that's the name of the song, is it?" Alice said, trying to feel interested. "No, you don't understand," the knight said, looking a little vexed. "That's what the name is called.
Reference: [37] <author> Umar Syyid. </author> <title> An Overview of TAO's Naming Service. </title> <type> Personal Communication. 62 </type>
Reference-contexts: The exceptions thrown by each operation are not shown also. For complete definition please see [21]. Overview of the Implementation of the Naming Service in TAO <ref> [37] </ref> As mentioned earlier, TAO is an open source CORBA compliant ORB developed at the Washington University. It is being used as the preferred ORB for implementing 2K.
Reference: [38] <author> Maarten van Steen, F.J. Hauck, G. Ballintijn, </author> <title> and A.S. Tanenbaum. Algorithmic Design of the Globe Wide-Area Location Service . The Computer Journal, </title> <booktitle> 41(5) </booktitle> <pages> 297-310, </pages> <year> 1998. </year>
Reference-contexts: They claim the object handle to be pure name but then encode region information to optimize lookup. Thus object handles are not pure names. Details of update, deletion, lookup, various optimizations for fast lookup and partitioning of name space to alleviate storage problems should be looked up in <ref> [38, 39, 40] </ref>. 55 4.4 Summary The most influential distributed naming systems from the previous decade are Lampson's GNS and Cheriton's Naming Service for the V System. We looked at three recent naming services. Inferno is a network operating system that forces all objects to have a file interface.
Reference: [39] <author> Maarten van Steen, F.J. Hauck, P. Homburg, </author> <title> and A.S. Tanenbaum. Locating Objects in Wide-Area Systems. </title> <journal> In IEEE Communications Magazine, </journal> <pages> pages 104-109. </pages> <publisher> IEEE, </publisher> <month> January </month> <year> 1998. </year>
Reference-contexts: They claim the object handle to be pure name but then encode region information to optimize lookup. Thus object handles are not pure names. Details of update, deletion, lookup, various optimizations for fast lookup and partitioning of name space to alleviate storage problems should be looked up in <ref> [38, 39, 40] </ref>. 55 4.4 Summary The most influential distributed naming systems from the previous decade are Lampson's GNS and Cheriton's Naming Service for the V System. We looked at three recent naming services. Inferno is a network operating system that forces all objects to have a file interface.
Reference: [40] <author> Maarten van Steen, F.J. Hauck, </author> <title> and A.S. Tanenbaum. A Model for Worldwide Tracking of Distributed Objects. </title> <booktitle> In Proceedings TINA '96 Conference, </booktitle> <pages> pages 203-212, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: They claim the object handle to be pure name but then encode region information to optimize lookup. Thus object handles are not pure names. Details of update, deletion, lookup, various optimizations for fast lookup and partitioning of name space to alleviate storage problems should be looked up in <ref> [38, 39, 40] </ref>. 55 4.4 Summary The most influential distributed naming systems from the previous decade are Lampson's GNS and Cheriton's Naming Service for the V System. We looked at three recent naming services. Inferno is a network operating system that forces all objects to have a file interface.
Reference: [41] <author> Steve Vinoski. </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments. </title> <journal> In IEEE Communications Magazine, </journal> <volume> volume 14. </volume> <publisher> IEEE, </publisher> <month> Febuary </month> <year> 1997. </year>
Reference-contexts: CORBA is a standard for distributed object computing proposed by Object Management Group (OMG). CORBA provides for the development and deployment of applications in distributed heterogeneous environments. CORBA is part of the Object Management Architecture (OMA), which consists of five major elements <ref> [41] </ref>: 1. The Object Request Broker (ORB) 2. CORBA Services 3. CORBA Facilities 4. Domain Interfaces 3 5. <p> The Interface Repository (IR) is a CORBA object which allows clients to access the IDL type system and write it programmatically. As the IR allows applications to programmatically 5 discover type information at runtime, its real utility lies in its support of the Dynamic Invocation Interface <ref> [41] </ref>. Object Adapters Object Adapters serve as a glue between the ORB and the server object. They adapt the programming language concept of servants to the CORBA concept of objects. There is a bit of confusion in the terminology used, so we define some related terms first. <p> They are used often enough in the particular segment that it is useful to standardize them. Vinoski <ref> [41] </ref> cites Distributed Document Component Facility (DDCF), a compound document facility based on OpenDoc as an example. DDCF allows for the presentation and interchange of objects based on a document model.
Reference: [42] <author> Brian Welch and John K. Ousterhout. </author> <title> Prefix Tables: A Simple Mechanism for Locating Files in a Distributed System. </title> <booktitle> In Proceeding of the Sixth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 184-189. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year>
Reference-contexts: This approach works well with hierarchical name-spaces. With time, all the upper level contexts will be cached, that will be resolved locally through the cache in the future. Variations and details can be found in [6] and <ref> [42] </ref>. 2. Full Name Cache: In this type of cache, each cache entry consists of a full name of object and its location. Thus this type of caches can be used with both structured and 25 flat name-spaces.
Reference: [43] <author> D. Wiebe. </author> <title> A Distributed Repository for Immutable Persistent Objects. </title> <booktitle> In Proceedings of OOPSLA '86, </booktitle> <pages> pages 453-465. </pages> <institution> Association of Computing Machinery, </institution> <year> 1986. </year>
Reference-contexts: If the object is not found, the request is broadcast in all the adjacent LANs. This process is repeated until the object is found or all the LANs have been searched. Wiebe <ref> [43] </ref> describes such a system. 3. Encoding Location of an Object Within its Identifier: In this scheme, the address of the object is embedded in the identifier itself. This makes the identifier location dependent and migration impossible without altering the identifier. Also multiple replicas of an object cannot be supported.
Reference: [44] <author> Stanley Zdonik and Michael Franklin. </author> <title> A Framework for Scalable Dissemination Based Systems. </title> <booktitle> In Proceedings of the 12th Conference on Object-Oriented Programming, Systems, Languages, and Applications, Sigplan Notices:32(10), </booktitle> <pages> pages 94-105. </pages> <booktitle> ACM Sigplan, </booktitle> <month> October </month> <year> 1997. </year> <month> 63 </month>
Reference-contexts: Sending irrelevant data is a waste of resources whereas not sending required data causes a fall back to the pull model. One way to solve this problem is to allow the clients to provide a profile of their interests to the servers. Publish/Subscribe <ref> [44] </ref> model may be used for this. In 2K, clerks are a natural point where the name servers can push naming data. These clerks can cache pushed data and use it to resolve names locally on client requests. <p> In 2K, clerks are a natural point where the name servers can push naming data. These clerks can cache pushed data and use it to resolve names locally on client requests. What names should be pushed that will cause performance improvement needs to be explored. In fact, in <ref> [44] </ref>, Franklin and Zdonik propose the notion of a Dissemination-Based Information System (DBIS) which integrate a variety of data delivery mechanisms and information broker hierarchies.
References-found: 44

