URL: ftp://ftp.cse.unsw.edu.au/pub/doc/papers/UNSW/9401.ps.Z
Refering-URL: http://www.cse.unsw.edu.au/school/research/tr.html
Root-URL: http://www.cse.unsw.edu.au
Title: Extending Statecharts with Temporal Logic  
Author: A. Sowmya and S. Ramesh 
Affiliation: SCHOOL OF COMPUTER SCIENCE AND ENGINEERING THE UNIVERSITY OF NEW SOUTH WALES  
Abstract: SCS&E Report 9401 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Koymans and R. Kuiper, </author> <title> "Paradigms for real-time systems", in Formal Techniques in real-time and fault-tolerant systems, </title> <editor> ed. Joseph, M., </editor> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 331), </volume> <pages> pp. 159-174, </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year> <month> 21 </month>
Reference-contexts: An alternative way to define a system from inside out is to view the system as possessing a set of behaviours, which it exhibits over time. One could then specify both the behaviour and function of such a system from the following perspectives <ref> [1] </ref>: * the behavioural specification of the system, which specifies how a system behaviour is gen erated by specifying the information processing required to generate it * the functional specification of the system, which specifies what the system behaviours are, by describing the causal and temporal relationships between behaviours as well
Reference: 2. <author> A. Pnueli, </author> <title> "Applications of temporal logic to the specification and verification of reactive systems: a survey of current trends", in Current trends in concurrency, </title> <editor> ed. J. W. de Bakker, W. P. de Roever, and G. Rozenberg, </editor> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 224), </volume> <pages> pp. 510-584, </pages> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: The motivation for this paper is to study the appropriateness of such a two-pronged specification system for a special class of systems called reactive systems, of which embedded systems discussed earlier are an example. The term reactive has been adopted for systems that exhibit interactive behaviours with their environments <ref> [2, 3] </ref>. A reactive system is characterized by being event-driven, continually reacting to external and internal stimuli, so that the system cannot be described independent of its environment. Reactive systems usually involve concurrency, though the reverse 1 is not always true. <p> The application of temporal logic to reactive systems has been studied by Pnueli <ref> [2] </ref>. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance [47]. <p> Pnueli <ref> [2] </ref> refers to the classification of temporal logic formulae into safety and liveness properties. Since our language too uses temporal operators, we can express safety and liveness properties in our language. Safety or invariance A safety property states that all finite prefixes of a computation satisfy some requirements. <p> Putting these together, a linear integer model of time best fits the existing semantics, since it enables references to histories of events; besides past formulae are purely behavioural descriptions and hence suit our application. In any case, past and future formulae are equivalent <ref> [2] </ref>. It was important to keep the temporal language design consistent with statecharts semantics, since our verification methodology depends on relating the two specifications together through their semantics. The functional flavour of FNLOG helps to retain the compositionality of statecharts specifications, by facilitating compositional FNLOG specifications. <p> The first two are syntactic conveniences, while the third has semantic significance. The temporal primitives of events and activities were a happy choice. They worked perfectly in defining the proof system and proved convenient for specifications to support event-based specifications. Pnueli has shown <ref> [2] </ref> that temporal logic must be augmented to specify event predicates. Hence our choice of primitives to augment past linear time temporal logic is supported by the theory and by our subsequent experiences. The most serious problem we encountered with past temporal logic was the treatment of time.
Reference: 3. <author> R. Kurki-Suonio and T. Kankaanpaa, </author> <title> "On the design of reactive systems", </title> <journal> BIT, </journal> <volume> Vol. 28, </volume> <pages> pp. 581-604, </pages> <year> 1988. </year>
Reference-contexts: The motivation for this paper is to study the appropriateness of such a two-pronged specification system for a special class of systems called reactive systems, of which embedded systems discussed earlier are an example. The term reactive has been adopted for systems that exhibit interactive behaviours with their environments <ref> [2, 3] </ref>. A reactive system is characterized by being event-driven, continually reacting to external and internal stimuli, so that the system cannot be described independent of its environment. Reactive systems usually involve concurrency, though the reverse 1 is not always true.
Reference: 4. <author> D. Harel, "Statecharts: </author> <title> a visual approach to complex systems", </title> <journal> Science of Computer Programming, Vol.8, </journal> <volume> No. 3, </volume> <pages> p. 231-274, </pages> <year> 1987. </year>
Reference-contexts: Our hypothesis is that the specification of behaviours and functions requires a combination of methods, languages and models of specification. Our approach is to combine one of the existing specification languages for reactive systems with temporal logic. The language we choose for this purpose is statecharts, due to Harel <ref> [4] </ref> and we extend the applicability of statecharts by creating a complementary language based on linear temporal logic. Our approach retains statecharts and its semantics, and combines it with the temporal logic-based language by building a semantic bridge between the two. <p> For the behavioural description of reactive systems, a number of special purpose specification languages have been proposed, including Petri nets [15], CCS [16], sequence diagrams [17] and Esterel [18]. Harel's statecharts was developed specifically for real-time reactive systems <ref> [4] </ref>. It possesses a number of distinctive features: the approach is diagrammatic, in keeping with Harel's belief in the virtue of visual descriptions. It is an extension of state machines and state diagrams, with a formal syntax and semantics. <p> A Specification of a Real-time Reactive System For transformational systems, a transformation or function specifies the system behaviour. Harel <ref> [4] </ref> defines the behaviour of a reactive system as the set of allowed sequences of input and output events, conditions and actions and additional information such as timing constraints. <p> B Statecharts Statecharts was designed to address these general issues, and it is an extension of the state/event formalism that satisfies software engineering principles such as structuredness and refinement, while retaining the visual appeal of state diagrams <ref> [4] </ref>. In statecharts, conventional finite state machines are extended by AND/OR decomposition of states, inter-level transitions and an implicit inter-component broadcast communication. A stat-echarts specification can be visualized as a tree of states, where the leaf states correspond to the conventional notion of states in FSM's. <p> A Motivation for Design Decisions To start with, we had a visual specification language for the specification of real-time reactive systems. This language, statecharts, is beginning to gain acceptance in industry circles as a preliminary design aid, in keeping with its origins in academy/industry interaction <ref> [4] </ref>. Early on in this work, we decided to retain the visual aspect of statecharts for the human advantages it offers. Additionally, the visual nature of statecharts aids modular, top-down system development by providing visual counterparts to clustering/orthogonality and refinement.
Reference: 5. <author> D. L. Parnas, </author> <title> "On the use of transition diagrams in the design of a user interface for an interactive computer system", </title> <booktitle> Proc. ACM Conf., </booktitle> <pages> pp. 379-385, </pages> <year> 1969. </year>
Reference-contexts: B Related Work For reactive systems, a number of approaches to decomposition and specification have been proposed. Many of these methods are based on states and events to describe dynamic behaviour, with a finite state machine (FSM) as the underlying formalism <ref> [5, 6, 7, 8, 9, 10, 11] </ref>. This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed.
Reference: 6. <author> R. J. K. Jacob, </author> <title> "Using formal specifications in the design of a human-computer interface", </title> <journal> Comm. ACM, </journal> <volume> Vol. 26, </volume> <pages> pp. 259-264, </pages> <year> 1983. </year>
Reference-contexts: B Related Work For reactive systems, a number of approaches to decomposition and specification have been proposed. Many of these methods are based on states and events to describe dynamic behaviour, with a finite state machine (FSM) as the underlying formalism <ref> [5, 6, 7, 8, 9, 10, 11] </ref>. This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed.
Reference: 7. <author> A. B. Ferrentino and H. D. Mills, </author> <title> "State machines and their semantics in software engineering", </title> <booktitle> Proc. IEEE COMPSAC '77 Conf., </booktitle> <pages> pp. 242-251, </pages> <year> 1977. </year>
Reference-contexts: B Related Work For reactive systems, a number of approaches to decomposition and specification have been proposed. Many of these methods are based on states and events to describe dynamic behaviour, with a finite state machine (FSM) as the underlying formalism <ref> [5, 6, 7, 8, 9, 10, 11] </ref>. This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed.
Reference: 8. <author> M. D. Edwards and D. Aspinall, </author> <title> "The synthesis of digital systems using ASM design techniques", in Computer Hardware description languages and their applications, </title> <editor> eds Uehara and Barbacci, </editor> <publisher> North Holland, </publisher> <pages> pp. 55-64, </pages> <year> 1983. </year>
Reference-contexts: B Related Work For reactive systems, a number of approaches to decomposition and specification have been proposed. Many of these methods are based on states and events to describe dynamic behaviour, with a finite state machine (FSM) as the underlying formalism <ref> [5, 6, 7, 8, 9, 10, 11] </ref>. This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed.
Reference: 9. <author> A. S. Tanenbaum, </author> <title> Computer Networks, </title> <address> Englewood, NJ: </address> <publisher> Prentice-Hall Inc., </publisher> <year> 1981. </year>
Reference-contexts: B Related Work For reactive systems, a number of approaches to decomposition and specification have been proposed. Many of these methods are based on states and events to describe dynamic behaviour, with a finite state machine (FSM) as the underlying formalism <ref> [5, 6, 7, 8, 9, 10, 11] </ref>. This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed.
Reference: 10. <author> C. A. Sunshine et al., </author> <title> "Specification and verification of communication protocols in AFFIRM using state transition models", </title> <journal> IEEE Trans. Soft. Engg, </journal> <volume> Vol. SE-8, </volume> <pages> pp. 460-489, </pages> <year> 1982. </year>
Reference-contexts: B Related Work For reactive systems, a number of approaches to decomposition and specification have been proposed. Many of these methods are based on states and events to describe dynamic behaviour, with a finite state machine (FSM) as the underlying formalism <ref> [5, 6, 7, 8, 9, 10, 11] </ref>. This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed.
Reference: 11. <author> S. </author> <title> Feyock, </title> <journal> "Transition=based CAI/HELP systems", Int. J. Man-machine studies, </journal> <volume> Vol. 9, </volume> <pages> pp. 399-413, </pages> <year> 1977. </year>
Reference-contexts: B Related Work For reactive systems, a number of approaches to decomposition and specification have been proposed. Many of these methods are based on states and events to describe dynamic behaviour, with a finite state machine (FSM) as the underlying formalism <ref> [5, 6, 7, 8, 9, 10, 11] </ref>. This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed.
Reference: 12. <author> CCITT (International Telecommunication Union), </author> <title> "Functional Specification and Description Language (SDL)", </title> <booktitle> Recommendations Z.101-Z.104, Vol VI, </booktitle> <address> Fasc. VI.7, Geneva, </address> <year> 1981. </year>
Reference-contexts: This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's <ref> [12] </ref> and Augmented Transition Networks [13, 14] have also been proposed. For the behavioural description of reactive systems, a number of special purpose specification languages have been proposed, including Petri nets [15], CCS [16], sequence diagrams [17] and Esterel [18]. Harel's statecharts was developed specifically for real-time reactive systems [4].
Reference: 13. <author> W. A. Woods, </author> <title> "Transition network grammars for natural language analysis", </title> <journal> Comm. ACM, </journal> <volume> Vol. 13, </volume> <pages> pp. 591-606, </pages> <year> 1970. </year>
Reference-contexts: This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks <ref> [13, 14] </ref> have also been proposed. For the behavioural description of reactive systems, a number of special purpose specification languages have been proposed, including Petri nets [15], CCS [16], sequence diagrams [17] and Esterel [18]. Harel's statecharts was developed specifically for real-time reactive systems [4].
Reference: 14. <author> A. Wasserman. </author> <title> "Extending state transition diagrams for the specification of human-computer interaction", </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. SE-11, </volume> <pages> pp. 699-713, </pages> <year> 1985. </year>
Reference-contexts: This approach has several drawbacks, such as exponential growth in the number of states and lack of a structured representation. Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks <ref> [13, 14] </ref> have also been proposed. For the behavioural description of reactive systems, a number of special purpose specification languages have been proposed, including Petri nets [15], CCS [16], sequence diagrams [17] and Esterel [18]. Harel's statecharts was developed specifically for real-time reactive systems [4].
Reference: 15. <author> W. Reisig, </author> <title> Petri Nets: an introduction, </title> <publisher> Berlin: Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed. For the behavioural description of reactive systems, a number of special purpose specification languages have been proposed, including Petri nets <ref> [15] </ref>, CCS [16], sequence diagrams [17] and Esterel [18]. Harel's statecharts was developed specifically for real-time reactive systems [4]. It possesses a number of distinctive features: the approach is diagrammatic, in keeping with Harel's belief in the virtue of visual descriptions.
Reference: 16. <author> R. Milner, </author> <title> A calculus of communication systems, </title> <booktitle> (Lecture Notes in Computer Science, </booktitle> <address> Vol.92), </address> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed. For the behavioural description of reactive systems, a number of special purpose specification languages have been proposed, including Petri nets [15], CCS <ref> [16] </ref>, sequence diagrams [17] and Esterel [18]. Harel's statecharts was developed specifically for real-time reactive systems [4]. It possesses a number of distinctive features: the approach is diagrammatic, in keeping with Harel's belief in the virtue of visual descriptions.
Reference: 17. <author> P. Zave, </author> <title> "A distributed alternative to finite- state-machine specifications", </title> <journal> ACM TOPLAS, </journal> <volume> Vol. 7, No. 1, </volume> <pages> pp. 10-36, </pages> <year> 1985. </year>
Reference-contexts: Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed. For the behavioural description of reactive systems, a number of special purpose specification languages have been proposed, including Petri nets [15], CCS [16], sequence diagrams <ref> [17] </ref> and Esterel [18]. Harel's statecharts was developed specifically for real-time reactive systems [4]. It possesses a number of distinctive features: the approach is diagrammatic, in keeping with Harel's belief in the virtue of visual descriptions.
Reference: 18. <author> G. Berry and L. Cosserat, </author> <title> "The ESTEREL synchronous programming language and its mathematical semantics", in Seminar on Concurrency, </title> <editor> ed. S. D. Brookes, A. W. Roscoe and G. Winskel, </editor> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 197), </volume> <publisher> Springer Verlag, </publisher> <pages> pp. 389-448, </pages> <year> 1985. </year>
Reference-contexts: Improvements on FSM's such as communicating FSM's [12] and Augmented Transition Networks [13, 14] have also been proposed. For the behavioural description of reactive systems, a number of special purpose specification languages have been proposed, including Petri nets [15], CCS [16], sequence diagrams [17] and Esterel <ref> [18] </ref>. Harel's statecharts was developed specifically for real-time reactive systems [4]. It possesses a number of distinctive features: the approach is diagrammatic, in keeping with Harel's belief in the virtue of visual descriptions. It is an extension of state machines and state diagrams, with a formal syntax and semantics. <p> When event a is generated externally in this configuration, the transition from and to state H will generate b, causing a transition from F to G which generates c, all in one time-step. Synchronization and Real-time Statecharts incorporates Berry's <ref> [18] </ref> strong synchrony hypothesis: an execution machine for a system is infinitely fast (which defines synchrony) and control takes no time. This hypothesis facilitates the specification task by abstracting from internal reaction time. The synchrony hypothesis might create causal paradoxes like an event causing itself.
Reference: 19. <author> B. T. Hailpern, </author> <title> Verifying concurrent processes using temporal logic, </title> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 129), </pages> <address> New York: </address> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Thus, statecharts redresses many of the shortcomings of FSM's for the specification of real time reactivity. The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency <ref> [19, 20, 21, 22, 23, 24, 25, 26] </ref>, program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42].
Reference: 20. <author> R. Kuiper and W. P. </author> <title> de Roever,"Fairness assumptions in CSP in a temporal logic framework", </title> <booktitle> Proc. IFIP Working Comf. on formal descriptions of programming concepts II, </booktitle> <pages> pp. 127-134, </pages> <year> 1982. </year>
Reference-contexts: Thus, statecharts redresses many of the shortcomings of FSM's for the specification of real time reactivity. The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency <ref> [19, 20, 21, 22, 23, 24, 25, 26] </ref>, program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42].
Reference: 21. <author> L. Lamport, </author> <title> "Proving the correctness of multiprocess programs", </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. SE-3, No. 2, </volume> <pages> pp. 125-143, </pages> <year> 1977. </year> <month> 22 </month>
Reference-contexts: Thus, statecharts redresses many of the shortcomings of FSM's for the specification of real time reactivity. The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency <ref> [19, 20, 21, 22, 23, 24, 25, 26] </ref>, program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42].
Reference: 22. <author> L. Lamport, </author> <title> "What good is temporal logic?", </title> <booktitle> Proc. </booktitle> <publisher> IFIP , North Holland, </publisher> <pages> pp. 657-668, </pages> <year> 1983. </year>
Reference-contexts: Thus, statecharts redresses many of the shortcomings of FSM's for the specification of real time reactivity. The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency <ref> [19, 20, 21, 22, 23, 24, 25, 26] </ref>, program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. <p> The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency <ref> [22, 43] </ref>, fault-tolerance [44, 45, 46] and performance [47]. On combining temporal logic with 2 another specification formalism, Wing and Nixon [48] extend Ina Jo, an existing specification language for secure operating systems, with branching time temporal logic in order to increase Ina Jo's expressibility.
Reference: 23. <author> L. Lamport, </author> <title> "Specifying concurrent program modules", </title> <journal> ACM Trans. Program, Lang. Syst., </journal> <volume> Vol. 5, No. 2, </volume> <pages> pp. 190-222, </pages> <year> 1983. </year>
Reference-contexts: Thus, statecharts redresses many of the shortcomings of FSM's for the specification of real time reactivity. The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency <ref> [19, 20, 21, 22, 23, 24, 25, 26] </ref>, program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42].
Reference: 24. <author> Z. Manna and A. Pnueli, </author> <title> "The temporal framework of concurrent programs", in The correctness problem in computer science, </title> <editor> eds R. S. Boyer and J. S. Moore, </editor> <publisher> Academic Press, </publisher> <address> p. 215-274, </address> <year> 1981. </year>
Reference-contexts: Thus, statecharts redresses many of the shortcomings of FSM's for the specification of real time reactivity. The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency <ref> [19, 20, 21, 22, 23, 24, 25, 26] </ref>, program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42].
Reference: 25. <author> Z. Manna and A. Pnueli, </author> <title> "How to cook a temporal proof for your pet language", </title> <booktitle> Proc. 10th ACM POPL, </booktitle> <year> 1983. </year>
Reference-contexts: Thus, statecharts redresses many of the shortcomings of FSM's for the specification of real time reactivity. The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency <ref> [19, 20, 21, 22, 23, 24, 25, 26] </ref>, program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42].
Reference: 26. <author> Z. Manna and A. </author> <title> Pnueli "Verification of concurrent programs: a temporal proof system", </title> <booktitle> Foundations of Computer Science IV, </booktitle> <editor> eds J. W. de Bakker and J. Van Leeuwen, </editor> <publisher> Mathematical Center Tracts 159, Amsterdam, </publisher> <pages> pp. 163-255, </pages> <year> 1983. </year>
Reference-contexts: Thus, statecharts redresses many of the shortcomings of FSM's for the specification of real time reactivity. The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency <ref> [19, 20, 21, 22, 23, 24, 25, 26] </ref>, program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42].
Reference: 27. <author> O. Lichtenstein, A. Pnueli, and L. </author> <title> Zuck,"The glory of the past", Logics of programs, </title> <booktitle> (Lecture Notes in Computer Science), </booktitle> <year> 1985. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness <ref> [27, 28, 29, 30, 31] </ref>, communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 28. <author> S. Owicki and l. Lamport, </author> <title> "Proving liveness properties of concurrent programs", </title> <journal> ACM TOPLAS, </journal> <volume> Vol. 4, No. 3, </volume> <pages> pp. 455-495, </pages> <year> 1982. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness <ref> [27, 28, 29, 30, 31] </ref>, communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 29. <author> A. Pnueli, </author> <title> "The temporal logic of programs", </title> <booktitle> 18th IEEE Symp. of Foundations of Computer Science, </booktitle> <pages> pp. 46-57, </pages> <year> 1977. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness <ref> [27, 28, 29, 30, 31] </ref>, communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 30. <author> A. Pnueli, </author> <title> "In transition from global to modular temporal reasoning about programs", in Logic and models of concurrent systems, </title> <editor> ed. K. R. Apt, </editor> <publisher> Springer Verlag, </publisher> <pages> pp. 123-144, </pages> <year> 1985. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness <ref> [27, 28, 29, 30, 31] </ref>, communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 31. <author> A. P. Sistla and S. M. </author> <title> German, "Reasoning with many processes", </title> <booktitle> IEEE Symp. Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <pages> pp. 138-152, </pages> <year> 1987. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness <ref> [27, 28, 29, 30, 31] </ref>, communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 32. <author> B. T. Hailpern, </author> <title> "Verifying concurrent processes using temporal logic", </title> <booktitle> (Lecture Notes in Computer Science 129), </booktitle> <address> New York: </address> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems <ref> [32, 33, 34, 35] </ref>, parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 33. <author> B. Hailpern and S. Owicki, </author> <title> "Modular verification of computer communication protocols", </title> <journal> IEEE Trans. Comm., </journal> <volume> Vol. COM-31, No. 1, </volume> <pages> pp. 56-68, </pages> <year> 1983. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems <ref> [32, 33, 34, 35] </ref>, parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 34. <author> V. Nguyen, D. Gries and S. Owicki, </author> <title> "A model and temporal proof system for network of processes", </title> <booktitle> 12th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pp. 121-131, </pages> <year> 1985. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems <ref> [32, 33, 34, 35] </ref>, parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 35. <author> R. L. Schwartz and P. M. Melliar-Smith, </author> <title> "From state machines to temporal logic: specification methods for protocol standards", </title> <journal> IEEE Trans. Comm., </journal> <volume> Vol. COM-30, No. 12, </volume> <pages> pp. 2486-2496, </pages> <year> 1982. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems <ref> [32, 33, 34, 35] </ref>, parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2]. <p> Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines <ref> [35, 41, 42] </ref>. The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance [47].
Reference: 36. <author> S. Owicki and D. Gries, </author> <title> "An axiomatic proof technique for parallel programs", </title> <journal> Acta Infor-matica, </journal> <volume> Vol. 6, </volume> <pages> pp. 319-340, </pages> <year> 1976. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs <ref> [36, 37] </ref>, real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 37. <author> E. M. Clarke, D. E. Mong and K. L. McMillan, </author> <title> "Compositional Model checking", </title> <booktitle> Proc. IEEE 4th Annual Symp. LICS, </booktitle> <address> Cambridge, MA., </address> <pages> pp. 353-362, </pages> <year> 1989. </year>
Reference-contexts: The literature on the applicability of temporal logic to specification and verification is prolific. Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs <ref> [36, 37] </ref>, real-time systems [38, 39, 40] and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2].
Reference: 38. <author> T. A. Henzinger, Z. Manna and A. Pnueli, </author> <title> "Temporal proof methodologies for real-time systems", </title> <booktitle> Proc. 18th Ann. ACM Symp. Principles of programming languages, </booktitle> <pages> pp. 353-366, </pages> <year> 1991. </year>
Reference-contexts: Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems <ref> [38, 39, 40] </ref> and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance [47].
Reference: 39. <author> R. Alur, C. Courcoubetis and D. Dill, </author> <title> "Model-checking for probabilistic real-time systems", </title> <booktitle> Proc. ICALP, </booktitle> <year> 1991. </year>
Reference-contexts: Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems <ref> [38, 39, 40] </ref> and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance [47].
Reference: 40. <author> A. Pnueli and E. Harel, </author> <title> "Applications of temporal logic to the specification of real-time systems", in Formal Techniques in real-time and fault-tolerant systems, </title> <editor> ed. Joseph, M., </editor> <booktitle> (Lecture Notes in Computer Science 331), </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 84-98, </pages> <year> 1988. </year> <month> 23 </month>
Reference-contexts: Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems <ref> [38, 39, 40] </ref> and also applied to automata/state machines [35, 41, 42]. The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance [47]. <p> The Quantifiers The existential and universal quantifiers are allowed to range over the time variable t in our logic-based functional specification language. Actually, even our temporal operators are short-hand notations to indicate range over time t. We borrow from quantified temporal logic <ref> [40] </ref> and introduce quantified temporal operators as short hand for quantification: fi tk true k instants before time t 3 tk t true at some instant in the interval [t-k,t] 2 tk t true at all instants in the interval [t-k,t] Two of these operators are short hand for the following
Reference: 41. <author> M. Y. Vardi and P. </author> <title> Wolper "An automata-theoretic approach to automatic program verifica-tion", </title> <booktitle> Proc. 1986 IEEE Symp. LICS, </booktitle> <address> Cambridge, MA, </address> <pages> pp. 332-344, </pages> <year> 1986. </year>
Reference-contexts: Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines <ref> [35, 41, 42] </ref>. The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance [47].
Reference: 42. <author> M. C. Brown, </author> <title> "An improved algorithm for the automatic verification of finite state systems using temporal logic", </title> <booktitle> Proc. 1986 IEEE Symp. LICS, </booktitle> <address> Cambridge, MA, </address> <pages> pp. 260-266, </pages> <year> 1986. </year>
Reference-contexts: Temporal logic has been applied to specifying and verifying concurrency [19, 20, 21, 22, 23, 24, 25, 26], program correctness [27, 28, 29, 30, 31], communication-based systems [32, 33, 34, 35], parallel programs [36, 37], real-time systems [38, 39, 40] and also applied to automata/state machines <ref> [35, 41, 42] </ref>. The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance [47].
Reference: 43. <author> D. I. Good, R. M. Cohen and J. Keeton-Williams, </author> <title> "Principles of proving concurrent programs in Gypsy", </title> <booktitle> Proc. 6th ACM Symp. Principles of Programming Languages, </booktitle> <year> 1979. </year>
Reference-contexts: The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency <ref> [22, 43] </ref>, fault-tolerance [44, 45, 46] and performance [47]. On combining temporal logic with 2 another specification formalism, Wing and Nixon [48] extend Ina Jo, an existing specification language for secure operating systems, with branching time temporal logic in order to increase Ina Jo's expressibility.
Reference: 44. <author> P. M. Melliar-Smith and R. L. Schwartz, </author> <title> "Formal specification and mechanical verification of SIFT: a fault-tolerant flight control system", </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. C-31, No. 7, </volume> <pages> pp. 616-630, </pages> <year> 1982. </year>
Reference-contexts: The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance <ref> [44, 45, 46] </ref> and performance [47]. On combining temporal logic with 2 another specification formalism, Wing and Nixon [48] extend Ina Jo, an existing specification language for secure operating systems, with branching time temporal logic in order to increase Ina Jo's expressibility.
Reference: 45. <author> F. Cristian, </author> <title> "A rigorous approach to fault-tolerant system development", </title> <institution> IBM Res. </institution> <type> Rep RJ 4008 (45056), </type> <year> 1983. </year>
Reference-contexts: The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance <ref> [44, 45, 46] </ref> and performance [47]. On combining temporal logic with 2 another specification formalism, Wing and Nixon [48] extend Ina Jo, an existing specification language for secure operating systems, with branching time temporal logic in order to increase Ina Jo's expressibility.
Reference: 46. <author> M. P. Herlihy and J. M. Wing, </author> <title> "Specifying graceful degradation in distributed systems", </title> <booktitle> Proc. Principles of Distributed Computing, </booktitle> <address> Vancouver, </address> <publisher> B. </publisher> <address> C., Canada, </address> <year> 1987. </year>
Reference-contexts: The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance <ref> [44, 45, 46] </ref> and performance [47]. On combining temporal logic with 2 another specification formalism, Wing and Nixon [48] extend Ina Jo, an existing specification language for secure operating systems, with branching time temporal logic in order to increase Ina Jo's expressibility.
Reference: 47. <author> I. Durham and M. Shaw, </author> <title> "Specifying reliability as a software attribute", </title> <type> CMU Tech. Rep. </type> <address> CS-82- 148, </address> <month> Dec. </month> <year> 1982. </year>
Reference-contexts: The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance <ref> [47] </ref>. On combining temporal logic with 2 another specification formalism, Wing and Nixon [48] extend Ina Jo, an existing specification language for secure operating systems, with branching time temporal logic in order to increase Ina Jo's expressibility.
Reference: 48. <author> J. M. Wing and M. R. Nixon, </author> <title> "Extending Ina Jo with temporal logic", </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. 15, No. 2, </volume> <pages> pp. 181-197, </pages> <year> 1989. </year>
Reference-contexts: The application of temporal logic to reactive systems has been studied by Pnueli [2]. On the combination of two specification methods, there exist a few schemes for concurrency [22, 43], fault-tolerance [44, 45, 46] and performance [47]. On combining temporal logic with 2 another specification formalism, Wing and Nixon <ref> [48] </ref> extend Ina Jo, an existing specification language for secure operating systems, with branching time temporal logic in order to increase Ina Jo's expressibility. Karam and Buhr [49] utilize a linear time temporal logic-based specification language COL to perform deadlock analysis for Ada programs.
Reference: 49. <author> G. M. Karam and J. A. Buhr, </author> <title> "Temporal logic-based deadlock analysis for Ada", </title> <journal> IEEE Trans. on Soft. Eng., </journal> <volume> Vol. 17, No. 10, </volume> <pages> pp. 1109-1125, </pages> <year> 1991. </year>
Reference-contexts: On combining temporal logic with 2 another specification formalism, Wing and Nixon [48] extend Ina Jo, an existing specification language for secure operating systems, with branching time temporal logic in order to increase Ina Jo's expressibility. Karam and Buhr <ref> [49] </ref> utilize a linear time temporal logic-based specification language COL to perform deadlock analysis for Ada programs. Temporal logic has also been used to verify properties of Petri nets [50]. Our approach is in the same tradition.
Reference: 50. <author> J. S. Sagoo and D. J. Holding, </author> <title> "The use of temporal Petri nets in the specification and design of systems with safety implications", in Algorithms and Architectures for Real-time Control, </title> <editor> ed. P. J. Fleming and D. I. Jones, </editor> <booktitle> IFAC Workshop Series, </booktitle> <volume> No. 4, </volume> <publisher> Pergamon Press, </publisher> <pages> pp. 231-236, </pages> <year> 1992. </year>
Reference-contexts: Karam and Buhr [49] utilize a linear time temporal logic-based specification language COL to perform deadlock analysis for Ada programs. Temporal logic has also been used to verify properties of Petri nets <ref> [50] </ref>. Our approach is in the same tradition. On specifying and verifying statecharts properties, research has been performed by Hooman et al. [51, 52] on axiomatising statecharts semantics and building a proof system based on first order predicate logic with arithmetic.
Reference: 51. <author> J. Hooman, S. Ramesh and W. P. De Roever, </author> <title> "A compositional semantics for statecharts", </title> <booktitle> Proc. Formal models of concurrency, </booktitle> <address> Novosibirsk, USSR, </address> <year> 1989. </year>
Reference-contexts: Temporal logic has also been used to verify properties of Petri nets [50]. Our approach is in the same tradition. On specifying and verifying statecharts properties, research has been performed by Hooman et al. <ref> [51, 52] </ref> on axiomatising statecharts semantics and building a proof system based on first order predicate logic with arithmetic. Our work is inspired by this research, and may be viewed as a natural extension of that work. <p> In our case, the bridge between the two languages is built using the statecharts semantics developed by Huizing [53] and refined by Hooman et al. <ref> [51] </ref>. The trace semantics of statecharts is perfectly matched by the use of linear temporal logic in the complementary language FNLOG designed by us. An equally significant contribution is the design of a logic-based temporal specification language, whose features are interesting in their own right. <p> As mentioned already, by the synchrony hypothesis, the maximal chain of transitions in one time step takes place simultaneously. The events, conditions and actions are inductively defined, details of which appear in <ref> [51] </ref>. <p> Actions and conditions have corresponding definitions. 5 Semantics of Statecharts Huizing [53] proposed an abstract semantics for statecharts, which was later refined by Hooman et al. <ref> [51, 52] </ref>. The semantic model associates with a statechart the set of all maximal computation histories representing complete computations. The semantics is a not-always semantics in which transitions labelled with : e/ e will never trigger, so that deadlock eventuates. <p> The semantic domain is the power set of all possible computation histories. For further details, the reader may consult <ref> [51, 52, 53] </ref>. C An Example Cox and Gehani [54] describe a two-degree-of-freedom robot controller, which we shall use as a running example to illustrate the efficacy of our approach. The robot possesses Cartesian XY motion, provided by a Sawyer motor in a single actuator. <p> The advantage is that a large statechart may be composed syntactically from smaller and simpler syntactic components, and the meaning of the composition has been well defined by Hooman et al. <ref> [51, 52] </ref>. Hooman's scheme starts with a basic statechart consisting of a single state, with a finite number of incoming and outgoing transitions. Syntactic operations are then defined on the basic statechart, which may be used to create larger statecharts out of smaller ones.
Reference: 52. <author> J. Hooman, S. Ramesh and W. P. De Roever, </author> <title> "A compositional axiomatization of safety and liveness properties of statecharts", </title> <booktitle> Proc. Int. BCS-FACS Workshop on Semantics for Concurrency Univ. </booktitle> <institution> of Leicester, Leicester, UK, </institution> <year> 1990. </year>
Reference-contexts: Temporal logic has also been used to verify properties of Petri nets [50]. Our approach is in the same tradition. On specifying and verifying statecharts properties, research has been performed by Hooman et al. <ref> [51, 52] </ref> on axiomatising statecharts semantics and building a proof system based on first order predicate logic with arithmetic. Our work is inspired by this research, and may be viewed as a natural extension of that work. <p> This hypothesis facilitates the specification task by abstracting from internal reaction time. The synchrony hypothesis might create causal paradoxes like an event causing itself. In statecharts, causal relationships are respected and paradoxes are removed semantically <ref> [52] </ref>. Real-time is incorporated in statecharts by having an implicit clock, allowing transitions to be triggered by timeouts relative to this clock and by requiring that if a transition can be taken, then it must be taken immediately. <p> Actions and conditions have corresponding definitions. 5 Semantics of Statecharts Huizing [53] proposed an abstract semantics for statecharts, which was later refined by Hooman et al. <ref> [51, 52] </ref>. The semantic model associates with a statechart the set of all maximal computation histories representing complete computations. The semantics is a not-always semantics in which transitions labelled with : e/ e will never trigger, so that deadlock eventuates. <p> The semantic domain is the power set of all possible computation histories. For further details, the reader may consult <ref> [51, 52, 53] </ref>. C An Example Cox and Gehani [54] describe a two-degree-of-freedom robot controller, which we shall use as a running example to illustrate the efficacy of our approach. The robot possesses Cartesian XY motion, provided by a Sawyer motor in a single actuator. <p> A functional specification in FNLOG would be complementary to the statecharts specification of the same AMR. In addition, since FNLOG is logic-based, it provides a verification facility for the specifications. 7 A Earlier Work A similar strategy was employed by Hooman et al. <ref> [52] </ref>, who define a logical assertion language complementary to statecharts, to which statecharts are related by formulae of the form U sat OE : statechart U satisfies assertion OE Assertions are written in a first-order typed language. <p> The advantage is that a large statechart may be composed syntactically from smaller and simpler syntactic components, and the meaning of the composition has been well defined by Hooman et al. <ref> [51, 52] </ref>. Hooman's scheme starts with a basic statechart consisting of a single state, with a finite number of incoming and outgoing transitions. Syntactic operations are then defined on the basic statechart, which may be used to create larger statecharts out of smaller ones.
Reference: 53. <author> C. Huizing, R. Gerth and W. P. De Roever, </author> <title> "Modelling statecharts behaviour in a fully abstract way", </title> <booktitle> Computing Science Notes, 88/07, </booktitle> <institution> Eindhoven Univ. Tech., Dept Math. Comp. Sci., </institution> <year> 1988. </year>
Reference-contexts: In our case, the bridge between the two languages is built using the statecharts semantics developed by Huizing <ref> [53] </ref> and refined by Hooman et al. [51]. The trace semantics of statecharts is perfectly matched by the use of linear temporal logic in the complementary language FNLOG designed by us. <p> Actions and conditions have corresponding definitions. 5 Semantics of Statecharts Huizing <ref> [53] </ref> proposed an abstract semantics for statecharts, which was later refined by Hooman et al. [51, 52]. The semantic model associates with a statechart the set of all maximal computation histories representing complete computations. <p> The semantic domain is the power set of all possible computation histories. For further details, the reader may consult <ref> [51, 52, 53] </ref>. C An Example Cox and Gehani [54] describe a two-degree-of-freedom robot controller, which we shall use as a running example to illustrate the efficacy of our approach. The robot possesses Cartesian XY motion, provided by a Sawyer motor in a single actuator.
Reference: 54. <author> I. J. Cox and N. H. Gehani, </author> <title> "Concurrent programming and robotics", </title> <journal> Int. J. Robot. Res., </journal> <volume> Vol. 8, No. 2, </volume> <pages> pp. 3-16, </pages> <year> 1989. </year>
Reference-contexts: The semantic domain is the power set of all possible computation histories. For further details, the reader may consult [51, 52, 53]. C An Example Cox and Gehani <ref> [54] </ref> describe a two-degree-of-freedom robot controller, which we shall use as a running example to illustrate the efficacy of our approach. The robot possesses Cartesian XY motion, provided by a Sawyer motor in a single actuator. <p> The problem is that of coordinating the motion of multiple robots in a common workspace, described by Cox and Gehani <ref> [54] </ref>. Consider the case of two cartesian robots moving in a common workspace; a cartesian robot moves in a two-dimensional cartesian space. We assume that the robots are performing independent tasks and that only collisions must be avoided.
Reference: 55. <author> A. Sowmya, S. Ramesh and J. R. Isaac, </author> <title> "A statechart approach to specification and verification of autonomous mobile robot behaviour", </title> <booktitle> Proc. Int. Conf. Automation, Robotics and Computer Vision ICARCV '90, </booktitle> <address> Singapore: </address> <publisher> McGraw Hill Sing., </publisher> <pages> pp. 499-503, </pages> <year> 1990. </year>
Reference-contexts: These relationships are peculiar to the AMR being designed for a specific environment and are called the domain-based properties. What we need is, thus, a facility for functional specification. Hence we propose a new logic-based functional specification language called FNLOG, first reported in <ref> [55] </ref>. A functional specification in FNLOG would be complementary to the statecharts specification of the same AMR.
Reference: 56. <author> A. Sowmya, </author> <title> "Autonomous robot motion: specification and verification", </title> <type> Ph. D. thesis, </type> <institution> Indian Institute of Technology, Bombay, India, </institution> <year> 1991. </year>
Reference-contexts: The semantics of all the operators operating on events and activities may be similarly extended. A formal treatment is given in <ref> [56] </ref>. B Translating Statecharts to FNLOG We now describe informally rules to translate a statecharts specification to a semantically equivalent FNLOG specification. A more formal treatment may be found in [56]. <p> A formal treatment is given in <ref> [56] </ref>. B Translating Statecharts to FNLOG We now describe informally rules to translate a statecharts specification to a semantically equivalent FNLOG specification. A more formal treatment may be found in [56]. The problem is to translate states and transitions, at many levels of structure, to a set of formulas in FNLOG. At the lowest level, we equate instantaneous events and actions in the statecharts domain to instantaneous events within the FNLOG framework. <p> For the OR'ing of two statecharts, the FNLOG specification is the logical disjunction of the FNLOG specifications of the individual statecharts; similarly AND is mapped to conjunction. A formal definition may be found in <ref> [56] </ref>. C Proof System As sketched in the plan, the proof system for FNLOG was relatively the easy part. All deductive rules of first order predicate logic and past temporal logic still hold. <p> The mapped FNLOG specification is tediously long, with 103 function definitions, but its generation is straightforward and is entirely automatable, using the mapping rules discussed earlier. The 19 verification of properties against this specification is straightforward too, and the full derivation appears in <ref> [56] </ref>. This example illustrates the possibility of modular development using this approach. It also shows that non-trivial systems may be usefully specified and verified using this approach. 7 Concluding Remarks We now present some conclusions based on our experience of utilizing a version of temporal logic to verify statecharts.

References-found: 56

