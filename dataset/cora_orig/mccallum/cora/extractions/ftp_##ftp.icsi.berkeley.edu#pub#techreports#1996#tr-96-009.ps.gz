URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1996/tr-96-009.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1996.html
Root-URL: http://www.icsi.berkeley.edu
Abstract-found: 0
Intro-found: 1
Reference: [ Apt et al., 1987 ] <author> Krzysztof R. Apt, H. A. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 2, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: In [ Thielscher, 1996a ] , we have discussed completeness of SLDENF-resolution. As already known from the special case of programs with negation and the empty equational theory, completeness cannot be guaranteed in general <ref> [ Clark, 1978; Apt et al., 1987 ] </ref> . The classical completeness result for SLDNF-resolution is restricted to so-called hierarchical and allowed programs [ Clark, 1978; Apt et al., 1987 ] . <p> As already known from the special case of programs with negation and the empty equational theory, completeness cannot be guaranteed in general <ref> [ Clark, 1978; Apt et al., 1987 ] </ref> . The classical completeness result for SLDNF-resolution is restricted to so-called hierarchical and allowed programs [ Clark, 1978; Apt et al., 1987 ] .
Reference: [ Baader and Siekmann, 1993 ] <author> Franz Baader and Jorg H. Siekmann. </author> <title> Unification theory. </title> <editor> In D. M. Gabbay, C. J. Hogger, and J. A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference-contexts: The concept of unification completeness [ Jaffar et al., 1984; Shepherdson, 1992 ] generalizes these axiom schemata for arbitrary equational theories. Prior to stating the formal definition, we need to introduce some notions and notations related to unification theory, taken from the survey article <ref> [ Baader and Siekmann, 1993 ] </ref> .
Reference: [ Baker, 1989 ] <author> A. B. Baker. </author> <title> A simple solution to the Yale Shooting problem. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning, </booktitle> <pages> pages 11-20, </pages> <year> 1989. </year>
Reference-contexts: Waiting is assumed to have no effects at all. The following two v-propositions then encode the Stanford Murder Mystery <ref> [ Baker, 1989 ] </ref> : initially alive alive after [wait; shoot] (4) In words, the turkey was alive at the beginning but not after having executed wait followed by shoot .
Reference: [ Baral and Gelfond, 1993 ] <author> Chitta Baral and Michael Gelfond. </author> <title> Representing concurrent actions in extended logic programming. </title> <editor> In R. Bajcsy, editor, </editor> <booktitle> Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 866-871, </pages> <address> Chambery, France, August 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: This question will be discussed in Section 4. To this end, we use a recent extension of the Action Description Language A which is called A C and supports representing and reason 1 ing about the concurrent execution of actions <ref> [ Baral and Gelfond, 1993 ] </ref> . In Subsection 4.1, we discuss different explicit methods which enable the designer of a representation to prevent the aforementioned conflicts by providing more specific information regarding particular concurrently executed actions. <p> Since an extension of A to concurrent actions, called A C , has recently been introduced <ref> [ Baral and Gelfond, 1993 ] </ref> , which uses the latter, most powerful method for stating differing effects of actions as regards their concurrent execution, we use this approach to illustrate our following discussion and adopt it when extending our approach to deal with concurrency. 4.2 The Language A C We <p> method for stating differing effects of actions as regards their concurrent execution, we use this approach to illustrate our following discussion and adopt it when extending our approach to deal with concurrency. 4.2 The Language A C We briefly review the concepts underlying the language A C as defined in <ref> [ Baral and Gelfond, 1993 ] </ref> by pointing out the corresponding extensions of A . <p> by b in iff 2. there is an e-proposition b causes ` if c 1 ; : : : ; c n such that each of c 1 ; : : : ; c n holds in ; and 9 The following definition differs slightly from the definition given in <ref> [ Baral and Gelfond, 1993 ] </ref> , which is circular; we assume that our's is what the authors actually intended. 10 3. there is no action c such that b c and a causes ` by c in .
Reference: [ Baral, 1995 ] <author> Chitta Baral. </author> <title> Reasoning about actions: Non-deterministic effects, constraints and qualification. </title> <editor> In C. S. Mellish, editor, </editor> <booktitle> Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 2017-2023, </pages> <address> Montreal, Canada, August 1995. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: [ Bibel, 1986 ] <author> Wolfgang Bibel. </author> <title> A deductive solution for plan generation. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 115-132, </pages> <year> 1986. </year>
Reference-contexts: On the basis of representing a situation by a collection of fluent terms, the execution of actions is modeled by manipulating such collections. For this reason, we call the underlying approach fluent calculus. Aside from being closely related, in its basic form, to the Linear Connection Method <ref> [ Bibel, 1986 ] </ref> and reasoning about actions based on Linear Logic [ Girard, 1987; Masseron et al., 1993 ] , the fluent calculus has recently been shown to successfully deal with the ramification problem [ Thielscher, 1995a; Thielscher, 1996b ] .
Reference: [ Bruning et al., 1993 ] <author> Stefan Bruning, Steffen Holldobler, Josef Schneeberger, Ute Sigmund, and Michael Thielscher. </author> <title> Disjunction in resource-oriented deductive planning. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the International Logic Programming Symposium (ILPS), </booktitle> <pages> page 670, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1993. </year> <note> MIT Press. (Poster). </note>
Reference: [ Chan, 1988 ] <author> David Chan. </author> <title> Constructive negation based on the completed database. </title> <editor> In R. Kowalski and K. Bowen, editors, </editor> <booktitle> Proceedings of the International Joint Conference and Symposium on Logic Programming (IJCSLP), </booktitle> <pages> pages 111-125. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: There are two ways of solving this problem. First, one could define an extension of the SLDENF-resolution principle that supports a proper treatment of non-ground, negative sub-goals, such as the concept of constructive negation, which is a well-known technique to avoid floundering in case of non-equational logic programs <ref> [ Chan, 1988; Przymusinski, 1989 ] </ref> . This, however, requires a new formal definition of an extended calculus, and then soundness and completeness have to be proved again. Here, we follow a simpler and more straightforward way.
Reference: [ Clark, 1978 ] <author> Keith L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: In the following subsection, 5.1, we describe how to construct a logic program corresponding to a domain description in A NCC . In Subsection 5.2, we discuss the semantics of the resulting program by applying the standard completion procedure <ref> [ Clark, 1978 ] </ref> augmented by a special treatment of the underlying equational theory [ Jaffar et al., 1984; Shepherdson, 1992 ] . In Subsection 5.3, we then prove soundness and completeness of the equational logic program (by taking the extended completion semantics) wrt the semantics of A NCC . <p> These negative literals are intended to be treated by the (non-monotonic) negation-as-failure principle. An adequate semantics for such programs which is based on classical first-order logic is obtained by applying an extension of Clark's completion procedure <ref> [ Clark, 1978 ] </ref> to the program: The idea is to consider the set of program clauses which define a predicate p as a complete description of the positive information regarding p . <p> K. Clark added some axiom schemata to the completed formula which allow for proving inequality of two terms whenever these are not syntactically unifiable <ref> [ Clark, 1978 ] </ref> . The concept of unification completeness [ Jaffar et al., 1984; Shepherdson, 1992 ] generalizes these axiom schemata for arbitrary equational theories. <p> In [ Thielscher, 1996a ] , we have discussed completeness of SLDENF-resolution. As already known from the special case of programs with negation and the empty equational theory, completeness cannot be guaranteed in general <ref> [ Clark, 1978; Apt et al., 1987 ] </ref> . The classical completeness result for SLDNF-resolution is restricted to so-called hierarchical and allowed programs [ Clark, 1978; Apt et al., 1987 ] . <p> As already known from the special case of programs with negation and the empty equational theory, completeness cannot be guaranteed in general <ref> [ Clark, 1978; Apt et al., 1987 ] </ref> . The classical completeness result for SLDNF-resolution is restricted to so-called hierarchical and allowed programs [ Clark, 1978; Apt et al., 1987 ] .
Reference: [ Denecker and de Schreye, 1993 ] <author> Marc Denecker and Danny de Schreye. </author> <title> Representing incomplete knowledge in abductive logic programming. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the International Logic Programming Symposium (ILPS), </booktitle> <pages> pages 147-163, </pages> <address> Vancouver, October 1993. </address> <publisher> MIT Press. </publisher>
Reference: [ Dung, 1993 ] <author> Phan Minh Dung. </author> <title> Representing actions in logic programming and its applications in database updates. </title> <editor> In D. S. Warren, editor, </editor> <booktitle> Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 222-238, </pages> <address> Budapest, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Our formalisms are based on the Action Description Language A . Two recent extensions of A , namely, first-order-fluents <ref> [ Dung, 1993 ] </ref> and indirect effects [ Kartha and Lifschitz, 1994 ] , are not subsumed by our approach. Yet the fluent calculus, which we used here, has already been extended to successfully cope with the ramification problem [ Thielscher, 1995a; Thielscher, 1996b ] .
Reference: [ Gelfond and Lifschitz, 1993 ] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Representing action and change by logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 17 </volume> <pages> 301-321, </pages> <year> 1993. </year>
Reference-contexts: In the very first part of this paper, we develop a high-level representation language and semantics which allows for intentionally specifying nondeterministic actions with randomized effects. Our language is based on the Action Description Language A <ref> [ Gelfond and Lifschitz, 1993 ] </ref> , which is appealing because of the simple, elegant and natural way in which the effects of actions are described.
Reference: [ Girard, 1987 ] <author> Jean-Yves Girard. </author> <title> Linear Logic. </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> 50(1) </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: For this reason, we call the underlying approach fluent calculus. Aside from being closely related, in its basic form, to the Linear Connection Method [ Bibel, 1986 ] and reasoning about actions based on Linear Logic <ref> [ Girard, 1987; Masseron et al., 1993 ] </ref> , the fluent calculus has recently been shown to successfully deal with the ramification problem [ Thielscher, 1995a; Thielscher, 1996b ] .
Reference: [ Groe, 1994 ] <author> Gerd Groe. </author> <title> Propositional State-Event Logic. </title> <editor> In C. MacNish, D. Peirce, and L. M. Peireira, editors, </editor> <booktitle> Proceedings of the European Workshop on Logics in AI (JELIA), volume 838 of LNAI, </booktitle> <pages> pages 316-331. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: uses this method by "cancelling" effects in specific cases), 3. add or remove a fluent from B f or B f : this enables one to arbitrarily modify B f and B f (used, for instance, in A C , our language A NCC , and in State Event Logic <ref> [ Groe, 1994 ] </ref> ). <p> In such cases, depending on the chosen interpretation and the extent of certainty required, one has to regard as unreliable 1. the whole domain description (as in State-Event Logic <ref> [ Groe, 1994 ] </ref> ), 2. the whole situation, 3. the effects of the conflicting actions, or 4. the contradictory fluents. It is the latter, weakest condition which we propose in this paper. This follows the idea of still believing in all information which do not cause the contradiction.
Reference: [ Hanks and McDermott, 1987 ] <author> Steve Hanks and Drew McDermott. </author> <title> Nonmonotonic logic and temporal projection. </title> <journal> Artificial Intelligence Journal, </journal> <volume> 33(3) </volume> <pages> 379-412, </pages> <year> 1987. </year>
Reference-contexts: An e-proposition (2) should be read as: Executing unit action a causes ` to hold in the resulting state provided the conditions c 1 ; : : :; c n hold in the current state. Example 1 The Yale Shooting domain <ref> [ Hanks and McDermott, 1987 ] </ref> can be modeled using the fluent names F D 1 = floaded; aliveg denoting the state of a gun and a turkey, respectively.
Reference: [ Holldobler and Schneeberger, 1990 ] <author> Steffen Holldobler and Josef Schneeberger. </author> <title> A new deductive approach to planning. </title> <journal> New Generation Computing, </journal> <volume> 8 </volume> <pages> 225-244, </pages> <year> 1990. </year>
Reference-contexts: The approach we follow here is based on the reification of complete situation descriptions by treating them as terms <ref> [ Holldobler and Schneeberger, 1990 ] </ref> . To this end, each atomic fluent that holds in a state is formally represented by a term (a so-called fluent term), and these fluent terms are connected by a special binary function symbol, written ffi . <p> Hence our connection function has some special properties, which are formalized using the following equational theory <ref> [ Holldobler and Schneeberger, 1990 ] </ref> : 8X; Y; Z: (X ffi Y ) ffi Z = X ffi (Y ffi Z) (associativity) 8X; Y: X ffi Y = Y ffi X (commutativity) 8X: X ffi ; = X (unit element) where the constant ; denotes a unit element for ffi
Reference: [ Holldobler and Thielscher, 1995 ] <author> Steffen Holldobler and Michael Thielscher. </author> <title> Computing change and specificity with equational logic programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 14(1) </volume> <pages> 99-133, </pages> <year> 1995. </year>
Reference-contexts: If s and t are E-unifiable then for each complete set of E-unifiers cU E (s; t) E fl j= 8X @ s = t ! 2cU E (s;t) 1 22 where Y denotes the variables which occur in eqn () but not in X . In <ref> [ Holldobler and Thielscher, 1995 ] </ref> , we have proved the existence of such a unification complete theory AC1 fl for the equational theory AC1 used in F C N CC .
Reference: [ Jaffar et al., 1984 ] <author> Joxan Jaffar, Jean-Louis Lassez, and Michael J. Maher. </author> <title> A theory of complete logic programs with equality. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 211-223, </pages> <year> 1984. </year>
Reference-contexts: In Subsection 5.2, we discuss the semantics of the resulting program by applying the standard completion procedure [ Clark, 1978 ] augmented by a special treatment of the underlying equational theory <ref> [ Jaffar et al., 1984; Shepherdson, 1992 ] </ref> . In Subsection 5.3, we then prove soundness and completeness of the equational logic program (by taking the extended completion semantics) wrt the semantics of A NCC . <p> K. Clark added some axiom schemata to the completed formula which allow for proving inequality of two terms whenever these are not syntactically unifiable [ Clark, 1978 ] . The concept of unification completeness <ref> [ Jaffar et al., 1984; Shepherdson, 1992 ] </ref> generalizes these axiom schemata for arbitrary equational theories. Prior to stating the formal definition, we need to introduce some notions and notations related to unification theory, taken from the survey article [ Baader and Siekmann, 1993 ] .
Reference: [ Kartha and Lifschitz, 1994 ] <author> G. Neelakantan Kartha and Vladimir Lifschitz. </author> <title> Actions with indirect effects. </title> <editor> In J. Doyle, E. Sandewall, and P. Torasso, editors, </editor> <booktitle> Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 341-350, </pages> <address> Bonn, Germany, May 1994. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Our formalisms are based on the Action Description Language A . Two recent extensions of A , namely, first-order-fluents [ Dung, 1993 ] and indirect effects <ref> [ Kartha and Lifschitz, 1994 ] </ref> , are not subsumed by our approach. Yet the fluent calculus, which we used here, has already been extended to successfully cope with the ramification problem [ Thielscher, 1995a; Thielscher, 1996b ] .
Reference: [ Kartha, 1993 ] <author> G. Neelakantan Kartha. </author> <title> Soundness and completeness theorems for three formalizations of actions. </title> <editor> In R. Bajcsy, editor, </editor> <booktitle> Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 724-729, </pages> <address> Chambery, France, August 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: [ Kartha, 1994 ] <author> G. Neelakantan Kartha. </author> <title> Two counterexamples related to Baker's approach to the frame problem. </title> <journal> Artificial Intelligence Journal, </journal> <volume> 69(1-2):379-391, </volume> <year> 1994. </year>
Reference: [ Lin and Shoham, 1992 ] <author> Fangzhen Lin and Yoav Shoham. </author> <title> Concurrent actions in the situation calculus. </title> <booktitle> In Proceedings of the AAAI National Conference on Artificial Intelligence, </booktitle> <pages> pages 590-595, </pages> <address> San Jose, California, 1992. </address> <publisher> MIT Press. </publisher>
Reference-contexts: the whole domain description to be inconsistent as it does not admit a proper notion of transition. 9 2. remove a fluent from B f or B f : this allows to remove predicted conflicts, but not to redefine facts not mentioned by the unit action descriptions (the approach in <ref> [ Lin and Shoham, 1992 ] </ref> uses this method by "cancelling" effects in specific cases), 3. add or remove a fluent from B f or B f : this enables one to arbitrarily modify B f and B f (used, for instance, in A C , our language A NCC ,
Reference: [ Lloyd, 1987 ] <author> John W. Lloyd. </author> <booktitle> Foundations of Logic Programming. Series Symbolic Computation. </booktitle> <address> Springer, </address> <note> second, extended edition, 1987. 32 </note>
Reference-contexts: We assume the reader be familiar with the basic concepts of normal logic programs (i.e., logic programs augmented by negation-as-failure) as described, e.g, in the textbook <ref> [ Lloyd, 1987 ] </ref> . We use a Prolog-like syntax in denoting constants and predicates by lower case letters and variables by upper case letters. <p> In the preceding subsection, we have taken the completion of these programs as an adequate semantics when negative literals are to be treated by negation-as-failure. An adequate computation mechanism for programs including equality and (nonmonotonic) negation is SLDENF-resolution, which is based on SLD-resolution (see, e.g., <ref> [ Lloyd, 1987 ] </ref> ) but with the standard unification procedure replaced by an E-unification algorithm and negation-as-failure used to treat negative subgoals. A formal introduction to this resolution principle can be found in [ Shepherdson, 1992; Thielscher, 1996a ] .
Reference: [ Lukaszewicz and Madalinska-Bugaj, 1995 ] <author> Witold Lukaszewicz and Ewa Madalinska-Bugaj. </author> <title> Reasoning about action and change using Dijkstra's semantics for programming languages: Preliminary report. </title> <editor> In C. S. Mellish, editor, </editor> <booktitle> Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 1950-1955, </pages> <address> Montreal, Canada, August 1995. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: [ Masseron et al., 1993 ] <author> M. Masseron, Christophe Tollu, and Jacqueline Vauzielles. </author> <title> Generating plans in linear logic I. Actions as proofs. </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> 113 </volume> <pages> 349-370, </pages> <year> 1993. </year>
Reference-contexts: For this reason, we call the underlying approach fluent calculus. Aside from being closely related, in its basic form, to the Linear Connection Method [ Bibel, 1986 ] and reasoning about actions based on Linear Logic <ref> [ Girard, 1987; Masseron et al., 1993 ] </ref> , the fluent calculus has recently been shown to successfully deal with the ramification problem [ Thielscher, 1995a; Thielscher, 1996b ] .
Reference: [ McCarthy and Hayes, 1969 ] <author> John McCarthy and Patrick J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <journal> Machine Intelligence, </journal> <volume> 4 </volume> <pages> 463-502, </pages> <year> 1969. </year>
Reference-contexts: Our translation follows an approach originally introduced in [ Holldobler and Schnee-berger, 1990 ] , which is based on the reification of entire situation descriptions by formally treating them as terms. In contrast to situation calculus <ref> [ McCarthy, 1963; McCarthy and Hayes, 1969 ] </ref> , where situation terms are abstract objects, the former approach employs situation terms consisting of an explicit collection of those fluents which hold in the situation being represented.
Reference: [ McCarthy, 1963 ] <author> John McCarthy. </author> <title> Situations and Actions and Causal Laws. </title> <booktitle> Stanford Artificial Intelligence Project, </booktitle> <volume> Memo 2, </volume> <year> 1963. </year>
Reference-contexts: Our translation follows an approach originally introduced in [ Holldobler and Schnee-berger, 1990 ] , which is based on the reification of entire situation descriptions by formally treating them as terms. In contrast to situation calculus <ref> [ McCarthy, 1963; McCarthy and Hayes, 1969 ] </ref> , where situation terms are abstract objects, the former approach employs situation terms consisting of an explicit collection of those fluents which hold in the situation being represented.
Reference: [ Przymusinski, 1989 ] <author> Teodor C. Przymusinski. </author> <title> On constructive negation in logic programming. </title> <editor> In E. L. Lusk and R. A. Overbeek, editors, </editor> <booktitle> Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <address> Cleveland, </address> <month> October </month> <year> 1989. </year> <title> (Insertion). </title>
Reference-contexts: There are two ways of solving this problem. First, one could define an extension of the SLDENF-resolution principle that supports a proper treatment of non-ground, negative sub-goals, such as the concept of constructive negation, which is a well-known technique to avoid floundering in case of non-equational logic programs <ref> [ Chan, 1988; Przymusinski, 1989 ] </ref> . This, however, requires a new formal definition of an extended calculus, and then soundness and completeness have to be proved again. Here, we follow a simpler and more straightforward way.
Reference: [ Richard etal., 1988 ] <author> Pierre Richard etal. A gauche en sortant de l'ascenseur. Renn Productions, </author> <year> 1988. </year>
Reference-contexts: To illustrate this, consider the following extension of Example 2, motivated by a scene in a Pierre Richard movie <ref> [ Richard etal., 1988 ] </ref> . 7 An additional fluent name, broken , is used to describe the state of a vase.
Reference: [ Sandewall, 1993 ] <author> Erik Sandewall. </author> <title> The range of applicability of nonmonotonic logics for the inertia problem. </title> <editor> In R. Bajcsy, editor, </editor> <booktitle> Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 738-743, </pages> <address> Chambery, France, August 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: [ Sandewall, 1994 ] <author> Erik Sandewall. </author> <title> Features and Fluents. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Example 2 We marginally extend the Russian Turkey scenario as formalized in <ref> [ Sandewall, 1994 ] </ref> and take this as the running example of this section. To this end, the set of unit actions used in Example 1 is augmented by an action called spin .
Reference: [ Shepherdson, 1992 ] <author> John C. Shepherdson. </author> <title> SLDNF-resolution with equality. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 8 </volume> <pages> 297-306, </pages> <year> 1992. </year>
Reference-contexts: In Subsection 5.2, we analyze the semantics of this program given by its completion, and in Subsection 5.3 we prove its soundness and completeness wrt the high-level action semantics given by A NCC . Finally, in Subsection 5.4 we discuss an adequate computation mechanism four our program, namely, SLDENF-resolution <ref> [ Shepherdson, 1992; Thielscher, 1996a ] </ref> , which is based on SLD-resolution but with the standard unification procedure replaced by a special equality unification algorithm and negation-as-failure used to treat negative subgoals. Our translation allows automated reasoning about dynamic systems following the concepts captured by A NCC . <p> In Subsection 5.2, we discuss the semantics of the resulting program by applying the standard completion procedure [ Clark, 1978 ] augmented by a special treatment of the underlying equational theory <ref> [ Jaffar et al., 1984; Shepherdson, 1992 ] </ref> . In Subsection 5.3, we then prove soundness and completeness of the equational logic program (by taking the extended completion semantics) wrt the semantics of A NCC . <p> K. Clark added some axiom schemata to the completed formula which allow for proving inequality of two terms whenever these are not syntactically unifiable [ Clark, 1978 ] . The concept of unification completeness <ref> [ Jaffar et al., 1984; Shepherdson, 1992 ] </ref> generalizes these axiom schemata for arbitrary equational theories. Prior to stating the formal definition, we need to introduce some notions and notations related to unification theory, taken from the survey article [ Baader and Siekmann, 1993 ] . <p> A complete set of E-unifiers cU E (s; t) for two terms s; t is a set of E-unifiers for s; t such that each E -unifier for s; t is subsumed by at least one element in cU E (s; t) . As in <ref> [ Shepherdson, 1992 ] </ref> , given a substitution = fX 1 7! t 1 ; : : : ; X n 7! t n g we use eqn () to denote the formula X 1 = t 1 ^ : : : ^ X n = t n : Definition 11 <p> A formal introduction to this resolution principle can be found in <ref> [ Shepherdson, 1992; Thielscher, 1996a ] </ref> . In [ Shepherdson, 1992 ] , soundness of SLDENF-resolution wrt the completion semantics (including the use of unification complete theories) has been proved for arbitrary equa tional logic programs with negation. <p> A formal introduction to this resolution principle can be found in [ Shepherdson, 1992; Thielscher, 1996a ] . In <ref> [ Shepherdson, 1992 ] </ref> , soundness of SLDENF-resolution wrt the completion semantics (including the use of unification complete theories) has been proved for arbitrary equa tional logic programs with negation.
Reference: [ Stickel, 1975 ] <author> Mark E. Stickel. </author> <title> A complete unification algorithm for associative-commutative functions. </title> <booktitle> In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 71-76, </pages> <address> Tbilisi, USSR, </address> <year> 1975. </year>
Reference-contexts: See [ Thielscher, 1996a ] for a more detailed and formal discussion. 26 The equational theory used in this paper, AC1, is known to be both finitary <ref> [ Stickel, 1975 ] </ref> and, obviously, regular. Nonetheless the result presented in [ Thielscher, 1996a ] cannot be applied since the program developed in Subsection 5.1 is neither hierarchical nor allowed. We therefore have to perform a more detailed and specific analysis of our program.
Reference: [ Thielscher, 1994 ] <author> Michael Thielscher. </author> <title> An analysis of systematic approaches to reasoning about actions and change. </title> <editor> In P. Jorrand and V. Sgurev, editors, </editor> <booktitle> International Conference on Artificial Intelligence: Methodology, Systems, Applications (AIMSA), </booktitle> <pages> pages 195-204, </pages> <address> Sofia, Bulgaria, </address> <month> September </month> <year> 1994. </year> <title> World Scientific. </title>
Reference: [ Thielscher, 1995a ] <author> Michael Thielscher. </author> <title> Computing ramifications by postprocessing. </title> <editor> In C. S. Mellish, editor, </editor> <booktitle> Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 1994-2000, </pages> <address> Montreal, Canada, August 1995. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Aside from being closely related, in its basic form, to the Linear Connection Method [ Bibel, 1986 ] and reasoning about actions based on Linear Logic [ Girard, 1987; Masseron et al., 1993 ] , the fluent calculus has recently been shown to successfully deal with the ramification problem <ref> [ Thielscher, 1995a; Thielscher, 1996b ] </ref> . In the following subsection, 5.1, we describe how to construct a logic program corresponding to a domain description in A NCC . <p> Two recent extensions of A , namely, first-order-fluents [ Dung, 1993 ] and indirect effects [ Kartha and Lifschitz, 1994 ] , are not subsumed by our approach. Yet the fluent calculus, which we used here, has already been extended to successfully cope with the ramification problem <ref> [ Thielscher, 1995a; Thielscher, 1996b ] </ref> . Hence we have good reasons to assume that the logic program presented in this paper can be extended to form an adequate encoding of a high-level action semantics including A N CC and indirect effects. Acknowledgments.
Reference: [ Thielscher, 1995b ] <author> Michael Thielscher. </author> <title> The logic of dynamic systems. </title> <editor> In C. S. Mellish, editor, </editor> <booktitle> Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 1956-1962, </pages> <address> Montreal, Canada, August 1995. </address> <publisher> Morgan Kaufmann. </publisher>
Reference: [ Thielscher, 1996a ] <author> Michael Thielscher. </author> <title> On the completeness of SLDENF-resolution. </title> <journal> Journal of Automated Reasoning, </journal> <note> 1996. (To appear Fall '96). </note>
Reference-contexts: In Subsection 5.2, we analyze the semantics of this program given by its completion, and in Subsection 5.3 we prove its soundness and completeness wrt the high-level action semantics given by A NCC . Finally, in Subsection 5.4 we discuss an adequate computation mechanism four our program, namely, SLDENF-resolution <ref> [ Shepherdson, 1992; Thielscher, 1996a ] </ref> , which is based on SLD-resolution but with the standard unification procedure replaced by a special equality unification algorithm and negation-as-failure used to treat negative subgoals. Our translation allows automated reasoning about dynamic systems following the concepts captured by A NCC . <p> In Subsection 5.3, we then prove soundness and completeness of the equational logic program (by taking the extended completion semantics) wrt the semantics of A NCC . Finally, in Subsection 5.4 we discuss the applicability of a special resolution variant, namely, SLDENF-resolution <ref> [ Shepherd-son, 1992; Thielscher, 1996a ] </ref> , to our logic program. We assume the reader be familiar with the basic concepts of normal logic programs (i.e., logic programs augmented by negation-as-failure) as described, e.g, in the textbook [ Lloyd, 1987 ] . <p> A formal introduction to this resolution principle can be found in <ref> [ Shepherdson, 1992; Thielscher, 1996a ] </ref> . In [ Shepherdson, 1992 ] , soundness of SLDENF-resolution wrt the completion semantics (including the use of unification complete theories) has been proved for arbitrary equa tional logic programs with negation. <p> In <ref> [ Thielscher, 1996a ] </ref> , we have discussed completeness of SLDENF-resolution. As already known from the special case of programs with negation and the empty equational theory, completeness cannot be guaranteed in general [ Clark, 1978; Apt et al., 1987 ] . <p> In such cases, the proof procedure does not come to a conclusion. In <ref> [ Thielscher, 1996a ] </ref> , we have lifted the aforementioned classical result to logic programs with equational theories. <p> See <ref> [ Thielscher, 1996a ] </ref> for a more detailed and formal discussion. 26 The equational theory used in this paper, AC1, is known to be both finitary [ Stickel, 1975 ] and, obviously, regular. Nonetheless the result presented in [ Thielscher, 1996a ] cannot be applied since the program developed in Subsection <p> See <ref> [ Thielscher, 1996a ] </ref> for a more detailed and formal discussion. 26 The equational theory used in this paper, AC1, is known to be both finitary [ Stickel, 1975 ] and, obviously, regular. Nonetheless the result presented in [ Thielscher, 1996a ] cannot be applied since the program developed in Subsection 5.1 is neither hierarchical nor allowed. We therefore have to perform a more detailed and specific analysis of our program.
Reference: [ Thielscher, 1996b ] <author> Michael Thielscher. </author> <title> Ramification and Causality. </title> <type> Technical Report TR-96-003, ICSI, </type> <institution> Berkeley, </institution> <address> CA, </address> <year> 1996. </year>
Reference-contexts: Aside from being closely related, in its basic form, to the Linear Connection Method [ Bibel, 1986 ] and reasoning about actions based on Linear Logic [ Girard, 1987; Masseron et al., 1993 ] , the fluent calculus has recently been shown to successfully deal with the ramification problem <ref> [ Thielscher, 1995a; Thielscher, 1996b ] </ref> . In the following subsection, 5.1, we describe how to construct a logic program corresponding to a domain description in A NCC . <p> Two recent extensions of A , namely, first-order-fluents [ Dung, 1993 ] and indirect effects [ Kartha and Lifschitz, 1994 ] , are not subsumed by our approach. Yet the fluent calculus, which we used here, has already been extended to successfully cope with the ramification problem <ref> [ Thielscher, 1995a; Thielscher, 1996b ] </ref> . Hence we have good reasons to assume that the logic program presented in this paper can be extended to form an adequate encoding of a high-level action semantics including A N CC and indirect effects. Acknowledgments.
References-found: 38

