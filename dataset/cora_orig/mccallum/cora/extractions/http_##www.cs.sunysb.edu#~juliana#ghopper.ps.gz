URL: http://www.cs.sunysb.edu/~juliana/ghopper.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: juliana@cs.sunysb.edu  
Title: Using Logic Programming to Efficiently Evaluate Recursive Queries  
Author: Juliana Freire 
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(3) </volume> <pages> 255-299, </pages> <year> 1991. </year>
Reference-contexts: A number of approaches have been used to attack the termination and complexity problems, most notably: (1) tabling [13], which has added features of database evaluation to logic programming languages, and (2) magic evaluation <ref> [1] </ref>, which has embedded recursive goal-orientation in the framework of database evaluation. Magic evaluation closely resembles tabling. Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent [10, 8].
Reference: [2] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2 </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent [10, 8]. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems. Magic-style systems, such as Aditi [12], LDL <ref> [2] </ref> and CORAL [7], are built upon set-at-a-time engines, and can use set-at-a-time operations like relational joins that may be made efficient for disk-resident data, while tabling systems, such as XSB [9], use a tuple-at-a-time strategy that reflects their genesis in the logic programming community.
Reference: [3] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The evaluation terminates when neither new answers nor new subgoals exist. Note that, at each iteration, the breadth-first tabling engine generates the same answers as the SNMT evaluation. Tabled Breadth-First Search was formally defined in <ref> [3] </ref> where we prove that any fact derived by this strategy is also derived by SNMT, that is, on an iteration-by-iteration basis, Tabled Breadth-First Search is equivalent to Semi-Naive Magic Template evaluation. Experimental results presented in [3] show that an implementation of the breadth-first strategy gives excellent times for queries that <p> Tabled Breadth-First Search was formally defined in <ref> [3] </ref> where we prove that any fact derived by this strategy is also derived by SNMT, that is, on an iteration-by-iteration basis, Tabled Breadth-First Search is equivalent to Semi-Naive Magic Template evaluation. Experimental results presented in [3] show that an implementation of the breadth-first strategy gives excellent times for queries that involve disk-resident data without sacrificing in-memory performance. 4 Conclusion We have presented a breadth-first scheduling strategy for tabled evaluations that combines fast in-memory processing of top-down logic programming systems with set-at-a-time access to external 4 data.
Reference: [4] <editor> H. Gallaire and J. Minker. </editor> <title> Logic and Databases. </title> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Usually, when one wants to reason about the contents of a database, it is necessary to leave the relational model by embedding SQL into a lower-level language such as C, which results in an impedance mismatch and consequent loss of declarativeness. Deductive databases <ref> [4, 5] </ref> address this problem by adopting logic programming or a restriction such as Datalog [11] as the query language.
Reference: [5] <editor> H. Gallaire, J. Minker, and J.M. Nicolas. </editor> <title> Logic and Databases: A Deductive Approach. </title> <journal> ACM Computing Surveys, </journal> <volume> 16 </volume> <pages> 153-185, </pages> <year> 1984. </year>
Reference-contexts: Usually, when one wants to reason about the contents of a database, it is necessary to leave the relational model by embedding SQL into a lower-level language such as C, which results in an impedance mismatch and consequent loss of declarativeness. Deductive databases <ref> [4, 5] </ref> address this problem by adopting logic programming or a restriction such as Datalog [11] as the query language.
Reference: [6] <author> R. Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 189-216, </pages> <year> 1991. </year>
Reference-contexts: It is important that we answer this query examining only the part of the database that involves individuals somehow connected to joe. Magic templates rewriting (see e.g. <ref> [6] </ref>) addresses this problem by means of a program transformation. Magic is well-discussed in the literature [11]; here we give an example to illustrate the idea.
Reference: [7] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, relations, </title> <booktitle> and logic. In Proc. of the 18th International Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 238-250, </pages> <year> 1992. </year>
Reference-contexts: Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent [10, 8]. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems. Magic-style systems, such as Aditi [12], LDL [2] and CORAL <ref> [7] </ref>, are built upon set-at-a-time engines, and can use set-at-a-time operations like relational joins that may be made efficient for disk-resident data, while tabling systems, such as XSB [9], use a tuple-at-a-time strategy that reflects their genesis in the logic programming community.
Reference: [8] <author> K.A. Ross. </author> <title> Modular stratification and magic sets for datalog programs with negation. </title> <journal> JACM, </journal> <volume> 41(6) </volume> <pages> 1216-1266, </pages> <year> 1994. </year>
Reference-contexts: Magic evaluation closely resembles tabling. Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent <ref> [10, 8] </ref>. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems.
Reference: [9] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> XSB as an efficient deductive database engine. </title> <booktitle> In Proceedings of SIGMOD, </booktitle> <pages> pages 442-453, </pages> <year> 1994. </year>
Reference-contexts: Magic-style systems, such as Aditi [12], LDL [2] and CORAL [7], are built upon set-at-a-time engines, and can use set-at-a-time operations like relational joins that may be made efficient for disk-resident data, while tabling systems, such as XSB <ref> [9] </ref>, use a tuple-at-a-time strategy that reflects their genesis in the logic programming community. Presently for in-memory Datalog queries, due mainly to the use of Prolog compilation technology, the fastest tabling systems show an order of magnitude speedup over magic-style systems [9]. <p> for disk-resident data, while tabling systems, such as XSB <ref> [9] </ref>, use a tuple-at-a-time strategy that reflects their genesis in the logic programming community. Presently for in-memory Datalog queries, due mainly to the use of Prolog compilation technology, the fastest tabling systems show an order of magnitude speedup over magic-style systems [9]. However, because of their tuple-at-a-time strategy, tabling systems cannot be efficiently extended to disk, and thus, they are not practical for applications that deal with massive amounts of data.
Reference: [10] <author> H. Seki. </author> <title> On the power of Alexander templates. </title> <booktitle> In Proceedings of PODS, </booktitle> <pages> pages 150-159, </pages> <year> 1989. </year>
Reference-contexts: Magic evaluation closely resembles tabling. Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent <ref> [10, 8] </ref>. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems.
Reference: [11] <author> J. Ullman. </author> <title> Principles of Data and Knowledge-base Systems Vol I and II. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Deductive databases [4, 5] address this problem by adopting logic programming or a restriction such as Datalog <ref> [11] </ref> as the query language. Prolog engines have been used to evaluate Datalog queries, but they have proven to be unacceptable for data-oriented queries for two major reasons: their poor termination and complexity properties for Datalog, and their tuple-at-a-time strategy. <p> Tabling In semi-naive bottom-up evaluation <ref> [11] </ref>, a derivation is made as follows: previously derived (or stored) facts are unified with each goal in the body of a rule; the head of the instantiated rule is the fact that is derived. Semi-naive is an incremental iterative fixpoint algorithm. <p> It is important that we answer this query examining only the part of the database that involves individuals somehow connected to joe. Magic templates rewriting (see e.g. [6]) addresses this problem by means of a program transformation. Magic is well-discussed in the literature <ref> [11] </ref>; here we give an example to illustrate the idea. A magic transformation of the rules in Example 2.1 would be: query (Y):- sg (joe,Y). magic (sg (joe,Y)). sg (X,Y):- magic (sg (X,Y)),person (X),X=Y. sg (X,Y):- magic (sg (X,Y)),par (X,Xp),sg (Xp,Yp),par (Y,Yp). magic (sg (Xp,Yp)):- magic (sg (X,Y)),par (X,Xp).
Reference: [12] <author> J. Vaghani, K. Ramamohanarao, D.B. Kemp, Z. Somogyi, P.J. Stuckey, T.S. Leask, and J. Harland. </author> <title> The Aditi deductive database system. </title> <journal> The VLDB Journal, </journal> <volume> 3(2) </volume> <pages> 245-288, </pages> <year> 1994. </year>
Reference-contexts: Magic evaluation closely resembles tabling. Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent [10, 8]. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems. Magic-style systems, such as Aditi <ref> [12] </ref>, LDL [2] and CORAL [7], are built upon set-at-a-time engines, and can use set-at-a-time operations like relational joins that may be made efficient for disk-resident data, while tabling systems, such as XSB [9], use a tuple-at-a-time strategy that reflects their genesis in the logic programming community.
Reference: [13] <author> D.S. Warren. </author> <title> Memoing for logic programs. </title> <journal> Communications of the ACM, </journal> <volume> 35(3) </volume> <pages> 93-111, </pages> <year> 1992. </year> <month> 5 </month>
Reference-contexts: A number of approaches have been used to attack the termination and complexity problems, most notably: (1) tabling <ref> [13] </ref>, which has added features of database evaluation to logic programming languages, and (2) magic evaluation [1], which has embedded recursive goal-orientation in the framework of database evaluation. Magic evaluation closely resembles tabling. Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking.
References-found: 13

