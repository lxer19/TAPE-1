URL: ftp://ftp.cs.wisc.edu/markhill/Papers/sosp95_pagetables.ps
Refering-URL: http://www.cs.wisc.edu/~markhill/
Root-URL: 
Note: Appears in Proceedings of SOSP95  
Abstract: Most computer architectures are moving to 64-bit virtual addr ess spaces. W e f irst discuss how this change impacts conventional linear , forwar d-mapped, and hashed page tables. W e then intr oduce a new page table data str uctureclustered page ta-blethat can be viewed as a hashed page table augmented with subblocking. Specif ically, it associates mapping information for several pages ( e.g., sixteen) with a single virtual tag and next pointer. Simulation results with several workloads show that cluster ed page tables use less memory than alternatives without adversely affecting page table access time. Since physical addr ess space use is also incr easing, computer ar chitects are using new techniques such as superpages, completesubblocking, and partial-subblockingto incr ease the memory mapped by a translation lookaside buf fer (TLB). Since these techniques are completely inef fective without page table support, we next look at extending conventional and clustered page tables to support them. Simulation results show cluster ed page tables support medium-sized superpage and subblock TLBs especially well. 
Abstract-found: 1
Intro-found: 1
Reference: [Agar88] <author> A. Agarwal, M. Horowitz, J. Hennessy. </author> <title> Cache Performance of Operating Systems and Multiprogramming Workloads. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 6(4):393 431, </volume> <month> November </month> <year> 1988. </year>
Reference-contexts: They ar e sonamed, because they can be viewed as memory-r esident level-two TLBs with overflow handled in many ways <ref> [Agar88, Silh93, Thak86] </ref>. The innovations we develop for hashed page tables ar e applicable to inverted page tables or software TLBs also. Due to space constraints, in this paper we only describe hashed page tables. Inverted page tables and softwar e TLB variations ar e described in [Tall95]. <p> An important limitation of our workloads is that we do not str ess the TLB with multipr ogrammed workloads 4 . Multipr ogramming can incr ease the number of TLB misses and make TLB miss handling more signif icant <ref> [Agar88] </ref>. Multipr ogramming can also affect physical memory allocation in superpage and partialsubblock systems. When physical memory demand is high, the operating system may not be able to use superpages or partialsubblocking as effectively as our simulations show.
Reference: [Appe91] <author> Andrew W. Appel and David B. McQueen. </author> <title> Standard ML of New Jersey. </title> <booktitle> In Proc. Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 113, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: compress, wave5, spice, and gcc ar e fr om the SPEC92 suite [SPEC91]; fftpde is a NAS benchmark [Bail91] operating on a 64X64X64 matrix; mp3d and pthor are unipr ocessor versions fr om the SPLASH benchmark suite [Sing92]; coral [Rama93] is a deductive database executing a nested loop join; ML <ref> [Appe91] </ref> is executing a str ess test on the garbage collector [Repp94]. Compress and gcc ar e multipr ogrammed workloads. Many pr ograms have negligible TLB miss ratios and would not benef it fr om page table enhancements.
Reference: [Bail91] <author> David Bailey, John Barton, Thomas Lasinski, Horst Simon. </author> <title> The NAS Parallel Benchmarks. </title> <journal> Intl. Journal of Supercomputer Applications, </journal> <volume> 5(3):6373, </volume> <month> Fall </month> <year> 1991. </year>
Reference-contexts: Our metric thus includes the opportunity cost for reserved TLB entries. 6.2 Workloads We selected ten 32-bit workloads that spend significant time in TLB miss handling. Nasa7, compress, wave5, spice, and gcc ar e fr om the SPEC92 suite [SPEC91]; fftpde is a NAS benchmark <ref> [Bail91] </ref> operating on a 64X64X64 matrix; mp3d and pthor are unipr ocessor versions fr om the SPLASH benchmark suite [Sing92]; coral [Rama93] is a deductive database executing a nested loop join; ML [Appe91] is executing a str ess test on the garbage collector [Repp94].
Reference: [Bala94] <author> Kavita Bala, M. Frans Kaashoek, William E. Weihl. </author> <title> Software prefetching and caching for translation lookaside buffers. </title> <booktitle> In Proc. First Symposium on Operating System Design and Implementation (OSDI), </booktitle> <pages> pages 243253, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Variations on hashed tables include inverted page tables and softwar e TLBs. Inverted page tables , e.g., in IBM System/38 [IBM78], hash to an array of pointers that when der eferenced obtain the f irst element of the hash bucket. Software TLBs (e.g., swTLB [Huck93], TSB [Yung95], STLB <ref> [Bala94] </ref>, PowerPCs page table [Silh93]) eliminate a hashed page tables next pointers by pr e-allocating a f ixed number of PTEs per bucket. They ar e sonamed, because they can be viewed as memory-r esident level-two TLBs with overflow handled in many ways [Agar88, Silh93, Thak86].
Reference: [Chan88] <author> Albert Chang and Mark F. Mergen. </author> <title> 801 Storage: Architecture and Programming. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 6(1):2850, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: This paper explores the effect of 64-bit addresses on page tables. An address is a virtual address unless we explicitly identify it as a physical address. A page table stor es translation, pr otection, attribute and status information for (virtual) addr esses <ref> [Huck93, Chan88, Levy82, Silh93, Lee89] </ref>. The information for each page is called a page table entry (PTE). The TLB miss handler accesses the page table on a TLB miss to load the appr opriate PTE into the TLB. <p> T ech-niques to short-cir cuit some levels, e.g., guarded page tables [Lied95] or Region Lookaside Buf fers [Chan95], ar e partially ef fective but still r equire many levels. . Large address space systems often use hashed (inverted) page tables <ref> [Lee89, Chan88, Rose85, Huck93] </ref>. The simplest implementation uses an open hash table with a hash function that maps a VPN to a bucket. Each PTE in the hash table, stor es the mapping information for one page, a tag identifying the VPN, and a next pointer.
Reference: [Chan95] <author> David Chih-Wei Chang and et al. </author> <title> Microarchitecture of HaLs Memory Management Unit. </title> <booktitle> Compcon Digest of Papers, </booktitle> <pages> pages 272279, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Forwar d-mapped page tables ar e impractical for 64-bit address spaces, because the overhead of seven memory accesses on every TLB miss is not acceptable. T ech-niques to short-cir cuit some levels, e.g., guarded page tables [Lied95] or Region Lookaside Buf fers <ref> [Chan95] </ref>, ar e partially ef fective but still r equire many levels. . Large address space systems often use hashed (inverted) page tables [Lee89, Chan88, Rose85, Huck93]. The simplest implementation uses an open hash table with a hash function that maps a VPN to a bucket. <p> In particular, it supports no mediumsize superpages. Forward-Mapped Intermediate Nodes. Forward-mapped page tables ar e a multilevel tr ee str ucture and also can stor e superpage PTEs at intermediate tree nodes, e.g., SPARC Refer ence MMU [SP AR91] and HaL <ref> [Chan95] </ref> support a few f ixed superpage sizes in this fashion. It is possible to extend forwar d-mapped page tables to support any arbitrary super-page size by varying the tr ees branching factor dynamically.
Reference: [Chas94] <author> J. S. Chase, H. M. Levy, M. J. Feeley, E. D. Lazowska. </author> <title> Sharing and Protection in a Single-Address-Space Operating System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(4):271307, </volume> <month> November </month> <year> 1994. </year>
Reference-contexts: The page table techniques described in this paper ar e equally applicable to single address space s ys tem s, e.g. , Opal <ref> [ Chas94] </ref> or MONADS [Rose85], and segmented systems that use global ef fective virtual addr esses, e.g, HP [Lee89] and a single shared page table.
Reference: [Denn70] <author> Peter J. Denning. </author> <title> Virtual Memory. </title> <journal> Computing Surveys, </journal> <volume> 2(3):153189, </volume> <month> September </month> <year> 1970. </year>
Reference-contexts: 1 Introduction One longstanding computer tr end is that pr o-grams memory usage doubles each year or two [Henn90]. Theoretically, therefore, systems that support paged virtual memory <ref> [Denn70] </ref> should increase their virtual and physical addr ess sizes linearly each year . In practice, however , compatibili ty issues for ce addr ess spaces to gr ow discontinuously, especially for virtual addr esses.
Reference: [Eykh92] <author> J. R. Eykholt, S. R. Kleiman, S. Barton, R. Faulkner, A. Shivalingiah, M. Smith, D. Stein, J. Voll, M. Weeks, D. Williams. </author> <title> Beyond Multiprocessing: Multithreading the SunOS Kernel. </title> <booktitle> In Proc. of the Summer USENIX Conference, </booktitle> <pages> pages 1118, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: It has two drawbacks. First, it does not allow the use of superpages to make page tables smaller. Second, r eplicated PTEs make adding or atomic update of superpage PTEs mor e complex in multi-threaded operating systems <ref> [Eykh92] </ref>. Multiple Page T ables. This solution cr eates a page table for each page size (or a set of page sizes) in use. On a TLB miss, the handler first accesses one of these page tables.
Reference: [Good83] <author> James R. Goodman. </author> <title> Using Cache Memory to Reduce Processor-Memory Traffic. </title> <booktitle> In Proc. of the Tenth Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 124131, </pages> <address> Stockholm Sweden, </address> <month> June </month> <year> 1983. </year>
Reference-contexts: Section 3 intr oduces the central contribution of this paper: the clustered page table. It is a new page table data str ucture that can be viewed as a hashed page table augmented with subblocking, a simple but effective technique used in har dware caches and TLBs <ref> [Lipt68, Good83, Hill84, T all94] </ref>. Hashed page tables associate a tag with every PTE. Clustered page A New Page Table for 64-bit Address Spaces Madhusudhan Talluri "= , Mark D. Hill " , Yousef A. <p> The section intr o-duces cluster ed page tables for pages of a single page size (4KB), base pages. Section 5 extends them to work with superpage and subblock TLBs. A clustered page table uses subblocking <ref> [Good83] </ref> to extend a hashed page table. Each node in the hash table stores one tag but stor es mappings for multiple base pages that belong to the same page blockan aligned gr oup of consecutive pages.
Reference: [Henn90] <author> John L Hennessy and David A Patterson. </author> <title> Computer Architecture A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers Inc., </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction One longstanding computer tr end is that pr o-grams memory usage doubles each year or two <ref> [Henn90] </ref>. Theoretically, therefore, systems that support paged virtual memory [Denn70] should increase their virtual and physical addr ess sizes linearly each year . In practice, however , compatibili ty issues for ce addr ess spaces to gr ow discontinuously, especially for virtual addr esses.
Reference: [Hill84] <author> Mark D. Hill and Alan Jay Smith. </author> <title> Experimental Evaluation of On-Chip Microprocessor Cache Memories. </title> <booktitle> In Proc. of the 11th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 158166, </pages> <address> Ann Arbor MI, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: Section 3 intr oduces the central contribution of this paper: the clustered page table. It is a new page table data str ucture that can be viewed as a hashed page table augmented with subblocking, a simple but effective technique used in har dware caches and TLBs <ref> [Lipt68, Good83, Hill84, T all94] </ref>. Hashed page tables associate a tag with every PTE. Clustered page A New Page Table for 64-bit Address Spaces Madhusudhan Talluri "= , Mark D. Hill " , Yousef A.
Reference: [Hill87] <author> Mark D. Hill. </author> <title> Aspects of Cache Memory and Instruction Buffer Performance. </title> <type> Ph.D. thesis, </type> <institution> University of California, Berkeley, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: S u b b l oc k prefetching never pollutes the TLB by r eplacing more useful mappings, because it never causes extra replacements <ref> [Hill87] </ref>, but r educes the number of TLB misses significantly50% or more [Tall95]. A drawback of subblock pr efetching is the increased time to service TLB block misses. This penalty is lar ge for hashed page tables, because multiple hash pr obes ar e needed.
Reference: [Huck93] <author> Jerry Huck and Jim Hays. </author> <title> Architectural Support for Translation Table Management in Large Address Space Machines. </title> <booktitle> In Proc. of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 3950, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: This paper explores the effect of 64-bit addresses on page tables. An address is a virtual address unless we explicitly identify it as a physical address. A page table stor es translation, pr otection, attribute and status information for (virtual) addr esses <ref> [Huck93, Chan88, Levy82, Silh93, Lee89] </ref>. The information for each page is called a page table entry (PTE). The TLB miss handler accesses the page table on a TLB miss to load the appr opriate PTE into the TLB. <p> Section 8 r eiterates our contributions. 2 Extensions to Conventional Page Tables for 64-bit Address Spaces This section r eviews commonly-used page ta-bleslinear, forwar d-mapped, and hashedand discusses extending them to support 64-bit (virtual) addresses. A detailed description can be found in Huck and Hays <ref> [Huck93] </ref>. For all page table designs, 64-bit addr ess mapping information will r equire eight bytes (unless physical addr esses ar e r estricted to less than about 36 bits). <p> T ech-niques to short-cir cuit some levels, e.g., guarded page tables [Lied95] or Region Lookaside Buf fers [Chan95], ar e partially ef fective but still r equire many levels. . Large address space systems often use hashed (inverted) page tables <ref> [Lee89, Chan88, Rose85, Huck93] </ref>. The simplest implementation uses an open hash table with a hash function that maps a VPN to a bucket. Each PTE in the hash table, stor es the mapping information for one page, a tag identifying the VPN, and a next pointer. <p> Variations on hashed tables include inverted page tables and softwar e TLBs. Inverted page tables , e.g., in IBM System/38 [IBM78], hash to an array of pointers that when der eferenced obtain the f irst element of the hash bucket. Software TLBs (e.g., swTLB <ref> [Huck93] </ref>, TSB [Yung95], STLB [Bala94], PowerPCs page table [Silh93]) eliminate a hashed page tables next pointers by pr e-allocating a f ixed number of PTEs per bucket. They ar e sonamed, because they can be viewed as memory-r esident level-two TLBs with overflow handled in many ways [Agar88, Silh93, Thak86]. <p> A softwar e TLB allows the choice of a lar ger subblock factor in clustered page tables than the cache line size dictates or makes it practical to use a slower forwar d-mapped page table <ref> [Huck93] </ref>. The exibility and ef fi-ciency of implementing operating system page table algorithms (Section 3.1) then becomes the overriding factor in choosing a page table structure. <p> For example, hashed page tables can be optimized by packing both the tag and next pointer into eight bytes by using a shorter next pointer and not storing tag bits that can be inferr ed fr om indexing the table <ref> [Huck93] </ref>. This r educes hashed page table size by 33%. This, however , does not change our results as cluster ed page tables ar e mor e ef fective with page table size r eductions of 50% or mor e over the unoptimized hashed page table (Figur e 10).
Reference: [IBM78] <institution> IBM System/38 technical developments. IBM, </institution> <year> 1978. </year> <title> Order no G580-0237. </title>
Reference-contexts: Variations on hashed tables include inverted page tables and softwar e TLBs. Inverted page tables , e.g., in IBM System/38 <ref> [IBM78] </ref>, hash to an array of pointers that when der eferenced obtain the f irst element of the hash bucket.
Reference: [Kane92] <author> Gerry Kane and Joe Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: It explains why both linear and hashed page tables ar e viable for 64-bit addr esses, and why forwar d-mapped page tables are probably impractical as each TLB miss r equires about seven memory r eferences. Many processors now support TLB miss handling in software, e.g., MIPS <ref> [Kane92] </ref>, Alpha [Site93], UltraS-PARC [Yung95]. This makes page table design an operating system issue and in this paper we explor e alternate operating system data structures for storing page tables and servicing TLB misses. Section 3 intr oduces the central contribution of this paper: the clustered page table. <p> Hardware designers ar e incr easing the ef fective-ness of TLBs for 64-bit systems using techniques such as superpages [Tall92] and subblocking <ref> [Kane92, Tall94] </ref>. These techniques ar e very ef fective at improving TLB performance, r educing the number of TLB misses by 50% to 99%, and pr oviding an average execution time speedup of upto 20% for the workloads we use [T all95]. <p> reside in virtual addr ess space, using page faults to d y n a m i c a l l y p o p u l a t e t h e t a b l e ( e . g . , VA X - 11 [Levy82], MIPS R4000 <ref> [Kane92] </ref>). Consequently , PTEs ar e allocated a page at a time and space overhead is high if an addr ess space is used sparsely . A separate data str ucture stor es mappings to the page table itself. <p> Many pr ocessors now support superpages, e.g., MIPS <ref> [Kane92] </ref>, UltraSP ARC [Yung95], Alpha [Site93], PowerPC [Silh93] etc. Supporting superpag-es is easier than supporting segments, which use a two-dimensional addr ess space, may be arbitrarily long, and may start at arbitrary physical addr esses [Orga72]. The MIPS R4000 [Kane92], for example, supports a 4KB base page size and superpages of <p> Many pr ocessors now support superpages, e.g., MIPS <ref> [Kane92] </ref>, UltraSP ARC [Yung95], Alpha [Site93], PowerPC [Silh93] etc. Supporting superpag-es is easier than supporting segments, which use a two-dimensional addr ess space, may be arbitrarily long, and may start at arbitrary physical addr esses [Orga72]. The MIPS R4000 [Kane92], for example, supports a 4KB base page size and superpages of 16KB, 64KB, 256KB, 1MB, 4MB, and 16MB. Lar ge su-perpages, e.g., 256KB and larger, are useful for kernel data, frame buf fer, database buf fer pools, etc. <p> Subblocking associates multiple PPNs with each TLB tag [Tall94]. With a subblock factor of sixteen and 4KB pages, for example, each tag covers an aligned 64KB block of (virtual) addr esses. The MIPS R4X00 <ref> [Kane92] </ref> processors support a subblock factor of two in the TLB. Subblocking is ef fective when spatial locality makes it likely that consecutive pages ar e in contemporaneous use. <p> Subblock misses add a new PPN and attribute information to an existing TLB entry , without causing a replacement. Subblock misses can be eliminated, however, if each block miss loads (pr efetches) all mappings associated with its tag, as the MIPS R4000 does for two PTEs <ref> [Kane92] </ref>. For example, on a TLB miss to virtual addr ess 0x41034 the TLB miss handler for MIPS R4000 would pr efetch mappings to v i r t u a l p a ge s 0 x4 0 0 0 0 a n d 0x 4 10 0 0 . <p> This would r esult in a performance only slightly worse that reported in Section 6.3. Many pr ocessors support mor e than one super-page size, e.g., the MIPS R4000 pr ocessor supports pages sizes of 4KB, 16KB, 64KB, 256KB, 1MB, 4MB, and 16MB <ref> [Kane92] </ref>. While our quantitative measurements include the effect of only two page sizes 4KB and 64KBclustered page tables support multiple page sizes mor e ef fectively then other page tables.
Reference: [Khal93] <author> Yousef Khalidi, Madhusudhan Talluri, Michael N. Nel-son, Dock Williams. </author> <title> Virtual Memory Support for Multiple Page Sizes. </title> <booktitle> In Proc. of the Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 104109, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Medium superpages, e.g., 16KB or 64KB, r equire mor e substantial operating system changes to pr ovide the mechanisms to support them and the policies for choosing appr opriate page sizes <ref> [Tall94, Khal93, Rome95] </ref>. Subblocking associates multiple PPNs with each TLB tag [Tall94]. With a subblock factor of sixteen and 4KB pages, for example, each tag covers an aligned 64KB block of (virtual) addr esses. The MIPS R4X00 [Kane92] processors support a subblock factor of two in the TLB.
Reference: [Khal94] <author> Yousef A. Khalidi, Vikram P. Joshi, Dock Williams. </author> <title> A Study of the Structure and Performance of MMU Handling Software. </title> <type> Technical Report TR-94-28, </type> <institution> Sun Microsystems Laboratories, </institution> <year> 1994. </year>
Reference-contexts: T h e synchronization protocol can significantly af fect performance <ref> [Khal94] </ref>. Hashed and cluster ed page tables may associate a lock with each hash bucket.
Reference: [Knut68] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Volume 3. </volume> <publisher> Addison Wesley, </publisher> <year> 1968. </year> <note> Second Printing. </note>
Reference-contexts: This r educes the number of PTEs in the page table and r esults in shorter hash table lists, a hash table with fewer buckets, or both. Shorter hash table lists reduce hash table search time on TLB misses <ref> [Knut68, Morr68] </ref>. Clustered page tables can have a worse page table access time if cache performance on TLB misses is worse when tag and mapping information r eside in separate cache lines. 3.1 Clustered Page Table support for Page Table Manipulations Page tables must support several operations.
Reference: [Lee89] <author> Ruby B. Lee. </author> <title> Precision Architecture. </title> <journal> IEEE Computer, </journal> <volume> 22(1):7891, </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: This paper explores the effect of 64-bit addresses on page tables. An address is a virtual address unless we explicitly identify it as a physical address. A page table stor es translation, pr otection, attribute and status information for (virtual) addr esses <ref> [Huck93, Chan88, Levy82, Silh93, Lee89] </ref>. The information for each page is called a page table entry (PTE). The TLB miss handler accesses the page table on a TLB miss to load the appr opriate PTE into the TLB. <p> T ech-niques to short-cir cuit some levels, e.g., guarded page tables [Lied95] or Region Lookaside Buf fers [Chan95], ar e partially ef fective but still r equire many levels. . Large address space systems often use hashed (inverted) page tables <ref> [Lee89, Chan88, Rose85, Huck93] </ref>. The simplest implementation uses an open hash table with a hash function that maps a VPN to a bucket. Each PTE in the hash table, stor es the mapping information for one page, a tag identifying the VPN, and a next pointer. <p> The page table techniques described in this paper ar e equally applicable to single address space s ys tem s, e.g. , Opal [ Chas94] or MONADS [Rose85], and segmented systems that use global ef fective virtual addr esses, e.g, HP <ref> [Lee89] </ref> and a single shared page table. Hashed and clustered page tables ar e especially suited to single addr ess space and segmented systems as they tend to have a very sparse but "bursty" address space.
Reference: [Levy82] <author> H. M. Levy and P. H. Lipman. </author> <title> Virtual Memory Management in the VAX/VMS Operating System. </title> <journal> IEEE Computer, </journal> <volume> 15(3):3541, </volume> <month> March </month> <year> 1982. </year>
Reference-contexts: This paper explores the effect of 64-bit addresses on page tables. An address is a virtual address unless we explicitly identify it as a physical address. A page table stor es translation, pr otection, attribute and status information for (virtual) addr esses <ref> [Huck93, Chan88, Levy82, Silh93, Lee89] </ref>. The information for each page is called a page table entry (PTE). The TLB miss handler accesses the page table on a TLB miss to load the appr opriate PTE into the TLB. <p> Consequently, they reside in virtual addr ess space, using page faults to d y n a m i c a l l y p o p u l a t e t h e t a b l e ( e . g . , VA X - 11 <ref> [Levy82] </ref>, MIPS R4000 [Kane92]). Consequently , PTEs ar e allocated a page at a time and space overhead is high if an addr ess space is used sparsely . A separate data str ucture stor es mappings to the page table itself.
Reference: [Lied95] <author> Jochen Liedtke. </author> <title> Address Space Sparsity and Fine Granularity. Operating Systems Review, </title> <address> 29(1):8790, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Forwar d-mapped page tables ar e impractical for 64-bit address spaces, because the overhead of seven memory accesses on every TLB miss is not acceptable. T ech-niques to short-cir cuit some levels, e.g., guarded page tables <ref> [Lied95] </ref> or Region Lookaside Buf fers [Chan95], ar e partially ef fective but still r equire many levels. . Large address space systems often use hashed (inverted) page tables [Lee89, Chan88, Rose85, Huck93].
Reference: [Lipt68] <author> J. S. Liptay. </author> <title> Structural aspects of the System/360 Model 85, Part II: the cache. </title> <journal> IBM Systems Journal, </journal> <volume> 7(1):1521, </volume> <year> 1968. </year>
Reference-contexts: Section 3 intr oduces the central contribution of this paper: the clustered page table. It is a new page table data str ucture that can be viewed as a hashed page table augmented with subblocking, a simple but effective technique used in har dware caches and TLBs <ref> [Lipt68, Good83, Hill84, T all94] </ref>. Hashed page tables associate a tag with every PTE. Clustered page A New Page Table for 64-bit Address Spaces Madhusudhan Talluri "= , Mark D. Hill " , Yousef A.
Reference: [May94] <editor> Cathay May, Ed Silha, Rick Simpson, Hank Warren. </editor> <title> The PowerPC Architecture. </title> <publisher> Morgan Kaufman Publishers, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: However , this is not critical as TLB miss handlers typically access page tables and update r eference and modif ied bits without acquiring any locks. PowerPC, for example, defines a synchr o-nization algorithm for page table updates that accounts for this unorthodox behavior of TLB miss handlers <ref> [May94] </ref>. Systems that r equire TLB miss handlers to acquir e locks can use r eaders-writer locks that allow multiple TLB lookups in parallel. We next r eview r ecent pr oposals for new TLB techniques that r equire page table support to be effective.
Reference: [Mile90] <author> Milan Milenkovic. </author> <title> Microprocessor Memory Management Units. </title> <journal> IEEE Micro, </journal> <volume> 10(2):7085, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: W e next r eview Appears in Proceedings of SOSP95 the new TLB techniques and then examine adapting conventional page tables to support superpages, partial-subblocking, and pr efetching into completesub-block TLBs. 4.1 Superpage and Subblock TLBs A TLB is a cache whose entries hold r ecently-used PTEs <ref> [Mile90] </ref>. A conventional TLB entry has VPN (and pr ocess ID, etc.) for a tag and physical page number (PPN) (and pr otection information, page-modified bit, etc.) as data.
Reference: [Morr68] <author> R. Morris. </author> <title> Scatter Storage Techniques. </title> <journal> Communications of the ACM, </journal> <volume> 11(1):3843, </volume> <month> January </month> <year> 1968. </year>
Reference-contexts: This r educes the number of PTEs in the page table and r esults in shorter hash table lists, a hash table with fewer buckets, or both. Shorter hash table lists reduce hash table search time on TLB misses <ref> [Knut68, Morr68] </ref>. Clustered page tables can have a worse page table access time if cache performance on TLB misses is worse when tag and mapping information r eside in separate cache lines. 3.1 Clustered Page Table support for Page Table Manipulations Page tables must support several operations.
Reference: [Nagl94] <author> David Nagle, Richard Uhlig, Tim Stanley, Stuart Sechrest, Trevor Mudge, Richard Brown. </author> <title> Design Tradeoffs for Software-Managed TLBs. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 12(3):175205, </volume> <month> August </month> <year> 1994. </year>
Reference-contexts: A multilevel tr ee of linear page tables is commonly used, e.g., Ultrix uses a two-level tr ee and OSF/1 uses a 3-level tr ee on the MIPS R3000 <ref> [Nagl94] </ref>. The straightforward extension of linear page tables to 64-bit addresses uses a virtual array with four thousand trillion entries and a 6-level tr ee. This design is practical, as a portion of the TLB is r eserved for mappings to the page tables [Nagl94] and the tr ee is rarely <p> tr ee on the MIPS R3000 <ref> [Nagl94] </ref>. The straightforward extension of linear page tables to 64-bit addresses uses a virtual array with four thousand trillion entries and a 6-level tr ee. This design is practical, as a portion of the TLB is r eserved for mappings to the page tables [Nagl94] and the tr ee is rarely traversed. Alternatively , some other data structure can be used to stor e the mappings to the linear page table itself ( e.g., a hashed page table or a forward-mapped page table, described below).
Reference: [Orga72] <author> E.J. Organick. </author> <title> The Multics System: An Examination of Its Structure. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1972. </year>
Reference-contexts: Many pr ocessors now support superpages, e.g., MIPS [Kane92], UltraSP ARC [Yung95], Alpha [Site93], PowerPC [Silh93] etc. Supporting superpag-es is easier than supporting segments, which use a two-dimensional addr ess space, may be arbitrarily long, and may start at arbitrary physical addr esses <ref> [Orga72] </ref>. The MIPS R4000 [Kane92], for example, supports a 4KB base page size and superpages of 16KB, 64KB, 256KB, 1MB, 4MB, and 16MB. Lar ge su-perpages, e.g., 256KB and larger, are useful for kernel data, frame buf fer, database buf fer pools, etc.
Reference: [Rama93] <author> Raghu Ramakrishnan, Divesh Srivastava, S. Sudarshan, Praveen Seshadri. </author> <title> Implementation of the CORAL Deductive Database System. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1993. </year>
Reference-contexts: Nasa7, compress, wave5, spice, and gcc ar e fr om the SPEC92 suite [SPEC91]; fftpde is a NAS benchmark [Bail91] operating on a 64X64X64 matrix; mp3d and pthor are unipr ocessor versions fr om the SPLASH benchmark suite [Sing92]; coral <ref> [Rama93] </ref> is a deductive database executing a nested loop join; ML [Appe91] is executing a str ess test on the garbage collector [Repp94]. Compress and gcc ar e multipr ogrammed workloads. Many pr ograms have negligible TLB miss ratios and would not benef it fr om page table enhancements.
Reference: [Repp94] <author> John H. Reppy. </author> <title> A High-performance Garbage Collector for Standard ML, 1994. </title> <institution> AT&T Bell Labs Technical Memo. </institution>
Reference-contexts: suite [SPEC91]; fftpde is a NAS benchmark [Bail91] operating on a 64X64X64 matrix; mp3d and pthor are unipr ocessor versions fr om the SPLASH benchmark suite [Sing92]; coral [Rama93] is a deductive database executing a nested loop join; ML [Appe91] is executing a str ess test on the garbage collector <ref> [Repp94] </ref>. Compress and gcc ar e multipr ogrammed workloads. Many pr ograms have negligible TLB miss ratios and would not benef it fr om page table enhancements. By emphasizing workloads for which TLB miss handling is important our r esults overestimate the potential benef it for workloads with small processes.
Reference: [Rome95] <author> Ted Romer, Wayne Ohlrich, Anna Karlin, Brian Bershad. </author> <title> Reducing TLB and Memory Overhead Using Online Super-page Promotion. </title> <booktitle> In Proc. of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 176187, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Medium superpages, e.g., 16KB or 64KB, r equire mor e substantial operating system changes to pr ovide the mechanisms to support them and the policies for choosing appr opriate page sizes <ref> [Tall94, Khal93, Rome95] </ref>. Subblocking associates multiple PPNs with each TLB tag [Tall94]. With a subblock factor of sixteen and 4KB pages, for example, each tag covers an aligned 64KB block of (virtual) addr esses. The MIPS R4X00 [Kane92] processors support a subblock factor of two in the TLB.
Reference: [Rose85] <author> J. Rosenberg and D. A. Abramson. </author> <title> MONAD PC: A Capability Based Workstation to Support Software Engineering. </title> <booktitle> In Proc. of the 18th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 222231, </pages> <year> 1985. </year>
Reference-contexts: T ech-niques to short-cir cuit some levels, e.g., guarded page tables [Lied95] or Region Lookaside Buf fers [Chan95], ar e partially ef fective but still r equire many levels. . Large address space systems often use hashed (inverted) page tables <ref> [Lee89, Chan88, Rose85, Huck93] </ref>. The simplest implementation uses an open hash table with a hash function that maps a VPN to a bucket. Each PTE in the hash table, stor es the mapping information for one page, a tag identifying the VPN, and a next pointer. <p> The page table techniques described in this paper ar e equally applicable to single address space s ys tem s, e.g. , Opal [ Chas94] or MONADS <ref> [Rose85] </ref>, and segmented systems that use global ef fective virtual addr esses, e.g, HP [Lee89] and a single shared page table. Hashed and clustered page tables ar e especially suited to single addr ess space and segmented systems as they tend to have a very sparse but "bursty" address space.
Reference: [Silh93] <author> Ed Silha. </author> <title> The PowerPC Architecture, IBM RISC System/ 6000 Technology, Volume II. </title> <institution> IBM Corp., </institution> <year> 1993. </year>
Reference-contexts: This paper explores the effect of 64-bit addresses on page tables. An address is a virtual address unless we explicitly identify it as a physical address. A page table stor es translation, pr otection, attribute and status information for (virtual) addr esses <ref> [Huck93, Chan88, Levy82, Silh93, Lee89] </ref>. The information for each page is called a page table entry (PTE). The TLB miss handler accesses the page table on a TLB miss to load the appr opriate PTE into the TLB. <p> Inverted page tables , e.g., in IBM System/38 [IBM78], hash to an array of pointers that when der eferenced obtain the f irst element of the hash bucket. Software TLBs (e.g., swTLB [Huck93], TSB [Yung95], STLB [Bala94], PowerPCs page table <ref> [Silh93] </ref>) eliminate a hashed page tables next pointers by pr e-allocating a f ixed number of PTEs per bucket. They ar e sonamed, because they can be viewed as memory-r esident level-two TLBs with overflow handled in many ways [Agar88, Silh93, Thak86]. <p> They ar e sonamed, because they can be viewed as memory-r esident level-two TLBs with overflow handled in many ways <ref> [Agar88, Silh93, Thak86] </ref>. The innovations we develop for hashed page tables ar e applicable to inverted page tables or software TLBs also. Due to space constraints, in this paper we only describe hashed page tables. Inverted page tables and softwar e TLB variations ar e described in [Tall95]. <p> Many pr ocessors now support superpages, e.g., MIPS [Kane92], UltraSP ARC [Yung95], Alpha [Site93], PowerPC <ref> [Silh93] </ref> etc. Supporting superpag-es is easier than supporting segments, which use a two-dimensional addr ess space, may be arbitrarily long, and may start at arbitrary physical addr esses [Orga72]. <p> One solution is to use a per process or per process gr oup page table instead of a single shared page table. Appears in Proceedings of SOSP95 In Section 2, we described set-associative software TLBs as an alternate native page table str uc-ture, e.g., page tables for the PowerPC <ref> [Silh93] </ref> ar e of this type. Softwar e TLBs, which can have thousands of entries, ar e also ef fective as a cache of r ecently used translations and may r eside between the TLB and a native page table.
Reference: [Sing92] <author> Jaswinder Pal Singh, Wolf-Dietrich Weber, Anoop Gupta. </author> <title> SPLASH: Stanford Parallel Applications for Shared Memory. Computer Architecture News, </title> <address> 20(1):544, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Nasa7, compress, wave5, spice, and gcc ar e fr om the SPEC92 suite [SPEC91]; fftpde is a NAS benchmark [Bail91] operating on a 64X64X64 matrix; mp3d and pthor are unipr ocessor versions fr om the SPLASH benchmark suite <ref> [Sing92] </ref>; coral [Rama93] is a deductive database executing a nested loop join; ML [Appe91] is executing a str ess test on the garbage collector [Repp94]. Compress and gcc ar e multipr ogrammed workloads.
Reference: [Site93] <author> Richard L. </author> <title> Sites. Alpha AXP Architecture. </title> <journal> Communications of the ACM, </journal> <volume> 36(2):3344, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: It explains why both linear and hashed page tables ar e viable for 64-bit addr esses, and why forwar d-mapped page tables are probably impractical as each TLB miss r equires about seven memory r eferences. Many processors now support TLB miss handling in software, e.g., MIPS [Kane92], Alpha <ref> [Site93] </ref>, UltraS-PARC [Yung95]. This makes page table design an operating system issue and in this paper we explor e alternate operating system data structures for storing page tables and servicing TLB misses. Section 3 intr oduces the central contribution of this paper: the clustered page table. <p> Many pr ocessors now support superpages, e.g., MIPS [Kane92], UltraSP ARC [Yung95], Alpha <ref> [Site93] </ref>, PowerPC [Silh93] etc. Supporting superpag-es is easier than supporting segments, which use a two-dimensional addr ess space, may be arbitrarily long, and may start at arbitrary physical addr esses [Orga72].
Reference: [SPAR91] <author> SPARC International Inc. </author> <title> The SPARC Architecture Appears in Proceedings of SOSP95 Manual, </title> <type> Version 8, </type> <year> 1991. </year>
Reference-contexts: Forward-mapped page tables stor e PTEs in nary trees, with each level of the tr ee indexed using fixed address f ields in the VPN (Figur e 3). The leaf nodes store PTEs while intermediate nodes stor e pointers (PTPs) to the next level ( e.g., SPARC Reference MMU <ref> [SPAR91] </ref>). Extending to a 64-bit addr ess space extends the number of levels to seven. Forwar d-mapped page tables ar e impractical for 64-bit address spaces, because the overhead of seven memory accesses on every TLB miss is not acceptable.
Reference: [SPEC91] <institution> SPEC. </institution> <note> SPEC Newsletter, 3(4), </note> <month> December </month> <year> 1991. </year>
Reference-contexts: Our metric thus includes the opportunity cost for reserved TLB entries. 6.2 Workloads We selected ten 32-bit workloads that spend significant time in TLB miss handling. Nasa7, compress, wave5, spice, and gcc ar e fr om the SPEC92 suite <ref> [SPEC91] </ref>; fftpde is a NAS benchmark [Bail91] operating on a 64X64X64 matrix; mp3d and pthor are unipr ocessor versions fr om the SPLASH benchmark suite [Sing92]; coral [Rama93] is a deductive database executing a nested loop join; ML [Appe91] is executing a str ess test on the garbage collector [Repp94].
Reference: [Tall92] <author> Madhusudhan Talluri, Shing Kong, Mark D. Hill, David A. Patterson. </author> <title> Tradeoffs in Supporting Two Page Sizes. </title> <booktitle> In Proc. of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 415424, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Hardware designers ar e incr easing the ef fective-ness of TLBs for 64-bit systems using techniques such as superpages <ref> [Tall92] </ref> and subblocking [Kane92, Tall94]. These techniques ar e very ef fective at improving TLB performance, r educing the number of TLB misses by 50% to 99%, and pr oviding an average execution time speedup of upto 20% for the workloads we use [T all95]. <p> Superpage-Index Hashed. One way to support superpages in a conventional hashed page table is to always assume a specific superpage size in the hash function and to associate with a bucket all appr opri-ate superpage and base page PTEs. T alluri et al. <ref> [Tall92] </ref> describe a similar scheme for har dware TLBs, wher e set-associative TLBs support two page sizes using the superpage index.
Reference: [Tall93] <author> Madhusudhan Talluri, Yousef A. Khalidi, Dock Williams, Vikram Joshi. </author> <title> Virtual Memory Computer System Address Translation Mechanism that Supports Multiple Page Sizes. Patent application filed, Serial No. </title> <institution> 08/139,549, Sun Micro-systems, </institution> <month> October </month> <year> 1993. </year> <note> (Accepted 1995). </note>
Reference-contexts: Finally, cluster ed page tables ar e the native page tables in Solaris 2.5, a commer cial operating system, on UltraSPARC-based computers. Appears in Proceedings of SOSP95 9 Acknowledgments We thank Dock W illiams and V ikram Joshi who are coinventors on a patent covering cluster ed page tables <ref> [Tall93] </ref>; A. Caceras and V. Joshi who designed and implemented clustered page tables in Solaris 2.5; J. Johnson, G. Limes, S. Chessin, S. Kong, R. Y ung, and others at Sun Micr osystems Inc. for their r ole in design of the page table and TLB for UltraSP ARC; P.
Reference: [Tall94] <author> Madhusudhan Talluri and Mark D. Hill. </author> <title> Surpassing the TLB performance of Superpages with Less Operating System Support. </title> <booktitle> In Proc. of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 171182, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Hardware designers ar e incr easing the ef fective-ness of TLBs for 64-bit systems using techniques such as superpages [Tall92] and subblocking <ref> [Kane92, Tall94] </ref>. These techniques ar e very ef fective at improving TLB performance, r educing the number of TLB misses by 50% to 99%, and pr oviding an average execution time speedup of upto 20% for the workloads we use [T all95]. <p> W ith 64-bit addr ess-es, har dware designers ar e incr easing the ef fective-ness of TLBs with support for superpages [T all92] and subblocking <ref> [Tall94] </ref>. <p> as conventional paging, have sizes that must be power - oftwo multiples of the base page size , and must be a li g ne d in b ot h v i r t u al a nd p h ys i c a l m e m or y <ref> [Tall94] </ref>. Many pr ocessors now support superpages, e.g., MIPS [Kane92], UltraSP ARC [Yung95], Alpha [Site93], PowerPC [Silh93] etc. Supporting superpag-es is easier than supporting segments, which use a two-dimensional addr ess space, may be arbitrarily long, and may start at arbitrary physical addr esses [Orga72]. <p> Medium superpages, e.g., 16KB or 64KB, r equire mor e substantial operating system changes to pr ovide the mechanisms to support them and the policies for choosing appr opriate page sizes <ref> [Tall94, Khal93, Rome95] </ref>. Subblocking associates multiple PPNs with each TLB tag [Tall94]. With a subblock factor of sixteen and 4KB pages, for example, each tag covers an aligned 64KB block of (virtual) addr esses. The MIPS R4X00 [Kane92] processors support a subblock factor of two in the TLB. <p> Medium superpages, e.g., 16KB or 64KB, r equire mor e substantial operating system changes to pr ovide the mechanisms to support them and the policies for choosing appr opriate page sizes [Tall94, Khal93, Rome95]. Subblocking associates multiple PPNs with each TLB tag <ref> [Tall94] </ref>. With a subblock factor of sixteen and 4KB pages, for example, each tag covers an aligned 64KB block of (virtual) addr esses. The MIPS R4X00 [Kane92] processors support a subblock factor of two in the TLB. <p> Pages not properly placed use multiple TLB entries. W e call this TLB design partialsubblocking 1 , and use complete subblocking to r efer to the f irst subblock design <ref> [Tall94] </ref>. A partialsubblock TLB entry is like a super-page TLB entry but allows a subset of the base page mappings to be validspecified by a valid bit vector (bottom of Figur e 6). <p> Superpages and partialsubblocking ar e ef fective only when operating systems often pr operly place virtual pages in physical memory. We have proposed one algorithm, page r eservation, that is described in <ref> [Tall94, Tall95] </ref>. Superpages and partialsubblocking also r equire support fr om the page table to stor e such mappings and in the TLB miss handler to traverse such page tables. <p> Second, partialsubblock PTEs reduce page table size mor e ef fectively than super-pages (Figur e 10). Thir d, partialsubblocking r e-quires s impler operating sys tem support than superpages <ref> [Tall94] </ref>. Fourth, a partialsubblock PTE is a natural intermediate format for page tables that construct superpage PTEs in an incr emental fashion. The disadvantage is that lar ge subblock factors, e.g., 32 or larger, are not practical due to the limited number of valid bits in a PTE.
Reference: [Tall95] <author> Madhusudhan Talluri. </author> <title> Use of Superpages and Subblocking in the Address Translation Hierarchy. </title> <type> Ph.D. thesis, </type> <institution> University of Wisconsin-Madison Computer Sciences, </institution> <month> August </month> <year> 1995. </year> <type> Technical Report #1277. </type>
Reference-contexts: The innovations we develop for hashed page tables ar e applicable to inverted page tables or software TLBs also. Due to space constraints, in this paper we only describe hashed page tables. Inverted page tables and softwar e TLB variations ar e described in <ref> [Tall95] </ref>. Multilevel linear page tables and forwar d-mapped page tables ar e both nary tr ees with some important dif ferences. <p> , to support addr ess spaces with varying degr ee of sparseness, cluster ed page tables generalize to include PTEs with varying subblock factors with only a small incr ease in page table access time (a few extra instr uctions in the TLB miss handler) but with better memory utilization <ref> [Tall95] </ref>. Clustered page tables stor e mappings for multiple base pages in a single PTE. This r educes the number of PTEs in the page table and r esults in shorter hash table lists, a hash table with fewer buckets, or both. <p> Ther e ar e two potential advantages of adding such support. First, using the new TLBs r educes the number of TLB misses by 50% to 99% and pr ovides an average execution time speedup of upto 20% for the workloads we use <ref> [Tall95] </ref>. Second, superpage and partialsubblock PTEs (described below) stor e mapping information more compactly than conventional PTEs, thus decreasing page table memory usage. <p> Superpages and partialsubblocking ar e ef fective only when operating systems often pr operly place virtual pages in physical memory. We have proposed one algorithm, page r eservation, that is described in <ref> [Tall94, Tall95] </ref>. Superpages and partialsubblocking also r equire support fr om the page table to stor e such mappings and in the TLB miss handler to traverse such page tables. <p> A partialsubblock PTE r esides in a page table exactly wher e a corresponding super-page PTE would have r esided. Page blocks that cannot use partialsubblock PTEs use base page PTEs. More complex optimizations are possible <ref> [Tall95] </ref>. The extensions described in Section 4.2 for super-page PTEs ar e mostly applicable to storing partial-subblock PTEs also. <p> S u b b l oc k prefetching never pollutes the TLB by r eplacing more useful mappings, because it never causes extra replacements [Hill87], but r educes the number of TLB misses significantly50% or more <ref> [Tall95] </ref>. A drawback of subblock pr efetching is the increased time to service TLB block misses. This penalty is lar ge for hashed page tables, because multiple hash pr obes ar e needed. <p> This support also requires that the TLB miss handler continue searching the hash chain after a tag match that fails to find a valid mapping <ref> [Tall95] </ref>. Larger superpages can be supported in at least two ways. First, one can use the Replicate PTEs solution, but r eplicate once per cluster ed PTE instead of once per base page PTE. <p> It is also straightforward to support both superpages and partialsub-blocking in the same clustered page table <ref> [Tall95] </ref>. 6 Performance Evaluation This section pr esents simulated performance r e-sults for the page tables discussed so far. We use estimates of page table size and page table access time (the TLB miss penalty) as metrics. <p> We also use a physical memory allocation algorithm, page r eservation, that allocates aligned physical pages for virtual pages (detailed description is available in [T all94] and <ref> [Tall95] </ref>). This memory allocation makes partialsub-block TLBs ef fective and makes superpage cr eation efficient. Second, we added a mechanism to trap on TLB misses (trap-driven simulation). <p> W e assume a 256-byte (level-two) cache line size for accessing page tables. W e assume 4096 hash buckets in hashed and cluster ed page tables. We also discuss sensitivity analysis for these assumptions, but space limitations prevent a full presentation <ref> [Tall95] </ref>. We first study page table size. Page table size has significant affect on cache behavior , even when page tables ar e much smaller than available physical memory (i.e., when their af fect on page faults is negligible). <p> Not shown is that use of superpages r educes TLB miss fr equency by 50% to 99% <ref> [Tall95] </ref>, which is the main r eason for supporting superpage PTEs in the page table. What is shown is the number of cache lines accessed by the r emain-ing misses. <p> Second, constr ucting hashed or cluster ed page tables as a software TLB can reduce the number of cache lines accessed. W e describe how cluster ed page table techniques can be applied to softwar e TLBs in <ref> [Tall95] </ref>. A disadvantage of hashed and clustered page tables is the unpr edictability of the hash table distribution that depends on the state of the current set of active pr ocesses.
Reference: [Thak86] <author> Shreekant S. Thakkar and Alan E. Knowles. </author> <title> A High-Performance Memory Management Scheme. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 822, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: They ar e sonamed, because they can be viewed as memory-r esident level-two TLBs with overflow handled in many ways <ref> [Agar88, Silh93, Thak86] </ref>. The innovations we develop for hashed page tables ar e applicable to inverted page tables or software TLBs also. Due to space constraints, in this paper we only describe hashed page tables. Inverted page tables and softwar e TLB variations ar e described in [Tall95].
Reference: [Thom74] <author> K. Thompson and D. M. Ritchie. </author> <title> The UNIX Time-Sharing System. </title> <journal> Communications of the ACM, </journal> <volume> 17(7):365375, </volume> <month> July </month> <year> 1974. </year>
Reference-contexts: The exibility and ef fi-ciency of implementing operating system page table algorithms (Section 3.1) then becomes the overriding factor in choosing a page table structure. A typical multipr ogramming operating system, e.g., UNIX <ref> [Thom74] </ref>, maintains one page table per process or associates a pr ocess id with each PTE in a shared page table.
Reference: [Yoo93] <author> Hyuck Yoo and Tom Rogers. </author> <title> UNIX Kernel Support for OLTP Performance. </title> <booktitle> In 1993 Winter USENIX Conference, </booktitle> <pages> pages 241247, </pages> <month> January </month> <year> 1993. </year>
Reference: [Yung95] <author> Robert Yung. </author> <title> UltraSPARC-I (Spitfire) Architecture. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: Many processors now support TLB miss handling in software, e.g., MIPS [Kane92], Alpha [Site93], UltraS-PARC <ref> [Yung95] </ref>. This makes page table design an operating system issue and in this paper we explor e alternate operating system data structures for storing page tables and servicing TLB misses. Section 3 intr oduces the central contribution of this paper: the clustered page table. <p> Variations on hashed tables include inverted page tables and softwar e TLBs. Inverted page tables , e.g., in IBM System/38 [IBM78], hash to an array of pointers that when der eferenced obtain the f irst element of the hash bucket. Software TLBs (e.g., swTLB [Huck93], TSB <ref> [Yung95] </ref>, STLB [Bala94], PowerPCs page table [Silh93]) eliminate a hashed page tables next pointers by pr e-allocating a f ixed number of PTEs per bucket. They ar e sonamed, because they can be viewed as memory-r esident level-two TLBs with overflow handled in many ways [Agar88, Silh93, Thak86]. <p> Many pr ocessors now support superpages, e.g., MIPS [Kane92], UltraSP ARC <ref> [Yung95] </ref>, Alpha [Site93], PowerPC [Silh93] etc. Supporting superpag-es is easier than supporting segments, which use a two-dimensional addr ess space, may be arbitrarily long, and may start at arbitrary physical addr esses [Orga72].
References-found: 45

