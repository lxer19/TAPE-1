URL: http://www.cs.nmsu.edu/lldap/jicslp98/p1.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp98/accepted.html
Root-URL: http://www.cs.nmsu.edu
Email: E-mail: Pierre-Etienne.Moreau@loria.fr  
Title: A choice-point library for backtrack programming  
Author: Pierre-Etienne Moreau 
Address: BP 239 54506 Vandoeuvre-les-Nancy Cedex, France  
Affiliation: LORIA-CNRS INRIA-Lorraine  
Abstract: Implementing a compiler for a language with nondeterministic features is known to be a difficult task. This paper presents two new functions setChoicePoint and fail that extend the C language to efficiently handle choice point management. Originally, these two functions were designed to compile the ELAN strategy language. However, they can be used by programmers for general programming in C. We illustrate their use by presenting the classical 8-queens problem and giving some experimental results. Algorithms and implementation techniques are sufficiently detailed to be easily modified and re-implemented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Ait-Kaci. </author> <title> The WAM: a (real) tutorial. </title> <type> Technical report 5, </type> <institution> Digital Systems Research Center, Paris (France), </institution> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Our method preserves the efficiency of deterministic computations and is of more general interest; it could be used in implementations of constraint solvers, imperative languages with backtracking such as Alma-0 [14, 2], the WAM <ref> [18, 1] </ref> and Prolog-like languages. A first implementation of our techniques has been done by Marian Vittek in 1996. The experimental results, presented in [16], show that nondeterministic rewriting can be implemented as efficiently as the best current implementations of functional and logic programming languages.
Reference: [2] <author> K. R. Apt and A. Schaerf. </author> <title> Search and imperative programming. </title> <booktitle> In 24th POPL, </booktitle> <pages> pages 67-79, </pages> <year> 1997. </year>
Reference-contexts: In this paper we present a new technique for compiling the specific control flow in programs during the backtracking. Our method preserves the efficiency of deterministic computations and is of more general interest; it could be used in implementations of constraint solvers, imperative languages with backtracking such as Alma-0 <ref> [14, 2] </ref>, the WAM [18, 1] and Prolog-like languages. A first implementation of our techniques has been done by Marian Vittek in 1996. The experimental results, presented in [16], show that nondeterministic rewriting can be implemented as efficiently as the best current implementations of functional and logic programming languages. <p> Therefore, our approach is not less portable than classical implementations of choice point managements. 5 Imperative programming with backtracking Several languages such as 2LP [11] and Alma-0 <ref> [14, 2] </ref> have been developed to combine advantages of logic and imperative programming in order to deal in a natural way with algorithmic problems that involve search. Alma-0 extends imperative programming with some features inspired by the logic programming paradigm.
Reference: [3] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18 </volume> <pages> 807-820, </pages> <year> 1988. </year> <month> 12 </month>
Reference-contexts: In average, only a small part of the system stack needs to be changed when a failure occurs. For example, let us consider the following program, where dots denote irrelevant instructions: 1 a similar idea is used in the BDW Garbage Collector <ref> [3] </ref> 4 void main () - ... ... fail (); ... void g (int arg) - ... setChoicePoint (); ... An execution of the main function creates the stack frame of main in the system stack. Then main calls g, this pushes the stack frame of g onto the stack.
Reference: [4] <author> P. Borovansky, C. Kirchner, H. Kirchner, P.-E. Moreau, and M. Vittek. </author> <title> ELAN: A logical framework based on computational systems. </title> <editor> In J. Meseguer, editor, </editor> <booktitle> Proceedings of the first international workshop on rewriting logic, volume 4 of Electronic Notes in TCS, </booktitle> <address> Asilomar (California), </address> <month> Sept. </month> <year> 1996. </year>
Reference: [5] <author> T. Budd. </author> <title> An implementation of generators in C. </title> <journal> Computer Languages, </journal> <volume> 7 </volume> <pages> 69-87, </pages> <year> 1982. </year>
Reference-contexts: A number of techniques for implementing branching schemes have been proposed over the years, especially in the functional and logic programming communities. Several languages use C as target language such as Cg, Icon, Janus, Erlang, KL1, and Mercury. Their different compilation schemes are presented in <ref> [5, 17, 8, 7, 10] </ref>. Among these techniques, the simplest method implements branching using a C goto statement. However problems arise because indirect branching is not available in standard C and also because a goto instruction can only do a jump into its function scope.
Reference: [6] <author> Y. Caseau and F. Laburthe. </author> <title> Introduction to the CLAIRE programming language. </title> <type> Technical report 96-15, LIENS Technical, </type> <month> September </month> <year> 1996. </year>
Reference-contexts: The second one to backtrack to the last created choice point and restore the saved environment. Many languages that offer nondeterministic capabilities provide similar functions: for instance world+ and world- in Claire <ref> [6] </ref>, try and retry in the WAM, onfail, fail, createlog and replaylog in the Alma-0 Abstract Machine [14], setChoicePoint and fail in ELAN [16]. Recently, a new approach to the implementation of tabling for prolog [9] has been proposed.
Reference: [7] <author> P. Codognet and D. Diaz. </author> <title> wamcc : Compiling Prolog to C. </title> <booktitle> In Proceedings of International Conference on Logic Programming, </booktitle> <address> Tokyo, Japan, 1995. </address> <publisher> The MIT press. </publisher>
Reference-contexts: A number of techniques for implementing branching schemes have been proposed over the years, especially in the functional and logic programming communities. Several languages use C as target language such as Cg, Icon, Janus, Erlang, KL1, and Mercury. Their different compilation schemes are presented in <ref> [5, 17, 8, 7, 10] </ref>. Among these techniques, the simplest method implements branching using a C goto statement. However problems arise because indirect branching is not available in standard C and also because a goto instruction can only do a jump into its function scope.
Reference: [8] <author> B. Demoen and G. Maris. </author> <title> A comparison of some schemes for translating logic to C. </title> <booktitle> In Workshop on Implementations of the 11th International Conference of Logic Programming, </booktitle> <address> Santa Margherita, Italy, 1994. </address> <publisher> MIT Press. </publisher>
Reference-contexts: A number of techniques for implementing branching schemes have been proposed over the years, especially in the functional and logic programming communities. Several languages use C as target language such as Cg, Icon, Janus, Erlang, KL1, and Mercury. Their different compilation schemes are presented in <ref> [5, 17, 8, 7, 10] </ref>. Among these techniques, the simplest method implements branching using a C goto statement. However problems arise because indirect branching is not available in standard C and also because a goto instruction can only do a jump into its function scope.
Reference: [9] <author> B. Demoen and K. Sagonas. </author> <title> CAT: the Copying Approach to Tabling. </title> <type> Personal Communication, </type> <year> 1998. </year>
Reference-contexts: Recently, a new approach to the implementation of tabling for prolog <ref> [9] </ref> has been proposed. The authors suggest to extend a prolog implementation by adding some new built-in predicates. For their purpose, a similar idea as the one presented here has been explored in a different context.
Reference: [10] <author> F. Henderson, T. Conway, and Z. Somogyi. </author> <title> The execution algorithm of Mercury, an efficient purely declarative logic programming language. </title> <journal> Journal of Logic Programming, </journal> <volume> 29 </volume> <pages> 17-54, </pages> <month> October-December </month> <year> 1996. </year>
Reference-contexts: A number of techniques for implementing branching schemes have been proposed over the years, especially in the functional and logic programming communities. Several languages use C as target language such as Cg, Icon, Janus, Erlang, KL1, and Mercury. Their different compilation schemes are presented in <ref> [5, 17, 8, 7, 10] </ref>. Among these techniques, the simplest method implements branching using a C goto statement. However problems arise because indirect branching is not available in standard C and also because a goto instruction can only do a jump into its function scope.
Reference: [11] <author> K. McAloon and C. Tretkoff. 2LP: </author> <title> Linear programming and logic programming. </title> <editor> In P. Hen-tenryck and V. Saraswat, editors, </editor> <booktitle> Principles and Practice of Constraint Programming, </booktitle> <pages> pages 101-116. </pages> <publisher> The MIT press, </publisher> <year> 1995. </year>
Reference-contexts: Therefore, our approach is not less portable than classical implementations of choice point managements. 5 Imperative programming with backtracking Several languages such as 2LP <ref> [11] </ref> and Alma-0 [14, 2] have been developed to combine advantages of logic and imperative programming in order to deal in a natural way with algorithmic problems that involve search. Alma-0 extends imperative programming with some features inspired by the logic programming paradigm.
Reference: [12] <author> J. Meseguer. </author> <title> Conditional rewriting logic as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96(1) </volume> <pages> 73-155, </pages> <year> 1992. </year>
Reference-contexts: In this context we are interested in nondeterministic computation and deduction. Term rewriting is nondeterministic in the sense that there may be several reductions starting from one initial term and producing different results. Rewriting logic <ref> [12] </ref> gives a logical background and raises new interesting problems concerning the efficient implementation of nondeterministic rewriting which needs backtracking. This is similar to the implementation of logic programming languages, but a significant difference is the fact that rewriting rules can be applied inside the terms.
Reference: [13] <author> P.-E. Moreau. </author> <title> Compiling nondeterministic computations. </title> <type> Technical Report 98-R-005, </type> <institution> CRIN, </institution> <year> 1998. </year>
Reference-contexts: This is a good alternative to avoid using an abstract machine and to get interesting performances. The two functions were originally designed to compile the ELAN language. Some examples of compilation schemes are given in <ref> [13] </ref> (see appendix A). Their "plug-in" designs make them easy to use: conventional programming techniques such as function calls, local variables, parameters passing, modular compilation are compatible with the proposed C language extension.
Reference: [14] <author> V. Partington. </author> <title> Implementation of an Imperative Programming Language with Backtracking. </title> <type> Technical Report P9714, </type> <institution> University of Amsterdam, Programming Research Group, </institution> <year> 1997. </year> <note> Available by anonymous ftp from ftp.wins.uva.nl, file pub/programming-research/reports/1997/P9712.ps.Z. </note>
Reference-contexts: In this paper we present a new technique for compiling the specific control flow in programs during the backtracking. Our method preserves the efficiency of deterministic computations and is of more general interest; it could be used in implementations of constraint solvers, imperative languages with backtracking such as Alma-0 <ref> [14, 2] </ref>, the WAM [18, 1] and Prolog-like languages. A first implementation of our techniques has been done by Marian Vittek in 1996. The experimental results, presented in [16], show that nondeterministic rewriting can be implemented as efficiently as the best current implementations of functional and logic programming languages. <p> The second one to backtrack to the last created choice point and restore the saved environment. Many languages that offer nondeterministic capabilities provide similar functions: for instance world+ and world- in Claire [6], try and retry in the WAM, onfail, fail, createlog and replaylog in the Alma-0 Abstract Machine <ref> [14] </ref>, setChoicePoint and fail in ELAN [16]. Recently, a new approach to the implementation of tabling for prolog [9] has been proposed. The authors suggest to extend a prolog implementation by adding some new built-in predicates. <p> Therefore, our approach is not less portable than classical implementations of choice point managements. 5 Imperative programming with backtracking Several languages such as 2LP [11] and Alma-0 <ref> [14, 2] </ref> have been developed to combine advantages of logic and imperative programming in order to deal in a natural way with algorithmic problems that involve search. Alma-0 extends imperative programming with some features inspired by the logic programming paradigm.
Reference: [15] <author> R. Stallman. </author> <title> Using and porting the GNU CC compiler, </title> <year> 1995. </year>
Reference-contexts: Consequently, this method is not the most optimised one but is suited for standard C and separate compilation. A third well-known existing scheme consists in using non standard C features that are supported by the GNU C compiler <ref> [15] </ref>. The gcc compiler makes it possible to take the address of labels, and later on to jump to those addresses. It also offers the possibility to insert inline assembly code, and to specify the assembly name of a function.
Reference: [16] <author> M. Vittek. </author> <title> A compiler for nondeterministic term rewriting systems. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of RTA'96, volume 1103 of Lecture Notes in Computer Science, </booktitle> <pages> pages 154-168, </pages> <address> New Brunswick (New Jersey), July 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A first implementation of our techniques has been done by Marian Vittek in 1996. The experimental results, presented in <ref> [16] </ref>, show that nondeterministic rewriting can be implemented as efficiently as the best current implementations of functional and logic programming languages. This paper presents a formalisation of the implementation and gives detailed algorithms to re-use, adapt and improve the proposed method. <p> Many languages that offer nondeterministic capabilities provide similar functions: for instance world+ and world- in Claire [6], try and retry in the WAM, onfail, fail, createlog and replaylog in the Alma-0 Abstract Machine [14], setChoicePoint and fail in ELAN <ref> [16] </ref>. Recently, a new approach to the implementation of tabling for prolog [9] has been proposed. The authors suggest to extend a prolog implementation by adding some new built-in predicates. For their purpose, a similar idea as the one presented here has been explored in a different context.
Reference: [17] <author> S. Wampler and R. Griswold. </author> <title> The implementation of generators and Goal-Directed Evaluation in Icon. </title> <journal> Software-Practice and Experience, </journal> <volume> 13 </volume> <pages> 495-518, </pages> <year> 1983. </year>
Reference-contexts: A number of techniques for implementing branching schemes have been proposed over the years, especially in the functional and logic programming communities. Several languages use C as target language such as Cg, Icon, Janus, Erlang, KL1, and Mercury. Their different compilation schemes are presented in <ref> [5, 17, 8, 7, 10] </ref>. Among these techniques, the simplest method implements branching using a C goto statement. However problems arise because indirect branching is not available in standard C and also because a goto instruction can only do a jump into its function scope.
Reference: [18] <author> D. H. D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical Report 309, </type> <institution> SRI International, Artificial Intelligence Center, </institution> <year> 1983. </year> <month> 13 </month>
Reference-contexts: Our method preserves the efficiency of deterministic computations and is of more general interest; it could be used in implementations of constraint solvers, imperative languages with backtracking such as Alma-0 [14, 2], the WAM <ref> [18, 1] </ref> and Prolog-like languages. A first implementation of our techniques has been done by Marian Vittek in 1996. The experimental results, presented in [16], show that nondeterministic rewriting can be implemented as efficiently as the best current implementations of functional and logic programming languages.
References-found: 18

