URL: http://cag-www.lcs.mit.edu/~saman/papers/siam95a.ps
Refering-URL: http://cag-www.lcs.mit.edu/~saman/cv.html
Root-URL: 
Title: Chapter 1: Interprocedural Parallelization Analysis: A Case Study  
Author: Mary W. Hall Brian R. Murphy Saman P. Amarasinghe 
Abstract: We present an overview of our interprocedural analysis system, which applies the program analysis required for parallelization across procedure boundaries. We discuss the issues we addressed to efficiently obtain precise results in the interprocedural setting. We present the analysis required for parallelization, illustrated with an excerpt from a Fortran benchmark program. By integrating a comprehensive suite of interprocedural analyses, we have built a system that is much more effective at locating parallelism in scientific benchmarks than earlier interprocedural systems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. W. Hall, J. Mellor-Crummey, A. Carle, and R. Rodriguez. FIAT: </author> <title> A framework for interprocedural analysis and transformation. </title> <booktitle> In Proceedings of the Sixth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: The final section highlights results we have gathered with this system. 2 Interprocedural Framework Interprocedural parallelization depends upon the solution of a large number of interproce-dural data-flow analysis problems. These problems share many commonalities. We have encapsulated these common features in a tool, Fiat <ref> [1] </ref>, which we have combined with the Stanford SUIF compiler to constitute our interprocedural parallelization system. Fiat is an interprocedural framework, analogous to traditional data-flow analysis frameworks [4].
Reference: [2] <author> P. Havlak and K. Kennedy. </author> <title> An implementation of interprocedural bounded regular section analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 2(3) </volume> <pages> 350-360, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Some studies of earlier interprocedural systems have shown reasonable success on linear algebra libraries <ref> [2, 3, 5, 6] </ref>, but the results on larger programs have been much less promising [3]. Our system has been significantly more effective at locating parallel loops in full scientific applications, because it integrates a comprehensive suite of interprocedural analyses.
Reference: [3] <author> M. Hind, P. Carini, M. Burke, and S. Midkiff. </author> <title> Interprocedural array analysis: how much precision do we need? In Proceedings of the 3rd Workshop on Compilers for Parallel Computers, vol. </title> <type> 2, </type> <institution> University of Vienna, Austria, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Some studies of earlier interprocedural systems have shown reasonable success on linear algebra libraries <ref> [2, 3, 5, 6] </ref>, but the results on larger programs have been much less promising [3]. Our system has been significantly more effective at locating parallel loops in full scientific applications, because it integrates a comprehensive suite of interprocedural analyses. <p> Some studies of earlier interprocedural systems have shown reasonable success on linear algebra libraries [2, 3, 5, 6], but the results on larger programs have been much less promising <ref> [3] </ref>. Our system has been significantly more effective at locating parallel loops in full scientific applications, because it integrates a comprehensive suite of interprocedural analyses. As we showed with spec77, a combination of analyses is often required in order to parallelize an outer, coarse-grain loop.
Reference: [4] <author> J. Kam and J. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23(1) </volume> <pages> 159-171, </pages> <month> January </month> <year> 1976. </year>
Reference-contexts: These problems share many commonalities. We have encapsulated these common features in a tool, Fiat [1], which we have combined with the Stanford SUIF compiler to constitute our interprocedural parallelization system. Fiat is an interprocedural framework, analogous to traditional data-flow analysis frameworks <ref> [4] </ref>. A framework is even more important for interprocedural optimization because of the complexity of collecting and managing information about all the procedures in a program.
Reference: [5] <author> Z. Li and P. Yew. </author> <title> Efficient interprocedural analysis for program restructuring for parallel programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Parallel Programming: Experience with Applications, Languages, and Systems (PPEALS), </booktitle> <address> New Haven, CT, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: Some studies of earlier interprocedural systems have shown reasonable success on linear algebra libraries <ref> [2, 3, 5, 6] </ref>, but the results on larger programs have been much less promising [3]. Our system has been significantly more effective at locating parallel loops in full scientific applications, because it integrates a comprehensive suite of interprocedural analyses.
Reference: [6] <author> R. Triolet, F. Irigoin, and P. Feautrier. </author> <title> Direct parallelization of call statements. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, SIGPLAN Notices 21(7), </booktitle> <pages> pages 176-185. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1986. </year>
Reference-contexts: Some studies of earlier interprocedural systems have shown reasonable success on linear algebra libraries <ref> [2, 3, 5, 6] </ref>, but the results on larger programs have been much less promising [3]. Our system has been significantly more effective at locating parallel loops in full scientific applications, because it integrates a comprehensive suite of interprocedural analyses.
References-found: 6

