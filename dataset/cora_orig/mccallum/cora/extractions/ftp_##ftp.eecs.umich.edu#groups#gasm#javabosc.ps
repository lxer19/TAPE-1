URL: ftp://ftp.eecs.umich.edu/groups/gasm/javabosc.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: boerger@di.unipi.it  wolfram@informatik.uni-ulm.de  
Phone: 2  
Title: A Programmer Friendly Modular Definition of the Semantics of Java  
Author: Egon Borger and Wolfram Schulte 
Address: I-56125 Pisa, Italy  D-89069 Ulm, Germany  
Affiliation: 1 Universita di Pisa, Dipartimento di Informatica,  Universitat Ulm, Fakultat fur Informatik,  
Abstract: We propose in this paper a definition of the semantics of Java programs which can be used as a basis for the standardization of the language and of its implementation on the Java Virtual Machine. The definition provides a machine and system independent view of the language as it is seen by the Java programmer. It takes care to directly reflect the description in the Java language reference manual so that the basic design decisions can be checked by standardizers and implementors against a mathematical model. Our definition is the basis for a related definition we give in a sequel to this paper for the implementation of Java on the Java Virtual Machine as described in the language and in the Virtual Machine reference manuals.
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> J. Alves-Foss, editor. </editor> <title> Formal Syntax and Semantics of Java(tm). </title> <note> Springer LNCS, to appear. </note> <year> 1998. </year>
Reference-contexts: ideas of Java's LRM into a transparent but rigorous form, whose adequacy can be recognized (or falsified in the sense of Popper [30]) by inspection, i.e., by a direct comparison of the mathematical definitions with the verbal descriptions in the manual (see the discussion on ? This paper appears in <ref> [1] </ref>. A preliminary version of this paper has been presented to the IFIP WG 2.2 Meeting in Graz (22.-26.9.1997) and to the Workshop on Pro gramming Languages in Avendorf/Fehmarn (24.-26.9.1997) [13]. ground models in [3]).
Reference: 2. <author> G. Bella and E. Riccobene. </author> <title> Formal analysis of the Kerberos authentification system. </title> <journal> Journal of Universal Computer Science (J.UCS), </journal> <year> 1997. </year>
Reference-contexts: A preliminary version of this paper has been presented to the IFIP WG 2.2 Meeting in Graz <ref> (22.-26.9.1997) </ref> and to the Workshop on Pro gramming Languages in Avendorf/Fehmarn (24.-26.9.1997) [13]. ground models in [3]). <p> A preliminary version of this paper has been presented to the IFIP WG 2.2 Meeting in Graz (22.-26.9.1997) and to the Workshop on Pro gramming Languages in Avendorf/Fehmarn <ref> (24.-26.9.1997) </ref> [13]. ground models in [3]). <p> ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam [7, 6], VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols <ref> [22, 2] </ref>, control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey.
Reference: 3. <author> E. Borger. </author> <title> Why use evolving algebras for hardware and software engineering. </title> <booktitle> In SOFSEM'95 22nd Seminar on Current Trends in Theory and Practice of Infor-matics, </booktitle> <publisher> Springer LNCS 1012, </publisher> <year> 1995. </year>
Reference-contexts: A preliminary version of this paper has been presented to the IFIP WG 2.2 Meeting in Graz (22.-26.9.1997) and to the Workshop on Pro gramming Languages in Avendorf/Fehmarn (24.-26.9.1997) [13]. ground models in <ref> [3] </ref>). <p> Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See <ref> [3] </ref> for a survey. ASMs have a simple mathematical foundation [21], which justifies their intuitive understanding as "pseudo-code over abstract data" so that the practitioner can use them correctly and successfully without having to go through any special formal training.
Reference: 4. <author> E. Borger, C. Beierle, I. Durdanovic, U. Glasser, and E. Riccobene. </author> <title> Refining abstract machine specifications of the steam boiler control to well documented executable code. In Formal Methods for Industrial Applications. Specifying and Programming the Steam-Boiler Control, </title> <publisher> Springer LNCS State-of-the-Art Survey 1165, </publisher> <year> 1996. </year>
Reference-contexts: ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam [7, 6], VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software <ref> [4, 10] </ref>, and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey.
Reference: 5. <author> E. Borger and G. Del Castillo. </author> <title> A formal method for provably correct composition of a real-life processor out of basic components (the APE100 reverse engineering project). </title> <booktitle> In Proc. First IEEE International Conference on Engineering of Complex Computer Systems (ICECCS'95). </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year>
Reference-contexts: ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam [7, 6], VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures <ref> [5, 9] </ref>, protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey.
Reference: 6. <author> E. Borger and I. Durdanovic. </author> <title> Correctness of compiling Occam to transputer code. </title> <journal> The Computer Journal, </journal> <volume> 39, </volume> <year> 1996. </year>
Reference-contexts: Gurevich's Abstract State Machines (ASMs), previously called Evolving Algebras, see [21], provide the fundamental concept for such a modeling technique. ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam <ref> [7, 6] </ref>, VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey. <p> The ASMs we are developing for the JVM provide the basis for a rigorous mathematical analysis of general compilation schemes of Java programs into JVM code including correctness proofs as developed for the implementation for Prolog on the WAM [12] (see also [33]) and of Occam on the Transputer <ref> [6] </ref>.
Reference: 7. <author> E. Borger, I. Durdanovic, and D.Rosenzweig. </author> <title> Occam: Specification and compiler correctness. Part I: Simple mathematical interpreters. </title> <editor> In E.-R. Olderog, editor, </editor> <booktitle> Proc. PROCOMET'94 (IFIP Working Conference on Programming Concepts, Methods and Calculi), </booktitle> <year> 1994. </year>
Reference-contexts: Gurevich's Abstract State Machines (ASMs), previously called Evolving Algebras, see [21], provide the fundamental concept for such a modeling technique. ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam <ref> [7, 6] </ref>, VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey. <p> To separate as much as possible the dynamic (run-time) aspects from the static aspects the compiler (parsing and elaboration) can take care of, we use the idea (which is taken from the work on Occam <ref> [7] </ref>) to view program execution by a thread as a walk of the thread through the program's annotated abstract syntax tree: at each node the corresponding task is executed and then the control flow proceeds to the next task.
Reference: 8. <author> E. Borger, U. Glasser, and W. Muller. </author> <title> Formal definition of an abstract VHDL'93 simulator by EA-machines. </title> <editor> In C. Delgado Kloos and P.T. Breuer, editors, </editor> <title> Formal Semantics for VHDL. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: Gurevich's Abstract State Machines (ASMs), previously called Evolving Algebras, see [21], provide the fundamental concept for such a modeling technique. ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam [7, 6], VHDL <ref> [8] </ref>, C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey.
Reference: 9. <author> E. Borger and S. Mazzanti. </author> <title> A practical method for rigorously controllable hardware design. In ZUM'97: The Z Formal Specification Notation, </title> <publisher> Springer LNCS 1212, </publisher> <year> 1997. </year>
Reference-contexts: A preliminary version of this paper has been presented to the IFIP WG 2.2 Meeting in Graz <ref> (22.-26.9.1997) </ref> and to the Workshop on Pro gramming Languages in Avendorf/Fehmarn (24.-26.9.1997) [13]. ground models in [3]). <p> A preliminary version of this paper has been presented to the IFIP WG 2.2 Meeting in Graz (22.-26.9.1997) and to the Workshop on Pro gramming Languages in Avendorf/Fehmarn <ref> (24.-26.9.1997) </ref> [13]. ground models in [3]). <p> ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam [7, 6], VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures <ref> [5, 9] </ref>, protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey.
Reference: 10. <author> E. Borger and L. Mearelli. </author> <title> Integrating ASMs into the software development life-cycle. </title> <journal> Journal of Universal Computer Science, Special ASM Issue, </journal> <volume> 3.5, </volume> <year> 1997. </year>
Reference-contexts: ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam [7, 6], VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software <ref> [4, 10] </ref>, and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey.
Reference: 11. <author> E. Borger and D. Rosenzweig. </author> <title> A mathematical definition of full Prolog. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 24, </volume> <year> 1995. </year>
Reference-contexts: Gurevich's Abstract State Machines (ASMs), previously called Evolving Algebras, see [21], provide the fundamental concept for such a modeling technique. ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog <ref> [11, 12] </ref>, Occam [7, 6], VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey. <p> The model can be used for standardization purposes along the lines the ASM model for Prolog <ref> [11] </ref> has been used for defining the ISO standard for the semantics of Prolog.
Reference: 12. <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <editor> In L.Plumer C.Beierle, editor, </editor> <title> Logic Programming: Formal Methods and Practical Applications. </title> <publisher> Elsevier Science B.V./North-Holland, </publisher> <year> 1995. </year>
Reference-contexts: Gurevich's Abstract State Machines (ASMs), previously called Evolving Algebras, see [21], provide the fundamental concept for such a modeling technique. ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog <ref> [11, 12] </ref>, Occam [7, 6], VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey. <p> The ASMs we are developing for the JVM provide the basis for a rigorous mathematical analysis of general compilation schemes of Java programs into JVM code including correctness proofs as developed for the implementation for Prolog on the WAM <ref> [12] </ref> (see also [33]) and of Occam on the Transputer [6].
Reference: 13. <author> E. Borger and W. Schulte. </author> <title> A programmer friendly modular definition of the semantics of Java. </title> <editor> In R. Berghammer and F. Simon, editors, </editor> <title> Programming Languages and Fundamentals of Programming. </title> <type> Technical report, </type> <institution> Christian Albrechts Univer-sitat Kiel, Institut fur Informatik und Praktische Mathematik, </institution> <year> 1997. </year> <month> 43 </month>
Reference-contexts: A preliminary version of this paper has been presented to the IFIP WG 2.2 Meeting in Graz (22.-26.9.1997) and to the Workshop on Pro gramming Languages in Avendorf/Fehmarn (24.-26.9.1997) <ref> [13] </ref>. ground models in [3]).
Reference: 14. <author> E. Borger and W. Schulte. </author> <title> Defining the Java Virtual Machine as platform for prov-ably correct Java compilation. </title> <editor> In J. Gruska, editor, </editor> <booktitle> 23rd International Symposium on Mathematical Foundations of Computer Science, </booktitle> <address> Brno, Czech Republic, </address> <month> August 24-28, </month> <year> 1998, </year> <note> Springer LNCS, to appear, </note> <year> 1998. </year>
Reference-contexts: A comparison of these two models illustrates the high degree of freedom ASMs offer to tune a mathematical model to its intended use. We are working on refinements of our Java model to the level of abstraction of the Java Virtual machine <ref> [14] </ref>. These refinements take advantage of the modular specification of orthogonal Java features as they appear in our models.
Reference: 15. <author> E. Borger and W. Schulte. </author> <title> A modular design for the Java VM architecture. </title> <editor> In E. Borger, editor, </editor> <booktitle> Architecture Design and Validation Methods. </booktitle> <address> Springer Verlag, </address> <note> to appear, </note> <year> 1998. </year>
Reference-contexts: We found it interesting to discover at a later stage of our work on the Java language that an analogous modular decomposition can be given also for models of the JVM <ref> [15] </ref>. Section 2 defines the basic ASM Java I for Java's imperative core, which is essentially a while language. It contains statements and expressions over Java's primitive types. This section provides an introduction to our approach and notation.
Reference: 16. <author> P. Cenciarelli, A. Knapp, B. Reus, and M. Wirsing. </author> <title> An event-based structural operational semantics of multi-threaded Java. </title> <booktitle> 1998. This volume. </booktitle>
Reference-contexts: The reference manual specifies a memory model for shared memory multiprocessors that support high performance implementations. It allows objects to reside in main and local working memory and presents rules (formalized as a particular event-structure by Cenciarelli et al. <ref> [16] </ref>) specifying when a thread is permitted or required to transfer the contents of its working copy of an instance variable into the master copy in main memory or vice versa.
Reference: 17. <author> R. M. Cohen. </author> <title> Defensive Java virtual machine version 0.5 alpha release. manuscript, </title> <booktitle> Computer Logic International. </booktitle>
Reference-contexts: We are also working on applying our JVM models for safety analysis of Java byte code along the research approaches of Stati and Abadi [35], Qian [31] and Cohen <ref> [17] </ref>. 42 Acknowledgement We thank the following persons for having read and com-mented upon previous versions of our Java models: Martin Abadi, Klaus Achatz, Matthias Anlauff, Giuseppe Del Castillo, Dag Diesen, Igor Durdanovic, Vincenzo Gervasi, Alexander Knapp, Bernd Koblinger, Philipp Kutter, Arnd Poetzsch-Heffter, Peter Pappinghaus, Karl Stroetmann, Giovanni Ricci, Kirsten Winter,
Reference: 18. <author> G. Del Castillo, I. Durdanovic, and U. Glasser. </author> <title> An Evolving Algebra abstract machine. </title> <editor> In H. Kleine Buning, editor, </editor> <booktitle> Computer Science Logic (CSL'95), </booktitle> <publisher> Springer LNCS 1092, </publisher> <year> 1996. </year>
Reference-contexts: Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter <ref> [18] </ref>) they can be used for high-level validation. See [3] for a survey. ASMs have a simple mathematical foundation [21], which justifies their intuitive understanding as "pseudo-code over abstract data" so that the practitioner can use them correctly and successfully without having to go through any special formal training.
Reference: 19. <author> S. Drossopoulou and S. Eisenbach. </author> <title> Java is type safe probably. </title> <booktitle> 1998. This volume. </booktitle>
Reference-contexts: Corresponding to these phases, a full mathematical definition of Java needs a grammar, a static and a dynamic semantics. The grammar is well defined in the LRM [20]. Numerous authors have formalized the static semantics of sequential Java, in particular its type soundness <ref> [19, 27, 32, 36] </ref>. The dynamic semantics given in these papers cover only a small structured sublanguage of sequential Java and do not consider the interaction of jump statements (like break), exception handling and concurrency, which we treat in full.
Reference: 20. <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java(tm) Language Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction In this chapter we formalize the semantics of Java by a system independent, purely mathematical yet easily manageable model, which reflects directly the intuitions and design decisions underlying the language as described in Java's language reference manual (LRM) <ref> [20] </ref>. Our goal is to contribute to a rigorous yet readable definition of the entire language, which supports the programmer's understanding of Java programs. <p> Execution, the dynamic phase, loads, links, and executes the code of the class by evaluating expressions and modifying the memory. Corresponding to these phases, a full mathematical definition of Java needs a grammar, a static and a dynamic semantics. The grammar is well defined in the LRM <ref> [20] </ref>. Numerous authors have formalized the static semantics of sequential Java, in particular its type soundness [19, 27, 32, 36]. <p> If the execution completes normally, i.e., without any run-time violation, the ASM reaches: task = finished. Expressions The expressions of Java's imperative core|except the conditional operators|are evaluated from left to right and from innermost to outermost. This is described in Chap. 15.6 of Java's LRM <ref> [20] </ref>. (In the remainder of this chapter, we will abbreviate citations like this one using the `x' sign, writing (x 15.6) to cite the corresponding chapter of the LRM. <p> However for best practice programs neither these time delays nor the different memory models produce any semantical difference. 7 Conclusion and Outlook In this work we have defined a rigorous abstract operational model which captures faithfully the programmer's view of Java as described in the reference manual <ref> [20] </ref>. The model can be used for standardization purposes along the lines the ASM model for Prolog [11] has been used for defining the ISO standard for the semantics of Prolog.
Reference: 21. <author> Y. Gurevich. </author> <title> Evolving algebras 1993: Lipari guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Gurevich's Abstract State Machines (ASMs), previously called Evolving Algebras, see <ref> [21] </ref>, provide the fundamental concept for such a modeling technique. ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam [7, 6], VHDL [8], C++[37] and others. <p> Furthermore, ASMs are effective in modeling architectures [5, 9], protocols [22, 2], control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey. ASMs have a simple mathematical foundation <ref> [21] </ref>, which justifies their intuitive understanding as "pseudo-code over abstract data" so that the practitioner can use them correctly and successfully without having to go through any special formal training. <p> Therefore we invite the reader to go ahead with reading our specification and to consult the formal definition of ASMs in <ref> [21] </ref> only should the necessity arise. We formally define the semantics of Java by providing an ASM which interprets arbitrary Java programs. A Java program consists of a set of classes. In the use of a class there are three phases: parsing, elaboration, and execution. <p> Threads are concurrent independent processes running within a single program so that they correspond to code executing agents in distributed ASMs <ref> [21] </ref>. For the modeling of threads we therefore use a universe Thread to formalize the objects belonging to the class Thread through which threads in Java are represented and controlled.
Reference: 22. <author> J. Huggins. </author> <title> Kermit: Specification and verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: ASMs have been successfully used to model the semantics and implementation of programming languages as different as Prolog [11, 12], Occam [7, 6], VHDL [8], C++[37] and others. Furthermore, ASMs are effective in modeling architectures [5, 9], protocols <ref> [22, 2] </ref>, control software [4, 10], and by being amenable to execution (see for an ASM interpreter [18]) they can be used for high-level validation. See [3] for a survey.
Reference: 23. <author> G. Kahn. </author> <title> Natural semantics. </title> <type> Technical report, </type> <institution> INRIA Rapport de Recherche No. </institution> <month> 601, Fevrier </month> <year> 1987. </year>
Reference-contexts: After some experimentation we decided to strictly stick to a run-time and not syntax-directed modeling. Structural methods (like SOS [28], natural semantics <ref> [23] </ref>, action semantics [26], etc.) are known to work well for the definition of languages where the control flow essentially follows the syntax (tree) structure with only little involvement of environment information (as is the case for example for purely functional languages or for strongly syntax supported languages).
Reference: 24. <author> T. Lindholm and F. Yellin. </author> <title> The Java(tm) Virtual Machine Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: In the context of class initialization an ambiguity arises. Whereas the LRM specifies that in an array creation expression the array's element type|provided it is a class or interface| is initialized, this is left out in Java's Virtual Machine specification <ref> [24] </ref>, although this is required as part of the resolution process. In fact, Sun's JDK triggers the initialization of the array's element type in array creation expressions.
Reference: 25. <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference: 26. <author> P. D. Mosses. </author> <title> Action Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: After some experimentation we decided to strictly stick to a run-time and not syntax-directed modeling. Structural methods (like SOS [28], natural semantics [23], action semantics <ref> [26] </ref>, etc.) are known to work well for the definition of languages where the control flow essentially follows the syntax (tree) structure with only little involvement of environment information (as is the case for example for purely functional languages or for strongly syntax supported languages).
Reference: 27. <author> Th. Nipkow and D. von Oheimb. </author> <title> Java light is type-safe definitely. </title> <booktitle> 1998. This volume. </booktitle>
Reference-contexts: Corresponding to these phases, a full mathematical definition of Java needs a grammar, a static and a dynamic semantics. The grammar is well defined in the LRM [20]. Numerous authors have formalized the static semantics of sequential Java, in particular its type soundness <ref> [19, 27, 32, 36] </ref>. The dynamic semantics given in these papers cover only a small structured sublanguage of sequential Java and do not consider the interaction of jump statements (like break), exception handling and concurrency, which we treat in full.
Reference: 28. <author> G. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical report, Internal Report, </type> <institution> CS Department, Aarhus University, DAIMI FN-19, </institution> <year> 1997. </year>
Reference-contexts: After some experimentation we decided to strictly stick to a run-time and not syntax-directed modeling. Structural methods (like SOS <ref> [28] </ref>, natural semantics [23], action semantics [26], etc.) are known to work well for the definition of languages where the control flow essentially follows the syntax (tree) structure with only little involvement of environment information (as is the case for example for purely functional languages or for strongly syntax supported languages).
Reference: 29. <author> A. Poetzsch-Heffter. </author> <title> Prototyping realistic programming languages based on formal specifications. </title> <journal> Acta Informatica, </journal> <volume> 34, </volume> <year> 1997. </year>
Reference-contexts: As is well known such a separation of statics and dynamics also lays 2 the ground for efficient implementations of the static features for program inter-pretation and for the generation of program debuggers, animation tools etc. (see for example <ref> [29] </ref>). In addition it has led to an interesting and novel integration, into ASM specifications, of various useful methods from functional programming and algebraic specifications for the definition of static (compile-time) functions. After some experimentation we decided to strictly stick to a run-time and not syntax-directed modeling.
Reference: 30. <author> K. </author> <title> Popper. </title> <journal> Logik der Forschung. </journal> <year> 1935. </year>
Reference-contexts: These goals oblige us to abstract the central ideas of Java's LRM into a transparent but rigorous form, whose adequacy can be recognized (or falsified in the sense of Popper <ref> [30] </ref>) by inspection, i.e., by a direct comparison of the mathematical definitions with the verbal descriptions in the manual (see the discussion on ? This paper appears in [1]. <p> For such an endeavor it is important that our mathematical definition of the semantics of Java yields a complete model which is falsifiable by mental or machine experiments, in the sense of Popper <ref> [30] </ref>, and thus complements and enhances purely experimental studies of Java and its implementations (see for example the Kimera project [34]). 41 Our definition provides a basis for a machine and system independent math-ematical analysis of the behavior of Java programs.
Reference: 31. <author> Z. Qian. </author> <title> A formal specification of Java(tm) Virtual Machine for objects, methods and subroutines. </title> <booktitle> This volume, </booktitle> <year> 1998. </year>
Reference-contexts: We are also working on applying our JVM models for safety analysis of Java byte code along the research approaches of Stati and Abadi [35], Qian <ref> [31] </ref> and Cohen [17]. 42 Acknowledgement We thank the following persons for having read and com-mented upon previous versions of our Java models: Martin Abadi, Klaus Achatz, Matthias Anlauff, Giuseppe Del Castillo, Dag Diesen, Igor Durdanovic, Vincenzo Gervasi, Alexander Knapp, Bernd Koblinger, Philipp Kutter, Arnd Poetzsch-Heffter, Peter Pappinghaus, Karl Stroetmann, Giovanni
Reference: 32. <author> V. Saraswat. </author> <title> Java is not type-safe. </title> <type> manuscript, </type> <institution> AT&T Research, </institution> <address> New York, </address> <year> 1997. </year>
Reference-contexts: Corresponding to these phases, a full mathematical definition of Java needs a grammar, a static and a dynamic semantics. The grammar is well defined in the LRM [20]. Numerous authors have formalized the static semantics of sequential Java, in particular its type soundness <ref> [19, 27, 32, 36] </ref>. The dynamic semantics given in these papers cover only a small structured sublanguage of sequential Java and do not consider the interaction of jump statements (like break), exception handling and concurrency, which we treat in full.
Reference: 33. <author> G. Schellhorn and W. Ahrendt. </author> <title> Reasoning about Abstract State Machines: The WAM Case Study. </title> <journal> Journal of Universal Computer Science (J.UCS), </journal> <year> 1997. </year>
Reference-contexts: The ASMs we are developing for the JVM provide the basis for a rigorous mathematical analysis of general compilation schemes of Java programs into JVM code including correctness proofs as developed for the implementation for Prolog on the WAM [12] (see also <ref> [33] </ref>) and of Occam on the Transputer [6].
Reference: 34. <author> E.G. Sirer, S. McDirmid, and B. Bershad. Kimera: </author> <title> A Java system security architecture. Web pages at: </title> <note> http://www.kimera.cs.washington.edu/, 1997. </note>
Reference-contexts: endeavor it is important that our mathematical definition of the semantics of Java yields a complete model which is falsifiable by mental or machine experiments, in the sense of Popper [30], and thus complements and enhances purely experimental studies of Java and its implementations (see for example the Kimera project <ref> [34] </ref>). 41 Our definition provides a basis for a machine and system independent math-ematical analysis of the behavior of Java programs.
Reference: 35. <author> R. Stata and M. Abadi. </author> <title> A type system for Java bytecode subroutines. </title> <booktitle> In Proceedings of the 25th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1998. </year>
Reference-contexts: We are also working on applying our JVM models for safety analysis of Java byte code along the research approaches of Stati and Abadi <ref> [35] </ref>, Qian [31] and Cohen [17]. 42 Acknowledgement We thank the following persons for having read and com-mented upon previous versions of our Java models: Martin Abadi, Klaus Achatz, Matthias Anlauff, Giuseppe Del Castillo, Dag Diesen, Igor Durdanovic, Vincenzo Gervasi, Alexander Knapp, Bernd Koblinger, Philipp Kutter, Arnd Poetzsch-Heffter, Peter Pappinghaus, Karl
Reference: 36. <author> D. Syme. </author> <title> Proving Java type soundness. </title> <booktitle> 1998. This volume. </booktitle>
Reference-contexts: Corresponding to these phases, a full mathematical definition of Java needs a grammar, a static and a dynamic semantics. The grammar is well defined in the LRM [20]. Numerous authors have formalized the static semantics of sequential Java, in particular its type soundness <ref> [19, 27, 32, 36] </ref>. The dynamic semantics given in these papers cover only a small structured sublanguage of sequential Java and do not consider the interaction of jump statements (like break), exception handling and concurrency, which we treat in full.
Reference: 37. <author> Ch. Wallace. </author> <title> The semantics of the C++ programming language. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: 38. <author> Ch. Wallace. </author> <title> The semantics of the Java programming language: Preliminary version. </title> <type> Technical report, </type> <institution> University of Michigan, Electrical Engineering and Computer Science, </institution> <address> Ann Arbor, </address> <year> 1997. </year> <month> 44 </month>
Reference-contexts: The modular structure, and the relegation of standard compile-time matters to static functions, which support the comprehension of the model by humans and its use for proving interesting properties for Java programs, are two main features which distinguish our work from the approach of Wallace <ref> [38] </ref>, which is geared towards executability of the ASM specification. A comparison of these two models illustrates the high degree of freedom ASMs offer to tune a mathematical model to its intended use.
References-found: 38

