URL: http://www.cs.rice.edu/CS/PLT/Publications/popl95-ff.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: The Semantics of Future and Its Use in Program Optimization  
Author: Cormac Flanagan Matthias Felleisen 
Address: Houston, Texas  
Affiliation: Department of Computer Science Rice University  
Abstract: The future annotations of MultiLisp provide a simple method for taming the implicit parallelism of functional programs. Past research concerning futures has focused on implementation issues. In this paper, we present a series of operational semantics for an idealized functional language with futures with varying degrees of inten-sionality. We develop a set-based analysis algorithm from the most intensional semantics, and use that algorithm to perform touch optimization on programs. Experiments with the Gambit compiler indicates that this optimization substantially reduces program execution times. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Baker, H., and Hewitt, C. </author> <title> The incremental garbage collection of processes. </title> <booktitle> In Proceedings of the Symposium on Artificial Intelligence and Programming Languages (1977), </booktitle> <volume> vol. 12(8), </volume> <pages> 55-59. </pages>
Reference-contexts: However, if such a strategy were applied indiscriminately, the execution of a program would generate far too many parallel threads. The overhead of managing these threads would clearly outweigh any benefits from parallel execution. The future annotations of MultiLisp <ref> [1, 12] </ref> and its Scheme successors provide a simple method for taming the implicit parallelism of functional programs. If a programmer believes that the parallel evaluation of some expression outweighs the overhead of creating a separate task, he may annotate the expression with the keyword future.
Reference: [2] <institution> BBN Advanced Computers, Inc., </institution> <address> Cambridge, MA. Inside the GP1000. </address> <year> 1989. </year>
Reference-contexts: of a 200 term polynomial, and evaluates the result at a given value of x. large subset of functional Scheme. 5 We used the extended Gambit compiler to test the effectiveness of touch optimization on the suite of benchmarks contained in Feeley's Ph.D. thesis [6] on a GP1000 shared-memory multiprocessor <ref> [2] </ref>. Figure 9 describes these benchmarks. Each benchmark was tested on the original compiler (standard ) and on the modified compiler (touch optimized). The results of the test runs are documented in Figure 10.
Reference: [3] <author> Cousot, P., and Cousot, R. </author> <title> Abstract interpretation: A unified lattice model for static analyses of programs by consruction or approximation of fixpoints. </title> <booktitle> In POPL (1977), </booktitle> <pages> 238-252. </pages>
Reference-contexts: We start from a parallel abstract machine and avoid these intermediate steps by deriving our set constraints and proving their correctness directly from the abstract machine semantics. Other techniques for static analysis of sequential programs include abstract interpretation <ref> [3, 4] </ref> and Shivers' 0CFA [30]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [13]. 11 Sequential optimization techniques such as tagging optimization [15] and soft-typing [33] are similar in character to touch optimization.
Reference: [4] <author> Cousot, P., and Cousot, R. </author> <title> Higer order abstract interpretation (and application to comportment analysis generalizing strictness, termination, projection and per analysis of functional languages. </title> <booktitle> ICCL (1994), </booktitle> <pages> 95-112. </pages>
Reference-contexts: We start from a parallel abstract machine and avoid these intermediate steps by deriving our set constraints and proving their correctness directly from the abstract machine semantics. Other techniques for static analysis of sequential programs include abstract interpretation <ref> [3, 4] </ref> and Shivers' 0CFA [30]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [13]. 11 Sequential optimization techniques such as tagging optimization [15] and soft-typing [33] are similar in character to touch optimization.
Reference: [5] <author> Deutsch, A. </author> <title> Modeles Operationnels de Language de Programmation et Representations de Relations sue des Languages Rationnels avec Application a la Determination Statique de Proprietes de Partages Dy-namiques de Donnees. </title> <type> PhD thesis, </type> <institution> Universite Paris VI, </institution> <year> 1992. </year>
Reference-contexts: He also uses his semantics to prove the type soundness of the complete language. Neither Reppy nor Leroy used their semantics for developing analyses or optimizations. Jaganathan and Weeks [18] define an operational semantics for a simple function language extended with the spawn construct by extending Deutsch's transition semantics <ref> [5] </ref>. They described an analysis for their language that they intend to use in a forthcoming compiler, but they do not have an implementation of their analysis for a full language like functional Scheme, and they do not have optimization algorithms that exploit the results of their analysis.
Reference: [6] <author> Feeley, M. </author> <title> An Efficient and General Implementation of Futures on Large Scale Shared-Memory Multiprocessors. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Brandeis University, </institution> <year> 1993. </year>
Reference-contexts: Past research on futures has almost exclusively concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 17, 23, 25, 26] </ref> and on the extension of the concept to first-class continuations [19, 27]. In contrast, the driving force behind our effort is the desire to develop a semantic framework and semantically well-founded optimizations for languages with future. <p> The last one is a low-level refinement, which explicates just enough information to permit the derivation of a set-based program analysis [14]. The secondary result is a touch optimization algorithm (based on the analysis) with its correctness proof. The algorithm was added to the Gambit Scheme compiler <ref> [6] </ref> and produced significant speedups on a standard set of benchmarks. The presentation of our results proceeds as follows. The second section introduces an idealized functional language with futures, together with its definitional, sequential semantics that interprets futures as no-ops. <p> 0 (transitive) consequently choose to ignore future expressions (along the lines of the C -machine), which yields a sequential execution, to execute fork as early as possible, which yields an eager task creation mechanism [23, 31], or to choose some strategy in between the extremes, which yields lazy task creation <ref> [6, 26] </ref> A second source of indeterminism is the transition rule (parallel ). This rule does not specify the number of steps that parallel sub-states must perform before they synchronize. <p> Kranz [22] and Feeley <ref> [6] </ref> estimated this cost at nearly 100% of the (se-quential) execution time, and our experiments confirm these results (see below). <p> The classical solution for avoiding this overhead is to provide a compiler switch that disables the automatic insertion of touches, and a touch primitive so that programmers can insert touch operations explicitly where needed <ref> [6, 20, 31] </ref>. We believe that this solution is flawed for several reasons. First, it clearly destroys the transparent character of future annotations. Instead of an annotation that only affects executions on some machines, future is now a task creation construct and touch is a synchronization tool. <p> following query on sba (P ): sba (P )(y) fc P ; (x: M ) P ; (cons x y) P g In a similar manner other queries on sba (P ) can easily be reformulated in terms of sba (P ). 7 Experimental Results We extended the Gambit compiler <ref> [6, 7] </ref>, which makes no attempt to remove touch operations from programs, with a preprocessor that implements the set-based analysis algorithm and the touch optimization algorithm. <p> 1000 integers. poly Computes the square of a 200 term polynomial, and evaluates the result at a given value of x. large subset of functional Scheme. 5 We used the extended Gambit compiler to test the effectiveness of touch optimization on the suite of benchmarks contained in Feeley's Ph.D. thesis <ref> [6] </ref> on a GP1000 shared-memory multiprocessor [2]. Figure 9 describes these benchmarks. Each benchmark was tested on the original compiler (standard ) and on the modified compiler (touch optimized). The results of the test runs are documented in Figure 10. <p> 811 110.8 7 &lt;1 52.1 29.4 5.8 allpairs 32360 150.4 14 &lt;1 60.0 39.6 &lt;1 abisort 5751 106.5 9 &lt;1 51.3 31.1 24.4 mst 20422 91.4 750 5.3 45.0 17.2 &lt;1 qsort 253 43.3 78 19.9 16.4 &lt;1 &lt;1 poly 526 65.3 121 16.2 29.7 12.5 &lt;1 ever, even Feeley <ref> [6] </ref> described these as "poorly parallel" programs, in which the effects of memory contention and communication costs are especially visible.
Reference: [7] <author> Feeley, M., and Miller, J. S. </author> <title> A parallel virtual ma chine for efficient scheme compilation. </title> <booktitle> In LFP (1990). </booktitle>
Reference-contexts: following query on sba (P ): sba (P )(y) fc P ; (x: M ) P ; (cons x y) P g In a similar manner other queries on sba (P ) can easily be reformulated in terms of sba (P ). 7 Experimental Results We extended the Gambit compiler <ref> [6, 7] </ref>, which makes no attempt to remove touch operations from programs, with a preprocessor that implements the set-based analysis algorithm and the touch optimization algorithm.
Reference: [8] <author> Felleisen, M., and Friedman, D. P. </author> <title> Control oper ators, the SECD-machine, and the lambda-calculus. </title> <booktitle> In 3rd Working Conference on the Formal Description of Programming Concepts (Aug. </booktitle> <year> 1986), </year> <pages> 193-219. </pages>
Reference-contexts: We specify the definitional semantics of the language using a sequential abstract machine called the C-machine (see Figure 2), whose states are either closed terms over the run-time language fl c or else the special state error, and whose deterministic transition rules are the typical leftmost-outermost reductions of the -calculus <ref> [8] </ref>. Each transition rule also specifies the error semantics of a particular class of expressions. For example, the transition rule for car defines that if the argument to car is a pair, then the transition rule extracts the first element of the pair. <p> For example, it does not permit a detailed view of the synchronization operations that are required for coordinating futures. To address these problems, we refine the P (C)-machine to the P (CEK)-machine (see Figure 4) using standard techniques <ref> [8, 11] </ref>. 4.1 The P (CEK)-machine An evaluation context, which represents the control stack, is now represented as a sequence of activation records (which are similar to closures). <p> The first step constructs an intermediate semantics by introducing placeholder objects into the P (C)-machine. The second step proves the correctness of the P (CEK)-machine with respect to the intermediate semantics using standard proof techniques <ref> [8] </ref>, appropriately modified to account for parallel evaluation. Theorem 4.1 eval pcek = eval pc 5 Touch Optimization The P (CEK)-machine performs touch operations on arguments in placeholder-strict positions of all program operations. These implicit touch operations guarantee the transparency of placeholders, which makes future-based parallelism so convenient to use.
Reference: [9] <author> Flanagan, C., and Felleisen, M. </author> <title> The semantics of Future. </title> <institution> Rice University Comp. Sci. TR94-238. </institution>
Reference-contexts: The latter is based on the set-based analysis algorithm of the sixth section. The seventh section presents experimental results demonstrating the effectiveness of this optimization. Section eight discusses related work. For more details, we refer the interested reader to two technical reports on this work <ref> [9, 10] </ref>.
Reference: [10] <author> Flanagan, C., and Felleisen, M. </author> <title> Well-founded touch optimization of Parallel Scheme. </title> <institution> Rice University Comp. Sci. TR94-239. </institution>
Reference-contexts: The latter is based on the set-based analysis algorithm of the sixth section. The seventh section presents experimental results demonstrating the effectiveness of this optimization. Section eight discusses related work. For more details, we refer the interested reader to two technical reports on this work <ref> [9, 10] </ref>.
Reference: [11] <author> Flanagan, C., Sabry, A., Duba, B. F., and Felleisen, M. </author> <title> The essence of compiling with continuations. </title> <booktitle> In PLDI (1993), </booktitle> <pages> 237-247. </pages>
Reference-contexts: Specifically, we use the subset of A-normal forms <ref> [11] </ref> of an extended -calculus-like language that includes conditionals and a future construct: see Figure 1. The language also includes primitives for list manipulation, which serve to illustrate the treatment of primitive operations, and an unspecified set of basic constants (numbers, booleans). <p> The key property of terms in A-normal form is that each intermediate value is explicitly named and that the order of execution follows the lexical nesting of let-expressions. The use of A-normal forms facilitates the compile-time analysis of programs [29], and it simplifies the definition of abstract machines <ref> [11] </ref>. We work with the usual conventions and terminology of the lambda calculus when discussing syntactic issues. <p> For example, it does not permit a detailed view of the synchronization operations that are required for coordinating futures. To address these problems, we refine the P (C)-machine to the P (CEK)-machine (see Figure 4) using standard techniques <ref> [8, 11] </ref>. 4.1 The P (CEK)-machine An evaluation context, which represents the control stack, is now represented as a sequence of activation records (which are similar to closures).
Reference: [12] <author> Halstead, R. </author> <title> Multilisp: A language for concurrent symbolic computataion. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <volume> 4 (1985), </volume> <pages> 501-538. </pages>
Reference-contexts: However, if such a strategy were applied indiscriminately, the execution of a program would generate far too many parallel threads. The overhead of managing these threads would clearly outweigh any benefits from parallel execution. The future annotations of MultiLisp <ref> [1, 12] </ref> and its Scheme successors provide a simple method for taming the implicit parallelism of functional programs. If a programmer believes that the parallel evaluation of some expression outweighs the overhead of creating a separate task, he may annotate the expression with the keyword future.
Reference: [13] <author> Heintze, N. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: He only reports the reduction of static counts of touch operations for an implementation of Common Lisp with future. Neither paper gives an indication concerning the expense of the analysis algorithms. Our analysis methods most closely follows Heintze's work on set-based analysis for the sequential language ML <ref> [13, 14] </ref>, but the extension of his technique to parallel languages requires a substantial reformulation of the derivation and correctness proof. Specifically, Heintze uses the "natural" semantics framework to define a set-based "natural" semantics, from which he reads off safeness conditions on set environments. <p> Other techniques for static analysis of sequential programs include abstract interpretation [3, 4] and Shivers' 0CFA [30]. The relationship between abstract interpretation and set-based analysis was covered by Heintze <ref> [13] </ref>. 11 Sequential optimization techniques such as tagging optimization [15] and soft-typing [33] are similar in character to touch optimization. Both techniques remove the type-dispatches required for dynamic type-checking wherever possible, without changing the behavior of programs, in the same fashion as we remove touch operations.
Reference: [14] <author> Heintze, N. </author> <title> Set-based analysis of ML programs. </title> <booktitle> In LFP (1994), </booktitle> <pages> 306-317. </pages>
Reference-contexts: The first semantics defines future to be a semantically-transparent annotation. The second one validates that a future expression interpreted as process creation is correct. The last one is a low-level refinement, which explicates just enough information to permit the derivation of a set-based program analysis <ref> [14] </ref>. The secondary result is a touch optimization algorithm (based on the analysis) with its correctness proof. The algorithm was added to the Gambit Scheme compiler [6] and produced significant speedups on a standard set of benchmarks. The presentation of our results proceeds as follows. <p> Second, we develop an algorithm for finding the minimal set environment satisfying these constraints. The constraints we produce are similar to those in Heintze's work on set based analysis for ML <ref> [14] </ref>, though our derivation of these constraints differs substantially. 6.1 Deriving Set Constraints We derive constraints on valid set environments by analyzing the transition rules of the machine. <p> He only reports the reduction of static counts of touch operations for an implementation of Common Lisp with future. Neither paper gives an indication concerning the expense of the analysis algorithms. Our analysis methods most closely follows Heintze's work on set-based analysis for the sequential language ML <ref> [13, 14] </ref>, but the extension of his technique to parallel languages requires a substantial reformulation of the derivation and correctness proof. Specifically, Heintze uses the "natural" semantics framework to define a set-based "natural" semantics, from which he reads off safeness conditions on set environments.
Reference: [15] <author> Henglein, F. </author> <title> Global tagging optimization by type in ference. </title> <booktitle> In LFP (1992), </booktitle> <pages> 205-215. </pages>
Reference-contexts: Other techniques for static analysis of sequential programs include abstract interpretation [3, 4] and Shivers' 0CFA [30]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [13]. 11 Sequential optimization techniques such as tagging optimization <ref> [15] </ref> and soft-typing [33] are similar in character to touch optimization. Both techniques remove the type-dispatches required for dynamic type-checking wherever possible, without changing the behavior of programs, in the same fashion as we remove touch operations.
Reference: [16] <editor> Ito, T., and Halstead, R., Eds. </editor> <booktitle> Parallel Lisp: Lan guages and Systems. Springer-Verlag Lecture Notes in Computer Science 441, </booktitle> <year> 1989. </year>
Reference: [17] <author> Ito, T., and Matsui, M. </author> <title> A parallel lisp language: Pailisp and its kernel specification. </title> [16:58-100]. 
Reference-contexts: Past research on futures has almost exclusively concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 17, 23, 25, 26] </ref> and on the extension of the concept to first-class continuations [19, 27]. In contrast, the driving force behind our effort is the desire to develop a semantic framework and semantically well-founded optimizations for languages with future.
Reference: [18] <author> Jagannathan, S., and Weeks, S. </author> <title> Analyzing stores and references in a parallel symbolic language. </title> <booktitle> In LFP (1994), </booktitle> <pages> 294-305. </pages>
Reference-contexts: Leroy formulates a semantics for a subset of CML in the traditional "natural" semantics framework. He also uses his semantics to prove the type soundness of the complete language. Neither Reppy nor Leroy used their semantics for developing analyses or optimizations. Jaganathan and Weeks <ref> [18] </ref> define an operational semantics for a simple function language extended with the spawn construct by extending Deutsch's transition semantics [5].
Reference: [19] <author> Katz, M., and Weise, D. </author> <title> Continuing into the fu ture: on the interaction of futures and first-class continuations. </title> <booktitle> In LFP (1990). </booktitle>
Reference-contexts: Past research on futures has almost exclusively concentrated on the efficient implementation of the underlying task creation mechanism [6, 17, 23, 25, 26] and on the extension of the concept to first-class continuations <ref> [19, 27] </ref>. In contrast, the driving force behind our effort is the desire to develop a semantic framework and semantically well-founded optimizations for languages with future. The specific example we choose to consider is the development of an algorithm for removing provably-redundant touch operations from programs.
Reference: [20] <author> Kessler, R.R., and R. Swanson. </author> <title> Concurrent scheme. </title> [16:200-234]. 
Reference-contexts: The classical solution for avoiding this overhead is to provide a compiler switch that disables the automatic insertion of touches, and a touch primitive so that programmers can insert touch operations explicitly where needed <ref> [6, 20, 31] </ref>. We believe that this solution is flawed for several reasons. First, it clearly destroys the transparent character of future annotations. Instead of an annotation that only affects executions on some machines, future is now a task creation construct and touch is a synchronization tool.
Reference: [21] <author> Knopp, J. </author> <title> Improving the performance of parallel lisp by compile time analysis. </title> [16:271-277]. 
Reference-contexts: The algorithm lowers the touch overhead to 65% from 100% in standard benchmarks, that is, it is significantly less effective than our touch optimization. The paper does not address the semantics of future or the well-foundedness of the optimizations. Knopp <ref> [21] </ref> reports the existence of a touch optimization algorithm based on abstract interpretation. His paper presents neither a semantics nor the abstract interpretation. He only reports the reduction of static counts of touch operations for an implementation of Common Lisp with future.
Reference: [22] <author> Kranz, D., Halstead, R., and Mohr, E. Mul-T: </author> <title> A high-performance parallel lisp. </title> [16:306-321]. 
Reference-contexts: Kranz <ref> [22] </ref> and Feeley [6] estimated this cost at nearly 100% of the (se-quential) execution time, and our experiments confirm these results (see below).
Reference: [23] <author> Kranz, D., Halstead, R., and Mohr, E. Mul-T: </author> <title> A high-performance parallel lisp. </title> <booktitle> In PLDI (1989), </booktitle> <pages> 81-90. </pages>
Reference-contexts: Past research on futures has almost exclusively concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 17, 23, 25, 26] </ref> and on the extension of the concept to first-class continuations [19, 27]. In contrast, the driving force behind our effort is the desire to develop a semantic framework and semantically well-founded optimizations for languages with future. <p> pc S 00 ; n = a + c; m = b + d; n &gt; 0 (transitive) consequently choose to ignore future expressions (along the lines of the C -machine), which yields a sequential execution, to execute fork as early as possible, which yields an eager task creation mechanism <ref> [23, 31] </ref>, or to choose some strategy in between the extremes, which yields lazy task creation [6, 26] A second source of indeterminism is the transition rule (parallel ). This rule does not specify the number of steps that parallel sub-states must perform before they synchronize. <p> The proof techniques are related to the ones we used to prove the equivalence of the P (CEK)-machine and the P (C)-machine. Kranz et al. <ref> [23] </ref> briefly describe a simplistic algorithm for touch optimization based on a first-order type analysis. The algorithm lowers the touch overhead to 65% from 100% in standard benchmarks, that is, it is significantly less effective than our touch optimization.
Reference: [24] <author> Leroy, X. </author> <title> Typage polymorphe d'un langage algorith mique. </title> <type> PhD thesis, </type> <institution> Universite Paris 7, </institution> <year> 1992. </year>
Reference-contexts: His primary goal is to design a semantics for the language that treats pcall as a pure annotation. His correctness proofs is far more complicated than our techniques, due to the inclusion of continuations. Independently, Reppy [28] and Leroy <ref> [24] </ref> define a formal operational semantics for an ML-like language with first-class synchronization operations. Reppy's language, Concurrent ML, can provide the future mechanism as an abstraction over the given primitives. The semantics is a two-level rewriting system. Reppy uses his semantics to prove a type soundness theorem.
Reference: [25] <author> Miller, J. MultiScheme: </author> <title> A Parallel Processing System. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1987. </year>
Reference-contexts: Past research on futures has almost exclusively concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 17, 23, 25, 26] </ref> and on the extension of the concept to first-class continuations [19, 27]. In contrast, the driving force behind our effort is the desire to develop a semantic framework and semantically well-founded optimizations for languages with future.
Reference: [26] <author> Mohr, E., Kranz, R., and Halstead, R. </author> <title> Lazy task creation: A technique for increasing the granularity of parallel programs. </title> <booktitle> In LFP (1990). </booktitle>
Reference-contexts: Past research on futures has almost exclusively concentrated on the efficient implementation of the underlying task creation mechanism <ref> [6, 17, 23, 25, 26] </ref> and on the extension of the concept to first-class continuations [19, 27]. In contrast, the driving force behind our effort is the desire to develop a semantic framework and semantically well-founded optimizations for languages with future. <p> 0 (transitive) consequently choose to ignore future expressions (along the lines of the C -machine), which yields a sequential execution, to execute fork as early as possible, which yields an eager task creation mechanism [23, 31], or to choose some strategy in between the extremes, which yields lazy task creation <ref> [6, 26] </ref> A second source of indeterminism is the transition rule (parallel ). This rule does not specify the number of steps that parallel sub-states must perform before they synchronize.
Reference: [27] <author> Moreau, L. </author> <title> Sound Evaluation of Parallel Functional Programs with First-Class Continuations. </title> <type> PhD thesis, </type> <institution> Universite de Liege, </institution> <year> 1994. </year>
Reference-contexts: Past research on futures has almost exclusively concentrated on the efficient implementation of the underlying task creation mechanism [6, 17, 23, 25, 26] and on the extension of the concept to first-class continuations <ref> [19, 27] </ref>. In contrast, the driving force behind our effort is the desire to develop a semantic framework and semantically well-founded optimizations for languages with future. The specific example we choose to consider is the development of an algorithm for removing provably-redundant touch operations from programs. <p> The only one that directly deals with parallelism based on transparent annotations is Moreau's Ph.D. thesis <ref> [27] </ref>. Moreau studies the functional core of Scheme extended with pcall (for evaluating function and argument expressions of an application in parallel) and first-class continuations. His primary goal is to design a semantics for the language that treats pcall as a pure annotation.
Reference: [28] <author> Reppy, J.H. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: His primary goal is to design a semantics for the language that treats pcall as a pure annotation. His correctness proofs is far more complicated than our techniques, due to the inclusion of continuations. Independently, Reppy <ref> [28] </ref> and Leroy [24] define a formal operational semantics for an ML-like language with first-class synchronization operations. Reppy's language, Concurrent ML, can provide the future mechanism as an abstraction over the given primitives. The semantics is a two-level rewriting system. Reppy uses his semantics to prove a type soundness theorem.
Reference: [29] <author> Sabry, A., and Felleisen, M. </author> <title> Is continuation-passing useful for data flow analysis. </title> <booktitle> In PLDI (1994), </booktitle> <pages> 1-12. </pages>
Reference-contexts: The key property of terms in A-normal form is that each intermediate value is explicitly named and that the order of execution follows the lexical nesting of let-expressions. The use of A-normal forms facilitates the compile-time analysis of programs <ref> [29] </ref>, and it simplifies the definition of abstract machines [11]. We work with the usual conventions and terminology of the lambda calculus when discussing syntactic issues.
Reference: [30] <author> Shivers, O. </author> <title> Control-flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference-contexts: We start from a parallel abstract machine and avoid these intermediate steps by deriving our set constraints and proving their correctness directly from the abstract machine semantics. Other techniques for static analysis of sequential programs include abstract interpretation [3, 4] and Shivers' 0CFA <ref> [30] </ref>. The relationship between abstract interpretation and set-based analysis was covered by Heintze [13]. 11 Sequential optimization techniques such as tagging optimization [15] and soft-typing [33] are similar in character to touch optimization.
Reference: [31] <author> Swanson, M., Kessler, R., and Lindstrom, G. </author> <title> An implementation of portable standard lisp on the BBN butterfly. </title> <booktitle> In LFP (1988), </booktitle> <pages> 132-142. </pages>
Reference-contexts: pc S 00 ; n = a + c; m = b + d; n &gt; 0 (transitive) consequently choose to ignore future expressions (along the lines of the C -machine), which yields a sequential execution, to execute fork as early as possible, which yields an eager task creation mechanism <ref> [23, 31] </ref>, or to choose some strategy in between the extremes, which yields lazy task creation [6, 26] A second source of indeterminism is the transition rule (parallel ). This rule does not specify the number of steps that parallel sub-states must perform before they synchronize. <p> The classical solution for avoiding this overhead is to provide a compiler switch that disables the automatic insertion of touches, and a touch primitive so that programmers can insert touch operations explicitly where needed <ref> [6, 20, 31] </ref>. We believe that this solution is flawed for several reasons. First, it clearly destroys the transparent character of future annotations. Instead of an annotation that only affects executions on some machines, future is now a task creation construct and touch is a synchronization tool.
Reference: [32] <author> Wand, M. </author> <title> Compiler correctness for parallel languages. </title> <type> Unpublished manuscript, </type> <year> 1995. </year>
Reference-contexts: They described an analysis for their language that they intend to use in a forthcoming compiler, but they do not have an implementation of their analysis for a full language like functional Scheme, and they do not have optimization algorithms that exploit the results of their analysis. Wand <ref> [32] </ref> recently extended his work on correctness proofs for sequential compilers to parallel languages. In his prior work on the correctness of sequential compil ers, he derived compilers from the semantic mappings that translate syntax into -calculus expressions.
Reference: [33] <author> Wright, A. and R. Cartwright. </author> <title> A practical soft type system for scheme. </title> <booktitle> In LFP (1994), </booktitle> <pages> 250-262. 12 </pages>
Reference-contexts: := E (x)] (join) transition rules (join-error ), (lift), (parallel), (reflexive) and (transitive) are as for the P (C)-machine Unfortunately, a standard technique for increasing execution speed in Scheme systems is to disable type-checking typically based on informal correctness arguments or based on type verifiers for the underlying sequential language <ref> [33] </ref>. When type-checking is disabled, most program operations do not perform a type-dispatch on their arguments. <p> Other techniques for static analysis of sequential programs include abstract interpretation [3, 4] and Shivers' 0CFA [30]. The relationship between abstract interpretation and set-based analysis was covered by Heintze [13]. 11 Sequential optimization techniques such as tagging optimization [15] and soft-typing <ref> [33] </ref> are similar in character to touch optimization. Both techniques remove the type-dispatches required for dynamic type-checking wherever possible, without changing the behavior of programs, in the same fashion as we remove touch operations.
References-found: 33

