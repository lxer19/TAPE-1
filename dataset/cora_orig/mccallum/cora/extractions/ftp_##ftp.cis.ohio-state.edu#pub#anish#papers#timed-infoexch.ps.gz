URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/timed-infoexch.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Title: A Timing-based Schema for Stabilizing Information Exchange  
Author: Anish Arora David M. Poduska 
Keyword: stabilization, timing-based protocols, fault-tolerance, adaptivity, high speed networks, formal methods, verification  
Abstract: The paradigm of information exchange provides a basis for nodes in a network to stay uptodate with the recent information in the network. In this paradigm, nodes cooperate with each other to share their current information. We present a simple and uniform schema for building information exchange protocols that are stabilizing, in the following strong sense. Starting from arbitrary state, the protocols reach within bounded real-time a state wherefrom all nodes remain uptodate with the recent information in the network. The ability to stabilize in bounded time is achieved by using timing-based actions. The timing constraints on these actions can be systematically adapted to suit a variety of network loads, delay requirements, and scheduling restrictions and to tolerate out-of-phase and drift-prone node clocks. Our schema also tolerates any number of topological changes in the network. Moreover, it accommodates information that is time-varying as well as it does information that is fixed. It is thus well-suited to dynamic high speed networks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. G. Gouda and N. Multari. </author> <title> Stabilizing communication protocols. </title> <journal> IEEE Transaction on Computers, </journal> <volume> 40(4) </volume> <pages> 448-458, </pages> <year> 1991. </year>
Reference-contexts: We also describe in this paper a simple and uniform verification schema to demonstrate the correctness of the resulting protocols. Previous Work. Gouda and Multari <ref> [1] </ref> present an indepth study of stabilization in networks protocols, although the protocols they consider are not explicitly timing-based. In fact, we have found only a few stabilizing protocols in the literature that are explicitly timing-based.
Reference: [2] <author> G. Varghese. </author> <title> Self-Stabilization by Local Checking and Correction. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: Previous Work. Gouda and Multari [1] present an indepth study of stabilization in networks protocols, although the protocols they consider are not explicitly timing-based. In fact, we have found only a few stabilizing protocols in the literature that are explicitly timing-based. Varghese <ref> [2] </ref> mentions that propagation of information with feedback may be achieved in a stabilizing fashion using timing-based actions on a tree network. He also refers to timing-based stabilizing solutions for maintaining spanning trees (due to Perlman), data links and virtual circuits (due to Spinelli).
Reference: [3] <author> A. Arora and D. M. Poduska. </author> <title> A logical foundation of real-time programs. </title> <type> Unpublished Manuscript, </type> <year> 1994. </year>
Reference: [4] <author> E. A. Ashcroft. </author> <title> Proving assertions about parallel programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 10 </volume> <pages> 110-135, </pages> <year> 1975. </year>
Reference-contexts: Intuitively, the state invariant of a protocol is a state predicate that characterizes the "intended" states of protocol execution <ref> [4, 14, 6] </ref>. Thus, every computation of an untimed protocol that starts at a state where its state invariant holds is an intended computation, one that meets the (safety and progress properties of the) problem specification that the protocol satisfies. This method of state invariants remains valid for timing-based protocols.
Reference: [5] <author> E. W. Dijkstra. </author> <title> Self-stabilizing systems in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17(11), </volume> <year> 1974. </year>
Reference: [6] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: Intuitively, the state invariant of a protocol is a state predicate that characterizes the "intended" states of protocol execution <ref> [4, 14, 6] </ref>. Thus, every computation of an untimed protocol that starts at a state where its state invariant holds is an intended computation, one that meets the (safety and progress properties of the) problem specification that the protocol satisfies. This method of state invariants remains valid for timing-based protocols.
Reference: [7] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 890-904, </pages> <year> 1986. </year>
Reference-contexts: This method of state invariants remains valid for timing-based protocols. However, the task of exhibiting the state invariant of timing-based protocols requires knowledge of timing dependencies in the protocol. These timing dependencies can be incorporated within the state invariant, as in <ref> [7, 8] </ref>, or within a separate assertion containing timing properties [9]. We prefer to separate timing assertions from state assertions: first, we exhibit a timing invariant, named T I, and then using T I we exhibit a state invariant, named SI.
Reference: [8] <author> R. Alur and T. A. Henzinger. </author> <title> Real-time logics: Complexity and expressiveness. </title> <type> Technical Report STAN-CS-90-1307, </type> <institution> Stanford University, </institution> <year> 1990. </year>
Reference-contexts: This method of state invariants remains valid for timing-based protocols. However, the task of exhibiting the state invariant of timing-based protocols requires knowledge of timing dependencies in the protocol. These timing dependencies can be incorporated within the state invariant, as in <ref> [7, 8] </ref>, or within a separate assertion containing timing properties [9]. We prefer to separate timing assertions from state assertions: first, we exhibit a timing invariant, named T I, and then using T I we exhibit a state invariant, named SI.
Reference: [9] <author> N. A. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Distributed Computing (PODC), </booktitle> <pages> pages 265-280, </pages> <address> Quebec City, PQ CDN, 1990. </address> <publisher> ACM Press, </publisher> <address> New York, NY, USA. </address>
Reference-contexts: However, the task of exhibiting the state invariant of timing-based protocols requires knowledge of timing dependencies in the protocol. These timing dependencies can be incorporated within the state invariant, as in [7, 8], or within a separate assertion containing timing properties <ref> [9] </ref>. We prefer to separate timing assertions from state assertions: first, we exhibit a timing invariant, named T I, and then using T I we exhibit a state invariant, named SI. <p> Our schema is based on well-established concepts. The protocol notation uses a modified form of Dijkstra's guarded commands [16]; the use of upper and lower time bounds on statement execution is based on earlier work <ref> [9, 15, 17] </ref>; protocols are verified by exhibiting a state invariant and a timing invariant; and, timing invariants are proven using a small number of well understood temporal concepts [15]. Our schema accommodates the exchange of both fixed and time-varying information.
Reference: [10] <author> N. A. Lynch and F. Vaandrager. </author> <title> Forward and backward simulations part ii: </title> <journal> Timing-based systems. Information and Computation, </journal> <volume> 128(1) </volume> <pages> 1-25, </pages> <year> 1996. </year>
Reference: [11] <author> R. Koymans, J. Vytopil, and W. P. de Roever. </author> <title> Real-time programming and asynchronous message passing. </title> <booktitle> In 2nd ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <year> 1983. </year>
Reference-contexts: We choose these two operators because they are well understood and suffice for our purposes. Note also that the fl operator is equivalent to a bounded version of the F operator and the = operator corresponds to a bounded version of the S operator in temporal logic <ref> [11, 15] </ref>. 2.3 Network Assumptions A computer network consists of N nodes and some number of communication channels that each connect a unique pair of nodes.
Reference: [12] <author> A. Arora and D. M. Poduska. </author> <title> A timing-based schema for stabilizing information exchange. </title> <type> Technical Report OSU-CISRC-5/95-TR26, </type> <institution> The Ohio State University, </institution> <year> 1995. </year>
Reference-contexts: The worst case stabilization time of the protocol is (K + 1)T + R. Due to lack of space, we refer the reader to <ref> [12] </ref> for all proofs of timing invariants, state invariants, and stabiliza tion. 3.2 Extensions Tolerating Clock Drift: Thus far we have assumed that all node clocks measure real-time ideally, and hence each node can accurately schedule its iteratively executed action in the interval [S; T ).
Reference: [13] <author> A. Segall. </author> <title> Distributed network protocols. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-29:23-35, </volume> <year> 1983. </year>
Reference-contexts: We restrict our proofs of timing properties to the use of two bounded temporal concepts, namely bounded response and bounded invariance. We use timing properties essentially to exhibit bounds on the convergence time and to deduce untimed properties. A discussion of information exchange protocols appears in Segall <ref> [13] </ref>. His protocols are not stabilizing. They do, however, tolerate topological changes, although unlike our protocols, they use messages of unbounded size to achieve fault-tolerance. Overview of the paper.
Reference: [14] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming, chapter 14. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N. J., </address> <year> 1976. </year>
Reference-contexts: Intuitively, the state invariant of a protocol is a state predicate that characterizes the "intended" states of protocol execution <ref> [4, 14, 6] </ref>. Thus, every computation of an untimed protocol that starts at a state where its state invariant holds is an intended computation, one that meets the (safety and progress properties of the) problem specification that the protocol satisfies. This method of state invariants remains valid for timing-based protocols.
Reference: [15] <author> T. A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> Temporal proof methodologies for real-time systems. </title> <booktitle> In Proceedings of the 18th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 353-366, </pages> <address> Orlando, Florida, Jan-uary 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We choose these two operators because they are well understood and suffice for our purposes. Note also that the fl operator is equivalent to a bounded version of the F operator and the = operator corresponds to a bounded version of the S operator in temporal logic <ref> [11, 15] </ref>. 2.3 Network Assumptions A computer network consists of N nodes and some number of communication channels that each connect a unique pair of nodes. <p> Our schema is based on well-established concepts. The protocol notation uses a modified form of Dijkstra's guarded commands [16]; the use of upper and lower time bounds on statement execution is based on earlier work <ref> [9, 15, 17] </ref>; protocols are verified by exhibiting a state invariant and a timing invariant; and, timing invariants are proven using a small number of well understood temporal concepts [15]. Our schema accommodates the exchange of both fixed and time-varying information. <p> of Dijkstra's guarded commands [16]; the use of upper and lower time bounds on statement execution is based on earlier work [9, 15, 17]; protocols are verified by exhibiting a state invariant and a timing invariant; and, timing invariants are proven using a small number of well understood temporal concepts <ref> [15] </ref>. Our schema accommodates the exchange of both fixed and time-varying information. While protocols for both types of information are developed in the same manner, their implementation is potentially different.
Reference: [16] <author> E. W. Dijkstra. </author> <title> Guarded commands, nondeterminacy and formal derivation of programs. </title> <journal> Communications of the ACM, </journal> <volume> 18(8) </volume> <pages> 453-457, </pages> <year> 1975. </year>
Reference-contexts: Our schema is based on well-established concepts. The protocol notation uses a modified form of Dijkstra's guarded commands <ref> [16] </ref>; the use of upper and lower time bounds on statement execution is based on earlier work [9, 15, 17]; protocols are verified by exhibiting a state invariant and a timing invariant; and, timing invariants are proven using a small number of well understood temporal concepts [15].

References-found: 16

