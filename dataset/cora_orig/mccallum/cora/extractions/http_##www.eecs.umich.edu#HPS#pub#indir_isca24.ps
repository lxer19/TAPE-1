URL: http://www.eecs.umich.edu/HPS/pub/indir_isca24.ps
Refering-URL: http://www.eecs.umich.edu/HPS/hps_branchpred.html
Root-URL: http://www.cs.umich.edu
Email: email: fpychang,ehao,pattg@eecs.umich.edu  
Title: Target Prediction for Indirect Jumps  
Author: Po-Yung Chang Eric Hao Yale N. Patt 
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: As the issue rate and pipeline depth of high performance superscalar processors increase, the amount of speculative work issued also increases. Because speculative work must be thrown away in the event of a branch mispredic-tion, wide-issue, deeply pipelined processors must employ accurate branch predictors to effectively exploit their performance potential. Many existing branch prediction schemes are capable of accurately predicting the direction of conditional branches. However, these schemes are ineffective in predicting the targets of indirect jumps achieving, on average, a prediction accuracy rate of 51.8% for the SPECint95 benchmarks. In this paper, we propose a new prediction mechanism, the target cache, for predicting indirect jump targets. For the perl and gcc benchmarks, this mechanism reduces the indirect jump misprediction rate by 93.4% and 63.3% and the overall execution time by 14% and 5%. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing indirect function call overhead in c++ programs. </title> <booktitle> In 21st Symposium on Principles of Programming Languages, </booktitle> <pages> pages 397-408, </pages> <year> 1994. </year>
Reference-contexts: Section 4 shows the performance benefits of target caches. Section 5 provides some concluding remarks. 2 Related Work To address the problem of target prediction for indirect jumps in C++ programs, Calder and Grunwald proposed a new strategy, the 2-bit strategy, for updating BTB target addresses <ref> [1] </ref>. The default strategy is to update the BTB on every indirect jump misprediction, Calder and Grunwald's 2-bit strategy does not update a BTB entry's target address until two consecutive predictions with that target address are incorrect.
Reference: [2] <author> Po-Yung Chang, Eric Hao, Tse-Yu Yeh, and Yale N. Patt. </author> <title> Branch classification: A new mechanism for improving branch predictor performance. </title> <booktitle> In Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pages 22-31, </pages> <year> 1994. </year>
Reference-contexts: In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [11, 7, 15, 6, 2, 8] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used.
Reference: [3] <author> W. W. Hwu and Yale N. Patt. </author> <title> Checkpoint repair for out-of-order execution machines. </title> <booktitle> In Proceedings of the 14th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 18-26, </pages> <year> 1987. </year>
Reference-contexts: We will concentrate on the gcc and perl benchmarks, the two benchmarks with the largest number of indirect jumps. The machine model simulated is the HPS microarchi-tecture [9] [10]. HPS is a wide-issue out-of-order execution machine, using Tomasulo algorithm for dynamic scheduling [12]. Checkpointing <ref> [3] </ref> is used to maintain precise exceptions. Checkpoints are established for each branch; thus, once a branch misprediction is determined, instructions from the correct path are fetched in the next cycle.
Reference: [4] <author> David R. Kaeli and Philip G. Emma. </author> <title> Branch history table prediction of moving target branches due to subroutine returns. </title> <booktitle> In Proceedings of the 18th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 34-41, </pages> <year> 1991. </year>
Reference-contexts: As the program executes, the target cache records the target for each indirect jump target encountered. When fetching an indirect jump, 1 Although return instructions technically are indirect jumps, they are not handled with the target cache because they are effectively handled with the return address stack <ref> [13, 4] </ref>. Ind. Jump Benchmark Input #Instructions #Branches #Indirect Jumps Mispred.
Reference: [5] <author> David R. Kaeli and Philip G. Emma. </author> <title> Improving the accuracy of history-based branch prediction. </title> <journal> IEEE Transactions on Computers, </journal> <month> April </month> <year> 1994. </year>
Reference-contexts: BTB 2-bit BTB compress 61.7% 44.4% gcc 66.0% 64.1% ijpeg 14.3% 9.36% m88ksim 37.3% 38.1% perl 76.4% 67.5% vortex 11.3% 14.6% xlisp 80.7% 85.4% Table 2: Performance of 2-bit BTB Kaeli et al. proposed a hardware mechanism, the case block table (CBT), to speed up the execution of SWITCH/CASE statements <ref> [5] </ref>. Figure 9 gives an example of a SWITCH/CASE statement and the corresponding assembly code for that statement. The assembly code consists of a series of conditional branches that determine which case of the SWITCH/CASE statement is to be executed.
Reference: [6] <author> Scott McFarling. </author> <title> Combining branch predictors. </title> <type> Tech--nical Report TN-36, </type> <institution> Digital Western Research Laboratory, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [11, 7, 15, 6, 2, 8] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used.
Reference: [7] <author> Scott McFarling and John Hennessy. </author> <title> Reducing the cost of branches. </title> <booktitle> In Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 396-403, </pages> <year> 1986. </year>
Reference-contexts: In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [11, 7, 15, 6, 2, 8] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used.
Reference: [8] <author> Ravi Nair. </author> <title> Dynamic path-based branch correlation. </title> <booktitle> In Proceedings of the 28th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pages 15-23, </pages> <year> 1995. </year>
Reference-contexts: In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [11, 7, 15, 6, 2, 8] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used. <p> No extra hardware is required to maintain the branch history for the target cache if the branch prediction mechanism already contains this information. The target cache can use the branch predictor's branch history register. * Path History Previous research <ref> [16, 8] </ref> has shown that path history can also provide useful correlation information to improve branch prediction accuracy. Path history consists of the target addresses of branches that lead to the current branch. This information is also useful in predicting indirect branch targets.
Reference: [9] <author> Yale Patt, W. Hwu, and Michael Shebanow. HPS, </author> <title> a new microarchitecture: Rationale and introduction. </title> <booktitle> In Proceedings of the 18th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pages 103-107, </pages> <year> 1985. </year>
Reference-contexts: Table 1 (see Section 1) lists the input data set used for each benchmark and the dynamic instruction counts. We will concentrate on the gcc and perl benchmarks, the two benchmarks with the largest number of indirect jumps. The machine model simulated is the HPS microarchi-tecture <ref> [9] </ref> [10]. HPS is a wide-issue out-of-order execution machine, using Tomasulo algorithm for dynamic scheduling [12]. Checkpointing [3] is used to maintain precise exceptions. Checkpoints are established for each branch; thus, once a branch misprediction is determined, instructions from the correct path are fetched in the next cycle.
Reference: [10] <author> Yale N. Patt, Steven W. Melvin, W. Hwu, and Michael C. Shebanow. </author> <title> Critical issues regarding HPS, a high performance microarchitecture. </title> <booktitle> In Proceedings of the 18th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pages 109-116, </pages> <year> 1985. </year>
Reference-contexts: Table 1 (see Section 1) lists the input data set used for each benchmark and the dynamic instruction counts. We will concentrate on the gcc and perl benchmarks, the two benchmarks with the largest number of indirect jumps. The machine model simulated is the HPS microarchi-tecture [9] <ref> [10] </ref>. HPS is a wide-issue out-of-order execution machine, using Tomasulo algorithm for dynamic scheduling [12]. Checkpointing [3] is used to maintain precise exceptions. Checkpoints are established for each branch; thus, once a branch misprediction is determined, instructions from the correct path are fetched in the next cycle.
Reference: [11] <author> James E. Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> In Proceedings of the 8th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 135-148, </pages> <year> 1981. </year>
Reference-contexts: In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [11, 7, 15, 6, 2, 8] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used.
Reference: [12] <author> R. M. Tomasulo. </author> <title> An efficient algorithm for exploiting multiple arithmetic units. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 11 </volume> <pages> 25-33, </pages> <month> January </month> <year> 1967. </year>
Reference-contexts: We will concentrate on the gcc and perl benchmarks, the two benchmarks with the largest number of indirect jumps. The machine model simulated is the HPS microarchi-tecture [9] [10]. HPS is a wide-issue out-of-order execution machine, using Tomasulo algorithm for dynamic scheduling <ref> [12] </ref>. Checkpointing [3] is used to maintain precise exceptions. Checkpoints are established for each branch; thus, once a branch misprediction is determined, instructions from the correct path are fetched in the next cycle.
Reference: [13] <author> C. F. Webb. </author> <title> Subroutine call/return stack. </title> <journal> IBM Technical Disclosure Bulletin, </journal> <volume> 30(11), </volume> <month> April </month> <year> 1988. </year>
Reference-contexts: As the program executes, the target cache records the target for each indirect jump target encountered. When fetching an indirect jump, 1 Although return instructions technically are indirect jumps, they are not handled with the target cache because they are effectively handled with the return address stack <ref> [13, 4] </ref>. Ind. Jump Benchmark Input #Instructions #Branches #Indirect Jumps Mispred.
Reference: [14] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> Two-level adaptive branch prediction. </title> <booktitle> In Proceedings of the 24th Annual ACM/IEEE International Symposium on Microarchi-tecture, </booktitle> <pages> pages 51-61, </pages> <year> 1991. </year>
Reference-contexts: Two types of branch history information are used to decide which target of the indirect jump will be predicted pattern history and path history. * Branch History It is now well known that the 2-level branch predictor improves prediction accuracy over previous single-level branch predictors <ref> [14] </ref>. The 2-level predictors attain high prediction accuracies by using pattern history to distinguish different dynamic occurrences of a conditional branch. To predict indirect jumps, the target cache is indexed using branch address and global pattern history. Global pattern history is a recording of the last n conditional branches.
Reference: [15] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> A comparison of dynamic branch predictors that use two levels of branch history. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 257-266, </pages> <year> 1993. </year>
Reference-contexts: In the past, branch prediction research has focused on accurately predicting conditional and unconditional direct branches <ref> [11, 7, 15, 6, 2, 8] </ref>. To predict such branches, the prediction mechanism predicts the branch direction (for unconditional branches, this part is trivial) and then generates the target associated with that direction. To generate target addresses, a branch target buffer (BTB) is used.
Reference: [16] <author> Cliff Young and Michael D. Smith. </author> <title> Improving the accuracy of static branch prediction using branch correlation. </title> <booktitle> In Proceedings of the 6th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 232-241, </pages> <year> 1994. </year>
Reference-contexts: No extra hardware is required to maintain the branch history for the target cache if the branch prediction mechanism already contains this information. The target cache can use the branch predictor's branch history register. * Path History Previous research <ref> [16, 8] </ref> has shown that path history can also provide useful correlation information to improve branch prediction accuracy. Path history consists of the target addresses of branches that lead to the current branch. This information is also useful in predicting indirect branch targets.
References-found: 16

