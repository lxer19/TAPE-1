URL: http://www.cs.umn.edu/crisys/Publications/tse-analysis.ps
Refering-URL: http://www.cs.umn.edu/crisys/pubs.htm
Root-URL: http://www.cs.umn.edu
Email: heimdahl@cps.msu.edu  leveson@cs.washington.edu  
Title: Completeness and Consistency in Hierarchical State-Based Requirements  
Author: Mats P.E. Heimdahl Nancy G. Leveson 
Keyword: Index Terms: completeness, consistency, static analysis, reactive systems, state based requirements, formal semantics, formal methods  
Address: A-714 Wells Hall East Lansing, Michigan 48824-1027  FR-35 Seattle, WA 98195  
Affiliation: Michigan State University Department of Computer Science,  University of Washington Computer Science and Engineering,  
Abstract: This paper describes methods for automatically analyzing formal, state-based requirements specifications for some aspects of completeness and consistency. The approach uses a low-level functional formalism, simplifying the analysis process. State-space explosion problems are eliminated by applying the analysis at a high level of abstraction; i.e., instead of generating a reachability graph for analysis, the analysis is performed directly on the model. The method scales up to large systems by decomposing the specification into smaller, analyzable parts and then using functional composition rules to ensure that verified properties hold for the entire specification. The analysis algorithms and tools have been validated on TCAS II, a complex, airborne, collision-avoidance system required on all commercial aircraft with more than 30 passengers that fly in U.S. airspace. fl This work has been partially supported by NSF Grant CCR-9006279, NASA Grant NAG-1-668, and NSF CER Grant DCR-8521398. y This paper has appeared in IEEE Transactions on Software Engineering, vol. 22, no. 6, pp. 363-377, June 1996. Copyright 1996 by The Institute of Electrical and Electronics Engineering, Inc. All rights reserved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Atlee and J. Gannon. </author> <title> State-based model checking of event-driven system requirements. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Conference on Software for Critical Systems. Software Engineering Notes. </booktitle> <volume> Volume 16 Number 5, </volume> <year> 1991. </year>
Reference-contexts: The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem. Model checking: Model checking is conceptually simple and is applicable in a wide variety of languages and application areas <ref> [1, 6, 7] </ref>. Early work in model checking also relied on a global reachability graph. Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the 3 state space can significantly improve the performance of the model checking approach [5].
Reference: [2] <author> G. R. Bruns, S. L. Gerhart, I. Forman, and M. Graf. </author> <title> Design Technology Assessment: The Statecharts Approach. </title> <type> Technical Report STP-107-86, </type> <institution> MCC, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: Viewing an RSML specification as a mathematical relation is the basis for our formalization of the language and will be described in detail in Section 3. AND/OR Tables. Statecharts use predicate calculus to describe the guarding conditions on the transitions <ref> [2, 9] </ref>. Our TCAS external reviewers (including avionics engineers, component engineers, airline representatives, and pilots), however, did not find this notation natural or reviewable.
Reference: [3] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: The conditions for state transition in TCAS II are quite complex, resulting in many cases in large tables and requiring costly logical and and or operations on the transitions (satisfiability of boolean functions is known to be an N P problem). Our analysis tools use Binary Decision Diagrams (BDDs) <ref> [3] </ref> for the manipulation of the conditions. BDDs are data structures used to represent boolean functions in a canonical form. Initially, our main concern was the performance of the and and or operations needed to check for mutual exclusion and 17 complete coverage.
Reference: [4] <author> J.R. Burch, E.M. Clarke, D.E. Long, K.L. McMillan, and D.L. Dill. </author> <title> Symbolic model chacking for sequential circuit verification. </title> <type> Technical Report CMU-CS-93-211, </type> <institution> Carnegie Mellon University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the 3 state space can significantly improve the performance of the model checking approach [5]. Symbolic model checking has been applied to large models <ref> [5, 4] </ref>, but only for systems with simple, repetitive elements|such as those commonly found in hardware applications. The time and space complexity of the symbolic approach is affected not only by the size of the specification but also by the regularity of specification.
Reference: [5] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Early work in model checking also relied on a global reachability graph. Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the 3 state space can significantly improve the performance of the model checking approach <ref> [5] </ref>. Symbolic model checking has been applied to large models [5, 4], but only for systems with simple, repetitive elements|such as those commonly found in hardware applications. <p> Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the 3 state space can significantly improve the performance of the model checking approach [5]. Symbolic model checking has been applied to large models <ref> [5, 4] </ref>, but only for systems with simple, repetitive elements|such as those commonly found in hardware applications. The time and space complexity of the symbolic approach is affected not only by the size of the specification but also by the regularity of specification.
Reference: [6] <author> E. M. Clarke, M. C. Browne, E. A. Emerson, and A. P. Sistla. </author> <title> Using temporal logic for automatic verification of finite state systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 3-26. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem. Model checking: Model checking is conceptually simple and is applicable in a wide variety of languages and application areas <ref> [1, 6, 7] </ref>. Early work in model checking also relied on a global reachability graph. Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the 3 state space can significantly improve the performance of the model checking approach [5].
Reference: [7] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem. Model checking: Model checking is conceptually simple and is applicable in a wide variety of languages and application areas <ref> [1, 6, 7] </ref>. Early work in model checking also relied on a global reachability graph. Consequently, the approach suffered from state-space explosion problems. Newer approaches relying on a symbolic representation of the 3 state space can significantly improve the performance of the model checking approach [5].
Reference: [8] <author> P. Godefroid, G.J. Holzmann, and D. Pirottin. </author> <title> State space caching revisited. </title> <booktitle> In Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 175-186, </pages> <year> 1992. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to derive, and these approaches may not be practical for complex systems. Reachability analysis: Modeling a system as a finite-state machine and then performing reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [8, 18, 19] </ref>. The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem.
Reference: [9] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Section 6 presents conclusions. 2 Overview of the RSML Notation RSML is a state-based requirements specification language suitable for the specification of reactive systems. RSML includes several features developed by Harel for Statecharts <ref> [9, 10] </ref>: superstates, AND decomposition, broadcast communication, and conditional connectives. 4 In addition, RSML has some unique syntactic and semantic features that were developed to enhance readability, reviewability, and analyzability and our ability to handle complex systems. A complete description of RSML is provided in [23]. <p> Viewing an RSML specification as a mathematical relation is the basis for our formalization of the language and will be described in detail in Section 3. AND/OR Tables. Statecharts use predicate calculus to describe the guarding conditions on the transitions <ref> [2, 9] </ref>. Our TCAS external reviewers (including avionics engineers, component engineers, airline representatives, and pilots), however, did not find this notation natural or reviewable.
Reference: [10] <author> D. Harel and A. Naamad. </author> <title> The STATEMATE semantics of Statecharts. </title> <type> Technical Report CS95-31, </type> <institution> The Weizmann Institute of Science, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: Section 6 presents conclusions. 2 Overview of the RSML Notation RSML is a state-based requirements specification language suitable for the specification of reactive systems. RSML includes several features developed by Harel for Statecharts <ref> [9, 10] </ref>: superstates, AND decomposition, broadcast communication, and conditional connectives. 4 In addition, RSML has some unique syntactic and semantic features that were developed to enhance readability, reviewability, and analyzability and our ability to handle complex systems. A complete description of RSML is provided in [23].
Reference: [11] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: This type of software is often reactive in that it must react or respond to environmental conditions as reflected in the inputs arriving at the software boundary <ref> [11] </ref>. A robust system will detect and respond appropriately to violations of assumptions about the system environment (such as unexpected inputs). Robustness with respect to a state-machine description implies the following: 1. Every state must have a behavior (transition) defined for every possible input. 2.
Reference: [12] <author> D. Harel, A. Pnueli, J.P. Schmidt, and R. Sherman. </author> <title> On the formal semantics of statecharts (extended abstract). </title> <booktitle> In 2nd Symposium on Logic in Computer Science, </booktitle> <pages> pages 54-64, </pages> <address> Ithaca, NY, </address> <year> 1987. </year>
Reference-contexts: The restrictions governing the structure of a global state have been formally defined for Statecharts by Harel et al. <ref> [12] </ref>. These definitions are also applicable to RSML. Although the definitions are not essential for understanding the remainder of the paper, for completeness they have been included in Appendix A. The remainder of this section is devoted to the next-state relation F .
Reference: [13] <author> M. P.E. Heimdahl. </author> <title> Static Analysis of State-Based Requirements: Analysis for Completeness and Consistency. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <year> 1994. </year> <month> 28 </month>
Reference-contexts: Fortunately, the number of parallel transitions in real systems seems to be fairly limited, and this straight forward approach has been shown to be adequate to analyze a major part of a large real life system (TCAS II) for determinism <ref> [13] </ref>. In summary, the algorithms described in this paper are all quite simple. This simplicity results from, and is an advantage of, our functional definition of the semantics of RSML. Unfortunately, the algorithms outlined above all have high worst-case complexity.
Reference: [14] <author> M. P.E. Heimdahl and N.G. Leveson. </author> <title> Completeness and Consistency Analysis of State-Based Requirements. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: T . . . . . T . . . Own_Alt_Radio &lt;= ZSL5TO4 : . F . . . . . F . . . 5.1.1 Spurious Error Reports During initial experiments with our first prototype tool, spurious error reports were not a serious problem <ref> [14] </ref>. All spurious reports could be traced either to (1) a lack of type checking capability or (2) the inability of the tool to adequately include information about the structure of the state machine in the analysis.
Reference: [15] <author> C. L. Heitmeyer, B. L. Labaw, and D. Kiskis. </author> <title> Consistency checking of SCR-style requirements specifications. </title> <booktitle> In Proceedings of the International Symposium on Requirements Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Our approach differs from these techniques in that it performs the analysis directly on a high-level requirements model without generating a global reachability graph. Thus, the analysis is both conceptually simple and eliminates the problem with state-space explosion. Recently, Heitmeyer, Labow, and Kiskis have published a paper <ref> [15] </ref> discussing some aspects of consistency and completeness in the context of SCR-style (Software Cost Reduction [16, 17]) requirements specifications. SCR is a state-based approach using an assortment of tabular notations to define state transitions (or mode transitions as they are called in SCR) and output variables. <p> SCR is a state-based approach using an assortment of tabular notations to define state transitions (or mode transitions as they are called in SCR) and output variables. The consistency checks described in <ref> [15] </ref> are concerned with language properties such as proper syntax of the specification and type correctness, as well as a notion of local consistency and completeness of individual tables. The latter notion of consistency of tables is similar to the completeness and consistency properties we are investigating in this paper.
Reference: [16] <author> K. L. Heninger. </author> <title> Specifying software for complex systems: New techniques and their application. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(1) </volume> <pages> 2-13, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Thus, the analysis is both conceptually simple and eliminates the problem with state-space explosion. Recently, Heitmeyer, Labow, and Kiskis have published a paper [15] discussing some aspects of consistency and completeness in the context of SCR-style (Software Cost Reduction <ref> [16, 17] </ref>) requirements specifications. SCR is a state-based approach using an assortment of tabular notations to define state transitions (or mode transitions as they are called in SCR) and output variables.
Reference: [17] <author> K.L. Heninger, J.W. Kallander, J.E. Shore, and D.L. Parnas. </author> <title> Software Requirements for the A-7e Aircraft. </title> <type> Technical Report 3876, </type> <institution> Naval Research Laboratory, </institution> <address> Washington, D.C., </address> <month> November </month> <year> 1978. </year>
Reference-contexts: Thus, the analysis is both conceptually simple and eliminates the problem with state-space explosion. Recently, Heitmeyer, Labow, and Kiskis have published a paper [15] discussing some aspects of consistency and completeness in the context of SCR-style (Software Cost Reduction <ref> [16, 17] </ref>) requirements specifications. SCR is a state-based approach using an assortment of tabular notations to define state transitions (or mode transitions as they are called in SCR) and output variables.
Reference: [18] <author> G.J. Holzmann. </author> <title> Tracing protocols. </title> <journal> AT& T Technical Journal, </journal> <volume> 64(10), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to derive, and these approaches may not be practical for complex systems. Reachability analysis: Modeling a system as a finite-state machine and then performing reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [8, 18, 19] </ref>. The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem.
Reference: [19] <author> G.J. Holzmann. </author> <title> Automated protocol validation in Argos: Assertion proving and scatter searching. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(6) </volume> <pages> 683-696, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to derive, and these approaches may not be practical for complex systems. Reachability analysis: Modeling a system as a finite-state machine and then performing reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [8, 18, 19] </ref>. The main problem with reachability analysis is that it relies on the generation of a global reachability graph and, therefore, quickly runs into a state-space explosion problem.
Reference: [20] <author> M. S. Jaffe, N. G. Leveson, M. P.E. Heimdahl, and B. Melhart. </author> <title> Software requirements analysis for real-time process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 241-258, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: The definition of specification completeness provided by Jaffe was subsequently formalized using a simple Mealy-machine model called RSM (Requirements State Machine) <ref> [20] </ref>. The RSM notation was developed solely as a means for formally defining our criteria, and lacks most desirable properties of a true requirements specification language. To be useful in practical applications, these criteria need to be translated into criteria applicable to a real specification language. <p> However, safety-critical software should not be incompletely specified. In <ref> [20] </ref>, we define requirements completeness as the specification being sufficient to distinguish the behavior of the desired software from that of any other, undesired program that might be designed. Nondeterministic specifications often hide dangerous incompleteness in this sense. <p> Our long term goal is to provide a suite of analysis tools to help find a wide variety of flaws in software requirements early during software development. Many desirable properties of requirements specification have been defined by Jaffe et al. <ref> [20] </ref>, for example, non-reachability of hazardous states and path robustness properties. Additional properties are being defined for the human-computer interface (see Leveson [24] for some of the new criteria).
Reference: [21] <author> M.S. Jaffe. </author> <title> Completeness, Robustness, and Safety in Real-Time Software Requirements and Specifications. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <year> 1988. </year>
Reference-contexts: Jaffe, in his dissertation, defined a rigorous basis for ascertaining whether or not a given set of software requirements is internally complete, i.e, closed with respect to statements and inferences that can be made on the basis of information included in the specification <ref> [21] </ref>. Emphasis is placed on aspects of requirements specification that are usually not adequately handled, including timing and robustness, and on aspects that are particularly related to safety and accidents.
Reference: [22] <author> N. G. Leveson, M. Heimdahl, H. Hildreth, and J. Reese. </author> <title> TCAS II Requirements Specification. </title>
Reference-contexts: To ensure that the formal RSML specification language and the associated analysis algorithms and tools are appropriate for large and realistic systems, a testbed specification was developed for TCAS II <ref> [22] </ref>. The testbed is currently being used to develop and validate various types of analysis algorithms and tools on the underlying formal model. <p> Although the TCAS specification effort was originally planned to be experimental only, the government/industry groups responsible for TCAS II liked RSML so much that the specification was adopted as the official FAA TCAS II System Requirements Specification <ref> [22] </ref>. As a result, our initial baseline specification was subjected to an extensive (and expensive) independent verification and validation (IV&V) effort. We have applied the analysis techniques described in this paper to major parts of our baseline TCAS II specification.
Reference: [23] <author> N. G. Leveson, M. P.E. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: RSML was developed by the Irvine Safety Research Group using a real aircraft collision-avoidance system called TCAS II (Traffic alert and Collision Avoidance System II) as a testbed <ref> [23] </ref>. <p> A complete description of RSML is provided in <ref> [23] </ref>. This section contains only a description of the RSML features necessary to understand this paper. A simple finite-state machine is composed of states connected by transitions (see Figure 1). Default or start states are signified by states whose connecting transition has no source.
Reference: [24] <author> N.G. Leveson. Safeware: </author> <title> System Safety and Computers. </title> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference-contexts: that many serious conceptual errors are introduced in this first stage of software development|errors introduced during the requirements stage have been shown to be more difficult and more expensive to correct than errors introduced later in the lifecycle, and they are more likely than implementation errors to be safety critical <ref> [24, 25] </ref>. Therefore, it is important to provide methods and techniques to eliminate requirements-related errors as early as possible. To provide analysis procedures to find errors in specifications, it is first necessary to determine the desirable properties of a specification. <p> Many desirable properties of requirements specification have been defined by Jaffe et al. [20], for example, non-reachability of hazardous states and path robustness properties. Additional properties are being defined for the human-computer interface (see Leveson <ref> [24] </ref> for some of the new criteria). Our goal is to formally define these properties in the RSML framework (and develop new ones suitable to this new framework) and provide efficient automated analysis procedures for these properties.
Reference: [25] <author> R. Lutz. </author> <title> Targeting safety-related errors during software requirements analysis. </title> <booktitle> In Proceedings of the First ACM SOGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: that many serious conceptual errors are introduced in this first stage of software development|errors introduced during the requirements stage have been shown to be more difficult and more expensive to correct than errors introduced later in the lifecycle, and they are more likely than implementation errors to be safety critical <ref> [24, 25] </ref>. Therefore, it is important to provide methods and techniques to eliminate requirements-related errors as early as possible. To provide analysis procedures to find errors in specifications, it is first necessary to determine the desirable properties of a specification.
Reference: [26] <author> A. Pnueli and M. Shalev. </author> <title> What is in a step? In J. </title> <editor> Klop, J. Meijer, and J. Rutten, editors, J.W. De Baker, </editor> <booktitle> Liber Amicorum, </booktitle> <pages> pages 373-400. </pages> <address> CWI Amsterdam, </address> <year> 1989. </year>
Reference: [27] <author> A. P. Ravn and H. Richel. </author> <title> Requirements capture for embedded real-time systems. </title> <booktitle> In IMACS Symposium MCTS, </booktitle> <year> 1991. </year>
Reference-contexts: Formal proof systems: Formal proof systems can be powerful tools in the verification of critical properties of algorithms [29]. Attempts have been made to extend the use of formal proofs and apply them to requirements specifications, for example, the ProCoS (Provably Correct Systems) project <ref> [27, 28] </ref>. Unfortunately, the languages used in the theorem proving approach, such as process algebras and higher order logics, are not understandable by the non-software professionals involved in most requirements specification efforts and thus are not (in our opinion) suitable as high-level requirements languages.
Reference: [28] <author> H. Richel and A. P. Ravn. </author> <title> Requirements capture for computer based systems. </title> <type> Technical Report ID/DTH HR 2/2, </type> <institution> Technical University of Denmark, </institution> <month> October </month> <year> 1990. </year> <month> 29 </month>
Reference-contexts: Formal proof systems: Formal proof systems can be powerful tools in the verification of critical properties of algorithms [29]. Attempts have been made to extend the use of formal proofs and apply them to requirements specifications, for example, the ProCoS (Provably Correct Systems) project <ref> [27, 28] </ref>. Unfortunately, the languages used in the theorem proving approach, such as process algebras and higher order logics, are not understandable by the non-software professionals involved in most requirements specification efforts and thus are not (in our opinion) suitable as high-level requirements languages.
Reference: [29] <author> J. Rushby and F. von Henke. </author> <title> Formal verification of algorithms for critical systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 13-23, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Related approaches to requirements analysis include methods based on formal proof systems and different static analysis techniques such as reachability analysis and model checking. Formal proof systems: Formal proof systems can be powerful tools in the verification of critical properties of algorithms <ref> [29] </ref>. Attempts have been made to extend the use of formal proofs and apply them to requirements specifications, for example, the ProCoS (Provably Correct Systems) project [27, 28].
References-found: 29

