URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS95-02.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: stephane.grumbach@inria.fr  su@cs.ucsb.edu  
Title: Finitely Representable Databases  
Author: Stephane Grumbach Jianwen Su flfl 
Date: February 6, 1995  
Address: Rocquencourt BP 105 78153 Le Chesnay, France  Santa Barbara, CA 93106, USA  
Affiliation: I.N.R.I.A.  Computer Science Department University of California  
Abstract: We study classes of infinite but finitely representable databases based on constraints, motivated by new database applications such as geographical databases. We formally define these notions and introduce the concept of query which generalizes queries over classical relational databases. We prove that in this context the basic properties of queries (satisfiability, containment, equivalence, etc.) are nonrecursive. We investigate the theory of finitely representable models and prove that it differs strongly from both classical model theory and finite model theory. In particular, we show that most of the well known theorems of either one fail (compactness, completeness, locality, 0/1 laws, etc.). An immediate consequence is the lack of tools to consider the definability of queries in the relational calculus over finitely representable databases. We illustrate this very challenging problem through some classical examples. We then mainly concentrate on dense order databases, and exhibit some new techniques to prove non first-order definability results. The techniques include complexity theoretical arguments and Ehrenfeucht-Frasse games. In particular, we show that queries over finite relations such as parity and graph connectivity, as well as topological queries such as region connectivity, existence of a hole, Eulerian traversal, homeomorphism, etc. are not first-order definable. We also show that inflationary Datalog with negation captures exactly all dense order queries computable in PTIME. y An extended abstract [GS94] of this paper appeared in Proc. ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, 1994. fl Work supported in part by Esprit Project BRA AMUSING. flfl Work supported in part by NSF grants IRI-9109520 and IRI-9117094 and NASA grant NAGW-3888. A part of work was done while visiting I.N.R.I.A. 
Abstract-found: 1
Intro-found: 1
Reference: [ACGK94] <author> F. Afrati, S. Cosmadakis, S. Grumbach, and G. Kuper. </author> <title> Expressiveness of linear vs. polynomial constraints in database query languages. </title> <booktitle> In Proc. Workshop on the Principles and Practice of Constraint Programming, </booktitle> <publisher> LNCS, </publisher> <year> 1994. </year>
Reference-contexts: They are quite intuitive when the language does not contain arithmetic operation, and is restricted to equality and an order relation. Once arithmetic is allowed, the combinatorics becomes rather tedious, though in some cases, proofs can still be carried out <ref> [ACGK94] </ref>. Complexity theoretic arguments can also be used to prove non-definability results. It has been shown that some rather low upper bounds, in terms of boolean circuits, of the relational algebra over finite structures carry over in the case of finitely representable structures.
Reference: [AHV94] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The process ends when S stops growing. Finally, if S is the same as R, the algorithm stops and answers "the region is connected"; otherwise, it is "not connected". It is clear that this is expressible by a fixpoint query, and by a known translation technique (cf <ref> [AHV94] </ref>), it can be expressed in DATALOG : . ut Note that in the above example, the number of sweeps needed in the DATALOG : program is roughly the number of necessary "turns" the input relation contains, which depends on the number of constraints in the input.
Reference: [Aj83] <author> M. Ajtai. </author> <title> 1 1 formulae on finite structures. </title> <journal> Ann. of Pure and Applied Logic, </journal> <volume> Vol 24, </volume> <pages> pages 1-48, </pages> <year> 1983. </year>
Reference-contexts: We next present an alternative complexity theoretic proof of the non definability of the region connectivity query in the case k 3. Essentially, it is a reduction from the parity query that is known to be outside of AC 0 <ref> [FSS84, Aj83] </ref>. The reduction is first-order [Imm87], and so in AC 0 . Let fa 1 ; : : : ; a n g be the set of elements.
Reference: [AV91] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 62-124, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Recall that PTIME Q is the set of all dense order queries computable in PTIME. We show that DATALOG : expresses exactly the set of all queries in PTIME Q . This extends the result that inflationary DATALOG : captures all relational queries in the context of finite databases <ref> [AV91] </ref>. Datalog with constraints is defined as follows. Constraints are allowed in the bodies of rules. For DATALOG : , negations are allowed in the bodies of rules. The inflationary semantics is computed by adding after iteration the set of facts just derived to the set previously obtained.
Reference: [BJM93] <author> A. Brodsky, J. Jaffar, and M. J. Maher. </author> <title> Towards practical constraint databases. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases, </booktitle> <pages> pages 567-580, </pages> <year> 1993. </year>
Reference-contexts: Typical examples are temporal and spatial data. A new generation of data models for infinite collections of data items is starting to emerge in the literature (e.g., <ref> [KKR90, Rev90, Kup93a, BJM93] </ref>). We believe that in developing data models and languages for infinite data, there are two fundamental principles that should govern the choice of such a data model: (i) infinite databases should admit a finite representation, and (ii) a reasonable set of queries should be tractable.
Reference: [BKR86] <author> M. Ben-Or, D. Kozen, and J. Reif. </author> <title> The complexity of elementary algebra and geometry. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 32(2) </volume> <pages> 251-264, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The theory also admit quantifier elimination procedures [CK73]. The data complexity of queries over (R; )-instances has been studied in [KKR90]. Queries queries in L fi [ over L fi - representable (R; )-instances are computable in NC data complexity <ref> [BKR86, KKR90] </ref>. On the other hand, the only automorphism of R is the identity mapping. Hence, under Definition 4.2, if is a signature, then each partial recursive collection of L fi -representable (R; )-instances is a boolean query over R.
Reference: [CH80] <author> A. K. Chandra and D. Harel. </author> <title> Computable queries for relational data bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-78, </pages> <year> 1980. </year>
Reference-contexts: query languages for infinite recursive databases were reported by Hirst and Harel in [HH93], where two classes of recursive databases are considered, and it is shown that: (i) quantifier free first-order logic is complete on the class of all recursive databases, and (ii) a version of Chandra and Harel's QL <ref> [CH80] </ref> is complete on highly symmetric databases. The first result of [HH93] indicates that the class of recursive structures is much to general for database purposes, since quantifier free first-order logic is already complete on this class. Therefore, many basic queries are simply not computable (projection, connectivity, etc.). <p> Second, we define the notions of a boolean and non boolean query and show that they generalize the classical notion of a query introduced by Chandra and Harel <ref> [CH80] </ref>. It is established that the existence of quantifier elimination procedure of the (complete) theory of a first order structure is a necessary and sufficient condition for a formula in the first order language to define a (non) boolean query. <p> Some results were obtained for very specific languages (see [Com88]). They do not carry over in the general case. 4 Queries The notion of a database query was introduced by Chandra and Harel <ref> [CH80] </ref> as a mapping Q from structures over a given signature to relations of a fixed arity n, which is partial recursive and satisfies the following consistency criterion: If two structures over , A and B are isomorphic by an isomorphism , then Q (A) and Q (B) are isomorphic by <p> Intuitively, Condition (1) in Definition 4.2 states that either all equivalent representations of (finitely representable) "databases" are in a boolean query K or none of them is. Condition (2) is a natural generalization of the classical notion of genericity <ref> [CH80] </ref> where permutations of the universe U (i.e. automorphisms of the structure hU; =i) are replaced by automorphisms of the underlying more complex structure A. <p> In other words, it was shown that PTIME relational input/output inflationary DATALOG : PTIME dense-order input/input = PTIME Q . In our result, PTIME Q denotes a set of queries over dense-order constraint databases, and not over relational databases as defined in <ref> [CH80] </ref>. ut The proof of Theorem 5.10 relies on a syntactic normal form of the instances, called maximal cover. For simplicity, we consider only relations in dimension 2 and it will be clear how to generalize the following to relations of arbitrary arity. Suppose that R is some binary relation.
Reference: [CK73] <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory, </title> <booktitle> volume 73 of Studies in Logic. </booktitle> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: R = hR; =; ; +; fi; (q) q2A i, over the language L fi = f=; ; fi; +g [ A, where A is the set of algebraic numbers. 5 Note that the structure Q satisfies the theory of dense order without endpoints, which is known to be complete <ref> [CK73] </ref>. Moreover, it admits the elimination of quantifiers, which as we will see in the following is a fundamental property. The structure R satisfies the theory of ordered real closed fields which, like the theory of dense order without endpoints, is also complete and admits the elimination of quantifiers [CK73]. <p> complete <ref> [CK73] </ref>. Moreover, it admits the elimination of quantifiers, which as we will see in the following is a fundamental property. The structure R satisfies the theory of ordered real closed fields which, like the theory of dense order without endpoints, is also complete and admits the elimination of quantifiers [CK73]. Note that the languages considered contain a constant symbol for each rational number in the case of Q, and for each algebraic number in the case of R. This will be necessary in representing databases finitely (see Definition 2.2). <p> Then the result follows from the decidability of the theory of A. 2 The theory of dense order without endpoints and the theory of real closed fields mentioned above are decidable <ref> [CK73] </ref>. Therefore, validity over finitely representable databases over, for instances, Q and R is co-r.e. We will see below that it is not r.e. We next prove that in general the set of first-order sentences satisfiable over finitely representable models is not recursive. <p> The proof techniques for non-definability results include Ehrenfeucht-Frasse games and data complexity arguments. Q is a model of the theory of dense order without endpoints. The theory is decidable and admits quantifier elimination procedures <ref> [CK73] </ref>. Let R = (R; ) be the structure of 1 Or any other device such as a family of boolean circuits in the case of parallel complexity classes. 19 the real dense order. <p> R is a model of the theory of real closed fields. The theory also admit quantifier elimination procedures <ref> [CK73] </ref>. The data complexity of queries over (R; )-instances has been studied in [KKR90]. Queries queries in L fi [ over L fi - representable (R; )-instances are computable in NC data complexity [BKR86, KKR90]. On the other hand, the only automorphism of R is the identity mapping.
Reference: [Cod70] <author> E.F. Codd. </author> <title> A relational model of data for large shared data banks. </title> <journal> Communi cations of ACM, </journal> <volume> 13:6:377-387, </volume> <year> 1970. </year>
Reference-contexts: Our framework follows and generalizes the pioneer 1 work by Kanellakis, Kuper, and Revesz who introduced the constraint query languages in [KKR90]. The basic idea in [KKR90] is to generalize the relations of the relational model <ref> [Cod70] </ref> by defining generalized tuples as conjunctions of constraints. For instance, the formula x 2 + y 2 = 1 ^ x 0 defines a binary generalized tuple. A generalized, or finitely representable, relation is then a finite set of such tuples. <p> A k-ary finitely representable relation (or generalized relation in [KKR90]) is then a finite set of k-ary generalized tuples. In this framework, a tuple [a; b] in the context of classical relational databases <ref> [Cod70] </ref> is an abbreviation for the formula (x = a^y = b) represented using only the equality symbol, "=", and constants. A triangle (x y ^ x 0 ^ y 10) is also a generalized tuple represented using only "" and constants.
Reference: [Col75] <author> G. E. Collins. </author> <title> Quantifier elimination for real closed fields by cylindric decompositions. </title> <booktitle> In Proc. 2nd GI Conf. Automata Theory and Formal Languages, volume 35 of Lecture Notes in Computer Science, </booktitle> <pages> pages 134-83. </pages> <publisher> Springer-Verlag, </publisher> <year> 1975. </year>
Reference-contexts: This follows easily from results in <ref> [Col75, KKR90] </ref> (see Sections 5 and 6). <p> Obviously each finite subset of has a model with respect to R and which is L fi -representable. On the other hand, does not admit any L fi -representable model. Indeed, any monadic first-order formula over the reals define a finite set of intervals of R <ref> [Tar51, Col75] </ref>. 2 The failure of the compactness theorem for restricted classes of models of interested in computer science has been investigated in particular in [HH94, GST94]. The failure 9 of the completeness theorem follows. <p> By assumption, the theory of A admits a quantifier elimination procedure. Therefore, R i = fx j i j R (x)g is also L-representable. Let R i (x) be the quantifier-free monadic formula defining R i . By <ref> [Tar51, Col75] </ref>, R i (x) defines a finite set of segments (intervals) over the universe A.
Reference: [Com88] <author> K. J. Compton. </author> <title> 0-1 laws in logic and combinatorics. </title> <editor> In I. Rival, editor, </editor> <booktitle> NATO Adv. Study Inst. on Algorithms and Order, </booktitle> <pages> pages 353-383. </pages> <address> D. </address> <publisher> Reidel, </publisher> <year> 1988. </year>
Reference-contexts: This fails in presence of an order relation. Indeed, every neighborhood based on Gaifman's distance contains the whole domain. Techniques based on asymptotic probabilities of the truth of sentences also fail in the presence of order or arithmetic. Some results were obtained for very specific languages (see <ref> [Com88] </ref>).
Reference: [Dri82] <author> L. Van den Dries. </author> <title> Remarks on Tarski's problem concerning (R; +; fi; exp). </title> <booktitle> In Logic Colloquium, </booktitle> <publisher> North-Holland, </publisher> <address> 1982. </address> <publisher> Elsevier. </publisher>
Reference-contexts: In particular, van den Dries showed that the extension of the previous theory to a language with an exponential function, f=; ; +; fi; e x ; 0; 1g, doesn't admit a quantifier elimination procedure <ref> [Dri82] </ref>. The theory of dense order without endpoints is another example of a theory admitting a quantifier elimination procedure that is of great use here. We next briefly discuss the case of finite databases.
Reference: [Ehr61] <author> A. Ehrenfeucht. </author> <title> An application of games to the completeness problem for for malized theories. </title> <journal> Fund. Math, </journal> <volume> 49, </volume> <year> 1961. </year> <month> 39 </month>
Reference-contexts: In particular, none of these tools are known to be applicable in the presence of some regular mathematical structure such as an order relation for instance. Thus, the problem of the definability of a query over finitely representable databases is a very challenging issue. The Ehrenfeucht-Frasse games <ref> [Fra54, Ehr61] </ref> are among the few tools which carry over on finitely representable structures. They are quite intuitive when the language does not contain arithmetic operation, and is restricted to equality and an order relation.
Reference: [Fag76] <author> R. Fagin. </author> <title> Probabilities on finite models. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 41(1) </volume> <pages> 50-58, </pages> <year> 1976. </year>
Reference-contexts: The failure of the main theorems of classical model theory, suggests the need to develop new tools applicable for finitely representable structures. Although powerful tools have been developed in the case of finite model theory, such as the locality by Gaifman [Gai81], or the 0/1 laws by Fagin <ref> [Fag76] </ref>, the model theory of finitely representable structures differs from finite model theory. In particular, none of these tools are known to be applicable in the presence of some regular mathematical structure such as an order relation for instance.
Reference: [Fag93] <author> R. Fagin. </author> <title> Finite model theory | a personal perspective. </title> <journal> Theoretical Computer Science, </journal> <volume> 116(1) </volume> <pages> 3-31, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: We prove here that the model theory of finitely representable structures, differs strongly from the classical model theory of all structures. In particular, we prove that, like for finite model theory (see the survey by Fagin <ref> [Fag93] </ref>), most 2 of the classical theorems of logic, such as the compactness and the completeness theorems, fail for finitely representable structures. The model theory of recursive structures has been studied in [HH94], and shown to differ strongly from classical model theory.
Reference: [Fra54] <author> R. Frasse. </author> <title> Sur les classifications des systemes de relations. </title> <type> Publ. </type> <institution> Sci. Univ Alger, I:1, </institution> <year> 1954. </year>
Reference-contexts: In particular, none of these tools are known to be applicable in the presence of some regular mathematical structure such as an order relation for instance. Thus, the problem of the definability of a query over finitely representable databases is a very challenging issue. The Ehrenfeucht-Frasse games <ref> [Fra54, Ehr61] </ref> are among the few tools which carry over on finitely representable structures. They are quite intuitive when the language does not contain arithmetic operation, and is restricted to equality and an order relation.
Reference: [FSS84] <author> M. Furst, J. B. Saxe, and M. Sipser. </author> <title> Parity, circuits, and the polynomial-time hierarchy. </title> <journal> Math. Syst. Theory, </journal> <volume> 17 </volume> <pages> 13-27, </pages> <year> 1984. </year>
Reference-contexts: Since the boolean function majority is not in AC 0 <ref> [FSS84] </ref> and queries in L [ fRg are in AC 0 (Theorem 5.2), it follows that region connectivity is not definable in L [ fRg. <p> We next present an alternative complexity theoretic proof of the non definability of the region connectivity query in the case k 3. Essentially, it is a reduction from the parity query that is known to be outside of AC 0 <ref> [FSS84, Aj83] </ref>. The reduction is first-order [Imm87], and so in AC 0 . Let fa 1 ; : : : ; a n g be the set of elements.
Reference: [Gai81] <author> H. Gaifman. </author> <title> On local and non local properties. </title> <editor> In J. Stern, editor, </editor> <booktitle> Proc. Herbrand Symposium Logic Colloquium, </booktitle> <pages> pages 105-135. </pages> <publisher> North Holland, </publisher> <year> 1981. </year>
Reference-contexts: The failure of the main theorems of classical model theory, suggests the need to develop new tools applicable for finitely representable structures. Although powerful tools have been developed in the case of finite model theory, such as the locality by Gaifman <ref> [Gai81] </ref>, or the 0/1 laws by Fagin [Fag76], the model theory of finitely representable structures differs from finite model theory. In particular, none of these tools are known to be applicable in the presence of some regular mathematical structure such as an order relation for instance. <p> There exists a sentence B in L [ such that for each L-representable (A; )-expansion B 0 , B 0 is isomorphic to B iff B 0 j= B . On the other hand, the theory of finitely representable models differs from finite model theory. Gaifman <ref> [Gai81] </ref> proved that first-order logic was local in a topological sense. This fails in presence of an order relation. Indeed, every neighborhood based on Gaifman's distance contains the whole domain. Techniques based on asymptotic probabilities of the truth of sentences also fail in the presence of order or arithmetic.
Reference: [GS94] <author> S. Grumbach, J. Su. </author> <title> Finitely representable databases. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 289-300, </pages> <address> Minneapolis, </address> <year> 1994. </year>
Reference: [GST94] <author> S. Grumbach, J. Su, and C. Tollu. </author> <title> Linear constraint databases. </title> <booktitle> In Proc. </booktitle> <address> LCC, </address> <year> 1994. </year> <note> To appear in LNCS Spring-Verlag volume. </note>
Reference-contexts: The trade-off between the class of structures and the complexity of queries has been further investigated in <ref> [GST94] </ref>. We study here infinite databases that are finitely representable by first order formulas in some logical language under the context of a first order structure (e.g., rational numbers with the natural order, the real closed field). <p> The relational calculus over finitely representable relations constitutes a constraint query language which admits an efficient bottom-up and declarative semantics. It is suitable for expressing geometric queries, as shown by the examples illustrated in the present paper. Similar to the relational model, equivalent algebras were proposed <ref> [KG94, PVV94, GST94] </ref>. Deductive languages, such as Datalog, have also been studied in the context of constraint databases [KKR90]. Practical implementation issues, such as indexing of such databases have been considered [KRVV93], although this is probably one of the most fundamental research issues in this field. <p> Upper bounds on the data complexity of both the relational calculus and inflationary Datalog with negation over constraint databases have been studied in [KKR90]. This shows the practical interest of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, GST94] </ref>. The goal of the present paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages. <p> The result was recently extended to classes of linear constraint databases, called k-bounded, where the number of occurrences of the addition symbol in each constraint is bounded <ref> [GST94] </ref>. Numerous examples of interesting queries, such as connectivity, are not in AC 0 , and so are not expressible in first-order logic over dense order, or linear constraint databases. We also investigate other criteria such as the invariance of the properties. <p> In summary, the results provided here serve as a starting point for further study on query languages over finitely representable databases. Some of the results shown here have already been strengthened. In particular, it was shown in <ref> [GST94] </ref>, that in the case of linear constraints (the language doesn't allow the multiplication symbol), then the parity and connectivity queries and the topological queries mentioned above are still not definable in first order. However, many problems remain open. <p> Indeed, any monadic first-order formula over the reals define a finite set of intervals of R [Tar51, Col75]. 2 The failure of the compactness theorem for restricted classes of models of interested in computer science has been investigated in particular in <ref> [HH94, GST94] </ref>. The failure 9 of the completeness theorem follows. In classical model theory, the completeness theorem implies, among other things, the fact that the set of valid first-order sentences is recursively enumerable (r.e.). <p> This encoding itself is not in AC 0 . An algebra working on the representation in terms of finite relations, simulates first-order operations on the dense-order constraint databases. This algebra is easily shown to be in AC 0 . An alternative proof is given in <ref> [GST94] </ref>, which doesn't require an encoding in terms of finite relations. The AC 0 upper bound also applies to a wider class. On the other hand, the expressive power of first-order queries in the language L has not been seriously investigated. <p> In particular, it is still open if the connectivity of a graph, or the parity of a relation, to take classical examples, are expressible. Partial results were already obtained in this direction. It was shown in <ref> [GST94] </ref>, that in the case of linear constraints, that is when the language doesn't allow the multiplication symbol, then parity and connectivity are not definable. We conjecture that they are not expressible with polynomial constraints. An other question of theoretical importance, is the capture of complexity classes.
Reference: [HH93] <author> T. Hirst and D. Harel. </author> <title> Completeness results of recursive data bases. </title> <booktitle> In Proc. 12th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 244-252, </pages> <year> 1993. </year>
Reference-contexts: There have been only very few theoretical results on infinite databases. General results on the completeness of query languages for infinite recursive databases were reported by Hirst and Harel in <ref> [HH93] </ref>, where two classes of recursive databases are considered, and it is shown that: (i) quantifier free first-order logic is complete on the class of all recursive databases, and (ii) a version of Chandra and Harel's QL [CH80] is complete on highly symmetric databases. The first result of [HH93] indicates that <p> Harel in <ref> [HH93] </ref>, where two classes of recursive databases are considered, and it is shown that: (i) quantifier free first-order logic is complete on the class of all recursive databases, and (ii) a version of Chandra and Harel's QL [CH80] is complete on highly symmetric databases. The first result of [HH93] indicates that the class of recursive structures is much to general for database purposes, since quantifier free first-order logic is already complete on this class. Therefore, many basic queries are simply not computable (projection, connectivity, etc.).
Reference: [HH94] <author> T. Hirst and D. Harel. </author> <title> Recursive model theory, 1994. </title> <type> Draft. </type>
Reference-contexts: In particular, we prove that, like for finite model theory (see the survey by Fagin [Fag93]), most 2 of the classical theorems of logic, such as the compactness and the completeness theorems, fail for finitely representable structures. The model theory of recursive structures has been studied in <ref> [HH94] </ref>, and shown to differ strongly from classical model theory. The failure of the main theorems of classical model theory, suggests the need to develop new tools applicable for finitely representable structures. <p> Indeed, any monadic first-order formula over the reals define a finite set of intervals of R [Tar51, Col75]. 2 The failure of the compactness theorem for restricted classes of models of interested in computer science has been investigated in particular in <ref> [HH94, GST94] </ref>. The failure 9 of the completeness theorem follows. In classical model theory, the completeness theorem implies, among other things, the fact that the set of valid first-order sentences is recursively enumerable (r.e.).
Reference: [Hul86] <author> R. Hull. </author> <title> Relative information capacity of simple relational schemata. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15(3) </volume> <pages> 856-886, </pages> <year> 1986. </year>
Reference-contexts: Note that we could also restricted to automorphisms that are identity on a fixed set C of constants, and this variation corresponds to the notion of C-genericity <ref> [Hul86] </ref>. 14 Example 4.2 Consider a signature = fRg, where R is a unary relation symbol. Let K even be the collection of L -representable (Q; )-instances I such that I (R) represents a finite subset of Q of even cardinality.
Reference: [Imm86] <author> N. Immerman. </author> <title> Relational queries computable in polynomial time. </title> <journal> Inf. and Control, </journal> <volume> 68 </volume> <pages> 86-104, </pages> <year> 1986. </year>
Reference-contexts: other tuples in R I . 33 It is clear that I R I as well as each individual rule, can be expressed in DATALOG : . 2 The rest of the proof of the theorem involves techniques which have been used already in the literature, following the results of <ref> [Var82, Imm86] </ref>. Note that in I and its relational representation, the constants are rational numbers. These constants occurring in the relational representation of the input or in the query itself, are encoded into consecutive integers by respecting their order. Zero is zero.
Reference: [Imm87] <author> N. Immerman. </author> <title> Languages that capture complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 16(4) </volume> <pages> 760-778, </pages> <year> 1987. </year>
Reference-contexts: Theorem 5.3 For each positive integer k 2 and each k-ary relation symbol R, the k-dimensional region connectivity query over L -representable (Q; fRg)-instances is not defin able in L [ fRg. 22 Proof: The proof is accomplished by a first order reduction <ref> [Imm87] </ref> from the function majority to region connectivity. Since the boolean function majority is not in AC 0 [FSS84] and queries in L [ fRg are in AC 0 (Theorem 5.2), it follows that region connectivity is not definable in L [ fRg. <p> We next present an alternative complexity theoretic proof of the non definability of the region connectivity query in the case k 3. Essentially, it is a reduction from the parity query that is known to be outside of AC 0 [FSS84, Aj83]. The reduction is first-order <ref> [Imm87] </ref>, and so in AC 0 . Let fa 1 ; : : : ; a n g be the set of elements. For technical convenience and without loss of generality, we assume that for each i 2 [2::n], a i1 &lt; a i .
Reference: [KG94] <author> P. C. Kanellakis and D. Q. Goldin. </author> <title> Constraint programming and database query languages. </title> <booktitle> In Proc. 2nd Conference on Theoretical Aspects of Computer Software (TACS), </booktitle> <month> April </month> <year> 1994. </year> <note> (To appear in LNCS Spring-Verlag volume). </note>
Reference-contexts: The relational calculus over finitely representable relations constitutes a constraint query language which admits an efficient bottom-up and declarative semantics. It is suitable for expressing geometric queries, as shown by the examples illustrated in the present paper. Similar to the relational model, equivalent algebras were proposed <ref> [KG94, PVV94, GST94] </ref>. Deductive languages, such as Datalog, have also been studied in the context of constraint databases [KKR90]. Practical implementation issues, such as indexing of such databases have been considered [KRVV93], although this is probably one of the most fundamental research issues in this field. <p> Upper bounds on the data complexity of both the relational calculus and inflationary Datalog with negation over constraint databases have been studied in [KKR90]. This shows the practical interest of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, GST94] </ref>. The goal of the present paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages. <p> For example, it was first shown that the data complexity of first-order logic over dense order constraint databases in some normal form is in AC 0 <ref> [KG94] </ref>. The result was recently extended to classes of linear constraint databases, called k-bounded, where the number of occurrences of the addition symbol in each constraint is bounded [GST94]. <p> We next consider the complexity of dense order queries. For each complexity class C, we denote by C Q the set of queries over dense-order constraint databases computable in C. The data complexity of queries over L -representable (R ; )-instances has been studied 21 in <ref> [KKR90, KG94] </ref>. Kanellakis and Goldin have shown recently that the data complexity of queries in L [ is in AC 0 , while Kanellakis, Kuper, and Revesz proved that the data complexity of DATALOG : is in PTIME. <p> Kanellakis and Goldin have shown recently that the data complexity of queries in L [ is in AC 0 , while Kanellakis, Kuper, and Revesz proved that the data complexity of DATALOG : is in PTIME. Theorem 5.2 <ref> [KG94, KKR90] </ref> Each query in L [ (respectively, DATALOG : ) over L - representable (R ; )-instances is in AC 0 Q (respectively, PTIME Q ). The proof of the AC 0 upper bound [KG94] is made by an encoding of the dense-order constraint databases into finite models. <p> Theorem 5.2 [KG94, KKR90] Each query in L [ (respectively, DATALOG : ) over L - representable (R ; )-instances is in AC 0 Q (respectively, PTIME Q ). The proof of the AC 0 upper bound <ref> [KG94] </ref> is made by an encoding of the dense-order constraint databases into finite models. This encoding itself is not in AC 0 . An algebra working on the representation in terms of finite relations, simulates first-order operations on the dense-order constraint databases. <p> Theorem 5.10 Inflationary DATALOG : = PTIME Q . Remark: A similar statement can be found in [KKR90] and also in <ref> [KG94] </ref>, but its meaning is different. What was proved there was that "inflationary DATALOG : can express any relational database query computable in PTIME" (Theorem 3.15 of [KKR90]). In other words, it was shown that PTIME relational input/output inflationary DATALOG : PTIME dense-order input/input = PTIME Q . <p> It is important to note that the objects of these particular shapes may be represented by four constants (in Q [ f1; +1g) along with a flag indicating the shape. This lead to efficient encoding of dense-order constraint databases. An alternative encoding was proposed in <ref> [KG94] </ref>. Proof of Theorem 5.10: The inclusion of inflationary DATALOG : in PTIME Q has been shown in [KKR90]: each query in DATALOG : expresses a query over dense order databases and can be computed in PTIME. We only prove the converse inclusion.
Reference: [KKR90] <author> P. Kanellakis, G Kuper, and P. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <address> Nashville, </address> <year> 1990. </year> <month> 40 </month>
Reference-contexts: Typical examples are temporal and spatial data. A new generation of data models for infinite collections of data items is starting to emerge in the literature (e.g., <ref> [KKR90, Rev90, Kup93a, BJM93] </ref>). We believe that in developing data models and languages for infinite data, there are two fundamental principles that should govern the choice of such a data model: (i) infinite databases should admit a finite representation, and (ii) a reasonable set of queries should be tractable. <p> Our framework follows and generalizes the pioneer 1 work by Kanellakis, Kuper, and Revesz who introduced the constraint query languages in <ref> [KKR90] </ref>. The basic idea in [KKR90] is to generalize the relations of the relational model [Cod70] by defining generalized tuples as conjunctions of constraints. For instance, the formula x 2 + y 2 = 1 ^ x 0 defines a binary generalized tuple. <p> Our framework follows and generalizes the pioneer 1 work by Kanellakis, Kuper, and Revesz who introduced the constraint query languages in <ref> [KKR90] </ref>. The basic idea in [KKR90] is to generalize the relations of the relational model [Cod70] by defining generalized tuples as conjunctions of constraints. For instance, the formula x 2 + y 2 = 1 ^ x 0 defines a binary generalized tuple. <p> It is suitable for expressing geometric queries, as shown by the examples illustrated in the present paper. Similar to the relational model, equivalent algebras were proposed [KG94, PVV94, GST94]. Deductive languages, such as Datalog, have also been studied in the context of constraint databases <ref> [KKR90] </ref>. Practical implementation issues, such as indexing of such databases have been considered [KRVV93], although this is probably one of the most fundamental research issues in this field. <p> The data complexity is measured with respect to the size of a finitely representable relation, which is defined as the length of its finite representation. Upper bounds on the data complexity of both the relational calculus and inflationary Datalog with negation over constraint databases have been studied in <ref> [KKR90] </ref>. This shows the practical interest of this approach, which has been pursued in [Rev90, Kup93a, KG94, PVV94, GST94]. The goal of the present paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages. <p> However, many problems remain open. For example, it is not known, when the multiplication operation is also used, if the parity query and the Euclidean spanning tree <ref> [KKR90] </ref> query are expressible. The paper is organized as follows. In Section 2, we define finitely representable databases. In Section 3, we study the model theory of finitely representable structures and investigate the differences between finitely representable model theory and both finite model theory and classical model theory. <p> Throughout the paper, we always assume that the database schema is disjoint from the first-order language, and we distinguish between logical predicates (e.g., =; ) in L and relations in . Kanellakis, Kuper, and Revesz <ref> [KKR90] </ref> introduced the concept of a k-ary generalized tuple, which is a constraint expressed as a conjunction of atomic formulas in L over k variables. <p> For instance, (x fi x + y fi y = 1 ^ x 0) is a binary generalized tuple in L fi representing a half circle. A k-ary finitely representable relation (or generalized relation in <ref> [KKR90] </ref>) is then a finite set of k-ary generalized tuples. In this framework, a tuple [a; b] in the context of classical relational databases [Cod70] is an abbreviation for the formula (x = a^y = b) represented using only the equality symbol, "=", and constants. <p> This follows easily from results in <ref> [Col75, KKR90] </ref> (see Sections 5 and 6). <p> Conversely, it suffices to consider a formula ' in L. Since it defines a query, there exists a formula without quantifiers in L which is T -equivalent to '. Therefore T admits a quantifier elimination procedure. 2 The direction (1 ) 2) was used in <ref> [KKR90] </ref> to see that the query languages were well-defined for finitely representable databases. The previous proposition shows that this is a necessary condition, and therefore finitely representable databases can only be defined over models of theories admitting a quantifier elimination procedure. <p> Theorem 4.4 Under the same assumptions as in Theorem 3.4, the following problems are undecidable: the satisfiability, the equivalence, the containment, and whether a query is closed under fg-automorphism. In particular, Theorem 4.4 indicates that the above problems are undecidable in the first-order constraint query language of <ref> [KKR90] </ref> over the real field. The "data complexity" of queries is defined as usual based on computational devices and standard encoding of the input/output. <p> We next consider the complexity of dense order queries. For each complexity class C, we denote by C Q the set of queries over dense-order constraint databases computable in C. The data complexity of queries over L -representable (R ; )-instances has been studied 21 in <ref> [KKR90, KG94] </ref>. Kanellakis and Goldin have shown recently that the data complexity of queries in L [ is in AC 0 , while Kanellakis, Kuper, and Revesz proved that the data complexity of DATALOG : is in PTIME. <p> Kanellakis and Goldin have shown recently that the data complexity of queries in L [ is in AC 0 , while Kanellakis, Kuper, and Revesz proved that the data complexity of DATALOG : is in PTIME. Theorem 5.2 <ref> [KG94, KKR90] </ref> Each query in L [ (respectively, DATALOG : ) over L - representable (R ; )-instances is in AC 0 Q (respectively, PTIME Q ). The proof of the AC 0 upper bound [KG94] is made by an encoding of the dense-order constraint databases into finite models. <p> An alternative proof is given in [GST94], which doesn't require an encoding in terms of finite relations. The AC 0 upper bound also applies to a wider class. On the other hand, the expressive power of first-order queries in the language L has not been seriously investigated. In <ref> [KKR90] </ref>, it was shown that inflationary Datalog with negation can express all PTIME relational queries (mappings from finite relational databases to finite relations). 5.2 First-Order Queries We now study definability and non-definability of numerous queries in the first-order query language L for dense order databases. <p> The process need to be repeated for at most k times. 2 5.3 Inflationary DATALOG : In this section we study inflationary DATALOG : , which was originally introduced in <ref> [KKR90] </ref> for dense order constraint databases. We prove that some of the queries not expressible in L discussed earlier are in fact definable in DATALOG : . Recall that PTIME Q is the set of all dense order queries computable in PTIME. <p> Constraints are allowed in the bodies of rules. For DATALOG : , negations are allowed in the bodies of rules. The inflationary semantics is computed by adding after iteration the set of facts just derived to the set previously obtained. It has been shown in <ref> [KKR90] </ref> that the language can be evaluated bottom-up and in closed form, that is instances are mapped to instances. It is easy to see that under the restriction to L -representable (Q; )-instances, inflationary DATALOG : programs define queries over Q, in a way analogous to Proposition 4.2. <p> Theorem 5.10 Inflationary DATALOG : = PTIME Q . Remark: A similar statement can be found in <ref> [KKR90] </ref> and also in [KG94], but its meaning is different. What was proved there was that "inflationary DATALOG : can express any relational database query computable in PTIME" (Theorem 3.15 of [KKR90]). <p> Theorem 5.10 Inflationary DATALOG : = PTIME Q . Remark: A similar statement can be found in <ref> [KKR90] </ref> and also in [KG94], but its meaning is different. What was proved there was that "inflationary DATALOG : can express any relational database query computable in PTIME" (Theorem 3.15 of [KKR90]). In other words, it was shown that PTIME relational input/output inflationary DATALOG : PTIME dense-order input/input = PTIME Q . <p> This lead to efficient encoding of dense-order constraint databases. An alternative encoding was proposed in [KG94]. Proof of Theorem 5.10: The inclusion of inflationary DATALOG : in PTIME Q has been shown in <ref> [KKR90] </ref>: each query in DATALOG : expresses a query over dense order databases and can be computed in PTIME. We only prove the converse inclusion. <p> R is a model of the theory of real closed fields. The theory also admit quantifier elimination procedures [CK73]. The data complexity of queries over (R; )-instances has been studied in <ref> [KKR90] </ref>. Queries queries in L fi [ over L fi - representable (R; )-instances are computable in NC data complexity [BKR86, KKR90]. On the other hand, the only automorphism of R is the identity mapping. <p> The theory also admit quantifier elimination procedures [CK73]. The data complexity of queries over (R; )-instances has been studied in [KKR90]. Queries queries in L fi [ over L fi - representable (R; )-instances are computable in NC data complexity <ref> [BKR86, KKR90] </ref>. On the other hand, the only automorphism of R is the identity mapping. Hence, under Definition 4.2, if is a signature, then each partial recursive collection of L fi -representable (R; )-instances is a boolean query over R.
Reference: [KRVV93] <author> P. Kanellakis, S. Ramaswamy, D. Vengroff, and J. Vitter. </author> <title> Indexing for data models with constraints and classes. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 233-243, </pages> <year> 1993. </year>
Reference-contexts: Similar to the relational model, equivalent algebras were proposed [KG94, PVV94, GST94]. Deductive languages, such as Datalog, have also been studied in the context of constraint databases [KKR90]. Practical implementation issues, such as indexing of such databases have been considered <ref> [KRVV93] </ref>, although this is probably one of the most fundamental research issues in this field.
Reference: [Kup90] <author> G. M. Kuper. </author> <title> On the expressive power of the relational calculus with arithmetic constraints. </title> <booktitle> In Proc. Int. Conf. on Database Theory, </booktitle> <pages> pages 202-211, </pages> <year> 1990. </year>
Reference-contexts: The representation is based on the equality predicate only, and no negation is allowed in tuples. The concepts defined above carry over, and corresponds to well known concepts of (finite) database theory. In <ref> [Kup90] </ref>, finite databases over the structure R of real numbers were considered. It was claimed that if a query in L fi is closed under ;-automorphisms (permutations of real numbers), then it is definable using only equality. Unfortunately, this result doesn't hold [Via93, Kup93b].
Reference: [Kup93a] <author> G. M. Kuper. </author> <title> Aggregation in constraint databases. </title> <booktitle> In Proc. Workshop on the Principles and Practice of Constraint Programming, </booktitle> <pages> pages 176-183, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Typical examples are temporal and spatial data. A new generation of data models for infinite collections of data items is starting to emerge in the literature (e.g., <ref> [KKR90, Rev90, Kup93a, BJM93] </ref>). We believe that in developing data models and languages for infinite data, there are two fundamental principles that should govern the choice of such a data model: (i) infinite databases should admit a finite representation, and (ii) a reasonable set of queries should be tractable. <p> Upper bounds on the data complexity of both the relational calculus and inflationary Datalog with negation over constraint databases have been studied in [KKR90]. This shows the practical interest of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, GST94] </ref>. The goal of the present paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages.
Reference: [Kup93b] <author> G. M. Kuper. </author> <type> Personal communications, </type> <year> 1993. </year>
Reference-contexts: In [Kup90], finite databases over the structure R of real numbers were considered. It was claimed that if a query in L fi is closed under ;-automorphisms (permutations of real numbers), then it is definable using only equality. Unfortunately, this result doesn't hold <ref> [Via93, Kup93b] </ref>. A simple counterexample can be found in ([AHV94], Exercise 17.27, page 162). It has been conjectured more recently that a query in L fi closed under ;-automorphisms is definable with the equality and the order relation only [VdB95].
Reference: [PVV94] <author> J. Paredaens, J. Van den Bussche, and D. Van Gucht. </author> <title> Towards a theory of spatial database queries. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 279-88, </pages> <year> 1994. </year>
Reference-contexts: The relational calculus over finitely representable relations constitutes a constraint query language which admits an efficient bottom-up and declarative semantics. It is suitable for expressing geometric queries, as shown by the examples illustrated in the present paper. Similar to the relational model, equivalent algebras were proposed <ref> [KG94, PVV94, GST94] </ref>. Deductive languages, such as Datalog, have also been studied in the context of constraint databases [KKR90]. Practical implementation issues, such as indexing of such databases have been considered [KRVV93], although this is probably one of the most fundamental research issues in this field. <p> Upper bounds on the data complexity of both the relational calculus and inflationary Datalog with negation over constraint databases have been studied in [KKR90]. This shows the practical interest of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, GST94] </ref>. The goal of the present paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages. <p> We also investigate other criteria such as the invariance of the properties. There are interesting classes of queries that commute with groups of operations, such as permutations, rotations, translations, etc. This subject was explored in more detail in <ref> [PVV94] </ref>. We prove that the class of first-order queries definable by dense order constraints commute with the automorphisms of hQ; i. We illustrate these proof techniques on queries from computational geometry [Yao90], graph theory, and geographical databases. We investigate their definability in first-order logic over finitely representable databases. <p> In Section 6, we shall exhibit a technique based on closure under L 0 -automorphism for L 0 L, for proving inexpressibility results. More geometry-based properties of queries have been exhibited by Paredaens, Van den Bussche, and Van Gucht <ref> [PVV94] </ref>. We next focus on queries that are defined using first-order logic. We first consider boolean queries. The next proposition, shows that under the restriction to finitely representable models, every first-order sentence defines a boolean query. Proposition 4.2 Let A be an L-structure. <p> Nevertheless it includes all first-order definable mappings, and so constitutes a tool to prove non first-order definability results. Proposition 5.1 shows that queries over dense order constraints are insensitive to homeomorphic transformations on the axis. This constitutes an intuitive tool for non-definability. Other notions of queries were introduced in <ref> [PVV94] </ref>, based on closure under various groups of transformations, such as rotations, translations, etc. They have strong mathematical and practical motivations.
Reference: [Rev90] <author> P. Revesz. </author> <title> A closed form for datalog queries with integer order. </title> <booktitle> In Proc. Int. Conf. on Database Theory, </booktitle> <pages> pages 187-201, </pages> <year> 1990. </year>
Reference-contexts: Typical examples are temporal and spatial data. A new generation of data models for infinite collections of data items is starting to emerge in the literature (e.g., <ref> [KKR90, Rev90, Kup93a, BJM93] </ref>). We believe that in developing data models and languages for infinite data, there are two fundamental principles that should govern the choice of such a data model: (i) infinite databases should admit a finite representation, and (ii) a reasonable set of queries should be tractable. <p> Upper bounds on the data complexity of both the relational calculus and inflationary Datalog with negation over constraint databases have been studied in [KKR90]. This shows the practical interest of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, GST94] </ref>. The goal of the present paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages.
Reference: [Su93] <author> D. Suciu. </author> <title> Bounded fixpoints for complex objects. </title> <booktitle> In 4th Int. Workshop on Database Programming Languages, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: We conjecture that they are not expressible with polynomial constraints. An other question of theoretical importance, is the capture of complexity classes. We claim that in the case of constraint databases, the class of polynomial time queries can easily be captured by a bounded fixpoint <ref> [Su93] </ref>, to avoid the arbitrary explosion due to the iteration over addition for instance. Acknowledgments The authors wish to thanks Richard Lassaigne and Victor Vianu for helpful discussions. 38
Reference: [Tar51] <author> A. Tarski. </author> <title> A Decision Method for Elementary Algebra and Geometry. </title> <institution> University of California Press, Berkeley, California, </institution> <year> 1951. </year>
Reference-contexts: In particular it is easy to verify that the set of integers, Z, is not finitely representable over Q. Indeed, every L fi -representable set S over Q contains a finite number of segments of the reals <ref> [Tar51] </ref>, and so its intersection with Z is either finite or co-finite. We next define the fundamental notion of database instance. 7 Definition 2.3 Let B be an expansion of A to which is L 0 -representable over A. <p> Obviously each finite subset of has a model with respect to R and which is L fi -representable. On the other hand, does not admit any L fi -representable model. Indeed, any monadic first-order formula over the reals define a finite set of intervals of R <ref> [Tar51, Col75] </ref>. 2 The failure of the compactness theorem for restricted classes of models of interested in computer science has been investigated in particular in [HH94, GST94]. The failure 9 of the completeness theorem follows. <p> By assumption, the theory of A admits a quantifier elimination procedure. Therefore, R i = fx j i j R (x)g is also L-representable. Let R i (x) be the quantifier-free monadic formula defining R i . By <ref> [Tar51, Col75] </ref>, R i (x) defines a finite set of segments (intervals) over the universe A. <p> A theory admitting a quantifier elimination procedure, that is of great use in the context of finitely representable databases, is the theory of real closed fields over the language L fi <ref> [Tar51] </ref>. It should be noted that the functions allowed in the language play a fundamental role in the quantifier elimination procedure.
Reference: [Tra50] <author> B. A. Trakhtenbrot. </author> <title> The impossibilty of an algorithm for the decision problem for finite models. </title> <journal> Doklady Akademii Nauk SSR, </journal> <volume> 70 </volume> <pages> 569-572, </pages> <year> 1950. </year>
Reference-contexts: The contrary holds for finite model theory. Indeed, the set of first-order sentences valid over finite structures is co-r.e., and Trakhtenbrot proved <ref> [Tra50] </ref> that it is not r.e. A similar phenomenon holds for finitely representable models. Proposition 3.2 Let A be an L-structure such that the theory of A is decidable. Then the set of sentences in L [ valid over L-representable expansions of A to is co-r.e.
Reference: [Var82] <author> M. Vardi. </author> <title> Relational queries computable in polynomial time. </title> <booktitle> In Proc. 14th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference-contexts: other tuples in R I . 33 It is clear that I R I as well as each individual rule, can be expressed in DATALOG : . 2 The rest of the proof of the theorem involves techniques which have been used already in the literature, following the results of <ref> [Var82, Imm86] </ref>. Note that in I and its relational representation, the constants are rational numbers. These constants occurring in the relational representation of the input or in the query itself, are encoded into consecutive integers by respecting their order. Zero is zero.
Reference: [Vau60] <author> R. L. Vaught. </author> <title> Sentences true in all constructive models. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 25(1) </volume> <pages> 39-53, </pages> <month> March </month> <year> 1960. </year>
Reference-contexts: Theorem 3.3 Let L be a first-order language with = and N the structure of the natural numbers with equality only. Then the set of sentences in L [ valid over f=g-representable models with respect to N and is not r.e. Proof: The proof is based on Vaught's result <ref> [Vau60] </ref>. Let V r:e: (respectively V fin ) be the set of sentences true in all recursively enumerable (respectively finite) models. Vaught showed that for each set of sentences V , if V r:e: V V fin , then V is not r.e.
Reference: [VdB95] <author> J. Van den Bussche. </author> <type> Personal communications, </type> <year> 1995. </year>
Reference-contexts: Unfortunately, this result doesn't hold [Via93, Kup93b]. A simple counterexample can be found in ([AHV94], Exercise 17.27, page 162). It has been conjectured more recently that a query in L fi closed under ;-automorphisms is definable with the equality and the order relation only <ref> [VdB95] </ref>. Such a result would have important consequences on the expressive power of the languages considered for classical relational queries (see Section 5). It remains open if the transitive closure of a graph, or of the parity of the cardinality of a relation are definable in L fi .
Reference: [Via93] <author> V. Vianu. </author> <type> Personal communications, </type> <year> 1993. </year>
Reference-contexts: In [Kup90], finite databases over the structure R of real numbers were considered. It was claimed that if a query in L fi is closed under ;-automorphisms (permutations of real numbers), then it is definable using only equality. Unfortunately, this result doesn't hold <ref> [Via93, Kup93b] </ref>. A simple counterexample can be found in ([AHV94], Exercise 17.27, page 162). It has been conjectured more recently that a query in L fi closed under ;-automorphisms is definable with the equality and the order relation only [VdB95].
Reference: [Yao90] <author> F. F. Yao. </author> <title> Computational geometry. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theorical Computer Science, volume A, chapter 7, </booktitle> <pages> pages 343-389. </pages> <publisher> North Holland, </publisher> <year> 1990. </year>
Reference-contexts: This subject was explored in more detail in [PVV94]. We prove that the class of first-order queries definable by dense order constraints commute with the automorphisms of hQ; i. We illustrate these proof techniques on queries from computational geometry <ref> [Yao90] </ref>, graph theory, and geographical databases. We investigate their definability in first-order logic over finitely representable databases. We show in particular the non first-order definability of the connectivity of an area in the context of a dense order. <p> Now consider the Euclidean travel salesman query. It was shown to be NPTIME-complete <ref> [Yao90] </ref>.
References-found: 41

