URL: http://www.daimi.aau.dk/~beta/Mli/betamli.ps.Z
Refering-URL: http://www.daimi.aau.dk/~beta/Mli/mli.html
Root-URL: http://www.daimi.aau.dk
Email: Email: sbrandt@daimi.aau.dk  
Title: Reflection in a Statically Typed and Object Oriented Language A Meta-Level Interface for BETA  
Author: Soren Brandt 
Date: July 14, 1995  
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Abstract-found: 0
Intro-found: 0
Reference: [Accetta et al. 86] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. T. Jr., , and M. Young. </author> <title> Mach: A New Kernel Foundation for Unix Development. </title> <booktitle> In Proceedings of the 1986 Summer USENIX Conference, </booktitle> <pages> pages 93 - 113, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Here mapping dilemmas include how to map virtual addresses to pages, and how to map pages to physical memory. What is the best policy depends on the application at hand. A classic example system providing some control over these aspects is Mach <ref> [Accetta et al. 86] </ref>, through the concept of external pagers. * In the CORBA [OMG 91] distributed object specification, the concept of dynamic invocation interfaces allows client programs to dynamically synthesize requests to servers based on server descriptions obtained from an interface repository.
Reference: [Agesen & Frolund 89] <author> O. Agesen and S. Frolund. </author> <title> Dynamic Link and Load as a Basis for Implementing Extensibility. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <year> 1989. </year>
Reference-contexts: Originally, dynamic pattern references were proposed in [Agesen et al. 89] with the primary purpose of enabling extensibility 5 in a statically typed language. Since then, dynamic pattern references have played an important role in the design of a BETA interpreter [Malhotra 94], a callable dynamic linker and loader <ref> [Agesen & Frolund 89] </ref>, the design and implementation of distribution and persistence libraries for BETA [Brandt & Madsen 94, Brandt 94, Sloth & Hem 93] and finally as a general programming facility.
Reference: [Agesen & Ungar 94] <author> O. Agesen and D. Ungar. </author> <title> Sifting out the gold. </title> <booktitle> In OOPSLA'94 Conference Proceedings, </booktitle> <pages> pages 355 - 370. </pages> <publisher> ACM, ACM Press, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: As already noted, this includes information needed to implement the MLI. 3. The presence of an oodb enables replication of immutable objects. In large distributed environments this may lead to considerable performance gains. 1 Although type inference <ref> [Agesen & Ungar 94] </ref> and incremental optimization techniques [Holzle & Ungar 94] limits the cost considerably. 77 4. Derived objects may be created on demand.
Reference: [Agesen et al. 89] <author> O. Agesen, S. Frolund, and M. Olsen. </author> <title> Persistent and Shared Objects in BETA. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <year> 1989. </year>
Reference-contexts: Originally, dynamic pattern references were proposed in <ref> [Agesen et al. 89] </ref> with the primary purpose of enabling extensibility 5 in a statically typed language. <p> In comparison, ordinary nested patterns as described in section 3.2.2, correspond to static pattern references. 4 In the BETA book [Madsen et al. 93b] as well as in the original proposal <ref> [Agesen et al. 89] </ref>, dynamic pattern references were called pattern variables.
Reference: [Black et al. 87] <author> A. Black, N. Hutchinson, E. Jul, H. Levy, and L. Carter. </author> <title> Distribution and abstract types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1), </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: For example, the POET [Robie & Witte 91] object oriented database system extends the C++ programming language with the transient keyword. Object attributes with storage type transient are not followed when saving persistent data to disk. A similar example is the attach keyword used in the Emerald <ref> [Black et al. 87] </ref> distributed and object based programming language. In Emerald, attached references are followed when moving objects between network hosts. That is, attach is effectively the opposite of the transient keyword, since the Emerald default is not to follow references. <p> Thus, we shall define the relation on qualifications by q q 0 def , extension (q) extension (q 0 ) 2 Usually, static typing of hierarchical type systems is ensured by enforcing contravariant relationships between super/sub types in a type-hierarchy <ref> [Black et al. 87, Omohundro 93] </ref>. 3 Work on constraint based type inference [Oxhoj et al. 92] of BETA programs is being done, possibly leading to the ability to get rid of most runtime type checks, although probably at the expense of separate compilation. 17 IntVal: (# value: @Integer; (* Integer <p> For example, the ability to speak of attributes is useful in order to express clustering policies, implement schema-evolution tools, object-browsers, export and import persistent objects from external database formats and so on. 7.3 Object Movement and Attachment The distributed programming language Emerald <ref> [Black et al. 87] </ref> includes the attach keyword used to specify what objects should move along when an object is moved between network hosts. In Emerald, attachment is part of the type declaration, and it is therefore impossible to change attachment dynamically.
Reference: [Borning et al. 92] <author> A. Borning, B. Freeman-Benson, and M. Wilson. </author> <title> Constraint hierarchies. </title> <booktitle> In Lisp and Symbolic Computation, </booktitle> <pages> pages 223 - 270, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Unlike @, the job of ^ is to continually enforce that the value bound to id qualifies to q. The initial value bound to id by ^(id; q), is NONE, unless NONE does not qualify to q. This initial behaviour can be expressed using a two-level constraint hierarchy <ref> [Borning et al. 92] </ref>. required qual (object (id)) q strong object (id) = NONE After initialization, only the required constraint stays, and the strong constraint disappers.
Reference: [Brandt & Madsen 94] <author> S. Brandt and O. Madsen. </author> <title> Object-Oriented Distributed Programming in BETA. </title> <editor> In R. Guerraoui, O. Nierstrasz, and M. Riveill, editors, </editor> <booktitle> Lecture Notes in Computer Science 791, </booktitle> <pages> pages 185 - 212. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: chapter 9 describes related and future work, and chapter 10 presents my conclusions. 9 Chapter 2 Background This work has its offspring in systems programming in the Mjolner BETA system, including the implementation of a source level debugger, an object browser, a type-orthogonal persistent store and a distributed objects system <ref> [Brandt 94, Brandt & Madsen 94] </ref>. In addition, I have been involved in discussions relating to the design of a distributed object database, a distributed hypermedia [Gronbaek et al. 94] and an interpreter for the BETA language [Malhotra 94]. <p> Since then, dynamic pattern references have played an important role in the design of a BETA interpreter [Malhotra 94], a callable dynamic linker and loader [Agesen & Frolund 89], the design and implementation of distribution and persistence libraries for BETA <ref> [Brandt & Madsen 94, Brandt 94, Sloth & Hem 93] </ref> and finally as a general programming facility. Pattern references can be considered the BETA generalisation of, e.g., function pointers in procedural programming languages such as C and Modula-2. <p> Introspection would solve most of my problems with the ObjectSerializer, but it did not help solving some of the principal problems of the implementation of a fully general distributed object system as outlined in <ref> [Brandt & Madsen 94] </ref>. However, the right intercessory protocol, allowing the redefinition of method dispatch and variable access, could provide significant help in this area too. As a consequence I started looking into the literature on reflection.
Reference: [Brandt & Schmidt 95] <author> S. Brandt and R. Schmidt. </author> <title> The Design of a Meta-Level Architecture for the BETA Language. </title> <booktitle> Presented at META'95: Workshop on Advances in Metaobject Protocols and Reflection at ECOOP '95, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: As a paper design, it is likely to change during implementation and use. Implementation work has recently been initiated, as described in <ref> [Brandt & Schmidt 95] </ref>. 6.1 Object Introspection The GetObjQual pattern shown in figure 6.1 returns the actual type of an object, i.e., the pattern of which the object is an instance. GetObjQual thus corresponds to the qual () function (section 3.2.1) evaluated on objects. <p> What are the part technologies involved? In the following sections, I briefly outline answers to these questions, while postponing the exact details of the implementation to future work. Implementation work is under progress, and the first results have been reported elsewhere <ref> [Brandt & Schmidt 95] </ref>. 8.1 Existing Programming Environments Existing programming systems supporting reflection include SELF [Sun 93] CLOS [Kiczales et al. 91] and OpenC++ [Chiba 93]. SELF and CLOS are fully dynamic and include general and flexible reflectional capabilities, while OpenC++ is more restricted. <p> Initially the plan is to make a prototype implementation feasible for experimenting with reflection, persistence and distribution. On top of such a prototype, a large body of experiments will be possible. Some of the possibilities have already been outlined in chapter 7. Implementation work is underway, as described in <ref> [Brandt & Schmidt 95] </ref>. The job of a meta-level interface is to expose certain parts of the language implementation in a controlled manner. Clearly, a MLI can only be designed with a detailed understanding of the language being exposed.
Reference: [Brandt 93] <author> S. Brandt. </author> <title> The BETA Distribution Library. Manual. </title> <institution> Department of Computer Science, University of Aarhus, </institution> <month> Nov </month> <year> 1993. </year> <note> Draft Version. </note>
Reference-contexts: Concerning efficiency, the current oodb may have difficulties fulfilling the demands of an integrated distributed runtime environment. To address this problem, work is being done to provide more efficient persistence and locking mechanisms. Next, a distribution library is needed. The distribution library described in <ref> [Brandt 94, Brandt 93] </ref> is general enough for a prototype distributed programming environment. It is, for example, already used to implement the oodb. Finally, a very important component is a fine grained dynamic linker.
Reference: [Brandt 94] <author> S. Brandt. </author> <title> Implementing Shared and Persistent Objects in BETA | Progress Report. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <year> 1994. </year>
Reference-contexts: chapter 9 describes related and future work, and chapter 10 presents my conclusions. 9 Chapter 2 Background This work has its offspring in systems programming in the Mjolner BETA system, including the implementation of a source level debugger, an object browser, a type-orthogonal persistent store and a distributed objects system <ref> [Brandt 94, Brandt & Madsen 94] </ref>. In addition, I have been involved in discussions relating to the design of a distributed object database, a distributed hypermedia [Gronbaek et al. 94] and an interpreter for the BETA language [Malhotra 94]. <p> The concept of attribute reference described in this report is exactly such a general language construct. In the implementation of the BETA persistent store and distribution library <ref> [Brandt 94] </ref>, the problem of limiting object graph traversals in a type orthogonal way lead to the development of a tailorable graph traversal algorithm. This object graph traversal algorithm is available as the ObjectSerializer library, supporting flexible marshalling of object graphs. <p> A proxy object is a local representative of a remote object, the principal. Distributed BETA <ref> [Brandt 94] </ref>, like several other distributed object systems, is based on the the notion of proxies. Unlike Smalltalk, however, BETA is statically typed, and therefore prevents message not understood at compile time. Thus, using message not understood is not an option in a statically typed language. <p> Since then, dynamic pattern references have played an important role in the design of a BETA interpreter [Malhotra 94], a callable dynamic linker and loader [Agesen & Frolund 89], the design and implementation of distribution and persistence libraries for BETA <ref> [Brandt & Madsen 94, Brandt 94, Sloth & Hem 93] </ref> and finally as a general programming facility. Pattern references can be considered the BETA generalisation of, e.g., function pointers in procedural programming languages such as C and Modula-2. <p> The ability to reflect on the execution of several doparts of the same object is useful to implement a general object distribution mechanism in BETA, as described in <ref> [Brandt 94] </ref>. The reason is that the execution of INNER could result in the need to move the executing object itself. 6.6.2 Variable Access The previous section described a meta-level interface for altering the execution of specific doparts. This section describes an interface for altering access to simple variables. <p> The trouble is that the complex object relationships present in BETA means that even defining a simple thing as "shallow copy" is not straightforward, and thus a number of alternative choices exist. Something akin to the tailorable object copying algorithm has already been implemented in the ObjectSerial-izer described in <ref> [Brandt 94] </ref>, and used as a building block for persistence and distribution in BETA. However, first of all it is implemented in an unsafe, low-level way requiring detailed knowledge of the object layout, garbage collector and runtime system in general. <p> The concept of attribute references and the meta-level interface support such separation of concerns. And, even more importantly, allows such optimizations to be implemented without changing the compiler. Thus, the language itself has become extensible and tailorable. 7.4 General Distribution Implementation As outlined in <ref> [Brandt 94] </ref>, the implementation of a fully general distributed object system for BETA involves the movement of method objects at different points in time. In some situations, object movement should occur when the INNER imperative is executed. <p> As a consequence, efficiency is likely to end up in between. Furthermore, a specific goal not induced by the implementation of the MLI, but rather of the intended uses of the MLI, is a distributed programming environment supporting general object persistence and distribution. This goal was outlined in <ref> [Brandt 94] </ref>. In the case of dynamically typed languages such as SELF and CLOS, there is usually no distinction between the programming environment and the runtime environment. <p> By replacing the passive file system by an active agent (the oodb), a number of problems are solved, and several new possibilities arise. Some of these are listed below: 1. All system objects are automatically assigned unique object id's (OID's), thereby solving problems of referential integrity described in <ref> [Brandt 94] </ref>. This is paramount for the secure implementation of persistence and distribution. 2. A process needing some kind of derived object may request it from the oodb. This eases the secure implementation of fine-grained dynamic link. <p> Concerning efficiency, the current oodb may have difficulties fulfilling the demands of an integrated distributed runtime environment. To address this problem, work is being done to provide more efficient persistence and locking mechanisms. Next, a distribution library is needed. The distribution library described in <ref> [Brandt 94, Brandt 93] </ref> is general enough for a prototype distributed programming environment. It is, for example, already used to implement the oodb. Finally, a very important component is a fine grained dynamic linker. <p> The provisional answer that I came up with was that I needed a way to talk about attributes, and that BETA did not allow me to do so. Thus, my first attempt to describe the notion of attribute references was part of <ref> [Brandt 94] </ref>, also describing the design, implementation and first uses of the ObjectSerializer. Apart from being more precise about what attribute references really are, the goal was to demonstrate their feasibility through a number of detailed examples.
Reference: [Chiba 93] <author> S. Chiba. </author> <title> Designing an Extensible Distributed Language with a Meta-Level Architechture. </title> <editor> In O. Nierstrasz, editor, </editor> <booktitle> ECOOP'93 - Object-Oriented Programming, volume 707 of LNCS, </booktitle> <pages> pages 482 - 501. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: Implementation work is under progress, and the first results have been reported elsewhere [Brandt & Schmidt 95]. 8.1 Existing Programming Environments Existing programming systems supporting reflection include SELF [Sun 93] CLOS [Kiczales et al. 91] and OpenC++ <ref> [Chiba 93] </ref>. SELF and CLOS are fully dynamic and include general and flexible reflectional capabilities, while OpenC++ is more restricted. The runtime environment outlined in the next section have goals in between CLOS/SELF and OpenC++. It will be less flexible than CLOS/SELF when it comes to exploratory capabilities. <p> In both cases, the destination address is resolved at link time. In order to retain efficiency, the implementation of the BETA MLI will therefore use dynamic replacement of code objects and dynamic linking techniques. OpenC ++ 's <ref> [Chiba 93] </ref> concept of reflect methods was the direct inspiration for the reflector pattern of the BETA MLI. However, OpenC ++ does not have introspective capabilities, and reflect methods must be known at compile time. <p> In any case, it was not directly applicable to BETA, being a compiled and statically typed language. Finally, "The Art of the Metaobject Protocol" [Kiczales et al. 91] gave me a practical understanding of what was really going on, and while reading a description of the OpenC++ <ref> [Chiba 93] </ref> system by Chiba, I realized that BETA could express reflection on method dispatch even better than OpenC++, using the orthogonality and larger expressive power of BETA as compared to C++.
Reference: [Decouchant 86] <author> D. Decouchant. </author> <title> Design of a Distributed Object Manager for the Smalltalk-80 System. </title> <booktitle> In OOPSLA'86 Proceedings, </booktitle> <year> 1986. </year>
Reference-contexts: In Smalltalk [Goldberg & Robson 83], a dynamically typed language, the intercessory capabilities needed for a distributed objects system can be implemented by overriding message not understood <ref> [McCullough 87, Decouchant 86] </ref> in special proxy objects. A proxy object is a local representative of a remote object, the principal. Distributed BETA [Brandt 94], like several other distributed object systems, is based on the the notion of proxies.
Reference: [Farkas & Dearle 93] <author> A. Farkas and A. Dearle. Octopus: </author> <title> A Reflective Language Mechanism for Object Manipulation. </title> <booktitle> In Proceedings of the Fourth International Workshop on Database Programming Languages. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The C ++ concept of pointers to members may be considered a restricted version of attribute references. However, the absence of runtime type information and restriction to function members, renders C ++ pointers to members considerably less useful than attribute references. Octopus <ref> [Farkas & Dearle 93] </ref> provides a reflective language mechanism for generic manipulation of complex object structures. Like the BETA MLI, the Octopus mechanism enforces static typing constraints, but does not allow the meta-level programmer to express such constraints.
Reference: [Freeman-Benson & Borning 92] <author> B. Freeman-Benson and A. Borning. </author> <title> Integrating constraints with an object oriented language. </title> <booktitle> In ECOOP'92 proceedings, number 615 in LNCS, </booktitle> <pages> pages 268 - 286. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 83 </month>
Reference-contexts: As a side remark, notice that two types of qualifications have been mentioned, namely those corresponding to structural constraints and those corresponding to identity constraints. The final possibility is constraints on the values of simple objects. Such constraints are the main subject of constraint imperative languages such as Kaleidoscope <ref> [Freeman-Benson & Borning 92, Lopez et al. ] </ref> and Siri [Horn 92], but are outside the scope and aims of this report. Notice however, that full object qualifications are really constraints that fix the value of object references.
Reference: [Goldberg & Robson 83] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80. The Language and its Implementation. </title> <publisher> Addison-Wesley, Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Since then, most work on computational reflection has been carried out in the context of dynamically 1 typed languages such as, e.g., CLOS [Kiczales et al. 91], ABCL [Masuhara et al. 92] and Smalltalk <ref> [Goldberg & Robson 83] </ref>. This report considers how to turn BETA, a statically 2 typed OO programming language, into a reflective programming language. In a statically typed programming language, the compiler generates code assuming that certain kinds of runtime type-errors cannot occur. <p> For example, message send must clearly be implemented differently in the local and remote cases. Furthermore, since BETA allows one object to directly access the substance attributes of other objects, attribute access will also need different implementations in the remote and local cases. In Smalltalk <ref> [Goldberg & Robson 83] </ref>, a dynamically typed language, the intercessory capabilities needed for a distributed objects system can be implemented by overriding message not understood [McCullough 87, Decouchant 86] in special proxy objects. A proxy object is a local representative of a remote object, the principal.
Reference: [Gronbaek et al. 94] <author> K. Gronbaek, J. Hem, O. Madsen, and L. Sloth. </author> <title> Hypermedia Systems: A Dexter-Based Architecture. </title> <journal> Communications of the ACM, </journal> <volume> 37(2):64 - 74, </volume> <month> Feb </month> <year> 1994. </year>
Reference-contexts: In addition, I have been involved in discussions relating to the design of a distributed object database, a distributed hypermedia <ref> [Gronbaek et al. 94] </ref> and an interpreter for the BETA language [Malhotra 94]. Work within these areas lead to the recognition of the applicability of a comprehensible meta-level interface for the BETA language.
Reference: [Holzle & Ungar 94] <author> U. Holzle and D. Ungar. </author> <title> A Third Generation Self Implementation: Reconciling Responsiveness with Performance. </title> <booktitle> In OOPSLA'94 Conference Proceedings, </booktitle> <pages> pages 229 - 243, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: As already noted, this includes information needed to implement the MLI. 3. The presence of an oodb enables replication of immutable objects. In large distributed environments this may lead to considerable performance gains. 1 Although type inference [Agesen & Ungar 94] and incremental optimization techniques <ref> [Holzle & Ungar 94] </ref> limits the cost considerably. 77 4. Derived objects may be created on demand. For example, binary code requested from the oodb may be created by asking a compiler to create it from source code already present in the oodb. <p> Most notably, the BETA MLI allows, but does not force, the meta-level programmer to express static typing constraints, thereby leading to more readable and possibly more efficient meta-level code. ABCL/R [Masuhara et al. 92], AL-1/D [Okamura et al. 93], and Self <ref> [Holzle & Ungar 94] </ref> are further examples of dynamically typed programming languages with reflectional capabilities. As with CLOS, the most notable difference between the meta-level interfaces of these languages, as compared to the BETA MLI, is the issue of static versus dynamic typing.
Reference: [Horn 92] <author> B. Horn. </author> <title> Constraint patterns as a basis for object oriented programming. </title> <booktitle> In OOPSLA'92 proceedings, </booktitle> <pages> pages 218 - 234. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: The final possibility is constraints on the values of simple objects. Such constraints are the main subject of constraint imperative languages such as Kaleidoscope [Freeman-Benson & Borning 92, Lopez et al. ] and Siri <ref> [Horn 92] </ref>, but are outside the scope and aims of this report. Notice however, that full object qualifications are really constraints that fix the value of object references. <p> Examples of constraint programming languages are Kaleidoscope [Lopez et al. ] and Siri <ref> [Horn 92] </ref> and the CLP family of languages [J. Jaffar et al. 92]. A constraint framework, Gleipner, has been implemented for the BETA programming language [Knudsen & Middelfart 94]. To use the Gleipner framework to constrain, e.g., integer values, the programmer must use a special integer class, cInteger.
Reference: [J. Jaffar et al. 92] <author> S. M. J. Jaffar, P. Stuckey, and R. Yap. </author> <title> The CLP(R) Language and System. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3):339 - 395, </volume> <year> 1992. </year>
Reference-contexts: Examples of constraint programming languages are Kaleidoscope [Lopez et al. ] and Siri [Horn 92] and the CLP family of languages <ref> [J. Jaffar et al. 92] </ref>. A constraint framework, Gleipner, has been implemented for the BETA programming language [Knudsen & Middelfart 94]. To use the Gleipner framework to constrain, e.g., integer values, the programmer must use a special integer class, cInteger.
Reference: [Jul 94] <author> E. </author> <month> Jul. </month> <title> Private conversation regarding work on heterogeneous Emerald, </title> <month> May </month> <year> 1994. </year>
Reference-contexts: In BETA, an activation record includes information on the currently executing object (remember that method activations are also object instances), the return address belonging to that activation record, and temporary register contents. To support implementation of a cross-platform introspectory interface to callstacks, we shall use the notion of busstops <ref> [Jul 94] </ref>. A busstop corresponds to a code address where the execution of a component may be suspended, either because of a procedure call, or due to thread preemption.
Reference: [Kiczales & Lamping 93] <author> G. Kiczales and J. </author> <title> Lamping. </title> <booktitle> Operating Systems: Why Object-Oriented? In Proceedings of IWOOOS'93, </booktitle> <year> 1993. </year>
Reference-contexts: Kiczales and Lamping <ref> [Kiczales & Lamping 93] </ref> introduces the term mapping dilemma to describe one general class of problems that can be solved using reflectional techniques and meta-level interfaces.
Reference: [Kiczales 94] <author> G. Kiczales. </author> <title> Why are black boxes so hard to reuse? (towards a new model of abstraction in the engineering of software). Invited Talk at OOPSLA'94, </title> <month> October </month> <year> 1994. </year>
Reference-contexts: Whenever a mapping dilemma crops up, we should still choose a feasible default solution, but we should also open up the implementation, allowing the user to change the default if it is not feasible for his particular purpose <ref> [Kiczales 94] </ref>. The result of "opening up" will be some sort of metaobject protocol, allowing the user to change and inspect the inner workings of the substrate system. Exposing mapping dilemmas are just one specific way of making systems flexible and thus more useful.
Reference: [Kiczales et al. 91] <author> G. Kiczales, J. Rivieres, and D. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The concept of computational reflection was originally introduced in [Smith 84], along with the 3-Lisp reflective programming language. Since then, most work on computational reflection has been carried out in the context of dynamically 1 typed languages such as, e.g., CLOS <ref> [Kiczales et al. 91] </ref>, ABCL [Masuhara et al. 92] and Smalltalk [Goldberg & Robson 83]. This report considers how to turn BETA, a statically 2 typed OO programming language, into a reflective programming language. <p> To the best of my knowledge, BETA is the first compiled and statically typed language for which a comprehensive meta-level interface has been designed. 1.1 Reflection and Meta-Level Architectures | Terminology Along the lines of <ref> [Kiczales et al. 91] </ref>, this report distinguishes introspectional reflection and intercessory reflection. Introspection 4 is the ability of a running program to look into and analyze its own current state. Intercession 5 is the ability to change the behaviour of certain primitives of the reflective system. <p> Thus, the meta-level architecture provides the internal representation of the system needed for the system to be reflectional. The meta-level interface is an interface to the meta-level architecture. A well-known example of a meta-level interface is the CLOS MOP <ref> [Kiczales et al. 91] </ref>, providing an interface to the (meta-) objects in the Common Lisp implementation of the CLOS language. 1.2 Why Reflection? Although most work on reflectional systems has been carried out in the context of dynamically typed programming languages, the problems attacked are of a more general nature, and <p> Implementation work is under progress, and the first results have been reported elsewhere [Brandt & Schmidt 95]. 8.1 Existing Programming Environments Existing programming systems supporting reflection include SELF [Sun 93] CLOS <ref> [Kiczales et al. 91] </ref> and OpenC++ [Chiba 93]. SELF and CLOS are fully dynamic and include general and flexible reflectional capabilities, while OpenC++ is more restricted. The runtime environment outlined in the next section have goals in between CLOS/SELF and OpenC++. <p> This is by no means trivial 3 , and is an interesting project in its own right. Work is being done on this subject. 2 Created by Bjorn Freeman-Benson. 3 Consider the replacement of active code. 78 Chapter 9 Related and Future Work 9.1 Related Work CLOS <ref> [Kiczales et al. 91] </ref> includes a comprehensive meta-level interface, (the CLOS MOP, or metaobject protocol), which allows the meta-level programmer to inspect and change several primitives of the basic programming language, including redefiniton of slot access, multiple inheritance semantics, and replacement of meta-classes. <p> Most of what I found emerged from the LISP community and was extremely theoretical in nature. In any case, it was not directly applicable to BETA, being a compiled and statically typed language. Finally, "The Art of the Metaobject Protocol" <ref> [Kiczales et al. 91] </ref> gave me a practical understanding of what was really going on, and while reading a description of the OpenC++ [Chiba 93] system by Chiba, I realized that BETA could express reflection on method dispatch even better than OpenC++, using the orthogonality and larger expressive power of BETA
Reference: [Knudsen & Middelfart 94] <author> J. Knudsen and J. Middelfart. </author> <title> Supporting constraints in beta. </title> <booktitle> Presented at NW-PER'94: Nordic Workshop on Programming Environment Research, </booktitle> <institution> Lund, Sweden. </institution> <note> Available from http://www.daimi.aau.dk/ beta/Papers/BETAconstraints/BETAconstraints.html, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Examples of constraint programming languages are Kaleidoscope [Lopez et al. ] and Siri [Horn 92] and the CLP family of languages [J. Jaffar et al. 92]. A constraint framework, Gleipner, has been implemented for the BETA programming language <ref> [Knudsen & Middelfart 94] </ref>. To use the Gleipner framework to constrain, e.g., integer values, the programmer must use a special integer class, cInteger. This means that attributes of pre-existing patterns cannot be constrained using Gleipner.
Reference: [Lopez et al. ] <author> G. Lopez, B. Freeman-Benson, and A. Borning. </author> <title> Kaleidoscope: A constraint imperative programming language. </title> <note> Draft of August 3, </note> <year> 1993. </year>
Reference-contexts: The "static object reference" operator, @, is evaluated once, namely at creation time of the containing object. The result of evaluating @(id; q) is to bind the object returned from &(q) to the identifier id. In the terminology of 25 the Kaleidoscope <ref> [Lopez et al. ] </ref> constraint imperative programming language, @ in the new interpretation is a "once" constraint enforced at object creation time. Afterwards, the binding of id is not allowed to change. These generalized semantics of @ interferes with the concept of object location as described in section 3.1.1. <p> As a side remark, notice that two types of qualifications have been mentioned, namely those corresponding to structural constraints and those corresponding to identity constraints. The final possibility is constraints on the values of simple objects. Such constraints are the main subject of constraint imperative languages such as Kaleidoscope <ref> [Freeman-Benson & Borning 92, Lopez et al. ] </ref> and Siri [Horn 92], but are outside the scope and aims of this report. Notice however, that full object qualifications are really constraints that fix the value of object references. <p> Examples of constraint programming languages are Kaleidoscope <ref> [Lopez et al. ] </ref> and Siri [Horn 92] and the CLP family of languages [J. Jaffar et al. 92]. A constraint framework, Gleipner, has been implemented for the BETA programming language [Knudsen & Middelfart 94].
Reference: [Madsen & Moller-Pedersen 92] <author> O. Madsen and B. Moller-Pedersen. </author> <title> Part Objects and Their Location. </title> <editor> In B. M. G. Heeg and B. Meyer, editors, </editor> <booktitle> Technology of Object-Oriented Languages and Systems - TOOLS 7, </booktitle> <year> 1992. </year>
Reference-contexts: In BETA, StatRefs are declared using the operator @, defining a two-way relationship between the objects. Given the whole, the part may as usual be found by following the reference, using dot notation. Reversely, the concept of object location <ref> [Madsen & Moller-Pedersen 92] </ref> gives a way to find the whole given a part. Thus, if the object aa is part of the object a, then location (aa) returns a reference to a. If aa is not a part of another object, then location (aa) returns NONE.
Reference: [Madsen & Norgard 93] <author> O. Madsen and C. Norgard. </author> <title> An Object-Oriented Metaprogramming System. </title> <editor> In J. Knudsen, O. Madsen, B. Magnusson, and M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> Sep </month> <year> 1993. </year>
Reference-contexts: Concerning the type of functionality provided, an octopus is similar to the PendingObject abstraction described in section 6.4. Octopus's provides only limited intercessory capabilities, through replacement of function pointers in singular objects. The Mjolner BETA Meta Programming System (MPS) <ref> [Madsen & Norgard 93] </ref>, is a grammar based library 79 for managing abstract syntax trees (AST's). Virtually all tools of the Mjolner BETA System (MBS) is built on top of MPS.
Reference: [Madsen et al. 93a] <author> O. Madsen, B.Magnusson, and B. Pedersen. </author> <title> Strong typing of object-oriented languages revisited. </title> <editor> In J. Knudsen, O. Madsen, B. Magnusson, and M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> Sep </month> <year> 1993. </year>
Reference-contexts: Simula is the only other language with these properties, although class nesting in Simula is more restricted than in BETA. This section describes the BETA type system. More on this subject can be found in <ref> [Madsen et al. 93a] </ref>. 16 3.2.1 Static Typing A program in an object-oriented programming language can be said to be correctly typed if the program never accesses non-existing attributes of an object. A language is said to be strongly typed if correct typing is enforced. <p> In a dynamically typed language, all type-checking is done at runtime. BETA is strongly typed with most type checking done at compile time. However, assignments that can be statically neither accepted nor rejected are subject to a runtime type check <ref> [Madsen et al. 93a] </ref>. Due to the type system of BETA (like, e.g., Eiffel [Meyer 92]) being covariant 2 , these runtime type checks cannot be completely removed in the general case. Compile time type checking in BETA is based on explicit type constraints (qualifications) on attribute declarations. <p> To talk about qualifications, I shall use the functions object (), which returns the object that a reference actually denotes, and qual (), which returns the statically known qualification of an identifier, or the actual pattern of an object <ref> [Madsen et al. 93a] </ref>. The declaration R: ^T implies that qual (R) = T, whereas qual (object (R)) is the actual pattern of the object referred by R.
Reference: [Madsen et al. 93b] <author> O. Madsen, B. MollerPedersen, and K. Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> Addison Wesley, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Chapter 3 then describes selected aspects of the BETA programming language. A complete description of BETA may be found in <ref> [Madsen et al. 93b] </ref>. Chapter 4 describes the generalization of the BETA qualification concept, and gives a few examples of the added expressive power. Attribute references are described in chapter 5. <p> In BETA, the most important abstraction mechanism is the pattern concept. The pattern is a generalization of concepts such as class, procedure, virtual procedure, and exception. For a complete description of the BETA language, see <ref> [Madsen et al. 93b] </ref>. A pattern P is declared as follows: P: Super (# Dec1l; Decl2; ... Decln enter In do Imp1; Imp2; ... <p> Therefore, in addition to function references, a dynamic pattern reference also plays the role of a dynamic 6 class reference. In comparison, ordinary nested patterns as described in section 3.2.2, correspond to static pattern references. 4 In the BETA book <ref> [Madsen et al. 93b] </ref> as well as in the original proposal [Agesen et al. 89], dynamic pattern references were called pattern variables.
Reference: [Maes & Nardi 88] <editor> P. Maes and D. Nardi, editors. </editor> <title> Meta-Level Architectures and Reflection. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: As might therefore be expected, the following definition of a reflective system from the preface of <ref> [Maes & Nardi 88] </ref>, clearly identifies a reflective system as a self-referential system: A computational system is said to be reflective when it is itself part of its own domain.
Reference: [Malhotra 94] <author> J. Malhotra. </author> <title> Tailorable Systems: Design, Support, Techniques, and Applications. (Daimi PB-466). </title> <type> PhD dissertation, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: In addition, I have been involved in discussions relating to the design of a distributed object database, a distributed hypermedia [Gronbaek et al. 94] and an interpreter for the BETA language <ref> [Malhotra 94] </ref>. Work within these areas lead to the recognition of the applicability of a comprehensible meta-level interface for the BETA language. <p> Furthermore, the debugger specific MLI would become much smaller. Program tracing in order to do, e.g., profiling could be supported in a reflective system by using the intercessory capabilities to redefine all methods to execute tracing code before entering the actual method body. 12 2.4 Interpretation The BETA interpreter <ref> [Malhotra 94] </ref> is an embeddable interpreter allowing compiled BETA programs to be extended with interpreted code. Thus, the interpreter needs to access a mix of interpreted and non-interpreted objects and call methods in these objects. Again portability is hurt by the lack of a platform independent MLI. <p> Originally, dynamic pattern references were proposed in [Agesen et al. 89] with the primary purpose of enabling extensibility 5 in a statically typed language. Since then, dynamic pattern references have played an important role in the design of a BETA interpreter <ref> [Malhotra 94] </ref>, a callable dynamic linker and loader [Agesen & Frolund 89], the design and implementation of distribution and persistence libraries for BETA [Brandt & Madsen 94, Brandt 94, Sloth & Hem 93] and finally as a general programming facility.
Reference: [Masuhara et al. 92] <author> H. Masuhara, S. Matsuoka, T. Watanabe, and A. Yonezawa. </author> <title> Object-Oriented Concurrent Reflective Languages can be Implemented Efficiently. </title> <editor> In A. Paepcke, editor, </editor> <booktitle> OOPSLA'92 Conference Proceedings, </booktitle> <pages> pages 127 - 144. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1992. </year> <month> 84 </month>
Reference-contexts: The concept of computational reflection was originally introduced in [Smith 84], along with the 3-Lisp reflective programming language. Since then, most work on computational reflection has been carried out in the context of dynamically 1 typed languages such as, e.g., CLOS [Kiczales et al. 91], ABCL <ref> [Masuhara et al. 92] </ref> and Smalltalk [Goldberg & Robson 83]. This report considers how to turn BETA, a statically 2 typed OO programming language, into a reflective programming language. In a statically typed programming language, the compiler generates code assuming that certain kinds of runtime type-errors cannot occur. <p> However, BETA is statically typed, whereas CLOS is dynamically typed, leading to a considerably different style of meta-level interface. Most notably, the BETA MLI allows, but does not force, the meta-level programmer to express static typing constraints, thereby leading to more readable and possibly more efficient meta-level code. ABCL/R <ref> [Masuhara et al. 92] </ref>, AL-1/D [Okamura et al. 93], and Self [Holzle & Ungar 94] are further examples of dynamically typed programming languages with reflectional capabilities.
Reference: [McCullough 87] <author> P. McCullough. </author> <title> Transparent forwarding: First steps. </title> <booktitle> In OOPSLA'87 Proceedings, </booktitle> <pages> pages 331 - 341, </pages> <year> 1987. </year>
Reference-contexts: In Smalltalk [Goldberg & Robson 83], a dynamically typed language, the intercessory capabilities needed for a distributed objects system can be implemented by overriding message not understood <ref> [McCullough 87, Decouchant 86] </ref> in special proxy objects. A proxy object is a local representative of a remote object, the principal. Distributed BETA [Brandt 94], like several other distributed object systems, is based on the the notion of proxies.
Reference: [Meyer 92] <author> B. Meyer. </author> <title> Eiffel, The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: For example, when copying complex objects, notions such as deep and shallow copying have become standard, since they are easy to describe and implement and furthermore seems to be reasonable defaults <ref> [Meyer 92] </ref>. However, a more generally useful copying mechanism should be tailorable, and thus allow the user to express exactly what parts of an object graph he wants copied. <p> BETA is strongly typed with most type checking done at compile time. However, assignments that can be statically neither accepted nor rejected are subject to a runtime type check [Madsen et al. 93a]. Due to the type system of BETA (like, e.g., Eiffel <ref> [Meyer 92] </ref>) being covariant 2 , these runtime type checks cannot be completely removed in the general case. Compile time type checking in BETA is based on explicit type constraints (qualifications) on attribute declarations. <p> Two different copying algorithms are shown. First, a generic "shallow copy" is implemented, corresponding to the Eiffel standard copy method <ref> [Meyer 92] </ref>. Second, a tailorable copying algorithm allowing the user of the algorithm to decide what dynamic reference attributes should be followed. Default for this second algorithm is a deep copy of the object graph reachable from the root object entered.
Reference: [Okamura et al. 93] <author> H. Okamura, Y. Ishikawa, and M. Tokoro. </author> <title> Metalevel Decomposition in AL-1/D. </title> <booktitle> In Proceedings of the International Symposium on Object Technologies for Advanced Software (ISOTAS), </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Most notably, the BETA MLI allows, but does not force, the meta-level programmer to express static typing constraints, thereby leading to more readable and possibly more efficient meta-level code. ABCL/R [Masuhara et al. 92], AL-1/D <ref> [Okamura et al. 93] </ref>, and Self [Holzle & Ungar 94] are further examples of dynamically typed programming languages with reflectional capabilities. As with CLOS, the most notable difference between the meta-level interfaces of these languages, as compared to the BETA MLI, is the issue of static versus dynamic typing.
Reference: [OMG 91] <author> OMG. </author> <title> The Common Object Request Broker Architecture and Specification, </title> <month> Dec </month> <year> 1991. </year> <title> Document number 91.12.1, Revision 1.1. </title>
Reference-contexts: What is the best policy depends on the application at hand. A classic example system providing some control over these aspects is Mach [Accetta et al. 86], through the concept of external pagers. * In the CORBA <ref> [OMG 91] </ref> distributed object specification, the concept of dynamic invocation interfaces allows client programs to dynamically synthesize requests to servers based on server descriptions obtained from an interface repository.
Reference: [Omohundro 93] <author> S. Omohundro. </author> <title> The Sather Programming Language. </title> <journal> Doctor Dobb's Journal, </journal> <year> 1993. </year>
Reference-contexts: Thus, we shall define the relation on qualifications by q q 0 def , extension (q) extension (q 0 ) 2 Usually, static typing of hierarchical type systems is ensured by enforcing contravariant relationships between super/sub types in a type-hierarchy <ref> [Black et al. 87, Omohundro 93] </ref>. 3 Work on constraint based type inference [Oxhoj et al. 92] of BETA programs is being done, possibly leading to the ability to get rid of most runtime type checks, although probably at the expense of separate compilation. 17 IntVal: (# value: @Integer; (* Integer
Reference: [Oxhoj et al. 92] <author> N. Oxhoj, J. Palsberg, and M. Schwartzbach. </author> <title> Making type inference practical. </title> <editor> In O. Mad-sen, editor, ECOOP'92. </editor> <booktitle> European Conference on Object-Oriented Programming, number 615 in LNCS, </booktitle> <pages> pages 329 - 349. </pages> <publisher> Springer-Verlag, </publisher> <month> June/July </month> <year> 1992. </year>
Reference-contexts: define the relation on qualifications by q q 0 def , extension (q) extension (q 0 ) 2 Usually, static typing of hierarchical type systems is ensured by enforcing contravariant relationships between super/sub types in a type-hierarchy [Black et al. 87, Omohundro 93]. 3 Work on constraint based type inference <ref> [Oxhoj et al. 92] </ref> of BETA programs is being done, possibly leading to the ability to get rid of most runtime type checks, although probably at the expense of separate compilation. 17 IntVal: (# value: @Integer; (* Integer part object. *) add: (* Pattern attribute *) (# amount: @Integer; enter amount
Reference: [Paepcke 88] <author> A. Paepcke. PCLOS: </author> <title> A flexible implementation of clos persistence. </title> <editor> In S. Gjessing and K. Ny-gaard, editors, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming, number 322 in LNCS, </booktitle> <pages> pages 374 - 389, </pages> <year> 1988. </year>
Reference-contexts: An example of an implementation of persistence on top of a MLI may be found in <ref> [Paepcke 88] </ref>, describing an implementation of persistence in CLOS. However, a persistence implementation purely on top of the meta-level interface is probably not able to achieve performance comparable to that of hardware assisted persistence such as that of the Texas persistent store [V. Singhal & Wilson 92].
Reference: [Robie & Witte 91] <author> J. Robie and B. </author> <title> Witte. </title> <booktitle> The POET handbook. </booktitle> <address> Berlin, Germany, </address> <year> 1991. </year>
Reference-contexts: That is, the language must be able to denote the basic primitives of the programming language itself. This is exactly the purpose of reflectional language capabilities. A number of special purpose systems have proposed special purpose solutions to these problems. For example, the POET <ref> [Robie & Witte 91] </ref> object oriented database system extends the C++ programming language with the transient keyword. Object attributes with storage type transient are not followed when saving persistent data to disk.
Reference: [Sloth & Hem 93] <author> L. Sloth and J. Hem. </author> <title> Object Oriented Model for the Distributed Object Oriented Database. </title> <type> Technical report, EuroCODE, </type> <institution> Workpackage WP2 Deliverable D2.2, </institution> <year> 1993. </year>
Reference-contexts: Since then, dynamic pattern references have played an important role in the design of a BETA interpreter [Malhotra 94], a callable dynamic linker and loader [Agesen & Frolund 89], the design and implementation of distribution and persistence libraries for BETA <ref> [Brandt & Madsen 94, Brandt 94, Sloth & Hem 93] </ref> and finally as a general programming facility. Pattern references can be considered the BETA generalisation of, e.g., function pointers in procedural programming languages such as C and Modula-2.
Reference: [Smith 84] <author> B. Smith. </author> <title> Reflection and semantics in Lisp. </title> <booktitle> In Proceedings of the 1984 ACM Principles of Programming Language Conference, </booktitle> <pages> pages 23-35. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1984. </year>
Reference-contexts: More precisely, this implies that (i) the system has an internal representation of itself, and (ii) the system sometimes shifts its "normal" computation about the external domain to "reflective" computation about itself. The concept of computational reflection was originally introduced in <ref> [Smith 84] </ref>, along with the 3-Lisp reflective programming language. Since then, most work on computational reflection has been carried out in the context of dynamically 1 typed languages such as, e.g., CLOS [Kiczales et al. 91], ABCL [Masuhara et al. 92] and Smalltalk [Goldberg & Robson 83].
Reference: [Stallman 81] <author> R. Stallman. </author> <title> Emacs: The extensible, customizable, self-documenting display editor. </title> <booktitle> In Proceedings of the ACM SIGPLAN SIGOA Symposium on Text Manipulation, </booktitle> <pages> pages 147-156, </pages> <year> 1981. </year>
Reference-contexts: Hence, this is an example of an introspectional capability. * The Emacs <ref> [Stallman 81] </ref> editor is an example of a meta-level architecture that has been around for quite a while. The success of Emacs is mainly due to its extreme customizability, allowing the user to change and replace parts of its implementation.
Reference: [Sun 93] <institution> Sun Microsystems Laboratories, Inc., </institution> <address> 2550, Garcia Avenue, Mountain View, CA 94043 USA. SELF 3.0, </address> <year> 1993. </year>
Reference-contexts: Implementation work is under progress, and the first results have been reported elsewhere [Brandt & Schmidt 95]. 8.1 Existing Programming Environments Existing programming systems supporting reflection include SELF <ref> [Sun 93] </ref> CLOS [Kiczales et al. 91] and OpenC++ [Chiba 93]. SELF and CLOS are fully dynamic and include general and flexible reflectional capabilities, while OpenC++ is more restricted. The runtime environment outlined in the next section have goals in between CLOS/SELF and OpenC++.
Reference: [V. Singhal & Wilson 92] <author> S. K. V. Singhal and P. Wilson. </author> <title> Texas: An Efficient, Portable Persistent Store. </title> <editor> In A. Albano and R. Morrison, editors, </editor> <booktitle> Persistent Object Systems, </booktitle> <address> San Miniato 1992, </address> <year> 1992. </year> <month> 85 </month>
Reference-contexts: However, a persistence implementation purely on top of the meta-level interface is probably not able to achieve performance comparable to that of hardware assisted persistence such as that of the Texas persistent store <ref> [V. Singhal & Wilson 92] </ref>. But even in such a system, the MLI would be useful in providing a flexible persistence mechanism, since attribute references and the MLI provide the expressive power needed to describe the necessary interfaces.
References-found: 45

