URL: http://www.pmg.lcs.mit.edu/papers/obj-clusters.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/Thor-papers.html
Root-URL: 
Email: mday@lcs.mit.edu  
Title: Object Groups May Be Better Than Pages  
Author: Mark Day 
Date: July 30, 1993  
Affiliation: MIT Laboratory for Computer Science  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Francois Bancilhon, Claude Delobel, and Paris Kanellakis, </author> <title> editors. Building an Object-Oriented Database: </title> <publisher> The Story of O 2 . Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: I consider the case where objects are moved or copied to the client for at least the duration of the client transaction. A number of existing object-oriented databases work partially or entirely in this mode of executing operations on the client machine: examples are O2 <ref> [1] </ref>, GemStone [2, 8], and Orion [6]. fl 545 Technology Square, Cambridge, MA 02139, USA.
Reference: [2] <author> Paul Butterworth, Allen Otis, and Jacob Stein. </author> <title> The GemStone object database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: I consider the case where objects are moved or copied to the client for at least the duration of the client transaction. A number of existing object-oriented databases work partially or entirely in this mode of executing operations on the client machine: examples are O2 [1], GemStone <ref> [2, 8] </ref>, and Orion [6]. fl 545 Technology Square, Cambridge, MA 02139, USA.
Reference: [3] <author> Mark F. Hornick and Stanley B. Zdonik. </author> <title> A shared, segmented memory system for an object-oriented database. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 70-95, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: We thus provide a tool to applications to describe their own clustering and use the result to prefetch accordingly. However, in contrast to previous work (such as segments and segment groups in ObServer <ref> [3] </ref>) we do not guarantee that the elements grouped by a crystal will be contiguous on disk. We use the crystal simply as a hint: we prefetch the objects present in memory, and we can start disk reads for the objects not in memory.
Reference: [4] <author> Ted Kaehler. </author> <title> Virtual memory for an object-oriented language. </title> <journal> Byte, </journal> <pages> pages 378-387, </pages> <month> August </month> <year> 1981. </year>
Reference-contexts: But by using prefetching and crystals, clients with more resources can also achieve higher performance than would be possible in a strict object-fetching system. OOZE <ref> [4] </ref> and LOOM [5, 10] already demonstrated the value of object faulting for small memories. Tunable prefetching seems likely to be useful for a wider range of clients than clustering into fixed-size pages could be.
Reference: [5] <author> Ted Kaehler. </author> <title> Virtual memory on a narrow machine for an object-oriented language. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 87-106, </pages> <year> 1986. </year>
Reference-contexts: But by using prefetching and crystals, clients with more resources can also achieve higher performance than would be possible in a strict object-fetching system. OOZE [4] and LOOM <ref> [5, 10] </ref> already demonstrated the value of object faulting for small memories. Tunable prefetching seems likely to be useful for a wider range of clients than clustering into fixed-size pages could be.
Reference: [6] <author> Won Kim, Nat Ballou, Hong-Tai Chou, Jorge F. Garza, Darrell Woelk, and Jay Banerjee. </author> <title> Integrating an object-oriented programming system with a database system. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 142-152, </pages> <year> 1988. </year>
Reference-contexts: A number of existing object-oriented databases work partially or entirely in this mode of executing operations on the client machine: examples are O2 [1], GemStone [2, 8], and Orion <ref> [6] </ref>. fl 545 Technology Square, Cambridge, MA 02139, USA. This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136 and in part by the National Science Foundation under Grant CCR-8822158.
Reference: [7] <author> Barbara Liskov, Mark Day, and Liuba Shrira. </author> <title> Distributed object management in Thor. </title> <editor> In M. Tamer Ozsu, Umesh Dayal, and Patrick Valduriez, editors, </editor> <booktitle> Distributed Object Management. </booktitle> <publisher> Mor-gan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: Taken together with the possibility of poor clustering spreading the objects of interest across multiple pages, big pages can lead to very inefficient use of the network and the client's local storage. In the Thor distributed object-oriented database system <ref> [7] </ref>, we have one mechanism for moving data between the server's memory and disk, and a different mechanism for moving data between the client and the server. Server segments are significantly larger than current pages. Segments are transferred between the disk and the server's memory.
Reference: [8] <author> David Maier, Jacob Stein, Allen Otis, and Alan Purdy. </author> <title> Development of an object-oriented DBMS. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 472-482, </pages> <year> 1986. </year>
Reference-contexts: I consider the case where objects are moved or copied to the client for at least the duration of the client transaction. A number of existing object-oriented databases work partially or entirely in this mode of executing operations on the client machine: examples are O2 [1], GemStone <ref> [2, 8] </ref>, and Orion [6]. fl 545 Technology Square, Cambridge, MA 02139, USA.
Reference: [9] <author> R. Hugo Patterson, Garth A. Gibson, and M. Satyanarayanan. </author> <title> A status report on research in transparent informed prefetch-ing. </title> <journal> ACM Operating Systems Review, </journal> <volume> 27(2) </volume> <pages> 21-34, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: How ever, as currently envisioned, crystals are user-or application-level hints, and so have more in common with the ideas of transparent informed prefetching <ref> [9] </ref>. One way to see a crystal is as a substitute for a cluster: we compute a placement and save it. A crystal is better than a cluster because multiple independent users can have conflicting crystals, but the system can have only one physical clustering.
Reference: [10] <author> James William Stamos. </author> <title> A large object-oriented virtual memory: Grouping strategies, measurements, and performance. </title> <type> Technical Report SCG-82-2, </type> <institution> Xe-rox PARC, </institution> <month> May </month> <year> 1982. </year>
Reference-contexts: This is in contrast to when Stamos made measurements of LOOM and estimated that a typical page would hold 11 objects <ref> [10] </ref>. As pages get larger, it seems less likely that a single page will contain only semantically-related objects, and more likely that a single page will contain a lot of junk from the point of view of any given application. <p> But by using prefetching and crystals, clients with more resources can also achieve higher performance than would be possible in a strict object-fetching system. OOZE [4] and LOOM <ref> [5, 10] </ref> already demonstrated the value of object faulting for small memories. Tunable prefetching seems likely to be useful for a wider range of clients than clustering into fixed-size pages could be.
Reference: [11] <author> Carl D. Tait and Dan Duchamp. </author> <title> Detection and exploitation of file working sets. </title> <booktitle> In Proceedings of the 11th Conference on Distributed Computing Systems, </booktitle> <pages> pages 2-9, </pages> <address> Arlington, Texas, </address> <year> 1991. </year>
Reference-contexts: It may also be possible to construct and use a crystal completely automatically, in a way analogous to the working graphs and program trees of Tait and Duchamp <ref> [11] </ref>. How ever, as currently envisioned, crystals are user-or application-level hints, and so have more in common with the ideas of transparent informed prefetching [9]. One way to see a crystal is as a substitute for a cluster: we compute a placement and save it.
Reference: [12] <author> Manolis M. Tsangaris and Jeffrey F. Naughton. </author> <title> On the performance of object clustering techniques. </title> <editor> In Michael Stonebraker, editor, </editor> <booktitle> Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 144-153. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: This effect is not just an intuition, but was apparent in recent work by Tsangaris and Naughton <ref> [12] </ref>. If it were possible, we would like to cluster as well as we can for each application.
References-found: 12

