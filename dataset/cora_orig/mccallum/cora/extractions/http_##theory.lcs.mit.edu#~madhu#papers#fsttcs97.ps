URL: http://theory.lcs.mit.edu/~madhu/papers/fsttcs97.ps
Refering-URL: http://theory.lcs.mit.edu/~madhu/papers.html
Root-URL: 
Title: Algorithmic issues in coding theory  
Phone: 1997.  
Author: Madhu Sudan 
Date: October 9, 1997  
Address: Kharagpur, India,  
Affiliation: Computer Science,  
Note: Invited paper: 17th Conference on Foundations of Software Technology and Theoretical  
Abstract: The goal of this article is to provide a gentle introduction to the basic definitions, goals and constructions in coding theory. In particular we focus on the algorithmic tasks tackled by the theory. We describe some of the classical algebraic constructions of error-correcting codes including the Hamming code, the Hadamard code and the Reed Solomon code. We describe simple proofs of their error-correction properties. We also describe simple and efficient algorithms for decoding these codes. It is our aim that a computer scientist with just a basic knowledge of linear algebra and modern algebra should be able to understand every proof given here. We also describe some recent developments and some salient open problems.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Ar, R. Lipton, R. Rubinfeld and M. Sudan. </author> <title> Reconstructing algebraic functions from mixed data. </title> <journal> SIAM Journal on Computing, </journal> <volume> to appear. </volume> <booktitle> Preliminary version in Proceedings of the 33rd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 503-512, </pages> <year> 1992. </year>
Reference-contexts: It is easy to count the number of such coefficients. The existence of such coefficients will determine our choice of m; l. Having determined such a polynomial we will apply the following useful lemma to show that p can be extracted from Q. Lemma 20 <ref> [1] </ref>. Let Q (x; y) = P i;j q ij x i y j be such that q ij = 0 for every i; j with i + (k 1)j &gt; l.
Reference: 2. <author> E. R. Berlekamp. </author> <title> Algebraic Coding Theory. </title> <publisher> McGraw Hill, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: All of this makes it important that a theoretical computer scientist be comfortable with the methods of this field | and this is the goal of this article. A reader interested in further details may try one of the more classical texts <ref> [2, 11, 17] </ref>. Also, the article of Vardy [18] is highly recommended for a more detailed account of progress in coding theory. <p> A large number of algebraic codes do have such polynomial time bounded distance decoding algorithms. In particular the Reed Solomon codes are known to have such a decoding algorithm for t b (d 1)=2c (cf. <ref> [2, 11, 17] </ref>). This classical result is very surprising given the non-trivial nature of this task. This result is also very crucial for many of the known asymptotically good codes, since many of these codes are constructed by concatenating Reed Solomon codes with some other codes.
Reference: 3. <author> E. R. Berlekamp. </author> <title> Bounded Distance +1 Soft-Decision Reed-Solomon Decoding. </title> <journal> In IEEE Transactions on Information Theory, pages 704-720, </journal> <volume> vol. 42, no. 3, </volume> <month> May </month> <year> 1996. </year>
Reference-contexts: Notice that there are exactly 2 l 1 of these. Lemma 2. For every positive integer n such that n = 2 l 1 for some integer l, the Hamming code of block size n is an <ref> [n; n l; 3] </ref> 2 code. Proof Sketch. Notice that the rank of H Hmg is l. In particular the column vectors containing exactly one 1 are linearly independent and there are l of them. <p> However no such algorithm is known for all possible values of (n; k; d = n k). Recently, in [16], we presented an algorithm which does correct up to (1 *)d errors, provided k=n ! 0. This algorithm was inspired by an algorithm of Welch and Berlekamp <ref> [20, 3] </ref> for decoding Reed Solomon codes. This algorithm is especially clean and elegant. Our solution uses similar ideas to correct even more errors and we present this next.
Reference: 4. <author> E. R. Berlekamp, R. J. McEliece and H. C. A. van Tilborg. </author> <title> On the inherent intractability of certain coding problems. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 24 </volume> <pages> 384-386, </pages> <year> 1978. </year>
Reference-contexts: In particular, for "asymptotically good" or even "weakly good" codes, both strategies above run in exponential time. One may wonder if this exponential time behavior is inherent to the decoding problem. In perhaps the first "complexity" result in coding theory, Berlekamp, McEliece and van Tilborg <ref> [4] </ref> present the answer to this question. Theorem 16 [4]. The Maximum likelihood decoding problem for general linear codes is NP-hard. There are two potential ways to attempt to circumvent this result. One method is to define and solve the maximum likelihood decoding problem for specific linear codes. <p> One may wonder if this exponential time behavior is inherent to the decoding problem. In perhaps the first "complexity" result in coding theory, Berlekamp, McEliece and van Tilborg <ref> [4] </ref> present the answer to this question. Theorem 16 [4]. The Maximum likelihood decoding problem for general linear codes is NP-hard. There are two potential ways to attempt to circumvent this result. One method is to define and solve the maximum likelihood decoding problem for specific linear codes. We will come to this question momentarily. <p> Input: n fi k generator matrix G for a code C = C G ; a received word R 2 n and a positive integer t. Output: Find any/all codewords in C within a Hamming distance of t from R. The hardness result of <ref> [4] </ref> actually applies to the Bounded distance decoding problem as well. <p> This motivates the following problem: Problem 18 (Minimum distance). Input: n fi k generator matrix G for a code C = C G and an integer parameter d. Output: Is the distance of C at least d? This problem was conjectured to be coNP-hard in <ref> [4] </ref>. The problem remained open for nearly two decades. Recently, in a major breakthrough, this problem was shown to be coNP-complete by Vardy [18].
Reference: 5. <author> R. DeMillo and R. Lipton. </author> <title> A probabilistic remark on algebraic program testing. </title> <journal> Information Processing Letters, </journal> <volume> 7(4) </volume> <pages> 193-195, </pages> <month> June </month> <year> 1978. </year>
Reference-contexts: Obviously the multivariate polynomial codes form a generalization of the Reed Solomon codes (again using the first definition given here of Reed Solomon codes). The distance property of the multivariate polynomial codes follow also from the distance property of multivariate polynomials (cf. <ref> [5, 13, 21] </ref>). Lemma 10.
Reference: 6. <author> O. Goldreich, R. Rubinfeld and M. Sudan. </author> <title> Learning polynomials with queries: The highly noisy case. </title> <booktitle> Proceedings of the 36th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 294-303, </pages> <year> 1995. </year>
Reference-contexts: Such a bound does exist for the value of t as given above <ref> [6, 12] </ref>, thus raising the hope that this problem may be solvable in polynomial time also. Similar questions may also be raised about decoding multivariate polynomials. In particular, we don't have polynomial time algorithms matching the bounded distance decoding algorithm from [16], even for the case of bivariate polynomials.
Reference: 7. <author> D. Grigoriev. </author> <title> Factorization of Polynomials over a Finite Field and the Solution of Systems of Algebraic Equations. </title> <editor> Translated from Zapiski Nauchnykh Seminarov Lenningradskogo Otdeleniya Matematicheskogo Instituta im. V. A. Steklova AN SSSR, </editor> <volume> Vol. 137, </volume> <pages> pp. 20-79, </pages> <year> 1984. </year>
Reference-contexts: Thus in this case also we have a polynomial time algorithm provided Q can be factored in polynomial time. Fortunately, such algorithms are known, due to Kaltofen [8] and Grigoriev <ref> [7] </ref> (see Kaltofen [9] for a survey of polynomial factorization algorithms). For k=n ! 0, the number of errors corrected by this algorithm approaches (1 o (1))n. A more detailed analysis of this algorithm and the number of errors corrected by it appear in [16].
Reference: 8. <author> E. Kaltofen. </author> <title> A Polynomial-Time Reduction from Bivariate to Univariate Integral Polynomial Factorization. </title> <booktitle> In 23rd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 57-64, </pages> <year> 1982. </year>
Reference-contexts: Thus in this case also we have a polynomial time algorithm provided Q can be factored in polynomial time. Fortunately, such algorithms are known, due to Kaltofen <ref> [8] </ref> and Grigoriev [7] (see Kaltofen [9] for a survey of polynomial factorization algorithms). For k=n ! 0, the number of errors corrected by this algorithm approaches (1 o (1))n. A more detailed analysis of this algorithm and the number of errors corrected by it appear in [16].
Reference: 9. <author> E. Kaltofen. </author> <title> Polynomial factorization 1987-1991. LATIN '92, </title> <editor> I. Simon (Ed.) </editor> <publisher> Springer LNCS, v. </publisher> <pages> 583 294-313, </pages> <year> 1992. </year>
Reference-contexts: Thus in this case also we have a polynomial time algorithm provided Q can be factored in polynomial time. Fortunately, such algorithms are known, due to Kaltofen [8] and Grigoriev [7] (see Kaltofen <ref> [9] </ref> for a survey of polynomial factorization algorithms). For k=n ! 0, the number of errors corrected by this algorithm approaches (1 o (1))n. A more detailed analysis of this algorithm and the number of errors corrected by it appear in [16].
Reference: 10. <author> R. Lidl and H. Niederreiter. </author> <title> Introduction to Finite Fields and their Applications. </title> <publisher> Cambridge University Press, </publisher> <year> 1986 </year>
Reference-contexts: We will also describe the algorithmic issues motivated by these combinatorial objects and try to provide some solutions (and summarize the open problems). (We assume some familiarity with algebra of finite fields <ref> [10, 19] </ref>.) Before going on to these issues, we once again stress the importance of the theory of error-correcting codes and its relevance to computer science.
Reference: 11. <author> F. J. MacWilliams and N. J. A. Sloane. </author> <title> The Theory of Error-Correcting Codes. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981. </year>
Reference-contexts: All of this makes it important that a theoretical computer scientist be comfortable with the methods of this field | and this is the goal of this article. A reader interested in further details may try one of the more classical texts <ref> [2, 11, 17] </ref>. Also, the article of Vardy [18] is highly recommended for a more detailed account of progress in coding theory. <p> A large number of algebraic codes do have such polynomial time bounded distance decoding algorithms. In particular the Reed Solomon codes are known to have such a decoding algorithm for t b (d 1)=2c (cf. <ref> [2, 11, 17] </ref>). This classical result is very surprising given the non-trivial nature of this task. This result is also very crucial for many of the known asymptotically good codes, since many of these codes are constructed by concatenating Reed Solomon codes with some other codes.
Reference: 12. <author> J. Radhakrishnan. </author> <type> Personal communication, </type> <month> January, </month> <year> 1996. </year>
Reference-contexts: Such a bound does exist for the value of t as given above <ref> [6, 12] </ref>, thus raising the hope that this problem may be solvable in polynomial time also. Similar questions may also be raised about decoding multivariate polynomials. In particular, we don't have polynomial time algorithms matching the bounded distance decoding algorithm from [16], even for the case of bivariate polynomials.
Reference: 13. <author> J. T. Schwartz. </author> <title> Fast probabilistic algorithms for verification of polynomial identities. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 701-717, </pages> <year> 1980. </year>
Reference-contexts: Obviously the multivariate polynomial codes form a generalization of the Reed Solomon codes (again using the first definition given here of Reed Solomon codes). The distance property of the multivariate polynomial codes follow also from the distance property of multivariate polynomials (cf. <ref> [5, 13, 21] </ref>). Lemma 10.
Reference: 14. <author> M. Sipser and D. A. Spielman. </author> <title> Expander codes. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 42(6) </volume> <pages> 1710-1722, </pages> <year> 1996. </year>
Reference-contexts: Lastly there is another class of codes, constructed by combinatorial means, for which bounded distance decoding for some t *d can be performed in polynomial time. These are the expander codes, due to Sipser and Spielman <ref> [14] </ref> and Spielman [15]. The results culminate in a code with very strong | linear time (!!!) | encoding and bounded distance decoding algorithms. In addition to being provably fast, the algorithms for the encoding and decoding of these codes are surprisingly simple and clean. <p> In addition to being provably fast, the algorithms for the encoding and decoding of these codes are surprisingly simple and clean. However, the description of the codes and analysis of the algorithm is somewhat out of the scope of this paper. We refer the reader to the original articles <ref> [14, 15] </ref> for details. 5 Decoding of Reed Solomon code As mentioned earlier a polynomial time algorithm for bounded distance decoding is known and this algorithm corrects up to t b (d 1)=2c errors.
Reference: 15. <author> D. A. Spielman. </author> <title> Linear-time encodable and decodable error-correcting codes. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 42(6) </volume> <pages> 1723-1731, </pages> <year> 1996. </year>
Reference-contexts: For specific linear codes such as the Reed Solomon codes it is possible to encode the codes faster, in time O (n log c n) for some constant c. However till recently no asymptotically good code was known to be encodable in linear time. In a recent breakthrough. Spielman <ref> [15] </ref> presented the first known code that is encodable in linear time. We will discuss this more in a little bit. The next obvious candidate problem is the decoding problem. <p> Lastly there is another class of codes, constructed by combinatorial means, for which bounded distance decoding for some t *d can be performed in polynomial time. These are the expander codes, due to Sipser and Spielman [14] and Spielman <ref> [15] </ref>. The results culminate in a code with very strong | linear time (!!!) | encoding and bounded distance decoding algorithms. In addition to being provably fast, the algorithms for the encoding and decoding of these codes are surprisingly simple and clean. <p> In addition to being provably fast, the algorithms for the encoding and decoding of these codes are surprisingly simple and clean. However, the description of the codes and analysis of the algorithm is somewhat out of the scope of this paper. We refer the reader to the original articles <ref> [14, 15] </ref> for details. 5 Decoding of Reed Solomon code As mentioned earlier a polynomial time algorithm for bounded distance decoding is known and this algorithm corrects up to t b (d 1)=2c errors. <p> While there is no immediate formal reasoning to believe so it seems reasonable to believe that ff 1 will be larger than ff. Next we move to the questions in the area of design of efficient codes, motivated by the work of Spielman <ref> [15] </ref>. Open Problem 3 For every &gt; 0, design a family of [n; n; ffin] 2 codes C n so that the bounded distance problem on C n with parameter t fln can be solved in linear time.
Reference: 16. <author> M. Sudan. </author> <title> Decoding of Reed Solomon codes beyond the error-correction bound. </title> <journal> Journal of Complexity, </journal> <volume> 13(1) </volume> <pages> 180-193, </pages> <month> March </month> <year> 1997. </year> <note> See also http://theory.lcs.mit.edu/~ madhu/papers.html for a more recent version. </note>
Reference-contexts: Given this latitude it is reasonable to hope for a polynomial-time decoding algorithm that corrects more errors say up to t &lt; (1*)d where * is some fixed constant. However no such algorithm is known for all possible values of (n; k; d = n k). Recently, in <ref> [16] </ref>, we presented an algorithm which does correct up to (1 *)d errors, provided k=n ! 0. This algorithm was inspired by an algorithm of Welch and Berlekamp [20, 3] for decoding Reed Solomon codes. This algorithm is especially clean and elegant. <p> For k=n ! 0, the number of errors corrected by this algorithm approaches (1 o (1))n. A more detailed analysis of this algorithm and the number of errors corrected by it appear in <ref> [16] </ref>. The result shows that this given an [n; n; (1 )n] q Reed Solomon code, the number of errors corrected by this algorithm approaches n 1 1 + where = $ r 1 2 : A plot of this curve against appears in Figure 1. <p> Fraction of errors corrected by the algorithm from <ref> [16] </ref> plotted against the rate of the code. Also plotted are the distance of the code and the classical error-correction bound. The goal here is to find the smallest factor ff (n) for which a polynomial time approximation algorithm exists. <p> Similar questions may also be raised about decoding multivariate polynomials. In particular, we don't have polynomial time algorithms matching the bounded distance decoding algorithm from <ref> [16] </ref>, even for the case of bivariate polynomials. This we feel may be the most tractable problem here. Open Problem 5 Find a bounded distance decoding algorithm for the bivariate polynomial code C poly;2;n;n that decodes up to t (1 p 2)n 2 errors.
Reference: 17. <author> J. H. van Lint. </author> <title> Introduction to Coding Theory. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: All of this makes it important that a theoretical computer scientist be comfortable with the methods of this field | and this is the goal of this article. A reader interested in further details may try one of the more classical texts <ref> [2, 11, 17] </ref>. Also, the article of Vardy [18] is highly recommended for a more detailed account of progress in coding theory. <p> A large number of algebraic codes do have such polynomial time bounded distance decoding algorithms. In particular the Reed Solomon codes are known to have such a decoding algorithm for t b (d 1)=2c (cf. <ref> [2, 11, 17] </ref>). This classical result is very surprising given the non-trivial nature of this task. This result is also very crucial for many of the known asymptotically good codes, since many of these codes are constructed by concatenating Reed Solomon codes with some other codes.
Reference: 18. <author> A. Vardy. </author> <title> Algorithmic complexity in coding theory and the minimum distance problem. </title> <booktitle> Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 92-109, </pages> <year> 1997. </year>
Reference-contexts: A reader interested in further details may try one of the more classical texts [2, 11, 17]. Also, the article of Vardy <ref> [18] </ref> is highly recommended for a more detailed account of progress in coding theory. <p> Output: Is the distance of C at least d? This problem was conjectured to be coNP-hard in [4]. The problem remained open for nearly two decades. Recently, in a major breakthrough, this problem was shown to be coNP-complete by Vardy <ref> [18] </ref>. While this does not directly rule out the possibility that a good bounded distance decoding algorithm may exist, the result should be ruled as one more reason that general positive results may be unlikely. <p> The bottleneck to such an approach is that in general we can't compute d in polynomial time, due to the recent result of Vardy <ref> [18] </ref>. Thus the next step in this direction seems to suggest an application of approximation algorithms: Open Problem 1 Given an n fi k matrix G, approximate the distance d of the code C G to within a factor of ff (n). [t] Fig. 1. <p> A similar problem is posed by Vardy <ref> [18] </ref> for ff 1 = 2. Here the hope would be to find the smallest value of ff 1 for which a polynomial time algorithm exists. While there is no immediate formal reasoning to believe so it seems reasonable to believe that ff 1 will be larger than ff.
Reference: 19. <author> B. L. van der Waerden. </author> <title> Algebra, Volume 1. </title> <publisher> Frederick Ungar Publishing Co., Inc., </publisher> <pages> page 82. </pages>
Reference-contexts: We will also describe the algorithmic issues motivated by these combinatorial objects and try to provide some solutions (and summarize the open problems). (We assume some familiarity with algebra of finite fields <ref> [10, 19] </ref>.) Before going on to these issues, we once again stress the importance of the theory of error-correcting codes and its relevance to computer science.
Reference: 20. <author> L. Welch and E. R. Berlekamp. </author> <title> Error correction of algebraic block codes. </title> <type> US Patent Number 4,633,470, </type> <note> issued December 1986. </note>
Reference-contexts: However no such algorithm is known for all possible values of (n; k; d = n k). Recently, in [16], we presented an algorithm which does correct up to (1 *)d errors, provided k=n ! 0. This algorithm was inspired by an algorithm of Welch and Berlekamp <ref> [20, 3] </ref> for decoding Reed Solomon codes. This algorithm is especially clean and elegant. Our solution uses similar ideas to correct even more errors and we present this next. <p> Thus p (x) = B (x)=A (x) and can be computed easily by a simple polynomial division. Thus in this case we can decode from b (n k)=2c errors thus recovering the results of <ref> [20] </ref>. In fact, in this case the algorithm essentially mimics the [20] algorithm, though the correspondence may not be immediately obvious. At a different extreme one may pick m p p nk and in this case Lemma 20 works for t n 2 p nk. <p> Thus p (x) = B (x)=A (x) and can be computed easily by a simple polynomial division. Thus in this case we can decode from b (n k)=2c errors thus recovering the results of <ref> [20] </ref>. In fact, in this case the algorithm essentially mimics the [20] algorithm, though the correspondence may not be immediately obvious. At a different extreme one may pick m p p nk and in this case Lemma 20 works for t n 2 p nk. In this case to recover p (x) from Q, one first factors the bivariate polynomial Q.
Reference: 21. <author> R. E. Zippel. </author> <title> Probabilistic algorithms for sparse polynomials. </title> <booktitle> EUROSAM '79, Lecture Notes in Computer Science, </booktitle> <volume> 72 </volume> <pages> 216-226, </pages> <year> 1979. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Obviously the multivariate polynomial codes form a generalization of the Reed Solomon codes (again using the first definition given here of Reed Solomon codes). The distance property of the multivariate polynomial codes follow also from the distance property of multivariate polynomials (cf. <ref> [5, 13, 21] </ref>). Lemma 10.
References-found: 21

