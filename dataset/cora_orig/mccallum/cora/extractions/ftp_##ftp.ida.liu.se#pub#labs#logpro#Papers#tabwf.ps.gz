URL: ftp://ftp.ida.liu.se/pub/labs/logpro/Papers/tabwf.ps.gz
Refering-URL: http://meryl.csd.uu.se/~rolandb/papers/index.html
Root-URL: 
Email: Email:bol@win.tue.nl  Email: larde@ida.liu.se  
Title: Tabulated Resolution for Well Founded Semantics  
Author: Roland Bol Lars Degerstedt 
Keyword: logic programming, deductive databases, well founded semantics, tabulation, search forest, SLS-resolution, implementation.  
Address: HG 8.88, P.O.Box 513 NL 5600 MB Eindhoven, Netherlands  S-581 83 Linkoping, Sweden  
Affiliation: Eindhoven University of Technology  Linkoping University  
Abstract: Based on the search forest for positive programs as defined by Bol and Degerstedt, we define a tabulated version of SLS-resolution that is sound and complete w.r.t. well founded semantics. In contrast to SLS-resolution as proposed by Przymusinski and by Ross, a positivistic computation rule is not required. This proposal is closely related to that of Chen and Warren, but it relies on tabulation for both positive and negative recursion. In this way, only one forest needs to be constructed, rather than a forest for each negative context. For function-free programs, the resulting search forest is finite. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.R. Apt, R.N. Bol, and J.W. Klop. </author> <title> On the safe termination of Prolog programs. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. of the Sixth International Conference on Logic Programming, Lisbon, </booktitle> <pages> pages 353-368. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: It should also be mentioned that a top-down computation of the well founded semantics for ground programs is described in [17]; instead of tabulation, it uses both positive and negative contexts. That such use of positive contexts does not generalize easily to the nonground case is shown in <ref> [1] </ref>. When comparing systems using tabulation with ordinary SLD-resolution, one can observe that tabulation implies the use of a local computation rule [27].
Reference: [2] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. of the Fifth Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: 1 Introduction It was shown in [5, 24] that bottom-up computation with magic templates <ref> [2, 22] </ref> and tabulated SLD-resolution [9, 26, 27] perform `essentially' the same computation. This result is made more precise in [4], where a common framework for both methods is discussed. <p> If there is an answer A in T , then A is a computed answer for A. An elaborate discussion on the search forest for positive programs, in particular its soundness, completeness and relations to other approaches (such as OLDT-resolution [26] and bottom-up computation with magic templates <ref> [2] </ref>) can be found in [4]. 3 The Search Forest for Normal Programs For positive programs, the search forest is created operationally by performing certain extensions, until no further extension is possible.
Reference: [3] <author> R.N. Bol. </author> <title> Loop Checking and Negation. </title> <journal> J. of Logic Programming, </journal> <volume> 15(2) </volume> <pages> 147-175, </pages> <year> 1993. </year>
Reference-contexts: Extension by answer, by u-answers and by floundering can be seen as three instances of the same idea: extension by potential answer (this term was coined in <ref> [3] </ref>). Definition 3.2 [Computed and Potential Answers] Let F be a forest and B an atom. We call B a computed answer for B in F , if a tree for B in F contains a leaf (computed answer node) B .
Reference: [4] <author> R.N. Bol and L. Degerstedt. </author> <title> The underlying search for magic templates and tabulation. </title> <type> Technical Report LiTH-IDA-R-93-01, </type> <institution> IDA, Linkoping University, </institution> <year> 1993. </year> <note> Extended abstract in D.S. </note> <editor> Warren, editor, </editor> <booktitle> Proc. of the Tenth International Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction It was shown in [5, 24] that bottom-up computation with magic templates [2, 22] and tabulated SLD-resolution [9, 26, 27] perform `essentially' the same computation. This result is made more precise in <ref> [4] </ref>, where a common framework for both methods is discussed. It is called the search forest, because it has the additional advantage that it separates the search space from the search strategy. We recall this framework in Section 2. <p> We say that the forest F 1 is a subforest of F 2 , notation F 1 v F 2 , if we can obtain F 1 (modulo the renaming of variables within resultants) by removing zero or more nodes (and all their descendents) from F 2 . In <ref> [4] </ref>, the search forest for positive programs was defined as follows. Definition 2.5 [The Search Forest for Positive Programs] Let P be a positive program, A an atomic query and R a fixed computation rule. <p> An elaborate discussion on the search forest for positive programs, in particular its soundness, completeness and relations to other approaches (such as OLDT-resolution [26] and bottom-up computation with magic templates [2]) can be found in <ref> [4] </ref>. 3 The Search Forest for Normal Programs For positive programs, the search forest is created operationally by performing certain extensions, until no further extension is possible. This is translated to a declarative definition (Definition 2.5) by taking the v-least forest that is closed under all extensions. <p> Throughout this section, we assume that a program P , an atomic query A and a computation rule R are fixed. 1 It is well-defined and unique up to renaming of variables, see Corollary 4.2 in <ref> [4] </ref>. 3.1 Positive Extensions For normal programs, we have the following positive extensions. Definition 3.1 [Positive Extensions] Let F be a forest. <p> Often extensions can be performed in parallel. Adding the nodes by increasing number is always a possible way of constructing the forest. 3.5.1 Positive Programs For positive programs, the search forest defined here is exactly the one defined in <ref> [4] </ref>, where some examples can be found. 3.5.2 Undefinedness due to Finite Loops through Negation Example 3.1 w p j j Node 3 is obtained by `extension by u-assumption', node 4 by `extension by u-answer'. Each u-answer node is both positively and negatively reliable and thus determinate. <p> By adding different search strategies, different interpreters for the well founded semantics can be obtained. In <ref> [4] </ref>, a search strategy is described by means of search sequences. <p> A search sequence for a positive search forest F is a sequence of forests fF g i = F 1 ; F 2 ; : : :, such that F i v F , and F i+1 extends F i with one new node according to Algorithm 1 in <ref> [4] </ref>: we say that we visit a node in F i for extension. A search sequence fF g i is said to be complete if its limit is the final search forest. Search in search forests for a normal program generalizes the postitive case. <p> However, node ! 2 can only be added by a transfinite search sequence. For a discussion on particular search strategies for positive forests, such as depth-first and breadth-first strategies, see <ref> [4] </ref>. Extending this discussion to forests for normal programs is still an area of research. Another area of research is the incorporation of constructive negation [6, 10, 20] in this framework. <p> Finally, the search forest should be compared with the search space generated by the magic templates of [16], similar to what was done in <ref> [4] </ref> for positive programs. Acknowledgements We thank W lodzimierz Drabent, Ulf Nilsson, Halina Przymusinska, Teodor Przymusinski and David S. Warren for many valuable discussions. Part of this research was carried out while the first author visited Linkoping University, supported by the Netherlands Organization for Sci entific Research (NWO).
Reference: [5] <author> F. Bry. </author> <title> Query evaluation in recursive databases: Bottom-up and top-down reconciled. </title> <booktitle> In Proc. of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction It was shown in <ref> [5, 24] </ref> that bottom-up computation with magic templates [2, 22] and tabulated SLD-resolution [9, 26, 27] perform `essentially' the same computation. This result is made more precise in [4], where a common framework for both methods is discussed.
Reference: [6] <author> D. Chan. </author> <title> Constructive negation based on the completed database. </title> <booktitle> In Kowalski and Bowen [13], </booktitle> <pages> pages 111-125. </pages>
Reference-contexts: For a discussion on particular search strategies for positive forests, such as depth-first and breadth-first strategies, see [4]. Extending this discussion to forests for normal programs is still an area of research. Another area of research is the incorporation of constructive negation <ref> [6, 10, 20] </ref> in this framework. The search forest approach has more symmetry between positive and negative literals than [7, 19, 23]: it does not assume a positivistic computation rule and does not use negative contexts.
Reference: [7] <author> W. Chen and D. S. Warren. </author> <title> A goal-oriented approach to computing well founded semantics. </title> <editor> In K. R. Apt, editor, </editor> <booktitle> Proc. of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 589-603, </pages> <address> Washington, 1992. </address> <publisher> ALP, MIT Press. </publisher>
Reference-contexts: We recall this framework in Section 2. The main aim of this paper is to define an acceptable search forest for arbitrary normal programs w.r.t. the (three-valued) well founded semantics [11]. We do not repeat the definition of the well founded model again; it can be found in <ref> [7, 11, 16, 17, 19, 21, 23] </ref> and many other papers. This definition suggests almost immediately how the well founded model can be computed bottom-up (for this case, magic templates are studied in [16]), but how to compute it top-down has been much less clear. <p> Section 4 contains some elementary results about the search forest, such as its soundness and completeness. The proposals by Przymusinski and Ross have no mechanism to detect (positive and negative) loops, so they are essentially ineffective. In <ref> [7] </ref>, a version of SLS-resolution is presented that detects positive loops by tabulation. Negative loops are detected by maintaining a negative context: the set of negative literals that may be assumed undefined, because they are encountered in a loop. <p> In some situations, the locality of a computation rule conflicts with its safeness [8]: avoiding the selection of nonground negative literals, if possible. We propose a solution for this problem, which is not dealt with in <ref> [7] </ref>, nor in the two proposed tabulation mechanisms for stratified programs [12, 25]. 2 Preliminaries We use the standard logic programming terminology and definitions of [14]. By `programs' we understand normal programs. We prefer to use the term `positive programs' instead of `definite programs'. <p> Apart from ordinary resultants, which use the program implication , we also need resultants that use another connective, denoted by u . The interpretation of H u B is: if B is not false, then H is not false. (Alternative notations are (H; u) B <ref> [7] </ref> and H u; B [16, 21].) Definition 2.2 Let H be an atom and B a sequence of literals. A resultant is a formula H B; a u-resultant is a formula H u B. We refer to (u-)resultants with empty bodies as (u-)answers. <p> Because q is failed, node 14 has no descendents and w is failed in F 5 . Example 5.3 This example is taken from Section 5 of <ref> [7] </ref>. w p (a); r 1 : w p (a); r 2 : p (a) ~p (f (a)) 3 : p (f (a)) ~p (f (f (a))) : : : !+2 : w u r !+1 : p (a) u !+3 : p (f (a)) u : : : All atoms <p> In F 2 , r and w are failed. The example shows again that we can, in contrast to <ref> [7] </ref>, avoid the locality of the computation rule, if needed. 5.3 Results Persistence, at least items (i) and (ii), now follows from the definitions. We have soundness and completeness results similar to the ones in Section 4. Finally, we have the following result. <p> Extending this discussion to forests for normal programs is still an area of research. Another area of research is the incorporation of constructive negation [6, 10, 20] in this framework. The search forest approach has more symmetry between positive and negative literals than <ref> [7, 19, 23] </ref>: it does not assume a positivistic computation rule and does not use negative contexts. Therefore we believe that our approach is more suitable for constructive negation than these others.
Reference: [8] <author> K. Clark. </author> <title> Negation as Failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <title> Logic and Databases. </title> <publisher> Plenum, </publisher> <year> 1978. </year>
Reference-contexts: By locality we understand that the computation of literals in a composite goal is done by computing one atom completely, before starting the computation of any of the others. In some situations, the locality of a computation rule conflicts with its safeness <ref> [8] </ref>: avoiding the selection of nonground negative literals, if possible. We propose a solution for this problem, which is not dealt with in [7], nor in the two proposed tabulation mechanisms for stratified programs [12, 25]. 2 Preliminaries We use the standard logic programming terminology and definitions of [14].
Reference: [9] <author> S. W. Dietrich. </author> <title> Extension tables: Memo relations in logic programming. </title> <booktitle> In Proc. of the 1987 Symposium on Logic Programming, </booktitle> <pages> pages 264-273, </pages> <address> San Fran-cisco, </address> <month> August - September </month> <year> 1987. </year> <title> IEEE, </title> <publisher> Computer Society Press. </publisher>
Reference-contexts: 1 Introduction It was shown in [5, 24] that bottom-up computation with magic templates [2, 22] and tabulated SLD-resolution <ref> [9, 26, 27] </ref> perform `essentially' the same computation. This result is made more precise in [4], where a common framework for both methods is discussed. It is called the search forest, because it has the additional advantage that it separates the search space from the search strategy.
Reference: [10] <author> W. Drabent. </author> <title> What is failure? An approach to constructive negation. </title> <type> Draft, </type> <year> 1992. </year> <note> Provisionally accepted by Acta Informatica. </note>
Reference-contexts: For a discussion on particular search strategies for positive forests, such as depth-first and breadth-first strategies, see [4]. Extending this discussion to forests for normal programs is still an area of research. Another area of research is the incorporation of constructive negation <ref> [6, 10, 20] </ref> in this framework. The search forest approach has more symmetry between positive and negative literals than [7, 19, 23]: it does not assume a positivistic computation rule and does not use negative contexts.
Reference: [11] <author> A. van Gelder, K. Ross, and J. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> J. of the ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: We recall this framework in Section 2. The main aim of this paper is to define an acceptable search forest for arbitrary normal programs w.r.t. the (three-valued) well founded semantics <ref> [11] </ref>. We do not repeat the definition of the well founded model again; it can be found in [7, 11, 16, 17, 19, 21, 23] and many other papers. <p> We recall this framework in Section 2. The main aim of this paper is to define an acceptable search forest for arbitrary normal programs w.r.t. the (three-valued) well founded semantics [11]. We do not repeat the definition of the well founded model again; it can be found in <ref> [7, 11, 16, 17, 19, 21, 23] </ref> and many other papers. This definition suggests almost immediately how the well founded model can be computed bottom-up (for this case, magic templates are studied in [16]), but how to compute it top-down has been much less clear.
Reference: [12] <author> D. B. Kemp and R. W. Topor. </author> <title> Completeness of a top-down query evaluation procedure for stratified databases. </title> <booktitle> In Kowalski and Bowen [13], </booktitle> <pages> pages 178-194. </pages>
Reference-contexts: In some situations, the locality of a computation rule conflicts with its safeness [8]: avoiding the selection of nonground negative literals, if possible. We propose a solution for this problem, which is not dealt with in [7], nor in the two proposed tabulation mechanisms for stratified programs <ref> [12, 25] </ref>. 2 Preliminaries We use the standard logic programming terminology and definitions of [14]. By `programs' we understand normal programs. We prefer to use the term `positive programs' instead of `definite programs'. Definition 2.1 Let P be a program and A an atom.
Reference: [13] <editor> R. A. Kowalski and K. A. Bowen, editors. </editor> <booktitle> Proc. of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <address> Seattle, 1988. </address> <publisher> ALP, MIT Press. </publisher>
Reference: [14] <author> J. W. Lloyd. </author> <note> Foundations of Logic Programming. Springer-Verlag, second, extended edition, </note> <year> 1987. </year>
Reference-contexts: We propose a solution for this problem, which is not dealt with in [7], nor in the two proposed tabulation mechanisms for stratified programs [12, 25]. 2 Preliminaries We use the standard logic programming terminology and definitions of <ref> [14] </ref>. By `programs' we understand normal programs. We prefer to use the term `positive programs' instead of `definite programs'. Definition 2.1 Let P be a program and A an atom.
Reference: [15] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> J. of Logic Programming, </journal> <volume> 11(3 </volume> & 4):217-242, October/November 1991. 
Reference-contexts: Notice that P jA is unique up to renaming of variables. In order to distinguish derived clauses from program clauses, we refer to them as resultants <ref> [15] </ref>. Apart from ordinary resultants, which use the program implication , we also need resultants that use another connective, denoted by u .
Reference: [16] <author> U. Nilsson. </author> <title> Goal-directed bottom-up evaluation of normal logic programs. </title> <type> Draft, </type> <year> 1993. </year>
Reference-contexts: We recall this framework in Section 2. The main aim of this paper is to define an acceptable search forest for arbitrary normal programs w.r.t. the (three-valued) well founded semantics [11]. We do not repeat the definition of the well founded model again; it can be found in <ref> [7, 11, 16, 17, 19, 21, 23] </ref> and many other papers. This definition suggests almost immediately how the well founded model can be computed bottom-up (for this case, magic templates are studied in [16]), but how to compute it top-down has been much less clear. <p> This definition suggests almost immediately how the well founded model can be computed bottom-up (for this case, magic templates are studied in <ref> [16] </ref>), but how to compute it top-down has been much less clear. The main problem is that two kinds of loops must be distinguished: loops through positive literals give rise to the answer `false', loops through negation can yield `undefined'. <p> The interpretation of H u B is: if B is not false, then H is not false. (Alternative notations are (H; u) B [7] and H u; B <ref> [16, 21] </ref>.) Definition 2.2 Let H be an atom and B a sequence of literals. A resultant is a formula H B; a u-resultant is a formula H u B. We refer to (u-)resultants with empty bodies as (u-)answers. <p> The discussion on positively and negatively reliable answers can probably even be simplified by the incorporation of constructive negation, as it is complicated mostly by floundering. Finally, the search forest should be compared with the search space generated by the magic templates of <ref> [16] </ref>, similar to what was done in [4] for positive programs. Acknowledgements We thank W lodzimierz Drabent, Ulf Nilsson, Halina Przymusinska, Teodor Przymusinski and David S. Warren for many valuable discussions.
Reference: [17] <author> L.M. Pereira, J.N. Aparcio, and J.J. Alferes. </author> <title> Derivation Procedures for Extended Stable Models. </title> <booktitle> In Proc. of 12th International Conference on Artificial Intelligence, </booktitle> <pages> pages 863-868. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: We recall this framework in Section 2. The main aim of this paper is to define an acceptable search forest for arbitrary normal programs w.r.t. the (three-valued) well founded semantics [11]. We do not repeat the definition of the well founded model again; it can be found in <ref> [7, 11, 16, 17, 19, 21, 23] </ref> and many other papers. This definition suggests almost immediately how the well founded model can be computed bottom-up (for this case, magic templates are studied in [16]), but how to compute it top-down has been much less clear. <p> Our method can handle this case (at least on a theoretical level: the forest becomes of course infinite), as is shown in Example 5.3. It should also be mentioned that a top-down computation of the well founded semantics for ground programs is described in <ref> [17] </ref>; instead of tabulation, it uses both positive and negative contexts. That such use of positive contexts does not generalize easily to the nonground case is shown in [1].
Reference: [18] <author> H. Przymusinska, T. C. Przymusinski, and H. Seki. </author> <title> Soundness and completeness of partial deductions for well-founded semantics. </title> <booktitle> In Proc. of the International Conference on Automated Reasoning, </booktitle> <year> 1992. </year>
Reference-contexts: Two proposals, [19, 23], solve this problem by using a positivistic and negatively parallel computation rule (terminology of [23]): a computation rule that first selects all positive literals, and thereafter all negative literals at the same time. (In <ref> [18, 21] </ref>, this idea is hidden behind a mechanism that skips negative literals that cannot be decided at the current stage of the computation; at the first stage, no negative literal can be decided and the computation of this first stage is included in all subsequent stages.) The restriction to positivistic
Reference: [19] <author> T. Przymusinski. </author> <title> Every logic program has a natural stratification and an iterated fixed point model. </title> <booktitle> In Proc. of the 8th Symposium on Principles of Database Systems, </booktitle> <pages> pages 11-21. </pages> <booktitle> ACM SIGACT-SIGMOD, </booktitle> <year> 1989. </year>
Reference-contexts: We recall this framework in Section 2. The main aim of this paper is to define an acceptable search forest for arbitrary normal programs w.r.t. the (three-valued) well founded semantics [11]. We do not repeat the definition of the well founded model again; it can be found in <ref> [7, 11, 16, 17, 19, 21, 23] </ref> and many other papers. This definition suggests almost immediately how the well founded model can be computed bottom-up (for this case, magic templates are studied in [16]), but how to compute it top-down has been much less clear. <p> The main problem is that two kinds of loops must be distinguished: loops through positive literals give rise to the answer `false', loops through negation can yield `undefined'. Two proposals, <ref> [19, 23] </ref>, solve this problem by using a positivistic and negatively parallel computation rule (terminology of [23]): a computation rule that first selects all positive literals, and thereafter all negative literals at the same time. (In [18, 21], this idea is hidden behind a mechanism that skips negative literals that cannot <p> In the way it is used here, extension by u-assumption can be seen as an implementation of a positivistic computation rule <ref> [19, 23] </ref>: it removes a ground negative literal as soon as that literal is selected, thus in the end a positive literal is selected. But things are more subtle than that. <p> Extending this discussion to forests for normal programs is still an area of research. Another area of research is the incorporation of constructive negation [6, 10, 20] in this framework. The search forest approach has more symmetry between positive and negative literals than <ref> [7, 19, 23] </ref>: it does not assume a positivistic computation rule and does not use negative contexts. Therefore we believe that our approach is more suitable for constructive negation than these others.
Reference: [20] <author> T. Przymusinski. </author> <title> On constructive negation in logic programming. </title> <editor> In E.L. Lusk and R.A. Overbeek, editors, </editor> <booktitle> Proc. of the North American Logic Programming Conference, </booktitle> <institution> page (Addendum), Cleveland, Ohio, </institution> <month> October </month> <year> 1989. </year> <title> ALP, </title> <publisher> MIT Press. </publisher>
Reference-contexts: For a discussion on particular search strategies for positive forests, such as depth-first and breadth-first strategies, see [4]. Extending this discussion to forests for normal programs is still an area of research. Another area of research is the incorporation of constructive negation <ref> [6, 10, 20] </ref> in this framework. The search forest approach has more symmetry between positive and negative literals than [7, 19, 23]: it does not assume a positivistic computation rule and does not use negative contexts.
Reference: [21] <author> T. C. Przymusinski and D. S. Warren. </author> <title> Well founded semantics: Theory and implementation. </title> <type> Draft, </type> <year> 1992. </year>
Reference-contexts: We recall this framework in Section 2. The main aim of this paper is to define an acceptable search forest for arbitrary normal programs w.r.t. the (three-valued) well founded semantics [11]. We do not repeat the definition of the well founded model again; it can be found in <ref> [7, 11, 16, 17, 19, 21, 23] </ref> and many other papers. This definition suggests almost immediately how the well founded model can be computed bottom-up (for this case, magic templates are studied in [16]), but how to compute it top-down has been much less clear. <p> Two proposals, [19, 23], solve this problem by using a positivistic and negatively parallel computation rule (terminology of [23]): a computation rule that first selects all positive literals, and thereafter all negative literals at the same time. (In <ref> [18, 21] </ref>, this idea is hidden behind a mechanism that skips negative literals that cannot be decided at the current stage of the computation; at the first stage, no negative literal can be decided and the computation of this first stage is included in all subsequent stages.) The restriction to positivistic <p> The interpretation of H u B is: if B is not false, then H is not false. (Alternative notations are (H; u) B [7] and H u; B <ref> [16, 21] </ref>.) Definition 2.2 Let H be an atom and B a sequence of literals. A resultant is a formula H B; a u-resultant is a formula H u B. We refer to (u-)resultants with empty bodies as (u-)answers.
Reference: [22] <author> R. Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Kowalski and Bowen [13], </booktitle> <pages> pages 140-159. </pages>
Reference-contexts: 1 Introduction It was shown in [5, 24] that bottom-up computation with magic templates <ref> [2, 22] </ref> and tabulated SLD-resolution [9, 26, 27] perform `essentially' the same computation. This result is made more precise in [4], where a common framework for both methods is discussed.
Reference: [23] <author> K. Ross. </author> <title> A procedural semantics for well-founded negation in logic programs. </title> <journal> J. of Logic Programming, </journal> <volume> 13(1) </volume> <pages> 1-22, </pages> <year> 1992. </year>
Reference-contexts: We recall this framework in Section 2. The main aim of this paper is to define an acceptable search forest for arbitrary normal programs w.r.t. the (three-valued) well founded semantics [11]. We do not repeat the definition of the well founded model again; it can be found in <ref> [7, 11, 16, 17, 19, 21, 23] </ref> and many other papers. This definition suggests almost immediately how the well founded model can be computed bottom-up (for this case, magic templates are studied in [16]), but how to compute it top-down has been much less clear. <p> The main problem is that two kinds of loops must be distinguished: loops through positive literals give rise to the answer `false', loops through negation can yield `undefined'. Two proposals, <ref> [19, 23] </ref>, solve this problem by using a positivistic and negatively parallel computation rule (terminology of [23]): a computation rule that first selects all positive literals, and thereafter all negative literals at the same time. (In [18, 21], this idea is hidden behind a mechanism that skips negative literals that cannot <p> The main problem is that two kinds of loops must be distinguished: loops through positive literals give rise to the answer `false', loops through negation can yield `undefined'. Two proposals, [19, 23], solve this problem by using a positivistic and negatively parallel computation rule (terminology of <ref> [23] </ref>): a computation rule that first selects all positive literals, and thereafter all negative literals at the same time. (In [18, 21], this idea is hidden behind a mechanism that skips negative literals that cannot be decided at the current stage of the computation; at the first stage, no negative literal <p> In the way it is used here, extension by u-assumption can be seen as an implementation of a positivistic computation rule <ref> [19, 23] </ref>: it removes a ground negative literal as soon as that literal is selected, thus in the end a positive literal is selected. But things are more subtle than that. <p> The reader can check that the answer nodes 5 and 7 are only negatively reliable, that the answers nodes 6, 8, 9 and 10 are only positively reliable and that they are all determinate in the final forest. Example 3.4 The following example, taken from <ref> [23] </ref>, shows that it can take a transfinite number of iterations to construct the search forest. <p> This construction is needed to handle the universal query problem. See e.g. <ref> [23] </ref> for details. 5.1 Definitions Definition 5.1 [Dependency Relation] Let F be a forest, B an atom and G a node in F . B 7! 1 F G iff G is a node in a tree for B in F and G 62 F . <p> Extending this discussion to forests for normal programs is still an area of research. Another area of research is the incorporation of constructive negation [6, 10, 20] in this framework. The search forest approach has more symmetry between positive and negative literals than <ref> [7, 19, 23] </ref>: it does not assume a positivistic computation rule and does not use negative contexts. Therefore we believe that our approach is more suitable for constructive negation than these others.
Reference: [24] <author> H. Seki. </author> <title> On the power of Alexander Templates. </title> <booktitle> In Proc. of the 8th Symposium on Principles of Database Systems. ACM SIGACT-SIGMOD, </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction It was shown in <ref> [5, 24] </ref> that bottom-up computation with magic templates [2, 22] and tabulated SLD-resolution [9, 26, 27] perform `essentially' the same computation. This result is made more precise in [4], where a common framework for both methods is discussed.
Reference: [25] <author> H. Seki and H. Itoh. </author> <title> A query evaluation method for stratified programs under the extended CWA. </title> <booktitle> In Kowalski and Bowen [13], </booktitle> <pages> pages 195-211. </pages>
Reference-contexts: In some situations, the locality of a computation rule conflicts with its safeness [8]: avoiding the selection of nonground negative literals, if possible. We propose a solution for this problem, which is not dealt with in [7], nor in the two proposed tabulation mechanisms for stratified programs <ref> [12, 25] </ref>. 2 Preliminaries We use the standard logic programming terminology and definitions of [14]. By `programs' we understand normal programs. We prefer to use the term `positive programs' instead of `definite programs'. Definition 2.1 Let P be a program and A an atom.
Reference: [26] <author> H. Tamaki and T. Sato. </author> <title> OLD resolution with tabulation. </title> <editor> In E. Shapiro, editor, </editor> <booktitle> Proc. of the Third International Conference on Logic Programming, Lecture Notes in Computer Science 225, </booktitle> <pages> pages 84-98, </pages> <address> London, 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction It was shown in [5, 24] that bottom-up computation with magic templates [2, 22] and tabulated SLD-resolution <ref> [9, 26, 27] </ref> perform `essentially' the same computation. This result is made more precise in [4], where a common framework for both methods is discussed. It is called the search forest, because it has the additional advantage that it separates the search space from the search strategy. <p> If there is an answer A in T , then A is a computed answer for A. An elaborate discussion on the search forest for positive programs, in particular its soundness, completeness and relations to other approaches (such as OLDT-resolution <ref> [26] </ref> and bottom-up computation with magic templates [2]) can be found in [4]. 3 The Search Forest for Normal Programs For positive programs, the search forest is created operationally by performing certain extensions, until no further extension is possible.
Reference: [27] <author> L. Vieille. </author> <title> Recursive Query Processing: the Power of Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(1) </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction It was shown in [5, 24] that bottom-up computation with magic templates [2, 22] and tabulated SLD-resolution <ref> [9, 26, 27] </ref> perform `essentially' the same computation. This result is made more precise in [4], where a common framework for both methods is discussed. It is called the search forest, because it has the additional advantage that it separates the search space from the search strategy. <p> That such use of positive contexts does not generalize easily to the nonground case is shown in [1]. When comparing systems using tabulation with ordinary SLD-resolution, one can observe that tabulation implies the use of a local computation rule <ref> [27] </ref>. By locality we understand that the computation of literals in a composite goal is done by computing one atom completely, before starting the computation of any of the others.
References-found: 27

