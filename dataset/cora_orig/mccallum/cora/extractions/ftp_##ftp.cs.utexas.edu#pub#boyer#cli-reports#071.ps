URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/071.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/index.html
Root-URL: http://www.cs.utexas.edu
Title: Mechanically Verifying Concurrent Programs  
Phone: (512) 322-9951  
Author: David Moshe Goldschlag 
Note: This work, originally presented as a Ph.D. thesis at the  was sponsored in part at Computational Logic, Inc. by the Defense Advanced Research Projects Agency, ARPA Order 7406. The views and conclusions contained in this document are those of the author(s) and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency, or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  University of Texas at Austin,  
Abstract: Technical Report 71 May, 1992 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi and Leslie Lamport. </author> <title> The Existence of Refinement Mappings. </title> <type> Technical Report Research Report 29, </type> <institution> DEC Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> August, </month> <year> 1988. </year>
Reference-contexts: The mechanization of Unity presented here focuses on the first characteristic. The latter is a refinement methodology and the necessary proof rules have not been formalized. As an example of the Unity notation, consider the following program which sorts an array of N elements X <ref> [1] </ref>, . . . , X [N] into non-decreasing order: &lt;" I, J : 0 &lt; I < J <= N : X [I], X [J] := X [J], X [I] This program contains N (N-1)/2 statements, each of which swaps an out-of-order pair of array elements. <p> Because program statements are logical formulas, no translation is necessary between a programming language and a logical notation. Another advantage is that it is possible to prove that one program implements another via refinement mappings <ref> [1] </ref>. TLA includes quantification over state variables and is sufficiently expressive to support Lamport's hierarchical method of designing concurrent programs [57]. TLA is being mechanized in LP [24], the theorem prover implementing the Larch shared specification language [38], and mechanical proofs of several programs are in progress.
Reference: [2] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining Liveness. </title> <booktitle> Information Processing Letters21:181-185, </booktitle> <year> 1985. </year>
Reference-contexts: Safety properties are those that state that something bad will never happen [3]; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties state that something good will eventually happen <ref> [2] </ref>; examples are termination and freedom from starvation.
Reference: [3] <author> Bowen Alpern, Alan J. Demers, and Fred B. Schneider. </author> <title> Safety Without Stuttering. </title> <booktitle> Information Processing Letters23:177-180, </booktitle> <year> 1986. </year>
Reference-contexts: Proof rules will be theorems permitting the proofs of correctness properties. 3.1 Specification Predicates The Unity logic permits reasoning about the safety and liveness (progress) properties of concurrent programs. Safety properties are those that state that something bad will never happen <ref> [3] </ref>; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties state that something good will eventually happen [2]; examples are termination and freedom from starvation.
Reference: [4] <institution> Flemming Anderson. </institution>
Reference-contexts: Although automatic verification of propositional temporal specifications of finite state machines has been explored for some time [22, 19, 14, 18], most other projects investigating the semiautomatic verification of non-propositional specifications of concurrent systems are relatively recent and were started after this research began <ref> [16, 77, 4, 72] </ref>. The Gypsy system [34] formalized mechanized proof rules for verifying invariants of message passing systems over ten years ago, however. These will be discussed in the next sections. <p> It provides a proof system for a subset of CSP. Unfortunately, however, this mechanical support was not demonstrated on any CSP programs. 13 1.3.8 Unity in HOL Fleming Andersen has encoded most of Unity proofs rules in HOL in an interesting manner <ref> [4] </ref>. The methodological details are sketchy, however, since the report is still being written. In any case, this formalization in HOL is not supported by an execution-based semantics. Rather, Unity's LEADS-TO relation was characterized directly in terms of the three defining axioms in [17].
References-found: 4

