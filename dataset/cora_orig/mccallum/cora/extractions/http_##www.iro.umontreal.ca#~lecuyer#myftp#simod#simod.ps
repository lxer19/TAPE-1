URL: http://www.iro.umontreal.ca/~lecuyer/myftp/simod/simod.ps
Refering-URL: http://www.iro.umontreal.ca/~lecuyer/papers.html
Root-URL: http://www.iro.umontreal.ca
Email: Resume  
Title: SIMOD Definition fonctionnelle et guide d'utilisation Premiere version ao^ut 1987 Version courante du guide septembre 1993  
Author: Pierre L'Ecuyer 
Keyword: Presentement, SIMOD est implante sous VAX/VMS, MS-DOS, et SUN/OS.  
Address: Montreal  
Affiliation: Departement d'I.R.O., Universite de  
Abstract: SIMOD est un progiciel de simulation de systemes stochastiques a evenements discrets, avec vision par evenements ou par processus. Il supporte aussi la simulation continue, pour laquelle l'evolution de certaines variables du modele se fait selon des equations differentielles. Le progiciel est implante sous forme de modules pre-compiles, ecrits en Modula-2. Ces modules comprennent des types de donnees predefinis, des fonctions, des procedures, et supportent une partie de l'execution des programmes utilisateurs. Ces outils permettent d'exprimer un modele de facon relativement concise, dans un langage lisible. Il ne s'agit pas d'un nouveau langage; en realite, un programme SIMOD est un programme Modula-2 qui utilise les modules de SIMOD. Ceux qui connaissent deja la syntaxe de Modula-2 (qui ressemble en fait beaucoup a celle de Pascal) n'ont donc pas de nouvelle syntaxe a apprendre pour utiliser SIMOD. Le progiciel gere l'horloge et la liste des evenements d'une simulation. Il fournit des outils pour gerer des listes, generer des valeurs pseudo-aleatoires selon differentes lois de probabilite et recueillir des statistiques durant la simulation. Les objets "actifs" dans le systeme peuvent ^etre representes par des processus, et SIMOD s'occupe de la synchronisation entre les processus, implantes sous forme de co-routines. Differentes formes de synchronisation entre les processus sont disponibles, telles que l'exclusion mutuelle par des ressources a capacite limitee, la relation de type producteur/consommateur par le biais d'un tampon (une pile de jetons), l'attente sur des conditions, et les relations de type ma^itre/esclave. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Birtwistle, G. M., Lomow, G., Unger, B., and Luker, P. </author> <year> (1986). </year> <title> Process Style Packages for Discrete Event Modelling. </title> <journal> Transactions of the Society for Computer Simulation, </journal> <volume> 3, 4, </volume> <pages> 279-318. </pages>
Reference-contexts: D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C [26], Simula <ref> [1, 2] </ref>, SMALLTALK [10], SCHEME (un dialecte de Lisp) [27], PROLOG [31], etc. Quelques-uns sont aussi implantes en Modula-2 [18, 25], mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire. <p> BEGIN EVENT.Create (Fermeture, ProcFermeture, 'Fermeture du site'); PROCS.Create (GenArrivee, ProcGenArrivee, 1000, "Generateur d'arrivees"); PROCS.Create (Hotesse, ProcHotesse, 2000, 'Une hotesse'); BIN.Create (VisiteOK, Fifo, 'Groupe'); STAT.Create (StatPertes, STAT.Tally, 'Les clients perdus'); FOR i := 0 TO 3 DO V [i] := VAL (LONGREAL, i + 1) END; F [0] := 0.2; F <ref> [1] </ref> := 0.8; F [2] := 0.9; F [3] := 1.0; CreateDiscreteDist (TailleArriv, 4, V, F); FOR Rep := 1 TO 10 DO SimulerUneRepetition END; STAT.ReportConfidenceInterval (StatPertes, 0.9) END Visites. 20 3 EXEMPLES DE PROGRAMMES SIMOD Une visite dure 45 minutes et necessite une hotesse. <p> Le robot peut prendre une decision lorsqu'il arrive a destination, ou lors d'une fin de reparation, ou lorsqu'une machine se bloque pendant qu'il n'est pas en train d'effectuer une reparation. L'etat du systeme, tel qu'observe par le robot, est un couple (p; E), ou p 2 <ref> [1; N] </ref> indique la position du robot sur la ligne, et E f1; : : : ; N g est l'ensemble des machines qui sont en panne. Chaque decision d du robot est un element de l'ensemble D = f0; 1; : : : ; N g.
Reference: [2] <author> Birtwistle, G. M. </author> <year> (1979). </year> <title> Demos | A System for Discrete Event Modelling on Simula. </title> <publisher> MacMillan. </publisher>
Reference-contexts: Certaines des idees de SIMOD sont inspirees du progiciel DEMOS <ref> [2] </ref>, base sur le langage Simula [3], de SIMSCRIPT II.5 [24], et de SIMPascal [13]. D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. <p> D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C [26], Simula <ref> [1, 2] </ref>, SMALLTALK [10], SCHEME (un dialecte de Lisp) [27], PROLOG [31], etc. Quelques-uns sont aussi implantes en Modula-2 [18, 25], mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire. <p> 'Fermeture du site'); PROCS.Create (GenArrivee, ProcGenArrivee, 1000, "Generateur d'arrivees"); PROCS.Create (Hotesse, ProcHotesse, 2000, 'Une hotesse'); BIN.Create (VisiteOK, Fifo, 'Groupe'); STAT.Create (StatPertes, STAT.Tally, 'Les clients perdus'); FOR i := 0 TO 3 DO V [i] := VAL (LONGREAL, i + 1) END; F [0] := 0.2; F [1] := 0.8; F <ref> [2] </ref> := 0.9; F [3] := 1.0; CreateDiscreteDist (TailleArriv, 4, V, F); FOR Rep := 1 TO 10 DO SimulerUneRepetition END; STAT.ReportConfidenceInterval (StatPertes, 0.9) END Visites. 20 3 EXEMPLES DE PROGRAMMES SIMOD Une visite dure 45 minutes et necessite une hotesse.
Reference: [3] <author> Birtwistle, G. M., Dahl, O. J., Myhrhaug, B., and Nygaard, K. </author> <year> (1979). </year> <title> Simula begin. </title> <publisher> Lund:Studentlitteratur. </publisher>
Reference-contexts: Certaines des idees de SIMOD sont inspirees du progiciel DEMOS [2], base sur le langage Simula <ref> [3] </ref>, de SIMSCRIPT II.5 [24], et de SIMPascal [13]. D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. <p> (GenArrivee, ProcGenArrivee, 1000, "Generateur d'arrivees"); PROCS.Create (Hotesse, ProcHotesse, 2000, 'Une hotesse'); BIN.Create (VisiteOK, Fifo, 'Groupe'); STAT.Create (StatPertes, STAT.Tally, 'Les clients perdus'); FOR i := 0 TO 3 DO V [i] := VAL (LONGREAL, i + 1) END; F [0] := 0.2; F [1] := 0.8; F [2] := 0.9; F <ref> [3] </ref> := 1.0; CreateDiscreteDist (TailleArriv, 4, V, F); FOR Rep := 1 TO 10 DO SimulerUneRepetition END; STAT.ReportConfidenceInterval (StatPertes, 0.9) END Visites. 20 3 EXEMPLES DE PROGRAMMES SIMOD Une visite dure 45 minutes et necessite une hotesse.
Reference: [4] <author> Bratley, P., Fox, B. L. et Schrage, L. E. </author> <year> (1987). </year> <title> A Guide to Simulation. Second edition, </title> <publisher> Springer-Verlag, </publisher> <address> New York. </address>
Reference-contexts: Les modeles les plus realistes sont habituellement dynamiques et stochastiques, c'est-a-dire que leur etat evolue dans le temps et que cette evolution peut se faire de facon aleatoire. SIMOD permet de simuler des modeles de ce genre. Il a ete concu surtout pour la simulation a evenements discrets <ref> [4, 5, 11, 12] </ref>, mais permet aussi la simulation continue. Dans la pratique, les programmes de simulation ont longtemps ete (et sont encore souvent) ecrits dans des langages tout-usage, tels que C, Pascal ou FORTRAN [12, 4]. <p> Il a ete concu surtout pour la simulation a evenements discrets [4, 5, 11, 12], mais permet aussi la simulation continue. Dans la pratique, les programmes de simulation ont longtemps ete (et sont encore souvent) ecrits dans des langages tout-usage, tels que C, Pascal ou FORTRAN <ref> [12, 4] </ref>. Dans le but d'ameliorer la productivite, on a developpe, dans ces langages, des librairies de sous-routines fournissant des outils de base pour la programmation de simulation. On a aussi cree, par ailleurs, des langages specialises pour la simulation. <p> On examine differentes politiques pour dif-ferentes configurations, et dans chaque cas, on calcule un intervalle de confiance sur la pro-ductivite. Pour calculer cet intervalle de confiance, on utilise ici la methode des lots ("batch means") <ref> [4, 12] </ref>. On simule pour une duree donnee, que l'on subdivise en NLots intervalles de temps egaux (de duree DureeLot). Les resultats des Rechauf premiers intervalles sont elim-ines, et on traite les moyennes associees aux intervalles restants comme (NLots-Rechauf) valeurs de variables aleatoires independantes, distribuees selon la loi normale. <p> DO STAT.Report (G [i]^.Prod) END; SIM.Stop END ProcFinSim; BEGIN EVENT.Create (FinSim, ProcFinSim, "Fin de la simulation"); RES.Create (Guy, RES.Fifo, 1, "Le reparateur Guy"); RES.Create (Bob, RES.Fifo, 1, "Le reparateur Bob"); FOR i := 1 TO 3 DO Create (G [i], 10, 5, PlusPres, DFonc, Geo2, DRepMan, Guy) END; Create (G <ref> [4] </ref>, 15, 1, BalayageComplet, DFonc, Geo2, DRepMan, Bob); Schedule (FinSim, 2000.0, NIL); SIM.Start END Systeme. 42 4 CONCLUSION 4 Conclusion Modula-2 est un langage qui gagne de plus en plus en popularite. <p> END RAND. 48 RAND1 Ce module sert a generer des valeurs aleatoires selon differentes lois de probabilite. Des fonctions sont disponibles pour generer des valeurs selon les lois uniforme discrete, uniforme continue, exponentielle, Weibull, gamma, b^eta, normale et Student. Elles utilisent toutes la methode d'inversion <ref> [4, 12] </ref>, sauf pour les lois gamma et b^eta. L'usager peut aussi definir sa propre loi discrete, en donnant l'ensemble des valeurs qui peuvent ^etre prises, et la fonction de repartition. <p> La moyenne et la variance sont ff= et ff= 2 respectivement. Utilise les fonctions RGS et RGKM3 des figures L.12 et L.13 de <ref> [4] </ref>. Il s'agit d'une methode d'acceptation-rejet, de sorte que le nombre d'appels a la fonction Uniform01 est variable. <p> Utilise l'algorithme de Cheng donne a la figure L.2 de <ref> [4] </ref>. Il s'agit d'une methode d'acceptation-rejet, de sorte que le nombre d'appels a la fonction Uniform01 est variable. END RAND1. 51 Ce module fait l'interface avec l'executif du progiciel de simulation.
Reference: [5] <author> Concepcion, A. I. et Zeigler, B. P. </author> <year> (1988). </year> <title> DEVS Formalism: A Framework for Hierarchical Model Development. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 14, 2, </volume> <pages> 228-241. </pages>
Reference-contexts: Les modeles les plus realistes sont habituellement dynamiques et stochastiques, c'est-a-dire que leur etat evolue dans le temps et que cette evolution peut se faire de facon aleatoire. SIMOD permet de simuler des modeles de ce genre. Il a ete concu surtout pour la simulation a evenements discrets <ref> [4, 5, 11, 12] </ref>, mais permet aussi la simulation continue. Dans la pratique, les programmes de simulation ont longtemps ete (et sont encore souvent) ecrits dans des langages tout-usage, tels que C, Pascal ou FORTRAN [12, 4].
Reference: [6] <author> Eckhardt, H., Koch, J., Mall, M. et Putfarken, P. </author> <year> (1985). </year> <title> Logitech Modula-2 User's Manual , Logitech Inc., </title> <address> Redwood City, California. </address>
Reference-contexts: Nous ne pretendons pas que Modula-2 soit le langage parfait pour implanter un progiciel de simulation, mais il s'agit certainement d'un langage pratique, gr^ace auquel on peut des maintenant implanter des outils a la fois attrayants et performants. SIMOD est presentement implante sous VAX/VMS avec l'environnement Modula-2 de Logitech <ref> [6] </ref>, sous MS-DOS dans l'envronnement TopSpeed Modula-2 [28], et sous SUN/OS avec le compilateur Modula-2 de de SUN. La prochaine section donne une vue d'ensemble de SIMOD. Dans la section 3, on presente une serie d'exemples, d'abord simples puis plus complexes, dont l'objectif est d'illustrer l'utilisation de SIMOD. <p> PROCEDURE Delete ( VAR M : MasterSlave ); Detruit le point de rencontre M et recupere l'espace memoire qu'il utilisait. END MASLA. 96 B. GUIDE D'UTILISATION SUR VAX/VMS. B. Guide d'utilisation sur VAX/VMS. SIMOD sous VAX/VMS a ete implante en utilisant le compilateur Modula-2 de Logitech <ref> [6] </ref> (version 3.1-9). Les programmes SIMOD doivent donc ^etre traites par ce compilateur. A noter qu'il y a des differences mineures entre la version PC et la version VAX, a cause de la difference de taille pour les types REAL, INTEGER, et CARDINAL. <p> A noter qu'il y a des differences mineures entre la version PC et la version VAX, a cause de la difference de taille pour les types REAL, INTEGER, et CARDINAL. Tous les modules decrits dans ce guide sont precompiles, selon les specifications de <ref> [6] </ref>. Les fichiers du progiciel sont places dans un repertoire accessible aux usagers eventuels.
Reference: [7] <author> Ford, G. A. et Wiener, R. S. </author> <year> (1985). </year> <title> Modula-2 : A Software Development Approach. </title> <publisher> Wiley, New-York. </publisher>
Reference-contexts: Mais pour la vision par processus, on doit ou bien modifier le langage et reecrire le compilateur, ou bien ecrire un preprocesseur [9, 11, 19, 30]. 2 1 INTRODUCTION Le langage Modula-2, developpe par Wirth, est souvent presente comme le successeur de Pascal <ref> [7, 8, 32] </ref>. Il a ete concu pour combler les lacunes de Pascal, tout en essayant d'en conserver la simplicite (par opposition a ADA, par exemple). <p> Tout au long de ce guide, nous supposons que le lecteur est deja familier avec le langage Modula-2. Pour une introduction a Modula-2, voir <ref> [7, 8, 32] </ref>. 4 2 UNE VUE D'ENSEMBLE DU PROGICIEL 2 Une vue d'ensemble du progiciel Nous allons maintenant decrire l'organisation de SIMOD et les principaux modules qui le constituent. La description detaillee de tous les outils disponibles se trouve en Annexe A.
Reference: [8] <author> Gleaves, R. </author> <year> (1984). </year> <title> Modula-2 for Pascal Programmers. </title> <publisher> Springer-Verlag, New-York. </publisher>
Reference-contexts: Mais pour la vision par processus, on doit ou bien modifier le langage et reecrire le compilateur, ou bien ecrire un preprocesseur [9, 11, 19, 30]. 2 1 INTRODUCTION Le langage Modula-2, developpe par Wirth, est souvent presente comme le successeur de Pascal <ref> [7, 8, 32] </ref>. Il a ete concu pour combler les lacunes de Pascal, tout en essayant d'en conserver la simplicite (par opposition a ADA, par exemple). <p> Tout au long de ce guide, nous supposons que le lecteur est deja familier avec le langage Modula-2. Pour une introduction a Modula-2, voir <ref> [7, 8, 32] </ref>. 4 2 UNE VUE D'ENSEMBLE DU PROGICIEL 2 Une vue d'ensemble du progiciel Nous allons maintenant decrire l'organisation de SIMOD et les principaux modules qui le constituent. La description detaillee de tous les outils disponibles se trouve en Annexe A.
Reference: [9] <author> Kaubisch, W. H., Perrot, R. H. et Hoare, C. A. R. </author> <year> (1976). </year> <title> Quasi-parallel programming. </title> <journal> Software Practice and Experience, </journal> <volume> 6, </volume> <pages> 341-356. </pages>
Reference-contexts: Mais pour la vision par processus, on doit ou bien modifier le langage et reecrire le compilateur, ou bien ecrire un preprocesseur <ref> [9, 11, 19, 30] </ref>. 2 1 INTRODUCTION Le langage Modula-2, developpe par Wirth, est souvent presente comme le successeur de Pascal [7, 8, 32]. Il a ete concu pour combler les lacunes de Pascal, tout en essayant d'en conserver la simplicite (par opposition a ADA, par exemple).
Reference: [10] <author> Knapp, V. </author> <year> (1986). </year> <title> The Smalltalk Simulation Environment. </title> <booktitle> 1986 Winter Simulation Conference Proceedings, </booktitle> <pages> 125-128. </pages>
Reference-contexts: D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C [26], Simula [1, 2], SMALLTALK <ref> [10] </ref>, SCHEME (un dialecte de Lisp) [27], PROLOG [31], etc. Quelques-uns sont aussi implantes en Modula-2 [18, 25], mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire.
Reference: [11] <author> Kreutzer W. </author> <year> (1986). </year> <title> System Simulation | Programming Styles and Languages. </title> <publisher> Addi-son Wesley. </publisher>
Reference-contexts: Les modeles les plus realistes sont habituellement dynamiques et stochastiques, c'est-a-dire que leur etat evolue dans le temps et que cette evolution peut se faire de facon aleatoire. SIMOD permet de simuler des modeles de ce genre. Il a ete concu surtout pour la simulation a evenements discrets <ref> [4, 5, 11, 12] </ref>, mais permet aussi la simulation continue. Dans la pratique, les programmes de simulation ont longtemps ete (et sont encore souvent) ecrits dans des langages tout-usage, tels que C, Pascal ou FORTRAN [12, 4]. <p> Pour ces raisons, dans de nombreux projets de simulation, on utilise encore des langages tout-usage tels que FORTRAN. Mais FORTRAN est un langage plutot depasse (voir <ref> [11] </ref>). On lui prefere maintenant des langages plus riches de concepts et plus fiables, tels que Pascal, Modula-2, ADA, etc. <p> Mais pour la vision par processus, on doit ou bien modifier le langage et reecrire le compilateur, ou bien ecrire un preprocesseur <ref> [9, 11, 19, 30] </ref>. 2 1 INTRODUCTION Le langage Modula-2, developpe par Wirth, est souvent presente comme le successeur de Pascal [7, 8, 32]. Il a ete concu pour combler les lacunes de Pascal, tout en essayant d'en conserver la simplicite (par opposition a ADA, par exemple).
Reference: [12] <author> Law, A. M. et Kelton, W. D. </author> <year> (1982). </year> <title> Simulation Modeling and Analysis. </title> <publisher> McGraw-Hill. </publisher>
Reference-contexts: Les modeles les plus realistes sont habituellement dynamiques et stochastiques, c'est-a-dire que leur etat evolue dans le temps et que cette evolution peut se faire de facon aleatoire. SIMOD permet de simuler des modeles de ce genre. Il a ete concu surtout pour la simulation a evenements discrets <ref> [4, 5, 11, 12] </ref>, mais permet aussi la simulation continue. Dans la pratique, les programmes de simulation ont longtemps ete (et sont encore souvent) ecrits dans des langages tout-usage, tels que C, Pascal ou FORTRAN [12, 4]. <p> Il a ete concu surtout pour la simulation a evenements discrets [4, 5, 11, 12], mais permet aussi la simulation continue. Dans la pratique, les programmes de simulation ont longtemps ete (et sont encore souvent) ecrits dans des langages tout-usage, tels que C, Pascal ou FORTRAN <ref> [12, 4] </ref>. Dans le but d'ameliorer la productivite, on a developpe, dans ces langages, des librairies de sous-routines fournissant des outils de base pour la programmation de simulation. On a aussi cree, par ailleurs, des langages specialises pour la simulation. <p> L'objectif est de familiariser le lecteur avec le progiciel et d'illustrer son utilisation. Le premier exemple est classique et tres simple, il s'agit d'une file d'attente a plusieurs serveurs. Il illustre l'utilisation simultanee d'evenements et de processus. Les deux exemples qui suivent sont inspires de <ref> [12] </ref>. Il s'agit de programmes de simulation d'un atelier de production et d'un systeme a temps partage. Le quatrieme exemple est une simulation de visites guidees, et illustre une synchronisation des processus legerement plus complexe. <p> Capacity 3 3 3.000 Utilization 0 3 1.704 Queue 0 3 0.144 Wait 0.000 13.298 1.171 2.851 123 Service 12.055 15.982 13.952 1.141 121 Sojourn 12.055 28.607 15.132 3.115 121 3.2 Un atelier de production 11 3.2 Un atelier de production Cet exemple est inspire de Law et Kelton <ref> [12] </ref>, section 2.6, et de [13]. Un atelier de production contient M groupes de machines. Pour m = 1; : : : ; M, le groupe m est constitue de s m machines identiques. L'atelier est modelise par un reseau de files d'attente. <p> La premiere reinitialise tous les blocs statistiques, tandis que la seconde fournit les rapports statistiques demandes et arr^ete la simulation. 14 3 EXEMPLES DE PROGRAMMES SIMOD 3.3 Un systeme a temps partage Cet exemple est inspire de <ref> [12] </ref>, section 2.4. Considerons un systeme informatique a temps partage, simplifie. Le systeme est constitue de T terminaux independants et identiques, tous occupes, qui utilisent la m^eme unite centrale (CPU). <p> On examine differentes politiques pour dif-ferentes configurations, et dans chaque cas, on calcule un intervalle de confiance sur la pro-ductivite. Pour calculer cet intervalle de confiance, on utilise ici la methode des lots ("batch means") <ref> [4, 12] </ref>. On simule pour une duree donnee, que l'on subdivise en NLots intervalles de temps egaux (de duree DureeLot). Les resultats des Rechauf premiers intervalles sont elim-ines, et on traite les moyennes associees aux intervalles restants comme (NLots-Rechauf) valeurs de variables aleatoires independantes, distribuees selon la loi normale. <p> END RAND. 48 RAND1 Ce module sert a generer des valeurs aleatoires selon differentes lois de probabilite. Des fonctions sont disponibles pour generer des valeurs selon les lois uniforme discrete, uniforme continue, exponentielle, Weibull, gamma, b^eta, normale et Student. Elles utilisent toutes la methode d'inversion <ref> [4, 12] </ref>, sauf pour les lois gamma et b^eta. L'usager peut aussi definir sa propre loi discrete, en donnant l'ensemble des valeurs qui peuvent ^etre prises, et la fonction de repartition.
Reference: [13] <author> L'Ecuyer, P. </author> <year> (1987). </year> <institution> SIMPascal 2.0: Guide de l'usager pour VAX/VMS. Rapport no. DIUL-RT-8705, Departement d'informatique, Universite Laval. </institution>
Reference-contexts: Il ne supporte pas, par exemple, les coroutines et la compilation separee. L'implantation d'un progiciel de simulation base sur Pascal se fait assez bien si on se limite a la vision par evene-ments et si on utilise une extension du langage qui permet la compilation separee <ref> [13] </ref>. Mais pour la vision par processus, on doit ou bien modifier le langage et reecrire le compilateur, ou bien ecrire un preprocesseur [9, 11, 19, 30]. 2 1 INTRODUCTION Le langage Modula-2, developpe par Wirth, est souvent presente comme le successeur de Pascal [7, 8, 32]. <p> Certaines des idees de SIMOD sont inspirees du progiciel DEMOS [2], base sur le langage Simula [3], de SIMSCRIPT II.5 [24], et de SIMPascal <ref> [13] </ref>. D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C [26], Simula [1, 2], SMALLTALK [10], SCHEME (un dialecte de Lisp) [27], PROLOG [31], etc. <p> Utilization 0 3 1.704 Queue 0 3 0.144 Wait 0.000 13.298 1.171 2.851 123 Service 12.055 15.982 13.952 1.141 121 Sojourn 12.055 28.607 15.132 3.115 121 3.2 Un atelier de production 11 3.2 Un atelier de production Cet exemple est inspire de Law et Kelton [12], section 2.6, et de <ref> [13] </ref>. Un atelier de production contient M groupes de machines. Pour m = 1; : : : ; M, le groupe m est constitue de s m machines identiques. L'atelier est modelise par un reseau de files d'attente.
Reference: [14] <author> L'Ecuyer, P. et Cote, S. </author> <year> (1987). </year> <title> A Random Number Package with Splitting Facilities. Rapport no. </title> <institution> DIUL-RR-8705, Departement d'informatique, Universite Laval. </institution> <note> A para^itre dans ACM Transactions of Mathematical Software. </note>
Reference-contexts: Evidemment, outre les modules mentionnes ici, l'usager peut ajouter ses propres modules. * RAND contient le generateur de valeurs pseudo-aleatoires. Son noyau est une adaptation du logiciel propose par L'Ecuyer et Cote <ref> [14] </ref>, base sur le generateur 32-bits propose par L'Ecuyer [16]. * RAND1 fournit des fonctions pour generer des valeurs aleatoires suivant differentes lois de probabilite. * SIM fournit une fonction qui retourne l'instant courant de la simulation, et des proce dures pour initialiser, demarrer et stopper la simulation. * EVENT offre <p> Le generateur de base utilise est celui propose par L'Ecuyer [16], dont la periode est d'environ 2:3 fi 10 18 , et ce module implante les outils proposes dans <ref> [14] </ref>. A partir de la suite des etats visites dans une periode par le generateur de base, on extrait K sous-suites disjointes (et contigues) de 2 50 etats chacune. On obtient ainsi K generateurs "virtuels", numerotes de 1 a K.
Reference: [15] <author> L'Ecuyer, P. et Giroux, N. </author> <year> (1987). </year> <title> A Process-Oriented Package Based on Modula-2. </title> <booktitle> 1987 Winter Simulation Conference Proceedings, </booktitle> <address> Atlanta, </address> <month> Dec. </month> <year> 1987, </year> <pages> 165-174. </pages>
Reference-contexts: Mais comme tout langage, Modula-2 a aussi ses faiblesses. A ce sujet, on peut lire la critique de Moffat [20] et la section 5 de <ref> [15] </ref>. Parmi les aspects agacants ou restrictifs, mentionnons d'abord le fait que Modula-2 ne produit pas vraiment des programmes tout-a-fait "portables", car en general, on doit faire appel a des librairies de modules, et ces derniers varient d'une implantation a l'autre.
Reference: [16] <author> L'Ecuyer, P. </author> <year> (1988). </year> <title> Efficient and Portable Combined Random Number Generators. </title> <journal> Communications of the ACM , 31, </journal> <volume> 6, </volume> <pages> 742-749 et 774. </pages> <address> R EF ERENCES 99 </address>
Reference-contexts: Evidemment, outre les modules mentionnes ici, l'usager peut ajouter ses propres modules. * RAND contient le generateur de valeurs pseudo-aleatoires. Son noyau est une adaptation du logiciel propose par L'Ecuyer et Cote [14], base sur le generateur 32-bits propose par L'Ecuyer <ref> [16] </ref>. * RAND1 fournit des fonctions pour generer des valeurs aleatoires suivant differentes lois de probabilite. * SIM fournit une fonction qui retourne l'instant courant de la simulation, et des proce dures pour initialiser, demarrer et stopper la simulation. * EVENT offre des outils pour la prevision d'evenements dans un delai <p> On peut l'utiliser directement, mais il sert aussi de base au module RAND1, qui permet de generer des valeurs aleatoires suivant des lois de probabilite plus elaborees. Le generateur de base utilise est celui propose par L'Ecuyer <ref> [16] </ref>, dont la periode est d'environ 2:3 fi 10 18 , et ce module implante les outils proposes dans [14]. A partir de la suite des etats visites dans une periode par le generateur de base, on extrait K sous-suites disjointes (et contigues) de 2 50 etats chacune.
Reference: [17] <author> L'Ecuyer, P., Mayrand, M. et Dror, M. </author> <year> (1988). </year> <title> Dynamic Scheduling of a Robot Servicing Machines on a One-Dimensional Line. Rapport no. </title> <institution> DIUL-RR-8806, Departement d'informatique, Universite Laval. </institution> <note> A para^itre dans IIE Transactions. </note>
Reference-contexts: On retrouve le genre de systeme decrit ici dans certaines usines de produits textiles <ref> [17] </ref>. Soit un groupe de N machines identiques placees en ligne droite, equidistantes, numerotees 1; 2; : : : ; N , de gauche a droite. <p> On pourrait evidemment ajouter d'autres politiques a ce module, et en particulier celles suggerees dans <ref> [17] </ref>. On doit fournir une telle politique chaque fois que l'on initialise un groupe de machines. Evidemment, il n'est pas necessaire que la politique fournie provienne du module Commande, elle peut provenir d'ailleurs. <p> A remarquer que nous ne presentons pas ici le programme de simulation le plus efficace pour estimer la productivite d'un groupe de machines. Pour diminuer les temps d'execution, on pourrait d'abord facilement precalculer certaines expressions. Ensuite, l'adoption de techniques de reduction de la variance, telles que celles utilisees dans <ref> [17] </ref>, permettrait de reduire par un facteur de 5 a 10 le temps de simulation requis pour un intervalle de confiance de rayon donne. Enfin, si on utilisait une approche uniquement par evenements au lieu d'utiliser des processus, on reduirait encore les temps d'execution de facon substantielle.
Reference: [18] <author> Livny, M. </author> <year> (1987). </year> <title> DELAB|A Simulation Laboratory. </title> <booktitle> 1987 Winter Simulation Conference Proceedings, </booktitle> <address> Atlanta, </address> <month> Dec. </month> <year> 1987, </year> <pages> 486-494. </pages>
Reference-contexts: Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C [26], Simula [1, 2], SMALLTALK [10], SCHEME (un dialecte de Lisp) [27], PROLOG [31], etc. Quelques-uns sont aussi implantes en Modula-2 <ref> [18, 25] </ref>, mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire.
Reference: [19] <author> Malloy, B. et Soffa, M. L. </author> <year> (1986). </year> <title> SIMCAL : The Merger of Simula and Pascal. </title> <booktitle> 1986 Winter Simulation Conference Proceedings, </booktitle> <pages> 397-403. </pages>
Reference-contexts: Mais pour la vision par processus, on doit ou bien modifier le langage et reecrire le compilateur, ou bien ecrire un preprocesseur <ref> [9, 11, 19, 30] </ref>. 2 1 INTRODUCTION Le langage Modula-2, developpe par Wirth, est souvent presente comme le successeur de Pascal [7, 8, 32]. Il a ete concu pour combler les lacunes de Pascal, tout en essayant d'en conserver la simplicite (par opposition a ADA, par exemple).
Reference: [20] <author> Moffat, D. </author> <year> (1984). </year> <title> Some Concerns about Modula-2. </title> <booktitle> SIGPLAN Notice 19, </booktitle> <pages> 41-47. </pages>
Reference-contexts: Mais comme tout langage, Modula-2 a aussi ses faiblesses. A ce sujet, on peut lire la critique de Moffat <ref> [20] </ref> et la section 5 de [15]. Parmi les aspects agacants ou restrictifs, mentionnons d'abord le fait que Modula-2 ne produit pas vraiment des programmes tout-a-fait "portables", car en general, on doit faire appel a des librairies de modules, et ces derniers varient d'une implantation a l'autre.
Reference: [21] <author> Muller, C. </author> <year> (1986). </year> <title> Modula-Prolog: A software Development Tool. </title> <journal> IEEE Software, </journal> <volume> 3, 6, </volume> <pages> 39-45. </pages>
Reference-contexts: Dans certains cas, il pourrait ^etre interessant d'implanter cette politique sous forme d'une base de regles, par exemple sous forme d'un programme PROLOG. Le systeme Modula-Prolog decrit dans <ref> [21] </ref> permet d'utiliser Modula-2 et PROLOG simultanement, dans un m^eme programme, et pourrait donc permettre de le faire. A remarquer que nous ne presentons pas ici le programme de simulation le plus efficace pour estimer la productivite d'un groupe de machines.
Reference: [22] <author> Pegden, C. D. </author> <year> (1985). </year> <title> Introduction to SIMAN . Systems Modeling Corporation. </title>
Reference-contexts: On a aussi cree, par ailleurs, des langages specialises pour la simulation. Par exemple, les langages GPSS [26], SIMSCRIPT [24], SLAM [23] et SIMAN <ref> [22] </ref> ont ete crees pour la simulation des systemes a evenements discrets. Plusieurs langages specialises ont aussi ete crees pour la simulation continue. Les langages specialises fournissent des outils de plus haut niveau et permettent d'ecrire des programmes plus courts, mais n'offrent souvent que peu de flexibilite. <p> CONT.Create (x, x0, Dx, NIL); CONT.Create (z, z0, Dz, NIL); SelectMethod (RungeKutta4, 5.0); StartInteg (x, UnPas, NIL); StartInteg (z, EventType (NIL), NIL); EVENT.Schedule (FinSim, Duree, NIL); SIM.Start; CloseInput; CloseOutput END ProiePred. 24 3 EXEMPLES DE PROGRAMMES SIMOD 3.6 Simulation discrete et continue: chauffage de lingots Cet exemple est inspire de <ref> [22] </ref>, page 210. Dans une acierie, des lingots d'acier arrivent a une fournaise de trempage pour ^etre chauffes avant de poursuivre leur route vers l'etape suivante du processus. Les lingots arrivent selon un processus de Poisson, et le temps moyen entre les arrivees est de a heures.
Reference: [23] <author> Pritsker, A. A. B. </author> <year> (1986). </year> <title> Introduction to Simulation and SLAM II . Wiley, </title> <publisher> New-York. </publisher>
Reference-contexts: Dans le but d'ameliorer la productivite, on a developpe, dans ces langages, des librairies de sous-routines fournissant des outils de base pour la programmation de simulation. On a aussi cree, par ailleurs, des langages specialises pour la simulation. Par exemple, les langages GPSS [26], SIMSCRIPT [24], SLAM <ref> [23] </ref> et SIMAN [22] ont ete crees pour la simulation des systemes a evenements discrets. Plusieurs langages specialises ont aussi ete crees pour la simulation continue. Les langages specialises fournissent des outils de plus haut niveau et permettent d'ecrire des programmes plus courts, mais n'offrent souvent que peu de flexibilite.
Reference: [24] <author> Russel, E. C. </author> <year> (1983). </year> <title> Building Simulation Models with SIMSCRIPT II.5 . C. </title> <editor> A. C. I., </editor> <address> Los Angeles. </address>
Reference-contexts: Dans le but d'ameliorer la productivite, on a developpe, dans ces langages, des librairies de sous-routines fournissant des outils de base pour la programmation de simulation. On a aussi cree, par ailleurs, des langages specialises pour la simulation. Par exemple, les langages GPSS [26], SIMSCRIPT <ref> [24] </ref>, SLAM [23] et SIMAN [22] ont ete crees pour la simulation des systemes a evenements discrets. Plusieurs langages specialises ont aussi ete crees pour la simulation continue. <p> Certaines des idees de SIMOD sont inspirees du progiciel DEMOS [2], base sur le langage Simula [3], de SIMSCRIPT II.5 <ref> [24] </ref>, et de SIMPascal [13]. D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes.
Reference: [25] <author> Sharma, R. et Rose, L. L. </author> <year> (1988). </year> <title> Modular Design For Simulation. </title> <type> Research report, </type> <institution> Dept. of Computer Science, </institution> <note> University of Pittsburg (a para^itre dans Software Practice and Experience). </note>
Reference-contexts: Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C [26], Simula [1, 2], SMALLTALK [10], SCHEME (un dialecte de Lisp) [27], PROLOG [31], etc. Quelques-uns sont aussi implantes en Modula-2 <ref> [18, 25] </ref>, mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire.
Reference: [26] <author> Schwetman H. </author> <year> (1986). </year> <title> SIMCAL : A C-Based, Process-oriented simulation language. </title> <booktitle> 1986 Winter Simulation Conference Proceedings, </booktitle> <pages> 387-396. </pages>
Reference-contexts: Dans le but d'ameliorer la productivite, on a developpe, dans ces langages, des librairies de sous-routines fournissant des outils de base pour la programmation de simulation. On a aussi cree, par ailleurs, des langages specialises pour la simulation. Par exemple, les langages GPSS <ref> [26] </ref>, SIMSCRIPT [24], SLAM [23] et SIMAN [22] ont ete crees pour la simulation des systemes a evenements discrets. Plusieurs langages specialises ont aussi ete crees pour la simulation continue. <p> D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C <ref> [26] </ref>, Simula [1, 2], SMALLTALK [10], SCHEME (un dialecte de Lisp) [27], PROLOG [31], etc. Quelques-uns sont aussi implantes en Modula-2 [18, 25], mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire.
Reference: [27] <author> Stairmand, M. C. et Kreutzer, W. </author> <year> (1988). </year> <title> POSE: a Process-Oriented Simulation Environment embedded in SCHEME. </title> <journal> Simulation, </journal> <volume> 50, 4, </volume> <pages> 143-153. </pages>
Reference-contexts: D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C [26], Simula [1, 2], SMALLTALK [10], SCHEME (un dialecte de Lisp) <ref> [27] </ref>, PROLOG [31], etc. Quelques-uns sont aussi implantes en Modula-2 [18, 25], mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire.
Reference: [28] <editor> TopSpeed Modula-2 User's Manual, </editor> <booktitle> Jensen and Partners International (1988). </booktitle>
Reference-contexts: SIMOD est presentement implante sous VAX/VMS avec l'environnement Modula-2 de Logitech [6], sous MS-DOS dans l'envronnement TopSpeed Modula-2 <ref> [28] </ref>, et sous SUN/OS avec le compilateur Modula-2 de de SUN. La prochaine section donne une vue d'ensemble de SIMOD. Dans la section 3, on presente une serie d'exemples, d'abord simples puis plus complexes, dont l'objectif est d'illustrer l'utilisation de SIMOD. <p> Par exemple, pour le programme de la section 3.1, on fait : $ MODULA Queue $ MLINK Queue $ RUN Queue 97 C. Guide d'utilisation sur IBM-PC. SIMOD sous MS-DOS est implante en utilisant le compilateur TopSpeed Modula-2 <ref> [28] </ref>. Les programmes SIMOD doivent donc ^etre traites par ce compilateur. D. Guide d'utilisation sur SUN avec SUN/Modula-2. SIMOD sous SUN/OS est implante en utilisant le compilateur Modula-2 de SUN. Les pro-grammes SIMOD doivent donc ^etre traites par ce compilateur.
Reference: [29] <author> Unger, B. W., Lomow, G. A. et Birtwistle, G. M. </author> <year> (1984). </year> <title> Simulation Software and ADA. </title> <booktitle> The Society for Computer Simulation, </booktitle> <address> La Jolla, California. </address>
Reference-contexts: D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA <ref> [29] </ref>, C [26], Simula [1, 2], SMALLTALK [10], SCHEME (un dialecte de Lisp) [27], PROLOG [31], etc. Quelques-uns sont aussi implantes en Modula-2 [18, 25], mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire.
Reference: [30] <author> Vaucher, J. G. </author> <year> (1984). </year> <title> Process-oriented Simulation in Standard Pascal. Dans Simulation in Strongly Typed Languages : Ada, Pascal, Simula, </title> . . . , <editor> ed. par R. Bryant and B. W. Unger, </editor> <booktitle> SCS Simulation Series, </booktitle> <volume> 13, 2, </volume> <pages> 37-43. </pages>
Reference-contexts: Mais pour la vision par processus, on doit ou bien modifier le langage et reecrire le compilateur, ou bien ecrire un preprocesseur <ref> [9, 11, 19, 30] </ref>. 2 1 INTRODUCTION Le langage Modula-2, developpe par Wirth, est souvent presente comme le successeur de Pascal [7, 8, 32]. Il a ete concu pour combler les lacunes de Pascal, tout en essayant d'en conserver la simplicite (par opposition a ADA, par exemple).
Reference: [31] <author> Vaucher, J. G. et Lapalme, G. </author> <year> (1987). </year> <title> Process-oriented Simulation in Prolog. Dans Simulation and AI , ed. </title> <editor> par P. A. Luker at G. Birtwistle, </editor> <booktitle> SCS Simulation Series, </booktitle> <volume> vol. 18, no. 3, </volume> <pages> 41-46. </pages>
Reference-contexts: D'autres progiciels de simulation a evenements discrets, bases sur des langages qui supportent la quasi-concurrence, ont deja ete proposes. Sans pretendre ^etre exhaustif, on peut mentionner des progiciels bases sur ADA [29], C [26], Simula [1, 2], SMALLTALK [10], SCHEME (un dialecte de Lisp) [27], PROLOG <ref> [31] </ref>, etc. Quelques-uns sont aussi implantes en Modula-2 [18, 25], mais concus differemment de SIMOD. SMALLTALK, SCHEME et PROLOG sont des langages tres puis-sants et tres interessants pour developper des outils de prototypage exploratoire.
Reference: [32] <author> Wirth, N. </author> <year> (1985). </year> <title> Programming in Modula-2 . Third ed., </title> <publisher> Springer-Verlag, New-York. </publisher>
Reference-contexts: Mais pour la vision par processus, on doit ou bien modifier le langage et reecrire le compilateur, ou bien ecrire un preprocesseur [9, 11, 19, 30]. 2 1 INTRODUCTION Le langage Modula-2, developpe par Wirth, est souvent presente comme le successeur de Pascal <ref> [7, 8, 32] </ref>. Il a ete concu pour combler les lacunes de Pascal, tout en essayant d'en conserver la simplicite (par opposition a ADA, par exemple). <p> Tout au long de ce guide, nous supposons que le lecteur est deja familier avec le langage Modula-2. Pour une introduction a Modula-2, voir <ref> [7, 8, 32] </ref>. 4 2 UNE VUE D'ENSEMBLE DU PROGICIEL 2 Une vue d'ensemble du progiciel Nous allons maintenant decrire l'organisation de SIMOD et les principaux modules qui le constituent. La description detaillee de tous les outils disponibles se trouve en Annexe A.
References-found: 32

