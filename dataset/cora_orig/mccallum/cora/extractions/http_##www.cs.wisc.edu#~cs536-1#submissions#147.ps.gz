URL: http://www.cs.wisc.edu/~cs536-1/submissions/147.ps.gz
Refering-URL: 
Root-URL: 
Email: Email: megiddo@almaden.ibm.com.  Email: vivek sarkar@vnet.ibm.com.  
Phone: Phone: 408-927-1786  Phone: 408-463-5660  
Title: Optimal Weighted Loop Fusion (Extended Abstract)  confidential communication. Not for public access, use, or circulation. Access  
Author: Nimrod Megiddo Vivek Sarkar 
Address: 650 Harry Road, San Jose, CA 95120.  555 Bailey Avenue, San Jose, CA 95141.  
Affiliation: Almaden Research Center, IBM Research Division,  Application Development Technology Institute, IBM Software Solutions Division,  
Note: Private  restricted to submission reviewers of the ACM SIGPLAN'96 Conference on Program ming Language Design and Implementation.  
Abstract: Loop fusion is a well-known program transformation that has shown to be effective in reducing loop overhead and improving register and cache locality. Weighted loop fusion is the problem of finding a legal partition of loop nests into fusible clusters so as to minimize the total inter-cluster weights. It has been shown in past work that the weighted loop fusion problem is NP-hard. Despite the NP-hardness property, we show how optimal solutions can be found efficiently, in the context of an optimizing compiler, for weighted loop fusion problem sizes that occur in practice (partitioning of 100 loop nests). In this paper, we present an integer programming formulation for weighted loop fusion with size (number of variables and constraints) that is linearly proportional to the size of the input loop dependence graph and weights, and prove that an optimal solution to the integer programming problem yields an optimal solution to the weighted loop fusion problem. The integer programming formulation can be solved efficiently using a standard optimization package such as the IBM Optimization Subroutine Library (OSL). We present measurements of the execution time taken by OSL to solve integer-programming problem instances obtained from loop dependence graphs built by the IBM ASTI high-level optimizer. We also present a custom branch-and-bound algorithm for the integer programming formulation that we expect will be more efficient than the algorithms used in general integer programming packages such as OSL, and could be used in the compiler if greater efficiency is required. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> John R. Allen. </author> <title> Dependence Analysis for Subscripted Variables and its Application to Program Transformation. </title> <type> PhD thesis, </type> <institution> Rice University, Houston, TX, </institution> <year> 1983. </year>
Reference-contexts: A node in the LDG represents a perfect loop nest [23]. An edge in the LDG represents a loop- independent data dependence <ref> [1] </ref> from the source loop nest to the destination loop nest; like all dependence graphs, the LDG is a multigraph. The LDG is acyclic since it only contains loop- independent dependences.
Reference: [2] <author> R. Allen and K. Kennedy. </author> <title> Automatic translation of FORTRAN programs to vector form. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9 </volume> <pages> 491-542, </pages> <year> 1987. </year>
Reference-contexts: As a result, being able to handle loops efficiently is of fundamental importance. A lot of the past work in optimizing the performance of loops has focused on individual loop nests rather than on collections of loop nests <ref> [2, 10, 3, 23, 21, 22, 19] </ref>. Loop distribution and loop fusion are two well known loop transformations that deal with multiple loop nests [23]. Loop fusion transforms multiple conformable loop nests into a single loop nest.
Reference: [3] <author> U. Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1988. </year>
Reference-contexts: As a result, being able to handle loops efficiently is of fundamental importance. A lot of the past work in optimizing the performance of loops has focused on individual loop nests rather than on collections of loop nests <ref> [2, 10, 3, 23, 21, 22, 19] </ref>. Loop distribution and loop fusion are two well known loop transformations that deal with multiple loop nests [23]. Loop fusion transforms multiple conformable loop nests into a single loop nest.
Reference: [4] <author> David Callahan. </author> <title> A Global Approach to Detection of Parallelism. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1987. </year> <institution> Rice COMP TR87-50. </institution>
Reference-contexts: Goldberg and Paige [9] addressed a restricted form of the unweighted loop fusion problem for stream processing, with the goal of minimizing the number of fusible loop clusters In <ref> [4] </ref>, Callahan presented a greedy partitioning algorithm for unweighted loop fusion and proved its optimality.
Reference: [5] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year> <title> Document access restricted to PLDI '96 reviewers 15 Private confidential communication </title>
Reference-contexts: To simplify the discussion in this paper, we assume that the loop dependence graph represents a set of k adjacent identically control dependent <ref> [5] </ref> perfect loop nests, with conformable Document access restricted to PLDI '96 reviewers 3 Private confidential communication DO 10 I=1, N DO 20 I=1, N 20 C (I) = B (I) + 99 30 D (I) = A (N-I+1) + A (I) 40 E (I) = B (I) + C (I)
Reference: [6] <author> J. Ferrante, V. Sarkar, and W. Thrash. </author> <title> On estimating and enhancing cache effectiveness. </title> <booktitle> Fourth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 328-343, </pages> <month> August </month> <year> 1991. </year> <institution> Santa Clara, </institution> <address> CA. </address>
Reference-contexts: Weights may also take into account execution probabilities for conditionals in the loop bodies [16]. We assume that suitable iteration-reordering loop transformations have already been performed on the individual loop nests <ref> [10, 7, 15, 22, 6, 19] </ref> before applying the fusion algorithm.
Reference: [7] <author> Kyle Gallivan, William Jalby, and Dennis Gannon. </author> <title> On the Problem of Optimizing Data Transfers for Complex Memory Systems. </title> <type> Technical report, </type> <address> U. </address> <booktitle> of IL-Center for Supercomputing Research and Development, July Also in Proc. of ACM 1988 Int'l. Conf. on Supercomputing, </booktitle> <address> St. Malo, France, </address> <month> July 4-8, </month> <year> 1988, </year> <month> pp.238-253. </month> <year> 1988. </year>
Reference-contexts: Weights may also take into account execution probabilities for conditionals in the loop bodies [16]. We assume that suitable iteration-reordering loop transformations have already been performed on the individual loop nests <ref> [10, 7, 15, 22, 6, 19] </ref> before applying the fusion algorithm.
Reference: [8] <author> G. R. Gao, R. Olsen, V. Sarkar, and R. Thekkath. </author> <title> Collective loop fusion for array contraction. </title> <booktitle> Fifth International Workshop on Languages and Compilers for Parallel Computing, August 1992. </booktitle> <address> New Haven, Connecticut. </address>
Reference-contexts: In <ref> [8] </ref>, Gao et al studied the weighted loop fusion problem in the context of array contraction, and presented a polynomial-time algorithm based on the max-flow/min-cut algorithm as a heuristic solution.
Reference: [9] <author> A. Goldberg and R. Paige. </author> <title> Stream processing. </title> <booktitle> 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 53-62, </pages> <month> August </month> <year> 1984. </year> <institution> Austin, TX. </institution>
Reference-contexts: Goldberg and Paige <ref> [9] </ref> addressed a restricted form of the unweighted loop fusion problem for stream processing, with the goal of minimizing the number of fusible loop clusters In [4], Callahan presented a greedy partitioning algorithm for unweighted loop fusion and proved its optimality.
Reference: [10] <author> Francois Irigoin and Remi Triolet. </author> <title> Supernode Partitioning. </title> <booktitle> Conference Record of Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: As a result, being able to handle loops efficiently is of fundamental importance. A lot of the past work in optimizing the performance of loops has focused on individual loop nests rather than on collections of loop nests <ref> [2, 10, 3, 23, 21, 22, 19] </ref>. Loop distribution and loop fusion are two well known loop transformations that deal with multiple loop nests [23]. Loop fusion transforms multiple conformable loop nests into a single loop nest. <p> Weights may also take into account execution probabilities for conditionals in the loop bodies [16]. We assume that suitable iteration-reordering loop transformations have already been performed on the individual loop nests <ref> [10, 7, 15, 22, 6, 19] </ref> before applying the fusion algorithm.
Reference: [11] <author> Ken Kennedy and Kathryn S. McKinley. </author> <title> Maximizing loop parallelism and improving data locality via loop fusion and distribution. </title> <booktitle> Proceedings of the Sixth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: Weighted loop fusion is the problem of finding a legal partition of loop nests into fusible clusters so as to minimize the total inter-cluster node-pair weights. It has been shown in past work that the weighted loop fusion problem is NP-hard <ref> [11] </ref>. Despite the NP-hardness property, we show how 1 We use the term "statement" to refer to an individual operation in the compiler's intermediate representation (IR). For IR's that are closer to a high-level programming language, a "statement" many indeed refer to a source program statement. <p> In [8], Gao et al studied the weighted loop fusion problem in the context of array contraction, and presented a polynomial-time algorithm based on the max-flow/min-cut algorithm as a heuristic solution. In <ref> [11] </ref>, Kennedy and McKinley proved that the weighted loop fusion problem is NP-hard and presented two polynomial-time algorithms as heuristic solutions, a simple greedy algorithm and a more powerful algorithm based on the max-flow/min-cut algorithm.
Reference: [12] <author> Ken Kennedy and Kathryn S. McKinley. </author> <title> Typed Fusion with Applications to Parallel and Sequential Code Generation. </title> <type> Technical report, </type> <institution> Department of Computer Science, Rice University, </institution> <year> 1993. </year> <month> TR93-208. </month>
Reference-contexts: Goldberg and Paige [9] addressed a restricted form of the unweighted loop fusion problem for stream processing, with the goal of minimizing the number of fusible loop clusters In [4], Callahan presented a greedy partitioning algorithm for unweighted loop fusion and proved its optimality. In <ref> [12] </ref>, Kennedy and McKinley addressed the problem of (unweighted) typed fusion, an extension to unweighted loop fusion in which each loop has an assigned type and only loops of the same type can be fused together.
Reference: [13] <author> M. Metcalfe and J. Reid. </author> <title> Fortran 90 Explained. </title> <publisher> Oxford Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: Loop fusion has shown to be effective in reducing loop overhead, improving register and cache locality, and reducing inter-processor communication. Loop fusion is also essential for efficient implementation of Fortran 90 array language constructs <ref> [13] </ref>. Loop distribution is effective in controlling register pressure and in creating a larger number of loop nests to feed into loop fusion.
Reference: [14] <author> George L. Nemhauser and Laurence A. Wolsey. </author> <title> Integer and Combinatorial Optimization. </title> <publisher> John Wiley & Sons, </publisher> <year> 1988. </year> <note> Wiley Interscience Series in Discrete Mathematics and Optimization. </note>
Reference-contexts: The second condition ensures that if x ij = 1 and (i; j) 2 A then necessarily j &gt; i . The weighted loop fusion problem can now be modeled as the following mixed integer programming problem <ref> [14] </ref>: Problem 3.5.
Reference: [15] <author> V. Sarkar and G. R. Gao. </author> <title> Optimization of array accesses by collective loop transformations. </title> <booktitle> 1991 ACM International Conference on Supercomputing, </booktitle> <pages> pages 194-205, </pages> <address> June 1991. Cologne, Germany. </address>
Reference-contexts: Weights may also take into account execution probabilities for conditionals in the loop bodies [16]. We assume that suitable iteration-reordering loop transformations have already been performed on the individual loop nests <ref> [10, 7, 15, 22, 6, 19] </ref> before applying the fusion algorithm.
Reference: [16] <author> Vivek Sarkar. </author> <title> Determining Average Program Execution Times and their Variance. </title> <booktitle> Proceedings of the 1989 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <volume> 24(7) </volume> <pages> 298-312, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: For convenience, we assume that w ii = 0 for all i, and that w ij = W ji = 0 for each noncontractable edge (i; j) 2 . Weights may also take into account execution probabilities for conditionals in the loop bodies <ref> [16] </ref>. We assume that suitable iteration-reordering loop transformations have already been performed on the individual loop nests [10, 7, 15, 22, 6, 19] before applying the fusion algorithm.
Reference: [17] <author> Vivek Sarkar. </author> <title> Partitioning and Scheduling Parallel Programs for Multiprocessors. </title> <publisher> Pitman, London and The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1989. </year> <title> In the series, Research Monographs in Parallel and Distributed Computing. Document access restricted to PLDI '96 reviewers 16 Private confidential communication </title>
Reference-contexts: In addition, we will explore the possibility of developing integer programming solutions for other compiler-related NP-hard graph partitioning problems such as those introduced in <ref> [17, 18] </ref>.
Reference: [18] <author> Vivek Sarkar. </author> <title> Automatic Partitioning of a Program Dependence Graph into Parallel Tasks. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 35(5/6), </volume> <year> 1991. </year>
Reference-contexts: In addition, we will explore the possibility of developing integer programming solutions for other compiler-related NP-hard graph partitioning problems such as those introduced in <ref> [17, 18] </ref>.
Reference: [19] <author> Vivek Sarkar and Radhika Thekkath. </author> <title> A General Framework for Iteration-Reordering Loop Transformations. </title> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 175-187, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: As a result, being able to handle loops efficiently is of fundamental importance. A lot of the past work in optimizing the performance of loops has focused on individual loop nests rather than on collections of loop nests <ref> [2, 10, 3, 23, 21, 22, 19] </ref>. Loop distribution and loop fusion are two well known loop transformations that deal with multiple loop nests [23]. Loop fusion transforms multiple conformable loop nests into a single loop nest. <p> Weights may also take into account execution probabilities for conditionals in the loop bodies [16]. We assume that suitable iteration-reordering loop transformations have already been performed on the individual loop nests <ref> [10, 7, 15, 22, 6, 19] </ref> before applying the fusion algorithm.
Reference: [20] <author> Ko-Yang Wang, Wei-Min Ching, Manish Gupta, Sam Midkiff, Edith Schonberg, and Dave Shields. </author> <title> Improving the Performance of HPF Compilers. </title> <booktitle> Proceedings of the Fifth Workshop on Compilers for Parallel Computers, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: We present measurements of the execution time taken by OSL to solve integer-programming problem instances obtained from loop dependence graphs built by the IBM ASTI high-level optimizer, which is used in the IBM HPF Beta compiler <ref> [20] </ref> and internally in IBM for uniprocessor optimization and SMP parallelization. The loop fusion transformation implemented in the IBM ASTI high-level optimizer is currently based on a (sub-optimal) greedy clustering algorithm. <p> We present measurements of the execution time taken by OSL to solve integer-programming problem instances obtained from loop dependence graphs built by the IBM ASTI high-level optimizer, which is used in the IBM HPF Beta compiler <ref> [20] </ref> and internally in IBM for uniprocessor optimization and SMP parallelization. To test out the solution provided in this paper, the ASTI optimizer was extended to compute load- reuse weights (as in Section 4) for each LDG encountered in the loop fusion phase, and to print out the weighted LDG's.
Reference: [21] <author> Michael E. Wolf and Monica S. Lam. </author> <title> Maximizing Parallelism via Loop Transformations. </title> <booktitle> Proceedings of the Third Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: As a result, being able to handle loops efficiently is of fundamental importance. A lot of the past work in optimizing the performance of loops has focused on individual loop nests rather than on collections of loop nests <ref> [2, 10, 3, 23, 21, 22, 19] </ref>. Loop distribution and loop fusion are two well known loop transformations that deal with multiple loop nests [23]. Loop fusion transforms multiple conformable loop nests into a single loop nest.
Reference: [22] <author> Michael E. Wolf and Monica S. Lam. </author> <title> A Data Locality Optimization Algorithm. </title> <booktitle> Proceedings of the ACM SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 30-44, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: As a result, being able to handle loops efficiently is of fundamental importance. A lot of the past work in optimizing the performance of loops has focused on individual loop nests rather than on collections of loop nests <ref> [2, 10, 3, 23, 21, 22, 19] </ref>. Loop distribution and loop fusion are two well known loop transformations that deal with multiple loop nests [23]. Loop fusion transforms multiple conformable loop nests into a single loop nest. <p> Weights may also take into account execution probabilities for conditionals in the loop bodies [16]. We assume that suitable iteration-reordering loop transformations have already been performed on the individual loop nests <ref> [10, 7, 15, 22, 6, 19] </ref> before applying the fusion algorithm.
Reference: [23] <author> Michael J. Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> Pitman, London and The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1989. </year> <title> In the series, Research Monographs in Parallel and Distributed Computing. Document access restricted to PLDI '96 reviewers 17 Private confidential communication </title>
Reference-contexts: As a result, being able to handle loops efficiently is of fundamental importance. A lot of the past work in optimizing the performance of loops has focused on individual loop nests rather than on collections of loop nests <ref> [2, 10, 3, 23, 21, 22, 19] </ref>. Loop distribution and loop fusion are two well known loop transformations that deal with multiple loop nests [23]. Loop fusion transforms multiple conformable loop nests into a single loop nest. <p> A lot of the past work in optimizing the performance of loops has focused on individual loop nests rather than on collections of loop nests [2, 10, 3, 23, 21, 22, 19]. Loop distribution and loop fusion are two well known loop transformations that deal with multiple loop nests <ref> [23] </ref>. Loop fusion transforms multiple conformable loop nests into a single loop nest. Loop distribution is the inverse of loop transformation, and separates a single loop nest into multiple conformable loop nests. <p> We are interested in automatically selecting an optimized fusion/distribution configuration i.e. an optimized regrouping of statements. Without any loss of generality, we assume that all loop nests are maximally distributed <ref> [23] </ref> before any fusion transformation is applied. Maximal distribution also yields a larger number of perfect loop nests that can be subject to iteration-reordering loop transformations (e.g. interchange, tiling) before loop fusion. <p> However, as observed later in Section 3, the results of this paper can easily be extended to a more general LDG which includes non-conformable loop nests and the presence of control flow across LDG nodes. A node in the LDG represents a perfect loop nest <ref> [23] </ref>. An edge in the LDG represents a loop- independent data dependence [1] from the source loop nest to the destination loop nest; like all dependence graphs, the LDG is a multigraph. The LDG is acyclic since it only contains loop- independent dependences. <p> Each edge in the LDG is marked as being contractable or noncontractable. The source and destination loop nests of a noncontractable LDG edge cannot be fused because this would violate the data dependence test for loop fusion <ref> [23] </ref>. Algorithm Contractable (L; M ) in Appendix A outlines this data dependence test for nodes L and M such that there is at least one LDG edge from L to M .
References-found: 23

