URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1084/CS-TR-92-1084.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1084/
Root-URL: http://www.cs.wisc.edu
Title: EFFICIENT RACE CONDITION DETECTION FOR SHARED-MEMORY PROGRAMS WITH POST/WAIT SYNCHRONIZATION  
Author: Robert H.B. Netzer Sanjoy Ghosh 
Address: 1210 W. Dayton Street 104 South Wright Street Madison, Wisconsin 53706 Urbana, Illinois 61801  
Affiliation: Computer Sciences Department CSRD University of Wisconsin-Madison 305 Talbot Lab  
Note: In 1992 Intl Conference on Parallel Processing, August 1992, St. Charles, IL  
Abstract: Shared-memory parallel programs are often designed to be deterministic, both in their final results and intermediate states. However, debugging such programs requires a mechanism for locating race conditions or violations of the intended determinacy when they occur. This paper answers a previously open question by presenting the first precise, efficient algorithm for dynamically detecting race conditions in programs that use non-trivial synchronization. We address Post/Wait synchronization, the most powerful type of synchronization for which efficient race detection is possible. Our algorithm computes the order in which synchronization operations in the execution are guaranteed to have occurred. Using this information race conditions can be detected either postmortem or on-the-fly. Previous work has addressed either simpler types of synchronization, approximations to race detection, or a different (and easier to detect) type of race. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Dinning, A. and E. Schonberg, </author> <title> ``An Empirical Comparison of Monitoring Algorithms for Access Anomaly Detection,'' </title> <booktitle> 2nd ACM Symp. on Princ. and Practice of Parallel Prog., </booktitle> <pages> pp. </pages> <address> 1-10 Seattle, WA, </address> <month> (March </month> <year> 1990). </year>
Reference-contexts: Our primary goal is to dynamically detect race conditions that introduce any nondeterminacy. In contrast, other work has also addressed a different type of race <ref> [1] </ref>. We are considering races that occur when different processes access a common memory location in an order not guaranteed by synchronization (and at least one process modifies the location). Such races could result in either different results or paths of control in different executions on the same input. <p> A Wait (x) blocks until x is set; a Post (x) sets x. Although some implementations also provide a Clear (x) operation to reset x, we are not considering such operations. 1 process synchronization (but only task spawning direc-tives such as fork and join) have also been proposed <ref> [1, 6] </ref>. In addition, a restricted form of Post/Wait in PCF Fortran has been considered [5] (where at most one Post and Wait on any event variable are allowed). However, the full generality of Post/Wait synchronization has not yet been addressed.
Reference: [2] <author> Emrath, P.A., S. Ghosh, and D.A. Padua, </author> <title> ``Event Synchronization Analysis for Debugging Parallel Programs,'' </title> <booktitle> Supercomputing '89, </booktitle> <pages> pp. </pages> <address> 580-588 Reno, NV, </address> <month> (November </month> <year> 1989). </year>
Reference-contexts: Pure Post/Wait synchronization is incapable of implementing mutual exclusion because Wait operations do not reset the event variable (resetting requires a Clear operation). Approximate schemes for more powerful synchronization capable of implementing mutual exclusion, such as semaphores [4] or Post/Wait with Clear operations <ref> [2] </ref>, have already been proposed. Precise detection schemes for programs that use no inter-hhhhhhhhhhhhhhhhhhhhhhhhhhhhh (a) In Post/Wait synchronization, each synchronization variable (or event variable) is either set or reset. A Wait (x) blocks until x is set; a Post (x) sets x.
Reference: [3] <author> Emrath, P.A., S. Ghosh, and D.A. Padua, </author> <title> ``On-the-fly Race Detection for Parallel Programs with Events,'' </title> <booktitle> 1992 Intl. Conf. on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <month> (August </month> <year> 1992). </year>
Reference-contexts: From the trace of the shared-memory references, we can determine which of these portions accessed common locations and were thus race conditions. Second, in a hybrid on-the-fly/post-mortem approach, only the execution's synchronization operations are traced <ref> [3] </ref>. From this trace our algorithm can locate those sections of the execution that had no guaranteed ordering, although the shared-memory addresses referenced by them are not yet known. This information can then be used to instrument and reexecute the program to perform run-time race condition checks at these sections.
Reference: [4] <author> Helmbold, D.P., C.E. McDowell, and J.-Z. Wang, </author> <title> ``Analyzing Traces with Anonymous Synchronization,'' </title> <booktitle> 1990 Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> 70-77 St. Charles, IL, </address> <month> (August </month> <year> 1990). </year>
Reference-contexts: Pure Post/Wait synchronization is incapable of implementing mutual exclusion because Wait operations do not reset the event variable (resetting requires a Clear operation). Approximate schemes for more powerful synchronization capable of implementing mutual exclusion, such as semaphores <ref> [4] </ref> or Post/Wait with Clear operations [2], have already been proposed. Precise detection schemes for programs that use no inter-hhhhhhhhhhhhhhhhhhhhhhhhhhhhh (a) In Post/Wait synchronization, each synchronization variable (or event variable) is either set or reset. A Wait (x) blocks until x is set; a Post (x) sets x. <p> This graph is a convenient representation of MHB as it requires only O (np) space (each of the n nodes has at most p out-edges), and it allows vector timestamps to be computed that allow constant-time determination of whether any two opera tions have a guaranteed ordering <ref> [4] </ref>. Algorithm 1 computes this graph by considering every operation in the execution and visiting the operations in its MVE. Visiting operations consists of simulating their execution by honoring the semantics of Post/Wait synchronization.
Reference: [5] <author> Hood, R., K. Kennedy, and J. Mellor-Crummey, </author> <title> ``Parallel Program Debugging with On-the-fly Anomaly Detection,'' </title> <booktitle> Supercomputing '90, </booktitle> <pages> pp. </pages> <address> 74-81 New York, NY, </address> <month> (November </month> <year> 1990). </year>
Reference-contexts: In addition, a restricted form of Post/Wait in PCF Fortran has been considered <ref> [5] </ref> (where at most one Post and Wait on any event variable are allowed). However, the full generality of Post/Wait synchronization has not yet been addressed.
Reference: [6] <author> Mellor-Crummey, J.M., </author> <title> ``On-the-Fly Detection of Data Races for Programs with Nested Fork-Join Parallelism,'' </title> <booktitle> Supercomputing '91, </booktitle> <pages> pp. </pages> <address> 24-33 Al-buquerque, NM, </address> <month> (November </month> <year> 1991). </year>
Reference-contexts: A Wait (x) blocks until x is set; a Post (x) sets x. Although some implementations also provide a Clear (x) operation to reset x, we are not considering such operations. 1 process synchronization (but only task spawning direc-tives such as fork and join) have also been proposed <ref> [1, 6] </ref>. In addition, a restricted form of Post/Wait in PCF Fortran has been considered [5] (where at most one Post and Wait on any event variable are allowed). However, the full generality of Post/Wait synchronization has not yet been addressed.
Reference: [7] <author> Netzer, R.H.B. and B.P. Miller, </author> <title> ``On the Complexity of Event Ordering for Shared-Memory Parallel Program Executions,'' </title> <booktitle> 1990 Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> II-93-II-97 St. Charles, IL, </address> <month> (August </month> <year> 1990). </year>
Reference-contexts: Previous work has addressed either conservative approximations, simpler types of synchronization, or detection of a different type of race (discussed above). Netzer and Miller proved that detecting races in executions that use synchronization powerful enough to implement mutual exclusion is NP-hard <ref> [7] </ref>. Efficient detection is possible only for weaker types of synchronization, such as Post/Wait. Pure Post/Wait synchronization is incapable of implementing mutual exclusion because Wait operations do not reset the event variable (resetting requires a Clear operation).
Reference: [8] <author> Netzer, R.H.B. and B.P. Miller, </author> <title> ``Improving the Accuracy of Data Race Detection,'' </title> <booktitle> 3rd ACM Symp. on Princ. and Practice of Parallel Prog., </booktitle> <pages> pp. </pages> <address> 133-144 Williamsburg, VA, </address> <month> (April </month> <year> 1991). </year>
Reference-contexts: Detecting such first races is the most important aspect of race condition detection, as subsequent races may be artifacts and not direct manifestations of bugs <ref> [8] </ref>. An advantage of our algorithm is that it requires only compact, efficiently obtainable traces of the execution's synchronization operations. Only the sequence of operations per process need be traced. No information about the relative execution order of operations in different processes is required. <p> For programs that contain implicit synchronization, we might omit some orderings that are in fact guaranteed. In addition, Netzer and Miller have shown that unintentional implicit synchronization can occur when shared values are used in conditional expressions <ref> [8] </ref>. They present techniques to estimate additional orderings introduced by intentional or unintentional implicit synchronization. These techniques are complementary to our algorithm, so we will not address this issue here. Consider the synchronization operations performed by the single program execution being analyzed.

References-found: 8

