URL: http://www.cs.utexas.edu/users/moore/acl2/reports/bkm96.ps
Refering-URL: http://www.cs.utexas.edu/users/moore/acl2/acl2-doc.html
Root-URL: 
Title: ACL2 Theorems about Commercial Microprocessors  
Author: Bishop Brock, Matt Kaufmann and J Strother Moore 
Address: 1717 West Sixth Street, Austin, TX 78703-4776, USA  
Affiliation: Computational Logic, Inc.,  
Abstract: ACL2 is a mechanized mathematical logic intended for use in specifying and proving properties of computing machines. In two independent projects, industrial engineers have collaborated with researchers at Computational Logic, Inc. (CLI), to use ACL2 to model and prove properties of state-of-the-art commercial microprocessors prior to fabrication. In the first project, Motorola, Inc., and CLI collaborated to specify Motorola's complex arithmetic processor (CAP), a single-chip, digital signal processor (DSP) optimized for communications signal processing. Using the specification, we proved the correctness of several CAP microcode programs. The second industrial collaboration involving ACL2 was between Advanced Micro Devices, Inc. (AMD) and CLI. In this work we proved the correctness of the kernel of the floating-point division operation on AMD's first Pentium-class microprocessor, the AMD5 K 86. In this paper, we discuss ACL2 and these industrial applications, with particular attention to the microcode verification work.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. Albin. </author> <title> Validating the ACL2 CAP Model. </title> <type> CAP Technical Report 9, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> 6th, Austin, TX 78703 March, </address> <year> 1995. </year>
Reference-contexts: Only a few hardware and software initiated reset sequences are not modeled by our specification; these sequences were unnecessary to our intended verification work. In an effort to validate the specification we compared its execution with the results from executing Motorola's SPW engineering model of the processor <ref> [1] </ref>. 3 For example, we compared the results of executing an end-to-end application (a QPSK modem) on both the SPW model and the ACL2 model; we found the final states bit-exact for all programmer visible registers.
Reference: 2. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press: </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Government. tools that are part of the ACL2 system. The ACL2 system is essentially a re--implemented extension, for applicative Common Lisp, of the so-called "Boyer-Moore theorem prover" Nqthm <ref> [2, 3] </ref>. 1.1 The Logic The ACL2 logic is a first-order, essentially quantifier-free logic of total recursive functions providing mathematical induction and two extension principles: one for recursive definition and one for "encapsulation." The syntax of ACL2 is a subset of that of Common Lisp. <p> Fig. 1. The Orchestration of Proof Techniques Roughly speaking, as the formula moves clockwise around the ring in Figure 1 it becomes more general. Eventually, if all else fails, the induction mechanism is applied. The proof techniques are extensions of those used by Nqthm; see <ref> [2] </ref>. Most of the techniques are rule-driven. The rules are derived from previously proved theorems.
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press: </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Government. tools that are part of the ACL2 system. The ACL2 system is essentially a re--implemented extension, for applicative Common Lisp, of the so-called "Boyer-Moore theorem prover" Nqthm <ref> [2, 3] </ref>. 1.1 The Logic The ACL2 logic is a first-order, essentially quantifier-free logic of total recursive functions providing mathematical induction and two extension principles: one for recursive definition and one for "encapsulation." The syntax of ACL2 is a subset of that of Common Lisp.
Reference: 4. <author> R. S. Boyer and Y. Yu. </author> <title> Automated Proofs of Object Code for a Widely Used Microprocessor, </title> <journal> JACM, </journal> <month> 43(1) January, </month> <year> 1996, </year> <pages> pp. 166-192. </pages>
Reference-contexts: This specification closely followed the style of earlier Nqthm work on modeling microprocessors, e.g., <ref> [19, 20, 28, 4] </ref>. Readers unfamiliar with that style need merely imagine defining, as a Lisp function, an interpreter for the intended machine language. We owe a special debt of gratitude to Yuan Yu, whose techniques in [39] we followed closely. <p> The manpower requirements of these ACL2 projects are not extreme, considering the amount of manpower industry currently throws at testing. The manpower requirements in projects focused on code proofs for a given machine (the FM9001 assembly language [28], the MC68020 machine code proofs <ref> [4] </ref>, the CAP work here, and the AAMP5 work [26]) all reflect a common theme: we are repeatedly measuring the startup costs. Building the formal model of the "new" machine or language and getting the appropriate library of rules in place dominates the costs. Yu's work, [4], demonstrated that if one <p> MC68020 machine code proofs <ref> [4] </ref>, the CAP work here, and the AAMP5 work [26]) all reflect a common theme: we are repeatedly measuring the startup costs. Building the formal model of the "new" machine or language and getting the appropriate library of rules in place dominates the costs. Yu's work, [4], demonstrated that if one simply focuses on proving one program after another, it begins to get routine.
Reference: 5. <author> B. Brock. </author> <title> The CAP 94 Specification, </title> <type> CAP Technical Report 8, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> 6th, Austin, TX 78703, </address> <month> July, </month> <year> 1995. </year>
Reference-contexts: One motivation for our involvement was to demonstrate that it was possible to create and then use a formal model of a state-of-the-art processor to verify applications programs. 2.2 The Model We began by creating a formal, executable, ACL2 specification of the CAP <ref> [5] </ref>. This specification closely followed the style of earlier Nqthm work on modeling microprocessors, e.g., [19, 20, 28, 4]. Readers unfamiliar with that style need merely imagine defining, as a Lisp function, an interpreter for the intended machine language.
Reference: 6. <author> B. Brock. </author> <title> Formal Analysis of the CAP Instruction Pipeline, </title> <type> CAP Technical Report 10, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> 6th, Austin, TX 78703, </address> <month> June, </month> <year> 1996. </year>
Reference-contexts: We did this by proving an appropriate correspondence between the pipelined CAP model and a simpler pipeline-free model of the CAP <ref> [6] </ref>. Aside from making subsequent code proofs easier, this work had the important benefit of identifying (with both precision and assurance) an equivalence condition sufficient to avoid hazards yet weak enough to admit CAP application programs.
Reference: 7. <author> B. Brock. </author> <title> Formal Verification of CAP Applications, </title> <type> CAP Technical Report 15, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> 6th, Austin, TX 78703, </address> <month> June, </month> <year> 1996. </year>
Reference-contexts: A wonderfully subtle generalization of a key lemma was necessary in order to produce a theorem that could be proved by mathematical induction, <ref> [7] </ref>. In addition, as in the FIR example, correctness also depends on the invariance of many low-level properties of the initial CAP state. 2.5 Manpower Breakdown Our involvement with the CAP project lasted 31 months. Only one formal methods expert (Brock) worked on the project continuously during that time.
Reference: 8. <author> R. E. Bryant. </author> <title> Bit-Level Analysis of an SRT Divider Circuit, </title> <institution> CMU-CS-95-140, School of Computer Science, Carnegie Mellon University, Pittsburg, </institution> <address> PA 15213. </address>
Reference-contexts: There has been much interest in the mechanical analysis of division algorithms since the Pentium bug. Almost all of the work focuses on SRT division <ref> [8, 32, 12] </ref>.
Reference: 9. <author> R. E. Bryant and Y. A. Chen. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <booktitle> In Proceedings of the 32nd ACM/IEEE Design Automation Conference IEEE Computer Society Press, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Many techniques exist for reducing the "naive" state-space (e.g., "scaling", the removal of all bits of state that do not support any property being checked); model checkers at higher levels of abstraction are also being developed <ref> [13, 9] </ref>. But the reason an unequivocal rejection of model checking is so difficult here is that with creative insight (i.e., "heavyweight thinking?") the user of a "lightweight" tool can often abstract the problem into one that is manageable.
Reference: 10. <author> J. R. Burch, E. M. Clarke, D. E. Long, K. L. McMillan and D. L. Dill. </author> <title> Symbolic Model Checking for Sequential Circuit Verification, </title> <journal> IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems 13(4) April, </journal> <year> 1994, </year> <pages> pp. 401-424. </pages>
Reference-contexts: Simply put, it is hard work producing proofs of conjectures like these, a fact which stands in stark contrast to the impressive results obtained by "lightweight" analysis tools requiring so much less of the user <ref> [10, 14, 17, 38] </ref>. So why should people use general purpose theorem provers? If correctness is important and the problem cannot be solved by special-purpose "lightweight" tools, then a "heavyweight" tool is not only appropriate but is the only alternative.
Reference: 11. <author> J. R. Burch and D. L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <editor> in David Dill, editor, </editor> <booktitle> Computer-Aided Verification, CAV '94, Stan-ford, CA, Springer-Verlag Lecture Notes in Computer Science Volume 818, </booktitle> <month> June, </month> <year> 1994, </year> <pages> pp. 68-80. </pages>
Reference-contexts: Our condition is weak enough to accept every ROM-resident DSP application on the CAP. Our equivalence proof follows the approach suggested by Burch and Dill <ref> [11] </ref>. We found their method for stating equivalence, involving the idea of flushing the pipeline, intuitive for writing specifications. Applying it to the full CAP specification was somewhat challenging. <p> The first conditional equivalence proof was carried out on a simplified model of the CAP and then repeated when the IO module was added. A serendipitous visit by David Dill occurred just as Brock was beginning the first proof; Dill explained the methods in <ref> [11] </ref>, which proved very useful. The details of the equivalence condition were derived from failed proofs. The condition was later weakened to so that it would accept the ROM-resident DSP application codes and the (now largely automatic) proof was repeated a third time to confirm the new condition.
Reference: 12. <author> E. M. Clarke, S. M. German and X. Zhao. </author> <title> Verifying the SRT Division Algorithm using Theorem Proving Techniques, </title> <booktitle> Proceedings of Conference on Computer-Aided Verification, CAV '96, </booktitle> <month> July, </month> <year> 1996. </year>
Reference-contexts: There has been much interest in the mechanical analysis of division algorithms since the Pentium bug. Almost all of the work focuses on SRT division <ref> [8, 32, 12] </ref>.
Reference: 13. <author> E. M. Clarke, M. Fujita, and X. Zhao. </author> <title> Hybrid Decision Diagrams, </title> <address> ICCAD95, </address> <year> 1995, </year> <pages> pp. 159-163. </pages>
Reference-contexts: Many techniques exist for reducing the "naive" state-space (e.g., "scaling", the removal of all bits of state that do not support any property being checked); model checkers at higher levels of abstraction are also being developed <ref> [13, 9] </ref>. But the reason an unequivocal rejection of model checking is so difficult here is that with creative insight (i.e., "heavyweight thinking?") the user of a "lightweight" tool can often abstract the problem into one that is manageable.
Reference: 14. <author> E. M. Clarke, O. Grumberg, H. Hiraishi, S. Jha, D. E. Long, K. L. McMillan and L. A. Ness. </author> <title> Verification of the Futurebus+ Cache Coherence Protocol, </title> <booktitle> Proc. </booktitle> <address> CHDL, </address> <year> 1993. </year>
Reference-contexts: Simply put, it is hard work producing proofs of conjectures like these, a fact which stands in stark contrast to the impressive results obtained by "lightweight" analysis tools requiring so much less of the user <ref> [10, 14, 17, 38] </ref>. So why should people use general purpose theorem provers? If correctness is important and the problem cannot be solved by special-purpose "lightweight" tools, then a "heavyweight" tool is not only appropriate but is the only alternative.
Reference: 15. <author> J. Crow, S. Owre, J. Rushby, N. Shankar, and M. Srivas. </author> <title> A Tutorial Introduction to PVS, presented at Workshop on Industrial-Strength Formal Specification Techniques, </title> <address> Boca Raton, FL, </address> <note> April 1995 (see http://www.csl.sri.com/pvs.html). </note>
Reference-contexts: Until the CAP work, the most complicated commercial processor subjected to formal modeling at the functional level was probably the Rockwell-Collins AAMP5, a special purpose avionics processor. The functionality of the AAMP5 was partially specified with PVS <ref> [15] </ref>, as described in [26]: 108 of 209 instructions were specified and the two-stage pipelined microcode for eleven was verified.
Reference: 16. <author> S. Gilfeather, J. Gehman, and C. Harrison. </author> <title> Architecture of a Complex Arithmetic Processor for Communication Signal Processsing in SPIE Proceedings, </title> <booktitle> International Symposium on Optics, Imaging, and Instrumentation, 2296 Advanced Signal Processing: Algorithms, Architectures, and Implementations V, </booktitle> <month> July, </month> <year> 1994, </year> <pages> pp. 624-625. </pages>
Reference-contexts: books, representing about 15% of the system, has been certified by ACL2; however, all the source books have been checked syntactically by ACL2. 2 Motorola CAP The CAP is a single-chip, DSP co-processor optimized for communications signal processing, currently under development by Motorola Government and Systems Technology Group, Scottsdale, Arizona <ref> [16] </ref>. During the first seven months of the project one of us (Brock) relocated from Austin, Texas, to Scottsdale to work in close collaboration with the CAP design team. For the succeeding 18 months a member of the design team (Calvin Harrison) relocated to Austin to work at CLI.
Reference: 17. <author> Z. Har'El and R. P. Kurshan. </author> <title> Software for Analytical Development of Communications Protocols, </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 69(1) Jan-Feb, </volume> <year> 1990, </year> <pages> pp. 45-59. </pages>
Reference-contexts: Simply put, it is hard work producing proofs of conjectures like these, a fact which stands in stark contrast to the impressive results obtained by "lightweight" analysis tools requiring so much less of the user <ref> [10, 14, 17, 38] </ref>. So why should people use general purpose theorem provers? If correctness is important and the problem cannot be solved by special-purpose "lightweight" tools, then a "heavyweight" tool is not only appropriate but is the only alternative.
Reference: 18. <author> C. Harrison. </author> <title> Hardware Verification of the Complex Arithmetic Processor XY Address Generator. </title> <type> CAP Technical Report 16, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> 6th, Austin, TX 78703, </address> <month> August, </month> <year> 1995. </year>
Reference-contexts: A small part of the hardware implementation of the processor, the XY memory address generation unit, has been formally verified to agree with with the corresponding part of the ACL2 model <ref> [18] </ref>; this involved the hand-translation into ACL2 (in a very mechanical fashion) of the SPW description of the hardware. We believe that CAP is the most complex processor for which a complete formal specification has been produced.
Reference: 19. <author> W. A. Hunt, Jr. </author> <title> Microprocessor Design Verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4), </volume> <pages> pp. 429-460, </pages> <year> 1989. </year>
Reference-contexts: This specification closely followed the style of earlier Nqthm work on modeling microprocessors, e.g., <ref> [19, 20, 28, 4] </ref>. Readers unfamiliar with that style need merely imagine defining, as a Lisp function, an interpreter for the intended machine language. We owe a special debt of gratitude to Yuan Yu, whose techniques in [39] we followed closely.
Reference: 20. <author> W. A. Hunt, Jr. and B. Brock. </author> <title> A Formal HDL and its use in the FM9001 Verification. </title> <journal> Proceedings of the Royal Society, </journal> <year> 1992. </year>
Reference-contexts: This specification closely followed the style of earlier Nqthm work on modeling microprocessors, e.g., <ref> [19, 20, 28, 4] </ref>. Readers unfamiliar with that style need merely imagine defining, as a Lisp function, an interpreter for the intended machine language. We owe a special debt of gratitude to Yuan Yu, whose techniques in [39] we followed closely.
Reference: 21. <author> W. A. Hunt, Jr. </author> <title> CAP Pin-level Specifications, </title> <type> CAP Technical Report 12, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> 6th, Austin, TX 78703, </address> <month> April, </month> <year> 1996. </year>
Reference-contexts: We owe a special debt of gratitude to Yuan Yu, whose techniques in [39] we followed closely. Our behavioral-level specification describes every well-defined behavior of the CAP including all legal instructions, I/O <ref> [21] </ref>, traps, and interrupts. Only a few hardware and software initiated reset sequences are not modeled by our specification; these sequences were unnecessary to our intended verification work.
Reference: 22. <author> M. Kaufmann and J S. Moore. </author> <title> High-Level Correctness of ACL2: A Story, </title> <address> URL ftp://ftp.cli.com/pub/acl2/v1-8/acl2-sources/reports/story.txt, </address> <month> September, </month> <year> 1995. </year>
Reference-contexts: The user wishing to improve the execution speed of an ACL2 model is therefore encouraged to do guard verification. We discuss guards in more detail in [24]. Finally, ACL2 has two extension principles: definition and encapsulation. Both preserve the consistency of the extended logic. See <ref> [22] </ref>. The definitional principle insures consistency by requiring a proof that each defined function terminates. This is done, as in Nqthm, by the identification of some ordinal measure of the formals that decreases in recursion. The encapsulation principle allows the introduction of new function symbols axiomatized to have certain properties. <p> Because of the conservative nature of the extensions created by encapsulation, that logical mechanism is also very useful as a proof management tool. A complicated theorem can be derived in an encapsulation in which the uninter-esting but necessary details are developed locally. See <ref> [22] </ref> for a detailed logical justification of encapsulation. Fig. 2.
Reference: 23. <author> M. Kaufmann and J S. Moore. </author> <note> ACL2 Version 1.8, URL ftp://ftp.cli.- com/pub/acl2/v1-8/acl2-sources/doc/HTML/acl2-doc.html, </note> <year> 1995. </year>
Reference: 24. <author> M. Kaufmann and J S. Moore. ACL2: </author> <title> An Industrial Strength Version of Nqthm. </title> <booktitle> In Proceedings of the Eleventh Annual Conference on Computer Assurance (COMPASS-96), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June, </month> <year> 1996, </year> <pages> pp. 23-34. </pages>
Reference-contexts: The user wishing to improve the execution speed of an ACL2 model is therefore encouraged to do guard verification. We discuss guards in more detail in <ref> [24] </ref>. Finally, ACL2 has two extension principles: definition and encapsulation. Both preserve the consistency of the extended logic. See [22]. The definitional principle insures consistency by requiring a proof that each defined function terminates.
Reference: 25. <author> M. Kaufmann and P. Pecchiari. </author> <title> Interaction with the Boyer-Moore and Theorem Prover: A Tutorial Study Using the Arithmetic-Geometric Mean Theorem. </title> <journal> Journal of Automated Reasoning 16(1-2) March, </journal> <year> 1996, </year> <pages> pp. 181-222. </pages>
Reference-contexts: Make no mistake, these were "heavy duty proofs" requiring many skills, including great familiarity and insight into the applications areas, engineering issues, mathematics, formal logic, and the workings of the ACL2 proof tool. Furthermore, a fair amount of dedication and persistence were also required. See for example <ref> [25] </ref> for a case study describing practical problems in the use of a general purpose theorem prover.
Reference: 26. <author> S. P. Miller and M. Srivas. </author> <title> Formal Verification of the AAMP5 Microprocessor: </title>
Reference-contexts: Until the CAP work, the most complicated commercial processor subjected to formal modeling at the functional level was probably the Rockwell-Collins AAMP5, a special purpose avionics processor. The functionality of the AAMP5 was partially specified with PVS [15], as described in <ref> [26] </ref>: 108 of 209 instructions were specified and the two-stage pipelined microcode for eleven was verified. <p> The CAP instruction pipeline is certainly not the most complex instruction pipeline that has been formally specified and analyzed. However, although others have considered a few instructions on a pipelined commercial processor design (such as the AAMP5 work, <ref> [26] </ref>), or all instructions on a simple academic example [34, 35], our results cover every instruction sequence in a complete, bit-accurate model of a commercially designed processor. <p> The manpower requirements in projects focused on code proofs for a given machine (the FM9001 assembly language [28], the MC68020 machine code proofs [4], the CAP work here, and the AAMP5 work <ref> [26] </ref>) all reflect a common theme: we are repeatedly measuring the startup costs. Building the formal model of the "new" machine or language and getting the appropriate library of rules in place dominates the costs. <p> Once the startup costs have been paid for a given machine, the step of intuiting the informal proof becomes much more dominant. Our CAP and AMD5 K 86 projects, as well as the AAMP5 work <ref> [26] </ref>, also support the conclusion that theorem-prover based formal methods can "keep up" with an evolving hardware design and make important contributions.
References-found: 26

