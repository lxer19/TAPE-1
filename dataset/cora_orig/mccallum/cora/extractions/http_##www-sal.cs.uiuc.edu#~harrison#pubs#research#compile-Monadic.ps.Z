URL: http://www-sal.cs.uiuc.edu/~harrison/pubs/research/compile-Monadic.ps.Z
Refering-URL: http://www-sal.cs.uiuc.edu/~harrison/pubs/research/research.html
Root-URL: http://www.cs.uiuc.edu
Email: fharrison,kaming@cs.uiuc.edu  
Title: Deriving Compilers from Monadic Semantics  
Author: William L. Harrison and Samuel N. Kamin 
Keyword: Compilers, Partial Evaluation, Semantics-Based Compilation, Programming Language Semantics, Monads, Monad Transformers, Pass Separation.  
Date: October 1, 1997  
Affiliation: Department of Computer Science University of Illinois, Urbana-Champaign  
Abstract: The monadic style of language specification [6, 16, 15, 26] has the advantages of modularity and extensibility: it is simple to add or change features in an interpreter to reflect modifications in the source language. It has proven difficult to extend the method to compilation, because there is considerable interaction between different features. We demonstrate that by introducing machine-like stores (code and data) into the monadic semantics (to achieve pass separation [12]) and then partially evaluating the resulting semantic expressions, we can achieve many of the same advantages for a compiler as for an interpreter. A number of language constructs and features are compiled: expressions, while loops, CBV and CBN evaluation of -expressions, dynamic scoping, and various imperative features. The treatment of recursive procedures is outlined as well. The resulting method allows compilers to be constructed in a mix-and-match fashion just as in a monad-structured interpreter.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: compilation semantics, respectively. 6 Output from partial evaluator: (lambda (halt store add negate read) (lambda (a0) (lambda (sto1) (cons (cons ((store 1 (negate (read 0))) ((store 0 1) sto1)) 2) ((store "ACC" (negate (read 1))) ((store 1 (negate (read 0))) ((store 0 1) sto1))))))) Pretty printed version: [0] := 1; <ref> [1] </ref> := -[0]; Acc := -[1]; n 2 Numeral c 2 Cmd ::= c 1 ;c 2 j Addr:=Exp j if Bool then c t 2 Exp ::= n, b 2 Bool ::= T rue j F alse j not b j bor b 0 by lambda-abstracting over them in the <p> Dynamic scoping is introduced by altering the specification for application: [[t 1 t 2 ]] = C [[t 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; <ref> [1] </ref> := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN <p> s ; fi c &gt; :updateSto (: ) bind (: fi s ( l)) Source Code: new g:intvar in let f = v: intvar: e: intexp: v := 1 + e ; v := (g + 1) + e in f g (g + 1) Target Code: [0] := 0; <ref> [1] </ref> := [0]+1; [0] := 1+[1]; [1] := [0]+1; [2] := [0]+1; [0] := [1]+[2]; integer variable i. The specification for assignment looks up the acceptor-expresser pair associated with i, and passes the appropriate double continuation on to the integer expression ie. <p> (: ) bind (: fi s ( l)) Source Code: new g:intvar in let f = v: intvar: e: intexp: v := 1 + e ; v := (g + 1) + e in f g (g + 1) Target Code: [0] := 0; <ref> [1] </ref> := [0]+1; [0] := 1+[1]; [1] := [0]+1; [2] := [0]+1; [0] := [1]+[2]; integer variable i. The specification for assignment looks up the acceptor-expresser pair associated with i, and passes the appropriate double continuation on to the integer expression ie. The compilation semantics for new and assignment are identical to their standard semantics. <p> The type of stack locations are non-negative integer pairs &lt; f rame; disp &gt;, which may be thought of as a display address <ref> [1] </ref>, or alternatively, as a stack shape [23]. Intuitively, f rame points to an activation record and disp is an offset within that record. Following Reynolds [23], we assume each activation record has a call block where the labels of argument parameters are stored. <p> ]] = rdEnv bind : inEnv [ 7! fix (:[[c]])] [[c 0 ]] C [[letrec c : comm in c 0 ]] = rdEnv bind : currentFrame bind f: newlabel bind L c : C [[c]] bind : newSegment (L c ; inEnv [ 7! mkCall L c f] (return <ref> [f + 1; 1] </ref>)) bind : inEnv [ 7! mkCall L c f] C [[c 0 ]] mkCall L c f = newlabel bind L : unit: newSegment (L ; ) bind : updateSto ([f + 1; 1] 7! L ) bind : call L c call L c = rdSeg
Reference: [2] <author> H. Christiansen and Neil Jones. </author> <title> Control Flow Treatment in a Simple Semantics-directed Compiler Generator. Formal Description of Programming Concepts II, </title> <publisher> North-Holland Publishing Company 1983. </publisher>
Reference-contexts: newlabel bind L end : unit : newSegment (L end ; ) bind : newSegment (L test ; fi &lt;jump L c ; jump L end &gt;) bind : newSegment (L c ; fC [[c]];jumpL end g) bind : jump L test 12 0: jump 1; 1: [0] := 1; <ref> [2] </ref> := [0]+[1]; [4] := [2]+[3]; jump 2; 2: halt; it is a simple matter to create a monad for the compilation semantics for the language containing both simple expressions and control-flow. The syntax of this language is the conjunction of the syntax in Figures 1 and 5. <p> Dynamic scoping is introduced by altering the specification for application: [[t 1 t 2 ]] = C [[t 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; <ref> [2] </ref> := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: <p> := <ref> [2] </ref>+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; ACC := [2]+[3]; Observe that t 2 will not be evaluated in the current environment as with static scoping. An example is presented in Figure 13. <p> := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; <ref> [2] </ref> := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; ACC := [2]+[3]; Observe that t 2 will not be evaluated in the current environment as with static scoping. An example is presented in Figure 13. <p> (: fi s ( l)) Source Code: new g:intvar in let f = v: intvar: e: intexp: v := 1 + e ; v := (g + 1) + e in f g (g + 1) Target Code: [0] := 0; [1] := [0]+1; [0] := 1+[1]; [1] := [0]+1; <ref> [2] </ref> := [0]+1; [0] := [1]+[2]; integer variable i. The specification for assignment looks up the acceptor-expresser pair associated with i, and passes the appropriate double continuation on to the integer expression ie. The compilation semantics for new and assignment are identical to their standard semantics. <p> Both semantics for and = are very similar to those of addition, and so have not been included for reasons of space. An example is presented in Figure 18. Observe the use of temporary storage at <ref> [2] </ref> for the calculation of (g + 1) + e. 5.1 Recursive Bindings In Section 4.4, procedures were compiled via inlining, but that approach will not suffice for recursive bindings.
Reference: [3] <author> C. Consel and O. Danvy. </author> <title> Static and Dynamic Semantics Processing. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: Dynamic scoping is introduced by altering the specification for application: [[t 1 t 2 ]] = C [[t 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; <ref> [3] </ref> := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; <p> [2]+<ref> [3] </ref>; ACC := [2]+[3]; Observe that t 2 will not be evaluated in the current environment as with static scoping. An example is presented in Figure 13. The case of dynamic binding, when the body of f is evaluated, the most recent binding of s (i.e., 5) is stored in [3], rather than the value of s when f was defined (i.e., 10). 5 Compilation of Idealized Algol is the language compiled by Reynolds in [23], and the compiler we derive is essentially identical to Reynolds for the non-recursive fragment.
Reference: [4] <author> O. Danvy. </author> <title> Type-Directed Partial Evaluation. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: This code generation technique is due to Danvy and Vestergaard [5]; we use Danvys type-directed partial evaluator <ref> [4] </ref> to accomplish it. An example is presented in Figure 4. The "code" produced takes the form of a number of stores and reads from storage (it is underlined in the figure). <p> end : unit : newSegment (L end ; ) bind : newSegment (L test ; fi &lt;jump L c ; jump L end &gt;) bind : newSegment (L c ; fC [[c]];jumpL end g) bind : jump L test 12 0: jump 1; 1: [0] := 1; [2] := [0]+[1]; <ref> [4] </ref> := [2]+[3]; jump 2; 2: halt; it is a simple matter to create a monad for the compilation semantics for the language containing both simple expressions and control-flow. The syntax of this language is the conjunction of the syntax in Figures 1 and 5. <p> Dynamic scoping is introduced by altering the specification for application: [[t 1 t 2 ]] = C [[t 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; <ref> [4] </ref> := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5;
Reference: [5] <author> O. Danvy and R. Vestergaard. </author> <title> Semantics-Based Compiling: A Case Study in Type-Directed Partial Evaluation Eighth International Symposium on Programming Language Implementation and Logic Programming, </title> <booktitle> 1996, </booktitle> <pages> pages 182-197. </pages>
Reference-contexts: Their interpreter had no monadic structure. Also, their derivations were non-automatic as the introduction and exploitation of intermediate data structure was quite subtle. Danvy and Vestergaard <ref> [5] </ref> show how to produce code that "looks like" machine language, by expressing the source language semantics in terms of machine language-like combinators (e.g., "update", "popblock", "push"). <p> This code generation technique is due to Danvy and Vestergaard <ref> [5] </ref>; we use Danvys type-directed partial evaluator [4] to accomplish it. An example is presented in Figure 4. The "code" produced takes the form of a number of stores and reads from storage (it is underlined in the figure). <p> introduced by altering the specification for application: [[t 1 t 2 ]] = C [[t 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; <ref> [5] </ref> := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1];
Reference: [6] <author> D. Espinosa. </author> <title> Semantic Lego. </title> <type> Doctoral Dissertation, </type> <institution> Columbia University, </institution> <year> 1995. </year>
Reference-contexts: 1 Introduction This paper addresses the classic problem of generating compilers from denotational specifications of languages. Our tools are mainly classic as well: partial evaluation [9] and pass separation [12]. We add one new tool to this arsenal: monads. These have been used in the past to structure denotational definitions <ref> [16, 6, 26] </ref>, where the allow a mix-and-match (what Espinosa calls "semantic lego" [6]) approach. We argue that similar benefits can be obtained for compilers. Our method of compilation can be summarized as follows: 1. Start with a monad-structured semantics. <p> Our tools are mainly classic as well: partial evaluation [9] and pass separation [12]. We add one new tool to this arsenal: monads. These have been used in the past to structure denotational definitions [16, 6, 26], where the allow a mix-and-match (what Espinosa calls "semantic lego" <ref> [6] </ref>) approach. We argue that similar benefits can be obtained for compilers. Our method of compilation can be summarized as follows: 1. Start with a monad-structured semantics. More precisely, the semantics is based on monad transformers [16]. fl Department of Computer Science, 1304 West Springfield Avenue, Urbana, Illinois, 61801-2987, USA. <p> We then define call-by-value and call-by-name procedures, and dynamic binding, as examples of the kinds of features that can be compiled in this modular fashion. Our final example is the idealized Algol compiled by Reynolds in [23]. 2 Related Work Hudak, Liang, and Jones [16], Espinosa <ref> [6] </ref>, and Wadler [26] use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. <p> Our compiler for that language, presented in Section 5, improves on Reynolds in two ways: it is monad-structured|that is, built from interchangeable parts|and it includes jumps and labels where Reynolds simply allowed code duplication and infinite programs. 3 Monads and Monad Transformers Recent work in semantics <ref> [26, 16, 6] </ref> indicates that the denotational semantics for languages can be constructed modularly using monads and monad transformers as building blocks. When applied to a monad M, a monad transformer T creates a new monad M 0 with some additional features (e.g., states, environments, etc.). <p> These features are usually encapsulated by one or more combinators. For example, if T were the state transformer, a combinator: updateSto : (Sto ! Sto) ! M 0 Sto can be defined to manipulate the newly added state type Sto <ref> [16, 6] </ref>. The existing combinators of M are lifted through T meaning that they are redefined in a canonical manner for M 0 . <p> In this sense, it is similar to action semantics [20, 19] and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see <ref> [26, 16, 6] </ref>. 4 Introductory Examples Monadic definitions are not directly amenable to compilation because the structure of a denotational definition and a compiler are quite different. <p> the specification for application: [[t 1 t 2 ]] = C [[t 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; <ref> [6] </ref> := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; <p> application: [[t 1 t 2 ]] = C [[t 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; <ref> [6] </ref> := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; <p> Figure 19 contains the standard and compilation semantics for letrec and Figure 20 presents an example. 6 Conclusions and Further Work The main contribution of this work is the development a "mix-and-match" compilation method similar to the modular interpreter constructions of <ref> [16, 6, 26] </ref>. Using monads and monad transformers to structure semantics-directed compilers achieves much of the same flexibility and modularity that one associates with monadic interpreters. <p> The use of partial evaluation in the compiler clarifies the relationship between the compilation semantics and the machine language semantics; one of the remaining issues with this compilation method is to establish a formal correctness proof. Claims have been made <ref> [15, 17, 6] </ref> that proofs about monadic specifications retain some modularity as well, and a correctness proof of this method would be a good test of this.
Reference: [7] <author> W. Harrison and S. Kamin. </author> <title> Compilation as Partial Evaluation of Functor Category Semantics. </title> <type> Unpublished manuscript. </type>
Reference: [8] <author> N. D. Jones and D. A. Schmidt. </author> <title> Compiler Generation from Denotational Semantics. </title> <editor> In N. D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, </booktitle> <address> LNCS94, </address> <year> 1980, </year> <pages> pages 70-93. </pages>
Reference-contexts: t 2 ]] = C [[t 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; <ref> [8] </ref> := [6]+[7]; ACC := [6]+[7]; [10] := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; ACC := [2]+[3];
Reference: [9] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International Series in Computer Science, Prentice-Hall 1993. </booktitle>
Reference-contexts: 1 Introduction This paper addresses the classic problem of generating compilers from denotational specifications of languages. Our tools are mainly classic as well: partial evaluation <ref> [9] </ref> and pass separation [12]. We add one new tool to this arsenal: monads. These have been used in the past to structure denotational definitions [16, 6, 26], where the allow a mix-and-match (what Espinosa calls "semantic lego" [6]) approach. We argue that similar benefits can be obtained for compilers.
Reference: [10] <author> N. D. Jones, P. Sestoft, and H. Sondergaard. </author> <title> An Experiment in Partial Evaluation: The Generation of a Compiler Generator. </title> <booktitle> Proceedings of the First International Conference on Rewriting Techniques and Applications, </booktitle> <month> May </month> <year> 1985. </year>
Reference-contexts: 1 t 2 ]] = C [[t 1 ]] bind f:f (C [[t 2 ]]) 14 CBN evaluation: CBV evaluation: [0] := 1; [1] := 1; [2] := [0]+[1]; [3] := [1]+[2]; [4] := [2]+[3]; [5] := [3]+[4]; [6] := 1 [6] := [0]; [8] := [6]+[7]; ACC := [6]+[7]; <ref> [10] </ref> := [8]+[9]; ACC := [5]+[11]; let p = let f = x: x + s in (g 5) CBN + static scope: CBN + dynamic scope: [0] := 5; [0] := 5; [2] := [0]+[1]; [2] := [0]+[1]; ACC := [2]+[3]; ACC := [2]+[3]; Observe that t 2 will not
Reference: [11] <author> N. D. Jones, P. Sestoft, and H. Sondergaard. </author> <title> MIX: A Self-applicable Partial Evaluator for Experiments in Compiler Generation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2, </volume> <month> 9-50 </month> <year> (1989). </year>
Reference: [12] <author> U. Jorring and W. </author> <title> Scherlis. </title> <booktitle> Compilers and Staging Transformations Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1986. </year>
Reference-contexts: 1 Introduction This paper addresses the classic problem of generating compilers from denotational specifications of languages. Our tools are mainly classic as well: partial evaluation [9] and pass separation <ref> [12] </ref>. We add one new tool to this arsenal: monads. These have been used in the past to structure denotational definitions [16, 6, 26], where the allow a mix-and-match (what Espinosa calls "semantic lego" [6]) approach. We argue that similar benefits can be obtained for compilers. <p> Liangs work is the most closely related to ours, but since he does not compile to machine language, many of the issues we confront|especially pass separation|do not arise. Jorring and Scherlis <ref> [12] </ref> introduced the term "pass separation", which they defined as: The idea of pass separation is to introduce intermediate data structure to pass values between two phases of computation, enabling separation of the two phases. 2 They showed how how compilers could be constructed by introducing intermediate data structures into an <p> Assuming that the standard semantics is written in terms of a monad M, where M = T ID for the monad transformer T and identity monad ID, we can add the intermediate data structure for pass separation <ref> [12] </ref> by substituting a "larger" monad than ID in the definition of M, and lifting the additional combinators through T . So the new monad is defined as: M c = T (StateT Addr (StateT Sto ID)) where Addr = int and Sto = Addr ! int 2 .
Reference: [13] <author> R. Kelsey and P. Hudak. </author> <title> Realistic Compilation by Program Transformation. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference: [14] <author> P. Lee. </author> <title> Realistic Compiler Generation. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Monadic semantics separate the description of a language (i.e., its specification) from its definition (i.e., its denotation or underlying model). In this sense, it is similar to action semantics [20, 19] and high-level semantics <ref> [14] </ref>. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. <p> := [&lt;0,1&gt;]-1; call 1; &lt;0,0&gt; := 1; brEQ [&lt;0,1&gt;] 0 2 3; 5: return [1,1]; &lt;0,1&gt; := 5; 2: jump 5; 6: jump 5; storeCB [1,1] 7; 3: jump 4; 7: halt; call 1; transformers without complicating the denotational description unnecessarily, and because of this separability as Lee calls it <ref> [14] </ref>, monadic specifications are a natural setting for pass separation. The use of partial evaluation in the compiler clarifies the relationship between the compilation semantics and the machine language semantics; one of the remaining issues with this compilation method is to establish a formal correctness proof.
Reference: [15] <author> S. Liang. </author> <title> A Modular Semantics for Compiler Generation. </title> <institution> Yale University Department of Computer Science Technical Report TR-1067, </institution> <month> February </month> <year> 1995. </year> <month> 21 </month>
Reference-contexts: This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. Liang <ref> [15, 17] </ref> addresses that question, proposing that monadic semantics constructed from monad transformers and monadic specifications provide a modular and extensible basis for semantics-directed compilation. <p> The use of partial evaluation in the compiler clarifies the relationship between the compilation semantics and the machine language semantics; one of the remaining issues with this compilation method is to establish a formal correctness proof. Claims have been made <ref> [15, 17, 6] </ref> that proofs about monadic specifications retain some modularity as well, and a correctness proof of this method would be a good test of this.
Reference: [16] <author> S. Liang, P. Hudak, and M. Jones. </author> <title> Monad Transformers and Modular Interpreters. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: 1 Introduction This paper addresses the classic problem of generating compilers from denotational specifications of languages. Our tools are mainly classic as well: partial evaluation [9] and pass separation [12]. We add one new tool to this arsenal: monads. These have been used in the past to structure denotational definitions <ref> [16, 6, 26] </ref>, where the allow a mix-and-match (what Espinosa calls "semantic lego" [6]) approach. We argue that similar benefits can be obtained for compilers. Our method of compilation can be summarized as follows: 1. Start with a monad-structured semantics. <p> We argue that similar benefits can be obtained for compilers. Our method of compilation can be summarized as follows: 1. Start with a monad-structured semantics. More precisely, the semantics is based on monad transformers <ref> [16] </ref>. fl Department of Computer Science, 1304 West Springfield Avenue, Urbana, Illinois, 61801-2987, USA. Homepages: http://www-sal.cs.uiuc.edu/~fharrison,kaming. Phone: (217) 333-8069. Fax: (217) 244-6869. 1 2. <p> We then define call-by-value and call-by-name procedures, and dynamic binding, as examples of the kinds of features that can be compiled in this modular fashion. Our final example is the idealized Algol compiled by Reynolds in [23]. 2 Related Work Hudak, Liang, and Jones <ref> [16] </ref>, Espinosa [6], and Wadler [26] use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. <p> Our compiler for that language, presented in Section 5, improves on Reynolds in two ways: it is monad-structured|that is, built from interchangeable parts|and it includes jumps and labels where Reynolds simply allowed code duplication and infinite programs. 3 Monads and Monad Transformers Recent work in semantics <ref> [26, 16, 6] </ref> indicates that the denotational semantics for languages can be constructed modularly using monads and monad transformers as building blocks. When applied to a monad M, a monad transformer T creates a new monad M 0 with some additional features (e.g., states, environments, etc.). <p> These features are usually encapsulated by one or more combinators. For example, if T were the state transformer, a combinator: updateSto : (Sto ! Sto) ! M 0 Sto can be defined to manipulate the newly added state type Sto <ref> [16, 6] </ref>. The existing combinators of M are lifted through T meaning that they are redefined in a canonical manner for M 0 . <p> In this sense, it is similar to action semantics [20, 19] and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see <ref> [26, 16, 6] </ref>. 4 Introductory Examples Monadic definitions are not directly amenable to compilation because the structure of a denotational definition and a compiler are quite different. <p> Its syntax is given in Figure 1 and its standard semantics is given in arithmetic expressions [24]. Given an expression like " 1", a compiler would typically generate machine code (assuming 1 Some care must be taken in the order of application of monad transformers. Cf. <ref> [16] </ref> 4 [[n]] = unit fi: fin [[t]] = [[t]] bind e: unit fi: e (i:fi (i)) [[t 1 ]] bind e 1 : [[t 2 ]] bind e 2 : unit fi:(e 1 (v 1 :e 2 (v 2 :fi (v 1 + v 2 )))) no "constant folding" optimization <p> However, it is quite simple to add address allocation and store using the state monad transformer <ref> [16, 26] </ref>. In the parlance of pass separation, the addresses and storage are intermediate data structures. We do not claim that the standard monadic definition in Figure 2 can be used to obtain machine language programs. <p> Semantically, this requires that environments be added to the underlying monad, and we accomplish this by applying the environment monad transformer EnvT <ref> [16] </ref>. <p> Figure 19 contains the standard and compilation semantics for letrec and Figure 20 presents an example. 6 Conclusions and Further Work The main contribution of this work is the development a "mix-and-match" compilation method similar to the modular interpreter constructions of <ref> [16, 6, 26] </ref>. Using monads and monad transformers to structure semantics-directed compilers achieves much of the same flexibility and modularity that one associates with monadic interpreters.
Reference: [17] <author> S. Liang. </author> <title> Modular Monadic Semantics and Compilation. </title> <type> Doctoral Thesis, </type> <institution> Yale University, </institution> <year> 1997. </year>
Reference-contexts: This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. Liang <ref> [15, 17] </ref> addresses that question, proposing that monadic semantics constructed from monad transformers and monadic specifications provide a modular and extensible basis for semantics-directed compilation. <p> Liang [15, 17] addresses that question, proposing that monadic semantics constructed from monad transformers and monadic specifications provide a modular and extensible basis for semantics-directed compilation. He describes an experiment in <ref> [17] </ref> wherein the Glasgow Haskell compiler is retargeted to the SML/NJ back-end, and develops many examples of reasoning about monadic specifications. Liangs work is the most closely related to ours, but since he does not compile to machine language, many of the issues we confront|especially pass separation|do not arise. <p> The use of partial evaluation in the compiler clarifies the relationship between the compilation semantics and the machine language semantics; one of the remaining issues with this compilation method is to establish a formal correctness proof. Claims have been made <ref> [15, 17, 6] </ref> that proofs about monadic specifications retain some modularity as well, and a correctness proof of this method would be a good test of this.
Reference: [18] <author> F. L. </author> <title> Morris Advice on structuring compilers and proving them correct. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1973. </year>
Reference: [19] <author> P. Mosses. </author> <title> Abstract semantic algebras! Formal description of programming concepts II, </title> <booktitle> IFIP IC-2 Working Conference, </booktitle> <editor> D. Bjorner, Ed., </editor> <publisher> North-Holland, Amsterdam, </publisher> <pages> 63-88. </pages>
Reference-contexts: Monadic semantics separate the description of a language (i.e., its specification) from its definition (i.e., its denotation or underlying model). In this sense, it is similar to action semantics <ref> [20, 19] </ref> and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner.
Reference: [20] <author> P. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Monadic semantics separate the description of a language (i.e., its specification) from its definition (i.e., its denotation or underlying model). In this sense, it is similar to action semantics <ref> [20, 19] </ref> and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner.
Reference: [21] <author> L. C. Paulson. </author> <title> Compiler Generation from Denotational Semantics. </title> <editor> In Bernard Lorho, editor, </editor> <booktitle> Methods and Tools for Compiler Construction, </booktitle> <pages> pages 219-250. </pages> <publisher> Cambridge University Press, </publisher> <year> 1984. </year>
Reference: [22] <author> J. Reynolds. </author> <title> The Essence of Algol Algorithmic Languages, </title> <booktitle> Proceedings of the International Symposium on Algorithmic Languages, </booktitle> <address> Amsterdam, </address> <month> October 26-29, </month> <year> 1981, </year> <pages> pp. 345-372. </pages>
Reference-contexts: The command "new i in c" creates a new integer variable i which exists only during the execution of c. Its standard semantics is presented in Figure 17. The integer variable i is bound to an acceptor-expresser pair as in <ref> [22] </ref>. In Figure 17, "set S" returns an integer acceptor which takes an integer value, assigns the value to location S, and continues with the program.
Reference: [23] <author> J. Reynolds. </author> <title> Using Functor Categories to Generate Intermediate Code. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <pages> pages 25-36, </pages> <year> 1995. </year>
Reference-contexts: We then define call-by-value and call-by-name procedures, and dynamic binding, as examples of the kinds of features that can be compiled in this modular fashion. Our final example is the idealized Algol compiled by Reynolds in <ref> [23] </ref>. 2 Related Work Hudak, Liang, and Jones [16], Espinosa [6], and Wadler [26] use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. <p> These combinators, then, constitute the target language of the compiler. This approach is key to making the monadic structure useful for compilation. Reynolds <ref> [23] </ref> demonstration of how to produce efficient code in a compiler derived from the functor category semantics of an Algol-like language was an original inspiration for this study. We improve on in that our target language has jumps and labels, thus avoiding code duplication, tree-structured code, and infinite programs. <p> As in the first half of <ref> [23] </ref>, this compilation semantics corresponds to treating -expressions as open procedures, that is, procedures that are expanded like macros. Observe that the CBN standard and compilation semantics are identical (as is the case in [23]). <p> As in the first half of <ref> [23] </ref>, this compilation semantics corresponds to treating -expressions as open procedures, that is, procedures that are expanded like macros. Observe that the CBN standard and compilation semantics are identical (as is the case in [23]). <p> The case of dynamic binding, when the body of f is evaluated, the most recent binding of s (i.e., 5) is stored in [3], rather than the value of s when f was defined (i.e., 10). 5 Compilation of Idealized Algol is the language compiled by Reynolds in <ref> [23] </ref>, and the compiler we derive is essentially identical to Reynolds for the non-recursive fragment. <p> The underlying monad for the compilation semantics for this language must contain all of the intermediate data structure included when the features were compiled in isolation in Section 4: EnvT env (StateT Addr (StateT Sto (StateT CodeStore (State label Id)))) As in <ref> [23] </ref>, expressions are divided into those requiring temporary storage and those that do not. We give each expression two continuations, a "simple" and a "complex" one. <p> Addition is defined analogously, although is more complicated due to the possibility that one or both of its arguments may require storage. While our method for compiling expressions results in similar code to that of Reynolds <ref> [23] </ref>, the use of double continuations is more straightforward, while yielding a fine-grained control of temporary storage. The command "new i in c" creates a new integer variable i which exists only during the execution of c. Its standard semantics is presented in Figure 17. <p> The type of stack locations are non-negative integer pairs &lt; f rame; disp &gt;, which may be thought of as a display address [1], or alternatively, as a stack shape <ref> [23] </ref>. Intuitively, f rame points to an activation record and disp is an offset within that record. Following Reynolds [23], we assume each activation record has a call block where the labels of argument parameters are stored. <p> The type of stack locations are non-negative integer pairs &lt; f rame; disp &gt;, which may be thought of as a display address [1], or alternatively, as a stack shape <ref> [23] </ref>. Intuitively, f rame points to an activation record and disp is an offset within that record. Following Reynolds [23], we assume each activation record has a call block where the labels of argument parameters are stored. Call block entries are denoted [f; e] which points to the e-th argument in the activation pointed to by f .
Reference: [24] <author> J. E. Stoy. </author> <title> Denotational Semantics: the Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: Finally, the compilation of recursive procedures is outlined in Section 5.1. 4.1 Simple Expression Language We first consider the compilation of a simple expression language consisting of integer constants with negation and addition. Its syntax is given in Figure 1 and its standard semantics is given in arithmetic expressions <ref> [24] </ref>. Given an expression like " 1", a compiler would typically generate machine code (assuming 1 Some care must be taken in the order of application of monad transformers. <p> Also, this would result in considerable code duplication, since may be repeated many times. We remedy this situation with a common technique from the denotational semantics <ref> [24] </ref>. The idea is simple: when a command jumps to a label, it invokes the continuation "stored" at that label.
Reference: [25] <author> J. Thatcher, E. Wagner, and J. Wright. </author> <title> More On Advice On Structuring Compilers and Proving Them Correct. </title> <type> Research Report, </type> <institution> Mathematical Sciences Department, IBM Thomas J. Watson Research Center, </institution> <year> 1979. </year>
Reference: [26] <author> P. Wadler. </author> <title> The essence of functional programming. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper addresses the classic problem of generating compilers from denotational specifications of languages. Our tools are mainly classic as well: partial evaluation [9] and pass separation [12]. We add one new tool to this arsenal: monads. These have been used in the past to structure denotational definitions <ref> [16, 6, 26] </ref>, where the allow a mix-and-match (what Espinosa calls "semantic lego" [6]) approach. We argue that similar benefits can be obtained for compilers. Our method of compilation can be summarized as follows: 1. Start with a monad-structured semantics. <p> We then define call-by-value and call-by-name procedures, and dynamic binding, as examples of the kinds of features that can be compiled in this modular fashion. Our final example is the idealized Algol compiled by Reynolds in [23]. 2 Related Work Hudak, Liang, and Jones [16], Espinosa [6], and Wadler <ref> [26] </ref> use monads and monad transformers to create modular, extensible interpreters. This work shows how interpreters can be developed in a modular way, leaving open the question of whether compilers can be developed similarly. <p> Our compiler for that language, presented in Section 5, improves on Reynolds in two ways: it is monad-structured|that is, built from interchangeable parts|and it includes jumps and labels where Reynolds simply allowed code duplication and infinite programs. 3 Monads and Monad Transformers Recent work in semantics <ref> [26, 16, 6] </ref> indicates that the denotational semantics for languages can be constructed modularly using monads and monad transformers as building blocks. When applied to a monad M, a monad transformer T creates a new monad M 0 with some additional features (e.g., states, environments, etc.). <p> In this sense, it is similar to action semantics [20, 19] and high-level semantics [14]. However, monad transformers allow extensions to existing language specifications in a well-understood and canonical manner. For further background on monads and monad transformers, please see <ref> [26, 16, 6] </ref>. 4 Introductory Examples Monadic definitions are not directly amenable to compilation because the structure of a denotational definition and a compiler are quite different. <p> However, it is quite simple to add address allocation and store using the state monad transformer <ref> [16, 26] </ref>. In the parlance of pass separation, the addresses and storage are intermediate data structures. We do not claim that the standard monadic definition in Figure 2 can be used to obtain machine language programs. <p> Figure 19 contains the standard and compilation semantics for letrec and Figure 20 presents an example. 6 Conclusions and Further Work The main contribution of this work is the development a "mix-and-match" compilation method similar to the modular interpreter constructions of <ref> [16, 6, 26] </ref>. Using monads and monad transformers to structure semantics-directed compilers achieves much of the same flexibility and modularity that one associates with monadic interpreters.
Reference: [27] <author> M. Wand. </author> <title> Deriving Target Code as a Representation of Continuation Semantics. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 4, No. 3, </volume> <month> July </month> <year> 1982, </year> <pages> Pages 496-517. </pages>
Reference: [28] <author> M. Wand. </author> <title> Loops in Combinator-based Compilers. </title> <journal> Information and Control, </journal> <volume> 57, </volume> <pages> Pages 148-164 (1983). </pages>
References-found: 28

