URL: ftp://ftp.cs.arizona.edu/xkernel/Papers/customization.ps
Refering-URL: http://www.cs.rice.edu/~druschel/
Root-URL: 
Title: Efficient Support for Incremental Customization of OS Services  
Author: Peter Druschel 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Abstract: This paper argues that efficient, incremental customization of OS services can be achieved using a twofold strategy: an object-oriented architecture that relies on composition to facilitate code reuse and customization; and, an OS structure that places a minimal set of trusted functions into the kernel, with all remaining services collocated with application code in user-level protection domains. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V. Abrossimov, M. Rozier, and M. Shapiro. </author> <title> Generic virtual memory management for operating system kernels. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 123-136, </pages> <address> Litchfield Park AZ (USA), </address> <month> Dec. </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: The second approach makes it possible for applications to replace part of the implementation of an OS service. Examples are the external pager interfaces provided by several micro-kernels <ref> [13, 1] </ref>, which use upcalls to allow applications to implement virtual memory objects. The problem with the first approach is that it is unlikely that a manageable number of fixed implementations can satisfy the needs of all applications.
Reference: [2] <author> T. E. Anderson. </author> <title> The case for application-specific operating systems. </title> <booktitle> In Proc. Third Workshop on Workstation Operating Systems, </booktitle> <address> Key Biscayne, FL (USA), </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: The general idea of moving most of an OS implementation into application run-time libraries to permit application-specific modifications was put forward by Anderson <ref> [2] </ref>.
Reference: [3] <author> T. E. Anderson, B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: This is also supported by recent work that implements the TCP/IP protocol suite in application libraries to achieve better network performance [9, 12]. Work on user-level management of parallelism has separated processor allocation from user-level thread scheduling and synchronization <ref> [3, 10] </ref>. This work is also driven mainly by performance concerns, but results in a decomposition that suits our goals. User-level RPC [4] and fbufs [5] are examples of work that effectively elevate interpro-cess communication services to the application level.
Reference: [4] <author> B. N. Bershad, T. E. Anderson, E. D. Lazowska, and H. M. Levy. </author> <title> User-level interprocess communication for shared memory multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 175-198, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Work on user-level management of parallelism has separated processor allocation from user-level thread scheduling and synchronization [3, 10]. This work is also driven mainly by performance concerns, but results in a decomposition that suits our goals. User-level RPC <ref> [4] </ref> and fbufs [5] are examples of work that effectively elevate interpro-cess communication services to the application level. As a final point, the above works suggest that collocating OS implementation and application code has advantages beyond customization.
Reference: [5] <author> P. Druschel and L. L. Peterson. Fbufs: </author> <title> A high-bandwidth cross-domain transfer facility. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating System Principles, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Work on user-level management of parallelism has separated processor allocation from user-level thread scheduling and synchronization [3, 10]. This work is also driven mainly by performance concerns, but results in a decomposition that suits our goals. User-level RPC [4] and fbufs <ref> [5] </ref> are examples of work that effectively elevate interpro-cess communication services to the application level. As a final point, the above works suggest that collocating OS implementation and application code has advantages beyond customization.
Reference: [6] <author> P. Druschel, L. L. Peterson, and N. C. Hutchin-son. </author> <title> Beyond micro-kernel design: Decoupling modularity and protection in Lipto. </title> <booktitle> In Proc. of the Twelfth Int. Conf. on Distributed Computing Systems, </booktitle> <pages> pages 512-520, </pages> <address> Yokohama, (Japan), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: We are currently exploring this approach in the context of Lipto, a composable, object-oriented operating system <ref> [6] </ref>. 3.1 Composable, Object-Oriented Struc ture The goal of incremental customization implies a system structure where individual software components can be modified or replaced, without requiring an understanding of the system in its entirety. This suggests an object-oriented structure, where the system consists of encapsulated components with well-defined interfaces.
Reference: [7] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Furthermore, there is a variety of previous work by others that|although driven by goals other than customization|has effectively decomposed spe cific OS services in the desired fashion. Our own experience with the x-kernel <ref> [7] </ref> suggests that the network subsystem can be decomposed with good performance, and that large portions can be placed into application domains. This is also supported by recent work that implements the TCP/IP protocol suite in application libraries to achieve better network performance [9, 12].
Reference: [8] <author> G. Kiczales, M. Theimer, and B. Welch. </author> <title> A new model of abstraction for operating system design. </title> <booktitle> In 1992 Int. Workshop on Object Orientation and Operating Systems, </booktitle> <pages> pages 346-350, </pages> <address> Dourdan (France), </address> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: The use of meta-level interfaces in conjunction with object-oriented techniques to support incremental customization originates in the programming language community, and its application to operating systems has been proposed by Kiczales et al. <ref> [8] </ref>. The general idea of moving most of an OS implementation into application run-time libraries to permit application-specific modifications was put forward by Anderson [2].
Reference: [9] <author> C. Maeda and B. Bershad. </author> <title> Protocol service decomposition for high-performance networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Our own experience with the x-kernel [7] suggests that the network subsystem can be decomposed with good performance, and that large portions can be placed into application domains. This is also supported by recent work that implements the TCP/IP protocol suite in application libraries to achieve better network performance <ref> [9, 12] </ref>. Work on user-level management of parallelism has separated processor allocation from user-level thread scheduling and synchronization [3, 10]. This work is also driven mainly by performance concerns, but results in a decomposition that suits our goals.
Reference: [10] <author> B. D. Marsh, M. Scott, T. J. Leblanc, and E. P. Markatos. </author> <title> First-class user-level threads. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 110-121, </pages> <address> Pacific Grove CA (USA), </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: This is also supported by recent work that implements the TCP/IP protocol suite in application libraries to achieve better network performance [9, 12]. Work on user-level management of parallelism has separated processor allocation from user-level thread scheduling and synchronization <ref> [3, 10] </ref>. This work is also driven mainly by performance concerns, but results in a decomposition that suits our goals. User-level RPC [4] and fbufs [5] are examples of work that effectively elevate interpro-cess communication services to the application level.
Reference: [11] <author> R. K. Raj and H. M. Levy. </author> <title> A compositional model for software reuse. </title> <journal> The Computer Journal, </journal> <volume> 32(4) </volume> <pages> 312-322, </pages> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Moreover, implementations of inheritance often violate encapsulation between base class and derived subclass. This is incompatible with the need for protection in an operating system. Instead, we take an approach where composition is used instead of subclass specialization <ref> [11] </ref>. With this approach, objects are composed, or pieced together, to form services. A service implementation can be modified by composing it of a different set of objects. The advantage of this approach is that all objects are properly encapsulated and procedural interfaces are used among all components.
Reference: [12] <author> C. Thekkath, T. Nguyen, E. Moy, and E. La-zowska. </author> <title> Implementing network protocols at user level. </title> <booktitle> In Proceedings of the SIGCOMM '93 Symposium, </booktitle> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: Our own experience with the x-kernel [7] suggests that the network subsystem can be decomposed with good performance, and that large portions can be placed into application domains. This is also supported by recent work that implements the TCP/IP protocol suite in application libraries to achieve better network performance <ref> [9, 12] </ref>. Work on user-level management of parallelism has separated processor allocation from user-level thread scheduling and synchronization [3, 10]. This work is also driven mainly by performance concerns, but results in a decomposition that suits our goals.
Reference: [13] <author> M. Young, A. Tevanian, R. Rashid, D. Golub, J. Eppinger, J. Chew, W. Bolosky, D. Black, and R. Baron. </author> <title> The duality of memory and communication in the implementation of a multiprocessor operating system. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <address> Austin TX (USA), </address> <month> Nov. </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: The second approach makes it possible for applications to replace part of the implementation of an OS service. Examples are the external pager interfaces provided by several micro-kernels <ref> [13, 1] </ref>, which use upcalls to allow applications to implement virtual memory objects. The problem with the first approach is that it is unlikely that a manageable number of fixed implementations can satisfy the needs of all applications.
References-found: 13

