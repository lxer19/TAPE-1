URL: http://www.riaca.win.tue.nl/CAN/SystemsOverview/Special/DiffEqns/symgrp.ps.gz
Refering-URL: http://www.riaca.win.tue.nl/CAN/Systems_and_Packages/Per_Purpose/Special/index.html
Root-URL: http://www.win.tue.nl
Title: The Computer Calculation of Lie Point Symmetries of Large Systems of Differential Equations  
Author: B. Champagne y W. Hereman z P. Winternitz y 
Note: 2 This work was partly supported by AFOSR under Grant No. 85-NM-0263. 3 Ce rapport a ete publie gr^ace a une subvention du fonds FCAR pour l' aide et le soutien a la recherche.  
Date: August 8, 1994  
Address: C.P. 6128, Succursale A Montreal, Quebec, Canada H3C 3J7  Golden, CO 80401, USA  INRS-Telecommunications, Universite du Quebec, 3 Place du Commerce, Verdun, Quebec, Canada H3E 1H6  
Affiliation: Centre de Recherches Mathematiques Universite de Montreal  zDepartment of Mathematical and Computer Sciences Colorado School of Mines  1  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P.J. Olver, </author> <title> Applications of Lie Groups to Differential Equations (Springer Verlag, </title> <address> New York, </address> <year> 1988). </year>
Reference-contexts: The symmetry group thus transforms solutions of the system amongst each other. A large body of old and new literature exists on this topic; here we just refer to some recent books and reviews <ref> [1, 4] </ref>-[19] We also recommend the special issues of Acta Applicandae Mathematicae on 'Symmetries of Partial Differential Equations' [20]. A major obstacle in the application of Lie group theory to solving differential equations is that usually a large number of tedious calculations is involved. <p> The purpose of this article is to present and make available a MACSYMA program for the computer assisted calculation of symmetry groups. The setting is an entirely general one and the method is well known and described e.g. in <ref> [1] </ref>. <p> Note that the subscript g refers to the group parameters. The approach is an infinitesimal one; instead of looking for a Lie group G, we look for its Lie algebra L, realized by vector fields of the form ff = i=1 @ + l=1 @ The procedure <ref> [1] </ref> for finding the coefficients j i (x; u) and ' l (x; u) is described 1 below. <p> All the necessary substitutions and simplifations leading to the new determining system, which are error-prone if done by hand, are carried out automatically and correctly by this program. 2 Procedure for Computing the Determining Equations We closely follow the notations, the terminology and the method for symmetry analysis used in <ref> [1] </ref> which are well adapted to computer programming. Recall that the independent and dependent variables for the system (1) are denoted by (2) and (3), respectively. <p> More explicitly, at the end of the procedure, LODE <ref> [1] </ref> will be a list containing all the coefficients which are monomials; LODE [2] will be a list containing all the coefficients which are polynomials (containing 0 + 0 as the main operator). Note that in the present context, these coefficients will be precisely the determining equations. <p> Note that in the present context, these coefficients will be precisely the determining equations. SIMPEQN (): Given the two lists of determining equations in j i and ' l , LODE <ref> [1] </ref> and LODE [2], this function produces a unique list of determining equations called LODE, equivalent to the union of the first two lists but free of repetition and differential redundancy. More precisely, 9 1. <p> variables q Q Number of dependent variables m M Number of equations in the system x i X [I] Independent variables (I 2 f1; 2; :::; P g) u l U [L] Dependent variables (L 2 f1; 2; :::; Qg) J i J [I] Canonical vectors, e.g., J [2] = <ref> [0; 1; 0; :::; 0] </ref> (j 1 ; j 2 ; :::; j p ) [J [1]; J [2]; :::; J [p]] List of canonical vectors u l J U [L; J ] Derivatives of u l j i ETA [I] Coefficient of @ @x i in the vector field ' <p> i X [I] Independent variables (I 2 f1; 2; :::; P g) u l U [L] Dependent variables (L 2 f1; 2; :::; Qg) J i J [I] Canonical vectors, e.g., J [2] = [0; 1; 0; :::; 0] (j 1 ; j 2 ; :::; j p ) [J <ref> [1] </ref>; J [2]; :::; J [p]] List of canonical vectors u l J U [L; J ] Derivatives of u l j i ETA [I] Coefficient of @ @x i in the vector field ' l PHI [L] Coefficient of @ @u l in the vector field J l PSI [L; <p> We illustrate this in all details for the system (20). For this example the number of independent variables is p = 4, the number of dependent variables is q = 3 and there are clearly m = 3 equations. The correspondences are as follows: x 7! x <ref> [1] </ref>; ae 7! u [1] ; z 7! x [3]; 7! u [3] ; (21) This permits to write the equations (20) in a standard form accepted by the program (see below under "e1" through "e3"). <p> For this example the number of independent variables is p = 4, the number of dependent variables is q = 3 and there are clearly m = 3 equations. The correspondences are as follows: x 7! x <ref> [1] </ref>; ae 7! u [1] ; z 7! x [3]; 7! u [3] ; (21) This permits to write the equations (20) in a standard form accepted by the program (see below under "e1" through "e3"). <p> The 'translation' of the equations (20) is given in the data file KARPMAN-RUN1.DAT below. For example, ae t becomes u <ref> [1; [0; 0; 0; 1] </ref>]; etc. The batch file containing the MACSYMA commands to run SYMMGRP.MAX is called KARPMANRUN1.COM. <p> The 'translation' of the equations (20) is given in the data file KARPMAN-RUN1.DAT below. For example, ae t becomes u [1; <ref> [0; 0; 0; 1] </ref>]; etc. The batch file containing the MACSYMA commands to run SYMMGRP.MAX is called KARPMANRUN1.COM. <p> the first run: p : 4 $ m : 3 $ parameters : [a1,a2,s1,s2,w1,w2] $ warnings : true $ sublisteqs : [e1] $ info given : false $ highest derivatives : 1 $ e1 : u [1,[0,0,0,1]]+w1*u [1,[0,0,1,0]]+(1/2)*(s1*(2*u [1,[1,0,0,0]] +u <ref> [1] </ref>*u [2,[0,2,0,0]])+s2*(2*u [1,[0,0,1,0]]*u [2,[0,0,1,0]] e2 : u [2,[0,0,0,1]]+w1*u [2,[0,0,1,0]]-(1/2)*(s1*(u [1,[2,0,0,0]]/u [1] +s2*(u [1,[0,0,2,0]]/u [1]-u [2,[0,0,1,0]]^2 ))+a1*u [3]; -2*a2*u [1]*(u [1,[2,0,0,0]]+u [1,[0,2,0,0]]+u [1,[0,0,2,0]]) v1 : u [1,[0,0,0,1]]; v3 : u [3,[0,0,0,2]]; All the parameters a1, a2, .... w1, are supposed to be nonzero and may be canceled (as factors) in simplifications. <p> They are saved in KARPMANRUN1.412 and these equations reveal that eta4 only depends on x [4] as listed in Table 4. 'No' stands for 'not dependent on' and the subscript 1 refers to the information obtained from the first run, etc. Table 4 Dependencies for the Karpman Case x <ref> [1] </ref> x [2] x [3] x [4] u [1] u [2] u [3] eta2 no 4 no 4 no 4 no 3 no 3 no 2 eta4 no 1 no 1 no 1 no 4 no 1 no 1 no 1 phi2 no 3 linear 3 no 3 phi3 no 4 <p> Table 4 Dependencies for the Karpman Case x <ref> [1] </ref> x [2] x [3] x [4] u [1] u [2] u [3] eta2 no 4 no 4 no 4 no 3 no 3 no 2 eta4 no 1 no 1 no 1 no 4 no 1 no 1 no 1 phi2 no 3 linear 3 no 3 phi3 no 4 no 4 linear 4 17 For the second <p> We first look for more information on dependencies. Since phi1 and phi2 are independent of u [3] the (longest) equation, i.e., 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u <ref> [1] </ref> @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u [2]. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 <p> We first look for more information on dependencies. Since phi1 and phi2 are independent of u [3] the (longest) equation, i.e., 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u <ref> [1] </ref> @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u [2]. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear <p> Since phi1 and phi2 are independent of u [3] the (longest) equation, i.e., 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u <ref> [1] </ref> @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u [2]. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. <p> 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u <ref> [1] </ref> @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u [2]. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. <p> @ 2 phi2 @ 2 phi2 + s1 u <ref> [1] </ref> @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u [2]. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. <p> We add these three conclusions to Table 4. From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x [3] @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations with 4 terms each, such as @phi2 + u <ref> [1] </ref> @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. <p> [3] @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations with 4 terms each, such as @phi2 + u <ref> [1] </ref> @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 <p> [2] Comparison of three equations with 4 terms each, such as @phi2 + u <ref> [1] </ref> @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u <p> @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x <ref> [1] </ref> @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. <p> @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x <ref> [1] </ref> @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. <p> ) u [2] + f 2 (x <ref> [1] </ref>; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. To save time we shall not solve the rest of the equations for eta1; eta2; eta3 and phi3 but rather submit the above information and carry out the next run. <p> Substitution of (30) into u <ref> [1] </ref> @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. To save time we shall not solve the rest of the equations for eta1; eta2; eta3 and phi3 but rather submit the above information and carry out the next run. <p> Hence, the data file KARPMANRUN4.DAT contains the information from Table 4 and also the lines 19 sublisteqs:[all] $ depends ([f1,f2],[x <ref> [1] </ref>,x [2],x [3],x [4]]); phi1 : f1*u [1]; phi2 : (2*diff (eta1,x [1])-diff (eta4,x [4]))*u [2]+f2; gradef (eta3,x [1],-(s2/s1)*diff (eta1,x [3])); gradef (eta3,x [2],-(s2/s1)*diff (eta2,x [3])); gradef (eta2,x [1],-diff (eta1,x [2])); gradef (eta3,x [3],diff (eta1,x [1])); gradef (eta2,x [2],diff (eta1,x [1])); After 28 min. of CPU time, 30 simple determining equations are obtained (see 'Test Run Output'). <p> contains the information from Table 4 and also the lines 19 sublisteqs:[all] $ depends ([f1,f2],[x <ref> [1] </ref>,x [2],x [3],x [4]]); phi1 : f1*u [1]; phi2 : (2*diff (eta1,x [1])-diff (eta4,x [4]))*u [2]+f2; gradef (eta3,x [1],-(s2/s1)*diff (eta1,x [3])); gradef (eta3,x [2],-(s2/s1)*diff (eta2,x [3])); gradef (eta2,x [1],-diff (eta1,x [2])); gradef (eta3,x [3],diff (eta1,x [1])); gradef (eta2,x [2],diff (eta1,x [1])); After 28 min. of CPU time, 30 simple determining equations are obtained (see 'Test Run Output'). The simplifications described in the outline of the program actually reduced 249 determining equations to 30 this time. <p> 4 and also the lines 19 sublisteqs:[all] $ depends ([f1,f2],[x <ref> [1] </ref>,x [2],x [3],x [4]]); phi1 : f1*u [1]; phi2 : (2*diff (eta1,x [1])-diff (eta4,x [4]))*u [2]+f2; gradef (eta3,x [1],-(s2/s1)*diff (eta1,x [3])); gradef (eta3,x [2],-(s2/s1)*diff (eta2,x [3])); gradef (eta2,x [1],-diff (eta1,x [2])); gradef (eta3,x [3],diff (eta1,x [1])); gradef (eta2,x [2],diff (eta1,x [1])); After 28 min. of CPU time, 30 simple determining equations are obtained (see 'Test Run Output'). The simplifications described in the outline of the program actually reduced 249 determining equations to 30 this time. <p> A quick inspection of the remaining equations in 'Test Run Output' allows to conclude that f 1 = k6 is constant. Hence, with (32) we get phi1 = k6 u <ref> [1] </ref>: (33) Similarly, (30) simplifies into phi2 = f 2 (x [4]): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u [3] + f 4 (x [1]; x [2]; x [3]; x [4]): (35) We also find that eta1 is linear in x <p> Hence, with (32) we get phi1 = k6 u <ref> [1] </ref>: (33) Similarly, (30) simplifies into phi2 = f 2 (x [4]): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u [3] + f 4 (x [1]; x [2]; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where k1 and k2 are constants. The equations (25)-(27) and (29) then determine eta2 = k1 x [1] + k3; (37) eta4 = k5: <p> u [3] + f 4 (x <ref> [1] </ref>; x [2]; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where k1 and k2 are constants. The equations (25)-(27) and (29) then determine eta2 = k1 x [1] + k3; (37) eta4 = k5: (39) We again modify the previous data file, to account for the info in Table 4, the forms of the eta's and phi's and the dependencies of f 2 and f 4: 20 depends (f2,x [4]); depends (f4,[x [1],x [2],x [3],x [4]]); eta1 : <p> again modify the previous data file, to account for the info in Table 4, the forms of the eta's and phi's and the dependencies of f 2 and f 4: 20 depends (f2,x [4]); depends (f4,[x <ref> [1] </ref>,x [2],x [3],x [4]]); eta1 : k1*x [2]+k2; eta3 : k4; phi1 : k6*u [1]; phi3 : 2*k6*u [3]+f4; and with this file KARPMANRUN5.DAT we start the last run. <p> @x [2] 2 + w2 2 @ 2 f 4 @ 2 f 4 The first one requires that k6 = 0, hence, phi1 = 0; and also @f 2 = a1 f 4: (42) Since f 2 depends only on x [4], f 4 must be independent of x <ref> [1] </ref>; x [2] and x [3]. As a consequence of (41), f 4 is linear in x [4] and with (42) the final solution is known: f 2 = a1 k7 x [4] + a1 k8 x [4] + k9; (43) where k7; k8 and k9 are free constants.
Reference: [2] <author> MACSYMA Reference Manual, </author> <type> Version 13, </type> <institution> Computer Aided Mathematics Group (Symbolics, Burlington, </institution> <address> MA, </address> <year> 1989). </year>
Reference-contexts: REX MAC-SYMA 305 and MACSYMA 309.6 (running under UNIX). The user is supposed to have minimal experience with MACSYMA. Information about the syntax of MACSYMA and many examples of its use may be found in <ref> [2, 3] </ref>. The program SYMMGRP.MAX for which the source code is given further, consists essentially of function definitions. In fact, an appropriate function is defined for each major task in the process. <p> More explicitly, at the end of the procedure, LODE [1] will be a list containing all the coefficients which are monomials; LODE <ref> [2] </ref> will be a list containing all the coefficients which are polynomials (containing 0 + 0 as the main operator). Note that in the present context, these coefficients will be precisely the determining equations. <p> Note that in the present context, these coefficients will be precisely the determining equations. SIMPEQN (): Given the two lists of determining equations in j i and ' l , LODE [1] and LODE <ref> [2] </ref>, this function produces a unique list of determining equations called LODE, equivalent to the union of the first two lists but free of repetition and differential redundancy. More precisely, 9 1. <p> of independent variables q Q Number of dependent variables m M Number of equations in the system x i X [I] Independent variables (I 2 f1; 2; :::; P g) u l U [L] Dependent variables (L 2 f1; 2; :::; Qg) J i J [I] Canonical vectors, e.g., J <ref> [2] </ref> = [0; 1; 0; :::; 0] (j 1 ; j 2 ; :::; j p ) [J [1]; J [2]; :::; J [p]] List of canonical vectors u l J U [L; J ] Derivatives of u l j i ETA [I] Coefficient of @ @x i in the vector <p> [I] Independent variables (I 2 f1; 2; :::; P g) u l U [L] Dependent variables (L 2 f1; 2; :::; Qg) J i J [I] Canonical vectors, e.g., J <ref> [2] </ref> = [0; 1; 0; :::; 0] (j 1 ; j 2 ; :::; j p ) [J [1]; J [2]; :::; J [p]] List of canonical vectors u l J U [L; J ] Derivatives of u l j i ETA [I] Coefficient of @ @x i in the vector field ' l PHI [L] Coefficient of @ @u l in the vector field J l PSI [L; J ] <p> Furthermore, Greek letters should be avoided (for instance 'beta' refers to the Beta function and 'gamma' to the Gamma function). Before using any special character quickly check the index of <ref> [2, 3] </ref> to verify if the name or symbol does not interfere with a function or command name in MACSYMA. <p> Table 4 Dependencies for the Karpman Case x [1] x <ref> [2] </ref> x [3] x [4] u [1] u [2] u [3] eta2 no 4 no 4 no 4 no 3 no 3 no 2 eta4 no 1 no 1 no 1 no 4 no 1 no 1 no 1 phi2 no 3 linear 3 no 3 phi3 no 4 no 4 <p> Table 4 Dependencies for the Karpman Case x [1] x <ref> [2] </ref> x [3] x [4] u [1] u [2] u [3] eta2 no 4 no 4 no 4 no 3 no 3 no 2 eta4 no 1 no 1 no 1 no 4 no 1 no 1 no 1 phi2 no 3 linear 3 no 3 phi3 no 4 no 4 linear 4 17 For the second run, we <p> Since phi1 and phi2 are independent of u [3] the (longest) equation, i.e., 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u [1] @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u <ref> [2] </ref>. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. <p> are independent of u [3] the (longest) equation, i.e., 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u [1] @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u <ref> [2] </ref>. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. <p> phi2 @ 2 phi2 + s1 u [1] @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u <ref> [2] </ref>. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x [3] @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations <p> + s1 u [1] @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u <ref> [2] </ref>. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x [3] @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations with 4 terms each, <p> 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u <ref> [2] </ref>. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x [3] @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u <p> Next, u [1] @u <ref> [2] </ref> 2 + @u [2] gives that phi2 is linear in u [2]. We add these three conclusions to Table 4. From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x [3] @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; <p> From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x [3] @eta3 = s2 @x [3] @eta2 = @x <ref> [2] </ref> Comparison of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. <p> three remaining equations (with only two terms) we learn that @eta3 = s2 @x [3] @eta3 = s2 @x [3] @eta2 = @x <ref> [2] </ref> Comparison of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u <p> @x [3] @eta2 = @x <ref> [2] </ref> Comparison of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; <p> of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u <ref> [2] </ref> @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) <p> leads to @eta3 = @x <ref> [2] </ref> @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. <p> <ref> [2] </ref> + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. To save time we shall not solve the rest of the equations for eta1; eta2; eta3 and phi3 but rather submit the above information and carry out the next run. <p> Hence, the data file KARPMANRUN4.DAT contains the information from Table 4 and also the lines 19 sublisteqs:[all] $ depends ([f1,f2],[x [1],x <ref> [2] </ref>,x [3],x [4]]); phi1 : f1*u [1]; phi2 : (2*diff (eta1,x [1])-diff (eta4,x [4]))*u [2]+f2; gradef (eta3,x [1],-(s2/s1)*diff (eta1,x [3])); gradef (eta3,x [2],-(s2/s1)*diff (eta2,x [3])); gradef (eta2,x [1],-diff (eta1,x [2])); gradef (eta3,x [3],diff (eta1,x [1])); gradef (eta2,x [2],diff (eta1,x [1])); After 28 min. of CPU time, 30 simple determining equations are obtained (see 'Test Run Output'). The simplifications described in the outline of the program actually reduced 249 determining equations to 30 this time. <p> Hence, with (32) we get phi1 = k6 u [1]: (33) Similarly, (30) simplifies into phi2 = f 2 (x [4]): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u [3] + f 4 (x [1]; x <ref> [2] </ref>; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where k1 and k2 are constants. <p> (33) Similarly, (30) simplifies into phi2 = f 2 (x [4]): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u [3] + f 4 (x [1]; x <ref> [2] </ref>; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where k1 and k2 are constants. <p> = f 2 (x [4]): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u [3] + f 4 (x [1]; x <ref> [2] </ref>; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where k1 and k2 are constants. <p> <ref> [2] </ref>+k2; eta3 : k4; phi1 : k6*u [1]; phi3 : 2*k6*u [3]+f4; and with this file KARPMANRUN5.DAT we start the last run. Only 2 deter mining equations are left in KARPMANRUN5.412: 2 u [3] a1 k6 + a1 f 4 + @x [4] w2 2 @ 2 f 4 @x [2] 2 + w2 2 @ 2 f 4 @ 2 f 4 The first one requires that k6 = 0, hence, phi1 = 0; and also @f 2 = a1 f 4: (42) Since f 2 depends only on x [4], f 4 must be independent of x [1]; x <p> 2 + w2 2 @ 2 f 4 @ 2 f 4 The first one requires that k6 = 0, hence, phi1 = 0; and also @f 2 = a1 f 4: (42) Since f 2 depends only on x [4], f 4 must be independent of x [1]; x <ref> [2] </ref> and x [3]. As a consequence of (41), f 4 is linear in x [4] and with (42) the final solution is known: f 2 = a1 k7 x [4] + a1 k8 x [4] + k9; (43) where k7; k8 and k9 are free constants.
Reference: [3] <institution> MACSYMA User's Guide, Computer Aided Mathematics Group (Sym-bolics, Burlington, </institution> <address> MA, </address> <year> 1988). </year>
Reference-contexts: REX MAC-SYMA 305 and MACSYMA 309.6 (running under UNIX). The user is supposed to have minimal experience with MACSYMA. Information about the syntax of MACSYMA and many examples of its use may be found in <ref> [2, 3] </ref>. The program SYMMGRP.MAX for which the source code is given further, consists essentially of function definitions. In fact, an appropriate function is defined for each major task in the process. <p> Furthermore, Greek letters should be avoided (for instance 'beta' refers to the Beta function and 'gamma' to the Gamma function). Before using any special character quickly check the index of <ref> [2, 3] </ref> to verify if the name or symbol does not interfere with a function or command name in MACSYMA. <p> For this example the number of independent variables is p = 4, the number of dependent variables is q = 3 and there are clearly m = 3 equations. The correspondences are as follows: x 7! x [1]; ae 7! u [1] ; z 7! x <ref> [3] </ref>; 7! u [3] ; (21) This permits to write the equations (20) in a standard form accepted by the program (see below under "e1" through "e3"). <p> For this example the number of independent variables is p = 4, the number of dependent variables is q = 3 and there are clearly m = 3 equations. The correspondences are as follows: x 7! x [1]; ae 7! u [1] ; z 7! x <ref> [3] </ref>; 7! u [3] ; (21) This permits to write the equations (20) in a standard form accepted by the program (see below under "e1" through "e3"). <p> $ m : 3 $ parameters : [a1,a2,s1,s2,w1,w2] $ warnings : true $ sublisteqs : [e1] $ info given : false $ highest derivatives : 1 $ e1 : u [1,[0,0,0,1]]+w1*u [1,[0,0,1,0]]+(1/2)*(s1*(2*u [1,[1,0,0,0]] +u [1]*u [2,[0,2,0,0]])+s2*(2*u [1,[0,0,1,0]]*u [2,[0,0,1,0]] e2 : u [2,[0,0,0,1]]+w1*u [2,[0,0,1,0]]-(1/2)*(s1*(u [1,[2,0,0,0]]/u [1] +s2*(u [1,[0,0,2,0]]/u [1]-u [2,[0,0,1,0]]^2 ))+a1*u <ref> [3] </ref>; -2*a2*u [1]*(u [1,[2,0,0,0]]+u [1,[0,2,0,0]]+u [1,[0,0,2,0]]) v1 : u [1,[0,0,0,1]]; v3 : u [3,[0,0,0,2]]; All the parameters a1, a2, .... w1, are supposed to be nonzero and may be canceled (as factors) in simplifications. <p> Table 4 Dependencies for the Karpman Case x [1] x [2] x <ref> [3] </ref> x [4] u [1] u [2] u [3] eta2 no 4 no 4 no 4 no 3 no 3 no 2 eta4 no 1 no 1 no 1 no 4 no 1 no 1 no 1 phi2 no 3 linear 3 no 3 phi3 no 4 no 4 linear 4 <p> Table 4 Dependencies for the Karpman Case x [1] x [2] x <ref> [3] </ref> x [4] u [1] u [2] u [3] eta2 no 4 no 4 no 4 no 3 no 3 no 2 eta4 no 1 no 1 no 1 no 4 no 1 no 1 no 1 phi2 no 3 linear 3 no 3 phi3 no 4 no 4 linear 4 17 For the second run, we provide the <p> We modify a few lines in the data file: sublisteqs : [e2,e3] $ info given : true $ depends ([eta1,eta2,eta3,phi1,phi2,phi3],[x [1],x [2],x <ref> [3] </ref>,x [4],u [1],u [2],u [3]]); depends (eta4,x [4]); All the remaining lines are the same and we save the updated file as KARP-MANRUN2.DAT. We run the program again with a batch file similar to the one used for the first run. <p> So they usually do not require any solution techniques beyond a straightforward separation of variables, occasionally a simple integration, at worst an application of the method of the characteristics. We first look for more information on dependencies. Since phi1 and phi2 are independent of u <ref> [3] </ref> the (longest) equation, i.e., 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u [1] @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u [2]. <p> We first look for more information on dependencies. Since phi1 and phi2 are independent of u <ref> [3] </ref> the (longest) equation, i.e., 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u [1] @x [1] 2 + 2 @x [4] @phi1 = 0; (22) implies that phi1 is also independent of u [2]. <p> We add these three conclusions to Table 4. From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x <ref> [3] </ref> @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] <p> We add these three conclusions to Table 4. From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x <ref> [3] </ref> @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + <p> From the three remaining equations (with only two terms) we learn that @eta3 = s2 @x <ref> [3] </ref> @eta3 = s2 @x [3] @eta2 = @x [2] Comparison of three equations with 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. <p> equations with 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x <ref> [3] </ref> leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f <p> f 2 (x [1]; x [2]; x <ref> [3] </ref>; x [4]); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. To save time we shall not solve the rest of the equations for eta1; eta2; eta3 and phi3 but rather submit the above information and carry out the next run. <p> Hence, the data file KARPMANRUN4.DAT contains the information from Table 4 and also the lines 19 sublisteqs:[all] $ depends ([f1,f2],[x [1],x [2],x <ref> [3] </ref>,x [4]]); phi1 : f1*u [1]; phi2 : (2*diff (eta1,x [1])-diff (eta4,x [4]))*u [2]+f2; gradef (eta3,x [1],-(s2/s1)*diff (eta1,x [3])); gradef (eta3,x [2],-(s2/s1)*diff (eta2,x [3])); gradef (eta2,x [1],-diff (eta1,x [2])); gradef (eta3,x [3],diff (eta1,x [1])); gradef (eta2,x [2],diff (eta1,x [1])); After 28 min. of CPU time, 30 simple determining equations are obtained (see 'Test Run Output'). <p> Hence, the data file KARPMANRUN4.DAT contains the information from Table 4 and also the lines 19 sublisteqs:[all] $ depends ([f1,f2],[x [1],x [2],x <ref> [3] </ref>,x [4]]); phi1 : f1*u [1]; phi2 : (2*diff (eta1,x [1])-diff (eta4,x [4]))*u [2]+f2; gradef (eta3,x [1],-(s2/s1)*diff (eta1,x [3])); gradef (eta3,x [2],-(s2/s1)*diff (eta2,x [3])); gradef (eta2,x [1],-diff (eta1,x [2])); gradef (eta3,x [3],diff (eta1,x [1])); gradef (eta2,x [2],diff (eta1,x [1])); After 28 min. of CPU time, 30 simple determining equations are obtained (see 'Test Run Output'). The simplifications described in the outline of the program actually reduced 249 determining equations to 30 this time. <p> Hence, with (32) we get phi1 = k6 u [1]: (33) Similarly, (30) simplifies into phi2 = f 2 (x [4]): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u <ref> [3] </ref> + f 4 (x [1]; x [2]; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where k1 and k2 are constants. <p> Hence, with (32) we get phi1 = k6 u [1]: (33) Similarly, (30) simplifies into phi2 = f 2 (x [4]): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u <ref> [3] </ref> + f 4 (x [1]; x [2]; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where k1 and k2 are constants. <p> 2 and f 4: 20 depends (f2,x [4]); depends (f4,[x [1],x [2],x <ref> [3] </ref>,x [4]]); eta1 : k1*x [2]+k2; eta3 : k4; phi1 : k6*u [1]; phi3 : 2*k6*u [3]+f4; and with this file KARPMANRUN5.DAT we start the last run. Only 2 deter mining equations are left in KARPMANRUN5.412: 2 u [3] a1 k6 + a1 f 4 + @x [4] w2 2 @ 2 f 4 @x [2] 2 + w2 2 @ 2 f 4 @ 2 f 4 The first one requires that k6 = 0, hence, phi1 = 0; and also @f 2 = a1 f 4: (42) <p> 2 @ 2 f 4 @ 2 f 4 The first one requires that k6 = 0, hence, phi1 = 0; and also @f 2 = a1 f 4: (42) Since f 2 depends only on x [4], f 4 must be independent of x [1]; x [2] and x <ref> [3] </ref>. As a consequence of (41), f 4 is linear in x [4] and with (42) the final solution is known: f 2 = a1 k7 x [4] + a1 k8 x [4] + k9; (43) where k7; k8 and k9 are free constants.
Reference: [4] <author> W.F. Ames, </author> <title> Nonlinear Partial Differential Equations in Engineering (Academic Press, </title> <address> New York, </address> <year> 1972). </year>
Reference-contexts: The symmetry group thus transforms solutions of the system amongst each other. A large body of old and new literature exists on this topic; here we just refer to some recent books and reviews <ref> [1, 4] </ref>-[19] We also recommend the special issues of Acta Applicandae Mathematicae on 'Symmetries of Partial Differential Equations' [20]. A major obstacle in the application of Lie group theory to solving differential equations is that usually a large number of tedious calculations is involved. <p> The simplifications implemented in the program reduce the number of determining equations from 20 to 6 single term equations. They are saved in KARPMANRUN1.412 and these equations reveal that eta4 only depends on x <ref> [4] </ref> as listed in Table 4. 'No' stands for 'not dependent on' and the subscript 1 refers to the information obtained from the first run, etc. Table 4 Dependencies for the Karpman Case x [1] x [2] x [3] x [4] u [1] u [2] u [3] eta2 no 4 no <p> and these equations reveal that eta4 only depends on x <ref> [4] </ref> as listed in Table 4. 'No' stands for 'not dependent on' and the subscript 1 refers to the information obtained from the first run, etc. Table 4 Dependencies for the Karpman Case x [1] x [2] x [3] x [4] u [1] u [2] u [3] eta2 no 4 no 4 no 4 no 3 no 3 no 2 eta4 no 1 no 1 no 1 no 4 no 1 no 1 no 1 phi2 no 3 linear 3 no 3 phi3 no 4 no 4 linear 4 17 For <p> We modify a few lines in the data file: sublisteqs : [e2,e3] $ info given : true $ depends ([eta1,eta2,eta3,phi1,phi2,phi3],[x [1],x [2],x [3],x <ref> [4] </ref>,u [1],u [2],u [3]]); depends (eta4,x [4]); All the remaining lines are the same and we save the updated file as KARP-MANRUN2.DAT. We run the program again with a batch file similar to the one used for the first run. <p> We first look for more information on dependencies. Since phi1 and phi2 are independent of u [3] the (longest) equation, i.e., 2 w1 @x [3] @ 2 phi2 @ 2 phi2 + s1 u [1] @x [1] 2 + 2 @x <ref> [4] </ref> @phi1 = 0; (22) implies that phi1 is also independent of u [2]. With u [1] 2 @phi2 + @u [2] we have that phi2 is independent of u [1]. 18 Next, u [1] @u [2] 2 + @u [2] gives that phi2 is linear in u [2]. <p> 4 terms each, such as @phi2 + u [1] @u [1]@u [2] @eta4 2 @x [3] leads to @eta3 = @x [2] @eta1 : (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x <ref> [4] </ref>); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will <p> (29) Upon integration of (28) we get phi2 = (2 @x [1] @eta4 ) u [2] + f 2 (x [1]; x [2]; x [3]; x <ref> [4] </ref>); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. <p> (x [1]; x [2]; x [3]; x <ref> [4] </ref>); (30) where f 2 will be determined later. Substitution of (30) into u [1] @u [2] @phi1 + phi1 + u [1] @x [4] @eta1 = 0 (31) and integration yields phi1 = f 1 (x [1]; x [2]; x [3]; x [4]) u [1]; (32) where f 1 will be determined later. To save time we shall not solve the rest of the equations for eta1; eta2; eta3 and phi3 but rather submit the above information and carry out the next run. <p> Hence, the data file KARPMANRUN4.DAT contains the information from Table 4 and also the lines 19 sublisteqs:[all] $ depends ([f1,f2],[x [1],x [2],x [3],x <ref> [4] </ref>]); phi1 : f1*u [1]; phi2 : (2*diff (eta1,x [1])-diff (eta4,x [4]))*u [2]+f2; gradef (eta3,x [1],-(s2/s1)*diff (eta1,x [3])); gradef (eta3,x [2],-(s2/s1)*diff (eta2,x [3])); gradef (eta2,x [1],-diff (eta1,x [2])); gradef (eta3,x [3],diff (eta1,x [1])); gradef (eta2,x [2],diff (eta1,x [1])); After 28 min. of CPU time, 30 simple determining equations are obtained (see <p> A quick inspection of the remaining equations in 'Test Run Output' allows to conclude that f 1 = k6 is constant. Hence, with (32) we get phi1 = k6 u [1]: (33) Similarly, (30) simplifies into phi2 = f 2 (x <ref> [4] </ref>): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u [3] + f 4 (x [1]; x [2]; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where <p> Hence, with (32) we get phi1 = k6 u [1]: (33) Similarly, (30) simplifies into phi2 = f 2 (x <ref> [4] </ref>): (34) Further, we obtain phi3 up to an unknown function f 4, phi3 = 2 k6 u [3] + f 4 (x [1]; x [2]; x [3]; x [4]): (35) We also find that eta1 is linear in x [2], i.e., eta1 = k1 x [2] + k2; (36) where k1 and k2 are constants. <p> and (29) then determine eta2 = k1 x [1] + k3; (37) eta4 = k5: (39) We again modify the previous data file, to account for the info in Table 4, the forms of the eta's and phi's and the dependencies of f 2 and f 4: 20 depends (f2,x <ref> [4] </ref>); depends (f4,[x [1],x [2],x [3],x [4]]); eta1 : k1*x [2]+k2; eta3 : k4; phi1 : k6*u [1]; phi3 : 2*k6*u [3]+f4; and with this file KARPMANRUN5.DAT we start the last run. <p> k1 x [1] + k3; (37) eta4 = k5: (39) We again modify the previous data file, to account for the info in Table 4, the forms of the eta's and phi's and the dependencies of f 2 and f 4: 20 depends (f2,x <ref> [4] </ref>); depends (f4,[x [1],x [2],x [3],x [4]]); eta1 : k1*x [2]+k2; eta3 : k4; phi1 : k6*u [1]; phi3 : 2*k6*u [3]+f4; and with this file KARPMANRUN5.DAT we start the last run. Only 2 deter mining equations are left in KARPMANRUN5.412: 2 u [3] a1 k6 + a1 f 4 + @x [4] w2 2 @ 2 <p> (f4,[x [1],x [2],x [3],x <ref> [4] </ref>]); eta1 : k1*x [2]+k2; eta3 : k4; phi1 : k6*u [1]; phi3 : 2*k6*u [3]+f4; and with this file KARPMANRUN5.DAT we start the last run. Only 2 deter mining equations are left in KARPMANRUN5.412: 2 u [3] a1 k6 + a1 f 4 + @x [4] w2 2 @ 2 f 4 @x [2] 2 + w2 2 @ 2 f 4 @ 2 f 4 The first one requires that k6 = 0, hence, phi1 = 0; and also @f 2 = a1 f 4: (42) Since f 2 depends only on x [4], f <p> @x <ref> [4] </ref> w2 2 @ 2 f 4 @x [2] 2 + w2 2 @ 2 f 4 @ 2 f 4 The first one requires that k6 = 0, hence, phi1 = 0; and also @f 2 = a1 f 4: (42) Since f 2 depends only on x [4], f 4 must be independent of x [1]; x [2] and x [3]. As a consequence of (41), f 4 is linear in x [4] and with (42) the final solution is known: f 2 = a1 k7 x [4] + a1 k8 x [4] + k9; (43) where k7; <p> requires that k6 = 0, hence, phi1 = 0; and also @f 2 = a1 f 4: (42) Since f 2 depends only on x <ref> [4] </ref>, f 4 must be independent of x [1]; x [2] and x [3]. As a consequence of (41), f 4 is linear in x [4] and with (42) the final solution is known: f 2 = a1 k7 x [4] + a1 k8 x [4] + k9; (43) where k7; k8 and k9 are free constants. These functions determine the final form of phi2 and phi3 in (34) and (35). <p> f 4: (42) Since f 2 depends only on x <ref> [4] </ref>, f 4 must be independent of x [1]; x [2] and x [3]. As a consequence of (41), f 4 is linear in x [4] and with (42) the final solution is known: f 2 = a1 k7 x [4] + a1 k8 x [4] + k9; (43) where k7; k8 and k9 are free constants. These functions determine the final form of phi2 and phi3 in (34) and (35). One could submit these data for verification. We have done so and no determining equations were left, as expected. <p> 2 depends only on x <ref> [4] </ref>, f 4 must be independent of x [1]; x [2] and x [3]. As a consequence of (41), f 4 is linear in x [4] and with (42) the final solution is known: f 2 = a1 k7 x [4] + a1 k8 x [4] + k9; (43) where k7; k8 and k9 are free constants. These functions determine the final form of phi2 and phi3 in (34) and (35). One could submit these data for verification. We have done so and no determining equations were left, as expected.
Reference: [5] <author> G.W. Bluman and J.D. Cole, </author> <title> Similarity Methods for Differential Equations (Springer, </title> <address> New York, </address> <year> 1974). </year>
Reference: [6] <author> W. Miller, </author> <title> Symmetry and Separation of Variables (Reading, </title> <address> MA, </address> <year> 1977). </year>
Reference: [7] <author> R.L. Anderson and N.H. Ibragimov, </author> <title> Lie-Backlund Transformations in Applications, </title> <booktitle> Studies in Applied Mathematics 1 (SIAM, </booktitle> <address> Philadelphia, </address> <year> 1979). </year>
Reference-contexts: The development of a MACSYMA program that solves the determining equations in part is planned for the future. Upon modification of the algorithm, the program can be extended to the computation of more general Lie-Backlund transformation groups <ref> [7] </ref>. Notes added in Proof * One new parameter must be added to the input data as described in subsection 3.3 of this paper. The parameter subst deriv of vi: true, controls the substitution of the partial derivatives of the v i in the equation (12).
Reference: [8] <author> L.V. Ovsiannikov, </author> <title> Group Analysis of Differential Equations (Academic Press, </title> <address> New York, </address> <year> 1982). </year>
Reference: [9] <author> P. Winternitz, </author> <title> in: K.B. Wolf, Nonlinear Phenomena, </title> <publisher> Lecture Notes in Physics 189 (Springer Verlag, </publisher> <address> New York, 1983) p. </address> <month> 263. </month>
Reference: [10] <author> N.H. Ibragimov, </author> <title> Transformation Groups Applied to Mathematical Physics (Reidel, </title> <address> Boston, </address> <year> 1985). </year>
Reference: [11] <author> E.G. Kalnins, </author> <title> Separation of Variables for Riemannian Spaces of Constant Curvature (Longman, </title> <publisher> Essex, </publisher> <year> 1986). </year>
Reference: [12] <author> D.H. Sattinger and O.L. Weaver, </author> <title> Lie Groups and Algebras with Applications to Physics, Geometry, </title> <publisher> and Mechanics (Springer Verlag, </publisher> <address> New York, </address> <year> 1986). </year>
Reference: [13] <author> V.I. Fushchich and A.G. Nikitin, </author> <title> Symmetries of Maxwell Equations (Reidel, </title> <address> Dordrecht, </address> <year> 1987). </year>
Reference: [14] <editor> D. Levi and P. Winternitz, Eds., </editor> <title> Symmetries and Nonlinear Phenomena (World Scientific, </title> <address> Singapore, </address> <year> 1988). </year> <month> 25 </month>
Reference: [15] <author> F. Schwarz, </author> <note> SIAM Review 30 (1988) 450. </note>
Reference-contexts: These are the so-called determining equations for the symmetries of the system. The procedure thus consists of two major steps: deriving the determining equations and solving them. 1.2 Review of symbolic programs Several computer packages <ref> [15, 21] </ref>-[47] exist for this purpose, and some other programs were written for specific examples [48]. The well-documented REDUCE program developed by F. Schwarz [15, 21]- [25], is definitely going the furthest in solving the determining equations with minimal intervention by the user. <p> The procedure thus consists of two major steps: deriving the determining equations and solving them. 1.2 Review of symbolic programs Several computer packages <ref> [15, 21] </ref>-[47] exist for this purpose, and some other programs were written for specific examples [48]. The well-documented REDUCE program developed by F. Schwarz [15, 21]- [25], is definitely going the furthest in solving the determining equations with minimal intervention by the user. This program, called SPDE, is distributed with version 3.3 of REDUCE for various types of computers, ranging from PCs to CRAYs. <p> Schwarz [15, 21]- [25], is definitely going the furthest in solving the determining equations with minimal intervention by the user. This program, called SPDE, is distributed with version 3.3 of REDUCE for various types of computers, ranging from PCs to CRAYs. Schwarz also rewrote SPDE <ref> [15, 25] </ref> for use with SCRATCHPAD II, a symbolic manipulation program developed by IBM. Based on Cartan's exterior calculus, Edelen [26] and Gragert and Kersten [27] did some pioneering work in using REDUCE to calculate the classical Lie symmetries of differential equations.
Reference: [16] <author> G.W. Bluman and S. Kumei, </author> <title> Symmetries and Differential Equations (Springer Verlag, </title> <address> New York, </address> <year> 1989). </year>
Reference: [17] <author> C. Rogers and W.F. Ames, </author> <title> Nonlinear Boundary Value Problems in Science and Engineering (Academic Press, </title> <address> New York, </address> <year> 1989). </year>
Reference: [18] <author> H. Stephani, </author> <title> Differential Equations: Their Solution using Symmetries (Cambridge University Press, </title> <address> Cambridge, </address> <year> 1989). </year>
Reference: [19] <editor> P. Winternitz, in: R. Conte and N. Boccara, </editor> <title> Partially Integrable Nonlinear Evolution Equations and their Physical Applications (Kluwer, </title> <journal> Dor-drecht, </journal> <note> 1990) p. 515 </note>
Reference: [20] <editor> A.M. Vinogradov, Ed., </editor> <title> Symmetries of Partial Differential Equations, Part I, </title> <journal> Acta Appl. Math. </journal> <volume> 15, nos. 1 & 2 (1989); Part II, ibid. 16, no. </volume> <booktitle> 1 (1989); Part III, ibid., </booktitle> <volume> 16, no. </volume> <month> 2 </month> <year> (1989). </year>
Reference-contexts: A large body of old and new literature exists on this topic; here we just refer to some recent books and reviews [1, 4]-[19] We also recommend the special issues of Acta Applicandae Mathematicae on 'Symmetries of Partial Differential Equations' <ref> [20] </ref>. A major obstacle in the application of Lie group theory to solving differential equations is that usually a large number of tedious calculations is involved. The purpose of this article is to present and make available a MACSYMA program for the computer assisted calculation of symmetry groups.
Reference: [21] <author> F. </author> <title> Schwarz, </title> <journal> Comput. Phys. Comm. </journal> <volume> 27 (1982) 179. </volume>
Reference-contexts: These are the so-called determining equations for the symmetries of the system. The procedure thus consists of two major steps: deriving the determining equations and solving them. 1.2 Review of symbolic programs Several computer packages <ref> [15, 21] </ref>-[47] exist for this purpose, and some other programs were written for specific examples [48]. The well-documented REDUCE program developed by F. Schwarz [15, 21]- [25], is definitely going the furthest in solving the determining equations with minimal intervention by the user. <p> The procedure thus consists of two major steps: deriving the determining equations and solving them. 1.2 Review of symbolic programs Several computer packages <ref> [15, 21] </ref>-[47] exist for this purpose, and some other programs were written for specific examples [48]. The well-documented REDUCE program developed by F. Schwarz [15, 21]- [25], is definitely going the furthest in solving the determining equations with minimal intervention by the user. This program, called SPDE, is distributed with version 3.3 of REDUCE for various types of computers, ranging from PCs to CRAYs.
Reference: [22] <author> F. Schwarz, </author> <note> Computing 34 (1985) 91; Addendum: Computing 36 (1986) 279. </note>
Reference: [23] <author> F. </author> <title> Schwarz, </title> <journal> Comput. Phys. Comm. </journal> <volume> 39 (1986) 285. </volume>
Reference: [24] <author> F. </author> <title> Schwarz The Package SPDE for Determining Symmetries of Partial Differential Equations. User's Manual. Distributed with REDUCE 3.3 (Rand Corporation, </title> <address> Santa Monica, CA, </address> <year> 1987). </year>
Reference: [25] <editor> F. Schwarz, in: R. JanBen, </editor> <booktitle> Trends in Computer Algebra, Lecture Notes in Comput. </booktitle> <publisher> Sci. 296 (Springer Verlag, </publisher> <address> New York, 1988) p. </address> <month> 167. </month>
Reference-contexts: The procedure thus consists of two major steps: deriving the determining equations and solving them. 1.2 Review of symbolic programs Several computer packages [15, 21]-[47] exist for this purpose, and some other programs were written for specific examples [48]. The well-documented REDUCE program developed by F. Schwarz [15, 21]- <ref> [25] </ref>, is definitely going the furthest in solving the determining equations with minimal intervention by the user. This program, called SPDE, is distributed with version 3.3 of REDUCE for various types of computers, ranging from PCs to CRAYs. <p> Schwarz [15, 21]- [25], is definitely going the furthest in solving the determining equations with minimal intervention by the user. This program, called SPDE, is distributed with version 3.3 of REDUCE for various types of computers, ranging from PCs to CRAYs. Schwarz also rewrote SPDE <ref> [15, 25] </ref> for use with SCRATCHPAD II, a symbolic manipulation program developed by IBM. Based on Cartan's exterior calculus, Edelen [26] and Gragert and Kersten [27] did some pioneering work in using REDUCE to calculate the classical Lie symmetries of differential equations.
Reference: [26] <author> D.G.B. Edelen, </author> <title> Isovector Methods for Equations of Balance (Sijthoff & Nordhoff, </title> <editor> Alphen aan de Rijn, </editor> <year> 1981). </year>
Reference-contexts: This program, called SPDE, is distributed with version 3.3 of REDUCE for various types of computers, ranging from PCs to CRAYs. Schwarz also rewrote SPDE [15, 25] for use with SCRATCHPAD II, a symbolic manipulation program developed by IBM. Based on Cartan's exterior calculus, Edelen <ref> [26] </ref> and Gragert and Kersten [27] did some pioneering work in using REDUCE to calculate the classical Lie symmetries of differential equations. Kersten [28, 29] later developed a REDUCE software package for the calculation of the Lie algebra of infinitesimal symmetries (and corresponding Lie-Backlund transformations) of an exterior differential system.
Reference: [27] <author> P. Gragert, P.H.M. Kersten and A. Martini, </author> <note> Acta Appl. Math. 1 (1983) 43. </note>
Reference-contexts: Schwarz also rewrote SPDE [15, 25] for use with SCRATCHPAD II, a symbolic manipulation program developed by IBM. Based on Cartan's exterior calculus, Edelen [26] and Gragert and Kersten <ref> [27] </ref> did some pioneering work in using REDUCE to calculate the classical Lie symmetries of differential equations. Kersten [28, 29] later developed a REDUCE software package for the calculation of the Lie algebra of infinitesimal symmetries (and corresponding Lie-Backlund transformations) of an exterior differential system.
Reference: [28] <author> P.H.M. Kersten, </author> <title> Infinitesimal Symmetries: a Computational Approach, </title> <institution> CWI Tract 34 (Center for Mathematics and Computer Science, Amster-dam, </institution> <year> 1987). </year> <month> 26 </month>
Reference-contexts: Schwarz also rewrote SPDE [15, 25] for use with SCRATCHPAD II, a symbolic manipulation program developed by IBM. Based on Cartan's exterior calculus, Edelen [26] and Gragert and Kersten [27] did some pioneering work in using REDUCE to calculate the classical Lie symmetries of differential equations. Kersten <ref> [28, 29] </ref> later developed a REDUCE software package for the calculation of the Lie algebra of infinitesimal symmetries (and corresponding Lie-Backlund transformations) of an exterior differential system. Eliseev et al [30] wrote a REDUCE program to generate (but not solve) the system of determining equations for point and contact symmetries.
Reference: [29] <author> P.H.M. Kersten, </author> <title> Software to Compute Infinitesimal Symmetries of Ex--terior Differential Systems, with Applications, </title> <journal> Acta Appl. Math. </journal> <volume> 16 (1989) 207. </volume>
Reference-contexts: Schwarz also rewrote SPDE [15, 25] for use with SCRATCHPAD II, a symbolic manipulation program developed by IBM. Based on Cartan's exterior calculus, Edelen [26] and Gragert and Kersten [27] did some pioneering work in using REDUCE to calculate the classical Lie symmetries of differential equations. Kersten <ref> [28, 29] </ref> later developed a REDUCE software package for the calculation of the Lie algebra of infinitesimal symmetries (and corresponding Lie-Backlund transformations) of an exterior differential system. Eliseev et al [30] wrote a REDUCE program to generate (but not solve) the system of determining equations for point and contact symmetries.
Reference: [30] <author> V.P. Eliseev, R.N. Fedorova and V.V. </author> <title> Kornyak, </title> <journal> Comput. Phys. Comm. </journal> <volume> 36 (1985) 383. </volume>
Reference-contexts: Kersten [28, 29] later developed a REDUCE software package for the calculation of the Lie algebra of infinitesimal symmetries (and corresponding Lie-Backlund transformations) of an exterior differential system. Eliseev et al <ref> [30] </ref> wrote a REDUCE program to generate (but not solve) the system of determining equations for point and contact symmetries. Fedorova and Kornyak [31] generalized the algorithm to include the case of Lie-Backlund symmetries.
Reference: [31] <author> R.N. Fedorova and V.V. Kornyak, </author> <title> A REDUCE Program for Computing Determining Equations of Lie-Backlund Symmetries of Differential Equations. </title> <type> Report R11-87-19 (JINR, Dubna, </type> <year> 1987). </year>
Reference-contexts: Eliseev et al [30] wrote a REDUCE program to generate (but not solve) the system of determining equations for point and contact symmetries. Fedorova and Kornyak <ref> [31] </ref> generalized the algorithm to include the case of Lie-Backlund symmetries.
Reference: [32] <author> R.N. Fedorova and V.V. </author> <title> Kornyak, </title> <journal> Comput. Phys. Comm. </journal> <volume> 39 (1986) 93. </volume>
Reference-contexts: Fedorova and Kornyak [31] generalized the algorithm to include the case of Lie-Backlund symmetries. Apart from packages in REDUCE, we should mention the FORMAC programs by Fedorova and Kornyak <ref> [32] </ref> and Fushchich and Kornyak [33] that create the system of determining equations for the Lie-Backlund symmetries and solves these equations as far as possible.
Reference: [33] <author> W.I. Fushchich and V.V. Kornyak, J. </author> <note> Symb. Comp. 7 (1989) 611. </note>
Reference-contexts: Fedorova and Kornyak [31] generalized the algorithm to include the case of Lie-Backlund symmetries. Apart from packages in REDUCE, we should mention the FORMAC programs by Fedorova and Kornyak [32] and Fushchich and Kornyak <ref> [33] </ref> that create the system of determining equations for the Lie-Backlund symmetries and solves these equations as far as possible. The FORMAC package CRACK-STAR developed by Wolf [34] also allows investigation of Lie symmetries of PDEs, besides dealing with dynamical symmetries of ODEs and the like.
Reference: [34] <author> T. Wolf, </author> <title> Analytic solutions of differential equations with computer algebra systems. </title> <type> Preprint 87/5 (Universitat Jena, </type> <address> Jena, Germany, </address> <year> 1987). </year>
Reference-contexts: Apart from packages in REDUCE, we should mention the FORMAC programs by Fedorova and Kornyak [32] and Fushchich and Kornyak [33] that create the system of determining equations for the Lie-Backlund symmetries and solves these equations as far as possible. The FORMAC package CRACK-STAR developed by Wolf <ref> [34] </ref> also allows investigation of Lie symmetries of PDEs, besides dealing with dynamical symmetries of ODEs and the like. The program LIE by Head [35] is based on version 4.12 of muMATH, running on IBM compatible PCs. Head's program calculates and solves the determining equations automatically.
Reference: [35] <author> A.K. </author> <title> Head, LIE : A muMATH Program for the Calculation of the LIE Algebra of Differential Equations (CSIRO Division of Material Sciences, </title> <address> Clayton, Australia, </address> <year> 1990). </year>
Reference-contexts: The FORMAC package CRACK-STAR developed by Wolf [34] also allows investigation of Lie symmetries of PDEs, besides dealing with dynamical symmetries of ODEs and the like. The program LIE by Head <ref> [35] </ref> is based on version 4.12 of muMATH, running on IBM compatible PCs. Head's program calculates and solves the determining equations automatically.
Reference: [36] <author> P. Vafeades, </author> <title> Computer Algebraic Determination of Symmetries and Conservation Laws of PDEs, in: E.K. Park, </title> <booktitle> Proc. ISMM Int. Symposium on Computer Applications in Design, Simulation and Analysis, </booktitle> <address> (New Orleans, Louisiana, 1990) p. </address> <month> 310. </month>
Reference-contexts: The program LIE by Head [35] is based on version 4.12 of muMATH, running on IBM compatible PCs. Head's program calculates and solves the determining equations automatically. Interventions by the user are sometimes needed and therefore are made possible. 2 The SYMCON package written by Vafeades <ref> [36] </ref> also uses muMATH to cal-culate the determining equations (without solving them). Furthermore, the program verifies whether the symmetry group is of variational or divergence type and computes the conservation laws associated with the symmetries.
Reference: [37] <author> P. Vafeades, SYMCON: </author> <title> A MACSYMA Package for the Determination of Symmetries and Conservation Laws of PDEs, </title> <note> submitted to J. Symb. Comp. 8 (1990) </note>
Reference-contexts: Unfortunately, these programs are confined to the 256 K memory accessible by muMATH and can therefore presently not handle very large systems of equations. This limitation motivated Vafeades to rewrite his SYMCON program in MACSYMA syntax <ref> [37] </ref>. Although this program is similar in mission to ours, Vafeades' program requires quite a bit more interaction by the user. Geoff Prince from LaTrobe University (Melbourne, Australia) is working on a 'translation' of the source code of LIE into REDUCE. <p> Apart from an earlier version of our program [47] and the work done by Rosencrans [48], their are only three other MACSYMA-based symmetry programs. The MACSYMA version of SYMCON by Vafeades <ref> [37] </ref> was discussed 3 above. Schwarzmeier and Rosenau [43, 44] made a program that calculates the determining equations in their simplest form, but does not solve them automatically. The program SYM DE by Steinberg [45, 46] was recently added to the out-of-core library of MACSYMA.
Reference: [38] <author> M.D. Popov, </author> <title> Izvestiya AN Belor. </title> <journal> SSR, Ser. Phys.-Math. </journal> <volume> 2 (1985) 33. </volume>
Reference-contexts: Geoff Prince from LaTrobe University (Melbourne, Australia) is working on a 'translation' of the source code of LIE into REDUCE. The calculation of the Lie group by computer was also proposed by Popov, who used the program SOPHUS for the calculation of conservation laws of evolution equations <ref> [38] </ref>. The package DELiA by Bocharov [39] also runs on PC and claims to perform various tasks based on Lie's approach, such as the computation of point symmetries, conserved currents and conservation laws; simplification and partial integration of overdetermined systems of differential equations, etc.
Reference: [39] <author> A.V. Bocharov, DEliA: </author> <title> A System of Exact Analysis of Differential Equations using S. Lie Approach. </title> <institution> Report OWIMEX (Program Systems Institute, Pereslavl-Zalessky, USSR, </institution> <year> 1989). </year>
Reference-contexts: The calculation of the Lie group by computer was also proposed by Popov, who used the program SOPHUS for the calculation of conservation laws of evolution equations [38]. The package DELiA by Bocharov <ref> [39] </ref> also runs on PC and claims to perform various tasks based on Lie's approach, such as the computation of point symmetries, conserved currents and conservation laws; simplification and partial integration of overdetermined systems of differential equations, etc.
Reference: [40] <author> A.V. </author> <title> Bocharov and M.L. Bronstein, </title> <journal> Acta Appl. Math. </journal> <volume> 16 (1989) 143. </volume>
Reference-contexts: The marketing material that comes with the demonstration disk for DELiA does not specify any underlying symbolic manipulation package. We believe that the program is written in PASCAL. In <ref> [40] </ref> Bocharov and Bronstein present SCo-LAr, a package based on standard PASCAL, for finding infinitesimal symmetries and conservation laws of arbitrary systems of differential equations. To the best of our knowledge, no package is available yet for the calculation of Lie symmetries with MAPLE and MATHEMATICA.
Reference: [41] <author> D.K. Davison, MANDO: </author> <title> A Computer Program for Symbolic Manipulation of Differential Operators Generating Continuous Transformations, </title> <booktitle> M.Sc. Thesis (University of the Pacific, </booktitle> <address> Stockton, CA, </address> <year> 1973). </year> <month> 27 </month>
Reference-contexts: To the best of our knowledge, no package is available yet for the calculation of Lie symmetries with MAPLE and MATHEMATICA. For completeness, we mention the pioneering work by C. Wulfman and his master students Davison and Nagao <ref> [41, 42] </ref>. Already in the early seventies, Davison [41] developed computer algorithms in SNOBOL, a now obsolete computer language, that could handle symbolic manipulations with differential operators. In 1980, Nagao [42] wrote the computer program DETERMININGEQS (in Pascal) that could approximate Lie generators for dynamical systems. <p> To the best of our knowledge, no package is available yet for the calculation of Lie symmetries with MAPLE and MATHEMATICA. For completeness, we mention the pioneering work by C. Wulfman and his master students Davison and Nagao [41, 42]. Already in the early seventies, Davison <ref> [41] </ref> developed computer algorithms in SNOBOL, a now obsolete computer language, that could handle symbolic manipulations with differential operators. In 1980, Nagao [42] wrote the computer program DETERMININGEQS (in Pascal) that could approximate Lie generators for dynamical systems.
Reference: [42] <author> G.G. Nagao, DETERMININGEQS: </author> <title> A Computer Program for Aprrox--imating Lie Generators Admitted by Dynamcical Systems, </title> <booktitle> M.Sc. Thesis (University of the Pacific, </booktitle> <address> Stockton, CA, </address> <year> 1980). </year>
Reference-contexts: To the best of our knowledge, no package is available yet for the calculation of Lie symmetries with MAPLE and MATHEMATICA. For completeness, we mention the pioneering work by C. Wulfman and his master students Davison and Nagao <ref> [41, 42] </ref>. Already in the early seventies, Davison [41] developed computer algorithms in SNOBOL, a now obsolete computer language, that could handle symbolic manipulations with differential operators. In 1980, Nagao [42] wrote the computer program DETERMININGEQS (in Pascal) that could approximate Lie generators for dynamical systems. <p> For completeness, we mention the pioneering work by C. Wulfman and his master students Davison and Nagao [41, 42]. Already in the early seventies, Davison [41] developed computer algorithms in SNOBOL, a now obsolete computer language, that could handle symbolic manipulations with differential operators. In 1980, Nagao <ref> [42] </ref> wrote the computer program DETERMININGEQS (in Pascal) that could approximate Lie generators for dynamical systems. Last but not least, we discuss the programs written in MACSYMA, the symbolic package our symmetry program is based upon.
Reference: [43] <author> P. Rosenau and J.L. Schwarzmeier, </author> <title> Similarity Solutions of Systems of Partial Differential Equations using MACSYMA. </title> <institution> Report COO-3077-160 MF-94 (Courant Institute of Mathematical Sciences, </institution> <address> New York University, New York, </address> <year> 1979). </year>
Reference-contexts: Apart from an earlier version of our program [47] and the work done by Rosencrans [48], their are only three other MACSYMA-based symmetry programs. The MACSYMA version of SYMCON by Vafeades [37] was discussed 3 above. Schwarzmeier and Rosenau <ref> [43, 44] </ref> made a program that calculates the determining equations in their simplest form, but does not solve them automatically. The program SYM DE by Steinberg [45, 46] was recently added to the out-of-core library of MACSYMA.
Reference: [44] <author> J.L. Schwarzmeier and P. Rosenau, </author> <title> Using MACSYMA to Calculate Similarity Transformations of Partial Differential Equations. </title> <institution> Report LA-UR 88-4157 (Los Alamos National Laboratory, Los Alamos, </institution> <year> 1988). </year>
Reference-contexts: Apart from an earlier version of our program [47] and the work done by Rosencrans [48], their are only three other MACSYMA-based symmetry programs. The MACSYMA version of SYMCON by Vafeades [37] was discussed 3 above. Schwarzmeier and Rosenau <ref> [43, 44] </ref> made a program that calculates the determining equations in their simplest form, but does not solve them automatically. The program SYM DE by Steinberg [45, 46] was recently added to the out-of-core library of MACSYMA.
Reference: [45] <editor> S. Steinberg, in: V. E. Lewis, </editor> <booktitle> Proc. of the 1979 MACSYMA User's Conference (MIT Press, </booktitle> <address> Boston, 1979) p. </address> <month> 408 </month>
Reference-contexts: The MACSYMA version of SYMCON by Vafeades [37] was discussed 3 above. Schwarzmeier and Rosenau [43, 44] made a program that calculates the determining equations in their simplest form, but does not solve them automatically. The program SYM DE by Steinberg <ref> [45, 46] </ref> was recently added to the out-of-core library of MACSYMA. The program solves some (or all) of the determining equations automatically and if needed the user can (interactively) add extra information.
Reference: [46] <author> S. Steinberg, </author> <note> MACSYMA Newsletter 7 (1990) 3. </note>
Reference-contexts: The MACSYMA version of SYMCON by Vafeades [37] was discussed 3 above. Schwarzmeier and Rosenau [43, 44] made a program that calculates the determining equations in their simplest form, but does not solve them automatically. The program SYM DE by Steinberg <ref> [45, 46] </ref> was recently added to the out-of-core library of MACSYMA. The program solves some (or all) of the determining equations automatically and if needed the user can (interactively) add extra information.
Reference: [47] <author> B. Champagne and P. Winternitz, </author> <title> A MACSYMA Program for Calculating the Symmetry Group of a System of Differential Equations. </title> <institution> Report CRM-1278 (Centre de Recherches Mathematiques, Montreal, Canada, </institution> <year> 1985). </year>
Reference-contexts: Just as REDUCE, MACSYMA is currently available for various types of computers, ranging from PCs to various work stations and main frame computers (such as VAX) and it is used all over the world. Apart from an earlier version of our program <ref> [47] </ref> and the work done by Rosencrans [48], their are only three other MACSYMA-based symmetry programs. The MACSYMA version of SYMCON by Vafeades [37] was discussed 3 above. <p> Currently, Steinberg is working at the extension of his program so that it would include the calculation of generalized (i.e. derivative dependent) symmetries. 1.3 The program symmgrp.max The present program, called SYMMGRP.MAX is a modification of a package <ref> [47] </ref> that has been extensively used over the last five years at the University of Montreal and elsewhere. It has been tested on hundreds of systems of equations and has thus been solidly debugged.
Reference: [48] <institution> S.I. Rosencrans, Comput. Phys. </institution> <note> Comm. 38 (1985) 347. </note>
Reference-contexts: The procedure thus consists of two major steps: deriving the determining equations and solving them. 1.2 Review of symbolic programs Several computer packages [15, 21]-[47] exist for this purpose, and some other programs were written for specific examples <ref> [48] </ref>. The well-documented REDUCE program developed by F. Schwarz [15, 21]- [25], is definitely going the furthest in solving the determining equations with minimal intervention by the user. This program, called SPDE, is distributed with version 3.3 of REDUCE for various types of computers, ranging from PCs to CRAYs. <p> Just as REDUCE, MACSYMA is currently available for various types of computers, ranging from PCs to various work stations and main frame computers (such as VAX) and it is used all over the world. Apart from an earlier version of our program [47] and the work done by Rosencrans <ref> [48] </ref>, their are only three other MACSYMA-based symmetry programs. The MACSYMA version of SYMCON by Vafeades [37] was discussed 3 above. Schwarzmeier and Rosenau [43, 44] made a program that calculates the determining equations in their simplest form, but does not solve them automatically.
Reference: [49] <author> F. Schwarz, </author> <title> An Algorithm for Determining the Size of Symmetry Groups, private communication (1989). </title>
Reference-contexts: Furthermore, a computer program may accidentally not catch the most general result and therefore may return an incomplete symmetry group. The authors are very aware of this problem which occurred in testing some of the other existing programs ! Fortunately, as soon as the new programs by Schwarz <ref> [49] </ref> and Reid [50]-[52], both for the determination of the size of a symmetry group, become available this problem will be easily detectable. Let us briefly digress on this topic. Indeed, Schwarz and Reid independently developed algorithms to determine the size of a symmetry group of Lie (point) symmetries. <p> Let us briefly digress on this topic. Indeed, Schwarz and Reid independently developed algorithms to determine the size of a symmetry group of Lie (point) symmetries. Schwarz's program in REDUCE <ref> [49] </ref> calculates the number of parameters if the group is finite and the number of unspecified functions and its arguments if the group is infinite. 4 Recently, Reid [50]-[52] took up the same task.
Reference: [50] <author> G.J. Reid, in: V. Hussin, </author> <title> Lie Theory, Differential Equations and Representation Theory Proc. </title> <booktitle> Annual Seminar of the Canadian Math. </booktitle> <institution> Soc. (Les Publications de Centre de Recherches Mathematiques, </institution> <address> Montreal, Canada, 1990) p. </address> <month> 363. </month>
Reference: [51] <author> G.J. Reid, </author> <title> Finding symmetries of differential equations without integrating determining equations, </title> <type> Technical Report 90-4, </type> <institution> Inst. of Appl. Math., The University of British Columbia, Vancouver, Canada, </institution> <note> submitted to Eu-ropean J. Appl. Math (1990). </note>
Reference-contexts: Schwarz's program in REDUCE [49] calculates the number of parameters if the group is finite and the number of unspecified functions and its arguments if the group is infinite. 4 Recently, Reid [50]-[52] took up the same task. His program SYMCAL <ref> [51] </ref>, written originally in MACSYMA and currently being converted into MAPLE, computes the dimension and the structure constants of the Lie symmetry algebra of any system of PDEs.
Reference: [52] <author> G.J. Reid, </author> <title> A Triangular Algorithm which Determines the Lie Symmetry Algebra of any System of PDEs, </title> <journal> J. Phys. A: Math. Gen. </journal> <note> 23 (1990) to appear. </note>
Reference-contexts: if the group is infinite. 4 Recently, Reid [50]-<ref> [52] </ref> took up the same task. His program SYMCAL [51], written originally in MACSYMA and currently being converted into MAPLE, computes the dimension and the structure constants of the Lie symmetry algebra of any system of PDEs. An extension of the algorithm [52] also allows to classify differential equations (with variable coefficients) according to the structure of their symmetry groups. Furthermore, the approach advocated by Reid applies to the determination of symmetries of Lie, contact, and Lie-Backlund type as well as potential symmetries.
Reference: [53] <institution> V.I. Karpman, Phys. </institution> <note> Lett. A 136 (1989) 216. 28 Test Run Output 29 . . . . . Listing of symmgrp.max 35 . . . . . . . . . . . Listing of printeqn.max 47 </note>
Reference-contexts: Precautionary, we have assigned the value 0 to the first components of such arrays. 14 4 Example: The Karpman Equations This example shows how the program SYMMGRP.MAX can be used in batch mode. It also illustrates the feedback mechanism for solving the determining equations. The Karpman equations <ref> [53] </ref> describe the effect of modulation instability of a high frequency (whistler) wave due to its resonant parametric interaction with a low frequency wave in a plasma.
References-found: 53

