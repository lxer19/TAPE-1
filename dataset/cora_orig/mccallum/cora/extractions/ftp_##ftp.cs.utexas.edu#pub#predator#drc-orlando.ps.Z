URL: ftp://ftp.cs.utexas.edu/pub/predator/drc-orlando.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Email: -batory, geraci-@cs.utexas.edu  
Title: Validating Component Compositions in Software System Generators  
Author: Don Batory and Bart J. Geraci 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas,  
Abstract: 1 Generators synthesize software systems by composing components from reuse libraries. In general, not all syntactically correct compositions are semantically correct. In this paper, we present domain-inde-pendent algorithms for the GenVoca model of software generators to validate component compositions. Our work relies on attribute grammars and offers powerful debugging capabilities with explana-tion-based error reporting. We illustrate our approach by showing how compositions are debugged by a GenVoca generator for container data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat92a] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components, </title> <journal> ACM TOSEM, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Software system generators automate the development of software for large families of applications. Generators automatically transform compact, high-level specifications of target systems into actual source code, and rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bla91, Bat92a, Bax92, Gom94, Lei94, Nin94] </ref> are among many approaches that are being explored to construct customized software systems quickly and inexpensively from reuse libraries. <p> This work was supported in part by Microsoft, Schlumberger, the University of Texas Applied Research Labs, and the U.S. Department of Defense Advanced Research Projects Agency in cooperation with the U.S. Wright Laboratory Avionics Director-ate under contract F33615-91C-1788. of generators that we consider in this paper, called GenVoca generators <ref> [Bat92a] </ref>, is distinguished from the above approaches in that their components are parameterized program transformations that encapsulate consistent data and operation refinements. Components also encapsulate logic to automate domain-specific decisions about when to use a particular algorithm or when to apply a domain-specific optimization. <p> In general, the order in which components are composed can significantly 3. Note that composing components can be interpreted as stacking layers in hierarchical software systems. We use the terms component and layer interchangeably in this paper. 3 affect the semantics, performance, and behavior of the resulting system <ref> [Bat92a] </ref>. Design Rules and Domain Models. In principle, any component of realm S can instantiate the parameter of any component of realm T. Although the resulting equations would be type correct, the equation may not be semantically correct.
Reference: [Bat92b] <author> D. S. Batory and J. R. Barnett. DaTE: </author> <title> The Genesis DBMS Software Layout Editor. In Conceptual Modeling, Databases, and CASE, </title> <editor> Pericles Louco-poulos and Roberto Zicari, eds. </editor> <publisher> John Wiley & Sons, </publisher> <year> 1992. </year>
Reference-contexts: DRACO used a form of shallow consistency checking (called assertions and conditions) in composing layers of transformations [Nei80]. DaTE, the design rule checker for Genesis <ref> [Bat92b] </ref> supported only component preconditions. The limitations of DaTE led to the work presented in this paper. McAllester developed a functional programming language, VAG, based on variational attribute grammars, to address the design rule checking issues for the ADAGE generator [McA94]. Preconditions and prerestrictions are treated uniformly as constraints.
Reference: [Bat93] <author> D. Batory, et al., </author> <title> Scalable Software Libraries, </title> <booktitle> Proc. ACM SIGSOFT, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Although the number of fundamental abstractions in a domain is rather small, there is a huge number of potential implementations. Gen-Voca also advocates a layered decomposition of implementations, where each layer or component encapsulates a primitive domain feature. The advantage of GenVoca is scalability <ref> [Bat93, Big94] </ref>: component libraries are relatively small and grow at the rate new components are entered, whereas the number of possible combinations of components (i.e., distinct software systems in the domain that can be defined) grows geometrically. <p> Generators that use GenVoca organizations have been built for the domains of avionics, data structures, databases, file systems, and network protocols <ref> [Cog93, Bat93, Hei93, Hut91] </ref>. Components and Realms. A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component or layer is an implementation of a virtual machine.
Reference: [Bat95] <author> D. Batory and B.J. Geraci, </author> <title> Validating Compo nent Compositions in Software System Generators, </title> <institution> UT/CS TR-95-03, University of Texas at Austin, </institution> <year> 1995. </year>
Reference-contexts: Given the operators and fi, there is a straightforward, recursive algorithm for the top-down propagation of postconditions and the testing of component preconditions <ref> [Bat95] </ref>. 4.2 Bottom-Up Design Rule Checking Every parameter of a component has preconditions (called prerestrictions) for instantiation; every component also has postconditions (called postrestric-tions) that are exported to higher-level layers in a type equation. <p> Just as in the case of top-down design rule checking, there is a simple, recursive algorithm for the bottom q s system rooted at r w 6 up propagation of postrestrictions and the testing of parameter prerestrictions <ref> [Bat95] </ref>. 4.3 Attribute Grammars McAllester [McA94] observed that attribute grammars unify realms, components, attributes, top-down and bottom-up design rule checking. From previous sections, we know that realms of components define a grammar. <p> In <ref> [Bat95] </ref> we explain the need for a fifth attribute value. This enlarges the set of primitive predicates. Attribute Value Interpretation any nothing is known assert property is asserted negate property is negated inherit property value is inherited from existing conditions Table 1. <p> We wrote a general utility, called dreck, that would allow designers to declare realms, components, and their design rules based on the representations we noted previously for attributes, predicates, and DRC operators <ref> [Bat95] </ref>. component and its design rules. A components name, realm membership, and realm parameters are declared on the first line. Subsequent lines define design rules. A precondition for arrays usage is that a layer above array needs to support logical deletion. This precondition is expressed by asserting the df_present property.
Reference: [Bax92] <author> I. Baxter, </author> <title> Design Maintenance Systems, </title> <journal> CACM April 1992, </journal> <pages> 73-89. </pages>
Reference-contexts: 1 Introduction Software system generators automate the development of software for large families of applications. Generators automatically transform compact, high-level specifications of target systems into actual source code, and rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bla91, Bat92a, Bax92, Gom94, Lei94, Nin94] </ref> are among many approaches that are being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Bla91] <author> L. Blaine and A. Goldberg, </author> <title> DTRE - A Semi Automatic Transformation System, in Constructing Programs from Specifications, </title> <publisher> Elsevier Science Pub-lishers, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Software system generators automate the development of software for large families of applications. Generators automatically transform compact, high-level specifications of target systems into actual source code, and rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bla91, Bat92a, Bax92, Gom94, Lei94, Nin94] </ref> are among many approaches that are being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Boo91] <author> G. Booch. </author> <title> Object-Oriented Design With Appli cations, </title> <address> Benjamin-Cummings, </address> <year> 1991. </year>
Reference-contexts: Second, we believe that GenVoca offers a powerful methodology for the design of reusable components. Object-oriented design methodologies, for example, are powerful because of their ability to manage and control software complexity <ref> [Boo91] </ref>. It is not difficult to recognize that standardizing domain abstractions and their programming interfaces (i.e., the core of GenVoca) is also a powerful way of managing and controlling the complexity of software in a family of systems.
Reference: [Big94] <author> T. Biggerstaff, </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse, </title> <month> ICSR </month> <year> 1994. </year>
Reference-contexts: Although the number of fundamental abstractions in a domain is rather small, there is a huge number of potential implementations. Gen-Voca also advocates a layered decomposition of implementations, where each layer or component encapsulates a primitive domain feature. The advantage of GenVoca is scalability <ref> [Bat93, Big94] </ref>: component libraries are relatively small and grow at the rate new components are entered, whereas the number of possible combinations of components (i.e., distinct software systems in the domain that can be defined) grows geometrically.
Reference: [Coh95] <author> S. Cohen, et al., </author> <title> Models for Domains and Architectures: A Prescription for Systematic Software Reuse, </title> <booktitle> AIAA Computing in Aerospace, </booktitle> <year> 1995. </year>
Reference: [Cog93] <author> L. Coglianese and R. Szymanski, </author> <title> DSSA ADAGE: An Environment for Architecture-based Avi-onics Development, </title> <booktitle> Proc. </booktitle> <address> AGARD, </address> <year> 1993. </year>
Reference-contexts: Generators that use GenVoca organizations have been built for the domains of avionics, data structures, databases, file systems, and network protocols <ref> [Cog93, Bat93, Hei93, Hut91] </ref>. Components and Realms. A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component or layer is an implementation of a virtual machine.
Reference: [Gar94] <author> D. Garlan, et al., </author> <title> Exploiting Style in Architec tural Design Environments, </title> <booktitle> ACM SIGSOFT 1994. </booktitle>
Reference: [Gar95] <author> D. Garlan, et al, </author> <title> Architectural Mismatch or Why Its Hard to Build Systems out of Existing Parts, </title> <month> ICSE </month> <year> 1995. </year>
Reference-contexts: We believe that standardization makes some problems tractable that would otherwise be very difficult. Composibility of software components is one example (c.f., <ref> [Gar95] </ref>) and DRC is another (c.f. [Kat92]). 8 Conclusions Software system generators are becoming important tools for software developers. Generators utilize libraries of reusable components to assemble complex, high-performance systems quickly and cheaply. Each library component has limitations, called design rules, on how it can be combined with other components.
Reference: [Gog86] <author> J.A. Goguen, </author> <title> Reusing and Interconnecting Software Components, </title> <booktitle> Computer. </booktitle> <month> February </month> <year> 1986. </year>
Reference-contexts: The 9 VAG interpreter has limited reasoning abilities to infer values of unbound VAG program parameters. Parameterized programming is intimately associated with the verification of component compositions. Goguens work on OBJ and library interconnection languages, such as LIL and LILEANNA <ref> [Gog86, Tra93] </ref>, are basic. The RESOLVE project explores the design of reusable and parameterized components, component certifiability, and the certifiability of component compositions [Sit94]. Although there are many similarities among these works and ours, there is a basic difference: there is no action-at-a-distance in the other work.
Reference: [Gom94] <author> H. Gomaa, et al., </author> <title> A Prototype Domain Model ing Environment for reusable Software Architectures, </title> <month> ICSR </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Software system generators automate the development of software for large families of applications. Generators automatically transform compact, high-level specifications of target systems into actual source code, and rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bla91, Bat92a, Bax92, Gom94, Lei94, Nin94] </ref> are among many approaches that are being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Gri94] <author> M.L. Griss and K.D. Wentzel, </author> <title> Hybrid Domain-Specific Kits for a Flexible Software Factory, </title> <booktitle> ACM SAC94, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: CORBA and its variants simplify the task of building distributed applications from components [Ude94]; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment. In contrast, generators are closer to toolkits <ref> [Gri94] </ref>, object-ori-ented frameworks [Joh92], and other reuse-driven approaches (e.g, [Wei90, Sit94]), because they focus on software domains whose components are not stand-alone, that are designed to be plug-compatible and interoperable with other components, and that are written in a single language. The particular class 1.
Reference: [Hei93] <author> J. Heidemann and G. Popek, </author> <title> File System Development with Stackable Layers, </title> <journal> ACM TOCS, </journal> <month> March </month> <year> 1993. </year>
Reference-contexts: Generators that use GenVoca organizations have been built for the domains of avionics, data structures, databases, file systems, and network protocols <ref> [Cog93, Bat93, Hei93, Hut91] </ref>. Components and Realms. A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component or layer is an implementation of a virtual machine.
Reference: [Hut91] <author> N. Hutchinson and L. Peterson, </author> <title> The x-kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE TSE, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: Generators that use GenVoca organizations have been built for the domains of avionics, data structures, databases, file systems, and network protocols <ref> [Cog93, Bat93, Hei93, Hut91] </ref>. Components and Realms. A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component or layer is an implementation of a virtual machine.
Reference: [Joh92] <author> R.E. Johnson, </author> <title> Documenting Frameworks using Patterns, </title> <booktitle> OOPSLA 1992, </booktitle> <pages> 63-76. </pages>
Reference-contexts: CORBA and its variants simplify the task of building distributed applications from components [Ude94]; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment. In contrast, generators are closer to toolkits [Gri94], object-ori-ented frameworks <ref> [Joh92] </ref>, and other reuse-driven approaches (e.g, [Wei90, Sit94]), because they focus on software domains whose components are not stand-alone, that are designed to be plug-compatible and interoperable with other components, and that are written in a single language. The particular class 1.
Reference: [Kat92] <author> M.D. Katz and D.J. Volper, </author> <title> Constraint Propa gation in Software Libraries of Transformation Systems, </title> <journal> Int. Jour. Software Engineering and Knowledge Engineering, </journal> <volume> Vol. </volume> <month> 2#3 </month> <year> (1992). </year>
Reference-contexts: We believe that standardization makes some problems tractable that would otherwise be very difficult. Composibility of software components is one example (c.f., [Gar95]) and DRC is another (c.f. <ref> [Kat92] </ref>). 8 Conclusions Software system generators are becoming important tools for software developers. Generators utilize libraries of reusable components to assemble complex, high-performance systems quickly and cheaply. Each library component has limitations, called design rules, on how it can be combined with other components.
Reference: [Lei94] <author> J.C.S. do Prado Leite, et al., Draco-PUC: </author> <title> A Technology Assembly for Domain-Oriented Software Development, </title> <month> ICSR </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Software system generators automate the development of software for large families of applications. Generators automatically transform compact, high-level specifications of target systems into actual source code, and rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bla91, Bat92a, Bax92, Gom94, Lei94, Nin94] </ref> are among many approaches that are being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [McA94] <author> D. McAllester, </author> <title> Variational Attribute Gram mars for Computer Aided Design. </title> <publisher> ADAGE-MIT-94-01. </publisher>
Reference-contexts: Just as in the case of top-down design rule checking, there is a simple, recursive algorithm for the bottom q s system rooted at r w 6 up propagation of postrestrictions and the testing of parameter prerestrictions [Bat95]. 4.3 Attribute Grammars McAllester <ref> [McA94] </ref> observed that attribute grammars unify realms, components, attributes, top-down and bottom-up design rule checking. From previous sections, we know that realms of components define a grammar. <p> DaTE, the design rule checker for Genesis [Bat92b] supported only component preconditions. The limitations of DaTE led to the work presented in this paper. McAllester developed a functional programming language, VAG, based on variational attribute grammars, to address the design rule checking issues for the ADAGE generator <ref> [McA94] </ref>. Preconditions and prerestrictions are treated uniformly as constraints. The constraints associated with a component are expressed as a VAG program. When an avionics system is composed from components, the set of constraints that must be satisfied is defined by the composition of corresponding VAG programs.
Reference: [Mor94] <author> M. Moriconi and X. Qian, </author> <title> Correctness and Composition of Software Architectures, </title> <booktitle> ACM SIG-SOFT 1994. </booktitle>
Reference-contexts: Compositions of OBJ, LILEANNA, and RESOLVE components are verified locally; components constrain the behavior of immediately adjacent components, and not components that reside far above or below them in a hierarchy. Our work is also an example of the types of consistency checking problems encountered in software architectures <ref> [Per92, Gar94-95, Mor94] </ref>. To our knowledge, other than Inscape, validating compositions of components in the context of architectures has only begun to be addressed. Insights. Our work on DRC was actually developed independently of DRACO and Inscape.
Reference: [Nei80] <author> J. Neighbors, </author> <title> Software Construction Using Components, </title> <type> Ph.D. Thesis, </type> <institution> ICS-TR-160, University of California at Irvine, </institution> <year> 1980. </year>
Reference-contexts: With minimal experience, P2 users typically come very close to their desired equation on the first attempt; DRC messages enable them to correct errors quickly. 7 Related Work and Insights Related Work. DRACO used a form of shallow consistency checking (called assertions and conditions) in composing layers of transformations <ref> [Nei80] </ref>. DaTE, the design rule checker for Genesis [Bat92b] supported only component preconditions. The limitations of DaTE led to the work presented in this paper. McAllester developed a functional programming language, VAG, based on variational attribute grammars, to address the design rule checking issues for the ADAGE generator [McA94].
Reference: [Nin94] <editor> J.Q. Ning, et al. </editor> <title> An Architecture-Driven, Business-Specific, and Component-Based Approach to Software Engineering, </title> <month> ICSR </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Software system generators automate the development of software for large families of applications. Generators automatically transform compact, high-level specifications of target systems into actual source code, and rely on libraries of parameterized, plug-compatible, and reusable components for code synthesis. Generators <ref> [Bla91, Bat92a, Bax92, Gom94, Lei94, Nin94] </ref> are among many approaches that are being explored to construct customized software systems quickly and inexpensively from reuse libraries.
Reference: [Per87] <author> D.E. Perry, </author> <title> Software Interconnection Mod els, </title> <month> ICSE </month> <year> 1987. </year>
Reference: [Per89a] <author> D.E. Perry, </author> <title> The Logic of Propagation in The Inscape Environment, </title> <booktitle> ACM SIGSOFT 1989. </booktitle>
Reference: [Per89b] <author> D. E. Perry, </author> <title> The Inscape Environment, </title> <booktitle> Proc. </booktitle> <month> ICSE </month> <year> 1989. </year>
Reference: [Per92] <author> D.E. Perry and A.L. Wolf, </author> <title> Foundations for the Study of Software Architecture, </title> <booktitle> ACM SIGSOFT Soft-ware Engineering Notes, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Compositions of OBJ, LILEANNA, and RESOLVE components are verified locally; components constrain the behavior of immediately adjacent components, and not components that reside far above or below them in a hierarchy. Our work is also an example of the types of consistency checking problems encountered in software architectures <ref> [Per92, Gar94-95, Mor94] </ref>. To our knowledge, other than Inscape, validating compositions of components in the context of architectures has only begun to be addressed. Insights. Our work on DRC was actually developed independently of DRACO and Inscape.
Reference: [Sit94] <author> M. Sitaraman and B. Weide, </author> <title> Component Based Software using RESOLVE, </title> <booktitle> ACM Software Engineering Notes, </booktitle> <month> October, </month> <year> 1994. </year>
Reference-contexts: CORBA and its variants simplify the task of building distributed applications from components [Ude94]; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment. In contrast, generators are closer to toolkits [Gri94], object-ori-ented frameworks [Joh92], and other reuse-driven approaches (e.g, <ref> [Wei90, Sit94] </ref>), because they focus on software domains whose components are not stand-alone, that are designed to be plug-compatible and interoperable with other components, and that are written in a single language. The particular class 1. <p> Parameterized programming is intimately associated with the verification of component compositions. Goguens work on OBJ and library interconnection languages, such as LIL and LILEANNA [Gog86, Tra93], are basic. The RESOLVE project explores the design of reusable and parameterized components, component certifiability, and the certifiability of component compositions <ref> [Sit94] </ref>. Although there are many similarities among these works and ours, there is a basic difference: there is no action-at-a-distance in the other work.
Reference: [Tra93] <author> W. Tracz, LILEANNA: </author> <title> A Parameterized Pro gramming Language, </title> <month> ICSR </month> <year> 1993. </year>
Reference-contexts: The 9 VAG interpreter has limited reasoning abilities to infer values of unbound VAG program parameters. Parameterized programming is intimately associated with the verification of component compositions. Goguens work on OBJ and library interconnection languages, such as LIL and LILEANNA <ref> [Gog86, Tra93] </ref>, are basic. The RESOLVE project explores the design of reusable and parameterized components, component certifiability, and the certifiability of component compositions [Sit94]. Although there are many similarities among these works and ours, there is a basic difference: there is no action-at-a-distance in the other work.
Reference: [Ude94] <author> J. Udell, Componentware, BYTE, </author> <month> May </month> <year> 1994. </year>
Reference-contexts: Generators [Bla91, Bat92a, Bax92, Gom94, Lei94, Nin94] are among many approaches that are being explored to construct customized software systems quickly and inexpensively from reuse libraries. CORBA and its variants simplify the task of building distributed applications from components <ref> [Ude94] </ref>; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment.
Reference: [Wei90] <author> D.M. Weiss, </author> <title> Synthesis Operational Scenarios, </title> <type> Technical Report 90038-N. Version 1.00.01, </type> <institution> Software Productivity Consortium. </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: CORBA and its variants simplify the task of building distributed applications from components [Ude94]; CORBA can integrate components that are independently designed and stand-alone modules or executables in a heterogeneous environment. In contrast, generators are closer to toolkits [Gri94], object-ori-ented frameworks [Joh92], and other reuse-driven approaches (e.g, <ref> [Wei90, Sit94] </ref>), because they focus on software domains whose components are not stand-alone, that are designed to be plug-compatible and interoperable with other components, and that are written in a single language. The particular class 1.
References-found: 32

