URL: http://www.cs.ucla.edu/~nk/czdemo/greco/cslp.ps
Refering-URL: http://www.cs.ucla.edu/~nk/czdemo/greco/
Root-URL: http://www.cs.ucla.edu
Email: greco@si:deis:unical:it zaniolo@cs:ucla:edu  
Title: Greedy Algorithms in Greedy with Choice and Negation  
Author: Sergio Greco Carlo Zaniolo 
Address: Los Angeles 87030 Rende; Italy LosAngeles; CA 90024  
Affiliation: Dip: Elettr: Informatica Sist: Computer Science Dept: Universita della Calabria Univ: of California at  
Abstract: In the design of algorithms, the greedy paradigm provides a powerful tool for solving efficiently classical computational problems, within the framework of procedural languages. However, expressing these algorithms within the declarative framework of logic-based languages has proved to be a difficult research challenge. In this paper, we extend the framework of Datalog-like languages to obtain simple declarative formulations for such problems, and propose effective implementation techniques to ensure computational complexities comparable to those of procedural formulations. These advances are achieved through the use of the choice construct, that has semantics reducible to that of programs with negation under stable model semantics. Then we extend the fixpoint-based semantics of choice programs with preference annotations to guide search strategies and simple logic-based formulations of classical greedy algorithms.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul S., R. Hull, V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley. </publisher> <year> 1994. </year>
Reference-contexts: Because of the ability of choice programs to order the elements of a set, Datalog with choice is P-time complete and can, for instance, express the parity query|i.e., if a relation has an even number of elements <ref> [1] </ref>. This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity [4, 1]. <p> This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity <ref> [4, 1] </ref>.
Reference: [2] <author> Abiteboul S. and V. Vianu. </author> <title> Datalog Extensions for Databases Queries and Updates. </title> <journal> In Journal of Computer and System Science, </journal> <volume> 43, </volume> <pages> pages 62-124, </pages> <year> 1991. </year>
Reference-contexts: The expressive power of the choice construct has been studied in [14, 10], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator <ref> [2] </ref>, and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here [13]). <p> For instance, it has been shown in [13], that the task performed in Example 1 cannot be performed by positive programs with static choice or the witness operator <ref> [2] </ref>. Example 2. Rooted spanning tree. We are given an undirect graph where an edge joining two nodes, say x and y, is represented by means of two fact g (x; y; c) and g (y; x; c), where c is the cost.
Reference: [3] <author> Aho A.V., J.E. Hopcropt J.E., and J.D. </author> <title> Ullmann. The Design and analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference: [4] <author> Chandra A., and D. Harel, </author> <title> Structure and Complexity of Relational Queries, </title> <journal> Journal of Computer and System Sciences 25, </journal> <volume> 1, </volume> <year> 1982, </year> <pages> pp. 99-128. </pages>
Reference-contexts: This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity <ref> [4, 1] </ref>.
Reference: [5] <author> Chomicki J., </author> <title> Temporal deductive databases, in Temporal Databases: Theory, Design and Implementation, </title> <editor> A. Tansel et al. eds., Benjamin/Cummings, </editor> <year> 1993. </year>
Reference-contexts: Furthermore, as we shall see later, these programs can be extended with choice without compromising their virtues. These approaches basically build on the Datalog 1S model <ref> [5] </ref> where predicates have a special (discrete-time) temporal argument that models a succession of events or states.
Reference: [6] <author> Ganguly S., S. Greco, and C. Zaniolo. </author> <title> Minimum and maximum predicates in logic programming. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 154-163, </pages> <year> 1991. </year>
Reference: [7] <author> Ganguly S., S. Greco, and C. Zaniolo. </author> <title> Extrema Predicates in Deductive Databases. </title> <journal> Journal of Computer and System Science, </journal> <year> 1995. </year>
Reference: [8] <author> Greco S., C. Zaniolo, and S. Ganguly. </author> <title> Greedy by Choice. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: In this paper, we introduce a new kind of specialization called greedy choice; this is motivated by the observation that it is frequently desirable to select a value that is the least (or the most) among the possible values and still satisfy the FDs defined by the choice atoms <ref> [8] </ref>. Therefore, with X denoting one or more variables of r and C denoting one single variable ranging over an ordered domain, a goal choice-least ((X),(C)) in a rule r can be used to denote that the FD choice ((X),(C)) is to be satisfied using least values of C.
Reference: [9] <author> Greco S., D. Sacca, and C. Zaniolo, </author> <title> Dynamic Programming in Datalog with Aggregates. </title> <booktitle> In Proc. of the International Logic programming Symposium Vancouver, </booktitle> <year> 1993. </year> <month> 21 </month>
Reference: [10] <author> Greco S., D. Sacca, and C. Zaniolo, </author> <title> DATALOG Queries with Stratified Negation and Choice: from P to D P In Proc. </title> <booktitle> of the Fifth Int. Conf. on Database Theory, </booktitle> <year> 1995, </year> <pages> pp. 82-96. </pages>
Reference-contexts: This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity [4, 1]. The expressive power of the choice construct has been studied in <ref> [14, 10] </ref>, where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here [13]).
Reference: [11] <author> Greco S., and C. Zaniolo, </author> <title> Greedy Fixpoint Algorithms for Logic Programs with Negation and Extrema. </title> <type> TEchnical Report, </type> <year> 1997. </year>
Reference-contexts: Thus, the approach provides a programmer with declarative tools to express greedy algorithms, frees him/her from many implementation details, yet guarantees good performance. For space limitation the proofs of our result are omitted and they can be found in the full version of the paper <ref> [11] </ref>. 2 Basic Notions In this section, we summarize the basic notions of Horn Clauses logic, and its extensions to allow negative goals. <p> Assuming proper data structures, this fix-point procedure performs with the asymptotic complexity as greedy procedural algorithms. <ref> [11] </ref>
Reference: [12] <author> Gelfond M. and V. Lifschitz. </author> <title> The stable model semantics of logic programming. </title> <booktitle> In Proceedings of the Fifth Intern. Conference on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: Unfortunately, the computational problems remain largely unsolved; while various approaches have been fl Work partially supported by ECUS033 and NSF Grant IRI-9314905 1 proposed to more effective computations of well-founded models and stable models <ref> [26, 12] </ref>, these fall well short of matching the efficiency of classical procedural solutions, such as, say, algorithms that find shortest paths in graphs. In general, it is known that determining whether a program has a stable model is NP-complete [19]. <p> Since ground M (P ) is a positive program, it has a unique minimal model. A model M of P is said to be stable when M is also the minimum model of ground M (P ) <ref> [12] </ref>. A given program can have one or more stable (total) model, or possibly none. Positive programs, locally stratified programs [22] and weakly stratified programs [23] are among those that have exactly one stable model. Let I be an interpretation for a program P .
Reference: [13] <author> Giannotti F., D. Pedreschi, D. Sacca, and C. Zaniolo. </author> <title> Nondeterminism in deductive databases. </title> <booktitle> In Proc. 2nd Int. Conf. on Deductive and Object-Oriented Databases, </booktitle> <year> 1991. </year>
Reference-contexts: Let P be a Datalog program with choice constructs, we denote with f oe (P ) the program obtained by rewriting of the choice rules as above. In general, the program f oe (P ) generated by the transformation discussed above has the following properties <ref> [13] </ref>: * f oe (P ) has one or more total stable models. * The chosen atoms in each stable model of f oe (P ) obey the FDs defined by the choice goals. The stable models of f oe (P ) are called choice models for P . <p> power of the choice construct has been studied in [14, 10], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here <ref> [13] </ref>). For instance, it has been shown in [13], that the task performed in Example 1 cannot be performed by positive programs with static choice or the witness operator [2]. Example 2. Rooted spanning tree. <p> in [14, 10], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here <ref> [13] </ref>). For instance, it has been shown in [13], that the task performed in Example 1 cannot be performed by positive programs with static choice or the witness operator [2]. Example 2. Rooted spanning tree. <p> For logic programs with infinite Herbrand universe, an additional assumption of fairness is needed to ensure completeness. As customary for database queries, computational complexity is evaluated with respect to the size of the database. Theorem 2. <ref> [13] </ref> Let P be a choice Datalog program. <p> It is therefore of interest to explore specializations of this concept that trade nondeterministic completeness (which is only of abstract interest to a programmer) in return for very concrete benefits, such as expressive power and performance. For instance, in the specialization called Eager Choice <ref> [13] </ref>, a maximal I is used in Equation 2. This results in a significant increase in expressive power , as demonstrated by the fact that negation can be emulated by eager choice [13, 14]. <p> For instance, in the specialization called Eager Choice [13], a maximal I is used in Equation 2. This results in a significant increase in expressive power , as demonstrated by the fact that negation can be emulated by eager choice <ref> [13, 14] </ref>.
Reference: [14] <author> Giannotti F., D. Pedreschi, C. Zaniolo, </author> <title> Semantics and Expressive Power of Non-Deterministic Constructs in Deductive, </title> <type> Technical Report C96-04, </type> <institution> Istituto CNUCE, Pisa,1996, </institution> <note> submitted for publication. </note>
Reference-contexts: This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity [4, 1]. The expressive power of the choice construct has been studied in <ref> [14, 10] </ref>, where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here [13]). <p> Therefore, we have that, for any interpretation I of f oe (P ): T foe (P ) (I) = T P D (I) [ T P C (I): Following <ref> [14] </ref> we can now introduce a general operator for computing nondeterministic fixpoints of choice programs. Definition 1. <p> For instance, in the specialization called Eager Choice [13], a maximal I is used in Equation 2. This results in a significant increase in expressive power , as demonstrated by the fact that negation can be emulated by eager choice <ref> [13, 14] </ref>.
Reference: [15] <author> P. Helmann, B.M.E. Moret, and H.D. Shapiro. </author> <title> An Exact Characterization of Greedy Structures. </title> <journal> Siam J. Discrete Math., Vo. </journal> <volume> 6, No. 2, </volume> <pages> pages 274-283, </pages> <year> 1993. </year>
Reference-contexts: This entails simple declarative formulations and nearly optimal executions for large classes of problems, including those solvable using greedy algorithms. Greedy algorithms <ref> [16, 15] </ref> are those that solve a class of optimization problems, using a control structure of a single loop, where, at each iteration step some element judged the `best' at that stage is chosen and it is added to the solution.
Reference: [16] <author> Korte B. and L. Lovasz. </author> <title> Greedoids a structural framework for the greedy algorithm. </title> <editor> In W. R. Pulleyblank, editor, </editor> <booktitle> Progress in Combinatorial Optimization, </booktitle> <pages> pages 221-243. </pages> <publisher> Academic Press, </publisher> <year> 1984. </year>
Reference-contexts: This entails simple declarative formulations and nearly optimal executions for large classes of problems, including those solvable using greedy algorithms. Greedy algorithms <ref> [16, 15] </ref> are those that solve a class of optimization problems, using a control structure of a single loop, where, at each iteration step some element judged the `best' at that stage is chosen and it is added to the solution.
Reference: [17] <author> Krishnamurthy R. and S. Naqvi. </author> <title> Non-deterministic choice in Datalog. </title> <booktitle> In Proceedings of the 3rd International Conference on Data and Knowledge Bases, </booktitle> <year> 1988. </year>
Reference-contexts: The expressive power of the choice construct has been studied in [14, 10], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [2], and the original version of choice proposed in <ref> [17] </ref>, which is called static-choice, to distinguish from the dynamic choice used here [13]). For instance, it has been shown in [13], that the task performed in Example 1 cannot be performed by positive programs with static choice or the witness operator [2]. Example 2. Rooted spanning tree.
Reference: [18] <author> Ludasher W., W. May, and G. Lausen. </author> <title> Nested Transactions in a Logical Language for Active Rules. </title> <booktitle> Proc. Int. Workshop on Logic in Databases, </booktitle> <address> San Miniato, </address> <year> 1996, </year> <pages> pages 196-222. </pages>
Reference-contexts: While the unrestricted use of negation in recursive predicates leads to well-known semantics and implementation problems [20], recently there have been introduced 10 classes of programs, such as XY-stratification [28, 29], and the closely related notion of explicitly stratifiable programs [?], and Statelog <ref> [18] </ref>, which yield locally stratified programs that are easy to recognize and implement. Furthermore, as we shall see later, these programs can be extended with choice without compromising their virtues.
Reference: [19] <author> Marek W., M. Truszczynski. </author> <title> Autoepistemic Logic. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 588-619, </pages> <year> 1991. </year>
Reference-contexts: In general, it is known that determining whether a program has a stable model is NP-complete <ref> [19] </ref>. Therefore, in this paper we propose a different approach: while, at the semantic level, we strictly adhere to the formal declarative semantics of logic programs with negation, we also allow the use of extended non-monotonic constructs with first order semantics to facilitate the task of programmers and compilers alike. <p> the data complexity of computing a stable model for P is polynomial time. 2 Therefore, while finding a stable model for a Datalog program with negated goals is, assuming P 6= N P , in general exponential (checking if a Datalog program with negation admits a stable model is NP-complete <ref> [19] </ref>), for a choice Datalog program, P , the computation of one of the stable models for f oe (P ) can be performed in polynomial time using the Choice Fixpoint Computation.
Reference: [20] <author> Marek W., and M. Truszczynski, </author> <title> Nonmonotonic Logic|context dependent reasoning Springer-Verlag, </title> <year> 1993. </year>
Reference-contexts: While the unrestricted use of negation in recursive predicates leads to well-known semantics and implementation problems <ref> [20] </ref>, recently there have been introduced 10 classes of programs, such as XY-stratification [28, 29], and the closely related notion of explicitly stratifiable programs [?], and Statelog [18], which yield locally stratified programs that are easy to recognize and implement.
Reference: [21] <author> Papadimitriou C., K. Steiglitz, </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <address> En-glewood Cliff, N.J., </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: of a relation in decreasing order. succ (root; root): succ (X; Y) succ ( ; X); d (Y); choice-most ((X); (Y)); choice ((Y); (X)): 2 Greedy algorithms often provide efficient approximate solutions to NP-complete prob-lems; the following algorithm yields heuristically effective approximations of optimal solutions for the traveling salesperson problem <ref> [21] </ref>. Example 8. Greedy TSP. Given a complete undirected graph, the greedy approximate solution for the Traveling Salesman Problem (TSP) can be easily derived from the Hamilto-nian path problem of Example 4 since on complete graph every simple path is hamiltonian.
Reference: [22] <author> Przymusinski T., </author> <title> On the declarative and procedural semantics of stratified deductive databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <address> Morgan-Kaufman, Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: A model M of P is said to be stable when M is also the minimum model of ground M (P ) [12]. A given program can have one or more stable (total) model, or possibly none. Positive programs, locally stratified programs <ref> [22] </ref> and weakly stratified programs [23] are among those that have exactly one stable model. Let I be an interpretation for a program P . <p> Let Q denote a program that is stratified or locally stratified; then, let ground j (Q) (ground j fl (Q)) denote the clauses in ground (Q) with head in the j-th stratum (stratums j). Then the well-founded model for Q which is also its unique stable model <ref> [22] </ref>, can be computed as follows: Procedure 1. Iterated Fixpoint for (locally) stratified programs. Input: Locally stratified program Q. Output: Set of atoms M ! .
Reference: [23] <author> Przymusinska A. and T. Przymusinski. </author> <title> Weakly Perfect Model Semantics for Logic Programs. </title> <booktitle> In Proceedings of the Fifth Intern. Conference on Logic Programming, </booktitle> <pages> pages 1106-1122, </pages> <year> 1988. </year>
Reference-contexts: A model M of P is said to be stable when M is also the minimum model of ground M (P ) [12]. A given program can have one or more stable (total) model, or possibly none. Positive programs, locally stratified programs [22] and weakly stratified programs <ref> [23] </ref> are among those that have exactly one stable model. Let I be an interpretation for a program P .
Reference: [24] <author> Sacca D. and C. Zaniolo. </author> <title> Stable models and non-determinism in logic programs with negation. </title> <booktitle> Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 205-217, </pages> <year> 1990. </year>
Reference-contexts: In general, X can be a vector of variables | possibly an empty one denoted by "( )" | and Y is a vector of one or more variables. As shown in <ref> [24] </ref> the formal semantics of the construct can be given in terms of stable model semantics as follows.
Reference: [25] <author> Ullmann J. F., </author> <booktitle> Principles of Data and Knowledge-Base Systems. </booktitle> <volume> Vol 1 & 2, </volume> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference: [26] <author> Van Gelder A., K.A. Ross, and J.S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: Unfortunately, the computational problems remain largely unsolved; while various approaches have been fl Work partially supported by ECUS033 and NSF Grant IRI-9314905 1 proposed to more effective computations of well-founded models and stable models <ref> [26, 12] </ref>, these fall well short of matching the efficiency of classical procedural solutions, such as, say, algorithms that find shortest paths in graphs. In general, it is known that determining whether a program has a stable model is NP-complete [19].
Reference: [27] <author> Zaniolo C., </author> <title> Intelligent Databases: Old Challenges and New Opportunities, </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1, </volume> <pages> 271-292, </pages> <publisher> Kluwer Academic, </publisher> <year> 1992. </year>
Reference: [28] <author> Zaniolo, C., N. Arni, K. Ong, </author> <title> Negation and Aggregates in Recursive Rules: the LDL++ Approach, </title> <booktitle> Proc. 3rd Int. Conf. on Deductive and O-O DBs, </booktitle> <address> DOOD-93, Phoenix, AZ, </address> <month> Dec 6-8, </month> <year> 1993. </year>
Reference-contexts: While the unrestricted use of negation in recursive predicates leads to well-known semantics and implementation problems [20], recently there have been introduced 10 classes of programs, such as XY-stratification <ref> [28, 29] </ref>, and the closely related notion of explicitly stratifiable programs [?], and Statelog [18], which yield locally stratified programs that are easy to recognize and implement. Furthermore, as we shall see later, these programs can be extended with choice without compromising their virtues. <p> issues: (i) are these programs well-formed from a semantic viewpoint, and (ii) (if they are semantically well-formed, e.g., have a stable model semantics) are they amenable to efficient implementation? Both these questions receive a positive answer, due to the particular syntactic structure of these programs that is known as XY-stratification <ref> [28] </ref>. XY-stratification is a special form of local stratification induced by particular structure of the temporal argument in the recursive predicates. This property can be checked on the basis of the syntax of the rules, thus it is independent of the extensional database [28] and ensures very efficient implementations. <p> these programs that is known as XY-stratification <ref> [28] </ref>. XY-stratification is a special form of local stratification induced by particular structure of the temporal argument in the recursive predicates. This property can be checked on the basis of the syntax of the rules, thus it is independent of the extensional database [28] and ensures very efficient implementations. The well founded model of a stratified program or a locally stratified program can be computed using the iterated fixpoint procedure discussed next. <p> Therefore unrestricted locally stratified programs cannot be allowed as such in practical computations. Thus, we will restrict our attention to a particular form of local stratification, called of XY-stratification, which can be recognized at compile time, and also yields very efficient executions <ref> [28] </ref>. We will now introduce the notion of XY-stratification and in the next section extend it in the presence of choice goals.
Reference: [29] <author> Zaniolo C., S. Ceri, C. Faloutsos, V.S. Subrahmanian and R. Zicari, </author> <title> Advanced Database Systems, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1997. </year> <month> 22 </month>
Reference-contexts: While the unrestricted use of negation in recursive predicates leads to well-known semantics and implementation problems [20], recently there have been introduced 10 classes of programs, such as XY-stratification <ref> [28, 29] </ref>, and the closely related notion of explicitly stratifiable programs [?], and Statelog [18], which yield locally stratified programs that are easy to recognize and implement. Furthermore, as we shall see later, these programs can be extended with choice without compromising their virtues. <p> The iterated fixpoint computation provides a general approach to the computation of the well-founded model for a locally stratified program. For an XY-stratified program P , this computation specializes into the following <ref> [29] </ref>: Procedure 2. Stable model for XY-stratified programs. Input: XY-stratified program P . Output: Set of atoms. Initialize: Set S = ;, set T = 0 and insert the fact counter (T).
References-found: 29

