URL: http://www.cs.mu.oz.au/tr_db/mu_97_23.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Termination Analysis for Logic Programs  
Author: Chris Speirs 
Date: October 8, 1997  
Abstract: I survey termination analysis of logic programs with particular attention to methods for automatically proving termination. I introduce the central concepts of automatic termination analysis and give an overview of the research on other types of termination analysis. I describe the main approaches covered in the literature and compare the accuracy and efficiency of each of them.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Henri E. Bal and Dick Grune. </author> <title> Programming Language Essentials. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Throughout this thesis, I will assume that the reader is familiar with logic programs, and the syntax of Prolog. For an introduction to logic programs and Prolog, I refer the reader to <ref> [1] </ref>. The structure of this paper is as follows. The next section presents an overview of the different areas of research into termination analysis and explains which areas will be covered in more detail. Section 3 presents some examples of termination analysis as well as defining some relevant concepts.
Reference: [2] <author> Marc Bezem. </author> <title> Strong termination of logic programs. </title> <journal> Journal of Logic Programming, </journal> 15(1&2):79-98, 1992. 
Reference-contexts: The following result is due to Bezem <ref> [2] </ref> 5 Theorem 4.3 A program P is recurrent, if and only if, it is terminating.
Reference: [3] <author> A. Bossi, N. Cocco, and M. Fabris. </author> <title> Proving termination of logic programs by exploiting term properties. </title> <editor> In S. Abramsky and T. S. E. Maibaum, editors, </editor> <booktitle> Proc. TAPSOFT'91, </booktitle> <volume> vol. 2, </volume> <booktitle> Lecture Notes in Computer Science 494, </booktitle> <pages> pages 153-180. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Later on, Bossi, Cocco and Fabris introduced semi-linear norms <ref> [3] </ref> which are useful for handling partially instantiated data structures. Definition 3.2 ( semi-linear norm ) Let T be a set of terms.
Reference: [4] <author> A. Bossi, N. Cocco, and M. Fabris. </author> <title> Typed norms. </title> <editor> In B. Krieg-Bruckner, editor, </editor> <booktitle> Proc. ESOP'92, Lecture Notes in Computer Science 582, </booktitle> <pages> pages 73-92. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: These relationships are often called inter-argument relations. The second then uses this information to prove the termination of as many predicates as possible. These two sections are quite independent. In fact a number of papers have been written which only investigate the first part of finding inter-argument relations <ref> [4, 5] </ref>, whereas some others only investigate the second part [14]. 3.3 Norms Norms are used to associate a size with various terms. They are used to decide whether an argument is rigid and they are also used to determine how the sizes of different variables relate to each other.
Reference: [5] <author> Alexander Brodsky and Yehoshua Sagiv. </author> <title> Inference of inequality constraints in logic programs (extended abstract). </title> <booktitle> In Proc. Tenth ACM SIGACT-SIGMOD-SIGART Symp. Principles of Database Systems, </booktitle> <pages> pages 227-240. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: These relationships are often called inter-argument relations. The second then uses this information to prove the termination of as many predicates as possible. These two sections are quite independent. In fact a number of papers have been written which only investigate the first part of finding inter-argument relations <ref> [4, 5] </ref>, whereas some others only investigate the second part [14]. 3.3 Norms Norms are used to associate a size with various terms. They are used to decide whether an argument is rigid and they are also used to determine how the sizes of different variables relate to each other. <p> As it is used at runtime, Ullman and Van Gelder's algorithm is very efficient 7 Head Body Recursive Call Permute1 Permute2 Delete3 Permute2Permute1 Delete1 Delete2 but not very accurate. Brodsky and Sagiv <ref> [5] </ref> investigated the use of disjunctions of constraints, which can significantly improve accuracy of the analysis but does introduce some problems as some predicates need an infinite number of constraints to accurately describe the relationships between various arguments.
Reference: [6] <author> Danny De Schreye and Stefaan Decorte. </author> <title> Termination of logic programs: The never-ending story. </title> <journal> Journal of Logic Programming, </journal> 19/20:199-260, 1994. 
Reference-contexts: For a very detailed survey of research into termination analysis, I refer the reader to the paper by De Schreye and Decorte <ref> [6] </ref>. Although not very recent, it does cover essentially all of the research that was carried out before 1994, and provides an excellent starting point for further research.
Reference: [7] <author> Stefaan Decorte and Danny De Schreye. </author> <title> Demand-driven and constraint-based automatic left-termination analysis for logic programs. </title> <editor> In L. Naish, editor, </editor> <booktitle> Proceedings of the 1997 International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Definition 3.4 ( term-size norm ) ktk = 0, if t is a constant or if t is a variable ktk = 1 + i=1 kt i k, if t = f (t 1 :::t n ) In their recent paper, Decorte and De Schreye <ref> [7] </ref> define an even more general norm: Definition 3.5 ( generalized semi-linear norm ) Let T be a set of terms. <p> Given that kY k cannot be negative, this inequality proves that kYsk &lt; kXsk, so permute is guaranteed to terminate. Plumers method has been improved on by a number of researchers. Quite recently Decorte and De Schreye <ref> [7] </ref> have introduced the generalised semi-linear norm which was covered in section 3.3. Speirs, Somogyi and Stndergaard [15] made two improvements.
Reference: [8] <author> Gerhard Groger and Lutz Plumer. </author> <title> Handling of mutual recursion in automatic termination proofs for logic programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int. Conf. Symp. Logic Programming, </booktitle> <pages> pages 336-350. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Therefore, Plumers algorithm can only prove termination of the transformed program. It is always possible to satisfy requirement 3, but this can have the unfortunate side effect of makeing proof of termination more difficult. Two years later, Groger and Plumer <ref> [8] </ref> extended the method to include handling of mutual recursion. This newer algorithm is also substantially more efficient.
Reference: [9] <author> Fergus Henderson, Thomas Conway, Zoltan Somogyi, and David Jeffery. </author> <title> The Mercury language reference manual. </title> <type> Technical Report 96/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1996. </year> <note> Available from http://www.cs.mu.oz.au/mercury. </note>
Reference-contexts: The mode of a predicate can either be found by using mode analysis before termiantion analysis is run, or the mode can be specified as input to the termination analyser. Throughout this thesis I will specify the mode of a predicate by using the syntax of Mercury <ref> [9] </ref>. For example a mode of append is specified using :- mode append (in, in, out). This declaration states that the first 2 arguments of append will be ground, and the last argument will be free when append is called.
Reference: [10] <author> Naomi Lindenstrauss and Yehoshua Sagiv. </author> <title> Automatic termination analysis of logic programs (with detailed experimental results), </title> <note> 1997. http://www.cs.huji.ac.il/~naomil; Shorter version in L. </note> <editor> Naish, editor, </editor> <booktitle> Proceedings of the 1997 International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: It would be interesting to analyse the effect of varying the norm on the accuracy of termination analysis. So far, it seems that the choice of norm has very little effect on the accuracy of algorithms <ref> [10, 15] </ref>. Using a generalised norm presents a problem when analysing large programs as the choice of norm must not change throughout the analysis. <p> Brodsky and Sagiv [5] investigated the use of disjunctions of constraints, which can significantly improve accuracy of the analysis but does introduce some problems as some predicates need an infinite number of constraints to accurately describe the relationships between various arguments. Recently Lindenstrauss and Sagiv <ref> [10] </ref> implemented an automatic termination analyser which implements the algorithm described above. 5 Examples, and How the Analyses Apply 5.1 Permute Consider the program: perm ([],[]). perm (L,[H|T]) :- append (V,[H|U],L), append (V,U,W), perm (W,T). append ([],Y,Y). append ([H|X],Y,[H|Z]) :- append (X,Y,Z).
Reference: [11] <author> K. Morris, J. D. Ullman, and A. Van Gelder. </author> <title> Design overview of the NAIL! system. </title> <booktitle> In Proceedings of the 3rd International Conference on Logic Programming, </booktitle> <pages> pages 554-568. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Ullman and Van Gelder [16] were one of the first researchers to use monotonicity constraints. Their termination analysis is designed to be used with the NAIL! system. The NAIL! system is a so-called "knowledge-base management system" which applies logic rules to a large database <ref> [11] </ref>. The NAIL! system chooses an execution strategy at runtime and the termination analysis is used to help choose the best execution strategy.
Reference: [12] <author> Lee Naish. </author> <title> Automating control of logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(3) </volume> <pages> 167-183, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: 1 Introduction The study of termination analysis for logic programs began in 1985 when Naish investigated the question of automatically generating control for Prolog programs <ref> [12] </ref>. A basic tenet of this work is that development of a logic program is best divided into two steps. Firstly, to generate a correct logic specification of the problem, then, to add control to this to ensure that the program is executed efficiently.
Reference: [13] <author> Lutz Plumer. </author> <title> Termination Proofs for Logic Programs, </title> <booktitle> volume 446 of Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: There have been a number of different definitions of norms proposed in the literature. As time progresses, the tendency is to use more and more general norms for proving termination. One of the first norms to be proposed was the linear norm <ref> [13] </ref>, which is defined as Definition 3.1 ( linear norm ) Let T be a set of terms. <p> Bezem proves that according to this level-mapping A is recurrent. The proof basically follows from the fact that any atom B i which occurs in the clause which defines A has a proof-tree which is a proper subtree of the proof-tree of A. 4.2 Plumer's Approach Plumers Phd thesis <ref> [13] </ref> encouraged a lot of work in the area of termination analysis. His thesis was one of the first to provide an algorithm for automatically proving termination of Prolog programs. His algorithm was implemented by Schmidt, and the results of it are included in Plumer's thesis. <p> The best constraint that can be created using Plumers algorithm is. ksplit2 1 k ksplit2 2 k + ksplit2 3 k This constraint is no better than the constraint that than be created for normal mergesort, so the modification has not helped Plumers algorithm prove termination. 5.4 Unfolded Mergesort Plumer <ref> [13] </ref> made an extensive investigation into the use of unfolding in proving termination. mergesort is one example of where unfolding allows proof of termination. mergesort ([],[]). mergesort ([X],[X]). mergesort ([X,Y|Xs],Ys) :- split (Xs,X1s,X2s), mergesort ([X|X1s],Y1s), mergesort ([Y|X2s],Y2s), merge (Y1s,Y2s,Ys). Here we have unfolded split twice. <p> Although not very recent, it does cover essentially all of the research that was carried out before 1994, and provides an excellent starting point for further research. Another useful reference is Plumers Phd thesis <ref> [13] </ref> which details some program transformations that can be used to improve termination properties as well as describing Plumer's algorithm in detail. This thesis introduced the problem of termination analysis for logic programs and gave an overview of the topic as a whole.
Reference: [14] <author> Kirack Sohn and Allen Van Gelder. </author> <title> Termination detection in logic programs using argument sizes (extended abstract). </title> <booktitle> In Proc. Tenth ACM SIGACT-SIGMOD-SIGART Symp. Principles of Database Systems, </booktitle> <pages> pages 216-226. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: These two sections are quite independent. In fact a number of papers have been written which only investigate the first part of finding inter-argument relations [4, 5], whereas some others only investigate the second part <ref> [14] </ref>. 3.3 Norms Norms are used to associate a size with various terms. They are used to decide whether an argument is rigid and they are also used to determine how the sizes of different variables relate to each other. <p> This subset is also calculated using a fixed-point iteration. Sohn and Van Gelder <ref> [14] </ref> also modified the second phase of the analysis. Instead of trying to find a subset of input arguments which strictly decrease in size, they try to find a non-negative linear combination of the input arguments which is guaranteed to decrease in size.
Reference: [15] <author> Chris Speirs, Zoltan Somogyi, and Harald Stndergaard. </author> <title> Termination analysis for mercury. </title> <editor> In P. Van Hentenryck, editor, </editor> <title> To appear in Static Analysis: </title> <booktitle> Proceedings of the 4th International Symposium, Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: It would be interesting to analyse the effect of varying the norm on the accuracy of termination analysis. So far, it seems that the choice of norm has very little effect on the accuracy of algorithms <ref> [10, 15] </ref>. Using a generalised norm presents a problem when analysing large programs as the choice of norm must not change throughout the analysis. <p> Plumers method has been improved on by a number of researchers. Quite recently Decorte and De Schreye [7] have introduced the generalised semi-linear norm which was covered in section 3.3. Speirs, Somogyi and Stndergaard <ref> [15] </ref> made two improvements. <p> These recent papers have shown that termination analysis is now at a stage where it is accurate and efficient enough to be useful not only as input to an automatic control generator or optimizer but also as feedback to the programmer, to give warnings of possible non-termination <ref> [15] </ref>. For a very detailed survey of research into termination analysis, I refer the reader to the paper by De Schreye and Decorte [6].
Reference: [16] <author> Jeffrey D. Ullman and Allen Van Gelder. </author> <title> Efficient tests for top-down termination of logical rules. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 345-373, </pages> <year> 1988. </year> <month> 11 </month>
Reference-contexts: Most of the automatic termination analyses have been based around static analysis, but some of them have investigated the problem of catching non-termination at runtime <ref> [16] </ref>. Manual termination analyses are used to give insight into the problem of termination analysis. The efficiency of the analysis is in general not very important. Instead the algorithm should attempt to clarify what is required to prove termination of a predicate. <p> From the graph, it is clear that the only path from the first argument of permute in the head to the corresponding argument in the recursive call contains an arc. Therefore permute is guaranteed to terminate. Ullman and Van Gelder <ref> [16] </ref> were one of the first researchers to use monotonicity constraints. Their termination analysis is designed to be used with the NAIL! system. The NAIL! system is a so-called "knowledge-base management system" which applies logic rules to a large database [11].
References-found: 16

