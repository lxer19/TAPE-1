URL: http://www.cs.brown.edu/people/pck/Papers/simquery.ps
Refering-URL: http://www.cs.brown.edu/people/pck/publications.html
Root-URL: http://www.cs.brown.edu/
Email: Email: dgk@cs.brown.edu and pck@cs.brown.edu.  
Phone: Tel: 1-401-863-7647. Fax: 1-401-863-7657.  
Title: On Similarity Queries for Time-Series Data: Constraint Specification and Implementation  
Author: Dina Q Goldin and Paris C Kanellakis 
Address: PO Box 1910, Providence RI 02912, USA.  
Affiliation: Department of Computer Science, Brown University  
Abstract: Constraints are a natural mechanism for the specification of similarity queries on time-series data. However, to realize the expressive power of constraint programming in this context, one must provide the matching implementation technology for efficient indexing of very large data sets. In this paper, we formalize the intuitive notions of exact and approximate similarity between time-series patterns and data. Our definition of similarity extends the distance metric used in [2, 7] with in-variance under a group of transformations. Our main observation is that the resulting, more expressive, set of constraint queries can be supported by a new indexing technique, which preserves all the desirable properties of the indexing scheme proposed in [2, 7].
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aho. </author> <title> Algorithms for Finding Patterns in Strings. Handbook of TCS., </title> <editor> J. Van Leeuwen editor, </editor> <title> volume A, chapter 5, </title> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: A wide range of algorithms has been developed for internal (i.e., in-core) versions of this question <ref> [1] </ref> for strings over an alphabet or for values over bounded discrete domains.
Reference: 2. <author> R. Agrawal, C. Faloutsos, A. Swami. </author> <title> Efficient Similarity Search in Sequence Databases. </title> <booktitle> FODO Conf., </booktitle> <address> Evanston, Ill., </address> <month> Oct. </month> <year> 1993 </year>
Reference-contexts: However, any proposal of such linguistic facilities must be supported by indexing (i.e., be implementable with reasonable I/O efficiency) for very large data sets. Examples of recent database research towards this goal include <ref> [2, 7, 18] </ref>. A most basic problem in this area is First-Occurrence Subsequence Matching, defined as follows: given a query sequence Q of length n and a much longer data sequence S of length N , find the first occurrence of a contiguous subsequence within S that matches Q exactly. <p> The All-Occurrences Approximate Matching problems (either Subsequence or Whole-Sequence) are defined as before, but with "match approximately within tolerance *" instead of "match exactly". For external solutions to the All-Occurrence Whole-Sequence Approximate version, we refer to <ref> [2, 18] </ref>; for the All-Occurrence Subsequence Approximate version, we refer to [7]. A further characteristic of time-series data that is used to advantage, is that they have a skewed energy spectrum, to use the terminology borrowed from Discrete Signal Processing [16]. <p> We show this using a new indexing technique, which preserves all the desirable properties of the indexing scheme proposed in <ref> [2, 7] </ref>. In Section 2, we provide a semantics for similarity querying where we use the similarity distance between Q and S (defined in Section 2.2) as the distance metric. <p> In Section 3, we show that the semantics of Section 2.2 has several desirable properties, such as updateability and well-behaved trails, which allow us to provide efficient implementations for similarity querying, both in the internal and external query setting. We first adapt the criteria put forth in <ref> [2, 7] </ref> (Section 3.1) and satisfy them using fingerprints of the normal form (Section 3.2). We then argue that fingerprints are incrementally computable (Section 3.3), can be used ala Rabin-Karp [14] for internal searching (Section 3.4), and most importantly external indexing (Section 3.5). <p> We now define the fingerprint function F as well as the fingerprint distance function D F . These definitions are similar to the ones used for Approximate Matching in <ref> [2] </ref> and [7]. <p> As shown in <ref> [2] </ref>, 2-3 coefficients are usually sufficient to provide good accuracy. <p> In addition, we have shown that the fingerprint of <ref> [2] </ref> for time-series approximate matching (without similarity) is also updateable. 3.4 Internal Algorithms In this section, we sketch out the internal implementation of similarity queries, omitting the details that can be found in the works we reference.
Reference: 3. <author> M. Baudinet, M. Niezette, P. Wolper. </author> <title> On the Representation of Infinite Temporal Data and Queries. </title> <booktitle> Proc. 10th ACM PODS, </booktitle> <pages> 280-290, </pages> <year> 1991. </year>
Reference-contexts: This translation also clarifies the relationship of the problem as defined in Section 1.2 with the semantics of Section 2.2. The syntax could be embedded in most constraint logic programming languages [5, 6, 10] or constraint query languages <ref> [3, 4, 11, 12] </ref>. This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see [4, 13]) and the main motivation for this work. <p> Posssible extensions involve more powerful similarity queries and different distance functions; also indexing of time-series data that is represented using constraints (see <ref> [3, 11] </ref>). As with a generalized version of any problem, there is a potential trade-off between a gain in expressibility and a decrease in performance.
Reference: 4. <author> A. Brodsky, J. Jaffar, M.J. Maher. </author> <title> Toward Practical Constraint Databases. </title> <booktitle> Proc. 19th VLDB, </booktitle> <pages> 322-331, </pages> <year> 1993. </year>
Reference-contexts: This translation also clarifies the relationship of the problem as defined in Section 1.2 with the semantics of Section 2.2. The syntax could be embedded in most constraint logic programming languages [5, 6, 10] or constraint query languages <ref> [3, 4, 11, 12] </ref>. This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see [4, 13]) and the main motivation for this work. <p> This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see <ref> [4, 13] </ref>) and the main motivation for this work.
Reference: 5. <author> A. Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> CACM, </journal> <volume> 33:7:69-90, </volume> <year> 1990. </year>
Reference-contexts: We show how various query variations can be expressed and translated into the internal representation of Section 2. This translation also clarifies the relationship of the problem as defined in Section 1.2 with the semantics of Section 2.2. The syntax could be embedded in most constraint logic programming languages <ref> [5, 6, 10] </ref> or constraint query languages [3, 4, 11, 12]. This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see [4, 13]) and the main motivation for this work.
Reference: 6. <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> Proc. Fifth Generation Computer Systems, </booktitle> <address> Tokyo Japan, </address> <year> 1988. </year>
Reference-contexts: We show how various query variations can be expressed and translated into the internal representation of Section 2. This translation also clarifies the relationship of the problem as defined in Section 1.2 with the semantics of Section 2.2. The syntax could be embedded in most constraint logic programming languages <ref> [5, 6, 10] </ref> or constraint query languages [3, 4, 11, 12]. This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see [4, 13]) and the main motivation for this work.
Reference: 7. <author> C. Faloutsos, M. Ranganathan, Y. Manolopoulos. </author> <title> Fast Subsequence Matching in Time-Series Databases. </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <pages> pp. 419-429, </pages> <month> May </month> <year> 1994 </year>
Reference-contexts: However, any proposal of such linguistic facilities must be supported by indexing (i.e., be implementable with reasonable I/O efficiency) for very large data sets. Examples of recent database research towards this goal include <ref> [2, 7, 18] </ref>. A most basic problem in this area is First-Occurrence Subsequence Matching, defined as follows: given a query sequence Q of length n and a much longer data sequence S of length N , find the first occurrence of a contiguous subsequence within S that matches Q exactly. <p> The All-Occurrences Approximate Matching problems (either Subsequence or Whole-Sequence) are defined as before, but with "match approximately within tolerance *" instead of "match exactly". For external solutions to the All-Occurrence Whole-Sequence Approximate version, we refer to [2, 18]; for the All-Occurrence Subsequence Approximate version, we refer to <ref> [7] </ref>. A further characteristic of time-series data that is used to advantage, is that they have a skewed energy spectrum, to use the terminology borrowed from Discrete Signal Processing [16]. <p> Analogous definitions apply for All-Occurrences Exact Similarity problems (either Subsequence or Whole-Sequence). When T is restricted to be the identity transformation, the various similarity problems become the matching problems of the last section. In this sense, our work is a generalization of the work of <ref> [7] </ref>. This generalization is in the direction of [8], which discusses translation and distortion transformations but does not provide the guarantees of [7] and of our indexing scheme. A general framework for similarity queries is described in [9]. Our work happens to be (an efficiently solvable) special case. <p> In this sense, our work is a generalization of the work of <ref> [7] </ref>. This generalization is in the direction of [8], which discusses translation and distortion transformations but does not provide the guarantees of [7] and of our indexing scheme. A general framework for similarity queries is described in [9]. Our work happens to be (an efficiently solvable) special case. <p> We show this using a new indexing technique, which preserves all the desirable properties of the indexing scheme proposed in <ref> [2, 7] </ref>. In Section 2, we provide a semantics for similarity querying where we use the similarity distance between Q and S (defined in Section 2.2) as the distance metric. <p> In Section 3, we show that the semantics of Section 2.2 has several desirable properties, such as updateability and well-behaved trails, which allow us to provide efficient implementations for similarity querying, both in the internal and external query setting. We first adapt the criteria put forth in <ref> [2, 7] </ref> (Section 3.1) and satisfy them using fingerprints of the normal form (Section 3.2). We then argue that fingerprints are incrementally computable (Section 3.3), can be used ala Rabin-Karp [14] for internal searching (Section 3.4), and most importantly external indexing (Section 3.5). <p> This is the implementation technology that is needed to support the internal representation of Section 2. Our new indexing technique combines the MBR structure of <ref> [7] </ref> with our internal representation. Many spatial data-structures can be used, for examples varieties of R-trees (see [17] for a comprehensive survey of the available external data-structures). In Section 4, we provide a constraint syntax for similarity querying. <p> We now define the fingerprint function F as well as the fingerprint distance function D F . These definitions are similar to the ones used for Approximate Matching in [2] and <ref> [7] </ref>. <p> This is due to a very simple observation: for a real sequence of length m, the there would be m n + 1 indices with 2l reals each. Such space overhead renders indexing less efficient than a direct sequential scan of the data <ref> [7] </ref>. This problem is overcome with the Minimum Bounding Rectangle (MBR) technique, introduced in [7]. This technique significantly reduces the size of the indexing structure, though introducing some false alarms in the process. Our final indexing method consists of combining the MBR technique with the spatial access approach described above. <p> Such space overhead renders indexing less efficient than a direct sequential scan of the data <ref> [7] </ref>. This problem is overcome with the Minimum Bounding Rectangle (MBR) technique, introduced in [7]. This technique significantly reduces the size of the indexing structure, though introducing some false alarms in the process. Our final indexing method consists of combining the MBR technique with the spatial access approach described above. <p> We conclude the discussion of indexing by verifying that our indexing possesses the continuity property. This is a "heuristic" statistical argument, that also applies to <ref> [7] </ref> (where continuity was assumed, but not shown). <p> As with a generalized version of any problem, there is a potential trade-off between a gain in expressibility and a decrease in performance. There should be some slow-down due to the extra keys in the new indexing scheme (as opposed to <ref> [7] </ref>) and additional slow-down may come from the false alarms generated by our fingerprinting as compared to the specialized cases (without a similarity transformation). We are examining this trade-off through performance evaluation of several versions of similarity querying.
Reference: 8. <author> H.V. Jagadish. </author> <title> A Retrieval Technique for Similar Shapes. </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <pages> pp. 208-217, </pages> <month> May </month> <year> 1991 </year>
Reference-contexts: When T is restricted to be the identity transformation, the various similarity problems become the matching problems of the last section. In this sense, our work is a generalization of the work of [7]. This generalization is in the direction of <ref> [8] </ref>, which discusses translation and distortion transformations but does not provide the guarantees of [7] and of our indexing scheme. A general framework for similarity queries is described in [9]. Our work happens to be (an efficiently solvable) special case.
Reference: 9. <author> H. V. Jagadish, A. O. Mendelzon, T. Milo. </author> <title> Similarity-Based Queries. </title> <booktitle> to appear in Proc. 14th ACM PODS, </booktitle> <year> 1995 </year>
Reference-contexts: In this sense, our work is a generalization of the work of [7]. This generalization is in the direction of [8], which discusses translation and distortion transformations but does not provide the guarantees of [7] and of our indexing scheme. A general framework for similarity queries is described in <ref> [9] </ref>. Our work happens to be (an efficiently solvable) special case. The [9] framework for similarity-based queries has three components: a pattern language P , an approximation language (they refer to it as transformation rule language), and a query language. <p> This generalization is in the direction of [8], which discusses translation and distortion transformations but does not provide the guarantees of [7] and of our indexing scheme. A general framework for similarity queries is described in <ref> [9] </ref>. Our work happens to be (an efficiently solvable) special case. The [9] framework for similarity-based queries has three components: a pattern language P , an approximation language (they refer to it as transformation rule language), and a query language. In our case, P is the set of allowable transformations on the query sequence Q. <p> In our case, the approximations are the distortions in the time-series data (i.e., the jiggling of individual points); the cost is the distance between the original sequence and the distorted one. Note that membership testing in the <ref> [9] </ref> framework is at best exponential; thus this framework is too general for our purposes. 1.3 Contributions and Overview Our main contribution is: A syntax and semantics for similarity queries, that account for approximate matching, scaling and shifting, and that have efficient indexing support.
Reference: 10. <author> J. Jaffar, J.L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> Proc. 14th ACM POPL, </booktitle> <pages> 111-119, </pages> <year> 1987. </year>
Reference-contexts: We show how various query variations can be expressed and translated into the internal representation of Section 2. This translation also clarifies the relationship of the problem as defined in Section 1.2 with the semantics of Section 2.2. The syntax could be embedded in most constraint logic programming languages <ref> [5, 6, 10] </ref> or constraint query languages [3, 4, 11, 12]. This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see [4, 13]) and the main motivation for this work.
Reference: 11. <author> F. Kabanza, J-M. Stevenne, P. Wolper. </author> <title> Handling Infinite Temporal Data. </title> <booktitle> Proc. 9th ACM PODS, </booktitle> <pages> 392-403, </pages> <year> 1990. </year>
Reference-contexts: This translation also clarifies the relationship of the problem as defined in Section 1.2 with the semantics of Section 2.2. The syntax could be embedded in most constraint logic programming languages [5, 6, 10] or constraint query languages <ref> [3, 4, 11, 12] </ref>. This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see [4, 13]) and the main motivation for this work. <p> Posssible extensions involve more powerful similarity queries and different distance functions; also indexing of time-series data that is represented using constraints (see <ref> [3, 11] </ref>). As with a generalized version of any problem, there is a potential trade-off between a gain in expressibility and a decrease in performance.
Reference: 12. <author> P. C. Kanellakis, G. M. Kuper, P. Z. Revesz. </author> <title> Constraint Query Languages. </title> <booktitle> Proc. 9th ACM PODS, </booktitle> <pages> 299-313, </pages> <year> 1990. </year> <note> Full version available as Brown Univ. Tech. Rep. CS-92-50. To appear in JCSS. </note>
Reference-contexts: This translation also clarifies the relationship of the problem as defined in Section 1.2 with the semantics of Section 2.2. The syntax could be embedded in most constraint logic programming languages [5, 6, 10] or constraint query languages <ref> [3, 4, 11, 12] </ref>. This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see [4, 13]) and the main motivation for this work.
Reference: 13. <author> P. C. Kanellakis, S. Ramaswamy, D. E. Vengroff, J. S. Vitter. </author> <title> Indexing for Data Models with Constraints and Classes. </title> <booktitle> Proc. 12th ACM PODS, </booktitle> <pages> 233-243, </pages> <year> 1993. </year>
Reference-contexts: This completes the connection between high level specification and implementation. The importance of combining high-level specification with efficient implementation is the common theme of constraint databases (e.g., see <ref> [4, 13] </ref>) and the main motivation for this work.
Reference: 14. <author> R. M. Karp and M. O. Rabin. </author> <title> Efficient Randomized Pattern-Matching Algorithms. </title> <journal> IBM J. Res. Develop., </journal> <volume> 31(2), </volume> <year> 1987 </year>
Reference-contexts: The part of this technology that is most related to our paper is the Rabin-Karp randomized linear-time algorithm <ref> [14] </ref>, which provides an efficient in-core solution based on fingerprint functions. Fingerprints are a form of sequence hashing that allow constant-time comparisons between hash values and are incrementally computable. A variant of the above problem involves finding all occurrences; this is called the All-Occurrences Subsequence Matching problem. <p> We first adapt the criteria put forth in [2, 7] (Section 3.1) and satisfy them using fingerprints of the normal form (Section 3.2). We then argue that fingerprints are incrementally computable (Section 3.3), can be used ala Rabin-Karp <ref> [14] </ref> for internal searching (Section 3.4), and most importantly external indexing (Section 3.5). This is the implementation technology that is needed to support the internal representation of Section 2. Our new indexing technique combines the MBR structure of [7] with our internal representation. <p> An efficient implementation of similarity querying cannot afford to compute D S every time for each sequence in the data set (for the Whole-Sequence case), or for each contiguous subsequence in the time-series (for the Subsequence case). Following the approach of <ref> [14] </ref>, which has gained wide acceptance, we introduce a fingerprint function F , together with a fingerprint distance metric D F . This fingerprint mechanism provides fast rejection, filtering out most of the non-similar sequences. <p> As shown in [2], 2-3 coefficients are usually sufficient to provide good accuracy. Therefore, we may assume that the length l of the fingerprint is 3. (Note that, the randomization ala Rabin-Karp <ref> [14] </ref> makes no assumptions about the spectrum.) 3.3 Updateability of Fingerprinting When computing fingerprints of all subsequences of length n for a much longer sequence of length N , the efficiency of the algorithm hinges on a property of the fingerprint that we call updateability: Given the fingerprint of a subsequence <p> The updateability results established in Section 3.3 allow us to answer the query for the in-core case with an algorithm much like that of <ref> [14] </ref>. We proceed through the sequences and the subsequences, comparing D F (F (Q); F (S)) to * i and checking ff (S) and (S) against the bounds. <p> This experimental work in progress. The existence of a fingerprint function for internal similarity querying that is a real hash function but is also distance-preserving and updateable is an interesting open question. Is there a fingerprint method that gives a provably linear performance for the Rabin-Karp algorithm <ref> [14] </ref>, either for approximate matching or for similarity querying? Can it be truly randomized for any adversary?
Reference: 15. <author> Modenov and Pakhomenko. </author> <title> Geometric Transformations, </title> <publisher> Academic Press, </publisher> <year> 1965 </year>
Reference-contexts: Fig. 1. Sequence (b) is a similarity transformation of (a). Combinations of scaling and shifting are shape-preserving transformations, known as similarity transformations in the mathematical field of Transformational Geometry <ref> [15] </ref>. We will approach the definition of similarity from this well established geometrical perspective: Let G be a set of transformations then two sets of points are similar if there exists a transformation, in G, which maps one to the other. In geometry, a transformation typically belongs to a group.
Reference: 16. <author> A.V. Oppenheim and R.W. Schafer. </author> <title> Digital Signal Processing, </title> <publisher> Prentice Hall, </publisher> <year> 1975 </year>
Reference-contexts: A further characteristic of time-series data that is used to advantage, is that they have a skewed energy spectrum, to use the terminology borrowed from Discrete Signal Processing <ref> [16] </ref>. As a result, most of the technology of information retrieval in this area is influenced by signal processing methods. 1.2 Approximately Similar Time-Series Data The database applications of interest involve queries expressing notions of "user-perceived similarity".
Reference: 17. <author> H. Samet. </author> <title> The Design and Analysis of Spatial Data Structures. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1990. </year>
Reference-contexts: This is the implementation technology that is needed to support the internal representation of Section 2. Our new indexing technique combines the MBR structure of [7] with our internal representation. Many spatial data-structures can be used, for examples varieties of R-trees (see <ref> [17] </ref> for a comprehensive survey of the available external data-structures). In Section 4, we provide a constraint syntax for similarity querying. We show how various query variations can be expressed and translated into the internal representation of Section 2.
Reference: 18. <author> P. Sheshadri, M. Livny, R. Ramakrishnan. </author> <title> Sequence Query Processing Proc. </title> <booktitle> ACM SIGMOD Conf., </booktitle> <pages> pp. </pages> <month> 430-441, </month> <title> May 1994 This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: However, any proposal of such linguistic facilities must be supported by indexing (i.e., be implementable with reasonable I/O efficiency) for very large data sets. Examples of recent database research towards this goal include <ref> [2, 7, 18] </ref>. A most basic problem in this area is First-Occurrence Subsequence Matching, defined as follows: given a query sequence Q of length n and a much longer data sequence S of length N , find the first occurrence of a contiguous subsequence within S that matches Q exactly. <p> The All-Occurrences Approximate Matching problems (either Subsequence or Whole-Sequence) are defined as before, but with "match approximately within tolerance *" instead of "match exactly". For external solutions to the All-Occurrence Whole-Sequence Approximate version, we refer to <ref> [2, 18] </ref>; for the All-Occurrence Subsequence Approximate version, we refer to [7]. A further characteristic of time-series data that is used to advantage, is that they have a skewed energy spectrum, to use the terminology borrowed from Discrete Signal Processing [16].
References-found: 18

