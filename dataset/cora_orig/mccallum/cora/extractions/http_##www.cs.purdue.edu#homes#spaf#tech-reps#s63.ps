URL: http://www.cs.purdue.edu/homes/spaf/tech-reps/s63.ps
Refering-URL: http://www.cs.purdue.edu/homes/spaf/wwwpub/node10.html
Root-URL: http://www.cs.purdue.edu
Email: hsu@cs.purdue.edu  nse@l.cc.purdue.edu  spaf@cs.purdue.edu  
Phone: (317) 494-7812  (317) 494-7913  (317) 494-7825  
Title: An Experimental Approach to Statistical Mutation-Based Testing 1 SERC TR-63-P  
Author: William Hsu Mehmet Sahinoglu Eugene H. Spafford 
Date: August 25, 1992  
Address: West Lafayette, Indiana 47907  West Lafayette, Indiana 47907  West Lafayette, Indiana 47907  
Affiliation: Software Engineering Research Center Department of Computer Sciences Purdue University  Department of Statistics Purdue University  Software Engineering Research Center Department of Computer Sciences Purdue University  
Abstract: 1 An abbreviated form of this paper was presented as [11]. 2 Currently visiting Purdue University from Middle East Technical University (METU), Ankara, Turkey on a Fulbright Scholarship, support which is gratefully acknowledged. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Bai and Y. Yun. </author> <title> Optimum number of errors corrected before releasing a software system. </title> <journal> IEEE Transactions on Reliability, </journal> <volume> 37(1) </volume> <pages> 41-44, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Such mutant transformations are statically defined for a language fl and designed to expose errors frequently committed by programmers using fl. For each execution of a mutant against the test set, i (t ), exactly one of two things happens: <ref> [1] </ref> The mutant i (t ) yields different results than (t ), or [2] The mutant i (t ) yield the same results as (t ). 1 Program mutation has been well documented in the literature and will only be summarized here.
Reference: [2] <author> T. A. Budd. </author> <title> Mutation Analysis of Program Test Data. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <year> 1980. </year>
Reference-contexts: The more mutants killed by a test set, the better the measured adequacy of the test set. By proper choice of mutant operators, comprehensive testing can be performed, <ref> [2] </ref> including path coverage [10] and domain analysis. [17] By examination of unkilled mutants, testers can add new test cases to better the adequacy score of the entire test set. Mutation analysis is designed to substantiate the correctness of a program . <p> For each execution of a mutant against the test set, i (t ), exactly one of two things happens: [1] The mutant i (t ) yields different results than (t ), or <ref> [2] </ref> The mutant i (t ) yield the same results as (t ). 1 Program mutation has been well documented in the literature and will only be summarized here.
Reference: [3] <author> C. Bullard and E. H. Spafford. </author> <title> Testing experience with Mothra. </title> <booktitle> In Proceedings of 25th Southeast ACM Conference, </booktitle> <institution> Birmingham AL, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [4, 15, 9, 3, 18, 12] </ref>. 1 In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t .
Reference: [4] <author> B. J. Choi, R. A. DeMillo, E. W. Krauser, R. J. Martin, A. P. Mathur, A. J. Offutt, H. Pan, and E. H. Spafford. </author> <title> The Mothra tools set. </title> <booktitle> In Proceedings of the 22nd Hawaii International Conference on Systems and Software, </booktitle> <pages> pages 275-284, </pages> <address> Kona, Hawaii, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [4, 15, 9, 3, 18, 12] </ref>. 1 In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t . <p> The test set t can then be carried into the maintenance stage of the software life cycle. 2 On Mothra and the Stopping Rule The Mothra software testing environment <ref> [6, 5, 4] </ref> is an integrated set of tools and interfaces that support the planning, definition, preparation, execution, analysis, and evaluation of mutation-based tests of software systems.
Reference: [5] <author> R. A. DeMillo and A. J. Offutt. </author> <title> Experimental results of automatically generated adequate test sets. </title> <booktitle> In Proceedings of the Sixth Annual Pacific Northwest Software Quality Conference, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The test set t can then be carried into the maintenance stage of the software life cycle. 2 On Mothra and the Stopping Rule The Mothra software testing environment <ref> [6, 5, 4] </ref> is an integrated set of tools and interfaces that support the planning, definition, preparation, execution, analysis, and evaluation of mutation-based tests of software systems.
Reference: [6] <author> Richard A. DeMillo and Eugene H. Spafford. </author> <title> The Mothra software testing environment. </title> <booktitle> In 11th Nasa Software Engineering Laboratory Workshop. </booktitle> <institution> Goddard Space Center, </institution> <month> De-cember </month> <year> 1986. </year>
Reference-contexts: The test set t can then be carried into the maintenance stage of the software life cycle. 2 On Mothra and the Stopping Rule The Mothra software testing environment <ref> [6, 5, 4] </ref> is an integrated set of tools and interfaces that support the planning, definition, preparation, execution, analysis, and evaluation of mutation-based tests of software systems.
Reference: [7] <author> R. Govindarajalu. </author> <title> Sequential Statistical Procedures. </title> <publisher> Academic Press, </publisher> <year> 1975. </year>
Reference-contexts: 2 ); : : :; (x 1 ; : : : ; x k ), i.e. consider the sequence: f 2 (x 1 ) ; f 1 (x 1 )f 1 (x 2 ) f 2 (x 1 ) : : :f 2 (x k ) (2) Definition: The SPRT <ref> [16, 13, 7] </ref> (Test) for testing H 0 : fi = fi 1 versus H 1 : fi = fi 2 is a rule that states: 1. if k (x) &gt;= A, stop sampling and reject H 0 (accept H 1 ). 2. if k (x) &lt;= B, stop sampling and
Reference: [8] <author> W. E. Howden. </author> <title> Functional Program Testing and Analysis. </title> <publisher> McGraw-Hill, </publisher> <year> 1987. </year>
Reference-contexts: Mutations are simple changes introduced one at a time into the code being tested. These changes are derived empirically from studies of errors commonly made by programmers when translating requirements into code, although theoretical justification also can be found for their selection <ref> [8] </ref>. A mutant is killed if the execution of the mutated code against the test set distinguishes the behavior or output of the mutation from the unmutated code. The more mutants killed by a test set, the better the measured adequacy of the test set.
Reference: [9] <author> R. J. Martin. </author> <title> Using the Mothra software testing environment to ensure software quality. </title> <booktitle> In Proceedings of the IEEE National Aerospace and Electronics Conference, </booktitle> <address> Dayton, OH, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [4, 15, 9, 3, 18, 12] </ref>. 1 In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t . <p> This would be of great utility in situations where full mutation testing would be too expensive, too time consuming, or simply beyond the capabilities of the available testing software. Conventionally, a typical mutation system user must specify test requirements of the following form: <ref> [9] </ref> "I must be X% sure that Y% of the mutants of type Z are killed in unit A." Here, X% is the degree of assurance Mothra will use to perform the random selection of mutants of type Z in unit A.
Reference: [10] <author> G. Myers. </author> <title> The Art of Software Testing. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: The more mutants killed by a test set, the better the measured adequacy of the test set. By proper choice of mutant operators, comprehensive testing can be performed, [2] including path coverage <ref> [10] </ref> and domain analysis. [17] By examination of unkilled mutants, testers can add new test cases to better the adequacy score of the entire test set. Mutation analysis is designed to substantiate the correctness of a program .
Reference: [11] <author> Mehmet S . ahinoglu and Eugene H. Spafford. </author> <title> A sequential statistical procedure in mutation-based testing. </title> <booktitle> In Procedings of the 28th Reliability Spring Seminar, </booktitle> <pages> pages 127-148, </pages> <address> Boston, MA, </address> <month> April </month> <year> 1990. </year> <title> Central New England Reliability Chapter of the IEEE. </title>
Reference: [12] <author> Eugene H. Spafford. </author> <title> Extending mutation testing to find environmental bugs. </title> <journal> Software Practice and Experience, </journal> <volume> 20(2) </volume> <pages> 181-189, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [4, 15, 9, 3, 18, 12] </ref>. 1 In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t .
Reference: [13] <author> Statistics Research Group. </author> <title> Sequential Analysis of Statistical Data: Applications. </title> <publisher> Columbia University Press, </publisher> <year> 1945. </year>
Reference-contexts: 2 ); : : :; (x 1 ; : : : ; x k ), i.e. consider the sequence: f 2 (x 1 ) ; f 1 (x 1 )f 1 (x 2 ) f 2 (x 1 ) : : :f 2 (x k ) (2) Definition: The SPRT <ref> [16, 13, 7] </ref> (Test) for testing H 0 : fi = fi 1 versus H 1 : fi = fi 2 is a rule that states: 1. if k (x) &gt;= A, stop sampling and reject H 0 (accept H 1 ). 2. if k (x) &lt;= B, stop sampling and
Reference: [14] <author> Abraham Wald. </author> <title> Selected Papers in Statistics and Probability. </title> <publisher> McGraw Hill, </publisher> <year> 1945. </year>
Reference-contexts: A Type I error is mistakenly rejecting a good program as faulty. 3 Wald <ref> [14] </ref> tells us to consider the sequence of ratios 1 (x 1 ); 2 (x 1 ; x 2 ); : : :; (x 1 ; : : : ; x k ), i.e. consider the sequence: f 2 (x 1 ) ; f 1 (x 1 )f 1 (x 2
Reference: [15] <author> P. J. Walsh. </author> <title> A Measure of Test Case Completeness. </title> <type> PhD thesis, </type> <institution> Watson School of Engineering, State University of New York at Binghamton, Binghamton, </institution> <address> NY, </address> <year> 1985. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [4, 15, 9, 3, 18, 12] </ref>. 1 In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t .
Reference: [16] <author> G. B. Wetherill and K. D. Glazebrook. </author> <title> Sequential Methods in Statistics. </title> <publisher> Chapman and Hall, </publisher> <year> 1986. </year> <title> Third edition. </title> <type> 48 </type>
Reference-contexts: 2 ); : : :; (x 1 ; : : : ; x k ), i.e. consider the sequence: f 2 (x 1 ) ; f 1 (x 1 )f 1 (x 2 ) f 2 (x 1 ) : : :f 2 (x k ) (2) Definition: The SPRT <ref> [16, 13, 7] </ref> (Test) for testing H 0 : fi = fi 1 versus H 1 : fi = fi 2 is a rule that states: 1. if k (x) &gt;= A, stop sampling and reject H 0 (accept H 1 ). 2. if k (x) &lt;= B, stop sampling and
Reference: [17] <author> Lee J. White and E. K. Cohen. </author> <title> A domain strategy for computer program testing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(3) </volume> <pages> 247-257, </pages> <month> May </month> <year> 1980. </year>
Reference-contexts: The more mutants killed by a test set, the better the measured adequacy of the test set. By proper choice of mutant operators, comprehensive testing can be performed, [2] including path coverage [10] and domain analysis. <ref> [17] </ref> By examination of unkilled mutants, testers can add new test cases to better the adequacy score of the entire test set. Mutation analysis is designed to substantiate the correctness of a program .
Reference: [18] <author> M. R. Woodward and K. Halewood. </author> <title> From weak to strong: Dead or alive? an analysis of some mutation testing issues. </title> <booktitle> In Proceedings of the Second Workshop on Software Testing, Verification and Analysis, </booktitle> <pages> pages 152-158, </pages> <address> Banff, Alberta, Canada, </address> <month> July </month> <year> 1988. </year> <month> 49 </month>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [4, 15, 9, 3, 18, 12] </ref>. 1 In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t .
References-found: 18

