URL: ftp://ftp.dcs.ex.ac.uk/pub/usr/david/ifl97.ps.Z
Refering-URL: http://www.dcs.ex.ac.uk/~david/research/java.htm
Root-URL: http://www.dcs.ex.ac.uk
Title: A Haskell to Java Virtual Machine Code Compiler  
Author: David Wakeling 
Web: (web: http://www.dcs.exeter.ac.uk/~david)  
Address: Exeter, EX4 4PT, United Kingdom.  
Affiliation: Department of Computer Science, University of Exeter,  
Abstract: For some time now, we have been interested in using Haskell to program inexpensive embedded processors, such as those in SUN's new Java family. This paper describes our first attempt to produce a Haskell to Java Virtual Machine code compiler, based on a mapping between the G-machine and the Java Virtual Machine. Although this mapping looks good, it is not perfect, and our first results suggest that the compiled Java Virtual Machine code may be rather larger and slower than one might hope. 
Abstract-found: 1
Intro-found: 1
Reference: [AJ89] <author> L. Augustsson and T. Johnsson. </author> <title> Parallel Graph Reduction with the h;gi-machine. </title> <booktitle> In Proceedings of the 1989 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 202-213. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: To some extent, the garbage collection problem could be solved by mapping the pointer stack to a linked-list of frames instead of an array. Taking this idea further, the movement of pointers could also be avoided by using the h;Gi-machine <ref> [AJ89] </ref>, where stack space is allocated as part of the graph nodes, instead of the ordinary G-machine. We have just built such an implementation, and it looks more promising. Another problem is with SUN's implementation of the Java Virtual Machine.
Reference: [Jon92] <author> S. L. Peyton Jones. </author> <title> Implementing Lazy Functional Languages on Stock Hardware: </title> <journal> the Spineless Tagless G-machine. Journal of Functional Programming, </journal> <pages> pages 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: The trick is a variant of the "UUO handler" invented for the Rabbit Scheme compiler [Ste78] and later popularised as the "tiny interpreter" by the Glasgow Haskell compiler <ref> [Jon92] </ref>. A tail call is made by returning a function node object whose rn is to be invoked, rather than by invoking this method directly.
Reference: [LY96] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine. </title> <publisher> Addison-Wesley, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: But Java processors, with their compact instruction encoding, are an attractive alternative [SUN97]. This paper investigates whether these processors could successfully run lazy functional programs. The paper has two parts. The first part points out the similarity between the virtual machine usually used to implement Java <ref> [LY96] </ref> and the Chalmers G-machine [Pey87], a virtual machine often used to implement lazy functional languages. <p> This section gives a quick tour of the Java Virtual Machine; more detail can be found in <ref> [LY96] </ref>. Throughout objects ? variable stack ff 42 ? operand stack ff ? ? methods and constant pools Fig. 1. The Java Virtual Machine. this paper, Java source code and Java Virtual Machine code will be written in typewriter font.
Reference: [OW97] <author> M. Odersky and P. Wadler. </author> <title> Pizza into Java: Translating Theory into Practice. </title> <booktitle> In Proceedings of the 1997 ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 146-149, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: to fit out one of the free ones with more efficient storage management | perhaps using semispaces instead of mark/sweep | and a proper treatment of tail-calls. 8 Related Work The instant success of Java has attracted the attention of others in the functional programming community, notably Odersky and Wadler <ref> [OW97] </ref>. Their Pizza implementation extends Java with parametric polymorphism, higher-order functions and algebraic data types in order to make these ideas more widely accessible. Pizza can be used as a functional programming language, and object-oriented programming language, or something in between.
Reference: [Pey87] <editor> S. L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: This paper investigates whether these processors could successfully run lazy functional programs. The paper has two parts. The first part points out the similarity between the virtual machine usually used to implement Java [LY96] and the Chalmers G-machine <ref> [Pey87] </ref>, a virtual machine often used to implement lazy functional languages. <p> This section gives a quick tour of the G-machine; more detail can be found in <ref> [Pey87] </ref>. Throughout this paper, G-machine instructions will be written in upper-case SANS SERIF font.
Reference: [Ste78] <author> G. L. Steele. Rabbit: </author> <title> A Compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1978. </year>
Reference-contexts: Unfortunately, the Java Virtual Machine is not required to implement tail calls like this, and so we must use a well-known trick to achieve the proper behaviour. The trick is a variant of the "UUO handler" invented for the Rabbit Scheme compiler <ref> [Ste78] </ref> and later popularised as the "tiny interpreter" by the Glasgow Haskell compiler [Jon92]. A tail call is made by returning a function node object whose rn is to be invoked, rather than by invoking this method directly.
Reference: [SUN97] <author> SUN Microsystems Inc. </author> <title> PicoJava I Microprocessor Core Architecture. </title> <type> Technical Report WPR-0014-01, </type> <institution> SUN Microsystems, </institution> <year> 1997. </year>
Reference-contexts: So far, all of our implementations have assumed that next-generation products will be controlled by previous-generation RISC processors [Wak95]. But Java processors, with their compact instruction encoding, are an attractive alternative <ref> [SUN97] </ref>. This paper investigates whether these processors could successfully run lazy functional programs. The paper has two parts. The first part points out the similarity between the virtual machine usually used to implement Java [LY96] and the Chalmers G-machine [Pey87], a virtual machine often used to implement lazy functional languages.
Reference: [Wak95] <author> D. Wakeling. </author> <title> A Throw-away Compiler for a Lazy Functional Language. </title> <editor> In M. Takeichi and T. Ida, editors, </editor> <booktitle> Fuji International Workshop on Functional and Logic Programming, </booktitle> <pages> pages 287-300. </pages> <publisher> World Scientific, </publisher> <month> July </month> <year> 1995. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction For some time now, we have been interested in the efficient implementation of lazy functional programming languages on very small computers, such as those found in consumer electronics devices. So far, all of our implementations have assumed that next-generation products will be controlled by previous-generation RISC processors <ref> [Wak95] </ref>. But Java processors, with their compact instruction encoding, are an attractive alternative [SUN97]. This paper investigates whether these processors could successfully run lazy functional programs. The paper has two parts.
References-found: 8

