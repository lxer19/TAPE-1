URL: http://www.cis.ohio-state.edu/~neelam/papers/uf.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Title: Understanding Frameworks  
Author: Neelam Soundarajan 
Keyword: Specification and Verification, Traces, Flow-of-control Behavior, Behavioral refinement.  
Address: Columbus, OH 43210, USA  
Affiliation: Computer and Information Science The Ohio State University  
Email: e-mail: neelam@cis.ohio-state.edu  
Phone: Tel: (614) 292 1444; FAX: (614) 292 2911  
Date: June 1, 1998  
Abstract: When designing a framework F, the designer abstracts away certain key methods of certain key classes of the framework leaving them as virtual functions (in C++ terminology). One of the most important contributions that F makes to the final application built on F is the flow of control implemented in the non-virtual functions of F; this relieves the application builder from having to worry about this important and difficult issue. An application builder who builds a complete application A using F refines the abstract base classes of F by providing specific bodies for the virtual functions, thus implementing specific behaviors. We use the term behavioral refinement to characterize this type of refinement. The important questions we address in this chapter are the following: how do we understand the behavior -specifically the flow-of-control behavior- implemented by the framework code, how do we understand the behavior implemented by the method bodies defined in the application code, and how do we combine these to obtain an understanding of the behavior of the entire application? We propose a trace based approach for specifying the behavior of the framework, in particular the control flow. The particular refinement that an application builder implements is captured in an appropriate refined specification of the respective virtual functions of F . We then show how this refined specification can be combined with the specification of the framework to arrive at the behavior of the entire application. We illustrate our approach on a simple diagram editor framework. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Cardelli. </author> <title> On subtyping and matching. </title> <booktitle> In Proceedings of ECOOP, </booktitle> <volume> LNCS 952, </volume> <pages> pages 145-167. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: follow the C++ convention that the number and types of the parameters of the virtual functions in the base class must match exactly the (number and) types of the parameters of the corresponding functions in the derived classes; other more general requirements such as contra-variance or co-variance are also possible <ref> [1] </ref>, but we won't consider them in this chapter. 5 3 Behavioral Refinement: From Frameworks to Applications The run function of F provides a `behavioral skeleton' for the entire application with the virtual functions being `(partially) empty shells' in some sense. <p> For one possible way of dealing with such overriding, but not in the context of frameworks, see [17]. 7 The specification of run will be: pre run true (5) post run (x.v = #x.v + 2 ^ (jt j = 2 ^ t:o <ref> [1] </ref> = t:o [2] = x ^ t:f [1] = t:f [2] = g)) (6) The first clause in the post-condition of run asserts that when run finishes, the value of x.v will be 2 greater than at the start; the second clause asserts that during execution, run will call virtual <p> one possible way of dealing with such overriding, but not in the context of frameworks, see [17]. 7 The specification of run will be: pre run true (5) post run (x.v = #x.v + 2 ^ (jt j = 2 ^ t:o <ref> [1] </ref> = t:o [2] = x ^ t:f [1] = t:f [2] = g)) (6) The first clause in the post-condition of run asserts that when run finishes, the value of x.v will be 2 greater than at the start; the second clause asserts that during execution, run will call virtual functions twice (jt j is the length of <p> The particular request we consider corresponds to the Iconify operation; others are handled in a similar manner: post run (mx, my, "Iconify") [ !(f1.x, f1.y, f2.x, f2.y) ^ ((jt j = 2 _ jt j = 3) ^ (t:o <ref> [1] </ref> = f1) ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o [2] = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) <p> The particular request we consider corresponds to the Iconify operation; others are handled in a similar manner: post run (mx, my, "Iconify") [ !(f1.x, f1.y, f2.x, f2.y) ^ ((jt j = 2 _ jt j = 3) ^ (t:o <ref> [1] </ref> = f1) ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o [2] = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) <p> The particular request we consider corresponds to the Iconify operation; others are handled in a similar manner: post run (mx, my, "Iconify") [ !(f1.x, f1.y, f2.x, f2.y) ^ ((jt j = 2 _ jt j = 3) ^ (t:o <ref> [1] </ref> = f1) ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o [2] = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ <p> f2.y) ^ ((jt j = 2 _ jt j = 3) ^ (t:o <ref> [1] </ref> = f1) ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o [2] = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ (t:o [3] = f2) ^ (t:f [3] = iconify) ^ (f2.ic = 1) ^ (!(f1.ic)))) This asserts that the coordinates of the anchor points of f1, <p> run, in carrying out this request, makes either two or three virtual function calls; that the first call is to isIn, with the object being f1, and the argument being the point (with the coordinates) (mx,my) which was part of the original request; if the result of this call (t:res <ref> [1] </ref>) is 1, there is one more call to a 12 virtual function, this one being iconify, the object being again f1. <p> Here we will just assume that f1 is an instance of C and that f2 is an instance of R. This will allow us to strengthen, for instance, the clause [(t:res <ref> [1] </ref> = 1) ) ((jt j = 2) ^ (t:o [2] = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) from the specification (10) of run as follows: [(#f1.ic = 0) ^ distance ((f1.x,f1.y); (mx,my)) f1.rad] ) [(f1.ic = 1 ^ f1.count = #f1.count + 1) ^
Reference: [2] <author> J. Bosch and M. Mattsson. </author> <title> Framework composition. </title> <editor> In Ege, Singh, and Meyer, editors, </editor> <booktitle> Proceedings of TOOLS 23, </booktitle> <pages> pages 203-214. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: The problems of using OO have been remarked on by many people in the literature see, for example, [5]. One of the important issues is that of documentation; the issue becomes particularly critical for frameworks as has been noted by a number of authors <ref> [3, 9, 2] </ref>. Most of these authors focus on informal documentations rather than the precise specifications of the kind we are interested in. <p> For one possible way of dealing with such overriding, but not in the context of frameworks, see [17]. 7 The specification of run will be: pre run true (5) post run (x.v = #x.v + 2 ^ (jt j = 2 ^ t:o [1] = t:o <ref> [2] </ref> = x ^ t:f [1] = t:f [2] = g)) (6) The first clause in the post-condition of run asserts that when run finishes, the value of x.v will be 2 greater than at the start; the second clause asserts that during execution, run will call virtual functions twice (jt <p> of dealing with such overriding, but not in the context of frameworks, see [17]. 7 The specification of run will be: pre run true (5) post run (x.v = #x.v + 2 ^ (jt j = 2 ^ t:o [1] = t:o <ref> [2] </ref> = x ^ t:f [1] = t:f [2] = g)) (6) The first clause in the post-condition of run asserts that when run finishes, the value of x.v will be 2 greater than at the start; the second clause asserts that during execution, run will call virtual functions twice (jt j is the length of t ), and <p> others are handled in a similar manner: post run (mx, my, "Iconify") [ !(f1.x, f1.y, f2.x, f2.y) ^ ((jt j = 2 _ jt j = 3) ^ (t:o [1] = f1) ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o <ref> [2] </ref> = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ (t:o [3] = f2) ^ (t:f [3] = iconify) ^ <p> similar manner: post run (mx, my, "Iconify") [ !(f1.x, f1.y, f2.x, f2.y) ^ ((jt j = 2 _ jt j = 3) ^ (t:o [1] = f1) ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o <ref> [2] </ref> = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ (t:o [3] = f2) ^ (t:f [3] = iconify) ^ (f2.ic = 1) ^ (!(f1.ic)))) <p> 2 _ jt j = 3) ^ (t:o [1] = f1) ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o <ref> [2] </ref> = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ (t:o [3] = f2) ^ (t:f [3] = iconify) ^ (f2.ic = 1) ^ (!(f1.ic)))) This asserts that the coordinates of the anchor points of f1, f2 are not affected by <p> 3) ^ (t:o [1] = f1) ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o <ref> [2] </ref> = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ (t:o [3] = f2) ^ (t:f [3] = iconify) ^ (f2.ic = 1) ^ (!(f1.ic)))) This asserts that the coordinates of the anchor points of f1, f2 are not affected by carrying out this request; that <p> ^ (t:f [1] = isIn (mx,my)) ^ ((t:res [1] = 1) ) ((jt j = 2) ^ (t:o <ref> [2] </ref> = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ (t:o [3] = f2) ^ (t:f [3] = iconify) ^ (f2.ic = 1) ^ (!(f1.ic)))) This asserts that the coordinates of the anchor points of f1, f2 are not affected by carrying out this request; that run, in carrying out this request, <p> Here we will just assume that f1 is an instance of C and that f2 is an instance of R. This will allow us to strengthen, for instance, the clause [(t:res [1] = 1) ) ((jt j = 2) ^ (t:o <ref> [2] </ref> = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) from the specification (10) of run as follows: [(#f1.ic = 0) ^ distance ((f1.x,f1.y); (mx,my)) f1.rad] ) [(f1.ic = 1 ^ f1.count = #f1.count + 1) ^ : : :] This assures us that if the circle <p> Here we will just assume that f1 is an instance of C and that f2 is an instance of R. This will allow us to strengthen, for instance, the clause [(t:res [1] = 1) ) ((jt j = 2) ^ (t:o <ref> [2] </ref> = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) from the specification (10) of run as follows: [(#f1.ic = 0) ^ distance ((f1.x,f1.y); (mx,my)) f1.rad] ) [(f1.ic = 1 ^ f1.count = #f1.count + 1) ^ : : :] This assures us that if the circle f1 is currently not iconified,
Reference: [3] <author> R.H. Campbell and N. Islam. </author> <title> A technique for documenting the framework of an object-oriented system. </title> <journal> Computing Systems, </journal> <volume> 6 </volume> <pages> 363-389, </pages> <year> 1993. </year>
Reference-contexts: The problems of using OO have been remarked on by many people in the literature see, for example, [5]. One of the important issues is that of documentation; the issue becomes particularly critical for frameworks as has been noted by a number of authors <ref> [3, 9, 2] </ref>. Most of these authors focus on informal documentations rather than the precise specifications of the kind we are interested in. <p> 1) ) ((jt j = 2) ^ (t:o [2] = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ (t:o <ref> [3] </ref> = f2) ^ (t:f [3] = iconify) ^ (f2.ic = 1) ^ (!(f1.ic)))) This asserts that the coordinates of the anchor points of f1, f2 are not affected by carrying out this request; that run, in carrying out this request, makes either two or three virtual function calls; that the <p> 2) ^ (t:o [2] = f1) ^ (t:f [2] = iconify) ^ (f1.ic = 1) ^ (!(f2.ic)))) ^ ((t:res [1] = 0) ) ((t:o [2] = f2) ^ (t:f [2] = isIn (mx,my)) ^ ((t:res [2] = 1) ) ((jt j = 3) ^ (t:o <ref> [3] </ref> = f2) ^ (t:f [3] = iconify) ^ (f2.ic = 1) ^ (!(f1.ic)))) This asserts that the coordinates of the anchor points of f1, f2 are not affected by carrying out this request; that run, in carrying out this request, makes either two or three virtual function calls; that the first call is to isIn,
Reference: [4] <author> K.K. Dhara and G.T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In ICSE-18, </booktitle> <pages> pages 27-51. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We will return to the relation between the approach we propose and that of other authors in the final section of the chapter but one point is worth noting here: Approaches such as those of <ref> [11, 4, 13] </ref> that are used for specifying the behavior of `normal' OO programs are not well suited for dealing with frameworks. The problem is that these approaches tend to downplay the contribution of virtual functions to overall system behavior.
Reference: [5] <author> M.E. Fayad and D.C. Schmidt. </author> <title> Special issue on object oriented application frameworks. </title> <journal> CACM, </journal> <volume> 40, </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: The problems of using OO have been remarked on by many people in the literature see, for example, <ref> [5] </ref>. One of the important issues is that of documentation; the issue becomes particularly critical for frameworks as has been noted by a number of authors [3, 9, 2]. Most of these authors focus on informal documentations rather than the precise specifications of the kind we are interested in.
Reference: [6] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design patterns: Elements of reusable OO software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Situations such as these are often called `a template method (run) calling a `hook' method (the virtual function)' <ref> [6] </ref>. Before concluding this section, we should note a couple of points regarding our model of frameworks.
Reference: [7] <author> R. Helm, I. Holland, and D. Gangopadhyay. </author> <title> Contracts: Specifying behavioral compositions in object oriented systems. </title> <booktitle> In OOPSLA-ECOOP, </booktitle> <pages> pages 169-180, </pages> <year> 1990. </year>
Reference-contexts: We believe that both informal documentations, perhaps using examples as suggested by some authors, as well as precise specifications are useful and should be considered as complementing each other. Helm et al <ref> [7] </ref> use their formal notion of contracts to describe many relations between objects; however, their goal seems more towards using contracts for mechanical execution purposes rather than for documentation.
Reference: [8] <author> C. Horstmann. </author> <title> Mastering Object-Oriented Design in C++. </title> <publisher> Wiley, </publisher> <year> 1995. </year>
Reference-contexts: In section 4 we briefly consider how our approach may be applied to a (simplified version of a) diagram editor framework; this is a fairly typical framework and is based on a framework developed in Horstmann's <ref> [8] </ref> text book. <p> Arrows, as usual, indicate inheritance. The heavy solid lines enclosing the set of classes of F and A 0 do not correspond to any grouping 3 Thus in the diagram framework of <ref> [8] </ref>, each of the various classes of nodes and edges defined by the application code must be `registered' with the framework before the run function is invoked; the diagram framework uses two functions, registerNode and registerEdge for this purpose. 4 mechanism of the programming language; perhaps future languages that explicitly cater <p> The framework we consider is based on one presented by Horstmann <ref> [8] </ref>; Horstmann's framework is for dealing with a collection of figures made up of nodes and edges, for moving the figures around, drawing and erasing them etc. To keep the discussion simple, and to avoid getting into graphics issues, we will consider a highly stripped down version of that framework. <p> Next consider the controller class CF. CF has two member variables f1, f2 both of type F. These are the figures that this `framework' will let us work with. In a more realistic framework, such as the one in <ref> [8] </ref>, the user of the application would be able to create as many figures as he wanted, not be stuck with two.
Reference: [9] <author> R. Johnson. </author> <title> Frameworks = components + patterns. </title> <journal> Comm. of the ACM, </journal> <volume> 40(10) </volume> <pages> 39-42, </pages> <year> 1997. </year>
Reference-contexts: The problems of using OO have been remarked on by many people in the literature see, for example, [5]. One of the important issues is that of documentation; the issue becomes particularly critical for frameworks as has been noted by a number of authors <ref> [3, 9, 2] </ref>. Most of these authors focus on informal documentations rather than the precise specifications of the kind we are interested in.
Reference: [10] <author> R. Johnson and B. Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object Oriented Programming, </journal> <volume> 1 </volume> <pages> 22-35, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction and Motivation Frameworks <ref> [10, 18] </ref> promise to dramatically reduce the time and effort needed to develop complete applications. When designing a framework F, the designer identifies certain key methods of certain key classes as virtual or pure virtual functions (in C++ [19] terminology 1 ).
Reference: [11] <author> B. Liskov and J. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16 </volume> <pages> 1811-1841, </pages> <year> 1994. </year> <month> 15 </month>
Reference-contexts: Once we have an understanding of the concrete behavior of the entire application, we can use standard ways <ref> [11, 17] </ref> to convert it into an abstract specification in terms of a conceptual model. The problems of using OO have been remarked on by many people in the literature see, for example, [5]. <p> We will return to the relation between the approach we propose and that of other authors in the final section of the chapter but one point is worth noting here: Approaches such as those of <ref> [11, 4, 13] </ref> that are used for specifying the behavior of `normal' OO programs are not well suited for dealing with frameworks. The problem is that these approaches tend to downplay the contribution of virtual functions to overall system behavior.
Reference: [12] <author> S. Mamrak, J. Boyd, and I. Ordonez. </author> <title> Building an information system for collaborative researchers. </title> <journal> Software Practice and Experience, </journal> <volume> 27(3) </volume> <pages> 253-263, </pages> <year> 1997. </year>
Reference-contexts: We intend to apply our approach to specifying an actual framework (for collecting and disseminating medical information of a particular type) developed by Mamrak et al <ref> [12] </ref>. We believe this exercise will allow us to generalize the model so that it will be suitable for realistic framework. Finally, there is also the question of whether the programming language is too constraining.
Reference: [13] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: We will return to the relation between the approach we propose and that of other authors in the final section of the chapter but one point is worth noting here: Approaches such as those of <ref> [11, 4, 13] </ref> that are used for specifying the behavior of `normal' OO programs are not well suited for dealing with frameworks. The problem is that these approaches tend to downplay the contribution of virtual functions to overall system behavior. <p> The specification of isIn is worth remarking upon. Note first the special symbol result; this is used (borrowing a convention from <ref> [13] </ref>) to denote the value returned by this function. This specification says that the value returned by isIn is either 0 or 1.
Reference: [14] <author> J. Misra and K. Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 7 </volume> <pages> 417-426, </pages> <year> 1981. </year>
Reference-contexts: One point that is worth noting here is the similarity of this situation with that in reasoning about the behavior of distributed programs. Trace based approaches are commonly used <ref> [14, 16] </ref> for dealing with such programs, a trace being associated with each process of such a program to record its interactions, i.e., communications, with other processes of the program.
Reference: [15] <author> S. Fridella N. Soundarajan. </author> <title> Enriching subclass specifications, </title> <type> technical report, </type> <note> available at www.cis. ohio-state.edu/~neelam, </note> <year> 1998. </year>
Reference-contexts: We will omit the formal details of these rules; in <ref> [15] </ref> we deal with a related problem and the rules presented there can be tailored to deal with the current situation. One point that is worth noting here is the similarity of this situation with that in reasoning about the behavior of distributed programs.
Reference: [16] <author> N. Soundarajan. </author> <title> Axiomatic semantics of CSP. </title> <journal> ACM TOPLAS, </journal> <volume> 6 </volume> <pages> 647-662, </pages> <year> 1984. </year>
Reference-contexts: One point that is worth noting here is the similarity of this situation with that in reasoning about the behavior of distributed programs. Trace based approaches are commonly used <ref> [14, 16] </ref> for dealing with such programs, a trace being associated with each process of such a program to record its interactions, i.e., communications, with other processes of the program.
Reference: [17] <author> N. Soundarajan and S. Fridella. </author> <title> Inheriting and modifying behavior. </title> <editor> In Meyer Ege, Singh, editor, </editor> <booktitle> Proceedings of TOOLS '97, </booktitle> <pages> pages 148-163. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: One further point should be noted: throughout this chapter, we will be mostly working with what are usually called `concrete specifications', see for example <ref> [17] </ref>, in other words our specifications of functions are in terms of their effects on the actual data members of the classes we are dealing with. <p> Once we have an understanding of the concrete behavior of the entire application, we can use standard ways <ref> [11, 17] </ref> to convert it into an abstract specification in terms of a conceptual model. The problems of using OO have been remarked on by many people in the literature see, for example, [5]. <p> For one possible way of dealing with such overriding, but not in the context of frameworks, see <ref> [17] </ref>. 7 The specification of run will be: pre run true (5) post run (x.v = #x.v + 2 ^ (jt j = 2 ^ t:o [1] = t:o [2] = x ^ t:f [1] = t:f [2] = g)) (6) The first clause in the post-condition of run asserts that
Reference: [18] <author> S. Sparks, K. Benner, and C. Faris. </author> <title> Managing OO framework reuse. </title> <journal> Computer, </journal> <volume> 29(9) </volume> <pages> 52-62, </pages> <year> 1996. </year>
Reference-contexts: 1 Introduction and Motivation Frameworks <ref> [10, 18] </ref> promise to dramatically reduce the time and effort needed to develop complete applications. When designing a framework F, the designer identifies certain key methods of certain key classes as virtual or pure virtual functions (in C++ [19] terminology 1 ).
Reference: [19] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year> <month> 16 </month>
Reference-contexts: 1 Introduction and Motivation Frameworks [10, 18] promise to dramatically reduce the time and effort needed to develop complete applications. When designing a framework F, the designer identifies certain key methods of certain key classes as virtual or pure virtual functions (in C++ <ref> [19] </ref> terminology 1 ). Although these methods will be provided definitions by the application developer, F 's designer usually has some ideas on what kinds of behaviors these methods should exhibit such as which methods should be invoked at what points.
References-found: 19

