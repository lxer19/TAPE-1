URL: http://www.cs.washington.edu/homes/mernst/pubs/slicing-tr9414.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/mernst/pubs/slicing-tr9414-abstract.html
Root-URL: 
Email: mernst@research.microsoft.com  
Title: Practical fine-grained static slicing of optimized code  
Author: Michael D. Ernst 
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Advanced Technology Division Microsoft Corporation  
Date: July 26, 1994  
Abstract: Technical Report MSR-TR-94-14 
Abstract-found: 1
Intro-found: 1
Reference: [Agr94] <author> Hiralal Agrawal. </author> <title> On slicing programs with jump statements. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 302-312, </pages> <address> Orlando, FL, </address> <month> June 20-24 </month> <year> 1994. </year>
Reference-contexts: If a value is named by a particular variable at a statement in the slice, then the statement assigning the value to that variable must be included in the slice. Including the proper control-flow statements (such as goto) requires special care <ref> [JZR91, BH92, Bal93, CF93, Agr94] </ref>. Only a limited class of optimizations can be handled [Tip94], since optimized programs can be inexpressible in the original programming language.
Reference: [Bal93] <author> Thomas Jaudon Ball. </author> <title> The use of control-flow and control dependence in software tools. </title> <type> Technical Report 1169, </type> <institution> University of Wisconsin - Madison, </institution> <month> August </month> <year> 1993. </year> <type> PhD thesis. </type>
Reference-contexts: When used for integration of compatible versions of a program <ref> [RY89, HPR89, HR90, HRB90, Bin91, Bal93] </ref>, an executable slice combines all the features of the various versions. A closure slice, on the other hand, helps a programmer visualize dependences without regard to syntactic constraints. <p> If a value is named by a particular variable at a statement in the slice, then the statement assigning the value to that variable must be included in the slice. Including the proper control-flow statements (such as goto) requires special care <ref> [JZR91, BH92, Bal93, CF93, Agr94] </ref>. Only a limited class of optimizations can be handled [Tip94], since optimized programs can be inexpressible in the original programming language.
Reference: [BH92] <author> Thomas Ball and Susan Horwitz. </author> <title> Slicing programs with arbitrary control flow. </title> <type> Technical Report 1128, </type> <institution> University of Wisconsin - Madison, </institution> <month> December 21, </month> <year> 1992. </year>
Reference-contexts: If a value is named by a particular variable at a statement in the slice, then the statement assigning the value to that variable must be included in the slice. Including the proper control-flow statements (such as goto) requires special care <ref> [JZR91, BH92, Bal93, CF93, Agr94] </ref>. Only a limited class of optimizations can be handled [Tip94], since optimized programs can be inexpressible in the original programming language.
Reference: [Bin91] <author> David W. Binkley. </author> <title> Multi-procedure program integration. </title> <type> Technical Report 1038, </type> <institution> University of Wis-consin - Madison, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: When used for integration of compatible versions of a program <ref> [RY89, HPR89, HR90, HRB90, Bin91, Bal93] </ref>, an executable slice combines all the features of the various versions. A closure slice, on the other hand, helps a programmer visualize dependences without regard to syntactic constraints. <p> Ottenstein and Ottenstein's linear-time slicing algorithm based on graph reachability [OO84] demonstrates the appropriateness of the program dependence graph (PDG) [FOW87, HPR88] for slicing. Slicing criteria are slightly restricted: variables must appear in the specified statement. Most subsequent research builds upon this work. Horwitz et al. <ref> [HRB88, HRB90, Bin91, Bin93] </ref> extend the PDG algorithm to account for calling context. An interprocedural PDG (called the system dependence graph) summarizing transitive dependences due to calls is constructed from an attribute grammar that models procedure-call structure and the subordinate characteristic graphs of the grammar's nonterminals.
Reference: [Bin93] <author> David Binkley. </author> <title> Precise executable interprocedural slices. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):31-45, </volume> <month> March-December </month> <year> 1993. </year>
Reference-contexts: When used for testing [LW87, KSF90, PC90, FSKG92], parallelization [Wei83, BW88], or program decomposition <ref> [RY88, Bin93] </ref>, the goal is a smaller, faster program that computes the same slicing criterion values as the original program, but without computing other, irrelevant results. <p> Syntactic constraints complicate the construction of compilable slices and force the inclusion of extraneous program components <ref> [Bin93] </ref>. For instance, an compilable slice unnecessarily includes the entire program for figures 3, 4, 5, 7, 9, 12, and 13 (left side). <p> Ottenstein and Ottenstein's linear-time slicing algorithm based on graph reachability [OO84] demonstrates the appropriateness of the program dependence graph (PDG) [FOW87, HPR88] for slicing. Slicing criteria are slightly restricted: variables must appear in the specified statement. Most subsequent research builds upon this work. Horwitz et al. <ref> [HRB88, HRB90, Bin91, Bin93] </ref> extend the PDG algorithm to account for calling context. An interprocedural PDG (called the system dependence graph) summarizing transitive dependences due to calls is constructed from an attribute grammar that models procedure-call structure and the subordinate characteristic graphs of the grammar's nonterminals. <p> Once the graph is constructed, slicing takes linear time (but aliasing degrades the performance, and Binkley's analysis <ref> [Bin93] </ref> assumes the program contains a constant number of global variables). Constructing a compilable slice requires specialization of each procedure for each subset of parameters demanded by a call site, so the result is not a subset of the original program.
Reference: [BW88] <author> Lee Badger and Mark Weiser. </author> <title> Minimizing communication for synchronizing parallel dataflow programs. </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, Volume II, Software, </booktitle> <pages> pages 122-126, </pages> <institution> Penn State, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: When used for testing [LW87, KSF90, PC90, FSKG92], parallelization <ref> [Wei83, BW88] </ref>, or program decomposition [RY88, Bin93], the goal is a smaller, faster program that computes the same slicing criterion values as the original program, but without computing other, irrelevant results. <p> complexity from linear in the size of the VDG to linear in the size of the source code graph, which is approximately the size of the original program. 8 Related work Weiser introduced the concept of slicing [Wei79, Wei84] and showed its application to debugging [Wei82, LW86, LW87] and parallelization <ref> [Wei83, BW88] </ref>. His slicing criteria consist of a statement and a set of variables not necessarily referenced in the statement, and his slices are syntactically correct subsets of the original program with the same termination behavior.
Reference: [CF93] <author> Jong-Deok Choi and Jeanne Ferrante. </author> <title> Static slicing in the presence of GOTO statements. </title> <note> Submitted for publication; previously titled "What is in a slice", October 19, </note> <year> 1993. </year>
Reference-contexts: If a value is named by a particular variable at a statement in the slice, then the statement assigning the value to that variable must be included in the slice. Including the proper control-flow statements (such as goto) requires special care <ref> [JZR91, BH92, Bal93, CF93, Agr94] </ref>. Only a limited class of optimizations can be handled [Tip94], since optimized programs can be inexpressible in the original programming language.
Reference: [EGH93] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <type> ACAPS Technical Memo 54, </type> <institution> McGill Uiversity, School of Computer Science, </institution> <month> November </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: The slices in figure 5 have depth 1. drawing arrows and using colors. These techniques can be distracting, however, and usually provide more information than desired. 4 Slicing with pointers and aggregate values In order to effectively slice code containing pointer operations, our slicing algorithm uses a points-to analysis <ref> [HEGV93, EGH93] </ref>, which indicates the possible values for each location-valued construct in the program. Variable references and pointer dereferences are represented in the VDG by lookup nodes, which take two arguments|a location and a store|and return the contents of the location in the store. <p> By contrast to these techniques, we use a points-to analysis <ref> [HEGV93, EGH93] </ref> and add support for aggregates such as C's struct and union types. Ottenstein and Ottenstein [OO83, OO84] and Tip [Tip94] note that compiler transformations can be of use to a slicer but give no details.
Reference: [FOW87] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Weiser treats slicing as a dataflow problem and provides an O (ne log e) algorithm which includes every call site of a function if any call is included. Ottenstein and Ottenstein's linear-time slicing algorithm based on graph reachability [OO84] demonstrates the appropriateness of the program dependence graph (PDG) <ref> [FOW87, HPR88] </ref> for slicing. Slicing criteria are slightly restricted: variables must appear in the specified statement. Most subsequent research builds upon this work. Horwitz et al. [HRB88, HRB90, Bin91, Bin93] extend the PDG algorithm to account for calling context.
Reference: [FSKG92] <author> Peter Fritzson, Nahid Shahmehri, Mariam Kamkar, and Tibor Gyimothy. </author> <title> Generalized algorithmic debugging and testing. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(4) </volume> <pages> 303-322, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: When used for testing <ref> [LW87, KSF90, PC90, FSKG92] </ref>, parallelization [Wei83, BW88], or program decomposition [RY88, Bin93], the goal is a smaller, faster program that computes the same slicing criterion values as the original program, but without computing other, irrelevant results.
Reference: [Han93] <author> Chris Hanson. </author> <title> MIT Scheme Reference Manual. MIT Scheme Team, </title> <address> Cambridge, MA, </address> <note> 1.41 beta for scheme release 7.3 edition, December 6, </note> <year> 1993. </year>
Reference-contexts: Third, we slice a real programming language. We enhance work on slicing in the presence of pointers and function calls. We introduce techniques for handling arrays, structures, unions, and expressions with side effects. Our slicer supports the entire C programming language (except longjmp). The implementation is written in Scheme <ref> [Han93] </ref> and integrated with GNU Emacs [Sta94] for input and output; it uses the value dependence graph [WCES94] as its intermediate representation. 1.1 Types of slices Venkatesh [Ven91] categorizes slices into eight types according to three distinctions: backward vs. forward, executable vs. closure, and static vs. dynamic.
Reference: [HDC88] <author> J. C. Hwang, M. W. Du, and C. R. Chou. </author> <title> Finding program slices for recursive procedures. </title> <booktitle> In Proceedings COMPSAC 88: The Twelfth International Computer Software and Applications Conference, </booktitle> <address> Chicago, </address> <month> October </month> <year> 1988. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: That algorithm constructs unnecessarily large slices, because it does not account for calling context. Not all formal-to-actual links should be followed, as illustrated by figure 8. The obvious technique is to process each procedure body anew for each call, propagating the results to just that call site <ref> [HDC88] </ref>. However, this method does not run in time proportional to the size of the program, and recursion complicates guaranteeing its termination and correctness. <p> The algorithm processes contents of looping statements twice. Our inter-procedural algorithm is similar, but constructs the summary by solving a set of dataflow equations and uses direct dependences to skip over procedure bodies which do not contribute any dependences. Hwang et al. <ref> [HDC88] </ref> slice interprocedurally in the presence of self-recursion by computing a series of slices in which the recursion depth is limited: initially no recursive calls are followed, then one level, and so forth. The fixed point solution is achieved when increasing the level results in no larger a slice.
Reference: [HEGV93] <author> Laurie J. Hendren, Maryam Emami, Rakesh Ghiya, and Clark Verbrugge. </author> <title> A practical context-sensitive interprocedural alias analysis framework for C compilers. </title> <type> ACAPS Technical Memo 72, </type> <institution> McGill University School of Computer Science, Advanced Compilers, Architectures, and Parallel Systems Group, </institution> <address> Montreal, Quebec, </address> <month> July 24, </month> <year> 1993. </year>
Reference-contexts: The slices in figure 5 have depth 1. drawing arrows and using colors. These techniques can be distracting, however, and usually provide more information than desired. 4 Slicing with pointers and aggregate values In order to effectively slice code containing pointer operations, our slicing algorithm uses a points-to analysis <ref> [HEGV93, EGH93] </ref>, which indicates the possible values for each location-valued construct in the program. Variable references and pointer dereferences are represented in the VDG by lookup nodes, which take two arguments|a location and a store|and return the contents of the location in the store. <p> By contrast to these techniques, we use a points-to analysis <ref> [HEGV93, EGH93] </ref> and add support for aggregates such as C's struct and union types. Ottenstein and Ottenstein [OO83, OO84] and Tip [Tip94] note that compiler transformations can be of use to a slicer but give no details.
Reference: [HPR88] <author> Susan Horwitz, Jan Prins, and Thomas Reps. </author> <title> On the adequacy of program dependence graphs for representing programs. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 146-157, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Weiser treats slicing as a dataflow problem and provides an O (ne log e) algorithm which includes every call site of a function if any call is included. Ottenstein and Ottenstein's linear-time slicing algorithm based on graph reachability [OO84] demonstrates the appropriateness of the program dependence graph (PDG) <ref> [FOW87, HPR88] </ref> for slicing. Slicing criteria are slightly restricted: variables must appear in the specified statement. Most subsequent research builds upon this work. Horwitz et al. [HRB88, HRB90, Bin91, Bin93] extend the PDG algorithm to account for calling context.
Reference: [HPR89] <author> Susan Horwitz, Jan Prins, and Thomas Reps. </author> <title> Integrating non-interfering versions of programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 345-387, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: When used for integration of compatible versions of a program <ref> [RY89, HPR89, HR90, HRB90, Bin91, Bal93] </ref>, an executable slice combines all the features of the various versions. A closure slice, on the other hand, helps a programmer visualize dependences without regard to syntactic constraints.
Reference: [HR90] <author> Susan Horwitz and Thomas Reps. </author> <title> Efficient comparison of program slices. </title> <type> Technical Report 982, </type> <institution> University of Wisconsin - Madison, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: When used for integration of compatible versions of a program <ref> [RY89, HPR89, HR90, HRB90, Bin91, Bal93] </ref>, an executable slice combines all the features of the various versions. A closure slice, on the other hand, helps a programmer visualize dependences without regard to syntactic constraints.
Reference: [HRB88] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <type> Technical Report 756, </type> <institution> University of Wisconsin - Madison, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Ottenstein and Ottenstein's linear-time slicing algorithm based on graph reachability [OO84] demonstrates the appropriateness of the program dependence graph (PDG) [FOW87, HPR88] for slicing. Slicing criteria are slightly restricted: variables must appear in the specified statement. Most subsequent research builds upon this work. Horwitz et al. <ref> [HRB88, HRB90, Bin91, Bin93] </ref> extend the PDG algorithm to account for calling context. An interprocedural PDG (called the system dependence graph) summarizing transitive dependences due to calls is constructed from an attribute grammar that models procedure-call structure and the subordinate characteristic graphs of the grammar's nonterminals.
Reference: [HRB90] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: However, this method does not run in time proportional to the size of the program, and recursion complicates guaranteeing its termination and correctness. Our solution to this problem is patterned after Horwitz's <ref> [HRB90] </ref>, but we produce finer slices by not including entire calls when only some actuals are demanded, by including only the relevant parts of aggregate values, and by omitting entire procedure bodies where appropriate. <p> When used for integration of compatible versions of a program <ref> [RY89, HPR89, HR90, HRB90, Bin91, Bal93] </ref>, an executable slice combines all the features of the various versions. A closure slice, on the other hand, helps a programmer visualize dependences without regard to syntactic constraints. <p> Ottenstein and Ottenstein's linear-time slicing algorithm based on graph reachability [OO84] demonstrates the appropriateness of the program dependence graph (PDG) [FOW87, HPR88] for slicing. Slicing criteria are slightly restricted: variables must appear in the specified statement. Most subsequent research builds upon this work. Horwitz et al. <ref> [HRB88, HRB90, Bin91, Bin93] </ref> extend the PDG algorithm to account for calling context. An interprocedural PDG (called the system dependence graph) summarizing transitive dependences due to calls is constructed from an attribute grammar that models procedure-call structure and the subordinate characteristic graphs of the grammar's nonterminals. <p> The fixed point solution is achieved when increasing the level results in no larger a slice. The recursive and base cases of recursive procedures are assumed to be identifiable. Such slices are as accurate as those based on the system dependence graph but cannot be computed as efficiently <ref> [HRB90] </ref>. Jiang et al. [JZR91] handle pointers and arrays by means of an alias analysis [Wei80]. They introduce a dummy variable for each level of dereference of each pointer variable and a dummy literal for each variable whose address is taken. <p> Modifications of the pointer count as modifications of these dummy variables, and pointer uses count as dummy uses. Other authors do not address general pointer manipulation, but Horwitz et al. <ref> [HRB90] </ref> give two techniques for dealing with aliasing introduced by call-by-reference function parameters.
Reference: [JR94] <author> Daniel Jackson and Eugene J. Rollins. </author> <title> Abstract program dependences for reverse engineering. </title> <booktitle> Submitted to Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Unlike our implementation, their algorithm includes irrelevant operations (such as the assignment to sum in figure 7 of their paper), and they communicate the slice to the user in terms of whole statements. Jackson and Rollins <ref> [JR94] </ref> note the drawbacks of using an entire PDG node as a slicing criterion: slicing criteria should stand for particular values, not whole computations, and demand on part of a computation does not imply demand on all its inputs.
Reference: [JZR91] <author> Jingyue Jiang, Xiling Zhou, and David J. Robson. </author> <title> Program slicing for C | the problems in implementation. </title> <booktitle> In Proceedings, Conference on Software Maintenance 1991, </booktitle> <pages> pages 182-190, </pages> <address> Sorrento, Italy, </address> <month> October 15-17, </month> <title> 1991. </title> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: If a value is named by a particular variable at a statement in the slice, then the statement assigning the value to that variable must be included in the slice. Including the proper control-flow statements (such as goto) requires special care <ref> [JZR91, BH92, Bal93, CF93, Agr94] </ref>. Only a limited class of optimizations can be handled [Tip94], since optimized programs can be inexpressible in the original programming language. <p> The recursive and base cases of recursive procedures are assumed to be identifiable. Such slices are as accurate as those based on the system dependence graph but cannot be computed as efficiently [HRB90]. Jiang et al. <ref> [JZR91] </ref> handle pointers and arrays by means of an alias analysis [Wei80]. They introduce a dummy variable for each level of dereference of each pointer variable and a dummy literal for each variable whose address is taken.
Reference: [KSF90] <author> Miriam Kamkar, Nahid Shahmehri, and Peter Fritzson. </author> <title> Bug localization by algorithmic debugging and program slicing. </title> <editor> In P. Deransart and J. Ma luszynski, editors, </editor> <booktitle> Proceedings, Programming Language Implementation and Logic Programming, International Workshop PLILP '90, </booktitle> <pages> pages 60-74, </pages> <address> Linkoping, Sweden, </address> <month> August 20-22 </month> <year> 1990. </year> <note> Springer-Verlag. LNCS 456. </note>
Reference-contexts: When used for testing <ref> [LW87, KSF90, PC90, FSKG92] </ref>, parallelization [Wei83, BW88], or program decomposition [RY88, Bin93], the goal is a smaller, faster program that computes the same slicing criterion values as the original program, but without computing other, irrelevant results.
Reference: [LC92] <author> Panos E. Livadas and Stephen Croll. </author> <title> Program slicing. </title> <type> Technical Report SERC-TR-61-F, </type> <institution> Computer and Information Sciences Department, University of Florida, </institution> <address> Gainesville, FL, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Constructing a compilable slice requires specialization of each procedure for each subset of parameters demanded by a call site, so the result is not a subset of the original program. Livadas and Croll <ref> [LC92] </ref> build the system dependence graph incrementally, processing each procedure as it is encountered in a traversal. When a function call is encountered, processing of the current procedure is suspended and a partial solution is preserved; later refinements of that solution require reprocessing of callers. <p> Other authors do not address general pointer manipulation, but Horwitz et al. [HRB90] give two techniques for dealing with aliasing introduced by call-by-reference function parameters. The first technique (also used by Livadas and Croll <ref> [LC92] </ref> to solve the same problem) converts the program into an alias-free one by duplicating each procedure for every possible alias pattern among its (by-reference) parameters and modifying formal parameters and call sites accordingly. <p> Ottenstein and Ottenstein [OO83, OO84] and Tip [Tip94] note that compiler transformations can be of use to a slicer but give no details. Unlike their schemes, our optimizations are unconstrained by the syntax of the original program. Livadas and Croll <ref> [LC92] </ref> independently suggest slicing on a parse tree to improve statement-based slicers. Unlike our implementation, their algorithm includes irrelevant operations (such as the assignment to sum in figure 7 of their paper), and they communicate the slice to the user in terms of whole statements.
Reference: [LW86] <author> Jim Lyle and Mark Weiser. </author> <title> Experiments on slicing-based debugging aids. </title> <editor> In Elliot Soloway and Sitharama Iyengar, editors, </editor> <booktitle> Proceedings of the First Workshop on Empirical Studies of Programmers, </booktitle> <pages> pages 187-197, </pages> <address> Washington, DC, </address> <month> June 5-6, </month> <year> 1986. </year>
Reference-contexts: This modification increases the algorithm's complexity from linear in the size of the VDG to linear in the size of the source code graph, which is approximately the size of the original program. 8 Related work Weiser introduced the concept of slicing [Wei79, Wei84] and showed its application to debugging <ref> [Wei82, LW86, LW87] </ref> and parallelization [Wei83, BW88]. His slicing criteria consist of a statement and a set of variables not necessarily referenced in the statement, and his slices are syntactically correct subsets of the original program with the same termination behavior.
Reference: [LW87] <author> James R. Lyle and Mark Weiser. </author> <title> Automatic program bug location by program slicing. </title> <booktitle> In Proceedings of the Second International Conference on Computers and Applications, </booktitle> <address> Beijing, China, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: When used for testing <ref> [LW87, KSF90, PC90, FSKG92] </ref>, parallelization [Wei83, BW88], or program decomposition [RY88, Bin93], the goal is a smaller, faster program that computes the same slicing criterion values as the original program, but without computing other, irrelevant results. <p> This modification increases the algorithm's complexity from linear in the size of the VDG to linear in the size of the source code graph, which is approximately the size of the original program. 8 Related work Weiser introduced the concept of slicing [Wei79, Wei84] and showed its application to debugging <ref> [Wei82, LW86, LW87] </ref> and parallelization [Wei83, BW88]. His slicing criteria consist of a statement and a set of variables not necessarily referenced in the statement, and his slices are syntactically correct subsets of the original program with the same termination behavior.
Reference: [MNB + 94] <author> Lawrence Markosian, Philip Newcomb, Russell Brand, Scott Burson, and Ted Kitzmiller. </author> <title> Using an enabling technology to reengineer legacy systems. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 58-70, </pages> <month> May </month> <year> 1994. </year>
Reference: [NEK94] <author> Jim Q. Ning, Andre Engberts, and W. (Voytek) Kozaczynski. </author> <title> Automated support for legacy code understanding. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 50-57, </pages> <month> May </month> <year> 1994. </year> <month> 15 </month>
Reference: [OO83] <author> Karl J. Ottenstein and Linda M. Ottenstein. </author> <title> High-level debugging assistance via optimizing compiler technology (extended abstract). </title> <booktitle> In ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-level Debugging, </booktitle> <pages> pages 152-154, </pages> <address> Pacific Grove, CA, </address> <month> March 20-23 </month> <year> 1983. </year>
Reference-contexts: By contrast to these techniques, we use a points-to analysis [HEGV93, EGH93] and add support for aggregates such as C's struct and union types. Ottenstein and Ottenstein <ref> [OO83, OO84] </ref> and Tip [Tip94] note that compiler transformations can be of use to a slicer but give no details. Unlike their schemes, our optimizations are unconstrained by the syntax of the original program. Livadas and Croll [LC92] independently suggest slicing on a parse tree to improve statement-based slicers.
Reference: [OO84] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proc. ACM SIGSOFT/SIGPLAN Software Engineering Symp. on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: The VDG is composed of nodes which represent computation and arcs which carry values between computations. Figure 1 shows a program and its VDG representation. The basic slicing algorithm <ref> [OO84] </ref> on the VDG is extremely simple: the slice consists of all computations encountered in a graph traversal starting at the slicing criterion. A backward slice traversal follows consumer-producer arcs; at call results, it proceeds to all corresponding call returns, and at formal parameters it proceeds to corresponding actual parameters. <p> Weiser treats slicing as a dataflow problem and provides an O (ne log e) algorithm which includes every call site of a function if any call is included. Ottenstein and Ottenstein's linear-time slicing algorithm based on graph reachability <ref> [OO84] </ref> demonstrates the appropriateness of the program dependence graph (PDG) [FOW87, HPR88] for slicing. Slicing criteria are slightly restricted: variables must appear in the specified statement. Most subsequent research builds upon this work. Horwitz et al. [HRB88, HRB90, Bin91, Bin93] extend the PDG algorithm to account for calling context. <p> By contrast to these techniques, we use a points-to analysis [HEGV93, EGH93] and add support for aggregates such as C's struct and union types. Ottenstein and Ottenstein <ref> [OO83, OO84] </ref> and Tip [Tip94] note that compiler transformations can be of use to a slicer but give no details. Unlike their schemes, our optimizations are unconstrained by the syntax of the original program. Livadas and Croll [LC92] independently suggest slicing on a parse tree to improve statement-based slicers.
Reference: [PC90] <author> Andy Podgurski and Lori A. Clarke. </author> <title> A formal model of program dependences and its implications for software testing, debugging, and maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 965-979, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: When used for testing <ref> [LW87, KSF90, PC90, FSKG92] </ref>, parallelization [Wei83, BW88], or program decomposition [RY88, Bin93], the goal is a smaller, faster program that computes the same slicing criterion values as the original program, but without computing other, irrelevant results.
Reference: [RY88] <author> Thomas Reps and Wuu Yang. </author> <title> The semantics of program slicing. </title> <type> Technical Report 777, </type> <institution> University of Wisconsin - Madison, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: When used for testing [LW87, KSF90, PC90, FSKG92], parallelization [Wei83, BW88], or program decomposition <ref> [RY88, Bin93] </ref>, the goal is a smaller, faster program that computes the same slicing criterion values as the original program, but without computing other, irrelevant results.
Reference: [RY89] <author> Thomas Reps and Wuu Yang. </author> <title> The semantics of program slicing and program integration. </title> <editor> In J. Daz and F. Orejas, editors, </editor> <booktitle> TAPSOFT '89: Proceedings of the International Joint Conference on Theory and Practice of Software Development. Vol.2: Advanced Seminar on Foundations of Innovative Software II and Colloquium on Current Issues in Programming Languages (CCIPL), number 352 in Lecture Notes in Computer Science, </booktitle> <pages> pages 360-374, </pages> <address> Barcelona, Spain, March 13-17, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: When used for integration of compatible versions of a program <ref> [RY89, HPR89, HR90, HRB90, Bin91, Bal93] </ref>, an executable slice combines all the features of the various versions. A closure slice, on the other hand, helps a programmer visualize dependences without regard to syntactic constraints.
Reference: [Sta94] <author> Richard Stallman. </author> <title> GNU Emacs Manual. Free Software Foundation, </title> <address> Cambridge, MA, tenth edition, </address> <month> July </month> <year> 1994. </year> <note> ISBN 1-882114-03-5. </note>
Reference-contexts: We enhance work on slicing in the presence of pointers and function calls. We introduce techniques for handling arrays, structures, unions, and expressions with side effects. Our slicer supports the entire C programming language (except longjmp). The implementation is written in Scheme [Han93] and integrated with GNU Emacs <ref> [Sta94] </ref> for input and output; it uses the value dependence graph [WCES94] as its intermediate representation. 1.1 Types of slices Venkatesh [Ven91] categorizes slices into eight types according to three distinctions: backward vs. forward, executable vs. closure, and static vs. dynamic.
Reference: [Tip94] <author> F. </author> <title> Tip. A survey of program slicing techniques. </title> <type> Report CS-R9438, </type> <institution> Centrum voor Wiskunde en Infor-matica (CWI), </institution> <address> Amsterdam, </address> <year> 1994. </year>
Reference-contexts: Including the proper control-flow statements (such as goto) requires special care [JZR91, BH92, Bal93, CF93, Agr94]. Only a limited class of optimizations can be handled <ref> [Tip94] </ref>, since optimized programs can be inexpressible in the original programming language. <p> By contrast to these techniques, we use a points-to analysis [HEGV93, EGH93] and add support for aggregates such as C's struct and union types. Ottenstein and Ottenstein [OO83, OO84] and Tip <ref> [Tip94] </ref> note that compiler transformations can be of use to a slicer but give no details. Unlike their schemes, our optimizations are unconstrained by the syntax of the original program. Livadas and Croll [LC92] independently suggest slicing on a parse tree to improve statement-based slicers. <p> For further references to the extensive slicing literature, see Tip's survey <ref> [Tip94] </ref>. Acknowledgements Daniel Weise, Ellen Spertus, Bjarne Steensgaard, Todd Knoblock, Roger Crew, and Erik Ruf provided stimulating discussions and helpful comments on earlier drafts of this paper. They also assisted in the creation of the programming environment which includes the slicer described in this paper.
Reference: [Ven91] <author> G. A. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 107-119, </pages> <address> Toronto, Ontario, Canada, </address> <month> June 26-28, </month> <year> 1991. </year>
Reference-contexts: Our slicer supports the entire C programming language (except longjmp). The implementation is written in Scheme [Han93] and integrated with GNU Emacs [Sta94] for input and output; it uses the value dependence graph [WCES94] as its intermediate representation. 1.1 Types of slices Venkatesh <ref> [Ven91] </ref> categorizes slices into eight types according to three distinctions: backward vs. forward, executable vs. closure, and static vs. dynamic. This classification will help us to situate this research with respect to previous work.
Reference: [WCES94] <author> Daniel Weise, Roger F. Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <type> Technical Report MSR-TR-94-03, </type> <institution> Microsoft Research, </institution> <address> Redmond, WA, </address> <month> April 13, </month> <year> 1994. </year>
Reference-contexts: We introduce techniques for handling arrays, structures, unions, and expressions with side effects. Our slicer supports the entire C programming language (except longjmp). The implementation is written in Scheme [Han93] and integrated with GNU Emacs [Sta94] for input and output; it uses the value dependence graph <ref> [WCES94] </ref> as its intermediate representation. 1.1 Types of slices Venkatesh [Ven91] categorizes slices into eight types according to three distinctions: backward vs. forward, executable vs. closure, and static vs. dynamic. This classification will help us to situate this research with respect to previous work. <p> A dynamic slice gives definite information for some particular execution by maintaining an execution trace of a running program. This paper discusses only static slicing, which uses analysis to discover dependences. 2 Slicing the value dependence graph Our slicing algorithm operates on the value dependence graph (VDG) <ref> [WCES94] </ref>, a sparse, parallel, functional, dataflow-like program representation. The VDG is composed of nodes which represent computation and arcs which carry values between computations. Figure 1 shows a program and its VDG representation.
Reference: [Wei79] <author> Mark Weiser. </author> <title> Program slices: formal, psychological, and practical investigations of an automatic program abstraction method. </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <address> Ann Arbor, </address> <year> 1979. </year>
Reference-contexts: This modification increases the algorithm's complexity from linear in the size of the VDG to linear in the size of the source code graph, which is approximately the size of the original program. 8 Related work Weiser introduced the concept of slicing <ref> [Wei79, Wei84] </ref> and showed its application to debugging [Wei82, LW86, LW87] and parallelization [Wei83, BW88]. His slicing criteria consist of a statement and a set of variables not necessarily referenced in the statement, and his slices are syntactically correct subsets of the original program with the same termination behavior.
Reference: [Wei80] <author> William E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <booktitle> In Proceedings of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: The recursive and base cases of recursive procedures are assumed to be identifiable. Such slices are as accurate as those based on the system dependence graph but cannot be computed as efficiently [HRB90]. Jiang et al. [JZR91] handle pointers and arrays by means of an alias analysis <ref> [Wei80] </ref>. They introduce a dummy variable for each level of dereference of each pointer variable and a dummy literal for each variable whose address is taken. Modifications of the pointer count as modifications of these dummy variables, and pointer uses count as dummy uses.
Reference: [Wei82] <author> Mark Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <volume> 25(7) </volume> <pages> 446-52, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: This modification increases the algorithm's complexity from linear in the size of the VDG to linear in the size of the source code graph, which is approximately the size of the original program. 8 Related work Weiser introduced the concept of slicing [Wei79, Wei84] and showed its application to debugging <ref> [Wei82, LW86, LW87] </ref> and parallelization [Wei83, BW88]. His slicing criteria consist of a statement and a set of variables not necessarily referenced in the statement, and his slices are syntactically correct subsets of the original program with the same termination behavior.
Reference: [Wei83] <author> Mark Weiser. </author> <title> Reconstructing sequential behavior from parallel behavior projections. </title> <journal> Information Processing Letters, </journal> <volume> 17(5) </volume> <pages> 129-135, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: When used for testing [LW87, KSF90, PC90, FSKG92], parallelization <ref> [Wei83, BW88] </ref>, or program decomposition [RY88, Bin93], the goal is a smaller, faster program that computes the same slicing criterion values as the original program, but without computing other, irrelevant results. <p> complexity from linear in the size of the VDG to linear in the size of the source code graph, which is approximately the size of the original program. 8 Related work Weiser introduced the concept of slicing [Wei79, Wei84] and showed its application to debugging [Wei82, LW86, LW87] and parallelization <ref> [Wei83, BW88] </ref>. His slicing criteria consist of a statement and a set of variables not necessarily referenced in the statement, and his slices are syntactically correct subsets of the original program with the same termination behavior.
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: 1 Introduction A program slice <ref> [Wei84] </ref> captures a subset of a program's behavior. A slice represents either all parts of a program that can affect the slicing criterion|the expression of interest to the user|or all parts of the program whose run-time values may depend on the slicing criterion's value. <p> Slicing on an expression that produces multiple values produces a menu of the expression's results, one of which is selected as the slicing criterion. This mechanism also permits slicing on variables that are not referenced at a program point, which is not supported by other slicers (except <ref> [Wei84] </ref>). Since the global store is represented explicitly in the graph, any live component of it can be sliced upon. There are two complications to slicing on arbitrary variable references. First, optimization (see section 7) can reorder, eliminate, duplicate, and coalesce computations. <p> This modification increases the algorithm's complexity from linear in the size of the VDG to linear in the size of the source code graph, which is approximately the size of the original program. 8 Related work Weiser introduced the concept of slicing <ref> [Wei79, Wei84] </ref> and showed its application to debugging [Wei82, LW86, LW87] and parallelization [Wei83, BW88]. His slicing criteria consist of a statement and a set of variables not necessarily referenced in the statement, and his slices are syntactically correct subsets of the original program with the same termination behavior. <p> Their "chopping" technique, similar to the intersection of forward and backward slices, is the only technique besides ours to permit non-variables (such as the output stream) as slicing criteria; we also permit arbitrary expressions and arbitrary variable references, like Weiser <ref> [Wei84] </ref>. For further references to the extensive slicing literature, see Tip's survey [Tip94]. Acknowledgements Daniel Weise, Ellen Spertus, Bjarne Steensgaard, Todd Knoblock, Roger Crew, and Erik Ruf provided stimulating discussions and helpful comments on earlier drafts of this paper.
References-found: 40

