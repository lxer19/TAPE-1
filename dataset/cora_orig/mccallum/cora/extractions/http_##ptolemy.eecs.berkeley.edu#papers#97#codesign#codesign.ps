URL: http://ptolemy.eecs.berkeley.edu/papers/97/codesign/codesign.ps
Refering-URL: http://ptolemy.eecs.berkeley.edu/papers/97/codesign/
Root-URL: 
Email: sedwards@eecs.berkeley.edu  luciano@cadence.com  eal@eecs.berkeley.edu  alberto@leonardo.parades.rm.cnr.it  
Phone: (510) 643-6686  (408) 428-5326  (510) 642-0455  +39-6-68807923  
Title: Design of Embedded Systems: Formal Models, Validation, and Synthesis  
Author: S. Edwards, L. Lavagno, E. A. Lee, and A. Sangiovanni-Vincentelli Stephen Edwards Luciano Lavagno Edward A. Lee Alberto Sangiovanni-Vincentelli 
Date: 3, March 1997  
Note: European Labs PARADES, a Cadence, Magneti-Marelli and SGS-Thomson European Economic Interest Group. Research partially sponsored by:  under VIP grant. Via  published in: Proceedings of the IEEE, Vol. 85, No.  
Address: 211-48 Cory Hall #1772 Berkeley, CA 94720-1172  1919 Addison St. Suites 303-304 Berkeley, CA 94704-1144  Cory Hall Berkeley, CA 94720-1770  San Pantaleo 66 00186 Roma Italy  
Affiliation: University of California, Berkeley  Politecnico di Torino Cadence Berkeley Laboratories  University of California, Berkeley EECS Dept.,  University of California, Berkeley Cadence  SRC, Magneti-Marelli, Cadence, CNR  di  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Berry, </author> <title> Information Processing, vol. 89, chapter Real Time programming: Special purpose or general purpose languages, </title> <journal> pp. </journal> <pages> 11-17, </pages> <publisher> North Holland-Elsevier Science Publishers, </publisher> <year> 1989. </year>
Reference-contexts: They can be contrasted with interactive systems, which react with the environment at their own speed, and transformational systems, which take a body of input data and transform it into a body of output data <ref> [1] </ref>. A large percentage of the world-wide market for micro-processors is filled by micro-controllers that are the programmable core of embedded systems. In addition to micro-controllers, embedded systems may consist of ASICs and/or field programmable gate arrays as well as other programmable computing units such as Digital Signal Processors (DSPs).
Reference: [2] <author> R. Milner, M. Tofte, and R. Harper, </author> <title> The definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Such an approach is standard in certain communities, where languages with strong formal properties are used to ensure robust design. Examples include ML <ref> [2] </ref>, dataflow languages (e.g. Lucid [3], Haskell [4]) and synchronous languages (e.g., Lustre, Signal, Esterel [5]).
Reference: [3] <author> W. Wadge and E.A. Ashcroft, </author> <title> Lucid, the dataflow programming language, </title> <publisher> Academic Press, </publisher> <year> 1985. </year> <month> 58 </month>
Reference-contexts: Such an approach is standard in certain communities, where languages with strong formal properties are used to ensure robust design. Examples include ML [2], dataflow languages (e.g. Lucid <ref> [3] </ref>, Haskell [4]) and synchronous languages (e.g., Lustre, Signal, Esterel [5]). There is a broad range of potential formalizations of a design, but most tools and designers describe the behavior of a design as a relation between a set of inputs and a set of outputs.
Reference: [4] <author> A. Davie, </author> <title> An introduction to functional programming systems using Haskell, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Such an approach is standard in certain communities, where languages with strong formal properties are used to ensure robust design. Examples include ML [2], dataflow languages (e.g. Lucid [3], Haskell <ref> [4] </ref>) and synchronous languages (e.g., Lustre, Signal, Esterel [5]). There is a broad range of potential formalizations of a design, but most tools and designers describe the behavior of a design as a relation between a set of inputs and a set of outputs.
Reference: [5] <author> N. Halbwachs, </author> <title> Synchronous Programming of Reactive Systems, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Such an approach is standard in certain communities, where languages with strong formal properties are used to ensure robust design. Examples include ML [2], dataflow languages (e.g. Lucid [3], Haskell [4]) and synchronous languages (e.g., Lustre, Signal, Esterel <ref> [5] </ref>). There is a broad range of potential formalizations of a design, but most tools and designers describe the behavior of a design as a relation between a set of inputs and a set of outputs. This relation may be informal, even expressed in natural language. <p> A system is synchronous if every signal in the system is synchronous with every other signal in the system. A discrete-time system is a synchronous discrete-event system. Synchronous/reactive languages (see e.g. <ref> [5] </ref>) are synchronous in exactly this sense. The set of tags in a behavior of the system denotes a global clock for the system. <p> Signal [25] is a textual relational language, also with a dataflow flavor and a more powerful clocking system. Argos [26], a derivative of Harel's Statecharts [27], is a graphical language for describing hierarchical finite state machines. Halbwachs <ref> [5] </ref> gives a good summary of this group of languages. The synchronous/reactive languages describe systems as a set of concurrently-executing synchronized modules. These modules communicate through signals that are either present or absent in each clock tick.
Reference: [6] <author> K. McMillan, </author> <title> Symbolic model checking, </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: The more abstract specification in this case is an executable functional model that is closer to the problem level. 2 The refinement process can be defined formally once the models of the design are formally specified, see McMillan <ref> [6] </ref>. The specification undergoes a synthesis process (which may be partly manual) that generates a model of an implementation in hardware. That model itself may still be fairly abstract, capturing for example only timing properties. In this example the model is presumably used for hardware/software partitioning. <p> Many questions about Petri nets can be answered in finite time. Moreover, a large user community has developed a large body of theoretical results and practical design aids and methods based on them. In particular, partial order-based verification methods (e.g. [50], [51], <ref> [6] </ref>) are one possible answer to the state explosion problem plaguing FSM-based verification techniques. 2.3 Languages The distinction between a language and its underlying model of computation is important. <p> Moreover, self-bisimulation is an equivalence relation among states of an automaton, and hence it can be used to minimize the automaton (the result is called the quotient automaton). In model checking (see, e.g., <ref> [70, 71, 54, 6] </ref>), the system is modeled as a synchronous or asynchronous composition of automata, and the property is described as a formula in some temporal logic [72, 73].
Reference: [7] <author> J. E. Stoy, </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: Operational semantics, which dates back to Turing machines, gives meaning of a language in terms of actions taken by some abstract machine, and is typically closer to the implementation. Denotational semantics, first developed by Scott and Strachey <ref> [7] </ref>, gives the meaning of the language in terms of relations. How the abstract machine in an operational semantics can behave is a feature of what we call the model of computation underlying the language. <p> It is denotational in the Scott and Strachey <ref> [7] </ref> sense, and it defines a semantic framework (of signals and processes) within which models of computation can be studied and compared. It is very abstractdescribing a particular model of computation involves imposing further constraints that make it more concrete.
Reference: [8] <author> E. A. Lee and A. Sangiovanni-Vincentelli, </author> <title> The tagged signal model a preliminary version of a denotational framework for comparing models of computation, </title> <type> Tech. Rep., </type> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Thus we attempt to avoid confusion by being precise, even at the risk of being pedantic. 2.1.1 The Tagged-Signal Model Two of the authors (Lee and Sangiovanni-Vincentelli) have proposed the tagged-signal model <ref> [8] </ref>, a formalism for describing 7 aspects of models of computation for embedded system specification. It is denotational in the Scott and Strachey [7] sense, and it defines a semantic framework (of signals and processes) within which models of computation can be studied and compared. <p> = t 2 , d (t 1 ; t 2 ) = d (t 2 ; t 1 ) and A discrete-event system is a timed system where the tags in each signal are order-isomorphic with the integers (for a two-sided system) or the natural numbers (for a one-sided system) <ref> [8] </ref>. Intuitively, this means that any pair of ordered tags has a finite number of intervening tags. Two events are synchronous if they have the same tag. Two signals are synchronous if each event in one signal is synchronous with an event in the other signal and vice versa. <p> It is a convenient communication mechanism, because it has the semantics of a single assignment, in which the writer provides the right-hand side, and the reader provides the left-hand side. In the tagged-signal model, this is imposed by events with identical tags <ref> [8] </ref>. Lotos offers, in addition, multiple rendezvous, in which one among multiple possible communications is non-deterministically selected. <p> The heterogeneous nature of most embedded systems makes multiple models of computation a necessity. Many models of computation are built by combining three largely orthogonal aspects: sequential behavior, concurrency, and communication. We presented an outline of the tagged-signal model <ref> [8] </ref>, a framework developed by two of the authors to contrast different models of computation. The fundamental entity in the model is an event (a value/tag pair). Tags usually denote temporal behavior, and different models of time appear as structure imposed on the set of all possible tags.
Reference: [9] <author> J. E. Hopcroft and J. D. Ullman, </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: These properties include whether a system will need more memory than is available, whether a system will halt, and how fast a system will run. Hopcroft and Ullman <ref> [9] </ref> discuss these issues at length. Undecidability is not an insurmountable barrier, and decidability is not sufficient to answer all questions in practice (e.g., because the required run-time may be prohibitive). Many successful systems have been designed using undecidable languages (i.e., those in which questions about some programs are undecidable). <p> Control Flow Expressions (CFEs, [21]) have been recently proposed to represent the control flow of a set of operations in a cycle-based specification language. CFEs are an algebraic model extending Regular Expressions <ref> [9] </ref> and can be compiled into 21 FSMs that can be used in the synthesis of a control unit. 2.2.3 Synchronous/Reactive In a synchronous model of computation, all events are synchronous, i.e., all signals have events with identical tags. The tags are totally ordered, and globally available.
Reference: [10] <author> J. T. Buck, </author> <title> Scheduling Dynamic Dataflow Graphs with Bounded Memory Using the Token Flow Model, </title> <type> Ph.D. thesis, </type> <institution> University of California, Berkeley, 1993, Dept. of EECS, </institution> <type> Tech. Report UCB/ERL 93/69. </type>
Reference-contexts: Many successful systems have been designed using undecidable languages (i.e., those in which questions about some programs are undecidable). Although no algorithm can solve an undecidable problem for all systems, algorithms exist that can solve them for most systems. Buck's Boolean Dataflow scheduler <ref> [10] </ref>, for example, can answer the halting and bounded memory problems for many systems specified in a Turing-complete dataflow model, although it does, necessarily, fail to reach a conclusion for some systems. The non-terminating nature of embedded systems opens the possibility of using infinite time to solve certain undecidable problems. <p> Both have the useful property that a finite static schedule can always be found that will return the graph to its original state. This allows for extremely efficient implementations [32]. For more general dataflow models, it is undecidable whether such a schedule exists <ref> [10] </ref>. A looser model of dataflow is the tagged-token model, in which the partial order of tokens is explicitly carried with the tokens [44]. A significant advantage of this model is that while it logically preserves the FIFO semantics of the channels, it permits out-of-order execution.
Reference: [11] <author> T. M. Parks, </author> <title> Bounded Scheduling of Process Networks, </title> <type> Ph.D. thesis, </type> <institution> University of California, Berkeley, </institution> <month> Dec. </month> <year> 1995, </year> <institution> Dept. of EECS, </institution> <type> Tech. Report UCB/ERL 95/105. </type>
Reference-contexts: The non-terminating nature of embedded systems opens the possibility of using infinite time to solve certain undecidable problems. Parks' <ref> [11] </ref> scheduler, for example, will execute a potentially infinite-state system forever in bounded memory if it is possible to do so. However, it does not answer the question of how much memory is needed or whether the program will eventually halt.
Reference: [12] <author> J.C. Shepherdson and H. E. Sturgis, </author> <title> Computability of recursive functions, </title> <journal> Journal of the ACM, </journal> <volume> vol. 10, no. 2, </volume> <pages> pp. 217-255, </pages> <year> 1963. </year>
Reference-contexts: Most commonly-used programming languages (e.g., C, C++, Lisp, Pascal, FORTRAN) use this model of computation. Often, the memory is 4 It is formalized in the abstract model called random access machine or random access stored program <ref> [12] </ref>. 11 viewed as having an unbounded number of finite-valued words, which, when coupled with an appropriate choice of processor instructions, makes the model Turing complete 5 . Modern computer systems make this model practical by simulating unbounded memory with an elaborate hierarchy (registers, cache, RAM, hard disk).
Reference: [13] <author> G. Kahn, </author> <title> The semantics of a simple language for parallel programming, </title> <booktitle> in Proc. of the IFIP Congress 74. 1974, </booktitle> <publisher> North-Holland Publishing Co. </publisher>
Reference-contexts: The tags model the ordering imposed by the FIFO model. If the consumer implements blocking reads, then it imposes a total order on events at all its input signals. This model captures essential properties of both Kahn process networks and dataflow <ref> [13] </ref>. * Bounded FIFO buffered In this case, the data repository is modeled as a process that imposes ordering constraints on its inputs (which come from the producer) and the outputs (which go to the consumer). Each of the input and output signals are internally totally ordered. <p> In the latter case, we are mixing two of the models of computation from figure 2, where dataflow serves as the coordination language for subprograms written in an imperative host language. Dataflow is a special case of Kahn process networks <ref> [13, 31] </ref>. In a Kahn process network, 24 communication is by unbounded FIFO buffering, and processes are constrained to be continuous mappings from input streams to output streams. Continuous in this usage is a topological property that ensures that the program is determinate [13]. <p> In a Kahn process network, 24 communication is by unbounded FIFO buffering, and processes are constrained to be continuous mappings from input streams to output streams. Continuous in this usage is a topological property that ensures that the program is determinate <ref> [13] </ref>. Intuitively, it implies a form of causality without time; specifically, a process can use partial information about its input streams to produce partial information about its output streams.
Reference: [14] <author> J. T. Buck, S. Ha, E. A. Lee, and D. G. Messerschmitt, Ptolemy: </author> <title> A framework for simulating and prototyping heterogeneous systems, </title> <journal> Int. Journal of Computer Simulation, </journal> <volume> vol. 4, no. 155, </volume> <pages> pp. 155-182, </pages> <month> Apr. </month> <year> 1994, </year> <note> Special issue on simulation 59 software development. http://ptolemy.eecs.berkeley.edu/papers/JEurSim.ps.Z. </note>
Reference-contexts: The next firing of C will see the event from A only; the firing after that will see the (delay-delayed) event from B. Other simulators, including the DE simulator in Ptolemy <ref> [14] </ref>, attempt to statically analyze data precedences within a single time instant. Such precedence analysis is similar to that done in synchronous languages (Esterel, Lustre, and Signal) to ensure that simultaneous events are processed deterministically. <p> Most notions, such as composition and so on, can be naturally extended from one model to the other. In fact, any of the concurrency models described in this paper can be usefully combined with FSMs. In the Ptolemy project <ref> [14] </ref>, FSMs are hierarchically nested with dataflow, discrete-event, or synchronous/reactive models [20]. The nesting is arbitrarily deep and can mix concurrency models at different levels of the hierarchy. This very flexible model is called *charts, pronounced star charts, where the asterisk is meant to suggest a wildcard. <p> This is not always possible, but when it is, considerable simplification results [32]. In many existing environments, what happens within a firing can only be specified in a host language with imperative semantics, such as C or C++. In the Ptolemy system <ref> [14] </ref>, it can also consist of a quantum of computation specified with any of several models of computation, such as FSMs, a synchronous/reactive subsystem, or a discrete-event subsystem [33]. <p> A significant advantage of this model is that while it logically preserves the FIFO semantics of the channels, it permits out-of-order execution. Some examples of graphical dataflow programming environments intended for signal processing (including image processing) are Khoros [45], and Ptolemy <ref> [14] </ref>. 2.2.5 Other models Another commonly used partially ordered concurrency model is based on rendezvous. Two or more concurrent sequential processes proceed autonomously, but at certain points in their control flow, coordinate so that they are simultaneously at 26 specified points. <p> For example, it may specify only the interaction between computational modules, and not the computation performed by the modules. Instead, it provides an interface to a host language that specifies the computation, and is called a coordination language (examples include Linda [41], Granular Lucid [39], and Ptolemy domains <ref> [14] </ref>). Or the language may specify only the causality constraints of the interactions without detailing the interactions themselves nor providing an interface to a host language. <p> But what does it mean if two concurrent VHDL entities call C procedures that interact? The problem is exacerbated by the lack of agreed-upon semantics for C or VHDL. Studying the interaction semantics of mixed models of computation is the main objective of the Ptolemy project <ref> [14] </ref>. There, a hierarchical framework is used, where a specification in one model of computation can contain a primitive that is internally implemented using another model of computation. <p> Hardware is the master and software is the slave. In this case, the hardware simulator directly calls communication procedures which, in turn, call user software code. Kalavade and Lee [61] and Lee and Rabaey [63] take a similar approach. The simulation and design environment Ptolemy <ref> [14] </ref> is used to provide an interfacing mechanism between different domains. In Ptolemy, objects described at different levels of abstraction and using different semantic models are composed hierarchically. Each abstraction level, with its own semantic model, is a domain (e.g., dataflow, discrete-event).
Reference: [15] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot, Statemate: </author> <title> A working environment for the development of complex reactive systems, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 16, no. 4, </volume> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: The number of states alone is not always a good indication of complexity, but it often has a strong correlation. Harel advocated the use of three major mechanisms that reduce the size (and hence the visual 19 complexity) of finite automata for modeling practical systems <ref> [15] </ref>. The first one is hierarchy, in which a state can represent an enclosed state machine. That is, being in a particular state a has the interpretation that the state machine enclosed by a is active.
Reference: [16] <author> D. Drusinski and D. Harel, </author> <title> On the power of bounded concurrency. I. Finite automata., </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> vol. 41, no. 3, </volume> <pages> pp. 517-539, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: A system component can also be described non-deterministically to permit some optimization during the implementation phase. Non-determinism can also provide an exponential reduction in complexity. These three mechanisms have been shown in <ref> [16] </ref> to cooperate synergistically and orthogonally, to provide a potential triple exponential reduction in the size of the representation with respect to a single, flat deterministic FSM 6 . 6 The exact claim in [16] was that and type non-determinism (in which all non-deterministic choices must be successful), rather than hierarchical <p> These three mechanisms have been shown in <ref> [16] </ref> to cooperate synergistically and orthogonally, to provide a potential triple exponential reduction in the size of the representation with respect to a single, flat deterministic FSM 6 . 6 The exact claim in [16] was that and type non-determinism (in which all non-deterministic choices must be successful), rather than hierarchical states, was the third source of exponential reduc-20 Harel's Statecharts model uses a synchronous concurrency model (also called synchronous composition).
Reference: [17] <author> M. von der Beeck, </author> <title> A comparison of statecharts variants, in Proc. of Formal Techniques in Real Time and Fault Tolerant Systems. </title> <booktitle> 1994, vol. 863 of LNCS, </booktitle> <pages> pp. 128-148, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Unfortunately, Harel left open some questions about the semantics of causality loops and chains of instantaneous (same tick) events, triggering a flurry of activity in the community that has resulted in at least twenty variants of Statecharts <ref> [17] </ref>. Most of these twenty variants use the synchronous concurrency model. However, for many applications, the tight coordination implied by the synchronous model is inappropriate.
Reference: [18] <author> W. Takach and A. Wolf, </author> <title> An automaton model for scheduling constraints in synchronous machines, </title> <journal> IEEE Tr. on Computers, </journal> <volume> vol. 44, no. 1, </volume> <pages> pp. 1-12, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Most of these twenty variants use the synchronous concurrency model. However, for many applications, the tight coordination implied by the synchronous model is inappropriate. In response to this, a number of more loosely coupled asynchronous FSM models have evolved, including behavioral FSMs <ref> [18] </ref>, SDL process networks [18], tion together with or type non-determinism and concurrency. Hierarchical states, on the other hand, were shown in that paper to be able to simulate and non-determinism with only a polynomial increase in size. and codesign FSMs [19]. <p> Most of these twenty variants use the synchronous concurrency model. However, for many applications, the tight coordination implied by the synchronous model is inappropriate. In response to this, a number of more loosely coupled asynchronous FSM models have evolved, including behavioral FSMs <ref> [18] </ref>, SDL process networks [18], tion together with or type non-determinism and concurrency. Hierarchical states, on the other hand, were shown in that paper to be able to simulate and non-determinism with only a polynomial increase in size. and codesign FSMs [19]. A model that is closely related to FSMs is Finite Automata.
Reference: [19] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli, </author> <title> A formal methodology for hardware/software codesign of embedded systems, </title> <booktitle> IEEE Micro, </booktitle> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: Hierarchical states, on the other hand, were shown in that paper to be able to simulate and non-determinism with only a polynomial increase in size. and codesign FSMs <ref> [19] </ref>. A model that is closely related to FSMs is Finite Automata. FAs emphasize the acceptance or rejection of a sequence of inputs rather than the sequence of output symbols produced in response to a sequence of input symbols.
Reference: [20] <author> W.-T. Chang, A. Kalavade, and E. A. Lee, </author> <title> Effective heterogeneous design and cosimulation, </title> <booktitle> in NATO Advanced Study Institute Workshop on Hardware/Software Codesign, </booktitle> <address> Lake Como, Italy, </address> <month> June </month> <year> 1995, </year> <note> http://ptolemy.eecs.berkeley.edu/papers/effective. </note>
Reference-contexts: In fact, any of the concurrency models described in this paper can be usefully combined with FSMs. In the Ptolemy project [14], FSMs are hierarchically nested with dataflow, discrete-event, or synchronous/reactive models <ref> [20] </ref>. The nesting is arbitrarily deep and can mix concurrency models at different levels of the hierarchy. This very flexible model is called *charts, pronounced star charts, where the asterisk is meant to suggest a wildcard.
Reference: [21] <author> Jr C. N. Coelho and G. De Micheli, </author> <title> Analysis and synthesis of concurrent digital circuits using control-flow expressions, </title> <journal> IEEE Trans. on CAD, </journal> <volume> vol. 15, no. 8, </volume> <pages> pp. 854-876, </pages> <month> Aug. </month> <year> 1996. </year>
Reference-contexts: The nesting is arbitrarily deep and can mix concurrency models at different levels of the hierarchy. This very flexible model is called *charts, pronounced star charts, where the asterisk is meant to suggest a wildcard. Control Flow Expressions (CFEs, <ref> [21] </ref>) have been recently proposed to represent the control flow of a set of operations in a cycle-based specification language.
Reference: [22] <author> A. Benveniste and G. Berry, </author> <title> The synchronous approach to reactive and real-time systems, </title> <journal> Proc. of the IEEE, </journal> <volume> vol. 79, no. 9, </volume> <pages> pp. 1270-1282, </pages> <year> 1991. </year>
Reference-contexts: It is an excellent model for synchronous signal processing systems where sample rates are related by constant rational multiples, but in situations where the alignment of events in different signals is irregular, it can be inefficient. The more general synchronous/reactive model is embodied in the so-called synchronous languages <ref> [22] </ref>. Esterel [23] is a textual imperative language with sequential and concurrent statements 22 that describe hierarchically-arranged processes. Lustre [24] is a textual declarative language with a dataflow flavor and a mechanism for multirate clocking.
Reference: [23] <author> F. Boussinot and R. De Simone, </author> <booktitle> The ESTEREL language, Proc. of the IEEE, </booktitle> <volume> vol. 79, no. 9, </volume> <year> 1991. </year>
Reference-contexts: The more general synchronous/reactive model is embodied in the so-called synchronous languages [22]. Esterel <ref> [23] </ref> is a textual imperative language with sequential and concurrent statements 22 that describe hierarchically-arranged processes. Lustre [24] is a textual declarative language with a dataflow flavor and a mechanism for multirate clocking.
Reference: [24] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud, </author> <title> The synchronous data flow programming language LUSTRE, </title> <journal> Proc. of the IEEE, </journal> <volume> vol. 79, no. 9, </volume> <pages> pp. 1305-1319, </pages> <year> 1991. </year>
Reference-contexts: The more general synchronous/reactive model is embodied in the so-called synchronous languages [22]. Esterel [23] is a textual imperative language with sequential and concurrent statements 22 that describe hierarchically-arranged processes. Lustre <ref> [24] </ref> is a textual declarative language with a dataflow flavor and a mechanism for multirate clocking. Signal [25] is a textual relational language, also with a dataflow flavor and a more powerful clocking system.
Reference: [25] <author> A. Benveniste and P. Le Guernic, </author> <title> Hybrid dynamical systems theory and the SIGNAL language, </title> <journal> IEEE Transactions on Automatic Control, </journal> <volume> vol. 35, no. 5, </volume> <pages> pp. 525-546, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The more general synchronous/reactive model is embodied in the so-called synchronous languages [22]. Esterel [23] is a textual imperative language with sequential and concurrent statements 22 that describe hierarchically-arranged processes. Lustre [24] is a textual declarative language with a dataflow flavor and a mechanism for multirate clocking. Signal <ref> [25] </ref> is a textual relational language, also with a dataflow flavor and a more powerful clocking system. Argos [26], a derivative of Harel's Statecharts [27], is a graphical language for describing hierarchical finite state machines. Halbwachs [5] gives a good summary of this group of languages.
Reference: [26] <author> F. Maraninchi, </author> <title> The Argos language: Graphical representation of automata and description of reactive systems, </title> <booktitle> in Proc. of the IEEE Workshop on Visual Languages, </booktitle> <address> Kobe, Japan, </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Lustre [24] is a textual declarative language with a dataflow flavor and a mechanism for multirate clocking. Signal [25] is a textual relational language, also with a dataflow flavor and a more powerful clocking system. Argos <ref> [26] </ref>, a derivative of Harel's Statecharts [27], is a graphical language for describing hierarchical finite state machines. Halbwachs [5] gives a good summary of this group of languages. The synchronous/reactive languages describe systems as a set of concurrently-executing synchronized modules.
Reference: [27] <author> D. Harel, Statecharts: </author> <title> A visual formalism for complex systems, </title> <journal> Sci. Comput. Program., </journal> <volume> vol. 8, </volume> <pages> pp. 231-274, </pages> <year> 1987. </year>
Reference-contexts: Lustre [24] is a textual declarative language with a dataflow flavor and a mechanism for multirate clocking. Signal [25] is a textual relational language, also with a dataflow flavor and a more powerful clocking system. Argos [26], a derivative of Harel's Statecharts <ref> [27] </ref>, is a graphical language for describing hierarchical finite state machines. Halbwachs [5] gives a good summary of this group of languages. The synchronous/reactive languages describe systems as a set of concurrently-executing synchronized modules. These modules communicate through signals that are either present or absent in each clock tick.
Reference: [28] <author> G. Berry, </author> <title> A hardware implementation of pure Esterel, </title> <booktitle> in Proc. of the Int. Workshop on Formal Methods in VLSI Design, </booktitle> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: In addition to the ability to translate these languages into finite-state descriptions, it is possible to compile these languages directly into hardware. Techniques for translating both Esterel <ref> [28] </ref> and Lustre [29] into hardware have been proposed. The result is a logic network consisting of gates and flip-flops that can be optimized using traditional logic synthesis tools. To execute such a system in software, the resulting network is simply simulated.
Reference: [29] <author> F. Rocheteau and N. Halbwachs, </author> <title> Implementing reactive programs on circuits: A hardware implementation of LUSTRE, </title> <booktitle> in Real-Time, Theory in Practice, REX Workshop Proceedings, Mook, </booktitle> <address> Netherlands, </address> <month> June </month> <year> 1992, </year> <title> vol. </title> <booktitle> 600 of LNCS, </booktitle> <pages> pp. 195-208, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In addition to the ability to translate these languages into finite-state descriptions, it is possible to compile these languages directly into hardware. Techniques for translating both Esterel [28] and Lustre <ref> [29] </ref> into hardware have been proposed. The result is a logic network consisting of gates and flip-flops that can be optimized using traditional logic synthesis tools. To execute such a system in software, the resulting network is simply simulated.
Reference: [30] <author> T. R. Shiple, G. Berry, and H. Touati, </author> <title> Constructive analysis of cyclic circuits, </title> <booktitle> in Proc. of the European Design and Test Conference, </booktitle> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: To execute such a system in software, the resulting network is simply simulated. The technique is also the basis to perform more efficiently causality checks, by means of implicit state space traversal techniques <ref> [30] </ref>. 2.2.4 Dataflow Process Networks In dataflow, a program is specified by a directed graph where the nodes (called actors) represent computations and the arcs represent totally ordered sequences (called streams) of events (called tokens).
Reference: [31] <author> E. A. Lee and T. M. Parks, </author> <title> Dataflow pro cess networks, </title> <booktitle> Proc. of the IEEE, </booktitle> <month> May </month> <year> 1995, </year> <note> http://ptolemy.eecs.berkeley.edu/papers/processNets. </note>
Reference-contexts: In the latter case, we are mixing two of the models of computation from figure 2, where dataflow serves as the coordination language for subprograms written in an imperative host language. Dataflow is a special case of Kahn process networks <ref> [13, 31] </ref>. In a Kahn process network, 24 communication is by unbounded FIFO buffering, and processes are constrained to be continuous mappings from input streams to output streams. Continuous in this usage is a topological property that ensures that the program is determinate [13].
Reference: [32] <author> S. S. Bhattacharyya, P. K. Murthy, and E. A. Lee, </author> <title> Software Synthesis from Dataflow Graphs, </title> <publisher> Kluwer Academic Press, </publisher> <address> Norwood, Mass, </address> <year> 1996. </year>
Reference-contexts: This schedule is a list of firings that can be repeated indefinitely. One cycle through the schedule should return the graph to its original state (here, state is defined as the number of tokens on each arc). This is not always possible, but when it is, considerable simplification results <ref> [32] </ref>. In many existing environments, what happens within a firing can only be specified in a host language with imperative semantics, such as C or C++. <p> Synchronous dataflow (SDF) and cyclo-static dataflow require processes to consume and produce a fixed number of tokens for each firing. Both have the useful property that a finite static schedule can always be found that will return the graph to its original state. This allows for extremely efficient implementations <ref> [32] </ref>. For more general dataflow models, it is undecidable whether such a schedule exists [10]. A looser model of dataflow is the tagged-token model, in which the partial order of tokens is explicitly carried with the tokens [44]. <p> Many static scheduling methods have been developed. Most somehow construct a precedence graph and then apply or adapt classical methods. We refer the reader to Bhattacharyya et al. <ref> [32] </ref> and Sih and Lee [128, 129] as a starting point for scheduling of dataflow graphs. Many approaches to software synthesis for embedded systems divide the computation into cooperating tasks that are scheduled at run time.
Reference: [33] <author> W.-T. Chang, S.-H. Ha, and E. A. Lee, </author> <title> Heterogeneous simulation mixing 61 discrete-event models with dataflow, </title> <editor> J. </editor> <booktitle> on VLSI Signal Processing, </booktitle> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: In the Ptolemy system [14], it can also consist of a quantum of computation specified with any of several models of computation, such as FSMs, a synchronous/reactive subsystem, or a discrete-event subsystem <ref> [33] </ref>. A useful formal device is to constrain the operation 25 of a firing to be functional, i.e., a simple, stateless mapping from input values to output values.
Reference: [34] <author> R. M. Karp and R. E. Miller, </author> <title> Properties of a model for parallel computations: Determinacy, termination, queueing, </title> <journal> SIAM Journal, </journal> <volume> vol. 14, </volume> <pages> pp. 1390-1411, </pages> <month> Nov. </month> <year> 1966. </year>
Reference-contexts: An initial token on this self-loop provides the initial value for the state. Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs <ref> [34] </ref>, Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model [36, 37], Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid [39], and others [40, 41, 42, 43]. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory).
Reference: [35] <author> E. A. Lee and D. G. Messerschmitt, </author> <title> Synchronous data flow, </title> <booktitle> IEEE Proceedings, </booktitle> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: An initial token on this self-loop provides the initial value for the state. Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs <ref> [35] </ref>, Lauwereins et al.'s cyclo-static dataflow model [36, 37], Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid [39], and others [40, 41, 42, 43]. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory).
Reference: [36] <author> R. Lauwereins, P. Wauters, M. Ade, and J. A. Peperstraete, </author> <title> Geometric parallelism and cyclostatic dataflow in GRAPE-II, </title> <booktitle> in Proc. 5th Int. Workshop on Rapid System Prototyping, </booktitle> <address> Grenoble, France, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: An initial token on this self-loop provides the initial value for the state. Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model <ref> [36, 37] </ref>, Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid [39], and others [40, 41, 42, 43]. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory).
Reference: [37] <author> G. Bilsen, M. Engels, R. Lauwereins, and J. A. Peperstraete, </author> <title> Static scheduling of multi-rate and cyclo-static DSP applications, </title> <booktitle> in Proc. 1994 Workshop on VLSI Signal Processing. 1994, </booktitle> <publisher> IEEE Press. </publisher>
Reference-contexts: An initial token on this self-loop provides the initial value for the state. Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model <ref> [36, 37] </ref>, Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid [39], and others [40, 41, 42, 43]. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory).
Reference: [38] <author> D. J. Kaplan et al., </author> <title> Processing graph method specification version 1.0, </title> <institution> The Naval Research Laboratory, </institution> <address> Washington D.C., </address> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model [36, 37], Kaplan et al.'s Processing Graph Method (PGM) <ref> [38] </ref>, Granular Lucid [39], and others [40, 41, 42, 43]. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory). Synchronous dataflow (SDF) and cyclo-static dataflow require processes to consume and produce a fixed number of tokens for each firing.
Reference: [39] <author> R. Jagannathan, </author> <title> Parallel execution of GLU programs, </title> <booktitle> in 2nd Int. Workshop on Dataflow Computing, </booktitle> <address> Hamilton Island, Queensland, Australia, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model [36, 37], Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid <ref> [39] </ref>, and others [40, 41, 42, 43]. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory). Synchronous dataflow (SDF) and cyclo-static dataflow require processes to consume and produce a fixed number of tokens for each firing. <p> For example, it may specify only the interaction between computational modules, and not the computation performed by the modules. Instead, it provides an interface to a host language that specifies the computation, and is called a coordination language (examples include Linda [41], Granular Lucid <ref> [39] </ref>, and Ptolemy domains [14]). Or the language may specify only the causality constraints of the interactions without detailing the interactions themselves nor providing an interface to a host language.
Reference: [40] <author> W. B. Ackerman, </author> <title> Data flow languages, </title> <journal> Computer, </journal> <volume> vol. 15, no. 2, </volume> <year> 1982. </year>
Reference-contexts: Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model [36, 37], Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid [39], and others <ref> [40, 41, 42, 43] </ref>. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory). Synchronous dataflow (SDF) and cyclo-static dataflow require processes to consume and produce a fixed number of tokens for each firing.
Reference: [41] <author> N. Carriero and D. Gelernter, </author> <title> Linda in context, </title> <journal> Comm. of the ACM, </journal> <volume> vol. 32, no. 4, </volume> <pages> pp. 444-458, </pages> <month> Apr. </month> <year> 1989. </year>
Reference-contexts: Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model [36, 37], Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid [39], and others <ref> [40, 41, 42, 43] </ref>. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory). Synchronous dataflow (SDF) and cyclo-static dataflow require processes to consume and produce a fixed number of tokens for each firing. <p> For example, it may specify only the interaction between computational modules, and not the computation performed by the modules. Instead, it provides an interface to a host language that specifies the computation, and is called a coordination language (examples include Linda <ref> [41] </ref>, Granular Lucid [39], and Ptolemy domains [14]). Or the language may specify only the causality constraints of the interactions without detailing the interactions themselves nor providing an interface to a host language.
Reference: [42] <author> F. Commoner and A. W. Holt, </author> <title> Marked directed graphs, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> vol. 5, </volume> <pages> pp. 511-523, </pages> <year> 1971. </year>
Reference-contexts: Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model [36, 37], Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid [39], and others <ref> [40, 41, 42, 43] </ref>. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory). Synchronous dataflow (SDF) and cyclo-static dataflow require processes to consume and produce a fixed number of tokens for each firing.
Reference: [43] <author> P. A. Suhler, J. Biswas, K. M. Korner, and J. C. Browne, Tdfl: </author> <title> A task-level dataflow language, </title> <journal> J. on Parallel and Distributed Systems, </journal> <volume> vol. 9, no. 2, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: Many possibilities have been explored for precise semantics of dataflow coordination languages, including Karp and Miller's computation graphs [34], Lee and Messerschmitt's synchronous dataflow graphs [35], Lauwereins et al.'s cyclo-static dataflow model [36, 37], Kaplan et al.'s Processing Graph Method (PGM) [38], Granular Lucid [39], and others <ref> [40, 41, 42, 43] </ref>. Many of these limit expressiveness in exchange for formal properties (e.g., provable liveness and bounded memory). Synchronous dataflow (SDF) and cyclo-static dataflow require processes to consume and produce a fixed number of tokens for each firing.
Reference: [44] <author> Arvind and K. P. Gostelow, </author> <title> The U-Interpreter, </title> <journal> Computer, </journal> <volume> vol. 15, no. 2, </volume> <year> 1982. </year>
Reference-contexts: This allows for extremely efficient implementations [32]. For more general dataflow models, it is undecidable whether such a schedule exists [10]. A looser model of dataflow is the tagged-token model, in which the partial order of tokens is explicitly carried with the tokens <ref> [44] </ref>. A significant advantage of this model is that while it logically preserves the FIFO semantics of the channels, it permits out-of-order execution.
Reference: [45] <author> J. Rasure and C. S. Williams, </author> <title> An integrated visual language and software development 62 environment, </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> vol. 2, </volume> <pages> pp. 217-246, </pages> <year> 1991. </year>
Reference-contexts: A significant advantage of this model is that while it logically preserves the FIFO semantics of the channels, it permits out-of-order execution. Some examples of graphical dataflow programming environments intended for signal processing (including image processing) are Khoros <ref> [45] </ref>, and Ptolemy [14]. 2.2.5 Other models Another commonly used partially ordered concurrency model is based on rendezvous. Two or more concurrent sequential processes proceed autonomously, but at certain points in their control flow, coordinate so that they are simultaneously at 26 specified points.
Reference: [46] <author> C. A. R. Hoare, </author> <title> Communicating sequential processes, </title> <journal> Comm. of the ACM, </journal> <volume> vol. 21, no. 8, </volume> <year> 1978. </year>
Reference-contexts: Two or more concurrent sequential processes proceed autonomously, but at certain points in their control flow, coordinate so that they are simultaneously at 26 specified points. Rendezvous has been developed into elaborate process calculi (e.g., Hoare's CSP <ref> [46] </ref> and Milner's CCS [47]). It has also been implemented in the Occam and Lotos programming languages. Ada also uses rendezvous, although the implementation is stylistically quite different, using remote procedure calls rather than more elementary synchronization primitives. Rendezvous-based models of computation are often called synchronous. <p> Or the language may specify only the causality constraints of the interactions without detailing the interactions themselves nor providing an interface to a host language. In this case, the language is used as a tool to prove properties of systems, as done, for example, in process calculi <ref> [46, 47] </ref> and Petri nets [48, 49]. In still more abstract modeling, components in the system are replaced with nondeterminate specifications that give constraints on the behavior, but not the behavior itself.
Reference: [47] <author> R. Milner, </author> <title> Communication and Concurrency, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: Two or more concurrent sequential processes proceed autonomously, but at certain points in their control flow, coordinate so that they are simultaneously at 26 specified points. Rendezvous has been developed into elaborate process calculi (e.g., Hoare's CSP [46] and Milner's CCS <ref> [47] </ref>). It has also been implemented in the Occam and Lotos programming languages. Ada also uses rendezvous, although the implementation is stylistically quite different, using remote procedure calls rather than more elementary synchronization primitives. Rendezvous-based models of computation are often called synchronous. <p> Or the language may specify only the causality constraints of the interactions without detailing the interactions themselves nor providing an interface to a host language. In this case, the language is used as a tool to prove properties of systems, as done, for example, in process calculi <ref> [46, 47] </ref> and Petri nets [48, 49]. In still more abstract modeling, components in the system are replaced with nondeterminate specifications that give constraints on the behavior, but not the behavior itself.
Reference: [48] <author> J. L. Peterson, </author> <title> Petri Net Theory and the Modeling of Systems, </title> <publisher> Prentice-Hall Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: Rendezvous-based models of computation are often called synchronous. However, by the definition we have given, they are not synchronous. Events are partially ordered, not totally ordered, with rendezvous points imposing the partial ordering constraints. No discussing of concurrent models of computation would be complete without mentioning Petri nets <ref> [48, 49] </ref>. Petri nets are, in their basic form, neither Turing complete nor finite state. They are interesting as uninterpreted model for several very different classes of problems, including some relevant to embedded system design (e.g., process control, asynchronous communication, scheduling, ...). <p> In this case, the language is used as a tool to prove properties of systems, as done, for example, in process calculi [46, 47] and Petri nets <ref> [48, 49] </ref>. In still more abstract modeling, components in the system are replaced with nondeterminate specifications that give constraints on the behavior, but not the behavior itself.
Reference: [49] <author> W. Reisig, </author> <title> Petri Nets: An Introduction, </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Rendezvous-based models of computation are often called synchronous. However, by the definition we have given, they are not synchronous. Events are partially ordered, not totally ordered, with rendezvous points imposing the partial ordering constraints. No discussing of concurrent models of computation would be complete without mentioning Petri nets <ref> [48, 49] </ref>. Petri nets are, in their basic form, neither Turing complete nor finite state. They are interesting as uninterpreted model for several very different classes of problems, including some relevant to embedded system design (e.g., process control, asynchronous communication, scheduling, ...). <p> In this case, the language is used as a tool to prove properties of systems, as done, for example, in process calculi [46, 47] and Petri nets <ref> [48, 49] </ref>. In still more abstract modeling, components in the system are replaced with nondeterminate specifications that give constraints on the behavior, but not the behavior itself.
Reference: [50] <author> A. Valmari, </author> <title> A stubborn attack on state explosion, </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> vol. 1, no. 4, </volume> <pages> pp. 297-322, </pages> <year> 1992. </year>
Reference-contexts: Many questions about Petri nets can be answered in finite time. Moreover, a large user community has developed a large body of theoretical results and practical design aids and methods based on them. In particular, partial order-based verification methods (e.g. <ref> [50] </ref>, [51], [6]) are one possible answer to the state explosion problem plaguing FSM-based verification techniques. 2.3 Languages The distinction between a language and its underlying model of computation is important.
Reference: [51] <author> P. Godefroid, </author> <title> Using partial orders to improve automatic verification methods, </title> <booktitle> in Proc. of the Computer Aided Verification Workshop, </booktitle> <editor> E.M Clarke and R.P. Kurshan, Eds., </editor> <booktitle> 1990, DIMACS Series in Discrete Mathematica and Theoretical Computer Science, </booktitle> <year> 1991, </year> <pages> pages 321-340. </pages>
Reference-contexts: Many questions about Petri nets can be answered in finite time. Moreover, a large user community has developed a large body of theoretical results and practical design aids and methods based on them. In particular, partial order-based verification methods (e.g. [50], <ref> [51] </ref>, [6]) are one possible answer to the state explosion problem plaguing FSM-based verification techniques. 2.3 Languages The distinction between a language and its underlying model of computation is important.
Reference: [52] <author> E. Dijkstra, </author> <title> Cooperating sequential processes, in Programming Languages, </title> <editor> E. F. Genuys, Ed. </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: It appears that different models fundamentally have different strengths and weaknesses, and that attempts to find their common features result in models that are very low level, difficult to use. These low level models (such as Dijkstra's P/V systems <ref> [52] </ref>) provide a good theoretical foundation, but not a good basis for design. Thus we are faced with two alternatives in designing complex, heterogeneous systems. We can either use a single unified approach and suffer the consequences, or we can mix approaches.
Reference: [53] <author> R. P. Kurshan, </author> <title> Automata-Theoretic Verification of Coordinating Processes, </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: For example, they are often finite-state. Many safety properties (including deadlock detection) can be detected in a time-independent way using existing model checking and language containment methods (see, e.g., Kurshan <ref> [53] </ref> and Burch et al. [54]). Unfortunately, verifying most temporal properties is much more difficult (Alur and Henzinger [55] provide a good summary). Much more research is needed before this is practical. 3.1 Simulation Simulating embedded systems is challenging because they are heterogeneous. <p> In language containment, both the system and the property to be verified are described as a synchronous composition of automata. The proof is carried out by 36 testing whether the language of one is contained in the language of the other (Kurshan's approach is typical <ref> [53] </ref>). One particularly simple case occurs when comparing a synchronous FSM with its hardware implementation. Then both automata are on finite strings, and the proof of equivalence can be performed by traversing the state space of their product [69].
Reference: [54] <author> J. Burch, E. Clarke, K. McMillan, and D. Dill, </author> <title> Sequential circuit verification using symbolic model checking, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <year> 1990, </year> <pages> pp. 46-51. </pages>
Reference-contexts: For example, they are often finite-state. Many safety properties (including deadlock detection) can be detected in a time-independent way using existing model checking and language containment methods (see, e.g., Kurshan [53] and Burch et al. <ref> [54] </ref>). Unfortunately, verifying most temporal properties is much more difficult (Alur and Henzinger [55] provide a good summary). Much more research is needed before this is practical. 3.1 Simulation Simulating embedded systems is challenging because they are heterogeneous. <p> Moreover, self-bisimulation is an equivalence relation among states of an automaton, and hence it can be used to minimize the automaton (the result is called the quotient automaton). In model checking (see, e.g., <ref> [70, 71, 54, 6] </ref>), the system is modeled as a synchronous or asynchronous composition of automata, and the property is described as a formula in some temporal logic [72, 73].
Reference: [55] <author> R. Alur and T.A. Henzinger, </author> <title> Logics and models of real time: A survey, </title> <booktitle> in Real-Time: Theory in Practice. REX Workshop Proc., </booktitle> <editor> J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, Eds., </editor> <year> 1992. </year>
Reference-contexts: For example, they are often finite-state. Many safety properties (including deadlock detection) can be detected in a time-independent way using existing model checking and language containment methods (see, e.g., Kurshan [53] and Burch et al. [54]). Unfortunately, verifying most temporal properties is much more difficult (Alur and Henzinger <ref> [55] </ref> provide a good summary). Much more research is needed before this is practical. 3.1 Simulation Simulating embedded systems is challenging because they are heterogeneous. In particular, most contain both software and hardware components that must be simulated at the same time. This is the co-simulation problem.
Reference: [56] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli, </author> <title> Synthesis and simulation of digital systems containing interacting hardware and 63 software components, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: A unified approach, where the entire system is translated into a form suitable for a single simulator, is conceptually simple, but computationally inefficient. Making better use of computational resources often means distributing the simulation, but synchronization of the processes becomes a challenge. The method proposed by Gupta et al. <ref> [56] </ref> is typical of the unified approach to co-simulation. It relies on a single custom simulator for hardware and software that uses a single event queue and a high-level, bus-cycle model of the target CPU. <p> The output of the algorithm is a netlist of hardware components, initialization routines and I/O driver routines that can be called by the software generation procedure whenever a communication between software and hardware must take place. Gupta et al. <ref> [56, 109] </ref> started their work on software synthesis and scheduling by analyzing various implementation techniques for embedded 53 software. Their specification model is a set of threads, extracted from a Control and DataFlow Graph (CDFG) derived from a C-like HDL called Hardware-C.
Reference: [57] <editor> J. Rowson, Hardware/software co-simulation, </editor> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <year> 1994, </year> <pages> pp. 439-440. </pages>
Reference-contexts: The method proposed by Gupta et al. [56] is typical of the unified approach to co-simulation. It relies on a single custom simulator for hardware and software that uses a single event queue and a high-level, bus-cycle model of the target CPU. Rowson <ref> [57] </ref> takes a more distributed approach that loosely links a hardware simulator with a software process, synchronizing them with the standard interprocess communication mechanisms offered by the host operating system. One of the problems with this approach is that the relative clocks of software and hardware simulation are not synchronized.
Reference: [58] <author> J. Wilson, </author> <title> Hardware/software selected cycle solution, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: This requires the use of handshaking protocols, which may impose an undue burden on the implementation. This may happen, for example, because hardware and software would not need such handshaking since the hardware part runs in reality much faster than in the simulation. Wilson <ref> [58] </ref> describes the use of a commercial hardware simulator. In this approach, the simulator and software compiled on the host processor interact via a bus-cycle emulator inside the hardware simulator. The software and hardware simulator execute in separate processes and the two communicate via UNIX pipes.
Reference: [59] <author> D.E. Thomas, J.K. Adams, and H. Schmitt, </author> <title> A model and methodology for hardware-software codesign, </title> <journal> IEEE Design and Test of Computers, </journal> <volume> vol. 10, no. 3, </volume> <pages> pp. 6-15, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: In this approach, the simulator and software compiled on the host processor interact via a bus-cycle emulator inside the hardware simulator. The software and hardware simulator execute in separate processes and the two communicate via UNIX pipes. Thomas et al. <ref> [59] </ref> take a similar approach. Another approach keeps track of time in software and hardware independently, using various mechanisms to synchronize them periodically. For example, ten Hagen et al. [60] describe a two-level co-simulation environment that combines a timed and untimed level.
Reference: [60] <author> K. ten Hagen and H. Meyr, Timed and untimed hardware/software cosimulation: </author> <title> application and efficient implementation, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The software and hardware simulator execute in separate processes and the two communicate via UNIX pipes. Thomas et al. [59] take a similar approach. Another approach keeps track of time in software and hardware independently, using various mechanisms to synchronize them periodically. For example, ten Hagen et al. <ref> [60] </ref> describe a two-level co-simulation environment that combines a timed and untimed level. The untimed level is used to verify time-independent properties of the system, such as functional correctness. At this level, software and hardware run independent of each 32 other, passing messages whenever needed.
Reference: [61] <author> A. Kalavade and E. A. Lee, </author> <title> Hardware/software co-design using Ptolemy a case study, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Hardware is the master and software is the slave. In this case, the hardware simulator directly calls communication procedures which, in turn, call user software code. Kalavade and Lee <ref> [61] </ref> and Lee and Rabaey [63] take a similar approach. The simulation and design environment Ptolemy [14] is used to provide an interfacing mechanism between different domains. In Ptolemy, objects described at different levels of abstraction and using different semantic models are composed hierarchically. <p> Whenever a galaxy instantiates a galaxy belonging to another domain (typical in co-simulation), Ptolemy provides a mechanism called a wormhole for the two schedulers to communicate. The simplest form of communication is to pass time-stamped events across the interface between domains, with the appropriate data-type conversion. Kalavade and Lee <ref> [61] </ref> perform co-simulation at the specification level by using a dataflow model and at the implementation level by using an ISA processor model augmented with the interfaces within a hardware simulator, both built within Ptolemy.
Reference: [62] <author> S. Sutarwala and P. Paulin, </author> <title> Flexible modeling environment for embedded systems design, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: For example, the software running on the microprocessor can also be run on a host computer, while the DSP software runs on the DSP itself. Sutarwala and Paulin <ref> [62] </ref> describe an environment coupled with a retargetable compiler [64] for cycle-based simulation of a user-definable DSP architecture.
Reference: [63] <author> S. Lee and J.M. Rabaey, </author> <title> A hardware-software co-simulation environment, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Hardware is the master and software is the slave. In this case, the hardware simulator directly calls communication procedures which, in turn, call user software code. Kalavade and Lee [61] and Lee and Rabaey <ref> [63] </ref> take a similar approach. The simulation and design environment Ptolemy [14] is used to provide an interfacing mechanism between different domains. In Ptolemy, objects described at different levels of abstraction and using different semantic models are composed hierarchically. <p> Kalavade and Lee [61] perform co-simulation at the specification level by using a dataflow model and at the implementation level by using an ISA processor model augmented with the interfaces within a hardware simulator, both built within Ptolemy. Lee and Rabaey <ref> [63] </ref> simulate the specification by using concurrent processes communicating via queues within a timed model (the Ptolemy communicating processes domain).
Reference: [64] <author> C. Liem, T. May, and P. Paulin, </author> <title> Register assignment through resource classification for ASIP microcode generation, </title> <booktitle> in Proc. of the Int. Conf. on Computer-Aided Design, </booktitle> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: For example, the software running on the microprocessor can also be run on a host computer, while the DSP software runs on the DSP itself. Sutarwala and Paulin [62] describe an environment coupled with a retargetable compiler <ref> [64] </ref> for cycle-based simulation of a user-definable DSP architecture. <p> These parameters can be derived by compiling and running a few carefully designed benchmarks on the target processor, or on a cycle-accurate emulator or simulator. Liem et al. <ref> [64] </ref> tackle a very different problem, that of retargetable compilation for a generic processor architecture.
Reference: [65] <author> D.L. Dill, </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988, </year> <note> An ACM Distinguished Dissertation 1988. </note>
Reference-contexts: For example, Dill <ref> [65] </ref> describes a method to define and check correct implementation for asynchronous logic circuits in an automata-theoretic framework. In this section we only summarize the major approaches that have been or can be applied to embedded system verification.
Reference: [66] <editor> M.J.C. Gordon and T.F. Melham, Eds., </editor> <title> Introduction to HOL: a theorem proving environment for higher order logic, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year> <month> 64 </month>
Reference-contexts: The assistance can be either in the form of checking the correctness of the proof, or in performing some steps of the proof automatically (e.g., Gordon and Melham's HOL <ref> [66] </ref>, the Boyer-Moore system [67] and PVS [68]). The main problems with this approach are the undecidability of some higher order logics and the large size of the search space even for decidable logics. * Finite automata methods restrict the power of the model in order to automate proofs.
Reference: [67] <author> R.S. Boyer, M. Kaufmann, and J.S. Moore, </author> <title> The Boyer-Moore theorem prover and its interactive enhancement, </title> <journal> Computers & Mathematics with Applications, </journal> <pages> pp. 27-62, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: The assistance can be either in the form of checking the correctness of the proof, or in performing some steps of the proof automatically (e.g., Gordon and Melham's HOL [66], the Boyer-Moore system <ref> [67] </ref> and PVS [68]). The main problems with this approach are the undecidability of some higher order logics and the large size of the search space even for decidable logics. * Finite automata methods restrict the power of the model in order to automate proofs.
Reference: [68] <author> S. Owre, J.M. Rushby, and N. Shankar, PVS: </author> <title> a prototype verification system, </title> <booktitle> in 11th Int. Conf. on Automated Deduction. </booktitle> <address> June 1992, </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The assistance can be either in the form of checking the correctness of the proof, or in performing some steps of the proof automatically (e.g., Gordon and Melham's HOL [66], the Boyer-Moore system [67] and PVS <ref> [68] </ref>). The main problems with this approach are the undecidability of some higher order logics and the large size of the search space even for decidable logics. * Finite automata methods restrict the power of the model in order to automate proofs.
Reference: [69] <author> O. Coudert, C. Berthet, and J. C. Madre, </author> <title> Verification of Sequential Machines Using Boolean Functional Vectors, </title> <booktitle> in IMEC-IFIP Int'l Workshop on Applied Formal Methods for Correct VLSI Design, </booktitle> <month> November </month> <year> 1989, </year> <pages> pp. 111-128. </pages>
Reference-contexts: One particularly simple case occurs when comparing a synchronous FSM with its hardware implementation. Then both automata are on finite strings, and the proof of equivalence can be performed by traversing the state space of their product <ref> [69] </ref>. Simulation relations are an efficient sufficient (i.e., conservative) criterion to establish language containment properties between automata, originating from the process algebraic community ([47, 46]). <p> One may claim that these two (closely related) paradigms represent about the only solutions to the specification verification problem that are currently close to industrial applicability, thanks to: 39 * The development of extremely efficient implicit representation methods for the state space, based on Binary Decision Diagrams ([81], <ref> [69] </ref>), that do not require to represent and store every reachable state of the modeled system explicitly. * The good degree of automation, at least of the property satisfaction or language containment checks themselves (once a suitable abstraction has been found by hand). * The good match between the underlying semantics
Reference: [70] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla, </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications, </title> <journal> ACM TOPLAS, </journal> <volume> vol. 8, no. 2, </volume> <year> 1986. </year>
Reference-contexts: Moreover, self-bisimulation is an equivalence relation among states of an automaton, and hence it can be used to minimize the automaton (the result is called the quotient automaton). In model checking (see, e.g., <ref> [70, 71, 54, 6] </ref>), the system is modeled as a synchronous or asynchronous composition of automata, and the property is described as a formula in some temporal logic [72, 73].
Reference: [71] <author> J. P. Queille and J. Sifakis, </author> <title> Specification and verification of concurrent systems in Cesar, </title> <booktitle> in Int. Symposium on Programming. </booktitle> <address> April 1982, </address> <publisher> LNCS 137, Springer Verlag. </publisher>
Reference-contexts: Moreover, self-bisimulation is an equivalence relation among states of an automaton, and hence it can be used to minimize the automaton (the result is called the quotient automaton). In model checking (see, e.g., <ref> [70, 71, 54, 6] </ref>), the system is modeled as a synchronous or asynchronous composition of automata, and the property is described as a formula in some temporal logic [72, 73].
Reference: [72] <author> A. Pnueli, </author> <title> The temporal logics of programs, </title> <booktitle> in Proc. of the 18 th Annual Symposium on Foundations of Computer Science. </booktitle> <month> May </month> <year> 1977, </year> <note> IEEE Press. </note>
Reference-contexts: In model checking (see, e.g., [70, 71, 54, 6]), the system is modeled as a synchronous or asynchronous composition of automata, and the property is described as a formula in some temporal logic <ref> [72, 73] </ref>. The proof is again carried out by 37 traversing the state space of the automaton and marking the states that satisfy the formula. * Infinite automata methods can deal with infinite state spaces when some minimization to a finite form is possible.
Reference: [73] <author> Z. Manna and A. Pnueli, </author> <title> The temporal logic of reactive and concurrent systems, </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In model checking (see, e.g., [70, 71, 54, 6]), the system is modeled as a synchronous or asynchronous composition of automata, and the property is described as a formula in some temporal logic <ref> [72, 73] </ref>. The proof is again carried out by 37 traversing the state space of the automaton and marking the states that satisfy the formula. * Infinite automata methods can deal with infinite state spaces when some minimization to a finite form is possible.
Reference: [74] <author> R. Alur and D. Dill, </author> <title> Automata for Modeling Real-Time Systems, </title> <booktitle> in Automata, Languages and Programming: 17th Annual Colloquium, 1990, vol. 443 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 322-335, </pages> <institution> Warwick University, </institution> <month> July 16-20. </month>
Reference: [75] <author> P. Cousot and R. Cousot, </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints, </title> <booktitle> in 4th ACM Symp. on Principles of Programming Languages, </booktitle> <address> Los Angeles, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: I.e., the verification system may say that the approximate model does not satisfy the property, while the original one did, thus requiring a better approximation, but it will never say that the approximate model satisfies the property, while the original one did not <ref> [75, 77, 78] </ref>. The quotient with respect to bisimulation can also be used in place of every component, thus providing another mechanism (without false negative results) to fight space explosion.
Reference: [76] <author> J. McManis and P. Varaiya, </author> <title> Suspension automata: a decidable class of hybrid 65 automata, </title> <booktitle> in Proc. of the Sixth Workshop on Computer-Aided Verification, </booktitle> <year> 1994, </year> <pages> pp. 105-117. </pages>
Reference-contexts: Also, clocks can only be compared against integer values and initialized to integer values. In this case, it is possible to show that only a finite set of equivalence class representatives is sufficient to represent exactly the behavior of the timed automaton ([75, 74]). McManis and Varaiya <ref> [76] </ref> introduced the notion of suspension, which extends the class of systems that can be modeled with variations of timed automata.
Reference: [77] <author> J. R. Burch, </author> <title> Automatic Symbolic Verification of Real-Time Concurrent Systems, </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon University, </institution> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: I.e., the verification system may say that the approximate model does not satisfy the property, while the original one did, thus requiring a better approximation, but it will never say that the approximate model satisfies the property, while the original one did not <ref> [75, 77, 78] </ref>. The quotient with respect to bisimulation can also be used in place of every component, thus providing another mechanism (without false negative results) to fight space explosion.
Reference: [78] <author> E. Clarke, O. Grumberg, and D. </author> <title> Long, Model checking and abstraction, </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> vol. 16, no. 5, </volume> <pages> pp. 1512-1542, </pages> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: I.e., the verification system may say that the approximate model does not satisfy the property, while the original one did, thus requiring a better approximation, but it will never say that the approximate model satisfies the property, while the original one did not <ref> [75, 77, 78] </ref>. The quotient with respect to bisimulation can also be used in place of every component, thus providing another mechanism (without false negative results) to fight space explosion.
Reference: [79] <author> A. Mazurkiewicz, </author> <title> Traces, histories, graphs: Instances of a process monoid, </title> <booktitle> in Proc. Conf. on Mathematical Foundations of Computer Science, </booktitle> <editor> M. P. Chytil and V. Koubek, Eds. </editor> <year> 1984, </year> <note> vol. 176 of LNCS, Springer-Verlag. </note>
Reference-contexts: Some such methods are based on the so-called Mazurkiewicz traces, in which a trace is an equivalence class of sequences of state transitions where concurrent transitions are permuted <ref> [79, 80] </ref>. Model checking and language containment have been especially useful in verifying the correctness of protocols, which are particularly well-suited to the finite automaton model due to their relative data independence.
Reference: [80] <author> M. L. de Souza and R. de Simone, </author> <title> Using partial orders for verifying behavioral equivalences, </title> <booktitle> in Proc. of CONCUR '95, </booktitle> <year> 1995. </year>
Reference-contexts: Some such methods are based on the so-called Mazurkiewicz traces, in which a trace is an equivalence class of sequences of state transitions where concurrent transitions are permuted <ref> [79, 80] </ref>. Model checking and language containment have been especially useful in verifying the correctness of protocols, which are particularly well-suited to the finite automaton model due to their relative data independence.
Reference: [81] <author> R. Bryant, </author> <title> Graph-based algorithms for boolean function manipulation, </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-35, no. 8, </volume> <pages> pp. 677-691, </pages> <month> August </month> <year> 1986. </year>
Reference: [82] <author> J.R. Burch and D.L. Dill, </author> <title> Automatic verification of pipelined microprocessor control, </title> <booktitle> in Proc. of the Sixth Workshop on Computer-Aided Verification, </booktitle> <year> 1994, </year> <pages> pp. 68-80. </pages>
Reference-contexts: The first problem can be tackled by first assuming equality of arithmetic functions with the same name used at different levels of modeling (e.g., specification and implementation, see Burch and Dill <ref> [82] </ref>) and then separately verifying that a given piece of hardware implements correctly a given arithmetic function (see Bryant [83]).
Reference: [83] <author> R.E. Bryant and Y-A Chen, </author> <title> Verification of arithmetic circuits with Binary Moment Diagrams, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <year> 1995, </year> <pages> pp. 535-541. </pages>
Reference-contexts: The first problem can be tackled by first assuming equality of arithmetic functions with the same name used at different levels of modeling (e.g., specification and implementation, see Burch and Dill [82]) and then separately verifying that a given piece of hardware implements correctly a given arithmetic function (see Bryant <ref> [83] </ref>). The timing verification problem for sequential systems, on the other hand, still needs to be formulated in a way that permits the solution of practical problems in a reasonable amount of space and time.
Reference: [84] <author> F. Balarin and A. Sangiovanni-Vincentelli, </author> <title> A verification strategy for timing-constrained systems, </title> <booktitle> in Proc. of the Fourth Workshop on Computer-Aided Verification, </booktitle> <year> 1992, </year> <pages> pp. 148-163. </pages>
Reference-contexts: The timing verification problem for sequential systems, on the other hand, still needs to be formulated in a way that permits the solution of practical problems in a reasonable amount of space and time. One possibility, proposed almost simultaneously by <ref> [84] </ref> and [85], is to incrementally add timing constraints to an initially untimed model, rather than immediately building the full-blown timed automaton.
Reference: [85] <author> R. Alur, A. Itai, R. Kurshan, and M. Yannakakis, </author> <title> Timing verification by successive approximation, </title> <booktitle> in Proc. of the Computer Aided Verification Workshop, </booktitle> <year> 1993, </year> <pages> pp. 137-150. </pages>
Reference-contexts: The timing verification problem for sequential systems, on the other hand, still needs to be formulated in a way that permits the solution of practical problems in a reasonable amount of space and time. One possibility, proposed almost simultaneously by [84] and <ref> [85] </ref>, is to incrementally add timing constraints to an initially untimed model, rather than immediately building the full-blown timed automaton. This addition should be done iteratively, to gradually eliminate all false violations of the desired properties due to the fact that some timing properties of the model have been ignored.
Reference: [86] <author> J. Buck, S. Ha, E.A. Lee, and D.G. Masserschmitt, Ptolemy: </author> <title> a framework for simulating and prototyping heterogeneous systems, </title> <journal> Interntional Journal of Computer Simulation, </journal> <volume> vol. </volume> <booktitle> special issue on Simulation Software Development, </booktitle> <month> January </month> <year> 1990. </year>
Reference: [87] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, et al., STATEMATE: </author> <title> a working environment for the development of complex reactive systems, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 16, no. 4, </volume> <month> Apr. </month> <year> 1990. </year>
Reference: [88] <author> P. J. Ramadge and W. M. Wonham, </author> <title> The control of discrete event systems, </title> <journal> Proc. of the IEEE, </journal> <volume> vol. 77, no. 1, </volume> <month> January </month> <year> 1989. </year>
Reference: [89] <author> G. Hoffmann and H. Wong-Toi, </author> <title> Symbolic synthesis of supervisory controllers, </title> <booktitle> in American Control Conference, </booktitle> <address> Chicago, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Recent papers dealing with variations on this problem are, for example, <ref> [89, 90] </ref>. 4.1 Mapping from Specification to Architecture The problem of architecture selection and/or design is one of the key aspects of the design of embedded systems.
Reference: [90] <author> M. Di Benedetto, A. Saldanha, and A. Sangiovanni-Vincentelli, </author> <title> Strong model matching for finite state machines, </title> <booktitle> in Proc. of the Third European Control Conf., </booktitle> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: Recent papers dealing with variations on this problem are, for example, <ref> [89, 90] </ref>. 4.1 Mapping from Specification to Architecture The problem of architecture selection and/or design is one of the key aspects of the design of embedded systems.
Reference: [91] <author> M. Theissinger, P. Stravers, and H. Veit, </author> <title> CASTLE: an interactive environment for hardware-software co-design, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: Few papers have been published on automating the design of, say, a memory hierarchy or an I/O subsystem based on standard components. Notable exceptions to this rule are papers dealing with retargetable compilation (e.g., Theissinger et al. <ref> [91] </ref>), or with a very abstract formulation of partitioning for co-design (e.g., Kumar et al. [92, 93], Prakash and Parker [94], and Vahid and Gajski [95]). The structure of the application-specific hardware components, on the other hand, is generally much less constrained. <p> The cost of a given partition is a simple weighted sum of area, pin, chip count, and performance constraint satisfaction measures. Steinhausen et al. <ref> [106, 91, 115] </ref> describe a complete co-synthesis environment in which a CDFG representation is derived from an array of specification formats, such as Verilog, VHDL and C.
Reference: [92] <author> S. Kumar, J. H. Aylor, B. W. Johnson, and W. A. Wulf, </author> <title> A framework for hardware/software codesign, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Notable exceptions to this rule are papers dealing with retargetable compilation (e.g., Theissinger et al. [91]), or with a very abstract formulation of partitioning for co-design (e.g., Kumar et al. <ref> [92, 93] </ref>, Prakash and Parker [94], and Vahid and Gajski [95]). The structure of the application-specific hardware components, on the other hand, is generally much less constrained. Often, the communication mechanisms are also tem performance or causes a catastrophic failure. 43 standardized for a given methodology. <p> Uncommitted blocks are assigned to hardware or software starting from the block which has most to gain from a specific choice. The initial partition is then improved by a Kernighan and Lin-like iterative swapping procedure. Kumar et al. <ref> [92, 93] </ref>, on the other hand, consider partitioning in a very general and abstract form. They use a complex, set-based representation of the system, its various implementation choices and the various costs associated with them. Cost attributes are determined mainly by profiling.
Reference: [93] <author> S. Kumar, J. H. Aylor, B. Johnson, and W. Wulf, </author> <title> Exploring hardware/software abstractions and alternatives for codesign, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Notable exceptions to this rule are papers dealing with retargetable compilation (e.g., Theissinger et al. [91]), or with a very abstract formulation of partitioning for co-design (e.g., Kumar et al. <ref> [92, 93] </ref>, Prakash and Parker [94], and Vahid and Gajski [95]). The structure of the application-specific hardware components, on the other hand, is generally much less constrained. Often, the communication mechanisms are also tem performance or causes a catastrophic failure. 43 standardized for a given methodology. <p> Uncommitted blocks are assigned to hardware or software starting from the block which has most to gain from a specific choice. The initial partition is then improved by a Kernighan and Lin-like iterative swapping procedure. Kumar et al. <ref> [92, 93] </ref>, on the other hand, consider partitioning in a very general and abstract form. They use a complex, set-based representation of the system, its various implementation choices and the various costs associated with them. Cost attributes are determined mainly by profiling.
Reference: [94] <author> S. Prakash and A. Parker, </author> <title> Synthesis of application-specific multi-processor architectures, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Notable exceptions to this rule are papers dealing with retargetable compilation (e.g., Theissinger et al. [91]), or with a very abstract formulation of partitioning for co-design (e.g., Kumar et al. [92, 93], Prakash and Parker <ref> [94] </ref>, and Vahid and Gajski [95]). The structure of the application-specific hardware components, on the other hand, is generally much less constrained. Often, the communication mechanisms are also tem performance or causes a catastrophic failure. 43 standardized for a given methodology.
Reference: [95] <author> F. Vahid and D. G. Gajski, </author> <title> Specification partitioning for system design, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1992. </year> <month> 67 </month>
Reference-contexts: Notable exceptions to this rule are papers dealing with retargetable compilation (e.g., Theissinger et al. [91]), or with a very abstract formulation of partitioning for co-design (e.g., Kumar et al. [92, 93], Prakash and Parker [94], and Vahid and Gajski <ref> [95] </ref>). The structure of the application-specific hardware components, on the other hand, is generally much less constrained. Often, the communication mechanisms are also tem performance or causes a catastrophic failure. 43 standardized for a given methodology. <p> To guide the search process, it uses both critical path information and the suitability of a node to hardware or software. For example, bit manipulations are better suited to hardware while random accesses to a data structure are better suited to software. Vahid, Gajski et al. <ref> [95, 114] </ref> perform graph-based partitioning of a variable-grained specification. The specification language is SpecCharts, a hierarchical model in which the leaves are states of a hierarchical Statecharts-like finite state machine. These states can contain arbitrarily complex behavioral VHDL processes, written in a high-level specification style.
Reference: [96] <author> P. Chou, E.A. Walkup, and G. Borriello, </author> <title> Scheduling for reactive real-time systems, </title> <journal> IEEE Micro, </journal> <volume> vol. 14, no. 4, </volume> <pages> pp. 37-47, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: Few choices, often closely tied to the communication mechanism used at the specification level, are offered to the designer. Nonetheless, some work has been done on the design of interfaces (e.g., Chou et al. <ref> [96] </ref>). 4.2 Partitioning Partitioning is a problem with any design using more than one component. It is a particularly interesting problem in embedded systems because of the heterogeneous hardware/software mixture. <p> Processes can be merged and split, and the hierarchy can be changed by splitting, moving and clustering of subunits. The sequencing of these operations is currently done by the user. Finally, Chou et al. <ref> [96] </ref> and Walkup and Borriello [119] describe a specialized, scheduling-based algorithm for interface partitioning. The algorithm is based on a graph model derived from a formalized timing diagram. Nodes represent low-level events in the interface specification. <p> Parallel processor support generally consists of analyzing the schedulability of a given assignment of tasks to processors, providing the designer with feedback about potential bottlenecks and sources of deadlocks. Chou et al. <ref> [96] </ref> advocate developing new techniques based on a better knowledge of the domain. The problem they consider is to find a valid schedule of processes specified in Verilog under given timing constraints.
Reference: [97] <author> J. Henkel, R. Ernst, U. Holtmann, and T. Benner, </author> <title> Adaptation of partitioning and high-level synthesis in hardware/software co-synthesis, </title> <booktitle> in Proc. of the Int. Conf. on Computer-Aided Design, </booktitle> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Ernst et al. <ref> [110, 111, 97] </ref> use a graph-based model, with nodes corresponding to elementary operations (statements in C*, a C-like language extended with concurrency).
Reference: [98] <author> K. Olokutun, R. Helaihel, J. Levitt, and R. Ramirez, </author> <title> A software-hardware cosynthesis approach to digital system simulation, </title> <journal> IEEE Micro, </journal> <volume> vol. 14, no. 4, </volume> <pages> pp. 48-58, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: The inner loop uses simulated annealing, with a quick estimation of the gain derived by moving an operation between hardware and software, to improve an initial partition. The outer loop uses synthesis to refine the estimates used in the inner loop. Olokutun et al. <ref> [98] </ref> perform performance-driven partitioning working on a block-by-block basis. The specification model is a hardware description language. This allows them to use synthesis for hardware cost estimation, and profiling of a compiled-code simulator for software cost estimation.
Reference: [99] <author> X. Hu, J.G. D'Ambrosio, B. T. Murray, and D-L Tang, </author> <title> Codesign of architectures for powertrain modules, </title> <journal> IEEE Micro, </journal> <volume> vol. 14, no. 4, </volume> <pages> pp. 48-58, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: The partitioning process is followed by a decomposition of each function into virtual instruction sets, followed by design of an implementation for the set using the available resources, and followed again by an evaluation phase. D'Ambrosio et al. <ref> [112, 99] </ref> tackle the problem of choosing a set of processors on which a set of cooperating tasks can be executed while meeting real-time constraints. They also use a mathematical formulation, but provide an optimal solution procedure by using branch-and-bound.
Reference: [100] <author> E. Barros, W. Rosenstiel, and X. Xiong, </author> <title> Hardware/software partitioning with UNITY, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Other optimization criteria can be included beside schedulability, such as response times to tasks with soft deadlines, hardware costs, and expandability, which favors software solutions. Barros et al. <ref> [100] </ref> use a graph-based fine-grained representation, with each unit corresponding to a simple statement in the Unity specification language.
Reference: [101] <author> E. Barros and A. Sampaio, </author> <title> Towards provably correct hardware/software partitioning using OCCAM, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1994. </year>
Reference: [102] <author> A. Kalavade and E.A. Lee, </author> <title> A global criticality/local phase driven algorithm for the constrained hardware/software partitioning problem, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: They cluster the units to minimize the cost of cuts in the clustering tree, and then improve the clustering by considering pipelining opportunities, allocations done at the previous stage, and cost savings due to resource sharing. Kalavade and Lee <ref> [102] </ref> use an acyclic dependency graph derived from a dataflow graph to 46 simultaneously map each node (task) to software or hardware and schedule the execution of the tasks. The approach is heuristic, and can give an approximate solution to very large problem instances.
Reference: [103] <author> J.K. Adams, H. Schmitt, and D.E. Thomas, </author> <title> A model and methodology for hardware-software codesign, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference: [104] <author> P. Eles, Z. Peng, and A. Doboli, </author> <title> VHDL system-level specification and partitioning in a hardware/software cosynthesis environment, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Sept. </month> <year> 1994. </year>
Reference: [105] <author> W. Luk and T. Wu, </author> <title> Towards a declarative framework for hardware-software codesign, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference: [106] <author> U. Steinhausen, R. Camposano, H Gunther, P. Ploger, M. Theissinger, et al., </author> <title> System-synthesis using hardware/software codesign, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The cost of a given partition is a simple weighted sum of area, pin, chip count, and performance constraint satisfaction measures. Steinhausen et al. <ref> [106, 91, 115] </ref> describe a complete co-synthesis environment in which a CDFG representation is derived from an array of specification formats, such as Verilog, VHDL and C.
Reference: [107] <author> T.B. Ismail, M. Abid, and A.A. Jerraya, COSMOS: </author> <title> a codesign approach for communicating systems, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: ASIC synthesis is done with a commercial tool, while software synthesis, both for general-purpose and specialized processors, is done with an existing retargetable compiler developed by Hoogerbrugge et al. [116]. Ben Ismail et al. <ref> [107] </ref> and Voss et al. [117] start from a system specification described in SDL ([118]). The specification is then translated into the Solar internal representation, based on a hierarchical interconnection of communicating processes.
Reference: [108] <author> S. Antoniazzi, A. Balboni, W. Fornaciari, and D. Sciuto, </author> <title> A methodology for control-dominated systems codesign, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference: [109] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli, </author> <title> Program implementation schemes for hardware-software systems, </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 48-55, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The output of the algorithm is a netlist of hardware components, initialization routines and I/O driver routines that can be called by the software generation procedure whenever a communication between software and hardware must take place. Gupta et al. <ref> [56, 109] </ref> started their work on software synthesis and scheduling by analyzing various implementation techniques for embedded 53 software. Their specification model is a set of threads, extracted from a Control and DataFlow Graph (CDFG) derived from a C-like HDL called Hardware-C.
Reference: [110] <author> R. Ernst and J. Henkel, </author> <title> Hardware-software codesign of embedded controllers based on hardware extraction, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Ernst et al. <ref> [110, 111, 97] </ref> use a graph-based model, with nodes corresponding to elementary operations (statements in C*, a C-like language extended with concurrency).
Reference: [111] <author> J. Henkel, T. Benner, and R. Ernst, </author> <title> Hardware generation and partitioning effects in the COSYMA system, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Ernst et al. <ref> [110, 111, 97] </ref> use a graph-based model, with nodes corresponding to elementary operations (statements in C*, a C-like language extended with concurrency).
Reference: [112] <author> J.G. D'Ambrosio and X.B. Hu, </author> <title> Configuration-level hardware/software partitioning for real-time embedded systems, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: The partitioning process is followed by a decomposition of each function into virtual instruction sets, followed by design of an implementation for the set using the available resources, and followed again by an evaluation phase. D'Ambrosio et al. <ref> [112, 99] </ref> tackle the problem of choosing a set of processors on which a set of cooperating tasks can be executed while meeting real-time constraints. They also use a mathematical formulation, but provide an optimal solution procedure by using branch-and-bound.
Reference: [113] <author> C. Liu and J.W Layland, </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment, </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 44-61, </pages> <month> Jan. </month> <year> 1973. </year>
Reference-contexts: They also use a mathematical formulation, but provide an optimal solution procedure by using branch-and-bound. The cost of a software partition is estimated as a lower and an upper bound on processor utilization. The upper bound is obtained by rate-monotonic analysis (see Liu and Layland <ref> [113] </ref>), while the lower bound is obtained by various refinements of the sum of task computation times divided by task periods. The branch-and-bound procedure uses the bounds to prune the search space, while looking for optimal assignments of functions to components, and satisfying the timing constraints. <p> Embedded systems with fairly restricted specification paradigms are an easier target for specialized scheduling techniques than fully general algorithms written in an arbitrary high-level language. The former approach uses, for example, Rate Monotonic Analysis (RMA <ref> [113] </ref>) to perform schedulability analysis. In the pure RMA model, tasks are invoked periodically, can be preempted, have deadlines equal to their invocation period, and system overhead (context switching, interrupt response time, and so on) is negligible.
Reference: [114] <author> D. D. Gajski, S. Narayan, L. Ramachandran, and F. Vahid, </author> <title> System design methodologies: aiming at the 100 h design 69 cycle, </title> <journal> IEEE Trans. on VLSI, </journal> <volume> vol. 4, no. 1, </volume> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: To guide the search process, it uses both critical path information and the suitability of a node to hardware or software. For example, bit manipulations are better suited to hardware while random accesses to a data structure are better suited to software. Vahid, Gajski et al. <ref> [95, 114] </ref> perform graph-based partitioning of a variable-grained specification. The specification language is SpecCharts, a hierarchical model in which the leaves are states of a hierarchical Statecharts-like finite state machine. These states can contain arbitrarily complex behavioral VHDL processes, written in a high-level specification style.
Reference: [115] <author> J. Wilberg, R. Camposano, and W. Rosenstiel, </author> <title> Design flow for hardware/software cosynthesis of a video compression system, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: The cost of a given partition is a simple weighted sum of area, pin, chip count, and performance constraint satisfaction measures. Steinhausen et al. <ref> [106, 91, 115] </ref> describe a complete co-synthesis environment in which a CDFG representation is derived from an array of specification formats, such as Verilog, VHDL and C. <p> One exception to this rule are authors who propose the simultaneous design of a computer architecture and of the program that must run on it (e.g., Menez et al. [120], Marwedel [121], and Wilberg et al. <ref> [115] </ref>). Since the designers of general-purpose CPUs face different problems than the designers of embedded systems, we will only consider those authors who synthesize an Application-Specific Instruction Processor (ASIP, [122]) and the micro-code that runs on it.
Reference: [116] <author> J. Hoogerbrugge and H. Corporaal, </author> <title> Transport-triggering vs. </title> <booktitle> operation-triggering, in 5th Int. Conf. on Compiler Construction, </booktitle> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: ASIC synthesis is done with a commercial tool, while software synthesis, both for general-purpose and specialized processors, is done with an existing retargetable compiler developed by Hoogerbrugge et al. <ref> [116] </ref>. Ben Ismail et al. [107] and Voss et al. [117] start from a system specification described in SDL ([118]). The specification is then translated into the Solar internal representation, based on a hierarchical interconnection of communicating processes.
Reference: [117] <author> M. Voss, T. Ben Ismail, A.A. Jerraya, and K-H. Kapp, </author> <title> Towards a theory for hardware-software codesign, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: ASIC synthesis is done with a commercial tool, while software synthesis, both for general-purpose and specialized processors, is done with an existing retargetable compiler developed by Hoogerbrugge et al. [116]. Ben Ismail et al. [107] and Voss et al. <ref> [117] </ref> start from a system specification described in SDL ([118]). The specification is then translated into the Solar internal representation, based on a hierarchical interconnection of communicating processes. Processes can be merged and split, and the hierarchy can be changed by splitting, moving and clustering of subunits.
Reference: [118] <author> S. Saracco, J. R. W. Smith, and R. Reed, </author> <title> Telecommunications Systems Engineering Using SDL, </title> <publisher> North-Holland - Elsevier, </publisher> <year> 1989. </year>
Reference: [119] <author> E. Walkup and G. Borriello, </author> <title> Automatic synthesis of device drivers for hardware-software codesign, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Processes can be merged and split, and the hierarchy can be changed by splitting, moving and clustering of subunits. The sequencing of these operations is currently done by the user. Finally, Chou et al. [96] and Walkup and Borriello <ref> [119] </ref> describe a specialized, scheduling-based algorithm for interface partitioning. The algorithm is based on a graph model derived from a formalized timing diagram. Nodes represent low-level events in the interface specification.
Reference: [120] <author> G. Menez, M. Auguin, F Boeri, and C. Carriere, </author> <title> A partitioning algorithm for system-level synthesis, </title> <booktitle> in Proc. of the Int. Conf. on Computer-Aided Design, </booktitle> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: One exception to this rule are authors who propose the simultaneous design of a computer architecture and of the program that must run on it (e.g., Menez et al. <ref> [120] </ref>, Marwedel [121], and Wilberg et al. [115]). Since the designers of general-purpose CPUs face different problems than the designers of embedded systems, we will only consider those authors who synthesize an Application-Specific Instruction Processor (ASIP, [122]) and the micro-code that runs on it.
Reference: [121] <author> P. Marwedel, </author> <title> Tree-based mapping of algorithms to predefined structures, </title> <booktitle> in Proc. of the Int. Conf. on Computer-Aided Design, </booktitle> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: One exception to this rule are authors who propose the simultaneous design of a computer architecture and of the program that must run on it (e.g., Menez et al. [120], Marwedel <ref> [121] </ref>, and Wilberg et al. [115]). Since the designers of general-purpose CPUs face different problems than the designers of embedded systems, we will only consider those authors who synthesize an Application-Specific Instruction Processor (ASIP, [122]) and the micro-code that runs on it. <p> Their register assignment scheme is based on the notion of classes of registers, describing which type of operation can use which register. This information is used during CDFG covering with processor instructions [136] to minimize the number of moves required to save registers into temporary locations. 55 Marwedel <ref> [121] </ref> also uses a similar CDFG covering approach. The source specification can be written in VHDL or in the Pascal-like language Mimola. The purpose is micro-code generation for Very Long Instruction Word (VLIW) processors, and in this case the instruction set has not been defined yet.
Reference: [122] <author> P. Paulin, </author> <title> DSP design tool requirements for embedded systems: a telecommunications industrial perspective, </title> <journal> Journal of VLSI Signal Processing, </journal> <volume> vol. 9, no. </volume> <pages> 1-2, pp. 22-47, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Since the designers of general-purpose CPUs face different problems than the designers of embedded systems, we will only consider those authors who synthesize an Application-Specific Instruction Processor (ASIP, <ref> [122] </ref>) and the micro-code that runs on it.
Reference: [123] <author> G. De Micheli, </author> <title> Synthesis and optimization of digital circuits, </title> <publisher> McGraw-Hill, </publisher> <year> 1994. </year>
Reference-contexts: The hardware synthesis task for ASICs used in embedded systems (whether they are implemented on FPGAs or not) is generally performed according to the classical high-level and logic synthesis methods. These techniques have been worked on extensively; for example, recent books by De Micheli <ref> [123] </ref>, Devadas, Gosh and Keutzer [124], and Camposano and Wolf [125] describe them in detail. Marwedel and Goossens [126] present a good overview of code generation strategies for DSPs and ASIPs. The software synthesis task for embedded systems, on the other hand, is a relatively new problem.
Reference: [124] <author> S. Devadas, A. Ghosh, and K. Keutzer, </author> <title> Logic synthesis, </title> <publisher> McGraw-Hill, </publisher> <year> 1994. </year> <month> 70 </month>
Reference-contexts: The hardware synthesis task for ASICs used in embedded systems (whether they are implemented on FPGAs or not) is generally performed according to the classical high-level and logic synthesis methods. These techniques have been worked on extensively; for example, recent books by De Micheli [123], Devadas, Gosh and Keutzer <ref> [124] </ref>, and Camposano and Wolf [125] describe them in detail. Marwedel and Goossens [126] present a good overview of code generation strategies for DSPs and ASIPs. The software synthesis task for embedded systems, on the other hand, is a relatively new problem.
Reference: [125] <editor> R. Camposano and W. Wolf, Eds., </editor> <title> High-level VLSI synthesis, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: These techniques have been worked on extensively; for example, recent books by De Micheli [123], Devadas, Gosh and Keutzer [124], and Camposano and Wolf <ref> [125] </ref> describe them in detail. Marwedel and Goossens [126] present a good overview of code generation strategies for DSPs and ASIPs. The software synthesis task for embedded systems, on the other hand, is a relatively new problem.
Reference: [126] <author> P. Marwedel and G. Goossens, Eds., </author> <title> Code generation for embedded processors, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: These techniques have been worked on extensively; for example, recent books by De Micheli [123], Devadas, Gosh and Keutzer [124], and Camposano and Wolf [125] describe them in detail. Marwedel and Goossens <ref> [126] </ref> present a good overview of code generation strategies for DSPs and ASIPs. The software synthesis task for embedded systems, on the other hand, is a relatively new problem. Traditionally, software synthesis has been regarded with suspicion, mainly due to excessive claims made during its infancy.
Reference: [127] <author> W.A. Halang and A.D. Stoyenko, </author> <title> Constructing predictable real time systems, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Concurrent tasks are an excellent specification mechanism, but cannot be implemented as such on a standard CPU. The scheduling problem (reviewed e.g. by Halang and Stoyenko <ref> [127] </ref>) amounts to finding a linear execution order for the elementary operations composing the tasks, so that all the timing constraints are satisfied.
Reference: [128] <author> G. C. Sih and E. A. Lee, </author> <title> Declustering: A new multiprocessor scheduling technique, </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> vol. 4, no. 6, </volume> <pages> pp. 625-637, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Many static scheduling methods have been developed. Most somehow construct a precedence graph and then apply or adapt classical methods. We refer the reader to Bhattacharyya et al. [32] and Sih and Lee <ref> [128, 129] </ref> as a starting point for scheduling of dataflow graphs. Many approaches to software synthesis for embedded systems divide the computation into cooperating tasks that are scheduled at run time.
Reference: [129] <author> G. C. Sih and E. A. Lee, </author> <title> A compile-time scheduling heuristic for interconnection-constrained heterogeneous processor architectures, </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> vol. 4, no. 2, </volume> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Many static scheduling methods have been developed. Most somehow construct a precedence graph and then apply or adapt classical methods. We refer the reader to Bhattacharyya et al. [32] and Sih and Lee <ref> [128, 129] </ref> as a starting point for scheduling of dataflow graphs. Many approaches to software synthesis for embedded systems divide the computation into cooperating tasks that are scheduled at run time.
Reference: [130] <author> M. Cochran, </author> <title> Using the rate monotonic analysis to analyze the schedulability of ADARTS real-time software designs, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Sept. </month> <year> 1992. </year>
Reference: [131] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli, </author> <title> Hardware/software codesign of embedded systems, </title> <journal> IEEE Micro, </journal> <volume> vol. 14, no. 4, </volume> <pages> pp. 26-36, </pages> <month> Aug. </month> <year> 1994. </year>
Reference: [132] <author> P. Chou and G. Borriello, </author> <title> Software scheduling in the co-synthesis of reactive real-time systems, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Then the partial order is linearized by using a longest-path algorithm to check feasibility and assign start times to the operations. The same group describes in <ref> [132] </ref> a technique for device driver synthesis, targeted towards microcontrollers with specialized I/O ports. It takes as input a specification of the system to be implemented, a description of the function and structure of each I/O port (a list of bits and directions), and a list of communication instructions.
Reference: [133] <author> R.K. Gupta and G. De Micheli, </author> <title> Constrained software generation for hardware-software systems, </title> <booktitle> in Proc. of the Int. Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year>
Reference-contexts: The coroutine-based approach is more flexible (coroutines can be nested, e.g. to respond to urgent interrupts), but more expensive (due to the need to switch context) than the case-based approach. The same group developed in <ref> [133] </ref> a scheduling method for reactive real-time systems. The cost model takes into account the processor type, the memory model, and the instruction execution time. The latter is derived bottom-up from the CDFG by assigning a processor and memory-dependent cost to each leaf operation in the CDFG.
Reference: [134] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli, </author> <title> Synthesis of software programs from CFSM specifications, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Unbounded-time operations, on the other hand, are implemented by a call to the runtime scheduler, which may cause a context switch in favor of another more urgent thread. Chiodo et al. <ref> [134] </ref> also propose a software synthesis method from extended asynchronous Finite State Machines (called Co-design Finite 54 State Machines, CFSMs). The method takes advantage of optimization techniques from the hardware synthesis domain.
Reference: [135] <author> K. Suzuki and A. Sangiovanni-Vincentelli, </author> <title> Efficient software performance estimation 71 methods for hardware/software codesign, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <year> 1996. </year>
Reference: [136] <author> C. Liem, T. May, and P. Paulin, </author> <title> Instruction set matching and selection for DSP and ASIP code generation, </title> <booktitle> in European Design and Test Conf., </booktitle> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: Their register assignment scheme is based on the notion of classes of registers, describing which type of operation can use which register. This information is used during CDFG covering with processor instructions <ref> [136] </ref> to minimize the number of moves required to save registers into temporary locations. 55 Marwedel [121] also uses a similar CDFG covering approach. The source specification can be written in VHDL or in the Pascal-like language Mimola.

References-found: 136

