URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--94-02--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Keyword: Nondeterminism Bjorn Lisper  
Web: ISRN SICS-R-94/02-SE  
Abstract: SICS research report R94:02 ISSN 0283-3638 Unfolding of Programs with 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Proc. Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 31-46, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Therefore, establishing correctness is important from an implementation point of view. The concept of semantics-preservation can be formulated for transformations on expressions in general. Thus, the possible preservation of semantics can be assessed for other source-to-source optimizing transformations than unfolding. If terms with explicit substitutions <ref> [1] </ref> are introduced, for instance, then transformations that yield sharing of subexpressions can be expressed as a term rewrite system with non-left-linear rules.
Reference: [2] <author> A. Arnold, P. Naudin, and M. Nivat. </author> <title> On semantics of nondeterministic recursive program schemes. </title> <editor> In M. Nivat and J. C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 1, </booktitle> <pages> pages 1-33. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: We would like to point out the relationship with previous work on operational semantics for nondeterministic programs, <ref> [2, 5] </ref>. Proposition 6.6 in [2] is very much the same as our corollary 1 in the special case when a deterministic language is extended with pure nondeterministic choice. On the other hand, their result is with regard to a more developed semantics that takes infinite computations into account. <p> We would like to point out the relationship with previous work on operational semantics for nondeterministic programs, [2, 5]. Proposition 6.6 in <ref> [2] </ref> is very much the same as our corollary 1 in the special case when a deterministic language is extended with pure nondeterministic choice. On the other hand, their result is with regard to a more developed semantics that takes infinite computations into account.
Reference: [3] <author> H. P. Barendregt. </author> <title> The Lambda Calculus Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981. </year>
Reference-contexts: An abstract reduction strategy w.r.t. ! is a function F such that F (a) = a if F is a normal form, and a ! F (a) otherwise. Confluence and termination is defined similarly to the same concepts for relations, see [13] for the details (also cf. <ref> [3, p. 351] </ref>). We are especially interested in reduction systems over terms. In order to define them we need the concepts of position and replacement. We define a position in a term to be a sequence of nonnegative integers, where fl denotes the empty sequence.
Reference: [4] <author> G. Berry and J.-J. Levy. </author> <title> Minimal and optimal computations of recursive programs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 26(1) </volume> <pages> 148-175, </pages> <month> Jan. </month> <year> 1979. </year>
Reference-contexts: Sometimes we will consider pure term rewriting systems and sometimes systems that possibly contain other types of reductions, like fi-reduction. We will call such more general systems "term reduction systems". Finally, we need the notion of residual (cf. <ref> [4] </ref>). Formally, we express this as a relation between "old" and "new" positions. This relation is a function of the expression e to be rewritten, the position p of the redex, and the matching rewrite rule (s; t).
Reference: [5] <author> G. Boudol. </author> <title> Computational semantics of term rewriting systems. </title> <editor> In M. Nivat and J. C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 5, </booktitle> <pages> pages 170-236. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: We would like to point out the relationship with previous work on operational semantics for nondeterministic programs, <ref> [2, 5] </ref>. Proposition 6.6 in [2] is very much the same as our corollary 1 in the special case when a deterministic language is extended with pure nondeterministic choice. On the other hand, their result is with regard to a more developed semantics that takes infinite computations into account. <p> Proposition 6.6 in [2] is very much the same as our corollary 1 in the special case when a deterministic language is extended with pure nondeterministic choice. On the other hand, their result is with regard to a more developed semantics that takes infinite computations into account. Boudol <ref> [5] </ref> points out that in for computations defined by term rewriting systems in general, the full substitution evaluation rule is not correct, i.e. other evaluation orders can sometimes produce results that the full substitution evaluation rule 14 cannot.
Reference: [6] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: The result can then be manipulated in various ways. One possibility is to apply algebraic rewritings followed by a fold forming a new recursive definition, as in Burstall's and Darlington's classical fold-unfold-transformations <ref> [6, 9] </ref>. Another possibility is to take advantage of the possible simplifications that often occur when an unfolded function definition occurs in a calling environment, whith actual arguments instead of formal arguments. This is a common transformation in partial evaluation [11].
Reference: [7] <author> J. M. Cadiou. </author> <title> Recursive Definitions of Partial Functions and their Computation. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, California, </institution> <year> 1972. </year>
Reference-contexts: The full substitution evaluation rule is known to be a fixpoint computation rule <ref> [7] </ref>, i.e. it terminates with the correct answer exactly when the function that is least fixpoint solution of the recursive definition is defined. It can be informally described as follows. In order to compute a function call f (a 1 : : : a n ), do the following: 1.
Reference: [8] <author> B. Courcelle. </author> <title> Recursive applicative program schemes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, chapter 9, </booktitle> <pages> pages 459-492. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1990. </year>
Reference-contexts: Clearly, total unfolding will not terminate here. 1 In [13], a formal model for unfolding is developed, along the lines of recursive applicative program schemes <ref> [8, 14] </ref>. The model is used to prove a theorem that under certain conditions relates termination of symbolic unfolding to the termination of a call to the original function. It is also shown that unfolding preserves the semantics. <p> instance, a function definition expressed as ff x 1 : : : x n :eg will be expressed as the rewrite rule f (x 1 : : : x n ) ! e: This is actually more in accordance with the tradition for recursive applicative program schemes: see, for instance <ref> [8] </ref> or [14]. All results so far carry over directly. Definition 6 A rewrite rule (s; t) is flat if s is of the form f (x 1 : : : x n ), where x 1 : : : x n are variables.
Reference: [9] <author> J. Darlington and R. M. Burstall. </author> <title> A system which automatically improves programs. </title> <journal> Acta Inform., </journal> <volume> 6(1) </volume> <pages> 41-60, </pages> <year> 1976. </year> <month> 15 </month>
Reference-contexts: The result can then be manipulated in various ways. One possibility is to apply algebraic rewritings followed by a fold forming a new recursive definition, as in Burstall's and Darlington's classical fold-unfold-transformations <ref> [6, 9] </ref>. Another possibility is to take advantage of the possible simplifications that often occur when an unfolded function definition occurs in a calling environment, whith actual arguments instead of formal arguments. This is a common transformation in partial evaluation [11].
Reference: [10] <author> G. Huet. </author> <title> Confluent reductions: Abstract properties and applications to term rewriting systems. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 27(4) </volume> <pages> 797-821, </pages> <month> Oct. </month> <year> 1980. </year>
Reference-contexts: It has the property that 1 2 (e) = 1 ( 2 (e)) always. We will use reduction systems (sometimes called abstract reduction systems) to give semantics of operators. For completeness, we give the basic definitions. Also see <ref> [10] </ref> or [12]. Let !, ! 1 , ! 2 be binary relations over some set A. ! fl denotes the transitive-reflexive closure of !.
Reference: [11] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <address> Hertfordshire, UK, </address> <year> 1993. </year>
Reference-contexts: Another possibility is to take advantage of the possible simplifications that often occur when an unfolded function definition occurs in a calling environment, whith actual arguments instead of formal arguments. This is a common transformation in partial evaluation <ref> [11] </ref>. Partial evaluation refers to the technique of how to derive a specialized instance of a general function definition. In the type case, a recursive function definition f (x; y) = e is given.
Reference: [12] <author> J. W. Klop. </author> <title> Term rewriting systems. </title> <editor> In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> vol. 2, chapter 1, </volume> <pages> pages 1-116. </pages> <publisher> Oxford University Press, Oxford, </publisher> <year> 1992. </year>
Reference-contexts: It has the property that 1 2 (e) = 1 ( 2 (e)) always. We will use reduction systems (sometimes called abstract reduction systems) to give semantics of operators. For completeness, we give the basic definitions. Also see [10] or <ref> [12] </ref>. Let !, ! 1 , ! 2 be binary relations over some set A. ! fl denotes the transitive-reflexive closure of !. <p> Proof. See [15], [14], or the survey <ref> [12] </ref>. 7 a 0 a 1 a 2 N fl // fl ** D fl ** Note that if ! N is nonconfluent and ! D has a non-left-linear rule they will typically not commute. To see why, consider the following example. <p> Let R 1 given by f (x) ! R 1 and let R 2 be given by f (g (x)) ! R 2: Then both R 1 and R 2 are correct since each one is by itself confluent (left-linear and non-overlapping, see <ref> [12] </ref>). But as we saw before, R 1 [ R 2 is not correct.
Reference: [13] <author> B. Lisper. </author> <title> Total unfolding: </title> <journal> Theory and applications. </journal> <note> Accepted for publication in Journal of Functional Programming, </note> <year> 1993. </year>
Reference-contexts: It may, however, fail to terminate. A simple example is unfolding of f (3; n) rather than f (x; 3): f 3 (n) if (n = 0; 1; 3 f (3; n 1)) . . . Clearly, total unfolding will not terminate here. 1 In <ref> [13] </ref>, a formal model for unfolding is developed, along the lines of recursive applicative program schemes [8, 14]. The model is used to prove a theorem that under certain conditions relates termination of symbolic unfolding to the termination of a call to the original function. <p> The model is used to prove a theorem that under certain conditions relates termination of symbolic unfolding to the termination of a call to the original function. It is also shown that unfolding preserves the semantics. A short review of the results in <ref> [13] </ref> is given in section 3. All the above holds for purely functional, deterministic programs. The purpose of this paper is to extend the previous results for unfolding to programs with nonde-terminism. <p> An abstract reduction strategy w.r.t. ! is a function F such that F (a) = a if F is a normal form, and a ! F (a) otherwise. Confluence and termination is defined similarly to the same concepts for relations, see <ref> [13] </ref> for the details (also cf. [3, p. 351]). We are especially interested in reduction systems over terms. In order to define them we need the concepts of position and replacement. <p> residuals originating from P after several rewritings, i.e. in an expression e 0 where e ! fl R e 0 (with the obvious definition for the case e ! 0 R e 0 ). 3 Unfolding of Deterministic Programs The following is a review of the models and results in <ref> [13] </ref>. First, we give an evaluation model for recursive programs. <p> Given -, * and a set of terms under consideration, it is of course interesting to establish confluence and termination of F : see the discussion in <ref> [13] </ref>. In all "reasonable" cases, when deterministic operations are modeled, F will have these properties. One full step of the full substitution rule can now be expressed as the function F fl on terms. Repeated application of F fl models several steps of the full substitution rule. <p> Another concept that is needed is that of potential X-match: essentially, e has a potential X-match if there is a way to instantiate the variables outside X so that an erasing reduction can occur. See <ref> [13] </ref> for the formal definitions. <p> Not surprisingly, confluence and termination of F is crucial for proving this theorem (see <ref> [13] </ref> for the details). Consider now the classical pattern for partial evaluation: a partially instantiated function call f (x; c), where c is a constant and x is a variable, relative to a totally instantiated function call f (b; c) where also b is a constant. <p> Proof. The proof is analogous to the proof of theorem 2 given in <ref> [13] </ref>. <p> Theorem 3 and corollary 1 can be trivially extended to sets of terms. As in the deterministic case <ref> [13] </ref> the proof above also shows that any "prematurely interrupted" unfolding (that is: (D fl ) n t, where (D fl ) n t 6= (D fl ) fl t) is also (weakly) semantics-preserving. <p> This is because termination here is obtained through nondeterministic reductions. Theorem 1 guarantees termination only relative to termination caused by deterministic reductions in D. We now consider criteria to ensure correctness of R. First, the deterministic case (cf. <ref> [13] </ref>): Proposition 2 If ! R is confluent (and terminating), then R is correct. Proof. Since then both R fl R fl t and R fl t are singletons, so they must be equal. We will now prove correctness for a class of nonconfluent term rewriting systems.
Reference: [14] <author> J.-C. Raoult and J. Vuillemin. </author> <title> Operational and semantic equivalence between recursive programs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 27(4) </volume> <pages> 772-796, </pages> <month> Oct. </month> <year> 1980. </year>
Reference-contexts: Clearly, total unfolding will not terminate here. 1 In [13], a formal model for unfolding is developed, along the lines of recursive applicative program schemes <ref> [8, 14] </ref>. The model is used to prove a theorem that under certain conditions relates termination of symbolic unfolding to the termination of a call to the original function. It is also shown that unfolding preserves the semantics. <p> Proof. See [15], <ref> [14] </ref>, or the survey [12]. 7 a 0 a 1 a 2 N fl // fl ** D fl ** Note that if ! N is nonconfluent and ! D has a non-left-linear rule they will typically not commute. To see why, consider the following example. <p> function definition expressed as ff x 1 : : : x n :eg will be expressed as the rewrite rule f (x 1 : : : x n ) ! e: This is actually more in accordance with the tradition for recursive applicative program schemes: see, for instance [8] or <ref> [14] </ref>. All results so far carry over directly. Definition 6 A rewrite rule (s; t) is flat if s is of the form f (x 1 : : : x n ), where x 1 : : : x n are variables.
Reference: [15] <author> B. K. Rosen. </author> <title> Tree-manipulating systems and Church-Rosser theorems. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 20(1) </volume> <pages> 160-187, </pages> <month> Jan. </month> <year> 1973. </year> <month> 16 </month>
Reference-contexts: Proof. See <ref> [15] </ref>, [14], or the survey [12]. 7 a 0 a 1 a 2 N fl // fl ** D fl ** Note that if ! N is nonconfluent and ! D has a non-left-linear rule they will typically not commute. To see why, consider the following example.
References-found: 15

