URL: http://www.icsi.berkeley.edu/ftp/global/pub/real/formella/rayhis.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/ftp/global/pub/real/formella/
Root-URL: http://www.icsi.berkeley.edu
Title: Fast Ray Tracing of Sequences by Ray History Evaluation  
Author: Arno Formella Christian Gill, Volker Hofmeyer 
Address: Berkeley, CA, 94704, USA 66041 Saarbrucken, Germany  
Affiliation: International Computer Computer Science Department Science Institute University of the Saarland  
Abstract: We present a method to reduce the time needed to render a sequence of ray traced images. We exploit the temporal and spatial coherence between consecutive frames. The algorithm does not only inspect the image plane in order to find regions with minor changes; the object space is analyzed by evaluating the so called ray history. With this method we obtain a speedup in the range of 1.2 to 2.8 almost without visible loss of quality. The method is more or less independent of the used ray trace algorithm and can be implemented in many ray trace programs without too much effort. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> ACM. Online Computer Graphics Bibliography, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Since then a lot of improvements to the basic algorithm have been developed. Excellent references to the ray tracing literature are gathered for instance in the bibliographies of Speer in [24] and of ACM Sig-Graph in <ref> [1] </ref>. We focus on a method to reduce the render time for a sequence of ray traced frames. This means that not a single frame is rendered faster, but information of previous calculations is re-used in consecutive, correlated frames. We use the coherence normally found in a typical picture.
Reference: [2] <author> Taka-aki Akimoto, Kenji Mase, Ak-ihiko Hashimoto, and Yasuhito Suenaga. </author> <title> Pixel Selected Ray Tracing. </title> <editor> In W. Hansmann, F. R. A. Hopgood, and W. Strasser, editors, </editor> <volume> Eurograph-ics '89, </volume> <pages> pages 39-50. </pages> <publisher> North-Holland, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: Furthermore, all segments of the curves are detected, which are covered eventually by other polygons moving around. Once all visible segments are precalcu-lated, rendering can be performed fast. Pixel selected ray tracing is introduced in <ref> [2] </ref> and incremental ray tracing is presented in [21]. Those are the bases for our algorithm and thus explained in the next section in more detail. <p> Akimoto et al. use the ray-object intersection trees for adaptive undersampling in <ref> [2] </ref>. They decided recursively in four levels how to determine the color of the center pixel of a square if the four corners are pre-calculated (see figure 2). If different objects occur in the ray-object intersection trees of the corners real ray tracing is performed for the center (level 1). <p> The amount of memory to implement the data structures is very high and a moving camera can not be handled. Shadow rays are included in a similar manner without intersection histories. We use a similar approach as in <ref> [2] </ref> to implement adaptive undersampling in time. We apply the concept of extending the ray-object intersection trees found in [21] as well, but reduce it to single pixels. The next section describes our algorithm.
Reference: [3] <author> Arthur Appel. </author> <title> Some Techniques for Shading Machine Renderings of Solids. </title> <booktitle> In AFIPS 1968 Spring Joint Computer Conf., </booktitle> <volume> volume 32, </volume> <pages> pages 37-45, </pages> <year> 1968. </year>
Reference-contexts: Nevertheless todays fast computers and advanced ray tracing algorithms allow to render single frames within minutes. Ray tracing was first introduced by Appel in <ref> [3] </ref>. Early optimizations, such as recursion, bounding volumes and adaptive oversampling, which led to significantly better run times, have been studied by Whitted in [25]. Since then a lot of improvements to the basic algorithm have been developed.
Reference: [4] <author> James Arvo and David B. Kirk. </author> <title> Fast Ray Tracing by Ray Classification. </title> <editor> In Maureen C. Stone, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '87 Proceedings), </booktitle> <volume> volume 21, </volume> <pages> pages 55-64, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: In [11] he extends the data structure with a time axis to allow for animations. Ray tracing with ray classification (i. e. grouping rays according to their direction) is proposed by Arvo et al. in <ref> [4] </ref> as a very fast rendering algorithm. Introducing the time as an additional dimension to this approach is done by Groller et al. in [12].
Reference: [5] <author> Sig Badt, Jr. </author> <title> Two Algorithms for Taking Advantage of Temporal Coherence in Ray Tracing. </title> <journal> The Visual Computer, </journal> <volume> 4(3) </volume> <pages> 123-132, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: This knowledge can be used to reduce the time spent in the intersection calculation. As examples for the case of parametric surfaces we refer to the works of Kijiya in [18], Joy et al. in [17] or Lischin-ski [19]. Badt suggests in <ref> [5] </ref> an image space temporal coherence algorithm to accelerate frame by frame rendering. The first frame is traced entirely. In the following frames, first only randomly or heuristically chosen pixels are traced. <p> If the velocity exceeds a particular threshold oversampling in that region can be used to reduce aliasing or flickering of objects which have small spatial angles. The flood-fill algorithm introduced by Badt in <ref> [5] </ref> seems to be appropriate to determine the extent of such a region. A time comsuming operation of our algorithm is the comparison of two ray histories. A speedup is only gained if the histories are equal. Thus the entire information in the trees must be compared.
Reference: [6] <author> J. Chapman, T. W. Calvert, and J. Dill. </author> <title> Spatio-Temporal Coherence in Ray Tracing. </title> <booktitle> In Proceedings of Graphics Interface '91, </booktitle> <pages> pages 101-108, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Then, real ray tracing is performed again. As an heuristic a reprojection algorithm is presented. Another method to reduce the time for finding intersection points is introduced by Chapman et al. in <ref> [6] </ref>. Assume that all polygons and the camera are moving on curves defined through polynoms, if they move at all. Every ray describes a polynomial, maybe piecewise, curve on the polygon which it hits during the motion.
Reference: [7] <author> Arno Formella, Christian Gill, and Dirk Ower-feldt. </author> <title> A Hierarchical, Automatically Generated Space Subdivision for Ray Tracing with Fast Bounding Volume Search. </title> <note> In to be published, </note> <year> 1994. </year>
Reference-contexts: Practically, the speedup will depend on the length of the film and it will be a little bit smaller as it has been stated above. The algorithm has been implemented in a version of CGR, a fast ray tracer with automatical object oriented space subdivision [9] and <ref> [7] </ref>. We now compare the standard ray tracing time with our new approach.
Reference: [8] <author> Akira Fujimoto and Kansei Iwata. </author> <title> Accelerated Ray Tracing. </title> <editor> In Tosiyasu Kunii, editor, </editor> <booktitle> Computer Graphics: Visual Technology and Art (Proceedings of Computer Graphics Tokyo '85), </booktitle> <pages> pages 41-65, </pages> <address> New York, 1985. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: They suggest a 5 fi 5 pixel square. Murakami and Hirota [21] extend the data structure of a ray-object intersection tree. Their ray tracer uses as subdivision method a regular grid as it has been introduced by Fujimoto <ref> [8] </ref>. They add to the ray-object intersection tree a voxel traversal history and intersection histories. The voxel traveral history is a list of all voxels traversed by the incoming ray of the node.
Reference: [9] <author> Christian Gill. </author> <title> Implementierung von parallelem Ray Tracing auf DATIS-P-32. </title> <type> Master's thesis, </type> <institution> University of the Saarland, Department of Computer Science, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Practically, the speedup will depend on the length of the film and it will be a little bit smaller as it has been stated above. The algorithm has been implemented in a version of CGR, a fast ray tracer with automatical object oriented space subdivision <ref> [9] </ref> and [7]. We now compare the standard ray tracing time with our new approach.
Reference: [10] <author> Andrew S. Glassner. </author> <title> Space Subdivision for Fast Ray Tracing. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 4(10) </volume> <pages> 15-22, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: In section 4 we address this point more precisely. Naturally, the spatial coherence is the base of many subdivision strategies using hierarchical data structures. Glassner suggests in <ref> [10] </ref> the octree to speedup the process of finding the intersection points. In [11] he extends the data structure with a time axis to allow for animations.
Reference: [11] <author> Andrew S. Glassner. </author> <title> Spacetime Ray Tracing for Animation. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 8(2) </volume> <pages> 60-70, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: In section 4 we address this point more precisely. Naturally, the spatial coherence is the base of many subdivision strategies using hierarchical data structures. Glassner suggests in [10] the octree to speedup the process of finding the intersection points. In <ref> [11] </ref> he extends the data structure with a time axis to allow for animations. Ray tracing with ray classification (i. e. grouping rays according to their direction) is proposed by Arvo et al. in [4] as a very fast rendering algorithm.
Reference: [12] <author> E. Groller and W. Purgathofer. </author> <title> Using Temporal and Spatial Coherence for Accelerating the Calculation of Animation Sequences. </title> <editor> In Werner Pur-gathofer, editor, </editor> <volume> Eurographics '91, </volume> <pages> pages 103-113. </pages> <publisher> North-Holland, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: Ray tracing with ray classification (i. e. grouping rays according to their direction) is proposed by Arvo et al. in [4] as a very fast rendering algorithm. Introducing the time as an additional dimension to this approach is done by Groller et al. in <ref> [12] </ref>. The fact that a bunch of rays can be traced in parallel casting so-called beams is introduced by Heckbert et al. in [15] and expanded by Hanrahan in [14]. They use recursive subdivision of the beams to find edges of objects.
Reference: [13] <author> E. A. Haines and D. P. Greenberg. </author> <title> The Light Buffer: a Shadow Testing Accelerator. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 6(9) </volume> <pages> 6-16, </pages> <year> 1986. </year>
Reference-contexts: They say, that although similarity can be found between ray histories of adjacent pixels, it seems difficult to exploit this in an algorithm. The main obstacle is to ensure the validity of ray-object intersections. Coherence for shadow casting is used by Haines in <ref> [13] </ref> in such a way that the last object which cast a shadow for one pixel is likely to cast a shadow for the next one as well.
Reference: [14] <author> Pat Hanrahan. </author> <title> Using Caching and Breadth-First Search to Speed Up Ray Tracing. </title> <booktitle> In Proceedings of Graphics Interface '86, </booktitle> <pages> pages 56-61, </pages> <address> Toronto, Ontario, </address> <month> May </month> <year> 1986. </year> <booktitle> Canadian Information Processing Society. </booktitle>
Reference-contexts: Introducing the time as an additional dimension to this approach is done by Groller et al. in [12]. The fact that a bunch of rays can be traced in parallel casting so-called beams is introduced by Heckbert et al. in [15] and expanded by Hanrahan in <ref> [14] </ref>. They use recursive subdivision of the beams to find edges of objects. Caches and breadth first search in the ray histories are added to exploit the parallel nature of the considered rays.
Reference: [15] <author> Paul S. Heckbert and Pat Hanrahan. </author> <title> Beam Tracing Polygonal Objects. </title> <editor> In Hank Christiansen, editor, </editor> <booktitle> Computer Graphics (SIGGRAPH '84 Proceedings), </booktitle> <volume> volume 18, </volume> <pages> pages 119-127, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Introducing the time as an additional dimension to this approach is done by Groller et al. in [12]. The fact that a bunch of rays can be traced in parallel casting so-called beams is introduced by Heckbert et al. in <ref> [15] </ref> and expanded by Hanrahan in [14]. They use recursive subdivision of the beams to find edges of objects. Caches and breadth first search in the ray histories are added to exploit the parallel nature of the considered rays.
Reference: [16] <author> Volker Hofmeyer. </author> <title> Schnelles Ray Tracing von Bild-Sequencen. </title> <type> Master's thesis, </type> <institution> University of the Saarland, Department of Computer Science, </institution> <month> Februar </month> <year> 1994. </year>
Reference-contexts: The time T new is the time we measured with our method for the sequence of 4 frames. One can see that speedups between 1.2 and 2.7 have been achieved. A detailed analysis can be found in <ref> [16] </ref>. In figure 8 black pixels illustrate which pixels really had to be ray traced in the intermediate 3 frames of the scene balls. The white pixels indicate that those parts of the frames could be calculated by evaluating the ray history (fast ray tracing).
Reference: [17] <author> Kenneth I. Joy and Murthy N. Bhetanabhotla. </author> <title> Ray Tracing Parametric Surface Patches Utilizing Numerical Techniques and Ray Coherence. </title> <editor> In David C. Evans and Russell J. Athay, editors, </editor> <booktitle> Computer Graphics (SIGGRAPH '86 Proceedings), </booktitle> <volume> volume 20, </volume> <pages> pages 279-285, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Often, almost parallel rays are intersected with the same object. This knowledge can be used to reduce the time spent in the intersection calculation. As examples for the case of parametric surfaces we refer to the works of Kijiya in [18], Joy et al. in <ref> [17] </ref> or Lischin-ski [19]. Badt suggests in [5] an image space temporal coherence algorithm to accelerate frame by frame rendering. The first frame is traced entirely. In the following frames, first only randomly or heuristically chosen pixels are traced.
Reference: [18] <author> James T. Kajiya. </author> <title> Ray Tracing Parametric Patches. </title> <booktitle> In Computer Graphics (SIGGRAPH '82 Proceedings), </booktitle> <volume> volume 16, </volume> <pages> pages 245-254, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Often, almost parallel rays are intersected with the same object. This knowledge can be used to reduce the time spent in the intersection calculation. As examples for the case of parametric surfaces we refer to the works of Kijiya in <ref> [18] </ref>, Joy et al. in [17] or Lischin-ski [19]. Badt suggests in [5] an image space temporal coherence algorithm to accelerate frame by frame rendering. The first frame is traced entirely. In the following frames, first only randomly or heuristically chosen pixels are traced.
Reference: [19] <author> Daniel Lischinski and Jakob Gonczarowski. </author> <title> Improved Techniques for Ray Tracing Parametric Surfaces. </title> <journal> The Visual Computer, </journal> <volume> 6(3) </volume> <pages> 134-52, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Often, almost parallel rays are intersected with the same object. This knowledge can be used to reduce the time spent in the intersection calculation. As examples for the case of parametric surfaces we refer to the works of Kijiya in [18], Joy et al. in [17] or Lischin-ski <ref> [19] </ref>. Badt suggests in [5] an image space temporal coherence algorithm to accelerate frame by frame rendering. The first frame is traced entirely. In the following frames, first only randomly or heuristically chosen pixels are traced.
Reference: [20] <author> Joseph Marks, Robert Walsh, Jon Christensen, and Mark Friedell. </author> <title> Image and Intervisibility Coherence in Rendering. </title> <booktitle> In Proceedings of Graphics Interface '90, </booktitle> <pages> pages 17-30, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: They use recursive subdivision of the beams to find edges of objects. Caches and breadth first search in the ray histories are added to exploit the parallel nature of the considered rays. Marks et al. claim in <ref> [20] </ref> that the expected advantage of algorithms looking for coherence in an image fi nally may increase the run time, because the overhead consumes more time than the straight forward algorithm.
Reference: [21] <author> Koichi Murakami and Katsuhiko Hirota. </author> <title> Incremental Ray Tracing. </title> <booktitle> In Eurographics Workshop on Photosimulation, Realism and Physics in Computer Graphics, </booktitle> <pages> pages 15-29, </pages> <publisher> Rennes, </publisher> <address> France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Furthermore, all segments of the curves are detected, which are covered eventually by other polygons moving around. Once all visible segments are precalcu-lated, rendering can be performed fast. Pixel selected ray tracing is introduced in [2] and incremental ray tracing is presented in <ref> [21] </ref>. Those are the bases for our algorithm and thus explained in the next section in more detail. It is possible to include many of the optimizations cited above in this algorithm. 3 Ray History The kernel of each ray tracing algorithm is the following. <p> We call this process fast ray tracing. The size of the ini-tal square has a great influence on the quality of the image. They suggest a 5 fi 5 pixel square. Murakami and Hirota <ref> [21] </ref> extend the data structure of a ray-object intersection tree. Their ray tracer uses as subdivision method a regular grid as it has been introduced by Fujimoto [8]. They add to the ray-object intersection tree a voxel traversal history and intersection histories. <p> Shadow rays are included in a similar manner without intersection histories. We use a similar approach as in [2] to implement adaptive undersampling in time. We apply the concept of extending the ray-object intersection trees found in <ref> [21] </ref> as well, but reduce it to single pixels. The next section describes our algorithm. It depends on the basic ray tracing algorithm what information must be stored along with the ray-object intersection tree. <p> So far, we used a pointer to the object, a pointer to the material and a transformation matrix, which forms a block of 72 Bytes per node. If the block is compressed or encoded, the compare operation can be made faster, e. g. a hashing scheme as described in <ref> [21] </ref> is applyable; we would not use the voxel traversal history but a traversal history according to the hierarchy.
Reference: [22] <author> Andrew Pearce and David Jevans. </author> <title> Exploiting Shadow Coherence in Ray Tracing. </title> <booktitle> In Proceedings of Graphics Interface '91, </booktitle> <pages> pages 109-116, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Coherence for shadow casting is used by Haines in [13] in such a way that the last object which cast a shadow for one pixel is likely to cast a shadow for the next one as well. Pearce at el. use in <ref> [22] </ref> a whole set of small objects, which are defined through a grid in object space, as a shadow casting cache. Often, almost parallel rays are intersected with the same object. This knowledge can be used to reduce the time spent in the intersection calculation.
Reference: [23] <author> L. R. Speer, T. D. Derose, and B. A. Barsky. </author> <title> A Theoretical and Empirical Analysis of Coherent Ray Tracing. </title> <editor> In M. Wein and E. M. Kidd, editors, </editor> <booktitle> Graphics Interface '85 Proceedings, </booktitle> <pages> pages 1-8. </pages> <institution> Canadian Inf. Process. Soc., </institution> <year> 1985. </year>
Reference-contexts: Their analysis deals with scanline algorithms; however, they address ray tracing too and state that the resolution of the image has a great influence on the obtained speedup. A similar result has been obtained by Speer et al. in <ref> [23] </ref> with theoretical and empirical means. They say, that although similarity can be found between ray histories of adjacent pixels, it seems difficult to exploit this in an algorithm. The main obstacle is to ensure the validity of ray-object intersections.
Reference: [24] <author> L. Richard Speer. </author> <title> An Updated Cross-Indexed Guide to the Ray Tracing Literature. </title> <journal> Computer Graphics, </journal> <volume> 26(1) </volume> <pages> 41-72, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Since then a lot of improvements to the basic algorithm have been developed. Excellent references to the ray tracing literature are gathered for instance in the bibliographies of Speer in <ref> [24] </ref> and of ACM Sig-Graph in [1]. We focus on a method to reduce the render time for a sequence of ray traced frames. This means that not a single frame is rendered faster, but information of previous calculations is re-used in consecutive, correlated frames.
Reference: [25] <author> Turner Whitted. </author> <title> An Improved Illumination Model for Shaded Display. </title> <journal> Communications of the ACM, </journal> <volume> 23(6) </volume> <pages> 343-349, </pages> <month> June </month> <year> 1980. </year>
Reference-contexts: Nevertheless todays fast computers and advanced ray tracing algorithms allow to render single frames within minutes. Ray tracing was first introduced by Appel in [3]. Early optimizations, such as recursion, bounding volumes and adaptive oversampling, which led to significantly better run times, have been studied by Whitted in <ref> [25] </ref>. Since then a lot of improvements to the basic algorithm have been developed. Excellent references to the ray tracing literature are gathered for instance in the bibliographies of Speer in [24] and of ACM Sig-Graph in [1].
References-found: 25

