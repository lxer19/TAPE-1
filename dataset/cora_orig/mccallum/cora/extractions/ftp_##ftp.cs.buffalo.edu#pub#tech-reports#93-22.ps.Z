URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/93-22.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Title: A randomized parallel algorithm for dfa-minimization  
Keyword: Parallel-algorithms, Partitioning, DFA minimization  
Abstract: The problem of finding the coarsest partition of a set S with respect to another partition of S and one or more functions on S has several applications, one of which is the state minimization of finite state automata. The problem has a well known O(n log n) sequential algorithm. In this paper, we present efficient parallel randomised algorithms for the problem. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V.Aho, J.E.Hopcroft and J.D.Ullman, </author> <title> The design and analysis of computer algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: The functions are the state transitions on each symbol of the input alphabet. The final partition yields the minimum DFA. The first O (n log n) algorithm for the problem was given in <ref> [1] </ref>. This algorithm successively refines the partition, by examining the inverse image of the elements under the given mappings. An alternate O (n log n) algorithm for the problem was given by Rao et al [5], using an inverted list implementation.
Reference: [2] <author> J.Ja Ja and S.R.Kosaraju, </author> <title> Parallel algorithms for planar graph isomorphism and related problems, </title> <journal> IEEE trans. on circuits and systems, </journal> <volume> vol 35, 3, </volume> <month> March </month> <year> 1988, </year> <pages> pp 304-310. </pages>
Reference-contexts: Their approach exploits the structure of the mapping, and does not use the idea of successive refinements. However, their approach does not appear to be useful for handling the more general problem of multiple function partitioning. Parallel algorithms for these problems have been given by Ja Ja and Kosaraju <ref> [2] </ref>. Their approach yields an n 2 processor, O (log 2 n) time algorithm for the single function case, and an n 4 processor, O (log 2 n) 1 time algorithm for the multiple function problem. These algorithms run on the CREW PRAM.
Reference: [3] <author> J.F. JaJa and K.W.Ryu, </author> <title> An Efficient Algorithm for the Single Function Coarsest Partition Problem, </title> <note> to appear in SPAA 1993. </note>
Reference-contexts: As an open question, they ask if there is any parallel algorithm for the problem, that uses only a linear number of processors. More recently, Ja Ja and Ryu <ref> [3] </ref> have given efficient parallel algorithms for the single function case. Their algorithm runs on the weakest concurrent write PRAMs in O (log n) time and requires O (n log log n) work. In this paper, we present randomised parallel algorithms for the dfa-minimization problem.
Reference: [4] <author> R.Paige, R.E.Tarjan and R.Bonic, </author> <title> A linear time solution to the single function coarsest partition problem, </title> <journal> Theoretical computer science, </journal> <volume> 40, </volume> <year> 1985, </year> <month> pp67-84. </month>
Reference-contexts: This algorithm successively refines the partition, by examining the inverse image of the elements under the given mappings. An alternate O (n log n) algorithm for the problem was given by Rao et al [5], using an inverted list implementation. Paige et al <ref> [4] </ref> give an O (n) time algorithm for the single function case. Their approach exploits the structure of the mapping, and does not use the idea of successive refinements. However, their approach does not appear to be useful for handling the more general problem of multiple function partitioning.
Reference: [5] <author> N.Rao, R.Sridhar and S.S.Iyengar, </author> <title> An O(n log n) set refinement algorithm with applications, </title> <journal> Intl journal of computer math, </journal> <volume> vol 40, </volume> <year> 1991, </year> <pages> pp 129-138. </pages>
Reference-contexts: The first O (n log n) algorithm for the problem was given in [1]. This algorithm successively refines the partition, by examining the inverse image of the elements under the given mappings. An alternate O (n log n) algorithm for the problem was given by Rao et al <ref> [5] </ref>, using an inverted list implementation. Paige et al [4] give an O (n) time algorithm for the single function case. Their approach exploits the structure of the mapping, and does not use the idea of successive refinements.
Reference: [6] <author> Sairam S. and Klein P., </author> <title> A randomised parallel approximation scheme for shortest paths, </title> <booktitle> in Proceedings of 24th annual ACM STOC, </booktitle> <pages> pp 750-758, </pages> <year> 1992. </year>
Reference: [7] <author> Sarnath R., </author> <title> A randomised NC algorithm for finding the longest upsequence, </title> <type> TR no. 93-08, </type> <institution> dept of computer science, SUNY, Buffalo, </institution> <address> NY 14260. </address>
Reference: [8] <author> Ullman J.D. and Yannakakis M., </author> <title> High probability parallel transitive closure algorithms, </title> <journal> SIAM J comput, </journal> <volume> vol 20, no 1, </volume> <pages> pp 100-125, </pages> <month> Feb </month> <year> 1991. </year> <month> 6 </month>
Reference-contexts: In this paper, we present randomised parallel algorithms for the dfa-minimization problem. The method can be easily generalised to handle the case where we have 3 or more functions. These algorithms use ideas similar to those of Ullman and Yannakakis <ref> [8] </ref> to do BFS in sparse graphs. Our algorithms run in time O (n 2ff+* ) using n 2ff processors, for all ff &lt; 2=(fi 1), where n fi is the complexity of boolean matrix multiplication.
References-found: 8

