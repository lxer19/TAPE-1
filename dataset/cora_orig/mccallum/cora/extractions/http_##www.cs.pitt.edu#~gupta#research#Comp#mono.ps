URL: http://www.cs.pitt.edu/~gupta/research/Comp/mono.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/optimization.html
Root-URL: 
Email: mspezial@csee.lehigh.edu gupta@cs.pitt.edu  
Title: Loop Monotonic Statements  
Author: Madalene Spezialetti Rajiv Gupta 
Keyword: access anomalies (data races), array bound checking, run-time dependence checking, static analysis, induction variables.  
Note: Supported in part by NSF under Grant CCR-9212020 to Lehigh University and NSF Presidential Young Investigator Award CCR-9157371 to the  
Address: Pittsburgh Bethlehem, PA 18015 Pittsburgh, PA 15260  Pittsburgh.  
Affiliation: EECS Dept., Packard Lab Dept. of Computer Science Lehigh University University of  Univ. of  
Abstract: A statement is considered to be monotonic with respect to a loop if its execution, during the successive iterations of a given execution of the loop, assigns a monotonically increasing or decreasing sequence of values to a variable. We present static analysis techniques to identify loop monotonic statements. The knowledge of loop monotonicity characteristics of statements which compute array subscript expressions is of significant value in a number of applications. We illustrate the use of this information in improving the efficiency of run-time array bound checking, run-time dependence testing, and on-the-fly detection of access anomalies. Given that a significant percentage of subscript expressions are monotonic, substantial savings can be expected by using these techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman, </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: We assume that the program is represented using three address code <ref> [1] </ref>. Thus in this form an array subscript expression is computed into a temporary and each reference to an array element is represented by a separate statement. In addition, we also assume that the use-def chains for the program are available. <p> We also assume that all operands under consideration are integers and all arithmetic operations including division produce integer results. This is a reasonable assumption since array subscripts are integers. The approach taken in developing this algorithm is as follows. First all loop invariants <ref> [1] </ref> are identified and each invariant is assigned an invariance value of C + , C , or C ? . All statements that reference array elements, that is, statements of the form a [x]=y or y=a [x], are marked as chaotic (?). <p> Next we 10 Algorithm AnalyzeLoop f Characterize the initial values of variables that are used in the loop before they are redefined as C + , C , or C ? . Construct data dependency graph (DDG) for the loop. Identify loop invariant statements <ref> [1] </ref> and assign MIV values of C + , C , or C ? to these statements. for each statement in the loop which is not invariant do MIV &gt; endfor for each potentially basic monotonic statement do compute MIV values using algorithm in section 4.1. endfor Find Strongly Connected Components
Reference: [2] <author> Z. Ammarguellat, W.L. Harrison III, </author> <title> "Automatic Recognition of Induction Variables and Recurrence Relations by Abstract Interpretation," </title> <booktitle> Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 283-295, </pages> <address> White Plains, New York, </address> <year> 1990. </year>
Reference-contexts: Monotonic induction variables primarily fall under the category of basic monotonic computations. The notion of monotonic computations is also significantly different from the notion of recurrences introduced by Ammarguellat and Harrison in <ref> [2] </ref>. The values assigned to a variable by a irregular monotonic computation need not follow a pattern expressible as a recurrence. Regular monotonic computations, on the other hand, can be expressed as recurrences. In a recent paper Wolfe has also shown the utility of monotonic variables [19].
Reference: [3] <author> U. Banerjee, </author> <title> "Dependence Analysis for Supercomputing," </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: However, through symbolic analysis we may be able to compare the values of the constants and determine that the statements are monotonic. Next we briefly discuss the advantages of monotonicity analysis over traditional array dependency analysis <ref> [3] </ref> for the applications discussed in section 5. The advantages of our approach are two fold: monotonicity analysis is efficient and easy to implement; and there are circumstances under which monotonicity analysis is more effective than array dependency analysis.
Reference: [4] <author> A. Dinning, E. Schonberg, </author> <title> "An Empirical Comparison of Monitoring Algorithms for Access Anomaly Detection," </title> <booktitle> Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <address> Seattle, Washington, </address> <pages> pages 1-10, </pages> <year> 1990. </year>
Reference-contexts: Since the order in which the read and write operations can vary from one execution to another, the program may exhibit unpredictable behavior. Various approaches to the detection of access anomalies have been studied <ref> [4, 5, 6, 9, 12, 14, 15, 17] </ref>. An approach, which is based upon tracing array accesses, is referred to as on-the-fly detection of access anomalies. <p> On-the-fly anomaly dete ction algorithms continuously collect information regarding read and write accesses of all array elements and analyze this information at run-time to detect access anomalies. The analysis is performed at synchronization points. Primary contributions based upon this approach are reported in <ref> [4, 14, 15] </ref>. In [4] Dinning and Schonberg report that the cost of monitoring entails a 3-fold to 6-fold slowdown in a program's execution. <p> On-the-fly anomaly dete ction algorithms continuously collect information regarding read and write accesses of all array elements and analyze this information at run-time to detect access anomalies. The analysis is performed at synchronization points. Primary contributions based upon this approach are reported in [4, 14, 15]. In <ref> [4] </ref> Dinning and Schonberg report that the cost of monitoring entails a 3-fold to 6-fold slowdown in a program's execution.
Reference: [5] <author> P.A. Emrath, D.A. Padua, </author> <title> "Automatic Detection of Non-determinacy in Parallel Programs," </title> <booktitle> Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, Wisconsin, </address> <pages> pages 89-99, </pages> <year> 1988. </year>
Reference-contexts: Since the order in which the read and write operations can vary from one execution to another, the program may exhibit unpredictable behavior. Various approaches to the detection of access anomalies have been studied <ref> [4, 5, 6, 9, 12, 14, 15, 17] </ref>. An approach, which is based upon tracing array accesses, is referred to as on-the-fly detection of access anomalies.
Reference: [6] <author> P.A. Emrath, S. Ghosh, D.A. Padua, </author> <title> "Event Synchronization Analysis for Debugging Parallel Programs," </title> <booktitle> Proceedings of the Supercomputing'89 Conference, </booktitle> <address> Reno, Nevada, </address> <pages> pages 580-588, </pages> <year> 1989. </year>
Reference-contexts: Since the order in which the read and write operations can vary from one execution to another, the program may exhibit unpredictable behavior. Various approaches to the detection of access anomalies have been studied <ref> [4, 5, 6, 9, 12, 14, 15, 17] </ref>. An approach, which is based upon tracing array accesses, is referred to as on-the-fly detection of access anomalies.
Reference: [7] <author> R. Gupta, </author> <title> "A Fresh Look at Optimizing Array Bound Checking," </title> <booktitle> ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 272-282, </pages> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: This optimization can only be applied if the statement that involves the array reference is executed unconditionally, that is, the statement is executed during each iteration of the loop. Only certain special cases of this optimization have been considered in previous work <ref> [7, 8, 13] </ref>. Table 8: Bound Checks Required for Monotonic Subscript Expressions. <p> The values of induction variables can vary in a chaotic fashion from one loop iteration to the next. The notion of loop monotonic computations is more general than the notion of monotonic induction variables introduced in <ref> [7] </ref>. Monotonic induction variables primarily fall under the category of basic monotonic computations. The notion of monotonic computations is also significantly different from the notion of recurrences introduced by Ammarguellat and Harrison in [2].
Reference: [8] <author> R. Gupta, </author> <title> "Optimizing Array Bound Checks using Flow Analysis," </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> Vol. 2, </volume> <pages> Nos. 1-4, pages 135-150, </pages> <month> March-December </month> <year> 1994. </year>
Reference-contexts: This optimization can only be applied if the statement that involves the array reference is executed unconditionally, that is, the statement is executed during each iteration of the loop. Only certain special cases of this optimization have been considered in previous work <ref> [7, 8, 13] </ref>. Table 8: Bound Checks Required for Monotonic Subscript Expressions.
Reference: [9] <author> R. Gupta and M. Spezialetti, </author> <title> "Loop Monotonic Computations: An Approach for the Efficient Run-time Detection of Races," </title> <booktitle> Proceedings of the SIGSOFT Symposium on Testing, Analysis, and Verification, </booktitle> <pages> pages 98-111, </pages> <address> Victoria, Canada, </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Since the order in which the read and write operations can vary from one execution to another, the program may exhibit unpredictable behavior. Various approaches to the detection of access anomalies have been studied <ref> [4, 5, 6, 9, 12, 14, 15, 17] </ref>. An approach, which is based upon tracing array accesses, is referred to as on-the-fly detection of access anomalies.
Reference: [10] <author> M.R. Haghighat and C.D. Polychronopoulos, </author> <title> "Symbolic Program Analysis and Optimization for Parallelizing Compilers," </title> <booktitle> Proceedings of the Fifth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <institution> Yale University, </institution> <address> New Haven, Connecticut, </address> <pages> pages 355-369, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Symbolic analysis has been used to further enhance array subscript analysis by Haghighat and Poly-chronopoulos in <ref> [10] </ref> and Jouvelot and Dehbonei in [11]. The techniques for monotonicity analysis can also benefit from symbolic analysis. Symbolic analysis may allow branch conditions to be evaluated and hence improve the precision of analysis.
Reference: [11] <author> P. Jouvelot and B. Dehbonei, </author> <title> "A Unified Semantic Approach for the Vectorization and Parallelization of Generalized Reductions," </title> <booktitle> Proceedings of the 3rd International Conference on Supercomputing, </booktitle> <address> Crete, Greece, </address> <pages> pages 186-194, </pages> <year> 1989. </year>
Reference-contexts: Symbolic analysis has been used to further enhance array subscript analysis by Haghighat and Poly-chronopoulos in [10] and Jouvelot and Dehbonei in <ref> [11] </ref>. The techniques for monotonicity analysis can also benefit from symbolic analysis. Symbolic analysis may allow branch conditions to be evaluated and hence improve the precision of analysis.
Reference: [12] <author> B. Miller and J-D. Choi, </author> <title> "A Mechanism for Efficient Debugging of Parallel Programs," </title> <booktitle> Proceedings of the SIGPLAN'88 Conf. on Programming Language Design and Implementation, Atlanta, Georgia, </booktitle> <pages> pages 135-144, </pages> <year> 1988. </year>
Reference-contexts: Since the order in which the read and write operations can vary from one execution to another, the program may exhibit unpredictable behavior. Various approaches to the detection of access anomalies have been studied <ref> [4, 5, 6, 9, 12, 14, 15, 17] </ref>. An approach, which is based upon tracing array accesses, is referred to as on-the-fly detection of access anomalies.
Reference: [13] <author> V. Markstein, J. Cocke, and P. Markstein, </author> <title> "Optimization of Range Checking," </title> <booktitle> Proceedings of SIGPLAN'82 Symposium on Compiler Construction, </booktitle> <pages> pages 114-119, </pages> <year> 1982. </year>
Reference-contexts: This optimization can only be applied if the statement that involves the array reference is executed unconditionally, that is, the statement is executed during each iteration of the loop. Only certain special cases of this optimization have been considered in previous work <ref> [7, 8, 13] </ref>. Table 8: Bound Checks Required for Monotonic Subscript Expressions.
Reference: [14] <author> I. Nudler and L. Rudolph, </author> <title> "Tools for the Efficient Development of Parallel Programs," </title> <booktitle> Proceedings of the 1st Israeli Conference on Computer System Engineering, </booktitle> <year> 1988. </year>
Reference-contexts: Since the order in which the read and write operations can vary from one execution to another, the program may exhibit unpredictable behavior. Various approaches to the detection of access anomalies have been studied <ref> [4, 5, 6, 9, 12, 14, 15, 17] </ref>. An approach, which is based upon tracing array accesses, is referred to as on-the-fly detection of access anomalies. <p> On-the-fly anomaly dete ction algorithms continuously collect information regarding read and write accesses of all array elements and analyze this information at run-time to detect access anomalies. The analysis is performed at synchronization points. Primary contributions based upon this approach are reported in <ref> [4, 14, 15] </ref>. In [4] Dinning and Schonberg report that the cost of monitoring entails a 3-fold to 6-fold slowdown in a program's execution.
Reference: [15] <author> E. Schonberg, </author> <title> "On-The-Fly Detection of Access Anomalies," </title> <booktitle> Proceedings of the SIGPLAN'89 Conf. on Programming Language Design and Implementation, Portland, Oregon, </booktitle> <pages> pages 285-296, </pages> <year> 1989. </year>
Reference-contexts: Since the order in which the read and write operations can vary from one execution to another, the program may exhibit unpredictable behavior. Various approaches to the detection of access anomalies have been studied <ref> [4, 5, 6, 9, 12, 14, 15, 17] </ref>. An approach, which is based upon tracing array accesses, is referred to as on-the-fly detection of access anomalies. <p> On-the-fly anomaly dete ction algorithms continuously collect information regarding read and write accesses of all array elements and analyze this information at run-time to detect access anomalies. The analysis is performed at synchronization points. Primary contributions based upon this approach are reported in <ref> [4, 14, 15] </ref>. In [4] Dinning and Schonberg report that the cost of monitoring entails a 3-fold to 6-fold slowdown in a program's execution.
Reference: [16] <author> Z. Shen, Z. Li, </author> <title> and P.C. Yew, "An Empirical Study on Array Subscripts and Dara Dependencies," </title> <booktitle> Proceedings of the International Conference on Parallel Processing, </booktitle> <volume> vol. II, </volume> <pages> pages 145-152, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: If in a loop an if-statement controls the changes in the value of a variable which is used in a subscript expression, then the array references cannot be analyzed using traditional dependency tests. In a study of scientific programs Shen et al <ref> [16] </ref> found that about 47% of subscript expressions were non-linear. Monotonicity analysis may be helpful in performing the optimizations discussed in some of these cases.
Reference: [17] <author> M. Spezialetti and R. Gupta, </author> <title> "Automatic Generation of Assertions for Detecting Errors in Parallel Programs on Shared-Memory Multiprocessors," </title> <booktitle> abstract in ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 266-268, </pages> <address> Santa Cruz, California, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Since the order in which the read and write operations can vary from one execution to another, the program may exhibit unpredictable behavior. Various approaches to the detection of access anomalies have been studied <ref> [4, 5, 6, 9, 12, 14, 15, 17] </ref>. An approach, which is based upon tracing array accesses, is referred to as on-the-fly detection of access anomalies.
Reference: [18] <author> R. Tarjan, </author> <title> "Depth-first Search and Linear Graph Algorithms," </title> <journal> Siam Journal of Computing, </journal> <volume> Vol. 1, no. 2, </volume> <pages> pages 146-160, </pages> <month> June </month> <year> 1972. </year>
Reference-contexts: The data dependency graph (DDG) for the loop is constructed and the M IV values of remaining statements are initialized as &gt;. The strongly connected components (SCCs) in the DDG are next identified using an algorithm due to Tarjan <ref> [18] </ref>. A statement whose M IV value is unknown is potentially cyclic monotonic if it is part of a SCC; otherwise it is potentially dependent monotonic. Using the DDG we construct an ordered list in which each component is either a potential dependent monotonic statement or a SCC. <p> The determination of basic monotonic statements takes linear time since it requires examining all statements in the loop. The time for identifying SCCs is O (V + E) <ref> [18] </ref>. The time spent on processing dependent monotonic statements and cyclic monotonic statements is also O (V +E) because all statements as well as their incoming edges are examined by algorithms in sections 4.2 and 4.3.
Reference: [19] <author> M. Wolfe, </author> <title> "Beyond Induction Variables," </title> <booktitle> Proceedings of the SIGPLAN Conf. on Programming Language Design and Implementation, </booktitle> <address> San Francisco, California, </address> <pages> pages 162-174, </pages> <month> June </month> <year> 1992. </year> <month> 16 </month>
Reference-contexts: The values assigned to a variable by a irregular monotonic computation need not follow a pattern expressible as a recurrence. Regular monotonic computations, on the other hand, can be expressed as recurrences. In a recent paper Wolfe has also shown the utility of monotonic variables <ref> [19] </ref>. However, our algorithm for detection of monotonicity is more general than Wolfe's algorithm.
References-found: 19

