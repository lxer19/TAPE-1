URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/papers/frame.ps
Refering-URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/schedule.html
Root-URL: 
Title: Frame-based Fair Queueing: A New Traffic Scheduling Algorithm for Packet-Switched Networks  
Author: Dimitrios Stiliadis Anujan Varma 
Keyword: Packet scheduling, ATM switch scheduling, fair queueing, delay bounds, fairness.  
Note: This research is supported by the NSF Young Investigator Award No. MIP-9257103  
Address: Santa Cruz, CA 95064 USA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Date: July 18, 1995  
Pubnum: UCSC-CRL-95-39  
Abstract: In this paper we introduce and analyze frame-based fair queueing, a novel traffic scheduling algorithm for packet-switched networks. The algorithm provides end-to-end delay bounds identical to those of PGPS (packet-level generalized processor sharing), without the complexity of simulating the fluid-model system in the background as required in PGPS. The algorithm is therefore ideally suited for implementation in packet switches supporting a large number of sessions. Implementations of the algorithm are described for both general packet switches supporting variable packet sizes, and ATM switches supporting fixed-size cells. In addition, we prove that the algorithm is fair in the sense that sessions are not penalized for excess bandwidth they received while other sessions were idle. Frame-based fair queueing belongs to a general class of scheduling algorithms, which we call Rate-Proportional Servers. This class of algorithms provides the same end-to-end delay and burstiness bounds as PGPS, but allows more flexibility in the design and implementation of the algorithm. We provide a systematic analysis of this class of schedulers and obtain bounds on their fairness. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Verma, D. Ferrari, and H. Zhang, </author> <title> "Guaranteeing delay jitter bounds in packet switching networks," </title> <booktitle> in Tricomm 91, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: When the transmission time of a packet is short, as is typically the case in an ATM network, however, such a policy is seldom justified. Non-work-conserving algorithms are also used to control delay jitter by delaying packets that arrive early <ref> [1] </ref>. Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing [3], VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin [6], and Deficit Round Robin [7]. <p> Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing [3], VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin [6], and Deficit Round Robin [7]. On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date <ref> [1] </ref> are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10]. According to this classification there are two main architectures: sorted-priority and frame-based.
Reference: [2] <author> A. K. Parekh and R. G. Gallager, </author> <title> "A generalized processor sharing approach to flow control - the single node case," </title> <booktitle> in Proceedings of INFOCOM '92, </booktitle> <volume> vol. 2, </volume> <pages> pp. 915-924, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Non-work-conserving algorithms are also used to control delay jitter by delaying packets that arrive early [1]. Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) <ref> [2] </ref>, Weighted Fair Queueing [3], VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin [6], and Deficit Round Robin [7]. On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10]. <p> Scalability: The algorithm must perform well in switches with a large number of connections, as well as over a wide range of link speeds. Based only on the end-to-end delay bounds and fairness properties, Generalized-Processor-Sharing (GPS) is an ideal scheduling discipline <ref> [2] </ref>. GPS multiplexing is defined with respect to a fluid-model, where packets are considered to be infinitely divisible. The share of bandwidth reserved by session i is represented by a real number i . <p> A backlogged session in the VirtualClock server can be starved for an arbitrary period of 3 time as a result of excess bandwidth it received from the server when other sessions were idle <ref> [2] </ref>. A scheduling algorithm that combines the delay and burstiness behavior of PGPS, simple timestamp computations, and bounded unfairness, has so far remained elusive. <p> However, PGPS also has the highest implementation complexity. VirtualClock has the same latency as PGPS, but is not a fair algorithm <ref> [4, 2] </ref>. Notice, however, that none of the other algorithms suffers from such a high level of unfairness. In SCFQ as well as the round-robin schedulers, latency is a function of the number of connections that share the output link. <p> Let us assume that the kth packet leaves the system under the PRPS service discipline at time t P k . The same packet leaves the RPS server at time t F k . Using a similar approach as the one used for GPS servers <ref> [2] </ref>, we can prove the following lemma: Lemma 3: For all packets in a packet-by-packet rate-proportional server, t P k + r If we include the partial service received by packets in transmission, the maximum lag in service for a session i in the packet-by-packet server occurs at the instant when
Reference: [3] <author> A. Demers, S. Keshav, and S. Shenker, </author> <title> "Analysis and simulation of a fair queueing algorithm," Internetworking: </title> <journal> Research and Experience, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 3-26, </pages> <year> 1990. </year>
Reference-contexts: Non-work-conserving algorithms are also used to control delay jitter by delaying packets that arrive early [1]. Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing <ref> [3] </ref>, VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin [6], and Deficit Round Robin [7]. On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10].
Reference: [4] <author> L. Zhang, "VirtualClock: </author> <title> a new traffic control algorithm for packet switching networks," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 9, </volume> <pages> pp. 101-124, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Non-work-conserving algorithms are also used to control delay jitter by delaying packets that arrive early [1]. Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing [3], VirtualClock <ref> [4] </ref>, Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin [6], and Deficit Round Robin [7]. On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10]. <p> However, PGPS also has the highest implementation complexity. VirtualClock has the same latency as PGPS, but is not a fair algorithm <ref> [4, 2] </ref>. Notice, however, that none of the other algorithms suffers from such a high level of unfairness. In SCFQ as well as the round-robin schedulers, latency is a function of the number of connections that share the output link.
Reference: [5] <author> D. Ferrari and D. Verma, </author> <title> "A scheme for real-time channel establishment in wide-area networks," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 8, </volume> <pages> pp. 368-379, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Non-work-conserving algorithms are also used to control delay jitter by delaying packets that arrive early [1]. Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing [3], VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) <ref> [5] </ref>, Weighted Round Robin [6], and Deficit Round Robin [7]. On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10]. According to this classification there are two main architectures: sorted-priority and frame-based.
Reference: [6] <author> M. Katevenis, S. Sidiropoulos, and C. Courcoubetis, </author> <title> "Weighted round-robin cell multiplexing in a general-purpose ATM switch chip," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 9, </volume> <pages> pp. 1265-79, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Non-work-conserving algorithms are also used to control delay jitter by delaying packets that arrive early [1]. Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing [3], VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin <ref> [6] </ref>, and Deficit Round Robin [7]. On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10]. According to this classification there are two main architectures: sorted-priority and frame-based.
Reference: [7] <author> M. Shreedhar and G. Varghese, </author> <title> "Efficient Fair Queueing using Deficit Round Robin," </title> <booktitle> in Proc. </booktitle> <address> SIGCOMM'95, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing [3], VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin [6], and Deficit Round Robin <ref> [7] </ref>. On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10]. According to this classification there are two main architectures: sorted-priority and frame-based.
Reference: [8] <author> C. Kalmanek, H. Kanakia, and S. Keshav, </author> <title> "Rate controlled servers for very high-speed networks," </title> <booktitle> in IEEE Global Telecommunications Conferece, </booktitle> <pages> pp. </pages> <address> 300.3.1-300.3.9, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing [3], VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin [6], and Deficit Round Robin [7]. On the other hand, Hierarchical-Round-Robin (HRR) <ref> [8] </ref>, Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10]. According to this classification there are two main architectures: sorted-priority and frame-based.
Reference: [9] <author> S. Golestani, </author> <title> "A framing strategy for congestion management," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 9, </volume> <pages> pp. 1064-1077, </pages> <month> September </month> <year> 1991. </year> <month> 30 </month>
Reference-contexts: Work-conserving servers always have lower average delays than non-work-conserving servers. Examples of work-conserving schedulers include Generalized Processor Sharing (GPS) [2], Weighted Fair Queueing [3], VirtualClock [4], Delay-Earliest-Due-Date (Delay-EDD) [5], Weighted Round Robin [6], and Deficit Round Robin [7]. On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing <ref> [9] </ref>, and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure [10]. According to this classification there are two main architectures: sorted-priority and frame-based.
Reference: [10] <author> H. Zhang and S. Keshav, </author> <title> "Comparison of rate based service disciplines," </title> <booktitle> in Proceedings of ACM SIGCOMM '91, </booktitle> <pages> pp. 113-122, </pages> <year> 1991. </year>
Reference-contexts: On the other hand, Hierarchical-Round-Robin (HRR) [8], Stop-and-Go queueing [9], and Jitter-Earliest-Due-Date [1] are non-work-conserving schedulers. Another classification of schedulers is based on their internal structure <ref> [10] </ref>. According to this classification there are two main architectures: sorted-priority and frame-based. In a sorted-priority scheduler, there is a global variable | usually referred to as the virtual time | associated with each outgoing link of the switch.
Reference: [11] <author> J. Davin and A. Heybey, </author> <title> "A simulation study of fair queueing and policy enforcement," </title> <journal> Computer Communication Review, </journal> <volume> vol. 20, </volume> <pages> pp. 23-29, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: A maximum of V events may be triggered in the GPS simulator during the transmission of one packet. Thus, the process overhead for completing a scheduling decision is O (V ). In order to reduce this complexity, an approximate implementation of GPS multiplexing was proposed in <ref> [11] </ref> and was later analyzed in [12] under the name Self-Clocked Fair Queueing (SCFQ). In this implementation, the timestamp of an arriving packet is computed based on the packet currently in service.
Reference: [12] <author> S. Golestani, </author> <title> "A self-clocked fair queueing scheme for broadband applications," </title> <booktitle> in Proceedings of INFOCOM '94, </booktitle> <pages> pp. 636-646, </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: Thus, the process overhead for completing a scheduling decision is O (V ). In order to reduce this complexity, an approximate implementation of GPS multiplexing was proposed in [11] and was later analyzed in <ref> [12] </ref> under the name Self-Clocked Fair Queueing (SCFQ). In this implementation, the timestamp of an arriving packet is computed based on the packet currently in service. <p> Thus, if we represent the total amount of service received by each session by a function, then these functions can be seen to grow at the same rate for each backlogged session. Golestani <ref> [12] </ref> introduced such a function and called it virtual time. Virtual time of a backlogged session is a function whose rate of growth at each instant is exactly the rate of service provided to it by the scheduler at that instant. <p> In general, we would like the system to always serve connections proportional to their reservations and never penalize connections for bandwidth they received earlier, The measure of fairness that we will use is an extension of the definition presented for SCFQ <ref> [12] </ref>. Let us assume that at time t two connections i; j become greedy, requesting an infinite amount of bandwidth. Thus, the two connections will be continuously backlogged in the system after time t .
Reference: [13] <author> D. Stiliadis and A. Varma, </author> <title> "Latency-rate servers: A general model for analysis of traffic scheduling algorithms," </title> <type> Tech. Rep. </type> <institution> UCSC-CRL-95-38, U.C. Santa Cruz, Dept. of Computer Engineering, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: However, the price paid is the reduced level of isolation among the sessions, causing the end-to-end delay bounds to grow linearly with the number of sessions that share the outgoing link <ref> [13] </ref>. Thus, the worst-case delay of a session can no longer be controlled just by controlling its reservation, as is possible in PGPS. The higher end-to-end delay also affects the burstiness of sessions within the network, increasing the buffer requirements. <p> The rest of this paper is organized as follows: In Section 2, we present some definitions and a brief summary of the concept of Latency-Rate Servers (or LR-servers) <ref> [13] </ref>. LR-servers provide a general framework for modeling the worst-case behavior of scheduling algorithms. All work-conserving servers known to us can be modeled using this framework. <p> The beginning of a busy period is always caused by the 5 arrival of a packet into the system. Since we are interested in a worst-case analysis of the system, the session busy period provides us a convenient means to bound the queueing delays within the system. In <ref> [13] </ref>, we introduced a general model for traffic scheduling algorithms, called Latency-Rate (LR) servers. Any server in this class is characterized by two parameters: latency fi i and minimum allocated rate i . Let us assume that the jth busy period of connection i starts at time t . <p> That is, A i (t; t) i + i (t t ) during any time interval (t; t]. Also, we assume that session i is allocated a minimum rate of i in the network. We state without proof the following key result from <ref> [13] </ref>. <p> Furthermore, all known work-conserving schedulers | such as GPS, PGPS, Weighted Round Robin, Self-Clocked Fair Queueing, VirtualClock and Deficit-Round-Robin | have been shown to be LR-servers <ref> [13] </ref>. In Table 2 we summarize the latencies of many well-known work-conserving schedulers, along with bounds on their fairness and implementation complexity.
Reference: [14] <author> J. Turner, </author> <title> "New directions in communications (or which way to the information age?)," </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 24, </volume> <pages> pp. 8-15, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: Only in the case of a fluid-server packets can be arbitrarily small and thus W S i;j (t; t) may be continuous. To determine end-to-end delay bounds, we assume that traffic from session i at the source is leaky-bucket shaped <ref> [14] </ref>. That is, A i (t; t) i + i (t t ) during any time interval (t; t]. Also, we assume that session i is allocated a minimum rate of i in the network. We state without proof the following key result from [13].
Reference: [15] <author> J. Rexford, A. Greenberg, and F. Bononi, </author> <title> "A fair leaky-bucket shaper for atm networks." </title> <type> AT&T unpulbished report. </type>
Reference-contexts: A proof of this lemma can be found in Appendix A. We will now use the above lemma and a method similar to the one presented in <ref> [15] </ref> for the PGPS server to find an upper bound for the amount of service a session may receive in PRPS as compared to that in the fluid server.
Reference: [16] <author> J. L. Rexford, A. Greenberg, and F. Bonomi, </author> <title> "Hardware efficient fair queueing architectures for high-speed networks," </title> <booktitle> in Proceedings of INFOCOM 96, IEEE, </booktitle> <year> 1996. </year>
Reference-contexts: However, we take advantage of the fact that only integers are used, and replace the floating point operations in the original algorithm by shifts. In addition, the priority list implementation can be simplified as well by using the techniques described in <ref> [16] </ref>. 6 Conclusions In this paper, we introduced and analyzed frame-based fair queueing, a novel traffic scheduling algorithm with application in both ATM and general packet networks. The algorithm provides the same end-to-end delay guarantees as a PGPS server if the input traffic is leaky-bucket shaped.
Reference: [17] <author> O. Yaron and M. Sidi, </author> <title> "Performance and stability of communication networks via robust exponential bounds," </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> vol. 1, </volume> <pages> pp. 372-385, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: It is hoped that this framework will lead to the development of other algorithms in the future. Further work will include the analysis of frame-based fair queueing under probabilistic input traffic models, such as the exponentially-bounded-burstiness model <ref> [17] </ref>. We also plan to implement the algorithm in hardware using our FPGA-based ATM Simulation Testbed [18]. A network of switches will be simulated in order to evaluate the performance of the algorithm in conjunction with variable-bit-rate traffic.
Reference: [18] <author> A. Varma and D. Stiliadis, </author> <title> "FAST: an FPGA-based simulation testbed for ATM switching systems," </title> <booktitle> in Interop'95 Engineer Conference, </booktitle> <month> April </month> <year> 1995. </year> <month> 31 </month>
Reference-contexts: Further work will include the analysis of frame-based fair queueing under probabilistic input traffic models, such as the exponentially-bounded-burstiness model [17]. We also plan to implement the algorithm in hardware using our FPGA-based ATM Simulation Testbed <ref> [18] </ref>. A network of switches will be simulated in order to evaluate the performance of the algorithm in conjunction with variable-bit-rate traffic.
References-found: 18

