URL: http://www.cs.unc.edu/~anderson/papers/jacm94.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: The Elusive Atomic Register  
Author: Ambuj K. Singh James H. Anderson Mohamed G. Gouda 
Date: December 1986 Revised May 1989, November 1991, June 1992  
Address: Santa Barbara, California 93106-5110  College Park College Park, Maryland 20742-3255  Austin, Texas 78712-1188  
Affiliation: Department of Computer Science The University of California at Santa Barbara  Department of Computer Science The University of Maryland at  Department of Computer Sciences The University of Texas at Austin  
Note: (To appear in Journal of the ACM  Work supported in part by NSF Grant ECS 83-04734 and Office of Naval Research Contract N00014 86-K-0182. Work supported in part by Office of Naval Research Contract N00014-86-K-0763.  
Abstract: We present a construction of a single-writer, multiple-reader atomic register from single-writer, single-reader atomic registers. The complexity of our construction is asymptotically optimal; O(M 2 + MN) shared single-writer, single-reader safe bits are required to construct a single-writer, M-reader, N-bit atomic register. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Gouda, </author> <title> The virtue of patience: concurrent programming with and without waiting, </title> <type> Technical Report TR.90.23, </type> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: require that all variables are bounded in size. (There is a very simple solution if the variables are unbounded [23].) As mentioned in the introduction, each program of a construction is "wait-free," i.e., synchronization primitives and busy-wait loops are not allowed. (For a more formal definition of wait-freedom, refer to <ref> [1] </ref>.) Next, we define several concepts that are needed to state the correctness condition for a multiple-reader construction. These definitions apply to a given construction. <p> This difficulty will be encountered in any construction of a multiple-reader atomic register from single-reader ones. In our solution, the uncertainty interval begins after the Writer writes to WR <ref> [1] </ref> in the second pass and ends after the Writer writes to WR [M ] in the second pass. In other words, the uncertainty interval exists while the predicate w at 4 ^ :w before 4 is true. <p> Note also that we have renamed the programs and variables to coincide with the names given in Figure 3. We have also moved the assignment to seq <ref> [1] </ref> so that it occurs immediately after the read from RW . These changes to our original construction clearly do not affect the construction's correctness. Thus, because our original construction is correct, the construction shown in Now, consider the code for W in Figure 4 (a). <p> With this change, the seq [2] fields of the construction serve no useful purpose and hence all can be removed. Finally, the condition x:seq <ref> [1] </ref> = y:seq [1] ^ x:alt = y:alt in Reader S's computation of f lag is also a tautology. Instead of removing it, we choose to replace it by another tautology x = y. <p> With this change, the seq [2] fields of the construction serve no useful purpose and hence all can be removed. Finally, the condition x:seq <ref> [1] </ref> = y:seq [1] ^ x:alt = y:alt in Reader S's computation of f lag is also a tautology. Instead of removing it, we choose to replace it by another tautology x = y. These changes, which clearly do not affect the construction's correctness, yield the code given in Figure 4 (b). <p> It turns out that with a few slight changes to the code for Reader R, the first statement of Reader S can be broken into three separate statements. The required 16 program W (val : valtype) begin old; new; alt := new; val; :alt; read q <ref> [1] </ref> := RW ; seq [1] := q [1] 1; hread q [2] := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq <p> The required 16 program W (val : valtype) begin old; new; alt := new; val; :alt; read q <ref> [1] </ref> := RW ; seq [1] := q [1] 1; hread q [2] := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) <p> The required 16 program W (val : valtype) begin old; new; alt := new; val; :alt; read q <ref> [1] </ref> := RW ; seq [1] := q [1] 1; hread q [2] := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS <p> The required 16 program W (val : valtype) begin old; new; alt := new; val; :alt; read q <ref> [1] </ref> := RW ; seq [1] := q [1] 1; hread q [2] := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin <p> begin old; new; alt := new; val; :alt; read q <ref> [1] </ref> := RW ; seq [1] := q [1] 1; hread q [2] := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x := WR; h read x := WS; write RW := <p> := RW ; seq <ref> [1] </ref> := q [1] 1; hread q [2] := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x := WR; h read x := WS; write RW := x:seq [1]; write SW := x:seq [2]; read y := WR; <p> := SW ; seq [2] := q [2] 1; write WS := (old; new; seq <ref> [1] </ref>; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x := WR; h read x := WS; write RW := x:seq [1]; write SW := x:seq [2]; read y := WR; read v := RS; f lag := p 0 ; read y <p> [2]; alt; false); write WR := (old; new; seq <ref> [1] </ref>; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x := WR; h read x := WS; write RW := x:seq [1]; write SW := x:seq [2]; read y := WR; read v := RS; f lag := p 0 ; read y := WS i; write RS := (f lag; y:seq [1]; y:alt); flag := p 0 _ p 1 ; if flag then return (y:new) if f lag then return <p> program S returns valtype begin begin read x := WR; h read x := WS; write RW := x:seq <ref> [1] </ref>; write SW := x:seq [2]; read y := WR; read v := RS; f lag := p 0 ; read y := WS i; write RS := (f lag; y:seq [1]; y:alt); flag := p 0 _ p 1 ; if flag then return (y:new) if f lag then return (y:new) else return (y:old) fi else return (y:old) fi end end program W (val : valtype) program S returns valtype begin begin old; new; alt := new; val; :alt; h read <p> _ p 1 ; if flag then return (y:new) if f lag then return (y:new) else return (y:old) fi else return (y:old) fi end end program W (val : valtype) program S returns valtype begin begin old; new; alt := new; val; :alt; h read x := WS; read q <ref> [1] </ref> := RW ; read v := RS; seq [1] := q [1] 1; read y := WS i; write WS := (old; new; seq [1]; alt; f alse); flag := y:done _ (x = y ^ v [1]:flag ^ write WR := (old; new; seq [1]; alt); x:seq [1] = <p> if f lag then return (y:new) else return (y:old) fi else return (y:old) fi end end program W (val : valtype) program S returns valtype begin begin old; new; alt := new; val; :alt; h read x := WS; read q <ref> [1] </ref> := RW ; read v := RS; seq [1] := q [1] 1; read y := WS i; write WS := (old; new; seq [1]; alt; f alse); flag := y:done _ (x = y ^ v [1]:flag ^ write WR := (old; new; seq [1]; alt); x:seq [1] = v [1]:seq ^ x:alt = v [1]:alt); write WS <p> then return (y:new) else return (y:old) fi else return (y:old) fi end end program W (val : valtype) program S returns valtype begin begin old; new; alt := new; val; :alt; h read x := WS; read q <ref> [1] </ref> := RW ; read v := RS; seq [1] := q [1] 1; read y := WS i; write WS := (old; new; seq [1]; alt; f alse); flag := y:done _ (x = y ^ v [1]:flag ^ write WR := (old; new; seq [1]; alt); x:seq [1] = v [1]:seq ^ x:alt = v [1]:alt); write WS := (old; new; <p> program W (val : valtype) program S returns valtype begin begin old; new; alt := new; val; :alt; h read x := WS; read q <ref> [1] </ref> := RW ; read v := RS; seq [1] := q [1] 1; read y := WS i; write WS := (old; new; seq [1]; alt; f alse); flag := y:done _ (x = y ^ v [1]:flag ^ write WR := (old; new; seq [1]; alt); x:seq [1] = v [1]:seq ^ x:alt = v [1]:alt); write WS := (old; new; seq [1]; alt; true) if f lag then return (y:new) end else return <p> := WS; read q <ref> [1] </ref> := RW ; read v := RS; seq [1] := q [1] 1; read y := WS i; write WS := (old; new; seq [1]; alt; f alse); flag := y:done _ (x = y ^ v [1]:flag ^ write WR := (old; new; seq [1]; alt); x:seq [1] = v [1]:seq ^ x:alt = v [1]:alt); write WS := (old; new; seq [1]; alt; true) if f lag then return (y:new) end else return (y:old) fi end 17 changes to Reader R are as follows: Reader R computes its f lag by flag := x <p> q <ref> [1] </ref> := RW ; read v := RS; seq [1] := q [1] 1; read y := WS i; write WS := (old; new; seq [1]; alt; f alse); flag := y:done _ (x = y ^ v [1]:flag ^ write WR := (old; new; seq [1]; alt); x:seq [1] = v [1]:seq ^ x:alt = v [1]:alt); write WS := (old; new; seq [1]; alt; true) if f lag then return (y:new) end else return (y:old) fi end 17 changes to Reader R are as follows: Reader R computes its f lag by flag := x = y instead <p> read y := WS i; write WS := (old; new; seq <ref> [1] </ref>; alt; f alse); flag := y:done _ (x = y ^ v [1]:flag ^ write WR := (old; new; seq [1]; alt); x:seq [1] = v [1]:seq ^ x:alt = v [1]:alt); write WS := (old; new; seq [1]; alt; true) if f lag then return (y:new) end else return (y:old) fi end 17 changes to Reader R are as follows: Reader R computes its f lag by flag := x = y instead of f lag := y:done ^ x:seq [1] = y:seq [1]; Reader R assigns (flag; <p> <ref> [1] </ref>:alt); write WS := (old; new; seq [1]; alt; true) if f lag then return (y:new) end else return (y:old) fi end 17 changes to Reader R are as follows: Reader R computes its f lag by flag := x = y instead of f lag := y:done ^ x:seq [1] = y:seq [1]; Reader R assigns (flag; x:seq [1]; x:alt) to RS rather than (f lag; y:seq [1]; y:alt); and Reader R always returns x:new. With the last change, it turns out that the Writer no longer needs to write the old value to Reader R. <p> := (old; new; seq <ref> [1] </ref>; alt; true) if f lag then return (y:new) end else return (y:old) fi end 17 changes to Reader R are as follows: Reader R computes its f lag by flag := x = y instead of f lag := y:done ^ x:seq [1] = y:seq [1]; Reader R assigns (flag; x:seq [1]; x:alt) to RS rather than (f lag; y:seq [1]; y:alt); and Reader R always returns x:new. With the last change, it turns out that the Writer no longer needs to write the old value to Reader R. <p> true) if f lag then return (y:new) end else return (y:old) fi end 17 changes to Reader R are as follows: Reader R computes its f lag by flag := x = y instead of f lag := y:done ^ x:seq <ref> [1] </ref> = y:seq [1]; Reader R assigns (flag; x:seq [1]; x:alt) to RS rather than (f lag; y:seq [1]; y:alt); and Reader R always returns x:new. With the last change, it turns out that the Writer no longer needs to write the old value to Reader R. The resulting construction is the same as that given in Figure 3. <p> return (y:old) fi end 17 changes to Reader R are as follows: Reader R computes its f lag by flag := x = y instead of f lag := y:done ^ x:seq <ref> [1] </ref> = y:seq [1]; Reader R assigns (flag; x:seq [1]; x:alt) to RS rather than (f lag; y:seq [1]; y:alt); and Reader R always returns x:new. With the last change, it turns out that the Writer no longer needs to write the old value to Reader R. The resulting construction is the same as that given in Figure 3. This completes our comparison of the two constructions.
Reference: [2] <author> J. Anderson, A. Singh, and M. Gouda, </author> <title> The elusive atomic register, </title> <type> Technical Report TR.86.29, </type> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <year> 1986. </year>
Reference-contexts: Henceforth, we concern ourselves only with single-writer atomic registers. The problem of constructing a multiple-reader atomic register from single-reader atomic registers was mentioned as an open problem by Lamport [12] and by Vitanyi and Awerbuch [23]. The first solution to the problem was presented by us in <ref> [2] </ref>, where a two-reader construction is given and then generalized to construct an M -reader register from (M 1)-reader registers. <p> This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] <ref> [2, 4, 7, 10, 13, 15, 19] </ref> [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> Thus, the proof of correctness for the M -reader register reduces to the much simpler task of proving the correctness of a two-reader construction consisting of Readers R and S. A formal proof of correctness for the construction of Figure 3 appears in <ref> [2] </ref>, where this construction was first presented. <p> Next, consider Reader S. The first atomic statement of S assigns the same values to local variables x and y. Thus, in Reader S's calculation of flag, which depends on p 0 and p 1 as defined in Figure 2, x:seq <ref> [2] </ref> = y:seq [2] is a tautology and can be removed. With this change, the seq [2] fields of the construction serve no useful purpose and hence all can be removed. <p> Next, consider Reader S. The first atomic statement of S assigns the same values to local variables x and y. Thus, in Reader S's calculation of flag, which depends on p 0 and p 1 as defined in Figure 2, x:seq <ref> [2] </ref> = y:seq [2] is a tautology and can be removed. With this change, the seq [2] fields of the construction serve no useful purpose and hence all can be removed. <p> Thus, in Reader S's calculation of flag, which depends on p 0 and p 1 as defined in Figure 2, x:seq <ref> [2] </ref> = y:seq [2] is a tautology and can be removed. With this change, the seq [2] fields of the construction serve no useful purpose and hence all can be removed. Finally, the condition x:seq [1] = y:seq [1] ^ x:alt = y:alt in Reader S's computation of f lag is also a tautology. <p> The required 16 program W (val : valtype) begin old; new; alt := new; val; :alt; read q [1] := RW ; seq [1] := q [1] 1; hread q <ref> [2] </ref> := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq <p> The required 16 program W (val : valtype) begin old; new; alt := new; val; :alt; read q [1] := RW ; seq [1] := q [1] 1; hread q <ref> [2] </ref> := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) <p> The required 16 program W (val : valtype) begin old; new; alt := new; val; :alt; read q [1] := RW ; seq [1] := q [1] 1; hread q <ref> [2] </ref> := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R <p> The required 16 program W (val : valtype) begin old; new; alt := new; val; :alt; read q [1] := RW ; seq [1] := q [1] 1; hread q <ref> [2] </ref> := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x <p> new; alt := new; val; :alt; read q [1] := RW ; seq [1] := q [1] 1; hread q <ref> [2] </ref> := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x := WR; h read x := WS; write RW := x:seq [1]; <p> ; seq [1] := q [1] 1; hread q <ref> [2] </ref> := SW ; seq [2] := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x := WR; h read x := WS; write RW := x:seq [1]; write SW := x:seq [2]; read y := WR; read v <p> ; seq <ref> [2] </ref> := q [2] 1; write WS := (old; new; seq [1]; seq [2]; alt; false) i; hwrite WR := (old; new; seq [1]; seq [2]; alt; false); write WR := (old; new; seq [1]; seq [2]; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x := WR; h read x := WS; write RW := x:seq [1]; write SW := x:seq [2]; read y := WR; read v := RS; f lag := p 0 ; read y := WS <p> := (old; new; seq [1]; seq <ref> [2] </ref>; alt; true) i; write WS := (old; new; seq [1]; seq [2]; alt; true) end program R returns valtype program S returns valtype begin begin read x := WR; h read x := WS; write RW := x:seq [1]; write SW := x:seq [2]; read y := WR; read v := RS; f lag := p 0 ; read y := WS i; write RS := (f lag; y:seq [1]; y:alt); flag := p 0 _ p 1 ; if flag then return (y:new) if f lag then return (y:new) else return (y:old) fi
Reference: [3] <author> B. Bloom, </author> <title> Constructing two-writer atomic registers, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 37, No. 12, </volume> <month> December </month> <year> 1988, </year> <pages> pp. 1506-1514. </pages> <booktitle> Also appeared in Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 249-259. </pages>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] [2, 4, 7, 10, 13, 15, 19] <ref> [3, 13, 17, 18, 23] </ref> reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction.
Reference: [4] <author> J. Burns and G. Peterson, </author> <title> Constructing multi-reader atomic values from non-atomic values, </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 222-231. </pages>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] <ref> [2, 4, 7, 10, 13, 15, 19] </ref> [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> Subsequently, several solutions with polynomial complexity have been presented <ref> [4, 10, 13, 15] </ref>, including one given by us in [19]. The latter construction is a generalization of our two-reader construction. In this paper, we present a construction of a multiple-reader atomic register that is based upon the solution in [19].
Reference: [5] <author> K. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The assertion A unless B holds iff for every pair of consecutive states in any history, if A ^ :B holds in the first state, then A _ B holds in the second state. 2 Our notion of unless has been borrowed from the UNITY logic of Chandy and Misra <ref> [5] </ref>. Informally, A unless B means that once A becomes true, it remains true unless B becomes true.
Reference: [6] <author> P. Courtois, F. Heymans, and D. Parnas, </author> <title> Concurrent control with readers and writers, </title> <journal> Communications of the ACM , Vol. </journal> <volume> 14, No. 10, </volume> <month> Oct. </month> <year> 1971, </year> <pages> pp. 667-668. </pages>
Reference-contexts: amount of time, regardless of the activities of other processes. (This also means that the read or write of a process is immune to the failure of other processes that also access the register.) The wait-freedom restriction distinguishes the problem of constructing an atomic register from the classic readers-writers problem <ref> [6] </ref>. Peterson [16] was the first to suggest the problem of constructing atomic registers from safe registers.
Reference: [7] <author> S. Haldar and K. Vidyasankar, </author> <title> Counterexamples to a one writer multireader atomic variable construction of Burns and Peterson, </title> <type> Technical Report #9106, </type> <institution> Department of Computer Science, Memorial University of Newfoundland, St. John's, Canada, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] <ref> [2, 4, 7, 10, 13, 15, 19] </ref> [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction.
Reference: [8] <author> M. Herlihy and J. Wing, </author> <title> Linearizability: a correctness condition for concurrent objects, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 3, </volume> <year> 1990, </year> <pages> pp. 463-492. </pages>
Reference-contexts: His axioms for atomicity in essence require that all read and write operations be shrunk to a point; such a shrinking of operations is possible iff a function that meets the three conditions of our 13 definition exists. Recently, Herlihy and Wing <ref> [8] </ref> have extended the idea of atomicity to arbitrary abstract data types by defining the concept of linearizability . Though akin to serializability, the usual correctness criterion for concurrent execution of transactions, there are some subtle differences between the two concepts. <p> Though akin to serializability, the usual correctness criterion for concurrent execution of transactions, there are some subtle differences between the two concepts. One important distinction is that linearizability is a local correctness condition whereas serializability is not. We refer the reader to <ref> [8] </ref> for further details. In order to prove the correctness of a multiple-reader atomic register construction, a function that meets the three conditions of integrity, proximity, and precedence has to be defined for every possible history.
Reference: [9] <author> A. Israeli and M. Li, </author> <title> Bounded time-stamps, </title> <booktitle> Proc. of 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 371-382. </pages>
Reference-contexts: For our construction, this yields a space complexity of 6M 2 + 6M N + 26M + 19M (M +1)=2. It is well known that the lower bound on space for this problem is O (M 2 + M N ) bits <ref> [9] </ref>; thus, our construction is asymptotically optimal. Given the correctness proof of Section 5, our construction establishes the following theorem.
Reference: [10] <author> L. Kirousis, E. Kranakis, and P. Vitanyi, </author> <title> Atomic multireader register, </title> <booktitle> Proceedings of the Second International Workshop on Distributed Computing, Springer Verlag Lecture Notes in Computer Science 312, </booktitle> <year> 1987, </year> <pages> pp. 278-296. </pages>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] <ref> [2, 4, 7, 10, 13, 15, 19] </ref> [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> Subsequently, several solutions with polynomial complexity have been presented <ref> [4, 10, 13, 15] </ref>, including one given by us in [19]. The latter construction is a generalization of our two-reader construction. In this paper, we present a construction of a multiple-reader atomic register that is based upon the solution in [19].
Reference: [11] <author> L. Lamport, </author> <title> The "Hoare logic" of concurrent programs, </title> <journal> Acta Informatica, </journal> <volume> Vol. 14, No. 1, </volume> <year> 1980, </year> <pages> pp. 21-37. </pages>
Reference-contexts: Next, we define three types of control predicates <ref> [11] </ref>. Definition: Let p be an operation of program P in some history and let p : i be an event of p.
Reference: [12] <author> L. Lamport, </author> <title> On interprocess communication, parts I and II, </title> <journal> Distributed Computing, </journal> <volume> Vol. 1, </volume> <year> 1986, </year> <pages> pp. 77-101. </pages>
Reference-contexts: Each step in the figure is labeled by a reference to the papers in which the given construction is presented. Henceforth, we concern ourselves only with single-writer atomic registers. The problem of constructing a multiple-reader atomic register from single-reader atomic registers was mentioned as an open problem by Lamport <ref> [12] </ref> and by Vitanyi and Awerbuch [23]. The first solution to the problem was presented by us in [2], where a two-reader construction is given and then generalized to construct an M -reader register from (M 1)-reader registers. <p> This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - <ref> [12, 20] </ref> [2, 4, 7, 10, 13, 15, 19] [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> The presentation of this construction differs from that of [19] in two respects. First, the solution presented here is of optimal complexity, whereas the one given in [19] is not. (Actually, an optimal solution can be attained by combining the solution in [19] with constructions by Lamport <ref> [12] </ref> and Peterson [16] | see [19] for details.) Second, the correctness proof presented in this paper is more rigorous and formal (and, we hope, easier to understand) than the proof presented in [19]. The rest of the paper is organized as follows. <p> By dealing only with complete operations, the value "Read from" or "Written to" the 3 constructed register by an operation is well-defined. Notation: We denote the ith operation of the Writer, where i 0, by W : i. (Thus, W : 0 denotes the initial Write.) 2 Following Lamport <ref> [12] </ref>, we define the correctness condition for a construction as follows.
Reference: [13] <author> M. Li, J. Tromp, and P. Vitanyi, </author> <title> How to construct wait-free variables, </title> <booktitle> Proceedings of International Colloquium on Automata, Languages, and Programming , Springer Lecture Notes in Computer Science 372, </booktitle> <year> 1989, </year> <pages> pp. 488-505. </pages>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] <ref> [2, 4, 7, 10, 13, 15, 19] </ref> [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] [2, 4, 7, 10, 13, 15, 19] <ref> [3, 13, 17, 18, 23] </ref> reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> Subsequently, several solutions with polynomial complexity have been presented <ref> [4, 10, 13, 15] </ref>, including one given by us in [19]. The latter construction is a generalization of our two-reader construction. In this paper, we present a construction of a multiple-reader atomic register that is based upon the solution in [19].
Reference: [14] <author> J. Misra, </author> <title> Axioms for memory access in asynchronous hardware systems, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 8, </volume> <year> 1986, </year> <pages> pp. 142-153. </pages>
Reference-contexts: Our construction requires O (M 2 + M N ) shared single-writer, single-reader safe bits, which is asymptotically optimal. Our definition of atomicity is equivalent to that given by Misra in <ref> [14] </ref>. His axioms for atomicity in essence require that all read and write operations be shrunk to a point; such a shrinking of operations is possible iff a function that meets the three conditions of our 13 definition exists.
Reference: [15] <author> R. Newman-Wolfe, </author> <title> A protocol for wait-free, atomic, multi-reader shared variables, </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 232-248. </pages>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] <ref> [2, 4, 7, 10, 13, 15, 19] </ref> [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> Subsequently, several solutions with polynomial complexity have been presented <ref> [4, 10, 13, 15] </ref>, including one given by us in [19]. The latter construction is a generalization of our two-reader construction. In this paper, we present a construction of a multiple-reader atomic register that is based upon the solution in [19].
Reference: [16] <author> G. Peterson, </author> <title> Concurrent reading while writing, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 5, </volume> <year> 1983, </year> <pages> pp. 46-55. </pages>
Reference-contexts: Peterson <ref> [16] </ref> was the first to suggest the problem of constructing atomic registers from safe registers. <p> First, the solution presented here is of optimal complexity, whereas the one given in [19] is not. (Actually, an optimal solution can be attained by combining the solution in [19] with constructions by Lamport [12] and Peterson <ref> [16] </ref> | see [19] for details.) Second, the correctness proof presented in this paper is more rigorous and formal (and, we hope, easier to understand) than the proof presented in [19]. The rest of the paper is organized as follows.
Reference: [17] <author> G. Peterson and J. Burns, </author> <title> Concurrent reading while writing II: the multi-writer case, </title> <booktitle> Proceedings of the 28th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 383-392. </pages>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] [2, 4, 7, 10, 13, 15, 19] <ref> [3, 13, 17, 18, 23] </ref> reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction.
Reference: [18] <author> R. Schaffer, </author> <title> On the correctness of atomic multi-writer registers, </title> <type> Technical Report MIT/LCS/TM-364, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] [2, 4, 7, 10, 13, 15, 19] <ref> [3, 13, 17, 18, 23] </ref> reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction.
Reference: [19] <author> A. Singh, J. Anderson, and M. Gouda, </author> <title> The elusive atomic register revisited, </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 206-221. </pages>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] <ref> [2, 4, 7, 10, 13, 15, 19] </ref> [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in <ref> [19] </ref>. The latter construction is a generalization of our two-reader construction. In this paper, we present a construction of a multiple-reader atomic register that is based upon the solution in [19]. The presentation of this construction differs from that of [19] in two respects. <p> Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in <ref> [19] </ref>. The latter construction is a generalization of our two-reader construction. In this paper, we present a construction of a multiple-reader atomic register that is based upon the solution in [19]. The presentation of this construction differs from that of [19] in two respects. First, the solution presented here is of optimal complexity, whereas the one given in [19] is not. (Actually, an optimal solution can be attained by combining the solution in [19] with constructions by Lamport [12] and Peterson <p> [4, 10, 13, 15], including one given by us in <ref> [19] </ref>. The latter construction is a generalization of our two-reader construction. In this paper, we present a construction of a multiple-reader atomic register that is based upon the solution in [19]. The presentation of this construction differs from that of [19] in two respects. First, the solution presented here is of optimal complexity, whereas the one given in [19] is not. (Actually, an optimal solution can be attained by combining the solution in [19] with constructions by Lamport [12] and Peterson [16] | see [19] for details.) Second, the correctness proof <p> In this paper, we present a construction of a multiple-reader atomic register that is based upon the solution in <ref> [19] </ref>. The presentation of this construction differs from that of [19] in two respects. First, the solution presented here is of optimal complexity, whereas the one given in [19] is not. (Actually, an optimal solution can be attained by combining the solution in [19] with constructions by Lamport [12] and Peterson [16] | see [19] for details.) Second, the correctness proof presented in this paper is more rigorous and formal (and, we hope, easier to understand) than the proof <p> that is based upon the solution in <ref> [19] </ref>. The presentation of this construction differs from that of [19] in two respects. First, the solution presented here is of optimal complexity, whereas the one given in [19] is not. (Actually, an optimal solution can be attained by combining the solution in [19] with constructions by Lamport [12] and Peterson [16] | see [19] for details.) Second, the correctness proof presented in this paper is more rigorous and formal (and, we hope, easier to understand) than the proof presented in [19]. The rest of the paper is organized as follows. <p> this construction differs from that of <ref> [19] </ref> in two respects. First, the solution presented here is of optimal complexity, whereas the one given in [19] is not. (Actually, an optimal solution can be attained by combining the solution in [19] with constructions by Lamport [12] and Peterson [16] | see [19] for details.) Second, the correctness proof presented in this paper is more rigorous and formal (and, we hope, easier to understand) than the proof presented in [19]. The rest of the paper is organized as follows. <p> (Actually, an optimal solution can be attained by combining the solution in <ref> [19] </ref> with constructions by Lamport [12] and Peterson [16] | see [19] for details.) Second, the correctness proof presented in this paper is more rigorous and formal (and, we hope, easier to understand) than the proof presented in [19]. The rest of the paper is organized as follows. In Section 2, we formally define the problem of constructing an M -reader atomic register from single-reader atomic registers. In Section 3, we present our construction.
Reference: [20] <author> J. Tromp, </author> <title> How to construct an atomic variable, </title> <booktitle> Proceedings of the Third International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 392, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989, </year> <pages> pp. 292-302. 33 </pages>
Reference-contexts: This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - <ref> [12, 20] </ref> [2, 4, 7, 10, 13, 15, 19] [3, 13, 17, 18, 23] reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction.
Reference: [21] <author> K. Vidyasankar, </author> <title> Converting Lamport's regular registers to atomic registers, </title> <journal> Informa--tion Processing Letters, </journal> <volume> Vol. 28, No. 6, </volume> <year> 1988, </year> <pages> pp. 287-290. </pages>
Reference: [22] <author> K. Vidyasankar, </author> <title> Concurrent reading while writing revisited, </title> <journal> Distributed Computing, </journal> <volume> Vol. 4, </volume> <year> 1990, </year> <pages> pp. 81-85. </pages>
Reference-contexts: Using the construction of <ref> [22] </ref>, a single-writer, single-reader, B-bit atomic register can be constructed using 3B + 7 shared single-writer, single-reader safe bits. For our construction, this yields a space complexity of 6M 2 + 6M N + 26M + 19M (M +1)=2.
Reference: [23] <author> P. Vitanyi and B. Awerbuch, </author> <title> Atomic shared register access by asynchronous hardware, </title> <booktitle> Proceedings of the 27th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 233-243. </pages>
Reference-contexts: Henceforth, we concern ourselves only with single-writer atomic registers. The problem of constructing a multiple-reader atomic register from single-reader atomic registers was mentioned as an open problem by Lamport [12] and by Vitanyi and Awerbuch <ref> [23] </ref>. The first solution to the problem was presented by us in [2], where a two-reader construction is given and then generalized to construct an M -reader register from (M 1)-reader registers. <p> This solution, though easy to explain and understand, uses an exponential number of single 1 Safe 1/1/1 - Atomic 1=1=N - Atomic 1=M=N - Atomic K=M=N Atomic 1=M=1 - [12, 20] [2, 4, 7, 10, 13, 15, 19] <ref> [3, 13, 17, 18, 23] </ref> reader atomic registers. Subsequently, several solutions with polynomial complexity have been presented [4, 10, 13, 15], including one given by us in [19]. The latter construction is a generalization of our two-reader construction. <p> Each variable of a construction is a single-reader, single-writer atomic register | this restriction arises since our aim is to construct a multiple-reader register from single-reader registers. We also require that all variables are bounded in size. (There is a very simple solution if the variables are unbounded <ref> [23] </ref>.) As mentioned in the introduction, each program of a construction is "wait-free," i.e., synchronization primitives and busy-wait loops are not allowed. (For a more formal definition of wait-freedom, refer to [1].) Next, we define several concepts that are needed to state the correctness condition for a multiple-reader construction.
References-found: 23

