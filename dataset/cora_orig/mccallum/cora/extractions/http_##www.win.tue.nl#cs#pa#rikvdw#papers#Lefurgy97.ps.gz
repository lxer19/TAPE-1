URL: http://www.win.tue.nl/cs/pa/rikvdw/papers/Lefurgy97.ps.gz
Refering-URL: http://www.win.tue.nl/cs/pa/rikvdw/bibl.html
Root-URL: http://www.win.tue.nl
Title: Abstract  
Abstract: We propose a method for compressing programs in embedded processors where instruction memory size dominates cost. A post-compilation analyzer examines a program and replaces common sequences of instructions with a single instruction codeword. A microprocessor executes the compressed instruction sequences by fetching code-words from the instruction memory, expanding them back to the original sequence of instructions in the decode stage, and issuing them to the execution stages. We apply our technique to the PowerPC, ARM, and i386 instruction sets and achieve an average size reduction of 39%, 34%, and 26%, respectively, for SPEC CINT95 programs. 
Abstract-found: 1
Intro-found: 1
Reference: [ARM95] <institution> Advanced RISC Machines Ltd., </institution> <note> An Introduction to Thumb, </note> <month> March </month> <year> 1995. </year>
Reference-contexts: This suggests that the number of static instructions in programs increases by 40% and 20% respectively. This requires a program to execute more instructions which reduces performance. For example, Thumb code runs 15% - 20% slower on systems with ideal instruction memories (32-bit buses and no wait states) <ref> [ARM95] </ref>. Our method does not cause the number of instructions in a program to increase. Compressed programs are translated back into the instructions of the original uncompressed program and executed, so that the number of instructions executed in a program is not changed.
Reference: [Bell90] <author> T. Bell, J. Cleary, I. Witten, </author> <title> Text Compression, </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: It can be shown that for every dictionary method there is an equivalent statistical method which achieves equal compression and can be improved upon to give better compression <ref> [Bell90] </ref>. Thus statistical methods can always achieve better compression than dictionary methods albeit at the expense of additional computation requirements for decompression. It should be noted, however, that dictionary compression yields good results in systems with memory and time constraints because one entry expands to several characters.
Reference: [Bird96] <author> P. Bird and T. Mudge, </author> <title> An Instruction Stream Compression Technique, </title> <institution> CSE-TR-319-96, EECS Department, University of Michigan, </institution> <month> November </month> <year> 1996. </year>
Reference: [Chen97a] <author> I. Chen, P. Bird, and T. Mudge, </author> <title> The Impact of Instruction Compression on I-cache Performance, </title> <institution> CSE-TR-330-97, EECS Department, University of Michigan, </institution> <year> 1997. </year>
Reference: [Chen97b] <author> I. Chen, </author> <title> Enhancing Instruction Fetching Mechanism Using Data Compression, </title> <type> Ph.D. Dissertation, </type> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: This problem will only increase as the gap between processor performance and memory performance grows. Reducing program size is one way to reduce instruction cache misses and provide higher instruction bandwidth <ref> [Chen97b] </ref>. This paper focuses on compression for embedded applications, where execution speed can be traded for compression. We borrow concepts from the field of text compression and apply them to the compression of instruction sequences. We propose modifications at the microarchitecture level to support compressed programs.
Reference: [Kissell97] <author> K. Kissell, MIPS16: </author> <title> High-density MIPS for the Embedded Market, Silicon Graphics MIPS Group, </title> <year> 1997. </year>
Reference-contexts: Thumb [ARM95][MPR95] and MIPS16 <ref> [Kissell97] </ref> are two recently proposed instruction set modifications which define reduced instruction word sizes in an effort to reduce the overall size of compiled programs. Thumb and MIPS16 are defined as subsets of the ARM and MIPS-III architectures.
Reference: [Kozuch94] <author> M. Kozuch and A. Wolfe, </author> <title> Compression of Embedded System Programs, </title> <booktitle> IEEE International Conference on Computer Design, </booktitle> <year> 1994. </year>
Reference-contexts: Although there is a higher decode penalty for using variable-length code-words, they make possible better compression. By restrict ing the codewords to integer multiples of 4 bits, we still retain some of the decoding process regularity that the 1-bit aligned Huffman encoding in <ref> [Kozuch94] </ref> lacks. Our choice of encoding is based on CINT95 benchmarks. We present only the best encoding choice we have discovered. We use codewords that are 8-bits, 12-bits, and 16-bits in length. Other programs may benefit from different encodings. <p> Our approach combines elements of two previous proposals. First we use a dictionary compression method (as in [Liao96]) that allows codewords to expand to several instructions. Second, we allow the codewords to be smaller than a single instruction (as in <ref> [Kozuch94] </ref>).
Reference: [Liao96] <author> S. Liao, </author> <title> Code Generation and Optimization for Embedded Digital Signal Processors, </title> <type> Ph.D. Dissertation, </type> <institution> Massachu-setts Institute of Technology, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: Finally, our compression method does not need a LAT mechanism since we patch all branches in the binary executable to use the new instruction addresses in the compressed program. 2.4 Reusing mini-subroutines Liao proposes a software method for supporting compressed code <ref> [Liao96] </ref>. He finds mini-subroutines which are common sequences of instructions in the program. Each instance of a mini-subroutine is removed from the program and replaced with a call instruction. The mini-subroutine is placed once in the text of the program and ends with a return instruction. <p> Dic--tionary entries with 1 instruction achieve between 46% and 60% of the compression savings. The short entries contribute to a larger portion of the savings as the size of the dictionary increases. The compression method in <ref> [Liao96] </ref> cannot take advantage of this since the code-words are the size of single instructions, so single instructions are not compressed. 4.4 Variable-length codewords In the baseline method, we used 2-byte codewords. We can improve our compression ratio by using smaller encodings for the codewords. <p> Our approach combines elements of two previous proposals. First we use a dictionary compression method (as in <ref> [Liao96] </ref>) that allows codewords to expand to several instructions. Second, we allow the codewords to be smaller than a single instruction (as in [Kozuch94]).
Reference: [MPR95] <institution> Thumb Squeezes ARM Code Size, </institution> <type> Microprocessor Report 9(4), </type> <month> 27 March </month> <year> 1995. </year>
Reference: [Perl96] <author> S. Perl and R. </author> <title> Sites, Studies of Windows NT Performance Using Dynamic Execution Traces, </title> <booktitle> Proceedings of the USENIX 2nd Symposium on Operating Systems Design and Implementation, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Thus, the ability to compress instruction code is important, even at the cost of execution speed. High performance systems are also impacted by program size due to the delays incurred by instruction cache misses. A study at Digital <ref> [Perl96] </ref> showed that an SQL server on a DEC 21064 Alpha requires twice as much instruction bandwidth as the processor is able to provide due to instruction cache misses. This problem will only increase as the gap between processor performance and memory performance grows.
Reference: [SPEC95] <institution> SPEC CPU95, </institution> <note> Technical Manual, </note> <month> August </month> <year> 1995. </year>
Reference-contexts: Indeed, we found that a small number of instruction encodings are highly reused in most programs. To illustrate the repetition of instruction encodings, we profiled the SPEC CINT95 benchmarks <ref> [SPEC95] </ref>. The benchmarks were compiled for PowerPC with GCC 2.7.2 using -O2 optimization.
Reference: [Storer77] <author> J. Storer, </author> <title> NP-completeness Results Concerning Data Compression, </title> <type> Technical Report 234, </type> <institution> Department of Electrical Engineering and Computer Science, Princeton University, </institution> <year> 1977. </year>
Reference-contexts: Our algorithm has 3 parts: 1. Building the dictionary 2. Replacing instruction sequences with codewords 3. Encoding codewords 3.1.1 Building the dictionary For an arbitrary text, choosing those entries of a dictionary that achieve maximum compression is NP-complete in the size of the text <ref> [Storer77] </ref>. As with most dictionary methods, we use a greedy algorithm to quickly determine the dictionary entries. On every iteration of the algorithm, we examine each potential dictionary entry and find the one that results in the largest immediate savings.
Reference: [Szymanski78] <author> T. G. Szymanski, </author> <title> Assembling code for machines with span-dependent instructions, </title> <journal> Communications of the ACM 21:4, </journal> <pages> pp. 300-308, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: If we allowed compression of relative branches, we might need to rewrite codewords represent ing relative branches after a compression pass; but this would affect relative branch targets thus requiring a rewrite of codewords, etc. The result is again an NP-complete problem <ref> [Szymanski78] </ref>. Indirect branches are compressed in our study. Since these branches take their target from a register, the branch instruction itself does not need to be patched after compression, so it cannot create the codeword rewriting problem outlined above.
Reference: [Wolfe92] <author> A. Wolfe and A. Chanin, </author> <title> Executing Compressed Programs on an Embedded RISC Architecture, </title> <booktitle> Proceedings of the 25th Annual International Symposium on Microarchitecture, </booktitle> <month> December </month> <year> 1992. </year> <title> The numbers over the bars give the compression ratio. espresso li eqntott compress Benchmarks 0 40,000 80,000 120,000 Static Prog r am Siz e (b ytes) 73% 87% 63% 77% 63% ARM7 (source: ARM Ltd.) Thumb (source: </title> <publisher> ARM Ltd.) </publisher> <address> ARM6 Nibble compression 63% </address>
Reference-contexts: This token is replaced with an efficient encoding in the encoding step. 3.1.3 Encoding codewords Encoding refers to the representation of the code-words in the compressed program. As discussed in Section 2.1, variable-length codewords, (such as those used in the Huffman encoding in <ref> [Wolfe92] </ref>) are expensive to decode. A fixed-length codeword, on the other hand, can be used directly as an index into the dictionary making decoding a simple table lookup operation. Our baseline compression method uses a fixed-length codeword to enable fast decoding. We also investigate a variable-length scheme.
References-found: 14

