URL: ftp://ftp.cs.uchicago.edu/pub/publications/tech-reports/TR-89-02.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Title: On the concrete complexity of zero-knowledge proofs  
Author: Joan Boyar Rene Peralta 
Address: Wisconsin Milwaukee  
Affiliation: Computer Science Department University of Chicago  Computer Science Department University of  
Abstract: The fact that there are zero-knowledge proofs for all languages in NP has, potentially, enormous implications to cryptography. For cryptographers, the issue is no longer "which languages in NP have zero-knowledge proofs" but rather "which languages in NP have practical zero-knowledge proofs". Thus, the concrete complexity of zero-knowledge proofs for different languages must be established. In this paper, we study the concrete complexity of the known general methods for constructing zero-knowledge proofs. We establish that circuit-based methods have the potential of producing proofs which can be used in practice. Then we introduce several techniques which greatly reduce the concrete complexity of circuit-based proofs. In order to show that our protocols yield proofs of knowledge, we show how to extend the Feige-Fiat-Shamir definition for proofs of knowledge to the model of Brassard-Chaum-Crepeau. Finally, we present techniques for improving the efficiency of protocols which involve arithmetic computations, such as modular addition, subtraction, and multiplication, and greatest common divisor.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. C. Benaloh. </author> <title> Cryptographic capsules: A disjunctive primitive for interactive protocols. </title> <booktitle> In Advances in Cryptology proceedings of CRYPTO 86, Lecture Notes in Computer Science, </booktitle> <pages> pages 213-222. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction From a practical point of view, the bottleneck in the zero-knowledge interactive proof systems and in the "interactive arguments" 1 which are produced by the techniques of <ref> [1, 5, 7, 14] </ref> is the amount of interaction necessary.
Reference: [2] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <booktitle> Proceedings of the 21th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year>
Reference-contexts: We note that this technique is closely related to the concept of program "checking", as developed by Blum and Kannan <ref> [2] </ref> and therefore their methods may prove useful in lowering the communication complexity of zero-knowledge proofs. It is outside the scope of this paper to classify and explore all the different techniques that might prove useful in lowering the communication cost of zero-knowledge proofs.
Reference: [3] <author> J. Boyar, M. Krentel, and S. Kurtz. </author> <title> A discrete logarithm implementation of zero-knowledge blobs. </title> <journal> Journal of Cryptology, </journal> <volume> 2(2) </volume> <pages> 63-76, </pages> <year> 1990. </year>
Reference-contexts: In this paper, we introduce several techniques which greatly reduce the concrete complexity of circuit-based proofs. 3 Blobs A blob encryption scheme is a technique for encrypting a single bit. Several implementations of blobs are described in <ref> [3, 4] </ref>. Formally, a blob encryption scheme is a function E : f0; 1g fi D ! n for suitably large n and set D. <p> The fact that there is an exponentially small probability that the verifier can cheat during this subprotocol means that BC-blobs can only yield almost perfect (or statistical) zero-knowledge proofs. The authenticity property of blob encryption functions (see <ref> [3] </ref>) implies that the prover can not produce x 1 ; x 2 2 D such that E (0; x 1 ) = E (1; x 2 ). BC-blobs rely on the assumption that it is impossible to compute a square root of ff modulo N in probabilistic polynomial time. <p> Finally, we note that several implementations of blobs in the literature, including BC-blobs and those based on the discrete logarithm problem (see <ref> [3, 8] </ref> ), are "normal" in the sense of the following definition. <p> We impose no further restrictions on fan-out. We begin by showing that our interactive arguments are perfect or almost-perfect zero-knowledge proofs, depending on which implementation of blobs is used. Note that our interactive arguments are obviously zero-knowledge if the blob implementation used has the forgeability property (see <ref> [3] </ref>). The following theorem shows that the forgeability property is not necessary. <p> Theorem 1 Our interactive arguments are perfect zero-knowledge if Peggy and Vic 6 Independently of this work, den Boer [11] has also decreased the number of blobs necessary for validating the computation of binary boolean functions. use any implementation of blobs such as that in <ref> [3, 8] </ref>, which leads to perfect zero--knowledge proofs in the original Brassard-Crepeau interactive arguments. proof : We will construct a simulator for these interactive arguments. <p> We will prove that if an implementation of blobs is used which has the strong equality property (see section 3, definition 5), then our protocols are still proofs of knowledge. Unfortunately, the blob implementation described in <ref> [3, 8] </ref>, which leads to perfect zero-knowledge proofs does not have the strong equality property.
Reference: [4] <author> G. Brassard, D. Chaum, and C. Crepeau. </author> <title> Minimum disclosure proofs of knowledge. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 37 </volume> <pages> 156-189, </pages> <year> 1988. </year>
Reference-contexts: In this paper we provide powerful fl Supported in part by NSA Grant Number MDA904-88-H-2006. y Supported in part by NSF Grant Number CCR-8909657. 1 Protocols, which are proofs in the model of Brassard-Chaum-Crepeau <ref> [4] </ref>, are not technically interactive proof systems, so we will refer to them as interactive arguments. 1 tools for reducing the number of bits communicated. <p> In this paper, we introduce several techniques which greatly reduce the concrete complexity of circuit-based proofs. 3 Blobs A blob encryption scheme is a technique for encrypting a single bit. Several implementations of blobs are described in <ref> [3, 4] </ref>. Formally, a blob encryption scheme is a function E : f0; 1g fi D ! n for suitably large n and set D. <p> additional blobs, and she will decode the remaining n 1 blobs to show that they are all zeros or all ones, depending on 5 Unfortunately the techniques presented here must be greatly modified for compatibility with the complementation of the bits on the wires, which occurs with the Brassard-Chaum-Crepeau system <ref> [4] </ref> . whether the gate was an AND or OR gate. If the bit b is a one, Peggy will show that n of the additional blobs are encryptions of the same bit as the output bit. NOT gates require no additional blobs.
Reference: [5] <author> G. Brassard and C. Crepeau. </author> <title> Nontransitive transfer of confidence: a perfect zero-knowledge interactive protocol for Sat and beyond. </title> <booktitle> In Proceedings of the 27th IEEE Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 188-195, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction From a practical point of view, the bottleneck in the zero-knowledge interactive proof systems and in the "interactive arguments" 1 which are produced by the techniques of <ref> [1, 5, 7, 14] </ref> is the amount of interaction necessary. <p> Vic checks everything that Peggy has sent him. 5 Eliminating truth tables In this section, we will present techniques which can be useful in improving the efficiency of perfect and almost perfect zero-knowledge proofs which use the techniques of the original Brassard-Crepeau <ref> [5] </ref> proof system. 5 In designing circuits for NP-problems, one would often want to use MAJORITY gates or AND or OR gates with large fan-in. <p> It is, of course, relatively easy to replace these gates with AND, OR, and NOT gates with bounded fan-in so that one could directly apply the Brassard-Crepeau <ref> [5] </ref> proof system. It is more efficient, however, to skip this replacement and to use the techniques in the following sections to prove that these gates with large fan-in work correctly. <p> In addition, if BC-blobs are used, then the blobs for the outputs of NOT and PARITY gates can be computed by the verifier without help from the prover (and hence without communication) <ref> [5] </ref>. Carsten Lund has shown that the resulting protocol is still a restricted input zero-knowledge proof of knowledge. The techniques described in this paper can also be used in circuit-based proofs which are interactive proof systems according to the GMR [16] definition.
Reference: [6] <author> G. Brassard and C. Crepeau. </author> <title> Zero-knowledge simulation of boolean circuits. </title> <booktitle> In Advances in Cryptology proceedings of CRYPTO 86, Lecture Notes in Computer Science, </booktitle> <pages> pages 223-233. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference: [7] <author> D. Chaum. </author> <title> Demonstrating that a public predicate can be satisfied without revealing any information about how. </title> <booktitle> In Advances in Cryptology proceedings of CRYPTO 86, Lecture Notes in Computer Science, </booktitle> <pages> pages 195-199. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction From a practical point of view, the bottleneck in the zero-knowledge interactive proof systems and in the "interactive arguments" 1 which are produced by the techniques of <ref> [1, 5, 7, 14] </ref> is the amount of interaction necessary.
Reference: [8] <author> D. Chaum, I. Damg-ard, and J. van de Graaf. </author> <title> Multiparty computations ensuring privacy of each party's input and correctness of the result. </title> <booktitle> In Advances in Cryptology proceedings of CRYPTO 87, Lecture Notes in Computer Science, </booktitle> <pages> pages 87-119. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Finally, we note that several implementations of blobs in the literature, including BC-blobs and those based on the discrete logarithm problem (see <ref> [3, 8] </ref> ), are "normal" in the sense of the following definition. <p> Theorem 1 Our interactive arguments are perfect zero-knowledge if Peggy and Vic 6 Independently of this work, den Boer [11] has also decreased the number of blobs necessary for validating the computation of binary boolean functions. use any implementation of blobs such as that in <ref> [3, 8] </ref>, which leads to perfect zero--knowledge proofs in the original Brassard-Crepeau interactive arguments. proof : We will construct a simulator for these interactive arguments. <p> We will prove that if an implementation of blobs is used which has the strong equality property (see section 3, definition 5), then our protocols are still proofs of knowledge. Unfortunately, the blob implementation described in <ref> [3, 8] </ref>, which leads to perfect zero-knowledge proofs does not have the strong equality property.
Reference: [9] <author> P.L. </author> <title> Chebyshev. Memoire sur les nombres premiers. </title> <journal> J. Math. Pures et Appl, (I)(17):366-390, </journal> <volume> 1852. </volume>
Reference-contexts: In order to obtain a concrete upper bound on p m we will need the following lemma: Lemma 1 For x &gt; 29, the product of primes less than x is greater than 2 x . proof : We will use the following inequality (due to Chebyshev <ref> [9] </ref>) :92 (x= ln x) &lt; (x) &lt; 1:11 (x= ln x): Consider the sum S (x) = p&lt;x X ln p t (x)ln x where p denotes a prime number and t (x) is 1 if x is prime and 0 otherwise.
Reference: [10] <author> S. A. Cook. </author> <title> The complexity of theorem-proving procedures. </title> <booktitle> In Proceedings of the 3rd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year>
Reference-contexts: If L is a language in N P , then a zero-knowledge proof system for L would be constructed as follows: 1. Transform L to a SAT instance S via Cook's theorem <ref> [10] </ref>. 2. Transform S to a 3-SAT instance 3S via [10]. 3. Transform 3S to a graph 3-colorability instance G via [13]. 4. Prove, via GMW, that G is 3-colorable. The size of the SAT instance S depends on the time complexity of the NDTM for L. <p> If L is a language in N P , then a zero-knowledge proof system for L would be constructed as follows: 1. Transform L to a SAT instance S via Cook's theorem <ref> [10] </ref>. 2. Transform S to a 3-SAT instance 3S via [10]. 3. Transform 3S to a graph 3-colorability instance G via [13]. 4. Prove, via GMW, that G is 3-colorable. The size of the SAT instance S depends on the time complexity of the NDTM for L.
Reference: [11] <author> B. den Boer. </author> <title> An efficiency improvement to prove satisfiability with zero knowl-edge with public key. </title> <booktitle> In Advances in Cryptology proceedings of EUROCRYPT 89, Lecture Notes in Computer Science, </booktitle> <year> 1989. </year> <note> To appear. </note>
Reference-contexts: Note that our interactive arguments are obviously zero-knowledge if the blob implementation used has the forgeability property (see [3]). The following theorem shows that the forgeability property is not necessary. Theorem 1 Our interactive arguments are perfect zero-knowledge if Peggy and Vic 6 Independently of this work, den Boer <ref> [11] </ref> has also decreased the number of blobs necessary for validating the computation of binary boolean functions. use any implementation of blobs such as that in [3, 8], which leads to perfect zero--knowledge proofs in the original Brassard-Crepeau interactive arguments. proof : We will construct a simulator for these interactive arguments.
Reference: [12] <author> U. Feige, A. Fiat, and A. Shamir. </author> <title> Zero-knowledge proofs of identity. </title> <journal> Journal of Cryptology, </journal> <volume> 1(2) </volume> <pages> 77-94, </pages> <year> 1988. </year>
Reference-contexts: We will use the formalism developed in <ref> [12] </ref>, which we will call the "FFS model". In the FFS model the prover and verifier are BPP in power and have an input tape, a random tape, and a "knowledge" tape. <p> But what does it mean to "know" how to break a blob encryption scheme? As pointed out by <ref> [12] </ref>, the concept of Turing machine "knowledge" is a very subtle one. <p> Definition 7 We say that the prover "knows" how to break the blob encryption scheme E if it knows (in the sense of <ref> [12] </ref>) a satisfying assignment to the predicate E (0; x 1 ) = E (1; x 2 ) where the free variables are x 1 and x 2 . <p> the prover cheats, we need to assume that the encryption scheme is normal (see section 3, definition 6 ). 7 P (I; W ) should be thought of as a family of circuits indexed by I and with input a binary string W . 8 For a formal definition see <ref> [12] </ref>. Note that our interactive arguments are "restricted input", not "unrestricted input", zero-knowledge proofs of knowledge. Theorem 3 Suppose the circuit contains AND, OR, NOT, and MAJORITY gates. <p> This remains so even if gates have unbounded fan-in. proof : From the proof in <ref> [12] </ref> that every problem in NP has an interactive proof system of knowledge which is zero-knowledge, we see that to prove that our protocol is a proof of knowledge, we need only show that if an observer is able to see Peggy respond to receiving b = 0 and b =
Reference: [13] <author> M.R. Garey, D.S. Johnson, and L. Stockmeyer. </author> <title> Some simplified np-complete graph problems. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 237-267, </pages> <year> 1976. </year>
Reference-contexts: Transform L to a SAT instance S via Cook's theorem [10]. 2. Transform S to a 3-SAT instance 3S via [10]. 3. Transform 3S to a graph 3-colorability instance G via <ref> [13] </ref>. 4. Prove, via GMW, that G is 3-colorable. The size of the SAT instance S depends on the time complexity of the NDTM for L. Let us assume this time complexity to be linear in the size n of the problem instance.
Reference: [14] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> Proofs that yield nothing but their validity and a methodology of cryptographic protocol design. </title> <booktitle> In 27th. IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 174-187, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction From a practical point of view, the bottleneck in the zero-knowledge interactive proof systems and in the "interactive arguments" 1 which are produced by the techniques of <ref> [1, 5, 7, 14] </ref> is the amount of interaction necessary.
Reference: [15] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic encryption. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28 </volume> <pages> 270-299, </pages> <year> 1984. </year>
Reference-contexts: The techniques described in this paper can also be used in circuit-based proofs which are interactive proof systems according to the GMR [16] definition. If one substitutes probabilistic encryption with the quadratic residuosity assumption <ref> [15] </ref> for the BC-blobs, everything still works (except that of course the proofs will now be only computational, rather than almost perfect, zero-knowledge). At this conference, a paper by Kilian, Micali, and Ostrovsky [18] was presented which introduces a different technique for reducing the communication cost of zero-knowledge proofs.
Reference: [16] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The knowledge complexity of interactive proof-systems. </title> <journal> SIAM Journal of Computation, </journal> <volume> 18(1) </volume> <pages> 186-208, </pages> <year> 1989. </year>
Reference-contexts: Carsten Lund has shown that the resulting protocol is still a restricted input zero-knowledge proof of knowledge. The techniques described in this paper can also be used in circuit-based proofs which are interactive proof systems according to the GMR <ref> [16] </ref> definition. If one substitutes probabilistic encryption with the quadratic residuosity assumption [15] for the BC-blobs, everything still works (except that of course the proofs will now be only computational, rather than almost perfect, zero-knowledge).
Reference: [17] <author> R. Impagliazzo and M. Yung. </author> <title> Direct minimum-knowledge computations. </title> <booktitle> In Advances in Cryptology proceedings of CRYPTO 87, Lecture Notes in Computer Science, </booktitle> <pages> pages 40-51. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: We define "BC-blobs" by E (0; x) = x 2 (mod N ) and E (1; x) = ffx 2 (mod N ), for x 2 Z fl 3 Impagliazzo and Yung <ref> [17] </ref> also present a technique for giving direct proofs for the computation of a Turing machine. 4 In this paper, it will at times be convenient to think of the verifier as being named Vic, and the prover being named Peggy.
Reference: [18] <author> J. Kilian, S. Micali, and R. Ostrovsky. </author> <title> Efficient zero-knowledge proofs with bounded interaction. </title> <booktitle> In Advances in Cryptology proceedings of CRYPTO 89, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: If one substitutes probabilistic encryption with the quadratic residuosity assumption [15] for the BC-blobs, everything still works (except that of course the proofs will now be only computational, rather than almost perfect, zero-knowledge). At this conference, a paper by Kilian, Micali, and Ostrovsky <ref> [18] </ref> was presented which introduces a different technique for reducing the communication cost of zero-knowledge proofs. The techniques they use to reduce the number of envelopes necessary in "subset-revealing" protocols can easily be extended to protocols such as ours which also reveal the XOR of pairs of bits.
Reference: [19] <author> W. LeVeque. </author> <title> Fundamentals of Number Theory. </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: Using Theorem 6.15, page 145 of <ref> [19] </ref>, it is not hard to show that S (x) = (x) ln x 2 Thus S (x) &gt; f (x) where f (x) = :92x 1:11 2 ln t Notice that f 0 (x) = :92 1:11 ln 1 (x) x 1 .
Reference: [20] <author> N. Pippenger and M. Fischer. </author> <title> Relations among complexity measures. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 23 </volume> <pages> 361-381, </pages> <year> 1979. </year>
Reference: [21] <author> J. Rosser and L. Schoenfeld. </author> <title> Approximate formulas for some functions of prime numbers. </title> <journal> Illinois Journal of Mathematics, </journal> <volume> 6 </volume> <pages> 64-94, </pages> <year> 1962. </year>
Reference-contexts: (log 2 C)=(log 2 log 2 C) : 2 Corollary 3 If &lt; (1=2)log 2 log 2 C, then p m &lt; 2 log 2 C. proof : For p r &gt; 5 we have p r &lt; r log 2 r (this can be derived from theorem 3 of <ref> [21] </ref>).
References-found: 21

