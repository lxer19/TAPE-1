URL: http://www.cs.wustl.edu/~schmidt/europlop-96/papers/paper29.ps
Refering-URL: http://www.cs.wustl.edu/~schmidt/europlop-96/ww1-papers.html
Root-URL: 
Title: State Patterns  
Author: Paul Dyson and Bruce Anderson 
Note: Acknowledgement  
Abstract: As our understanding of how we build software grows, we document recurrent design decisions in the form of patterns. As our understanding of each pattern grows, we extend and refine these patterns so that the advice they give is more concrete and comprehensive. Here, we present seven patterns that refine and extend the State pattern found in the GOF [GHJ+94] book: the refinements are concrete advice for some of the decisions mentioned, but not dealt with in detail, in the original pattern; the extensions are new advice for making decisions that we have repeatedly had to make while implementing the State pattern. The splitting of the one large pattern into a pattern-language also makes it more accessible and easier to understand. Many thanks to Walter Zimmer who was the EuroPLoP shepherd for this paper and gave some excellent and concrete advice on how it might be improved. 
Abstract-found: 1
Intro-found: 1
Reference: [Bec95] <author> Kent Beck, </author> <title> Smalltalk Best Practice Patterns Volume 1: Coding (draft review copy), First Class Software Inc., </title> <year> 1995. </year>
Reference-contexts: If we took this approach, the checkOutBy: method would look like: checkOutBy: aUser Check self out to aUser (currentlyBorrowed = 1) ifTrue: [^self error: The book is currently out on loan.]. Check the book out There are two problems with this approach (as described in the Choosing Message pattern <ref> [Bec95] </ref>): 1. Adding new states that the LibraryBook may have requires more flags and more conditional tests. 2. This kind of logic will have to be repeated in other methods. This means that several methods have to be maintained. Encapsulate the state of the object in another, separate, object. <p> as a Template Method [GHJ+94] ensures that each new class must define what its Default State is, but doesnt dictate as to what that should be: LoanableItem&gt;&gt;initialize Some initialisation state := self defaultState LoanableItem&gt;&gt;defaultState ^self implementedBySubclass Book&gt;&gt;defaultState ^Available new VideoRecorder&gt;&gt;defaultState ^BeingMaintained new Default State is an example of Modifying Super <ref> [Bec95] </ref>.
Reference: [GHJ+94] <author> E. Gamma, R. Helm, R. Johnson and J. Vlissides, </author> <title> Design Patterns: Elements of Object Oriented Software, </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year> <note> Book defaultState VideoRecorder defaultState LoanableItem defaultState initialize A </note>
Reference-contexts: Introduction Here we present seven patterns that deal with the implementation of statedependant behaviour. The patterns are all extensions or refinements to the State pattern found in Patterns: Elements of Object-Oriented Software <ref> [GHJ+94] </ref> (referred to here as the Gang-of-Four - or GOF - book), with the first pattern State Object - representing what we see as the core of the GOF pattern: the delegation of state-dependant behaviour to an object which encapsulates state. This pattern is the central pattern to the language. <p> These dependencies are shown below with the single-headed arrows indicating preceding patterns and the double-headed arrow indicating two patterns in tension with each other: State Object represents the core of the State pattern as presented in the GOF <ref> [GHJ+94] </ref> book: the encapsulation of state as an object to which statedependant actions are delegated. The State Member pattern deals with whether data members should be placed in the owning object or in the State Object. This is an extension of the GOF State pattern. <p> number of LibraryBook objects can share a single Available object, LibraryBook checkOutBy: LibraryBookState checkOut:withReservations:by: A 1 Reservation n reservations they only need separate OnLoan objects because each OnLoan object records some statespecific data (on which LibraryUser is borrowing the book): A Pure State object is an example of a Flyweight <ref> [GHJ+94] </ref>, and is also often a Singleton [GHJ+94]. Exposed State You have a State Object encapsulated within an owning object. <p> single Available object, LibraryBook checkOutBy: LibraryBookState checkOut:withReservations:by: A 1 Reservation n reservations they only need separate OnLoan objects because each OnLoan object records some statespecific data (on which LibraryUser is borrowing the book): A Pure State object is an example of a Flyweight <ref> [GHJ+94] </ref>, and is also often a Singleton [GHJ+94]. Exposed State You have a State Object encapsulated within an owning object. How do you prevent the owning class having an excessive number of statespecific, statedependant methods? State Object is an implementation pattern - it describes how we might implement statespecific behaviour in a separate object. <p> Even if some of the State Objects are to be used across different FSMs, it may still be possible to use StateDriven Transitions by using a Template Method <ref> [GHJ+94] </ref> to avoid redundancies between different implementations of the State Objects. This should only be considered when there are only slight changes in transition or when there are only a few occurrences of reusing the State Objects. <p> This should only be considered when there are only slight changes in transition or when there are only a few occurrences of reusing the State Objects. The owning object in Owner-Driven Transitions is taking on the role of a Mediator <ref> [GHJ+94] </ref>. Default State You are creating a new object which is implemented with State Object. When creating a new owning object, how do I ensure that it has the correct initial State Object ? Creating a new instance of an owning object requires that its state is initialised. <p> The initial state for Book is Available but for VideoRecorder it is BeingMaintained (we can assume that new books are okay, but we have to check that new video recorders work okay). Having the initialize method as a Template Method <ref> [GHJ+94] </ref> ensures that each new class must define what its Default State is, but doesnt dictate as to what that should be: LoanableItem&gt;&gt;initialize Some initialisation state := self defaultState LoanableItem&gt;&gt;defaultState ^self implementedBySubclass Book&gt;&gt;defaultState ^Available new VideoRecorder&gt;&gt;defaultState ^BeingMaintained new Default State is an example of Modifying Super [Bec95].
References-found: 2

