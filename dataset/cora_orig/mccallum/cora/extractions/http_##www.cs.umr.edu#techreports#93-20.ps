URL: http://www.cs.umr.edu/techreports/93-20.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Title: ENSURING THE SATISFACTION OF A TEMPORAL SPECIFICATION AT RUN-TIME 1  
Author: Grace Tsai, Matt Insall and Bruce McMillin Grace Tsai and Bruce McMillin 
Address: MO 65401.  Rolla, MO 65401.  
Affiliation: Department of Mathematics and Statistics at the University of Missouri-Rolla, Rolla,  Department of Computer Science at the University of Missouri-Rolla,  
Note: 1 This work was supported by UM research board, the National Science Foundation under Grant Numbers MSS-9216479 and CDA-9222827, and from the Air Force Office of Scientific Research under contract number F49620-92-J-0546. 2 Matt Insall is with the  are with the  
Date: August 1, 1993  
Pubnum: CSC-93-020  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. E. Chodrow, F. Jahanian, and M. Donner, </author> <title> Run-time monitoring of real-time systems, </title> <booktitle> in IEEE Symposium on Real-Time Systems, </booktitle> <pages> pp. 74-83, </pages> <year> 1991. </year>
Reference-contexts: If the history does not satisfy the assertion (specification), then we have detected a violation of a program's specification. Otherwise, we say that the specification is satisfied at run-time. Other work has used embedded assertions to examine system behavior. For example, <ref> [1] </ref> embeds system constraints into programs and examines them at run-time. <p> Example 4. In Figure 2, the initial clock values of processes P 1 ; P 2 ; andP 3 are [0; 0; 0]. When process P 2 sends e 2;1 to process P 1 , P 2 changes its clock value to <ref> [0; 1; 0] </ref> (by Operation 1). Then, e 2;1 is timestamped with [0; 1; 0]. Upon receiving this message, P 1 changes its clock 6 value to [1; 1; 0] (by Operation 2). <p> When process P 2 sends e 2;1 to process P 1 , P 2 changes its clock value to <ref> [0; 1; 0] </ref> (by Operation 1). Then, e 2;1 is timestamped with [0; 1; 0]. Upon receiving this message, P 1 changes its clock 6 value to [1; 1; 0] (by Operation 2). <p> When process P 2 sends e 2;1 to process P 1 , P 2 changes its clock value to [0; 1; 0] (by Operation 1). Then, e 2;1 is timestamped with [0; 1; 0]. Upon receiving this message, P 1 changes its clock 6 value to <ref> [1; 1; 0] </ref> (by Operation 2). Likewise, we can obtain the timestamps of e 2;2 ; e 3;1 ; e 1;2 and e 3;2 , as shown in Figure 2.2 The following definition describes the mechanism of deciding causality of any two timestamped events. <p> Example 5. In Figure 4, processor P 1 sends the values of x to processor P 2 , at times [5; 0] and [9; 0], by executing events e 1;1 and e 1;2 . e 1;1 = ((P 1 ; x = 1; <ref> [1; 0] </ref>); (P 1 ; P 2 ; send; [5; 0])) e 1;2 = ((P 1 ; x = 5; [7; 0]); (P 1 ; P 2 ; send; [9; 0])) Events e 1;1 shows that at time [1; 0] the value of x is 1 in processor P 1 , <p> e 1;2 . e 1;1 = ((P 1 ; x = 1; <ref> [1; 0] </ref>); (P 1 ; P 2 ; send; [5; 0])) e 1;2 = ((P 1 ; x = 5; [7; 0]); (P 1 ; P 2 ; send; [9; 0])) Events e 1;1 shows that at time [1; 0] the value of x is 1 in processor P 1 , and P 1 sent a message to P 2 at time [5; 0]. <p> For example, before communication m 1 occurs, the histories of processors P 1 and P 2 only contain events executed by themselves. V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; <ref> [1; 0; 0] </ref>); (P 1 ; P 2 ; receive; [5; 9; 0])) &gt; V h 2 =&lt; J; e 2;1 = ((P 2 ; y = 2; [0; 3; 0]); (P 2 ; P 1 ; send; [0; 9; 0])) &gt; During the communication m 1 , processors P 1 <p> The histories of processors P 1 and P 3 before the exchange are as follows. V h 1 =&lt; J; e 1;1 &gt; V h 3 =&lt; J; e 3;1 &gt; where e 1;1 = (P 1 ; P 3 ; send; <ref> [1; 0; 0] </ref>) e 3;1 = ((P 3 ; z = 2; [0; 0; 7]); (P 3 ; P 1 ; receive; [1; 0; 7])) 14 15 The histories of processors P 1 and P 3 after the exchange are as follows. <p> V h 1 =&lt; J; e 1;1 &gt; V h 3 =&lt; J; e 3;1 &gt; where e 1;1 = (P 1 ; P 3 ; send; [1; 0; 0]) e 3;1 = ((P 3 ; z = 2; [0; 0; 7]); (P 3 ; P 1 ; receive; <ref> [1; 0; 7] </ref>)) 14 15 The histories of processors P 1 and P 3 after the exchange are as follows. V h 1 =&lt; J; e 1;1 ; e 3;1 &gt; Next, communication m 2 occurs, and processors P 2 and P 3 exchange their histories. <p> The following are the histories of processors P 2 and P 3 before the exchange. V h 2 =&lt; J; e 2;1 &gt; V h 3 =&lt; J; e 1;1 ; e 3;1 ; e 3;2 &gt; where e 2;1 = (P 2 ; P 3 ; receive; <ref> [1; 5; 9] </ref>) e 3;2 = (P 3 ; P 2 ; send; [1; 0; 9]) Thus, after the exchange and the incorporation of received histories, the histories of processors P 2 and P 3 are now as follows. <p> V h 2 =&lt; J; e 2;1 &gt; V h 3 =&lt; J; e 1;1 ; e 3;1 ; e 3;2 &gt; where e 2;1 = (P 2 ; P 3 ; receive; [1; 5; 9]) e 3;2 = (P 3 ; P 2 ; send; <ref> [1; 0; 9] </ref>) Thus, after the exchange and the incorporation of received histories, the histories of processors P 2 and P 3 are now as follows. <p> Thus, the history V h 2 to be sent to processor P 1 contains event e 3;1 as follows. e 3;1 = ((P 3 ; z = 0; [0; 0; 7]); (P 3 ; P 1 ; receive; <ref> [1; 0; 7] </ref>)) Before processor P 1 incorporates history V h 2 into its own history, P 1 applies a consistency check to histories V h 1 and V h 2 and detects an inconsistency of z 0 s value.2 16 A run-time history V h i of processor P i <p> The new histories are as follows. V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; <ref> [1; 0] </ref>); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; <p> The new histories are as follows. V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; <ref> [0; 1] </ref>); (P 2 ; P 1 ; receive; [2; 1])) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; <p> The new histories are as follows. V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; <ref> [2; 1] </ref>)) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; Recall that <p> ; x = 1; <ref> [1; 0] </ref>); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; Recall that by Definition 4.4 processors incorporate events into their histories, such that for any event e, e does <p> ; y = 1; <ref> [0; 1] </ref>); (P 2 ; P 1 ; receive; [2; 1])) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; Recall that by Definition 4.4 processors incorporate events into their histories, such that for any event e, e does not cause any event preceding e, and e causes the next event. <p> P 1 ; receive; <ref> [2; 1] </ref>)) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; Recall that by Definition 4.4 processors incorporate events into their histories, such that for any event e, e does not cause any event preceding e, and e causes the next event. Therefore, histories of the communicating processors after the incorporation of a received history are the same. <p> After communications m 2 and m 3 , the histories V h 1 and V h 2 are as follows. V h 1 = V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; <ref> [1; 0] </ref>); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = <p> V h 1 = V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; <ref> [0; 1] </ref>); (P 2 ; P 1 ; receive; [2; 1])); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = <p> V h 1 = V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; <ref> [2; 1] </ref>)); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; <p> e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; <ref> [2; 1] </ref>)); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7;
Reference: [2] <author> S. Alagar and S. Venkatesan, </author> <title> Hierarchy in testing distributed programs, </title> <note> in Computer Science Technical Report UTDCS-8-92, </note> <institution> The University of Texas at Dallas, </institution> <year> 1992. </year>
Reference-contexts: The new histories are as follows. V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; <ref> [2; 0] </ref>)); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = <p> The new histories are as follows. V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; <ref> [2; 1] </ref>)) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; Recall that <p> P 2 ; send; <ref> [2; 0] </ref>)); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; Recall that by Definition 4.4 processors incorporate events into their histories, such that for any event e, e does not cause any event preceding e, and e causes <p> P 1 ; receive; <ref> [2; 1] </ref>)) &gt; V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])) &gt; Recall that by Definition 4.4 processors incorporate events into their histories, such that for any event e, e does not cause any event preceding e, and e causes the next event. Therefore, histories of the communicating processors after the incorporation of a received history are the same. <p> After communications m 2 and m 3 , the histories V h 1 and V h 2 are as follows. V h 1 = V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; <ref> [2; 0] </ref>)); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; <p> V h 1 = V h 2 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; <ref> [2; 1] </ref>)); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; <p> e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; <ref> [2; 1] </ref>)); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; <p> e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; <ref> [4; 2] </ref>)); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; [4; 3]); (P 1 ; P 2 ; receive; [4; 4])) &gt; Now, processor P 2 does an operational evaluation <p> (P 2 ; P 1 ; receive; [2; 1])); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; <ref> [2; 3] </ref>); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; [4; 3]); (P 1 ; P 2 ; receive; [4; 4])) &gt; Now, processor P 2 does an operational evaluation on the assertion (x = 1) ! EF (x = 7) <p> e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; <ref> [2; 4] </ref>)); e 1;3 = ((P 1 ; x = 7; [4; 3]); (P 1 ; P 2 ; receive; [4; 4])) &gt; Now, processor P 2 does an operational evaluation on the assertion (x = 1) ! EF (x = 7) as follows. <p> This can be done by utilizing consistent cuts ([13], <ref> [2] </ref>, [12]). Definition 6.4 Two events e i;k and e j;l are independent (concurrent), if their respective times-tamps C i k and C l satisfy conditions, C i k [i] C l [i] and C l [j] C i k [j].
Reference: [3] <author> D. S. Rosenblum, </author> <title> Towards a method of programming with assertions, </title> <booktitle> in Proceeding of the Fourteenth International Conference of Software Engineering, </booktitle> <pages> pp. 92-104, </pages> <year> 1992. </year>
Reference-contexts: Other work has used embedded assertions to examine system behavior. For example, [1] embeds system constraints into programs and examines them at run-time. However, they use a centralized monitor to obtain an execution history, while we collect event history without using monitors. ([2], <ref> [3] </ref>, and [4]) use assertions as a tool for run-time detection of software faults during debugging and testing, while we use assertions to detect a violation of a program's specification and to ensure satisfaction of a program's specification. <p> V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0; 0]); (P 1 ; P 2 ; receive; [5; 9; 0])) &gt; V h 2 =&lt; J; e 2;1 = ((P 2 ; y = 2; <ref> [0; 3; 0] </ref>); (P 2 ; P 1 ; send; [0; 9; 0])) &gt; During the communication m 1 , processors P 1 and P 2 exchange their histories. Then, they apply function h to incorporate received histories into their own histories. <p> V h 2 = &lt; J; e 1;1 ; e 2;1 ; e 2;2 &gt;; V h 3 = &lt; J; e 3;1 &gt;; where e 2;2 = ((P 2 ; y = 2; <ref> [0; 3; 0] </ref>); (P 2 ; P 1 ; send; [0; 9; 0])) e 3;1 = ((P 3 ; z = 2; [0; 0; 7]); (P 3 ; P 2 ; receive; [0; 11; 20])): At this point of time, processor P 2 has knowledge of events executed by processor P <p> (P 1 ; P 2 ; send; [2; 0])); e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; <ref> [3; 0] </ref>); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; [4; 3]); (P 1 ; P 2 ; receive; [4; 4])) <p> (P 2 ; P 1 ; receive; [2; 1])); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; <ref> [2; 3] </ref>); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; [4; 3]); (P 1 ; P 2 ; receive; [4; 4])) &gt; Now, processor P 2 does an operational evaluation on the assertion (x = 1) ! EF (x = 7) <p> 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; <ref> [4; 3] </ref>); (P 1 ; P 2 ; receive; [4; 4])) &gt; Now, processor P 2 does an operational evaluation on the assertion (x = 1) ! EF (x = 7) as follows.
Reference: [4] <author> S. Venkatesan and B. Dathan, </author> <title> Testing and debugging distributed programs using global predicates, </title> <booktitle> in The Thirtieth Annual Allerton Conference on Communication, Control, and Computing, </booktitle> <year> 1992. </year>
Reference-contexts: Other work has used embedded assertions to examine system behavior. For example, [1] embeds system constraints into programs and examines them at run-time. However, they use a centralized monitor to obtain an execution history, while we collect event history without using monitors. ([2], [3], and <ref> [4] </ref>) use assertions as a tool for run-time detection of software faults during debugging and testing, while we use assertions to detect a violation of a program's specification and to ensure satisfaction of a program's specification. <p> e 2;1 = ((P 2 ; y = 1; [0; 1]); (P 2 ; P 1 ; receive; [2; 1])); e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; <ref> [4; 2] </ref>)); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; [4; 3]); (P 1 ; P 2 ; receive; [4; 4])) &gt; Now, processor P 2 does an operational evaluation <p> e 2;2 = (P 2 ; P 1 ; send; [2; 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; <ref> [2; 4] </ref>)); e 1;3 = ((P 1 ; x = 7; [4; 3]); (P 1 ; P 2 ; receive; [4; 4])) &gt; Now, processor P 2 does an operational evaluation on the assertion (x = 1) ! EF (x = 7) as follows. <p> 1]); e 1;2 = ((P 1 ; x = 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; <ref> [4; 3] </ref>); (P 1 ; P 2 ; receive; [4; 4])) &gt; Now, processor P 2 does an operational evaluation on the assertion (x = 1) ! EF (x = 7) as follows. <p> 5; [3; 0]); (P 1 ; P 2 ; receive; [4; 2])); e 2;3 = ((P 2 ; y = 3; [2; 3]); (P 2 ; P 1 ; send; [2; 4])); e 1;3 = ((P 1 ; x = 7; [4; 3]); (P 1 ; P 2 ; receive; <ref> [4; 4] </ref>)) &gt; Now, processor P 2 does an operational evaluation on the assertion (x = 1) ! EF (x = 7) as follows.
Reference: [5] <author> H. Lutfiyya and B. McMillin, </author> <title> Formal generation of executable assertions for a fault-tolerant parallel matrix relaxation, </title> <institution> UMR Department of Computer Science Technical Report Number CSC 91-13, </institution> <year> 1991. </year>
Reference-contexts: Example 5. In Figure 4, processor P 1 sends the values of x to processor P 2 , at times <ref> [5; 0] </ref> and [9; 0], by executing events e 1;1 and e 1;2 . e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [5; 0])) e 1;2 = ((P 1 ; x = 5; [7; 0]); (P 1 ; P 2 ; <p> In Figure 4, processor P 1 sends the values of x to processor P 2 , at times <ref> [5; 0] </ref> and [9; 0], by executing events e 1;1 and e 1;2 . e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [5; 0])) e 1;2 = ((P 1 ; x = 5; [7; 0]); (P 1 ; P 2 ; send; [9; 0])) Events e 1;1 shows that at time [1; 0] the value of x is 1 in processor P 1 , and P 1 sent a message to P 2 <p> 1;2 = ((P 1 ; x = 5; [7; 0]); (P 1 ; P 2 ; send; [9; 0])) Events e 1;1 shows that at time [1; 0] the value of x is 1 in processor P 1 , and P 1 sent a message to P 2 at time <ref> [5; 0] </ref>. Likewise, events e 1;2 shows that at time [7; 0] the value of x is 5 in processor P 1 , and P 1 sent a message to P 2 at time [9; 0]. <p> For example, before communication m 1 occurs, the histories of processors P 1 and P 2 only contain events executed by themselves. V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0; 0]); (P 1 ; P 2 ; receive; <ref> [5; 9; 0] </ref>)) &gt; V h 2 =&lt; J; e 2;1 = ((P 2 ; y = 2; [0; 3; 0]); (P 2 ; P 1 ; send; [0; 9; 0])) &gt; During the communication m 1 , processors P 1 and P 2 exchange their histories. <p> The following are the histories of processors P 2 and P 3 before the exchange. V h 2 =&lt; J; e 2;1 &gt; V h 3 =&lt; J; e 1;1 ; e 3;1 ; e 3;2 &gt; where e 2;1 = (P 2 ; P 3 ; receive; <ref> [1; 5; 9] </ref>) e 3;2 = (P 3 ; P 2 ; send; [1; 0; 9]) Thus, after the exchange and the incorporation of received histories, the histories of processors P 2 and P 3 are now as follows. <p> V h 1 =&lt; J; e 1;1 ; e 3;1 ; e 1;2 &gt; V h 2 =&lt; J; e 1;1 ; e 3;1 ; e 3;2 ; e 2;1 ; e 2;2 &gt; where e 2;2 = (P 2 ; P 1 ; receive; <ref> [9; 5; 9] </ref>) e 1;2 = (P 1 ; P 2 ; send; [9; 0; 0]) Since processor P 2 is faulty, it sends an incorrect value (z = 0) to processor P 1 .
Reference: [6] <author> H. Lutfiyya, A. Sun, and B. McMillin, </author> <title> A fault tolerant branch and bound algorithm derived from program verification, </title> <booktitle> in IEEE Computers Software and Applications Conference(COMPSAC), </booktitle> <pages> pp. 182-187, </pages> <year> 1992. </year>
Reference-contexts: Our work of Changeling ([5], <ref> [6] </ref>, and [7]) embeds safety assertions to detect errors in the presence of failures. This paper focuses on building a framework of operational evaluation of a temporal assertion (specification).
Reference: [7] <author> H. Lutfiyya, M. Schollmeyer, and B. McMillin, </author> <title> Formal generation of executable assertions for application-oriented fault tolerance, </title> <institution> UMR Department of Computer Science Technical Report Number CSC 92-15, </institution> <year> 1992. </year>
Reference-contexts: Our work of Changeling ([5], [6], and <ref> [7] </ref>) embeds safety assertions to detect errors in the presence of failures. This paper focuses on building a framework of operational evaluation of a temporal assertion (specification). <p> Thus, the history V h k is correct with respect to the history h. 2 8 4.2 Computing Histories in a Non-Faulty Environment In this section, we present an algorithm, which allows distributed processors to obtain their histories (views) about system execution in a non-faulty environment <ref> [7] </ref>. These histories will be utilized to detect a violation of processors' run-time behaviors. Main idea. Every process relies on communications to find out events that have occurred in other processes, and to collect these events into its history. <p> to processor P 2 , at times [5; 0] and [9; 0], by executing events e 1;1 and e 1;2 . e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [5; 0])) e 1;2 = ((P 1 ; x = 5; <ref> [7; 0] </ref>); (P 1 ; P 2 ; send; [9; 0])) Events e 1;1 shows that at time [1; 0] the value of x is 1 in processor P 1 , and P 1 sent a message to P 2 at time [5; 0]. <p> Likewise, events e 1;2 shows that at time <ref> [7; 0] </ref> the value of x is 5 in processor P 1 , and P 1 sent a message to P 2 at time [9; 0]. <p> e 1;1 ; e 2;1 ; e 2;2 &gt;; V h 3 = &lt; J; e 3;1 &gt;; where e 2;2 = ((P 2 ; y = 2; [0; 3; 0]); (P 2 ; P 1 ; send; [0; 9; 0])) e 3;1 = ((P 3 ; z = 2; <ref> [0; 0; 7] </ref>); (P 3 ; P 2 ; receive; [0; 11; 20])): At this point of time, processor P 2 has knowledge of events executed by processor P 1 from communication m 1 . During communication m 2 , processors P 2 and P 3 exchanges their histories. <p> V h 1 =&lt; J; e 1;1 &gt; V h 3 =&lt; J; e 3;1 &gt; where e 1;1 = (P 1 ; P 3 ; send; [1; 0; 0]) e 3;1 = ((P 3 ; z = 2; <ref> [0; 0; 7] </ref>); (P 3 ; P 1 ; receive; [1; 0; 7])) 14 15 The histories of processors P 1 and P 3 after the exchange are as follows. <p> V h 1 =&lt; J; e 1;1 &gt; V h 3 =&lt; J; e 3;1 &gt; where e 1;1 = (P 1 ; P 3 ; send; [1; 0; 0]) e 3;1 = ((P 3 ; z = 2; [0; 0; 7]); (P 3 ; P 1 ; receive; <ref> [1; 0; 7] </ref>)) 14 15 The histories of processors P 1 and P 3 after the exchange are as follows. V h 1 =&lt; J; e 1;1 ; e 3;1 &gt; Next, communication m 2 occurs, and processors P 2 and P 3 exchange their histories. <p> Thus, the history V h 2 to be sent to processor P 1 contains event e 3;1 as follows. e 3;1 = ((P 3 ; z = 0; <ref> [0; 0; 7] </ref>); (P 3 ; P 1 ; receive; [1; 0; 7])) Before processor P 1 incorporates history V h 2 into its own history, P 1 applies a consistency check to histories V h 1 and V h 2 and detects an inconsistency of z 0 s value.2 16 <p> Thus, the history V h 2 to be sent to processor P 1 contains event e 3;1 as follows. e 3;1 = ((P 3 ; z = 0; [0; 0; 7]); (P 3 ; P 1 ; receive; <ref> [1; 0; 7] </ref>)) Before processor P 1 incorporates history V h 2 into its own history, P 1 applies a consistency check to histories V h 1 and V h 2 and detects an inconsistency of z 0 s value.2 16 A run-time history V h i of processor P i
Reference: [8] <author> G. Tsai, M. Insall, and B. McMillin, </author> <title> Ensuring value liveness of distributed software through changeling, </title> <institution> UMR Department of Computer Science Technical Report Number CSC 93-03, </institution> <year> 1993. </year>
Reference-contexts: Our work of Changeling ([5], [6], and [7]) embeds safety assertions to detect errors in the presence of failures. This paper focuses on building a framework of operational evaluation of a temporal assertion (specification). In particular, we consider liveness assertions <ref> [8] </ref>, which are obtained from the reasoning of communications, using the temporal proof system of Interleaving Set Temporal Logic [9].
Reference: [9] <author> D. Peled and A. Pnueli, </author> <title> Proving partial order liveness properties, </title> <booktitle> 17th Colloquium on Automata, Language and Programming, </booktitle> <pages> pp. 553-571, </pages> <year> 1990. </year>
Reference-contexts: This paper focuses on building a framework of operational evaluation of a temporal assertion (specification). In particular, we consider liveness assertions [8], which are obtained from the reasoning of communications, using the temporal proof system of Interleaving Set Temporal Logic <ref> [9] </ref>. A liveness assertion (denoting a program's specification) is satisfied at run-time only if the operational evaluation of the assertion is true or the collected event history does not violate the assertion. This is the concept of operational evaluation of a temporal assertion. <p> In other words, v i and v i+1 only differ by the order of adjacent symbols which are independent according to the causal relation ! of Definition 2.2 <ref> [9] </ref>. Example 1. Let an alphabet A be fa; b; cg, where events a and c are causally related, and (a and b) or (b and c) are not causally related. <p> Definition 2.6 A trace is an equivalence class of histories, denoted by [J; w] where J is an initial state and &lt; J; w &gt; is some member of the equivalence class [J; w] <ref> [9] </ref>. Definition 2.7 Let a set V h k be a processor P 0 k s collection of values including processor P 0 k s (local) values, and those it observes (processor P x communicates with processor P k about its local values). <p> Example 5. In Figure 4, processor P 1 sends the values of x to processor P 2 , at times [5; 0] and <ref> [9; 0] </ref>, by executing events e 1;1 and e 1;2 . e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [5; 0])) e 1;2 = ((P 1 ; x = 5; [7; 0]); (P 1 ; P 2 ; send; [9; 0])) <p> and <ref> [9; 0] </ref>, by executing events e 1;1 and e 1;2 . e 1;1 = ((P 1 ; x = 1; [1; 0]); (P 1 ; P 2 ; send; [5; 0])) e 1;2 = ((P 1 ; x = 5; [7; 0]); (P 1 ; P 2 ; send; [9; 0])) Events e 1;1 shows that at time [1; 0] the value of x is 1 in processor P 1 , and P 1 sent a message to P 2 at time [5; 0]. <p> Likewise, events e 1;2 shows that at time [7; 0] the value of x is 5 in processor P 1 , and P 1 sent a message to P 2 at time <ref> [9; 0] </ref>. Then, how does processor P 2 incorporate the received events into its history V h 2 ? The following describes an incorporation of a received event into a history. <p> For example, before communication m 1 occurs, the histories of processors P 1 and P 2 only contain events executed by themselves. V h 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0; 0]); (P 1 ; P 2 ; receive; <ref> [5; 9; 0] </ref>)) &gt; V h 2 =&lt; J; e 2;1 = ((P 2 ; y = 2; [0; 3; 0]); (P 2 ; P 1 ; send; [0; 9; 0])) &gt; During the communication m 1 , processors P 1 and P 2 exchange their histories. <p> 1 =&lt; J; e 1;1 = ((P 1 ; x = 1; [1; 0; 0]); (P 1 ; P 2 ; receive; [5; 9; 0])) &gt; V h 2 =&lt; J; e 2;1 = ((P 2 ; y = 2; [0; 3; 0]); (P 2 ; P 1 ; send; <ref> [0; 9; 0] </ref>)) &gt; During the communication m 1 , processors P 1 and P 2 exchange their histories. Then, they apply function h to incorporate received histories into their own histories. The new histories V h 1 and V h 2 are as follows. <p> V h 2 = &lt; J; e 1;1 ; e 2;1 ; e 2;2 &gt;; V h 3 = &lt; J; e 3;1 &gt;; where e 2;2 = ((P 2 ; y = 2; [0; 3; 0]); (P 2 ; P 1 ; send; <ref> [0; 9; 0] </ref>)) e 3;1 = ((P 3 ; z = 2; [0; 0; 7]); (P 3 ; P 2 ; receive; [0; 11; 20])): At this point of time, processor P 2 has knowledge of events executed by processor P 1 from communication m 1 . <p> The following are the histories of processors P 2 and P 3 before the exchange. V h 2 =&lt; J; e 2;1 &gt; V h 3 =&lt; J; e 1;1 ; e 3;1 ; e 3;2 &gt; where e 2;1 = (P 2 ; P 3 ; receive; <ref> [1; 5; 9] </ref>) e 3;2 = (P 3 ; P 2 ; send; [1; 0; 9]) Thus, after the exchange and the incorporation of received histories, the histories of processors P 2 and P 3 are now as follows. <p> V h 2 =&lt; J; e 2;1 &gt; V h 3 =&lt; J; e 1;1 ; e 3;1 ; e 3;2 &gt; where e 2;1 = (P 2 ; P 3 ; receive; [1; 5; 9]) e 3;2 = (P 3 ; P 2 ; send; <ref> [1; 0; 9] </ref>) Thus, after the exchange and the incorporation of received histories, the histories of processors P 2 and P 3 are now as follows. <p> V h 1 =&lt; J; e 1;1 ; e 3;1 ; e 1;2 &gt; V h 2 =&lt; J; e 1;1 ; e 3;1 ; e 3;2 ; e 2;1 ; e 2;2 &gt; where e 2;2 = (P 2 ; P 1 ; receive; <ref> [9; 5; 9] </ref>) e 1;2 = (P 1 ; P 2 ; send; [9; 0; 0]) Since processor P 2 is faulty, it sends an incorrect value (z = 0) to processor P 1 . <p> e 3;1 ; e 1;2 &gt; V h 2 =&lt; J; e 1;1 ; e 3;1 ; e 3;2 ; e 2;1 ; e 2;2 &gt; where e 2;2 = (P 2 ; P 1 ; receive; [9; 5; 9]) e 1;2 = (P 1 ; P 2 ; send; <ref> [9; 0; 0] </ref>) Since processor P 2 is faulty, it sends an incorrect value (z = 0) to processor P 1 . <p> Thus, a 4 The liveness assertions are of the form ( ! EF ) where the symbol EF denotes eventuality. They can be obtained from the reasoning of communications using the temporal proof system of Interleaving Set Temporal Logic <ref> [9] </ref>. 19 send/receive event is an action (or a sequence of actions) that changes the state of a processor. Also, the liveness assertions of interest are derived from communication points (observable events). Therefore, we consider a send/receive event as an intermediate state.
Reference: [10] <author> L. Lamport, </author> <title> Time, clocks and the ordering of events in a distributed system, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 7, </volume> <pages> pp. 558-565, </pages> <year> 1978. </year>
Reference-contexts: Definition 2.2 Event e precedes event f in an execution, i.e., e ! f , iff any one of the following conditions holds <ref> [10] </ref>: 1. e and f are events of the same process, and e occurs before f , 2. e is a send event, and f is the corresponding receive event, or 3. there exists event g, such that e ! g, and g ! f .
Reference: [11] <author> J. Fidge, </author> <title> Timestamps in message passing systems that preserve the partial ordering, </title> <booktitle> in Proceeding of the Tenth International Conference of Software Engineering, </booktitle> <pages> pp. 182-187, </pages> <year> 1992. </year>
Reference-contexts: h 3 = &lt; J; e 3;1 &gt;; where e 2;2 = ((P 2 ; y = 2; [0; 3; 0]); (P 2 ; P 1 ; send; [0; 9; 0])) e 3;1 = ((P 3 ; z = 2; [0; 0; 7]); (P 3 ; P 2 ; receive; <ref> [0; 11; 20] </ref>)): At this point of time, processor P 2 has knowledge of events executed by processor P 1 from communication m 1 . During communication m 2 , processors P 2 and P 3 exchanges their histories.
Reference: [12] <author> F. Mattern, </author> <title> Virtual time and global states of distributed systems, </title> <booktitle> in Parallel and Distributed Algorithms: Proceedings of the International Workshops on Parallel and Distributed Algorithms, </booktitle> <pages> pp. 215-226, </pages> <publisher> Ed. Elsevier Science Publishers B.V., </publisher> <year> 1989. </year>
Reference-contexts: Moreover, the time-stamping scheme should not impose any arbitrary ordering on any two events which are not originally causally related. Thus, vector clocks ([11], <ref> [12] </ref>) are utilized to determine causality between any two events. Vector Clock Scheme Let C i be the vector clock of process P i , and let C i k denote the clock value after the execution of event e i;k . <p> This can be done by utilizing consistent cuts ([13], [2], <ref> [12] </ref>). Definition 6.4 Two events e i;k and e j;l are independent (concurrent), if their respective times-tamps C i k and C l satisfy conditions, C i k [i] C l [i] and C l [j] C i k [j].
Reference: [13] <author> L. Lamport, </author> <title> Paradigms for distributed programs: Computing global states, in Distributed Systems-Methods and Tools for Specification, </title> <booktitle> Lecture Notes in Computer Science 190 (M. </booktitle> <editor> Paul and H. Siegert, </editor> <booktitle> eds.), </booktitle> <pages> pp. 454-468, </pages> <year> 1985. </year> <month> 26 </month>
References-found: 13

