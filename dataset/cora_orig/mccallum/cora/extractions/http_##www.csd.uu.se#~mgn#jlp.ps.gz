URL: http://www.csd.uu.se/~mgn/jlp.ps.gz
Refering-URL: http://www.csd.uu.se/~mgn/
Root-URL: 
Title: Generating lattice code for Prolog analyzers  
Author: Magnus Nordin Thomas Lindgren H-akan Millroth 
Keyword: automatic code generation, lattices, abstract domains, program analysis, logic programming  
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department, Uppsala University  
Email: e-mail: fmgn,thomasl,hakanmg@csd.uu.se  
Phone: Phone: +46 18 182500 Fax: +46 18 511925  
Date: February 27, 1996  
Abstract: Igor is a tool that supports high-level specifications of abstract domains for static analysis of Prolog. Specifications are compiled to Prolog code and interfaced with an fixpoint engine to make up a complete analyzer. The specifications supported by Igor are close to an order of magnitude less voluminous than the corresponding Prolog code. The execution speed of compiled specifications is comparable to that of hand-written analyzers.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Alt & F. Martin, </author> <title> Generation of efficient interprocedural analyzers with PAG, Static Analysis Symp. 95, </title> <publisher> Springer LNCS 983, </publisher> <year> 1995. </year>
Reference-contexts: Our system extends the capabilities of Z1 with disjunctive and structure-based domains and more flexible projection operations. Igor is furthermore substantially faster. We do not, however, include the fixpoint engine in the specifications as Z1 does. PAG <ref> [1] </ref> is another tool for generating data flow analyzers.
Reference: [2] <author> T. Armstrong, K. Marriott, P. Schacte & H. Sondergaard, </author> <title> Boolean functions for dependency analysis: Algebraic properties and efficient representation, Static Analysis Symp. 94, </title> <publisher> Springer LNCS, </publisher> <year> 1994. </year>
Reference-contexts: The support language should also be extended to cope with graph elements in an elegant way. One possible language extension facilitating this is graph explorations [10], a language construct similar to set expressions and list comprehensions, but intended to express graph algorithms. Definite boolean functions <ref> [2] </ref> is another representation used by abstract domain designers that need a lattice type and some basic support in the language to be easily used in Igor specifications. Figure 4 gives an idea of the structure of a more complete taxonomy of lattices.
Reference: [3] <author> J. Bevemyr, T. Lindgren & H. Millroth, </author> <title> Exploiting recursion-parallelism in Prolog, </title> <booktitle> Intl. Conf. </booktitle> <editor> PARLE-93 (eds. A. Bode, M. Reeve & G. Wolf), </editor> <publisher> Springer LNCS 694, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Comparisons of hand-coded with auto-generated domains were performed as follows. The hand-coded freeness, sharing, and linearity analysis (called shfrson) of &-Prolog [14] was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog <ref> [3, 17] </ref> was compared with Dep. The compared domains are not identical but similar enough to serve for our very approximate comparisons. Only the execution time for analysis is included in the measurements. Program loading, code preparation, presentation of the results and similar phases are left out.
Reference: [4] <author> M. Carlsson, J. Widen, J. Andersson, S. Andersson, K. Boortz, H. Nilsson, T. Sjoland, </author> <title> SICStus Prolog User's Manual, </title> <institution> Swedish Institute of Computer Science, </institution> <year> 1993. </year>
Reference-contexts: However, using anything but a closure operation would probably be pointless. 4 Evaluation All measurements were made on a Sun 630 MP with a 55 Mhz processor and 128 Mb of memory. The time unit is seconds. SICStus Prolog <ref> [4] </ref> version 2.1.9, with the fastcode option on, was used.
Reference: [5] <author> M. Codish, A. Mulkers, M. Bruynooghe, M. Garca de la Banda & M. Hermenegildo, </author> <title> Improving abstract interpretations by combining domains, </title> <booktitle> Proc. Symp. Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <institution> PEPM'91, Yale University, </institution> <address> Connecticut, </address> <year> 1991. </year>
Reference: [6] <author> A. Cortesi, B. Le Charlier & P. van Hentenryck, </author> <title> Conceptual and software support for abstract domain design: Generic structural domain and open product, </title> <booktitle> Proc. Symp. Principles of Programming Languages, </booktitle> <address> POPL'94, </address> <year> 1994. </year>
Reference-contexts: The specifications are interpreted rather than compiled. Tjiang [21] describes a tool that greatly simplifies the implementation of opti-mizers by using high-level specifications to combine several simpler optimization specifications. This tool works with flow-graphs and is aimed at imperative rather than declarative languages. Cortesi et al <ref> [6] </ref> propose two kinds of support for domain construction. Generic pattern domains provides software support for upgrading simpler domains to include structural information. This upgrade results in more accurate domains. Open products is a method for combining domains to obtain a more sophisticated domain.
Reference: [7] <author> S.K. Debray, </author> <title> Static inference of modes and data dependencies in logic programs, </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> Vol. 11, No. 3, </volume> <pages> pp. 418-450, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [20]; J&L, Jacobs's and Langen's sharing domain [15]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [8]; Dep, Debray's mode and dependency domain <ref> [7] </ref>.
Reference: [8] <author> S.K. Debray, </author> <title> Efficient dataflow analysis of logic programs, </title> <journal> J. ACM , Vol. </journal> <volume> 39, No. 4, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: When used for Prolog analysis, the mode lattice above must be combined with a lattice for variable aliasing (since it is not substitution-closed <ref> [8] </ref>). We can specify an aliasing domain that is a set of sets of variables in a clause C as follows: type aliasing (C) =&gt; set (set (variables (C))). The argument C can be any Prolog term. <p> SICStus Prolog [4] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [20]; J&L, Jacobs's and Langen's sharing domain [15]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains <ref> [8] </ref>; Dep, Debray's mode and dependency domain [7].
Reference: [9] <author> S.K. Debray, QD-Janus: </author> <title> a sequential implementation of Janus in Prolog, </title> <journal> Software-Practice and Experience, </journal> <volume> Vol. 23(12), </volume> <month> December </month> <year> 1993. </year>
Reference: [10] <author> M. Erwig, </author> <title> Graph Algorithms = Iteration + Data Structures?, </title> <booktitle> Graph-Theoretic Concepts in Computer Science, LNCS 657, </booktitle> <year> 1992. </year>
Reference-contexts: Lattice types to define type graphs are under consideration. The support language should also be extended to cope with graph elements in an elegant way. One possible language extension facilitating this is graph explorations <ref> [10] </ref>, a language construct similar to set expressions and list comprehensions, but intended to express graph algorithms. Definite boolean functions [2] is another representation used by abstract domain designers that need a lattice type and some basic support in the language to be easily used in Igor specifications.
Reference: [11] <author> C. Fecht, </author> <title> GENA | A Tool for Generating Prolog Analyzers from Specifications, Static Analysis Symp. 95, </title> <publisher> Springer LNCS 984, </publisher> <year> 1995. </year> <month> 16 </month>
Reference-contexts: Igor employs type information to use bit vectors to represent sets wherever possible. Significant gains can be achieved by using the bit vector representation when the domains rely heavily on union, intersection, and member operations performed on very large sets (Sund and J&L). 5 Related work GENA <ref> [11] </ref>, a tool for generating Prolog analyzers from specifications, is similar to Igor but provides no automatic generation of lattice code. Abstract domains are defined in SML extended by some useful libraries. The domain code is combined with a flexible fixpoint engine to produce a parameterized analyzer.
Reference: [12] <author> T.W. Getzinger, </author> <title> Abstract interpretation for the compile-time optimization of logic programs, </title> <type> Ph.D. Thesis, </type> <institution> University of South California, </institution> <type> Report 93/09, </type> <year> 1993. </year>
Reference-contexts: This language has operations for manipulating sets and lattices, for projecting domains, and for combining domains. Specifications are compiled to Prolog code and optionally linked with any fixpoint engine (we have used a fixpoint engine based on Getzinger's algorithm <ref> [12] </ref>.) The interface between the automatically-generated domain code and the fixpoint engine is completely customizable so that users can provide their own fixpoint engines. The system provides support for very concise specification of the often plentiful builtin operations. In this paper we will concentrate on the lattice specifications.
Reference: [13] <author> P. van Hentenryck, A. Cortesi & B. Le Charlier, </author> <title> Type analysis of prolog using type graphs, </title> <journal> J. Logic Programming, </journal> <volume> Vol. 22, No. 3, </volume> <year> 1995. </year>
Reference-contexts: This upgrade results in more accurate domains. Open products is a method for combining domains to obtain a more sophisticated domain. This method can be used in Igor specifications. 6 Future work and conclusion Igor does not provide support for type graphs <ref> [13, 16] </ref>. Lattice types to define type graphs are under consideration. The support language should also be extended to cope with graph elements in an elegant way.
Reference: [14] <author> M. Hermenegildo & K. Greene, </author> <title> The &-Prolog system: Exploiting independent and-parallelism, </title> <journal> New Generation Computing, </journal> <volume> Vol. 9(3,4), </volume> <pages> pp. 233-257, </pages> <year> 1991. </year>
Reference-contexts: Comparisons of hand-coded with auto-generated domains were performed as follows. The hand-coded freeness, sharing, and linearity analysis (called shfrson) of &-Prolog <ref> [14] </ref> was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog [3, 17] was compared with Dep. The compared domains are not identical but similar enough to serve for our very approximate comparisons. Only the execution time for analysis is included in the measurements.
Reference: [15] <author> D. Jacobs & A. Langen, </author> <title> Accurate and efficient approximation of variable aliasing in logic programs, </title> <booktitle> Proc. North American Conf. Logic Programming 1989, </booktitle> <pages> pp. 154-165, </pages> <year> 1989. </year>
Reference-contexts: The time unit is seconds. SICStus Prolog [4] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [20]; J&L, Jacobs's and Langen's sharing domain <ref> [15] </ref>; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [8]; Dep, Debray's mode and dependency domain [7].
Reference: [16] <author> G. Janssens & M. Bruynooghe, </author> <title> Deriving Descriptions of Possible Values of Program Variables by Means of Abstract Interpretation, </title> <journal> J. Logic Programming, </journal> <volume> Vol. </volume> <pages> 13(2-2), pp. 205-258, </pages> <year> 1992. </year>
Reference-contexts: This upgrade results in more accurate domains. Open products is a method for combining domains to obtain a more sophisticated domain. This method can be used in Igor specifications. 6 Future work and conclusion Igor does not provide support for type graphs <ref> [13, 16] </ref>. Lattice types to define type graphs are under consideration. The support language should also be extended to cope with graph elements in an elegant way.
Reference: [17] <author> T. Lindgren, </author> <title> The compilation and execution of recursion-parallel Prolog on shared-memory multiprocessors, </title> <booktitle> Licentiate of Philosophy Thesis, Uppsala Theses in Computer Science 18/93, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Comparisons of hand-coded with auto-generated domains were performed as follows. The hand-coded freeness, sharing, and linearity analysis (called shfrson) of &-Prolog [14] was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog <ref> [3, 17] </ref> was compared with Dep. The compared domains are not identical but similar enough to serve for our very approximate comparisons. Only the execution time for analysis is included in the measurements. Program loading, code preparation, presentation of the results and similar phases are left out.
Reference: [18] <author> M. Nordin, Igor: </author> <title> A tool for developing abstract domains for Prolog, </title> <institution> Licentiate of Philosophy Thesis, Uppsala University, </institution> <year> 1995. </year>
Reference-contexts: The system provides support for very concise specification of the often plentiful builtin operations. In this paper we will concentrate on the lattice specifications. A full description of the Igor tool is available elsewhere <ref> [18] </ref>. 2 Lattice types The user specifies lattice types. Several kinds of lattice types are supported: flat lattices, subset lattices, product lattices, atomic function lattices, explicitly defined finite lattices, tree lattices, and lattices with disjunctive elements. <p> Care must be taken by the user to avoid the creation 3 of infinite elements, either via a self-referential lattice type or via disjunctive sets of lattice elements with unordered arguments. This language is defined elsewhere <ref> [18] </ref>; here we only give a few examples of constructs in the language. 3 The supporting language In addition to the lattice type system, Igor contains a first-order, statically typed, strict functional language. <p> The language includes expressions for traversing sets, mapping functions on sets, and universal or existential quantification over set elements <ref> [18] </ref>. Here we give a few examples of constructs in the language. Example. The following expression maps the function f on all elements X, satisfying property p, drawn from the set of sets Set. --f (X) | X &lt;- SubSet, p (X)- | SubSet &lt; Set 2 Example.
Reference: [19] <author> P.L. van Roy, </author> <title> Can Logic Programming Execute as Fast as Imperative Programming?, </title> <type> Ph.D. Thesis, </type> <institution> UCB/CSD 90/600, Computer Science Division (EECS), University of California, Berkeley, </institution> <year> 1990. </year>
Reference-contexts: The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks <ref> [19] </ref>. 12 Comparison of hand-coded domains and generated domains Program &-Prolog Sund ratio Reform Dep ratio boyer 6.82 2.93 0.43 4.49 2.26 0.50 browse 5.33 30.86 5.79 1.06 1.81 1.71 chatparser - 23.10 57.92 2.51 crypt 1.84 0.83 0.45 0.39 1.37 3.51 divide 3.17 0.26 0.08 0.13 0.56 4.31 fastmu 0.95
Reference: [20] <author> R. Sundararajan, </author> <title> An abstract interpretation scheme for groundness, freeness, and sharing analysis of logic programs, </title> <type> Technical Report CIS-TR-91-06, </type> <institution> Dept. of Computer and Information Science, University of Oregon, </institution> <year> 1991 </year>
Reference-contexts: The time unit is seconds. SICStus Prolog [4] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity <ref> [20] </ref>; J&L, Jacobs's and Langen's sharing domain [15]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [8]; Dep, Debray's mode and dependency domain [7].
Reference: [21] <author> S.W-K. Tjiang, </author> <title> Automatic Generation of Data-Flow Analyzers: A Tool for Building Optimzers, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, Stanford University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Venkatesh [22] designed a denotational semantics specification language augmented with a collecting semantics mechanism for program analysis. The specifications are interpreted rather than compiled. Tjiang <ref> [21] </ref> describes a tool that greatly simplifies the implementation of opti-mizers by using high-level specifications to combine several simpler optimization specifications. This tool works with flow-graphs and is aimed at imperative rather than declarative languages. Cortesi et al [6] propose two kinds of support for domain construction.
Reference: [22] <author> G.A. Venkatesh, </author> <title> A framework for construction and evaluation of high-level specifications for program analysis techniques, </title> <booktitle> SIGPLAN Conf. Programming Language Design and Implementation, PLDI'89, </booktitle> <pages> pp. 1-12, </pages> <year> 1989. </year>
Reference-contexts: It is mainly intended for imperative languages and it also uses a high-level functional language to define data flow functions, an abstract domain, and an compiler interface and produces an efficient executable from this. 14 and boolean formula lattices are not yet supported by Igor. Venkatesh <ref> [22] </ref> designed a denotational semantics specification language augmented with a collecting semantics mechanism for program analysis. The specifications are interpreted rather than compiled. Tjiang [21] describes a tool that greatly simplifies the implementation of opti-mizers by using high-level specifications to combine several simpler optimization specifications.
Reference: [23] <author> K. Yi & W.L. Harrison III, </author> <title> Automatic generation and management of in-terprocedural program analyses, </title> <booktitle> The 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: Abstract domains are defined in SML extended by some useful libraries. The domain code is combined with a flexible fixpoint engine to produce a parameterized analyzer. The performance of analyzers implemented with GENA seems to be very good. The Z1 system <ref> [23] </ref> allows the programmer to specify an analyzer and an abstract domain which is compiled into executable code. Our system extends the capabilities of Z1 with disjunctive and structure-based domains and more flexible projection operations. Igor is furthermore substantially faster.
References-found: 23

