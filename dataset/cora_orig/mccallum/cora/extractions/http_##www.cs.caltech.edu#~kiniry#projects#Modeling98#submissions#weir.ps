URL: http://www.cs.caltech.edu/~kiniry/projects/Modeling98/submissions/weir.ps
Refering-URL: http://www.cs.caltech.edu/~kiniry/projects/Modeling98/submissions.html
Root-URL: http://www.cs.caltech.edu
Title: Dynamic Distribution for the Application Designer  Dynamic Distribution for the Application Designer  
Author: Charles Weir Charles Weir 
Date: Aug 98-18  1998 1  10 August 1998  
Abstract-found: 0
Intro-found: 1
Reference: [Gamma+] <author> Design Patterns, Gamma, Helm, Johnson and Vlissides, </author> <note> Addison-Wesley, ISBN 0-201-63361-2 </note>
Reference-contexts: Certainly this approach doesnt lend itself very readily to dynamic distribution; moving a Match instance from one host to another would mean notifying all its clients of the move. The Faade Model Here the server provides just one Faade object (see <ref> [Gamma+] </ref>) which provides single functions to do each operation. So in the example we might provide a FootballServer, with operation getMatch and operation changeMatch, with parameters a match I.D., and all of the data required to make the changes. This approach is also easy to design. <p> Variant: Session Object One way to remove the problems of multi-threading is to have a separate instance of the Faade Object for each client. Thus the server object can be single threaded. Typically there would be a single Factory object (see <ref> [Gamma+] </ref>) on each host to create such a session object. This removes the problems of multi-threading. Also, the session object can easily implement security facilities, since it knows its client. However: The Session Object approach retains all the other problems of the Faade approach above. <p> However: it may require many clientserver calls to set up the data for a single database change which is slow. A single object may represent one of a number of different possible changes to the database; although one might use the State pattern (see <ref> [Gamma+] </ref>) to implement this cleanly, it is still awkward for the server programmer. Which approach is best? A logical question to ask at this point would be which approach should we use, then? In practice no one model is suitable for all purposes. <p> Instead we should choose the best model for each specific network interaction. The approachs, in fact, are patterns for us to use whenever appropriate (see <ref> [Gamma+] </ref>). Introducing Migrating Objects An interesting feature of many Agent systems is that distributed objects can migrate easily between hosts. What is the benefit of this? CORBA, DCOM and other RPC-based systems already provide broker facilities to allow load balancing and simple object migration.
Reference: [Jacobsen] <author> ObjectOriented Software Engineering, </author> <title> A Use Case Driven Approach, Ivar Jacobson, </title> <publisher> Addison-Wesley, </publisher> <address> ISBN 0-201-54435-0 </address>
Reference-contexts: Suppose we want to add distribution to such a nave model, but to distribute only the two Use Cases (see <ref> [Jacobsen] </ref>) that involve Match information: entering a goal and updating the team list.
Reference: [Orfali+] <editor> Essential Distributed Objects Survival Guide, Orfali, Harkey and Edwards, </editor> <publisher> John Wiley and Sons Ltd., </publisher> <address> ISBN 0-471-12993-3 </address>
Reference-contexts: A better approach is to migrate the upgrade task onto the database host. 3 In MTS, special objects manage contention for shared resources such as databases or memory. These objects are written by experts in multi-threading; application programmers dont have to worry about them. 4 See <ref> [Orfali+] </ref> for a discussion of DCOM object migration.
Reference: [Waldo+94] <institution> A Note on Distributed Computing, Waldo, Wyant, Wollrath and Kendall, Sun Microsystems Laboratories, </institution> <note> http://www.sunlabs.com/smli/technical-reports/1994/smli_tr-94-29.ps </note>
Reference-contexts: If we implement these updates using Remote Procedure Calls (RPCs), this can require database elements to be locked for the duration of several client server calls; that can make it impossible to get decent throughput (see <ref> [Waldo+94] </ref>). A better approach is to migrate the upgrade task onto the database host. 3 In MTS, special objects manage contention for shared resources such as databases or memory.
References-found: 4

