URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/main.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Title: Explicit Substitutions  
Author: M. Abadi L. Cardelli P.-L. Curien J.-J. Levy 
Affiliation: Ecole Normale Superieure;  
Note: Digital Equipment Corporation, Systems Research Center.  part of this work was completed while at Digital Equipment Corporation, Systems Research Center. INRIA Rocquencourt; part of this work was completed while at Digital Equipment Corporation, Systems Research Center and Paris Research Laboratory.  
Date: May 31, 1991  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H.P. Barendregt, </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <publisher> North Holland, </publisher> <year> 1985. </year>
Reference-contexts: The correspondence between the theory and its implementations becomes highly nontrivial, and the correctness of the implementations can be difficult to establish. In this paper we study the oe-calculus, a refinement of the -calculus <ref> [1] </ref> where substitutions are manipulated explicitly. Substitutions have syntactic representations, and if a is a term and s is a substitution then the term a [s] represents a with the substitution s. <p> Conversely, suppose that b is a weak head normal form, then oe (b) is a weak head normal form. 2 Corollary 3.10 n ! is a complete strategy. Proof This follows from the completeness of the n ! fi strategy. (See <ref> [1] </ref> for a proof in the classical notation.) 2 With the same approach, we can also define a system wn !, which incor porates some slight optimizations (present also in our abstract machine, below).
Reference: [2] <author> N. De Bruijn, </author> <title> Lambda-calculus Notation with Nameless Dummies, a Tool for Automatic Formula Manipulation, </title> <journal> Indag. Mat. </journal> <volume> 34, </volume> <pages> pp. 381-392, </pages> <year> 1972. </year>
Reference-contexts: We start out by discussing an untyped calculus. The main value of the untyped calculus is for studying evaluation methods. We give reduction rules that extend those of the classical -calculus and investigate their confluence. We concentrate on a presentation that relies on De Bruijn's numbering for variables <ref> [2] </ref>, and briefly discuss presentations with more traditional variable names. Then we proceed to consider typed calculi of substitutions, in De Bruijn notation. We discuss typing rules for a first-order system and for a higher-order system; we prove some of their central properties. <p> The classical fi rule is not directly included, but it can be simulated, as we now argue. The precise definition of fi reduction, in the style of De Bruijn <ref> [2] </ref>, is as follows: (a)b ! fi afb=1; 1=2; : : : n=n+1; : : :g where the meta-level substitution f: : :g is defined inductively by using the rules: nfa 1 =1; : : :; a n =n; : : :g = a n afa 1 =1; : : :
Reference: [3] <author> L. Cardelli, </author> <title> Typeful Programming, </title> <type> SRC Report No. 45, </type> <institution> Digital Equipment Corporation, </institution> <year> 1989. </year>
Reference-contexts: The typing rules are meant to serve in designing typechecking algorithms. In particular, their study has been of help for both soundness and efficiency in the design of the 2 typechecking algorithm for the Quest programming language <ref> [3] </ref>. We postpone discussion of the untyped calculi to section 3 and of the typed calculi to sections 4 and 5. We now proceed with a general technical overview. 2 Overview The technical details of the oe-calculus can be quite intricate, and hence a gentle informal introduction seems in order. <p> These are important concerns in typechecking programs in the Quest language <ref> [3] </ref>, for example. It is nice to discover that we can apply the same concept of explicit substitutions to tackle typecheck-ing problems as well. In order to carry out this plan, we must first obtain a second-order system with explicit substitutions, which already incurs several difficulties.
Reference: [4] <author> P.-L. Curien, </author> <title> The ae-calculi: an Abstract Framework for Closures, </title> <note> unpublished (preliminary version printed as LIENS report, </note> <year> 1988). </year>
Reference-contexts: For example, the calculus is Church-Rosser and is a conservative extension of the -calculus. Moreover, the oe-calculus is strongly connected with the categorical understanding of the -calculus, where a substitution is interpreted as a composition <ref> [4] </ref>. 1 We propose the oe-calculus as a step in closing the gap between the classical -calculus and concrete implementations. The calculus is a vehicle for designing, understanding, verifying, and comparing implementations of the -calculus, from interpreters to machines. <p> Weak reduction strategies do not compute in the scope of 's. Then, there arise neither nested substitutions nor substitutions in the scope of 's. All substitutions are at the top level, as simple environments. An ancestor of the oe-calculus, the ae-calculus, suffices for the treatment of weak reduction <ref> [4] </ref>. However, strong reduction strategies are useful in general, both in logics and in the typechecking of higher-order programming languages. In fact, strong reduction strategies are useful in all situations where symbolic matching has to be conducted in the scope of binders. <p> One basic idea is to implement the recursive call on b [s] during the evaluation of (ba)[s] by using a stack to store the argument a [s]. Thus, the stack contains closures. The following table represents an extension of Krivine's abstract machine <ref> [16, 4] </ref>. The first column represents the "current state," the second one represents the "next state." Each line has to be read as a transition from a triple (Subst, Term, Stack) to a triple of the same nature.
Reference: [5] <author> P.-L. Curien, </author> <title> Categorical Combinators, Sequential Algorithms and Functional Programming, </title> <publisher> Pitman, </publisher> <year> 1986. </year>
Reference-contexts: The rest of this subsection is devoted to proving Theorem 3.2. First we show that oe is noetherian (that is, oe reductions always terminate) and confluent. Proposition 3.3 oe is noetherian and confluent. Proof We have an indirect proof of noetherianity, as follows. The oe-calculus translates into categorical combinators <ref> [5] </ref>, by merging the two sorts of terms and substitutions and collapsing the operations [ ] and ffi into one.
Reference: [6] <author> P.-L. Curien, T. Hardin, J.-J. Levy, </author> <title> Confluence Properties of Weak and Strong Calculi of Explicit Substitutions, </title> <type> draft, </type> <year> 1991. </year>
Reference-contexts: The proof appears in <ref> [6] </ref>. Let us just summarize the informal argument. Call b = Y (c) the term above. It reduces to both x [u ffi ((cb) id )] and c (x [u ffi ((cb) id )]). <p> However, her difficulties and ours differ somewhat, and in particular the counterexamples to confluence differ. Recently, Hardin and Levy have succeeded in obtaining confluence with metavariables for both terms and substitutions, by slightly changing the syntax and the set of equations. These results are reported in <ref> [13, 6] </ref>. 3.3 The oe-calculus with names Let us discuss a more traditional formulation of the calculus, with variable names x; y; z; : : : , as a small digression. Two ways seem viable. <p> Finally, b 0 can be an abstraction only if b = b 0 [s]. 2 Other results on normal-order reduction strategies for weak calculi of explicit substitutions can be found in <ref> [6] </ref>. 3.5 Towards an implementation As a further refinement towards an implementation, we adapt wn nipulate only expressions of the forms a [t] and s ffi t.
Reference: [7] <author> P.-L. Curien, T. Hardin, A. Rios, </author> <title> Normalisation Forte des Substitutions, </title> <type> draft, </type> <year> 1991. </year>
Reference-contexts: For example, for the critical pair (1 [id ])[s] ! 1 [s] and (1 [id ])[s] ! 1 [id ffi s] local confluence is ensured through the IdL rule. A different proof of termination for SUBST and oe has been found re cently <ref> [7] </ref>. 2 Since oe is noetherian, let us examine the form of oe normal forms.
Reference: [8] <author> P.-L. Curien, A. Rios, </author> <title> Un Resultat de Completude pour les Substitutions Explicites, </title> <institution> Comptes Rendus de l'Academie des Sciences de Paris, t. </institution> <address> 312, </address> <publisher> Serie I, </publisher> <pages> pp. 471-476, </pages> <year> 1991. </year>
Reference-contexts: To obtain c from 1 [a:A (b:B id)], we have reconstructed Beta redexes from closures, by undoing Beta steps. This reconstruction can be performed in a systematic way with a suitable rewriting system; soundness and completeness results follow. We refer the interested reader to <ref> [8] </ref>. 5 Second-order theories Type rules and typecheckers are also needed for second-order calculi. Unfortunately, the situation is more complex than at the first order, because types include binding constructs (quantifiers).
Reference: [9] <author> H.P. Curry and R. </author> <title> Feys, </title> <booktitle> Combinatory Logic, </booktitle> <volume> Vol. 1, </volume> <publisher> North Holland, </publisher> <year> 1958. </year>
Reference-contexts: Thus, a general treatment of substitutions is required, where substitutions may occur at the top level and deep inside terms. In some respects, the oe-calculus resembles the calculi of combinators, including those of categorical combinators <ref> [9] </ref>. The oe-calculus and the combinator calculi all give full formal accounts of the process of computation, without suffering from unpleasant complications in the (informal) handling of variables. They all make it easy to derive machines for the -calculus and to show the correctness of these machines.
Reference: [10] <author> J. </author> <title> Field, On Laziness and Optimality in Lambda Interpreters: Tools for Specification and Analysis, </title> <booktitle> in the Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 1-15, </pages> <address> San Francisco, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: This distinction is important to a simple understanding of confluence properties and to the practicality of the oe-calculus. Simultaneously with our work, Field developed a system almost identical to our basic system, too, and claimed some of the same results <ref> [10] </ref>. Thus, we share a starting point. However, Field's paper is an investigation of optimality properties of reduction schemes, so for example Field went on to consider a labelled calculus.
Reference: [11] <author> T. Hardin, </author> <title> Confluence Results for the Pure Strong Categorical Combi-natory Logic CCL: -calculi as Subsystems of CCL, </title> <booktitle> Theoretical Computer Science 65, </booktitle> <pages> pp. 291-342, </pages> <year> 1989. </year>
Reference-contexts: Then we focus on a more specialized reduction system, still based on normal order, which provides a suitable basis for abstract oe machines. We describe one machine, which extends Krivine's weak reduction machine [16] with strong reduction. In her study of categorical combinators, Hardin proposed systems similar to ours <ref> [11] </ref>. In particular, Hardin's system E + (Beta) is a homomorphic image of our basic system. <p> We come back to this subtle point below. Instead, the proof relies on the termination and confluence of oe, the confluence of the classical -calculus, and Hardin's interpretation technique <ref> [11] </ref>. The rest of this subsection is devoted to proving Theorem 3.2. First we show that oe is noetherian (that is, oe reductions always terminate) and confluent. Proposition 3.3 oe is noetherian and confluent. Proof We have an indirect proof of noetherianity, as follows. <p> Hardin's results on confluence bear some similarity with ours. In <ref> [11] </ref>, Hardin has shown that various systems are confluent on a set D of closed terms, which includes the representation of all the usual expressions; she found problems with confluence for non-closed terms, too. However, her difficulties and ours differ somewhat, and in particular the counterexamples to confluence differ.
Reference: [12] <author> T. Hardin, A. Laville, </author> <title> Proof of Termination of the Rewriting System SUBST on CCL, </title> <booktitle> Theoretical Computer Science 46, </booktitle> <pages> pp. 305-312, </pages> <year> 1986. </year> <month> 55 </month>
Reference-contexts: Under this translation, a one-step rewriting in oe is mapped to a one-step rewriting of a system SUBST of categorical rewriting rules (the exact translation of the largest variant considered in 3.2). Hardin and Laville have established the termination of SUBST <ref> [12] </ref>. Noetherianity simplifies the proof of confluence. By a well-known lemma, local confluence suffices [14]; it can be checked by examining critical pairs, according to the Knuth-Bendix test.
Reference: [13] <author> T. Hardin, J.-J. Levy, </author> <title> A Confluent Calculus of Substitutions, </title> <booktitle> France--Japan Artificial Intelligence and Computer Science Symposium, </booktitle> <address> Izu, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: However, her difficulties and ours differ somewhat, and in particular the counterexamples to confluence differ. Recently, Hardin and Levy have succeeded in obtaining confluence with metavariables for both terms and substitutions, by slightly changing the syntax and the set of equations. These results are reported in <ref> [13, 6] </ref>. 3.3 The oe-calculus with names Let us discuss a more traditional formulation of the calculus, with variable names x; y; z; : : : , as a small digression. Two ways seem viable.
Reference: [14] <author> G. Huet, </author> <title> D.C. Oppen, Equations and Rewrite Rules: A Survey, in Formal Languages Theory: Perspectives and Open Problems (R. Book, </title> <booktitle> editor), </booktitle> <pages> pp. 349-393, </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Hardin and Laville have established the termination of SUBST [12]. Noetherianity simplifies the proof of confluence. By a well-known lemma, local confluence suffices <ref> [14] </ref>; it can be checked by examining critical pairs, according to the Knuth-Bendix test. For example, for the critical pair (1 [id ])[s] ! 1 [s] and (1 [id ])[s] ! 1 [id ffi s] local confluence is ensured through the IdL rule.
Reference: [15] <author> J.W. Klop, </author> <title> Combinatory Reduction Systems, </title> <publisher> Mathematical Center Tracts 129, </publisher> <address> Amsterdam, </address> <year> 1980. </year>
Reference-contexts: It expresses that a substitution is equal to its first element appended in front of the rest. This rule is reminiscent of the surjective-pairing rule, which deserved much attention in the classical -calculus. Klop has shown that surjective pairing destroys confluence for the -calculus <ref> [15] </ref>. Similarly, the system oe + Id + IdR + VarShift + SCons is not confluent when we have metavariables for both terms and substitutions, although it is locally confluent. The following term, inspired by Klop's counterexample [15], works as a counterexample to confluence: Y (Y (x [1 [u ffi (1 <p> Klop has shown that surjective pairing destroys confluence for the -calculus <ref> [15] </ref>. Similarly, the system oe + Id + IdR + VarShift + SCons is not confluent when we have metavariables for both terms and substitutions, although it is locally confluent. The following term, inspired by Klop's counterexample [15], works as a counterexample to confluence: Y (Y (x [1 [u ffi (1 id )] (" ffi (u ffi ((21) id )))])) where Y is a fixpoint combinator, x is a term metavariable, and u is a substitution metavariable. The proof appears in [6].
Reference: [16] <author> J.-L. Krivine, </author> <note> unpublished. </note>
Reference-contexts: We discuss a normal-order strategy for oe evaluation. Then we focus on a more specialized reduction system, still based on normal order, which provides a suitable basis for abstract oe machines. We describe one machine, which extends Krivine's weak reduction machine <ref> [16] </ref> with strong reduction. In her study of categorical combinators, Hardin proposed systems similar to ours [11]. In particular, Hardin's system E + (Beta) is a homomorphic image of our basic system. <p> One basic idea is to implement the recursive call on b [s] during the evaluation of (ba)[s] by using a stack to store the argument a [s]. Thus, the stack contains closures. The following table represents an extension of Krivine's abstract machine <ref> [16, 4] </ref>. The first column represents the "current state," the second one represents the "next state." Each line has to be read as a transition from a triple (Subst, Term, Stack) to a triple of the same nature.
Reference: [17] <author> P. Martin-Lof, </author> <title> Intuitionistic Type Theory, notes by G. Sambin of a series of lectures given in Padova in 1980, </title> <publisher> Bibliopolis, </publisher> <year> 1984. </year>
Reference-contexts: Ty; nil The typing rules become more complex because types may contain type variables, which must be looked up in the appropriate environments. (The problem arises in full generality with dependent types <ref> [17] </ref>, and some readers may find it helpful to think about calculi of substitutions with dependent types.) In particular, the typing axiom for 1 shown above becomes the rule: E ` A :: Ty The extra shift is required because A is understood in the environment E in the hypothesis, while
Reference: [18] <author> C.P. Wadsworth, </author> <title> Semantics and Pragmatics of the Lambda Calculus, </title> <type> Dissertation, </type> <institution> Oxford University, </institution> <year> 1971. </year> <month> 56 </month>
Reference-contexts: In implementations, substitutions invariably happen in a more controlled way. This is due to practical considerations, relevant in the implementation of both logics and programming languages. The term afb=xg may contain many copies of b (for instance, if a = xxxx); without sophisticated structure-sharing mechanisms <ref> [18] </ref>, performing substitutions immediately causes a size explosion. Therefore, in practice, substitutions are delayed and explicitly recorded; the application of substitutions is independent, and not coupled with the fi rule.
References-found: 18

