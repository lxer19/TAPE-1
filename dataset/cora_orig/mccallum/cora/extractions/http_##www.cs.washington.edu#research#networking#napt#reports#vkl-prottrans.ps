URL: http://www.cs.washington.edu/research/networking/napt/reports/vkl-prottrans.ps
Refering-URL: http://www.cs.washington.edu/research/networking/napt/reports/index.html
Root-URL: http://www.cs.washington.edu
Email: vkl@cs.washington.edu  
Title: just an upper-layer protocol handler. IPv6/IPv4 Protocol Translation in SPIN  
Author: P l e u s P r o t o c o l G r a p h U D P T C P N A P T IC M P v I C M P v I P .P k tR e c v I P .P k tR e c v E th e r n e t D e v ic e D r i v e r Vincent K. Lam 
Address: Seattle, Washington 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Note: NAPT handler or  
Abstract: H a n d le rs Figure 1: IP handling on the receive path. The Ether.PktRecv event causes either the IPv4 or IPv6 handler to fire. These handlers then inspect the IP header to determine whether to invoke the translating 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B.N. Bershad, S. Savage, P. Pardyak, E.G. Sirer, M.E. Fiuczynski, D. Becker, S. Eggers, C. Chambers, </author> <title> Extensibility, Safety and Performance in the SPIN Operating System, </title> <booktitle> Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: The protocol translation procedure indeed depends on the type of address used, but its core concepts and associated issues are generally independent of any address translation mechanism. This paper focuses on the protocol translation aspect and details it using a translator implementation done in the SPIN extensible operating system <ref> [1] </ref>. Although this specific implementation is discussed, the protocol translation procedure described is fundamental to all IPv6/IPv4 translators.
Reference: [2] <author> M.E. Fiuczynski, V.K. Lam, B.N. Bershad, </author> <title> The Design and Implementation of an IPv6/IPv4 Network Address and Protocol Translator, </title> <booktitle> Proceedings of the 1998 USENIX Technical Conference, </booktitle> <address> New Orleans, LA., </address> <month> Jun. </month> <year> 1998. </year>
Reference-contexts: Although this specific implementation is discussed, the protocol translation procedure described is fundamental to all IPv6/IPv4 translators. Marc Fiuczynski, a graduate student at the University of Washington, and myself have implemented a Network Address and Protocol Translator (NAPT) <ref> [2] </ref>, in the context of SPIN, that performs the basic translation of packets from IPv4 to IPv6 and vice versa. For example, the translator can correctly translate cross protocol accesses of WWW, FTP, and Telnet services. Section 2 of the paper gives an overview of the NAPT translation implementation. <p> For ease of implementation, the length fields are recomputed from the entire translated packet instead of being adjusted based on upper layer translations. In the case of stateless translation, the address fields are simply converted to v4-mapped and v4-compatible IPv6 addresses in accordance to [6]. When stateful translation <ref> [2] </ref> is used, the address fields are set according some address mapping maintained by the NAPT. Unlike the fields mentioned above, the quality of service or flow related fields do not have the same translation convenience.
Reference: [3] <author> M.E. Fiuczynski, B.N. Bershad, </author> <title> An Extensible Protocol Architecture for ApplicationSpecific Networking, </title> <booktitle> Proceedings of the 1996 USENIX Technical Conference, </booktitle> <address> San Diego, CA., </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Finally, conclusions are presented in Section 5. 2 Implementation In order to implement the NAPT in SPIN, we had to start by adding IPv6 support to the operating system. Written under the Plexus networking architecture <ref> [3] </ref>, SPIN already had support for IPv4 over Ethernet. 2 T ran slate IC M P N A T P H an d ler T ran slate F rag m en t F ield s Packet is fragm ent? Packet is head fragm ent? A d d re ss T ra
Reference: [4] <author> S. Deering, R. Hinden, </author> <title> IPv6 Specification, </title> <type> RFC 1883, </type> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Currently, the IPv6 layer is a lightweight implementation that incorporates only the set of services necessary to support the translator (i.e. it does not completely implement the full router requirements as outlined in the IPv6 specification <ref> [4] </ref>). The IPv6 layer can respond to ICMP Echo Requests and Neighbor Solicitations (for link-layer address resolution) and supports fragmentation of outgoing packets.
Reference: [5] <author> A. Conta, S. Deering, </author> <title> Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification, </title> <type> RFC 1885, </type> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: This was expected since ICMPv6 has more requirements than ICMPv4 (e.g. Neighbor Discovery). The minimal nature of the size increase is due to the fact that our ICMPv6 implementation only includes essential services and does not fully incorporate the full requirements outlined in the ICMPv6 RFC <ref> [5] </ref>. 3 Protocol Translation Mechanism The basic operation in protocol translation is to replace the IP header of the original packet with a new header of a different IP version. <p> In this case, we simply copy the lower 16 bits of the IPv6 id field. Because the id field is typically generated by increments of one, the probability of duplicate IDs should be equivalent to that of a normal IPv4 session. 3.2 ICMP translation Since ICMPv4 [7] and ICMPv6 <ref> [5] </ref> share the same header (type, code, and checksum fields) and most of the message types have semantic equivalence across versions, translation of ICMP is mostly straightforward with just a few special cases. One of these cases is the checksum field.
Reference: [6] <author> E. Nordmark, </author> <title> Stateless IP/ICMP Translator (SIIT), </title> <type> IETF Internet Draft, </type> <month> Nov. </month> <year> 1997. </year>
Reference-contexts: For ease of implementation, the length fields are recomputed from the entire translated packet instead of being adjusted based on upper layer translations. In the case of stateless translation, the address fields are simply converted to v4-mapped and v4-compatible IPv6 addresses in accordance to <ref> [6] </ref>. When stateful translation [2] is used, the address fields are set according some address mapping maintained by the NAPT. Unlike the fields mentioned above, the quality of service or flow related fields do not have the same translation convenience. <p> Again, because of the equivalence of most of the ICMP messages, translating between versions mainly involves doing static conversions of the field values. The exact field translation details are discussed in <ref> [6] </ref>. However, one important detail to note is that ICMP Error Messages contains as much of the error invoking packet's IP header and payload as can fit, and thus that needs to be translated as well.
Reference: [7] <author> J. Postel, </author> <title> Internet Control Message Protocol, </title> <type> RFC 792, </type> <month> Sep. </month> <year> 1981. </year>
Reference-contexts: In this case, we simply copy the lower 16 bits of the IPv6 id field. Because the id field is typically generated by increments of one, the probability of duplicate IDs should be equivalent to that of a normal IPv4 session. 3.2 ICMP translation Since ICMPv4 <ref> [7] </ref> and ICMPv6 [5] share the same header (type, code, and checksum fields) and most of the message types have semantic equivalence across versions, translation of ICMP is mostly straightforward with just a few special cases. One of these cases is the checksum field.
References-found: 7

