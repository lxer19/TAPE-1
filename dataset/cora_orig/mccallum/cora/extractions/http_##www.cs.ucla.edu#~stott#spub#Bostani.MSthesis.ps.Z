URL: http://www.cs.ucla.edu/~stott/spub/Bostani.MSthesis.ps.Z
Refering-URL: http://www.cs.ucla.edu/~stott/spub/
Root-URL: http://www.cs.ucla.edu
Title: CHAPTER 1 Background  
Abstract: In recent years, much research has been directed at developing programming environments that efficiently combine various programming paradigms such as logic programming, rewriting, functional programming and lazy evaluation. It has been envisioned that such environments would provide the "expressive power of both functions, and relations" [Nar 88]. In [Nar 88], Narain proposes a new language, F*, and its implementation in Prolog, called Log(F), which can be used to do lazy functional programming in logic. In Log(F), an F* compiler translates F* rules into Horn clauses using an additional primitive for lazy simplification of F* terms, called reduce. This chapter presents some background information about F* and Log(F) which have been used extensively at UCLA [Liv 88, Muntz 88, Parker 88a, Parker 88b] for the implementation of stream processing systems. We also review Bop, which is an extension to the Log(F) programming environment. Finally, we discuss related research in the area of compiling logic programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [Barr 85] <author> Barrett, R. and Ramsay, A. and Sloman, A., "POP-11: </author> <title> A Practical Language for Artificial Intelligence," </title> <publisher> Ellis Horwood Limited, </publisher> <year> 1985. </year>
Reference: [Boyd 90] <author> Boyd J.L. and Karam G.M., </author> <title> "Prolog in C," </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 25, No. 7, </volume> <month> July </month> <year> 1990. </year>
Reference: [Bruy 86] <author> Bruynooghe, M., </author> <title> "Compile Time Garbage Collection," </title> <type> Report No. 43, </type> <institution> Dept. Computerwetenschappen, Katholieke Universiteit Leuven, </institution> <month> April </month> <year> 1986. </year>
Reference: [Card 85] <author> Cardelli, L. and Wegner, P., </author> <title> "On Understanding Types, Data Abstraction, and Polymorphism," </title> <journal> Computing Surveys, </journal> <volume> Vol. 17, No. 4, </volume> <month> December </month> <year> 1985, </year> <pages> pp. 471-522. </pages>
Reference: [Cloc 81] <author> Clocksin, W.F. and Mellish, C.S., </author> <title> "Programming In Prolog, Second Edition," </title> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference: [Cohen 85] <author> Cohen, J., </author> <title> "Describing Prolog by its interpretation and compilation," </title> <journal> Communication of the ACM, </journal> <volume> Vol. 28, No. 12, </volume> <pages> pp 1311-1324, </pages> <month> December </month> <year> 1985. </year>
Reference: [Debr 86] <author> Debray S.K. and Warren D.S., </author> <title> "Detection and Optimization of Functional Computations in Prolog," </title> <booktitle> Proceeding of the Third International Conference on Logic Programming, </booktitle> <address> London, U.K., </address> <month> July </month> <year> 1986. </year>
Reference: [Ders 85] <author> Dershowitz, N. and Plaisted, D. A., </author> <title> "Logic Programming cum Applicative Programming," </title> <booktitle> Symposium on Logic Programming, 85CH2205-3, </booktitle> <pages> pp. 54-66, </pages> <year> 1985. </year>
Reference: [Gabr 85] <author> Gabriel, J. and Lindholm, T. and Lusk, E.L. and Overbreek R.A., </author> <title> "A Tutorial on the Warren Abstract Machine for Computational Logic," </title> <type> TR ANL-8-84, </type> <institution> Argonne National Laboratory, Argonne, Illinois 60439. </institution>
Reference-contexts: Since its introduction, the WAM has evolved and has become the basis of many Prolog implementations <ref> [Gabr 85, Newt 87, Turk 86] </ref>. In the following sections, we define an abstract machine, called the DF* Abstract Machine (or DFAM), which we use as intermediate representation for compiling DF*. <p> be represented on the heap as a structure containing a reference to the function to be invoked and the list of arguments to be passed to the function upon invocation. 1 Many optimizations that have been successfully applied too compiling Prolog programs, such as indexing and tail recursion optimization (see <ref> [Gabr 85, Warr 83] </ref>) can also be used in an F* implementation.
Reference: [Hayn 86] <author> Haynes, </author> <title> C.T., "Logic Continuations," </title> <booktitle> Proceeding of the Third International Conference on Logic Programming, </booktitle> <address> London, U.K., </address> <month> July </month> <year> 1986. </year>
Reference: [Kahn 84] <author> Kahn, K.M., </author> <title> "How to Implement Prolog on a LISP Machine," Implementations of Prolog, </title> <editor> Ed. Campbell, </editor> <publisher> Ellis Horwood, </publisher> <year> 1984. </year> <month> 78 </month>
Reference: [Kral 87] <author> Krall, A., </author> <title> "Implementation of a High-Speed Prolog Interpreter," </title> <booktitle> Pro--ceedings of the SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pp. 125-131, </pages> <address> St. Paul, Minnesota, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: In a compilation setting, however, the code for data manipulation is duplicated each time these data types are accessed. Compilation, therefore, leads to a significant amount of bulk in the final compiled executable. In a comparison of compiled versus interpreted Prolog code, <ref> [Kral 87] </ref> reports that his compiled Prolog code used ten times the amount of memory used by his interpreted byte-code representation.
Reference: [Levi 87] <author> Levi, G., Palamidessi, C., Bosco, P. G., Giovannetti, E. and Moiso, C., </author> <title> "A Complete Semantic Characterization of K-LEAF, A Logic Programming Language With Partial Functions," </title> <booktitle> IEEE Symposium on Logic Programming, 87CH2472-9, </booktitle> <pages> pp. 318-327, </pages> <year> 1987. </year>
Reference: [Liv 88] <author> Livezey. B.K., </author> <title> "The Aspen Distributed Stream Processing Environment," </title> <type> Masters Thesis, </type> <institution> UCLA Computer Science Dept., </institution> <address> Los Angeles, CA 90024-1596, </address> <year> 1988. </year>
Reference: [Mell 85] <author> Mellish, C.S., </author> <title> "Some Global Optimizations for a Prolog Compiler," </title> <journal> Journal of Logic Programming, </journal> <volume> Vol. 2, No. 1, </volume> <pages> pp. 43-66, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Of course, the quality of the generated machine code depends substantially on the C compiler used. 15 CHAPTER 3 Compiling Deterministic F* 3.1 Determinacy in Prolog Since the inception of Prolog, researchers have tried to create more efficient Pro-log implementations by introducing user-supplied annotations <ref> [Mell 85, Newt 87, Turk 86, Wein 88] </ref>. These annotations (i.e. mode, type, domain declarations) provide a Prolog compiler with hints about the user's intended usage of Prolog predicates. Using these annotations, a Prolog compiler is able to generate more efficient code leading to significant improvements in performance [Wein 88].
Reference: [Muntz 88] <author> Muntz, R.R. and D.S. Parker, "Tangram: </author> <title> Project Overview," </title> <type> TR CSD-880032, </type> <institution> UCLA Computer Science Dept., LA, </institution> <address> CA, </address> <month> April </month> <year> 1988. </year>
Reference: [Nar 88] <author> Narain, S., "LOG(F): </author> <title> An Optimal Combination of Logic Programming, Rewrite Rules and Lazy Evaluation," </title> <type> Ph.D. Dissertation, </type> <institution> UCLA Computer Science Dept., </institution> <address> Los Angeles, CA 90024-1596, </address> <year> 1988. </year>
Reference-contexts: If we needed an append with a different mode specification (e.g. append (-, -, +)), we would either have to do away with the mode declaration or duplicate the append predicate and rename it. 3.2 Determinacy in F* In <ref> [Nar 88] </ref> Narain proves that there exists a class of F* programs, called deterministic F* (DF*) which possess certain useful computational properties, such as confluence and directedness. F* programs with these properties are guaranteed to return at most one value (i.e. they are deterministic). <p> Even though this restriction was used in <ref> [Nar 88] </ref> solely for the purpose of simplifying the theoreti cal analysis of F*, it remains intact in the Log (F) implementation. The following is an example of a rule which violates restriction (c), but is accepted by CFC. listOfList ([[X|Y]|Z]) =&gt; true.
Reference: [Newt 87] <author> Newton, M.O., </author> <title> "A High Performance Implementation of Prolog," </title> <type> TR 5234-86, </type> <institution> Caltech Computer Science Dept., Pasadena, </institution> <address> CA, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: Of course, the quality of the generated machine code depends substantially on the C compiler used. 15 CHAPTER 3 Compiling Deterministic F* 3.1 Determinacy in Prolog Since the inception of Prolog, researchers have tried to create more efficient Pro-log implementations by introducing user-supplied annotations <ref> [Mell 85, Newt 87, Turk 86, Wein 88] </ref>. These annotations (i.e. mode, type, domain declarations) provide a Prolog compiler with hints about the user's intended usage of Prolog predicates. Using these annotations, a Prolog compiler is able to generate more efficient code leading to significant improvements in performance [Wein 88]. <p> Since its introduction, the WAM has evolved and has become the basis of many Prolog implementations <ref> [Gabr 85, Newt 87, Turk 86] </ref>. In the following sections, we define an abstract machine, called the DF* Abstract Machine (or DFAM), which we use as intermediate representation for compiling DF*.
Reference: [Nils 83] <author> Nilsson, Jorgen Fischer, </author> <title> "On the Compilation of a Domain-Based Pro-log," Information Processing, </title> <editor> R.E.A Mason (ed.), </editor> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <pages> pp. 293-299, </pages> <year> 1983. </year>
Reference: [Parker 88a] <author> Parker, D.S., and Muntz, R.R. and Chau, L., </author> <title> "The Tangram Stream Query Processing System," </title> <type> TR CSD-880025, </type> <institution> UCLA Computer Science Dept., </institution> <address> Los Angeles, CA, </address> <month> March </month> <year> 1988. </year>
Reference: [Parker 88b] <author> Parker, D.S. and Muntz, </author> <title> R.R., "A Theory of Directed Logic Programs and Streams," </title> <type> TR CSD-880031, </type> <institution> UCLA Computer Science Dept., </institution> <address> Los Angeles, CA, </address> <month> April </month> <year> 1988. </year>
Reference: [Parker 92] <author> Parker, </author> <note> D.S., "Bop 0.2 Manual," </note> <institution> UCLA Computer Science Dept., </institution> <address> Los Angeles, CA, </address> <year> 1992. </year>
Reference: [Sriv 85] <author> Srivastava, A. and Oxley, D., </author> <title> "An Integration of Logic and Functional Programming," </title> <booktitle> IEEE Symposium on Logic Programming, 85CH2205-3, </booktitle> <pages> pp. 254-260, </pages> <year> 1986. </year>
Reference: [Stic 88] <author> Stickel, </author> <title> M.E., "A Prolog Technology Theorem Prover: Implementation by an Extended Prolog Compiler," </title> <journal> Journal of Automated Reasoning, </journal> <volume> Vol. 4, </volume> <pages> pp. 353-380, </pages> <year> 1988. </year>
Reference: [Tama 84] <author> Tamaki, H., </author> <title> "Semantics of a Logic Programming Language With a Reducibility Predicate," </title> <booktitle> IEEE International Symposium on Logic Programming, 84CH2007-3, </booktitle> <pages> pp. 259-264, </pages> <year> 1984. </year>
Reference: [Tsan 88] <author> Tsang, C.P. and Lewins, N., </author> <title> "Embedding Logic Variables in Scheme," </title> <type> TR 88/18, </type> <institution> Dept. of Computer Science, University of Western Australia, Nedlands, </institution> <address> W.A. 6009, Australia, </address> <year> 1988. </year>
Reference: [Turk 86] <author> Turk, </author> <title> A.K., "Compiler Optimizations for the WAM," </title> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <address> London, U.K., </address> <month> July </month> <year> 1986. </year> <editor> [van E 87] van Emden, M. and Yukawa, K., </editor> <title> "Logic Programming With Equations," </title> <journal> Journal of Logic Programming, </journal> <volume> Vol. 4, </volume> <pages> pp. 265-288, </pages> <year> 1987. </year>
Reference-contexts: Of course, the quality of the generated machine code depends substantially on the C compiler used. 15 CHAPTER 3 Compiling Deterministic F* 3.1 Determinacy in Prolog Since the inception of Prolog, researchers have tried to create more efficient Pro-log implementations by introducing user-supplied annotations <ref> [Mell 85, Newt 87, Turk 86, Wein 88] </ref>. These annotations (i.e. mode, type, domain declarations) provide a Prolog compiler with hints about the user's intended usage of Prolog predicates. Using these annotations, a Prolog compiler is able to generate more efficient code leading to significant improvements in performance [Wein 88]. <p> Since its introduction, the WAM has evolved and has become the basis of many Prolog implementations <ref> [Gabr 85, Newt 87, Turk 86] </ref>. In the following sections, we define an abstract machine, called the DF* Abstract Machine (or DFAM), which we use as intermediate representation for compiling DF*.
Reference: [Wand 80] <author> Wand, M., </author> <title> "Continuation-based program transformation strategies," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 27, No. 1, </volume> <pages> pp 164-180. </pages>
Reference: [Warr 83] <author> Warren, D.H.D., </author> <title> "An Abstract Prolog Instruction Set," </title> <type> TR SRI-83-309, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: Later in this work, we will show that the detection of determinacy in F* programs can considerably improve their performance. 3.3 DFAM: The DF* Abstract Machine In <ref> [Warr 83] </ref> David Warren presented a new method for compiling Prolog through the use of an intermediate code for a virtual machine referred to as the Warren Abstract Machine (WAM). <p> be represented on the heap as a structure containing a reference to the function to be invoked and the list of arguments to be passed to the function upon invocation. 1 Many optimizations that have been successfully applied too compiling Prolog programs, such as indexing and tail recursion optimization (see <ref> [Gabr 85, Warr 83] </ref>) can also be used in an F* implementation.

References-found: 29

