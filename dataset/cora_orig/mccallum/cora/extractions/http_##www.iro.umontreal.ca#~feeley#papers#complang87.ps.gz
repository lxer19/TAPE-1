URL: http://www.iro.umontreal.ca/~feeley/papers/complang87.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~feeley/
Root-URL: http://www.iro.umontreal.ca
Title: Using closures for code generation  
Author: Marc Feeley Guy Lapalme 
Keyword: Ke ywords: Code Generation, Closure, Compiling, Interpretation, Lisp, Scheme  
Address: P.O.B. 6128, Station A Montreal, Quebec, H3C 3J7 (Canada)  
Affiliation: Departement d'informatique et de recherche operationnelle (I.R.O.) Universite de Montreal  
Abstract: This paper describes a new approach to compiling which is based on the extensive use of closures. In this method, a compiled expression is embodied by a closure whose application performs the evaluation of the given expression. For each primitive construct contained in the expression to compile, a closure is generated. As a whole, the compiled expression consists of a network of these closures. In a way, 'code generation' is replaced by 'closure generation'. This method, combined with an efficient closure implementation, produces compiled code which compares favorably (in execution time) with its interpreted counterpart. It can also be used to implement compilers for embedded languages and as it has been implemented in Scheme, it yields a straightforward metacircu-lar compiler for Scheme. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abelson H., Sussman G. J., Sussman J., </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> (1985). </year>
Reference-contexts: This paper describes an original compiling technique which offers the advantages of an interpreter with the speed of compiled code. Code generation relies only on closure generation. Scheme <ref> [1] </ref>, which is a dialect of Lisp, is used as the source and implementation language. As closures are already implemented in Scheme, it was thus possible to write an efficient and portable Scheme compiler in Scheme. <p> A complete example and improvements over the basic technique are then given. Finally, we explain how this technique can be applied to other languages and we analyse its performance. 2. Scheme and closures In many lexically scoped dialects of Lisp, e.g. Scheme [28] <ref> [1] </ref> [2], T [24] [25] and Common Lisp [30], procedures are first class objects. <p> This operation is called closure. We speak of the resulting procedure as being a closure. In fact, we shall consider them to be synonymous in this paper. Closures are a useful programming feature. They can be used to express data abstractions <ref> [1] </ref>, to implement actors [27] [32] and also to provide classes and data protection [34]. The work of Atkinson and Morrison [6] discusses their usefulness in implementing modules, separate compilation and database views.
Reference: [2] <author> Abelson H., Adams N., Bartley D., Brooks G., Clinger W., Friedman D., Halstead R., Hanson C., Haynes C., Kohlbecker E., Oxley D., Pitman K., Rees J., Rozas B., Sussman G. J., Wand M., </author> <title> The Revised Revised Report on Scheme or an UnCommon Lisp. </title> <booktitle> MIT Artificial Intelligence Memo 848, </booktitle> <address> Cambridge, Massachusetts, </address> <year> (1985). </year>
Reference-contexts: A complete example and improvements over the basic technique are then given. Finally, we explain how this technique can be applied to other languages and we analyse its performance. 2. Scheme and closures In many lexically scoped dialects of Lisp, e.g. Scheme [28] [1] <ref> [2] </ref>, T [24] [25] and Common Lisp [30], procedures are first class objects.
Reference: [3] <author> Aho A. V., Ullman J. D., </author> <title> Principles of Compiler Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> (1977). </year>
Reference-contexts: This method is much like the classical strength reduction optimization technique <ref> [3] </ref> which consists of using less general but more efficient code instead of the usual form. In our case, we are actually constructing "custom-made" closures and tayloring them to each particular case.
Reference: [4] <author> Allen F. E., </author> <title> Bibliography on program optimization. </title> <institution> IBM Research Report RC-5767, Technical Jour nal Watson Research Center, </institution> <address> Yorktown Heights, New York, </address> <year> (1975). </year>
Reference-contexts: Its performance is discussed in section 7. The optimizations that have been described always dealt with closure generation but any other optimizations could also be used, for example: invariant removal, common subexpression elimination and expression simplifications <ref> [4] </ref> [16] [29]. Data and control ow analysis could also be computed [17] [18]. Many of these optimizations can be seen as source to source transformations as was done in the RABBIT Scheme compiler [29].
Reference: [5] <author> Allen J., </author> <title> Anatomy of Lisp. </title> <publisher> McGraw-Hill, </publisher> <address> New York, New York, </address> <year> (1978). </year>
Reference-contexts: This list is checked on entering gen-ref and, if a corresponding closure is found, then it is given back otherwise it is added to the list and returned. This technique is similar to hash consing <ref> [5] </ref> [15] [33] but it applies to closures instead of pairs. This method could also be integrated in the closure generation mecanism.
Reference: [6] <author> Atkinson M. P., Morrison R., </author> <title> Procedures as Persistent Data Objects. </title> <journal> ACM Transactions on Pro gramming Languages and Systems, </journal> <volume> 7 , no. 4, </volume> <pages> 539-559, </pages> <year> (1985). </year>
Reference-contexts: In fact, we shall consider them to be synonymous in this paper. Closures are a useful programming feature. They can be used to express data abstractions [1], to implement actors [27] [32] and also to provide classes and data protection [34]. The work of Atkinson and Morrison <ref> [6] </ref> discusses their usefulness in implementing modules, separate compilation and database views. Felleisen and Friedman [11] show how to incorporate modules in Scheme via syntactic extensions which make use of closures. Closures are used here to represent compiled code.
Reference: [7] <author> Dahl O.-J., Myhrhaug B., Nygaard K., </author> <title> SIMULA 67 Common Base Language. </title> <institution> Norwegian Comput ing Center Report 725, </institution> <year> (1982). </year>
Reference-contexts: Many lexically scoped dialects of Lisp (e.g. T [24] or Common Lisp [30]) give closures as a primitive construct. But it can also be used within a language like Simula 67 <ref> [7] </ref> if closures are implemented with class instances. Feeley [9] gives the details of this implementation and a small example is given in appendix E. In fact, most object oriented language allowing for the dynamic creation of objects can be used for the implementation language. 7.
Reference: [8] <author> ExperTelligence, </author> <title> ExperLisp Reference Manual . Santa Barbara, </title> <address> California, </address> <year> (1984). </year>
Reference-contexts: This technique was also embedded in a compiler for Scheme generating assembly language; it is described in [9] and table 2 gives the times for that implementation and for ExperLisp <ref> [8] </ref> which is also a native code compiler.
Reference: [9] <author> Feeley M., </author> <title> Deux approches a l'implantation du langage Scheme , These de Maitrise, </title> <type> Document de travail #183, </type> <institution> Departement d'informatique et recherche operationnelle, Universite de Montreal, </institution> - <month> 10 </month> - 
Reference-contexts: The execution of the generated code consists mainly of closure applications, thus, an efficient closure implementation will improve performance. Such a method is described in <ref> [9] </ref> [10]. In fact that method has been used in conjunction with our compilation method to implement the compiler for the MC68000 using MC68000 assembly language as the implementation language. Its performance is discussed in section 7. <p> Many lexically scoped dialects of Lisp (e.g. T [24] or Common Lisp [30]) give closures as a primitive construct. But it can also be used within a language like Simula 67 [7] if closures are implemented with class instances. Feeley <ref> [9] </ref> gives the details of this implementation and a small example is given in appendix E. In fact, most object oriented language allowing for the dynamic creation of objects can be used for the implementation language. 7. <p> When a few simple optimisations are added, execution times drop by 40% to 70% which is only two to four times slower than the implementation language. This technique was also embedded in a compiler for Scheme generating assembly language; it is described in <ref> [9] </ref> and table 2 gives the times for that implementation and for ExperLisp [8] which is also a native code compiler.
Reference: [10] <author> Feeley M., Lapalme G., </author> <title> Closure generation based on viewing LAMBDA as EPSILON plus COM PILE . Submitted for publication, </title> <year> (1986). </year>
Reference-contexts: The execution of the generated code consists mainly of closure applications, thus, an efficient closure implementation will improve performance. Such a method is described in [9] <ref> [10] </ref>. In fact that method has been used in conjunction with our compilation method to implement the compiler for the MC68000 using MC68000 assembly language as the implementation language. Its performance is discussed in section 7.
Reference: [11] <author> Felleisen M., </author> <title> Friedman D.P., A closer look at export and import statements , Computer Language, </title> <month> 11 , 29-37 </month> <year> (1986). </year>
Reference-contexts: They can be used to express data abstractions [1], to implement actors [27] [32] and also to provide classes and data protection [34]. The work of Atkinson and Morrison [6] discusses their usefulness in implementing modules, separate compilation and database views. Felleisen and Friedman <ref> [11] </ref> show how to incorporate modules in Scheme via syntactic extensions which make use of closures. Closures are used here to represent compiled code. The possibility of naming computed values in order to ease their manipulation is a fundamental aspect of programming languages. This feature is provided by variables.
Reference: [12] <author> Forgy C. L., </author> <note> The OPS5 User's Manual . Technical Report CMU-CS-81-135, </note> <institution> Computer Science Department, Carnegie-Mellon University, Pittsburgh, Pennsylvania, </institution> <year> (1981). </year>
Reference-contexts: We would also need to write the primitive functions and a parser. But a more appropriate use of this technique would be for "embedded languages" within Scheme. These languages are often designed in artificial intelligence (e.g. MICRO-PLANNER [31], CONNIVER [22], OPS5 <ref> [12] </ref> and LCF [14]) and are usually implemented with an interpreter written in Lisp. Using the technique described in this paper we could easily compile those languages and the programs would run - 8 - much faster.
Reference: [13] <author> Gabriel R. P., Masinter L. M., </author> <title> Performance of Lisp Systems. </title> <booktitle> Conference record of the 1982 ACM Symposium on Lisp and Functional Programming , Pittsburgh, Pennsylvania, </booktitle> <pages> 123-142, </pages> <year> (1982). </year>
Reference-contexts: Performance We hav e conducted some benchmarks to measure the performance of the code generated by our method. Table 1 shows the run times for the evaluation of (fib 20), (tak 18 12 6) <ref> [13] </ref> which are the "classical tests" involving many recursive calls and integer arithmetic and (sort '(3 1 ...)) a selection sort of 70 numbers allocating many pairs and using tail recursion for iterating. These programs can be found in the appendix D. Relative times are shown in parenthesis.
Reference: [14] <author> Gordon M., Milner R., Wadsworth C., </author> <booktitle> Edinburgh LCF , Lecture Notes in Computer Science, </booktitle> <publisher> 78 , Springer-Verlag, </publisher> <address> New York, New York, </address> <year> (1979). </year>
Reference-contexts: We would also need to write the primitive functions and a parser. But a more appropriate use of this technique would be for "embedded languages" within Scheme. These languages are often designed in artificial intelligence (e.g. MICRO-PLANNER [31], CONNIVER [22], OPS5 [12] and LCF <ref> [14] </ref>) and are usually implemented with an interpreter written in Lisp. Using the technique described in this paper we could easily compile those languages and the programs would run - 8 - much faster.
Reference: [15] <author> Goto E., </author> <title> Monocopy and Associative Algorithms in an Extended Lisp . University of Tokyo, </title> <address> Japan, </address> <year> (1974). </year>
Reference-contexts: This list is checked on entering gen-ref and, if a corresponding closure is found, then it is given back otherwise it is added to the list and returned. This technique is similar to hash consing [5] <ref> [15] </ref> [33] but it applies to closures instead of pairs. This method could also be integrated in the closure generation mecanism.
Reference: [16] <author> Haraldsson A., </author> <title> A Partial Evaluator, </title> <booktitle> and Its Use for Compiling Iterative Statements in Lisp . Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages, Tuc son, Arizona, </booktitle> <pages> 195-202, </pages> <year> (1978). </year>
Reference-contexts: Its performance is discussed in section 7. The optimizations that have been described always dealt with closure generation but any other optimizations could also be used, for example: invariant removal, common subexpression elimination and expression simplifications [4] <ref> [16] </ref> [29]. Data and control ow analysis could also be computed [17] [18]. Many of these optimizations can be seen as source to source transformations as was done in the RABBIT Scheme compiler [29].
Reference: [17] <author> Hecht M. S., </author> <title> Data Flow Analysis of Computer Programs . American Elsevier, </title> <address> New York, New York, </address> <year> (1977). </year>
Reference-contexts: Its performance is discussed in section 7. The optimizations that have been described always dealt with closure generation but any other optimizations could also be used, for example: invariant removal, common subexpression elimination and expression simplifications [4] [16] [29]. Data and control ow analysis could also be computed <ref> [17] </ref> [18]. Many of these optimizations can be seen as source to source transformations as was done in the RABBIT Scheme compiler [29]. It would also be interesting to link this technique with the Orbit compiler [20] which has proven itself to be very efficient. 6.
Reference: [18] <author> Jones N. D., Muchnick S. S., </author> <title> Flow Analysis and Optimisation of LISP-like Structures. </title> <booktitle> Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages , 244-256, </booktitle> <address> San Antonio, Texas, </address> <year> (1979). </year>
Reference-contexts: Its performance is discussed in section 7. The optimizations that have been described always dealt with closure generation but any other optimizations could also be used, for example: invariant removal, common subexpression elimination and expression simplifications [4] [16] [29]. Data and control ow analysis could also be computed [17] <ref> [18] </ref>. Many of these optimizations can be seen as source to source transformations as was done in the RABBIT Scheme compiler [29]. It would also be interesting to link this technique with the Orbit compiler [20] which has proven itself to be very efficient. 6.
Reference: [19] <author> Klint P., </author> <title> Interpretation Techniques. </title> <note> Software-Practice and Experience , 11 , 963-973, </note> <year> (1981). </year>
Reference-contexts: The closures generated by the compilation of the subexpressions are passed to the code generation procedure to parameterize the behaviour of the closure it generates. The compilation of an expression has the effect of constructing a network of closures which is reminiscent of the code generated for threaded languages <ref> [19] </ref> [21]. Not surprizingly, the compiler has a structure very similar to an interpreter. Both receive data structures representing expressions, classify them and recursively traverse the compound ones.
Reference: [20] <author> Kranz D., Kelsey R., Rees J., Hudak P., Philbin J., Adams N., </author> <title> Orbit: an Optimizing Compiler for Scheme, </title> <booktitle> Proceedings of the SIGPLAN'86 Symposium on Compiler Construction , (1986). </booktitle>
Reference-contexts: Data and control ow analysis could also be computed [17] [18]. Many of these optimizations can be seen as source to source transformations as was done in the RABBIT Scheme compiler [29]. It would also be interesting to link this technique with the Orbit compiler <ref> [20] </ref> which has proven itself to be very efficient. 6. Application to other languages This code generation can also be used for other languages than Scheme.
Reference: [21] <author> Loeliger R. G., </author> <title> Threaded Interpretive Languages . Byte Books, </title> <address> Peterborough, New Hampshire, </address> <year> (1981). </year>
Reference-contexts: The compilation of an expression has the effect of constructing a network of closures which is reminiscent of the code generated for threaded languages [19] <ref> [21] </ref>. Not surprizingly, the compiler has a structure very similar to an interpreter. Both receive data structures representing expressions, classify them and recursively traverse the compound ones.
Reference: [22] <author> McDermott D., Sussman G. J., </author> <title> The CONNIVER Reference Manual . MIT Artificial Intelligence Memo 259A, </title> <address> Cambridge, Massachusetts, </address> <year> (1973). </year>
Reference-contexts: We would also need to write the primitive functions and a parser. But a more appropriate use of this technique would be for "embedded languages" within Scheme. These languages are often designed in artificial intelligence (e.g. MICRO-PLANNER [31], CONNIVER <ref> [22] </ref>, OPS5 [12] and LCF [14]) and are usually implemented with an interpreter written in Lisp. Using the technique described in this paper we could easily compile those languages and the programs would run - 8 - much faster.
Reference: [23] <institution> MIT Scheme Manual . Sev enth Edition, Cambridge, Massachusetts, </institution> <year> (1984). </year>
Reference-contexts: These programs can be found in the appendix D. Relative times are shown in parenthesis. We tested our implementation on two Scheme interpreters: - MIT C Scheme (version 6.1) <ref> [23] </ref> written in C, generating pseudo-code (S-code) and running on a SUN-2/50; - MacScheme (version 1.11)[26] written in MC68000 assembly language, generating pseudo-code (byte code) and running on a Macintosh Plus.
Reference: [24] <author> Rees J. A., Adams N. I., </author> <title> T: A Dialect of Lisp or, LAMBDA: The Ultimate Software Tool. </title> <booktitle> Confer ence record of the 1982 ACM Symposium on Lisp and Functional Programming , Pittsburgh, Penn sylvania, </booktitle> <pages> 114-122, </pages> <year> (1982). </year>
Reference-contexts: A complete example and improvements over the basic technique are then given. Finally, we explain how this technique can be applied to other languages and we analyse its performance. 2. Scheme and closures In many lexically scoped dialects of Lisp, e.g. Scheme [28] [1] [2], T <ref> [24] </ref> [25] and Common Lisp [30], procedures are first class objects. <p> The technique could also be implemented in another language than Scheme as long as the language enables the creation of closures or their equivalent. Many lexically scoped dialects of Lisp (e.g. T <ref> [24] </ref> or Common Lisp [30]) give closures as a primitive construct. But it can also be used within a language like Simula 67 [7] if closures are implemented with class instances. Feeley [9] gives the details of this implementation and a small example is given in appendix E.
Reference: [25] <author> Rees J. A., Adams N. I., Meehan J. </author> <title> R., </title> <institution> The T Manual . Computer Science Department, Yale Univer sity, New Hav en, </institution> <address> Connecticut, </address> <year> (1984). </year>
Reference-contexts: A complete example and improvements over the basic technique are then given. Finally, we explain how this technique can be applied to other languages and we analyse its performance. 2. Scheme and closures In many lexically scoped dialects of Lisp, e.g. Scheme [28] [1] [2], T [24] <ref> [25] </ref> and Common Lisp [30], procedures are first class objects.
Reference: [26] <author> Semantic Microsystems, </author> <title> MacScheme Reference Manual . Sausalito, </title> <address> California, </address> <year> (1985). </year>
Reference: [27] <author> Steele G. L., </author> <title> Lambda: </title> <booktitle> the ultimate declarative . MIT Artificial Intelligence Memo 379, </booktitle> <address> Cambridge, Massachusetts, </address> <year> (1976). </year>
Reference-contexts: This operation is called closure. We speak of the resulting procedure as being a closure. In fact, we shall consider them to be synonymous in this paper. Closures are a useful programming feature. They can be used to express data abstractions [1], to implement actors <ref> [27] </ref> [32] and also to provide classes and data protection [34]. The work of Atkinson and Morrison [6] discusses their usefulness in implementing modules, separate compilation and database views. Felleisen and Friedman [11] show how to incorporate modules in Scheme via syntactic extensions which make use of closures.
Reference: [28] <author> Steele G. L., Sussman G. J., </author> <title> The Revised Report on Scheme: A Dialect of Lisp . MIT Artificial Intel ligence Memo 452, </title> <address> Cambridge, Massachusetts, </address> <year> (1978). </year>
Reference-contexts: A complete example and improvements over the basic technique are then given. Finally, we explain how this technique can be applied to other languages and we analyse its performance. 2. Scheme and closures In many lexically scoped dialects of Lisp, e.g. Scheme <ref> [28] </ref> [1] [2], T [24] [25] and Common Lisp [30], procedures are first class objects. <p> Other constructs, such as begin, cond, and, or, let, letrec and others can be expressed with the primitive constructs <ref> [28] </ref> [29]. They are written as macros and are processed by the front-end of the compiler which is not discussed in this paper. Thus, we limit our discussion to these primitive constructs. The heart of the compiler is a procedure of one argument named gen.
Reference: [29] <author> Steele G. L., Rabbit: </author> <title> a compiler for Scheme . MIT Artificial Intelligence Memo 474, </title> <address> Cambridge, Massachusetts, </address> <year> (1978). </year>
Reference-contexts: Other constructs, such as begin, cond, and, or, let, letrec and others can be expressed with the primitive constructs [28] <ref> [29] </ref>. They are written as macros and are processed by the front-end of the compiler which is not discussed in this paper. Thus, we limit our discussion to these primitive constructs. The heart of the compiler is a procedure of one argument named gen. <p> Its performance is discussed in section 7. The optimizations that have been described always dealt with closure generation but any other optimizations could also be used, for example: invariant removal, common subexpression elimination and expression simplifications [4] [16] <ref> [29] </ref>. Data and control ow analysis could also be computed [17] [18]. Many of these optimizations can be seen as source to source transformations as was done in the RABBIT Scheme compiler [29]. <p> other optimizations could also be used, for example: invariant removal, common subexpression elimination and expression simplifications [4] [16] <ref> [29] </ref>. Data and control ow analysis could also be computed [17] [18]. Many of these optimizations can be seen as source to source transformations as was done in the RABBIT Scheme compiler [29]. It would also be interesting to link this technique with the Orbit compiler [20] which has proven itself to be very efficient. 6. Application to other languages This code generation can also be used for other languages than Scheme.
Reference: [30] <author> Steele G. L., </author> <title> Common Lisp: </title> <publisher> the Language . Digital Press, </publisher> <year> (1984). </year>
Reference-contexts: Finally, we explain how this technique can be applied to other languages and we analyse its performance. 2. Scheme and closures In many lexically scoped dialects of Lisp, e.g. Scheme [28] [1] [2], T [24] [25] and Common Lisp <ref> [30] </ref>, procedures are first class objects. <p> The technique could also be implemented in another language than Scheme as long as the language enables the creation of closures or their equivalent. Many lexically scoped dialects of Lisp (e.g. T [24] or Common Lisp <ref> [30] </ref>) give closures as a primitive construct. But it can also be used within a language like Simula 67 [7] if closures are implemented with class instances. Feeley [9] gives the details of this implementation and a small example is given in appendix E.
Reference: [31] <author> Sussman G. J., Winograd T., Charniak E., </author> <title> MICRO-PLANNER Reference Manual . MIT Artificial Intelligence Memo 203A, </title> <address> Cambridge, Massachusetts, </address> <year> (1971). </year>
Reference-contexts: We would also need to write the primitive functions and a parser. But a more appropriate use of this technique would be for "embedded languages" within Scheme. These languages are often designed in artificial intelligence (e.g. MICRO-PLANNER <ref> [31] </ref>, CONNIVER [22], OPS5 [12] and LCF [14]) and are usually implemented with an interpreter written in Lisp. Using the technique described in this paper we could easily compile those languages and the programs would run - 8 - much faster.
Reference: [32] <author> Sussman G. J., Steele G. L., </author> <title> Scheme: An Interpreter for extended Lambda Calculus . MIT Artificial Intelligence Memo 349, </title> <address> Cambridge, Massachusetts, </address> <year> (1975). </year> <month> - 11 </month> - 
Reference-contexts: This operation is called closure. We speak of the resulting procedure as being a closure. In fact, we shall consider them to be synonymous in this paper. Closures are a useful programming feature. They can be used to express data abstractions [1], to implement actors [27] <ref> [32] </ref> and also to provide classes and data protection [34]. The work of Atkinson and Morrison [6] discusses their usefulness in implementing modules, separate compilation and database views. Felleisen and Friedman [11] show how to incorporate modules in Scheme via syntactic extensions which make use of closures.
Reference: [33] <author> Terashima M., </author> <title> Algorithms Used in an Implementation of HLISP . Information Sciences Laboratory Technical Report 75-03, </title> <institution> University of Tokyo, </institution> <address> Japan, </address> <year> (1975). </year>
Reference-contexts: This list is checked on entering gen-ref and, if a corresponding closure is found, then it is given back otherwise it is added to the list and returned. This technique is similar to hash consing [5] [15] <ref> [33] </ref> but it applies to closures instead of pairs. This method could also be integrated in the closure generation mecanism. A hash table could be used to keep track of the closures generated and checked to see if a similar closure has already been generated before creating a new one.

References-found: 33

