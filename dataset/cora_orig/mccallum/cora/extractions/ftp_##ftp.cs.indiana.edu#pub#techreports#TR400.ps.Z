URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR400.ps.Z
Refering-URL: http://www.cs.indiana.edu/proglang/proglang.html
Root-URL: 
Title: Don't Stop the BIBOP: Flexible and Efficient Storage Management for Dynamically-Typed Languages  
Author: R. Kent Dybvig, David Eby, and Carl Bruggeman 
Note: Copyright c 1994  
Abstract: R. Kent Dybvig, David Eby, and Carl Bruggeman fdyb,deby,bruggemag@cs.indiana.edu Indiana University Computer Science Department Technical Report #400 March 1994 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25, </volume> <month> June </month> <year> 1987. </year>
Reference-contexts: If a nongenerational collector is used, the heap is subdivided into two equal-sized spaces; otherwise, the heap is divided into three or more spaces. Heap allocation using this model can be as fast as stack allocation <ref> [1] </ref>, since all objects can be allocated from a single allocation pointer kept in a register. Sophisticated versions of this model have been described that allow the spaces to be resized during collection and which, unlike most copying collectors, avoid touching all of memory on each collection cycle [2, 18]. <p> Typed objects and low tagged typed pointers do not require this separation. Objects of different type may be allocated in succession, so only a single allocation pointer is needed. By keeping this in a dedicated register, allocation can be made very quick <ref> [1] </ref>. An excellent survey of automatic storage reclamation techniques for dynamically allocated objects is provided by Wilson [24]. 3 Storage Management Framework Our storage management system employs a hybrid run-time tagging mechanism that incorporates elements of typed pointers, typed objects, and BIBOP typing (see Figure 1). <p> Where sufficient operating system support is available and trapping overhead is not too great, the first page beyond the new allocation area could be marked read-only so that attempts to write into it result in a trap <ref> [1] </ref>. In order to use this trick, the compiler must assure that at least one word per page in the object is written before the allocation operation is assumed to have succeeded.
Reference: [2] <author> Andrew W. Appel. </author> <title> Simple garbage collection and fast allocation. </title> <institution> Dept. of Computer Science CS-TR-143-88, Princeton University, Princeton, </institution> <address> NJ 08544, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: Sophisticated versions of this model have been described that allow the spaces to be resized during collection and which, unlike most copying collectors, avoid touching all of memory on each collection cycle <ref> [2, 18] </ref>. In many ways, the flat memory model is the simplest and most efficient model to use for automatic storage management. <p> Copying costs during garbage collection are eliminated for large objects without the need to treat them specially when they are allocated. The segmented memory model also yields better virtual memory behavior than the standard flat n-space memory model, as vacated pages are reused immediately after garbage collection. Appel <ref> [2] </ref> and Shaw [18, Chapter 6] have independently described a generation-based collector for a flat memory model with the same property.
Reference: [3] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(2) </volume> <pages> 153-162, </pages> <month> June </month> <year> 1989. </year> <month> 14 </month>
Reference-contexts: To determine an object's type, a memory reference is required to extract the tag 1 Code objects and weak pairs are distinguished immediately; see Section 3. 2 Our handling of stack frames is somewhat similar to tagless garbage collection methods <ref> [3] </ref>. 3 from the object. Typed objects can easily accomodate a large number of tags as the object can simply be made larger to increase the size of the tag. With typed pointers the type tag is included within the pointer to the object. <p> For large frames the live-pointer mask is a pointer to a variable-length heap-allocated mask. The live-pointer mask is similar to the type descriptors required to support tagless garbage collection <ref> [3] </ref>. 5.4 Weak pairs Weak pairs are identical to normal pairs except that they have a weak car field pointer. A weak pointer to an object is treated like a normal pointer so long as nonweak pointers to the object exist. <p> A possible extension of this work is to allow the compiler to use the metatyping mechanism to customize collector behavior at a much finer granularity in order support tagless garbage collection. For statically typed languages, like ML, type tags are required only for collection. Appel <ref> [3] </ref> has suggested associating a record describing the types of the frame elements with each activation record. Goldberg [14, 15] subsequently noted that the compiler could generate code the collector invokes directly rather than a record which the collector must interpret. <p> In either case, type information is determined only during the tracing phase of a collection. In order to use a nonrecursive breadth-first collector the type must be associated with the object during collection, although, as Appel <ref> [3] </ref> notes, the types can be stored separately from the objects, swept in parallel, and discarded after the collection. Our metatyping mechanism provides an alternative solution.
Reference: [4] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The distinction between common and uncommon types might be made dynamically based on actual object counts. In his book, Compiling with Continuations, Appel <ref> [4, page 211] </ref> makes a similar observation. He notes that with BIBOP typing for older generations, type tags can be removed from objects that survive their first garbage collection and associated with segments instead.
Reference: [5] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <note> WRL Research Report 88/2, </note> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <address> 100 Hamilton Avenue, Palo Alto, CA, 94301, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: They do not mention using metatypes for segregating objects based on characteristics, and they make no commitments with respect to typing or allocation since their system is intended to be language-independent. Bartlett's "mostly copying" collector <ref> [5] </ref> uses a segmented memory layout similar to ours in order to mark groups of objects pointed to by an ambiguous root set (whose values cannot be modified) as "forwarded" so that they need not be copied. Later work [6] associates a generation number with each segment as well.
Reference: [6] <author> Joel F. Bartlett. </author> <title> Mostly-copying garbage collection picks up generations and C++. </title> <type> Technical Note TN-12, </type> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <address> 100 Hamilton Avenue, Palo Alto, CA, 94301, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Bartlett's "mostly copying" collector [5] uses a segmented memory layout similar to ours in order to mark groups of objects pointed to by an ambiguous root set (whose values cannot be modified) as "forwarded" so that they need not be copied. Later work <ref> [6] </ref> associates a generation number with each segment as well.
Reference: [7] <author> Joel F. Bartlett. </author> <title> SCHEME-&gt;C a portable Scheme-to-C compiler. </title> <note> WRL Research Report 89/1, </note> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <address> 100 Hamilton Avenue, Palo Alto, CA, 94301, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: Later work [6] associates a generation number with each segment as well. In addition, Bartlett's Scheme-&gt;C implementation <ref> [7] </ref> uses metatyping to separate pairs from variable length objects, in order to simplify sweeping, and to mark segments as "continued" when an object spans a segment boundary so that the collector can find the beginning of the object.
Reference: [8] <institution> Cadence Research Systems, Bloomington, Indiana. Chez Scheme. </institution>
Reference-contexts: Since our segments are relatively small (currently 4K bytes), objects need not be extremely large to benefit from this optimization. The storage management system described in this paper has been implemented and is in use as part of Chez Scheme, a high-performance implementation of Scheme <ref> [8] </ref>. Although hybrid typing mechanisms and segmented memory models are not entirely new, we believe we are the first to implement a segmented memory model using an extensive set of metatypes with fast inline allocation. <p> This storage management system is used by Chez Scheme <ref> [8] </ref> on a variety of architectures under several operating systems with widely varying capabilities. Use of the segmented memory model and BIBOP metatyping results in no overhead outside of the garbage collector.
Reference: [9] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for an Object-Oriented Programming Language. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1992. </year>
Reference-contexts: Our system uses bytes rather than bits to store the dirty marks for two reasons. First, it is typically faster to write a byte than to set a single bit <ref> [9, Chapter 6] </ref>. Second, because the garbage collector supports more than two generations, it is useful to know for each card the youngest generation to which a pointer exists, rather than simply whether a pointer to some younger generation exists.
Reference: [10] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <year> 1970. </year>
Reference-contexts: If the object is reached without going through the pointer, however, its type cannot be determined since the tag is stored apart from the object. This happens, for example, during the sweep phase of a breadth-first copying garbage collector <ref> [10] </ref>. One solution to this problem is to require the garbage collector to insert type descriptors as it copies objects, while their types are still available. Some types of objects, e.g., fixnums and characters, can be encoded in a small number of bits.
Reference: [11] <author> R. Kent Dybvig, Carl Bruggeman, and David Eby. </author> <title> Guardians in a generation-based garbage collector. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Design and Implementation, </booktitle> <pages> pages 207-216. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: In this case, a known value, such as false, is left in the car field to indicate the loss. Like code objects, weak pairs are segregated from other objects when they are allocated because they require special treatment by the garbage collector <ref> [11] </ref>. They are identical in every other way to normal pairs.
Reference: [12] <author> John R. Ellis, Kai Li, and Andrew W. Appel. </author> <title> Real-time concurrent collection on stock multiprocessors. </title> <institution> Systems Research Center 25, Digital Equipment Corp., </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Although his system supports fast inline allocation, doing so is trivial since only two allocation pointers are required to handle the two metatypes his system supports. The page-based incremental collector described by Ellis <ref> [12] </ref> also uses a "boundary crossing" table to enable the collector to find the beginning of an object that crosses page boundaries. This can be seen as a simple use of metatyping.
Reference: [13] <author> Scott E. Fahlman and David B. McDonald. </author> <title> Design considerations for CMU common lisp. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Advanced Language Implementation, chapter 6, </booktitle> <pages> pages 137-156. </pages> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: On the other hand, these bits could be used as part of the address. In this case, the address space is divided into several distinct type regions, with objects of the same type being allocated into the same region <ref> [13] </ref>. This separation removes the need for type descriptors during garbage collection as object type may be determined by address. Each object type is assigned a type region with its own allocation pointer.
Reference: [14] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection for stongly typed programming languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 165-176. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: For statically typed languages, like ML, type tags are required only for collection. Appel [3] has suggested associating a record describing the types of the frame elements with each activation record. Goldberg <ref> [14, 15] </ref> subsequently noted that the compiler could generate code the collector invokes directly rather than a record which the collector must interpret. In either case, type information is determined only during the tracing phase of a collection.
Reference: [15] <author> Benjamin Goldberg and Michael Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> In Proceedings of the 1992 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 53-65. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: For statically typed languages, like ML, type tags are required only for collection. Appel [3] has suggested associating a record describing the types of the frame elements with each activation record. Goldberg <ref> [14, 15] </ref> subsequently noted that the compiler could generate code the collector invokes directly rather than a record which the collector must interpret. In either case, type information is determined only during the tracing phase of a collection.
Reference: [16] <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Design and Implementation, </booktitle> <pages> pages 66-77. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: The code object offset is stored with the live-pointer mask behind the return point so that the code object can be relocated and the updated return address computed. Stacks are "walked" by the collector using frame size information also stored behind the return point <ref> [16] </ref>. 11 live-pointer mask, and the code object offset.
Reference: [17] <author> Richard L. Hudson, J. Eliot B. Moss, Amer Diwan, and Christopher F. </author> <title> Weight. A language-independent garbage collector toolkit. </title> <institution> Dept. of Computer and Information Science COINS Technical Report 91-47, University of Massachusetts, Amherst, Object Oriented Systems Laboratory, Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> September </month> <year> 1991. </year> <month> 15 </month>
Reference-contexts: More importantly, once collection is over, the segments just vacated can be recycled immediately for new allocation while they still reside in physical memory. These effects are also noted by Hudson <ref> [17] </ref>. Allocation by other run-time systems is easily handled through metatyping. <p> The large object area is managed as a free list. Hudson <ref> [17] </ref> also stores large objects in an area separate from the main heap, but does not introduce the indirection required to go through an object header for Ungar's mechanism. Instead, the generation for each object is recorded with the object itself. <p> He does not mention how he would handle fragmentation caused by the proliferation of types. This fragmentation could be especially serious with the large segment size he suggests (64K bytes). Like our storage management system, the language-independent garbage-collection toolkit described by Hudson <ref> [17] </ref> divides memory up into segments (called blocks). They do so in order to reduce memory demand (compared to a standard semi-space collector) and to support a generation-based collector with a varying number of generations of varying size.
Reference: [18] <author> Robert A. Shaw. </author> <title> Emperical Analysis of A Lisp System. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Sophisticated versions of this model have been described that allow the spaces to be resized during collection and which, unlike most copying collectors, avoid touching all of memory on each collection cycle <ref> [2, 18] </ref>. In many ways, the flat memory model is the simplest and most efficient model to use for automatic storage management. <p> By using the known constant to adjust the field offset for the field being referenced, the access may be done with little or no extra cost <ref> [18, Chapter 3] </ref>. To use typed pointers with the tag in the high bits, address extraction is more complicated for most platforms. Some architectures have a word size larger than the address size and ignore the upper bits for addressing purposes. <p> The segmented memory model also yields better virtual memory behavior than the standard flat n-space memory model, as vacated pages are reused immediately after garbage collection. Appel [2] and Shaw <ref> [18, Chapter 6] </ref> have independently described a generation-based collector for a flat memory model with the same property. A possible extension of this work is to allow the compiler to use the metatyping mechanism to customize collector behavior at a much finer granularity in order support tagless garbage collection.
Reference: [19] <author> Patrick G. Sobalvarro. </author> <title> A lifetime-based garbage collector for LISP systems on general-purpose computers. B.S. </title> <type> Thesis, </type> <institution> Massachusetts Institute of Technology, Electrical Engineering and Computer Science Department, </institution> <address> Cambridge, MA., </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Our mechanisms for collecting stacks and code objects, which both contain a mix of pointer and nonpointer data, are also new 2 (see Section 5.3). We also describe a variant of card marking <ref> [19, 25] </ref> for remembering pointers from older generations to newer ones. This variant allows us to perform the marking inline while maintaining a record of the youngest generation involved, reducing card sweeping overhead when more than two generations are used. <p> A segment's generation number is orthogonal to other metatype information, so each generation may encompass segments of many different metatypes. 9 In the remainder of this section we describe some of the applications for which metatypes are used in the current implementation. 5.1 Card marking The card marking <ref> [19, 25] </ref> mechanism for tracking pointers from older generations to newer generations fits well with the BIBOP heap organization. The dirty marks used to record that an assignment has occurred to an object within a card are simply another form of metatype information to be tracked for each segment.
Reference: [20] <author> Guy Steele, Jr. </author> <title> Data representation in PDP-10 MACLISP. MIT AI Memo 421, </title> <institution> Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1977. </year>
Reference-contexts: The system described in this paper, therefore, makes use of the Big Bag of Pages (BIBOP) typing mechanism, which views memory as a group of equal-sized segments with an associated type table mapping segment numbers to types <ref> [20] </ref>. BIBOP typing has fallen into disfavor in recent years because newer type systems provide faster allocation and type manipulation and because of percevied problems with the handling of large objects. We have found, however, that these problems can be eliminated through the use of a hybrid typing system. <p> Immediate values may be encoded as for typed pointers, but as these values correspond to virtual addresses, portions of the address space will be made unavailable. The BIBOP typing mechanism <ref> [20] </ref> also employs a representation in which the object's type is determined by the high bits of its address. Rather than encoding a type tag, however, these bits represent an index into a table where the type is stored.
Reference: [21] <author> P.A. Steenkiste. </author> <title> Tags and run-time type checking. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Advanced Language Implementation, chapter 1, </booktitle> <pages> pages 3-24. </pages> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Section 4 describes some of the benefits derived from the segmented memory model. Section 5 describes how the system exploits metatype distinctions. Finally, Section 6 summarizes the paper and discusses related work. 2 Type Representation There are several common mechanisms for dynamic allocation and typing of objects <ref> [21] </ref>. The simplest representation is that provided by typed objects, in which the type tag is stored explicitly within the object. The pointer to the object carries no information other than the object's location. <p> All objects are allocated on eight-byte boundaries allowing the low three bits to be used as a type tag. Low-tagged pointers incur little or no run-time overhead for allocation, integer arithmetic, and field dereference, and type testing involves only a mask and compare <ref> [21] </ref>. Using a larger tag (and a correspondingly coarser alignment boundary) would result in increased storage fragmentation to maintain the object alignment restriction. Three tag bits, however, do not suffice to encode all Scheme object types.
Reference: [22] <author> David Ungar and Frank Jackson. </author> <title> Tenuring policies for generation-based storage reclamation. </title> <booktitle> In OOPSLA '88 Conference Proceedings, </booktitle> <pages> pages 1-17. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> September </month> <year> 1988. </year>
Reference-contexts: A byte set to the maximum possible generation number, ff 16 , denotes a totally clean card, so the bit pattern ffffffff 16 denotes four totally clean cards. (See Figure 1.) 5.2 Large object handling Ungar notes that substantial gains may be made by treating large objects specially <ref> [22, 23] </ref>. In his system, objects are reachable only through their headers.
Reference: [23] <author> David Ungar and Frank Jackson. </author> <title> An adaptive tenuring policy for generation scavengers. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(1) </volume> <pages> 1-27, </pages> <year> 1992. </year>
Reference-contexts: A byte set to the maximum possible generation number, ff 16 , denotes a totally clean card, so the bit pattern ffffffff 16 denotes four totally clean cards. (See Figure 1.) 5.2 Large object handling Ungar notes that substantial gains may be made by treating large objects specially <ref> [22, 23] </ref>. In his system, objects are reachable only through their headers.
Reference: [24] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Yves Bekkers and Jacques Co-hen, editors, </editor> <booktitle> Memory Management: IWMM 92 proceedings, </booktitle> <pages> pages 1-42. </pages> <booktitle> INRIA in cooperation with ACM SIGPLAN, </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: Objects of different type may be allocated in succession, so only a single allocation pointer is needed. By keeping this in a dedicated register, allocation can be made very quick [1]. An excellent survey of automatic storage reclamation techniques for dynamically allocated objects is provided by Wilson <ref> [24] </ref>. 3 Storage Management Framework Our storage management system employs a hybrid run-time tagging mechanism that incorporates elements of typed pointers, typed objects, and BIBOP typing (see Figure 1). Low tagged typed pointers are used for primary typing.
Reference: [25] <author> Paul R. Wilson and Thomas G. Moher. </author> <title> Design of the opportunistic garbage collector. </title> <booktitle> In OOPSLA '89 Conference Proceedings, </booktitle> <pages> pages 23-35. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1989. </year> <month> 16 </month>
Reference-contexts: Our mechanisms for collecting stacks and code objects, which both contain a mix of pointer and nonpointer data, are also new 2 (see Section 5.3). We also describe a variant of card marking <ref> [19, 25] </ref> for remembering pointers from older generations to newer ones. This variant allows us to perform the marking inline while maintaining a record of the youngest generation involved, reducing card sweeping overhead when more than two generations are used. <p> A segment's generation number is orthogonal to other metatype information, so each generation may encompass segments of many different metatypes. 9 In the remainder of this section we describe some of the applications for which metatypes are used in the current implementation. 5.1 Card marking The card marking <ref> [19, 25] </ref> mechanism for tracking pointers from older generations to newer generations fits well with the BIBOP heap organization. The dirty marks used to record that an assignment has occurred to an object within a card are simply another form of metatype information to be tracked for each segment.
References-found: 25

