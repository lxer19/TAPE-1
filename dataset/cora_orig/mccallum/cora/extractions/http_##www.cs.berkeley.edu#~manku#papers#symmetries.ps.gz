URL: http://www.cs.berkeley.edu/~manku/papers/symmetries.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~manku/papers-abstracts.html
Root-URL: 
Email: manku@almaden.ibm.com rhojati@hdac.com brayton@eecs.berkeley.edu  
Title: Structural Symmetries and Model Checking  
Author: Gurmeet Singh Manku Ramin Hojati Robert K Brayton 
Address: Berkeley  
Affiliation: IBM Almaden Research Centre UC Berkeley and HDAC Inc. UC  
Abstract: We present a fully automatic framework for identifying symmetries in structural descriptions of digital circuits and CTL* formulas and using them in a model checker. The set of sub-formulas of a formula is partitioned into equivalence classes so that truth values for only one sub-formula in any class need be evaluated for model checking. Structural symmetries in net-list descriptions of digital circuits and CTL* formulas are formally defined and their relationship with the corresponding Kripke structures is described. A technique for automatic identification of structural symmetries is described that requires computation of the automorphism group of a suitable labeled directed graph. A novel fast algorithm for this problem is presented. Finally, experimental results are reported for BLIF-MV net-lists derived from Verilog. 
Abstract-found: 1
Intro-found: 1
Reference: [AE89] <author> P. C. Attie and E. A. Emerson. </author> <title> Synthesis of Concurrent Systems with many Similar Sequential Processes. </title> <booktitle> Proc. 16th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 191-201, </pages> <year> 1989. </year>
Reference-contexts: Huber, Jepsen and Jensen [HJJ84] and Starke [Sta91] have investigated the use of symmetries for expediting reachability analysis for Petri nets. An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan [Kur87] and Attie and Emerson <ref> [AE89] </ref>. The approach uses quotient structures induced by au-tomorphisms of the system. The survey by Pong and Dubois [PD97] shows how symmetries can benefit verification of cache consistency protocols. Symmetries have also been shown to speedup transistor-level verification of digital circuits [PB97].
Reference: [AT96] <author> M. Agrawal and T. Thierauf. </author> <title> The Boolean Iso-morphism Problem. </title> <booktitle> In Proc. Symp. on Foundations of Computer Science, </booktitle> <pages> pages 422-430, </pages> <address> Burlington, Ver-mont, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: structures. 3.2 Computing Equivalence Classes Given G Aut M LAP and a CTL* formula f , how do we find two sub-formulas g and h such that g G h? This is a computationally hard problem even if f is a simple boolean formula without path operators or temporal quantifiers <ref> [AT96] </ref>. If we replace G by G s , the problem is as hard as graph isomorphism [Man97]. We now outline a technique that can identify symmetric sub-formulas if the symmetry in the specification is reflected in the formula as well, which is true in practice.
Reference: [B + 91] <author> R. K. Brayton et al. BLIF-MV: </author> <title> An Interchange Format for Design Verification and Synthesis. </title> <type> Technical Report UCB/ERL M91/97, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> Novem-ber </month> <year> 1991. </year>
Reference-contexts: In both the cases, we need to compute G 1 H. We now describe how G, H and G 1 H can be computed automatically from net-lists of digital circuits and CTL* formulas, with no assistance from the designer. We have chosen BLIF-MV <ref> [B + 91] </ref> as a representative structural hardware description language. 5.1 Characterizing a BLIF-MV Circuit We model a BLIF-MV circuit as a five tuple C = hI; O; L; T ; Si, consisting of a set of primary input ports I, a set of primary output ports O, a set of <p> Let Aut C L AP denote the set of all such permutations. It can be verified that Theorem 5 still holds. A detailed proof can be found in [Man97], which also shows how multiple-output tables, the "=" construct <ref> [B + 91] </ref>, pseudo inputs and other special cases 5 can be handled. The size of the graph is linear in the size of the flattened BLIF-MV description. Here are two interesting theoretical questions: 1. Is every group possible? Let G Aut M L AP . <p> At most n 1 iterations are required. In practice, a few iterations suffice. See Table 1 on the next page. 7 Experimental Results We have implemented an algorithm for constructing a graph from a BLIF-MV <ref> [B + 91] </ref> description, as described in Section 5.
Reference: [B + 96] <author> R.K. Brayton et al. </author> <title> VIS: A System for Verification and Synthesis. </title> <booktitle> In Proc. 8th Intl. Conf. on Computer Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-432. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Both programs are integrated with VIS <ref> [B + 96] </ref>. The source code for our work is available at http://www-cad.eecs.berkeley.edu/~manku/symmetries/. We implemented the algorithm in Figure 3 to convince ourselves that our modeling of the circuit is sufficient to allow discovering symmetries.
Reference: [BCL + 94] <author> J. R. Burch, E. M. Clarke, D. E. Long, K. L. McMillan, and D. L. Dill. </author> <title> Symbolic Model Checking for Sequential Circuit Verification. </title> <journal> IEEE Tran. on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Temporal model checking algorithms <ref> [CES86, CMB90, TS + 90, BCL + 94] </ref> typically explore the states of a non-deterministic finite state machine that represents the system under scrutiny. A major bottleneck is the exponential number of states that need be explored. This is commonly known as State Space Explosion. <p> Their algorithm is linear in the size of the formula and the number of states. A Binary Decision Diagrams (BDDs) [Bry86] based symbolic model checker that can handle more than 10 120 states on some pipelined circuits has been described by Burch et al <ref> [BCL + 94] </ref>. 2.4 Permutation Groups A permutation is a bijective mapping : S ! S defined over a finite non-empty set S. We denote the action of on an element s 2 S by s. We use H G to denote that H is a subgroup of G.
Reference: [BFJ89] <author> C. A. Brown, L. Finkelstein, and P. W. Purdom Jr. </author> <title> A New Base Change Algorithm for Permutation Groups. </title> <journal> SIAM J. Computing, </journal> <volume> 18(5) </volume> <pages> 1037-1047, </pages> <month> Octo-ber </month> <year> 1989. </year>
Reference-contexts: We run the algorithm in Figure 3 on the page before. We also maintain the group formed by automorphisms discovered so far using Jerrum's labeled branchings [Jer86], which we augment as new automorphisms are discovered. As we backtrack, we dynamically change base using the algorithms in <ref> [BFJ89] </ref>. As we branch, we use the pruning mechanism described in [BL85] to avoid rediscovering any automorphism already in the group.
Reference: [BL85] <author> G. Butler and C. W. H. Lam. </author> <title> A General Backtrack Algorithm for the Isomorphism Problem of Combinatorial Objects. </title> <journal> J. Symbolic Computation, </journal> <volume> 1 </volume> <pages> 363-381, </pages> <year> 1985. </year>
Reference-contexts: We also maintain the group formed by automorphisms discovered so far using Jerrum's labeled branchings [Jer86], which we augment as new automorphisms are discovered. As we backtrack, we dynamically change base using the algorithms in [BFJ89]. As we branch, we use the pruning mechanism described in <ref> [BL85] </ref> to avoid rediscovering any automorphism already in the group. We initially experimented with a software package for manipulating graphs and groups, GAP [Gap], which has a graph automorphism program called nauti [McK90] based on one of the earliest such programs written by McKay [McK81].
Reference: [Bry86] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35:677-691, </volume> <month> August </month> <year> 1986. </year> <month> 10 </month>
Reference-contexts: Their algorithm is linear in the size of the formula and the number of states. A Binary Decision Diagrams (BDDs) <ref> [Bry86] </ref> based symbolic model checker that can handle more than 10 120 states on some pipelined circuits has been described by Burch et al [BCL + 94]. 2.4 Permutation Groups A permutation is a bijective mapping : S ! S defined over a finite non-empty set S.
Reference: [But91] <author> G. Butler. </author> <title> Fundamental Algorithms for Permutation Groups, </title> <booktitle> volume 559 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Here is a brief description: Permutation groups are typically represented using a base and strong generating set [Sim70]. See <ref> [But91] </ref> for a good exposition. We run the algorithm in Figure 3 on the page before. We also maintain the group formed by automorphisms discovered so far using Jerrum's labeled branchings [Jer86], which we augment as new automorphisms are discovered.
Reference: [CEFJ96] <author> E. M. Clarke, R. Enders, T. Filkorn, and S. Jha. </author> <title> Exploiting Symmetry in Temporal Logic Model Checking. </title> <booktitle> Formal Methods in System Design, </booktitle> 9(1/2):77-104, 1996. 
Reference-contexts: The approach uses quotient structures induced by au-tomorphisms of the system. The survey by Pong and Dubois [PD97] shows how symmetries can benefit verification of cache consistency protocols. Symmetries have also been shown to speedup transistor-level verification of digital circuits [PB97]. Emerson and Sistla [ES96] and Clarke et al <ref> [CEFJ96] </ref> show how symmetries in Kripke structures and CTL* formulas allow the construction of a smaller sized quotient structure such that the formula need be verified only for the quotient. In both works, symmetries are specified by hand by the designer. <p> The representation for G 1 H would allow us to easily identify the partitions induced by G1H s and produce witnesses that transform one sub-formula into another. 4 Quotient Structures In this section, we develop a theory of symmetries for Kripke structures, extending those developed by Clarke et al <ref> [CEFJ96] </ref> and Emerson and Sistla [ES96]. Definition of [[s]] G and ~ G Let M = (S; R; K) be a Kripke structure with 2 L states. Let G Aut M L X for some set of labels X AP . <p> X for some set of labels X, the quotient structure is defined as M G = (S G ; R G ; K G ), where S G = f [[s]] G j s 2 Sg K G ([[s]] G ) = K (~ G (s)) The fundamental result in <ref> [CEFJ96] </ref> is captured by the following theorem: Theorem 3 [CEFJ96] For a Kripke structure M = (S; R; K) and a group G Aut M L AP , if (8 2 G)(8p 2 AP )(p = p), then (8s 2 S)((M; s j= f) , (M G ; [[s]] G j= <p> structure is defined as M G = (S G ; R G ; K G ), where S G = f [[s]] G j s 2 Sg K G ([[s]] G ) = K (~ G (s)) The fundamental result in <ref> [CEFJ96] </ref> is captured by the following theorem: Theorem 3 [CEFJ96] For a Kripke structure M = (S; R; K) and a group G Aut M L AP , if (8 2 G)(8p 2 AP )(p = p), then (8s 2 S)((M; s j= f) , (M G ; [[s]] G j= f)) for any CTL* formula f. 2 Application of <p> We note that computation of the corresponding H and G 1 H can indeed be automated. Once we have constructed G 1 H, how do we use it to expedite model checking? A detailed exposition can be found in <ref> [ES96, CEFJ96] </ref>. Briefly, we need to compute the canonical state function ~ G1H and modify the model checker so that it canonicalizes every state encountered during state space traversal. The problem of computing ~ G1H has not been completely solved.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction Temporal model checking algorithms <ref> [CES86, CMB90, TS + 90, BCL + 94] </ref> typically explore the states of a non-deterministic finite state machine that represents the system under scrutiny. A major bottleneck is the exponential number of states that need be explored. This is commonly known as State Space Explosion. <p> due to the commutativity of some operators. 2.3 Model Checking Problem Given a set of atomic propositions AP , a Kripke structure M = (S; R; K), a CTL* formula f and a set of initial states I S, does every state in I satisfy f? Clarke, Emerson and Sistla <ref> [CES86] </ref> presented the first algorithm for CTL model checking based on explicit state space exploration. Their algorithm is linear in the size of the formula and the number of states.
Reference: [CMB90] <author> O. Coudert, J. C. Madre, and C. Berthet. </author> <title> Verifying Temporal Properties of Sequential Machines Without Building Their State Diagrams. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Proc. Workshop on Computer-Aided Verification, volume 3 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 23-32. </pages> <publisher> American Mathematical Society, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Temporal model checking algorithms <ref> [CES86, CMB90, TS + 90, BCL + 94] </ref> typically explore the states of a non-deterministic finite state machine that represents the system under scrutiny. A major bottleneck is the exponential number of states that need be explored. This is commonly known as State Space Explosion.
Reference: [CYB93] <author> S.-T. Cheng, G. York, and R. K. Brayton. VL2MV: </author> <note> A Compiler from Verilog to BLIF-MV, Oc-tober 1993. </note>
Reference-contexts: She can provide a bipartition using her intuition and ratify it by running our algorithm. Then she can use symmetric sub-formulas as described in Section 3.1. Starting with a Verilog description, we obtain a BLIF-MV description using a compiler called vl2mv written by Cheng <ref> [CYB93] </ref>. The BLIF-MV description is flattened using a standard VIS command. The flattened description and a bipartition is then fed to our program which first generates a suitable labeled directed graph, then refines the labels using the techniques mentioned in Section 6.3 and finally runs the branch and bound algorithm.
Reference: [EH86] <author> E. A. Emerson and J. Y. Halpern. </author> <title> "Sometimes"and "Not Never" Revisited: on Branching versus Linear Time Temporal Logic. </title> <journal> J. of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <year> 1986. </year>
Reference-contexts: In the context of hardware verification, L corresponds to the set of latches, AP corresponds to the set of outputs of the circuit and K represents boolean functions of latches that generate the outputs. 2.2 Temporal Logic CTL* CTL* <ref> [EH86] </ref> is the set of all strings in S generated by the following grammar: S ! hAP i j :S j S _ S j E (P) where hAP i denotes any proposition p 2 AP , S denotes a set of state formulas that evaluate to true in a specific
Reference: [EJP97] <author> E. A. Emerson, S. Jha, and D. Peled. </author> <title> Combining Partial Order and Symmetry Reductions. </title> <editor> In E. Brinksma, editor, </editor> <booktitle> Proc. Third Intl. Workshop on Tools and Algorithms for the Construction and Analysis of Systems, </booktitle> <pages> pages 19-34. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1997. </year>
Reference-contexts: In both works, symmetries are specified by hand by the designer. Emerson and Sistla [ES95] have developed theory for using symmetries with fairness constraints. Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Emer-son, Jha and Peled <ref> [EJP97] </ref> have developed theory for combining partial orders and symmetries. Ip and Dill [ID96] use symmetries for speeding up verification of safety properties using explicit techniques for designs specified in a guarded command language.
Reference: [ES95] <author> E. A. Emerson and A. P. Sistla. </author> <title> Utilizing Symmetry when Model Checking under Fairness Assumptions: An Automata-theoretic Approach. </title> <editor> In P. Wolper, editor, </editor> <booktitle> Proc. 7th Intl. Conf. on Computer Aided Verification, </booktitle> <pages> pages 309-324. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1995. </year>
Reference-contexts: In both works, symmetries are specified by hand by the designer. Emerson and Sistla <ref> [ES95] </ref> have developed theory for using symmetries with fairness constraints. Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Emer-son, Jha and Peled [EJP97] have developed theory for combining partial orders and symmetries.
Reference: [ES96] <author> E. A. Emerson and A. P. Sistla. </author> <title> Symmetry and Model Checking. </title> <booktitle> Formal Methods in System Design, </booktitle> 9(1/2):105-131, 1996. 
Reference-contexts: The approach uses quotient structures induced by au-tomorphisms of the system. The survey by Pong and Dubois [PD97] shows how symmetries can benefit verification of cache consistency protocols. Symmetries have also been shown to speedup transistor-level verification of digital circuits [PB97]. Emerson and Sistla <ref> [ES96] </ref> and Clarke et al [CEFJ96] show how symmetries in Kripke structures and CTL* formulas allow the construction of a smaller sized quotient structure such that the formula need be verified only for the quotient. In both works, symmetries are specified by hand by the designer. <p> 1 H would allow us to easily identify the partitions induced by G1H s and produce witnesses that transform one sub-formula into another. 4 Quotient Structures In this section, we develop a theory of symmetries for Kripke structures, extending those developed by Clarke et al [CEFJ96] and Emerson and Sistla <ref> [ES96] </ref>. Definition of [[s]] G and ~ G Let M = (S; R; K) be a Kripke structure with 2 L states. Let G Aut M L X for some set of labels X AP . <p> In the extreme case, we could have AP = L, giving each state a unique label. As a consequence, G is trivial and the quotient structure is not smaller than the original. Emerson and Sistla <ref> [ES96] </ref> present a generalization of Theorem 3. However, their theory is built for Kripke structures derived from systems of communicating isomorphic processes, the set of atomic propositions being the set of shared variables. In our terminology, it amounts to assuming AP = L and a single initial state. <p> In the next section, we will show how the three steps can be carried out automatically. Theorem 4 can be further extended along the lines of Auto f in <ref> [ES96] </ref>. Briefly, it amounts to introducing an additional set of labels corresponding to all sub-formulas that have E; X or U as the topmost operator. Due to lack of time, we omit the extended theorem and its proof from this paper. <p> We note that computation of the corresponding H and G 1 H can indeed be automated. Once we have constructed G 1 H, how do we use it to expedite model checking? A detailed exposition can be found in <ref> [ES96, CEFJ96] </ref>. Briefly, we need to compute the canonical state function ~ G1H and modify the model checker so that it canonicalizes every state encountered during state space traversal. The problem of computing ~ G1H has not been completely solved.
Reference: [FH + 83] <author> G. Fowler, R. Haralick, et al. </author> <title> Efficient Graph Automorphism by Vertex Partitioning. </title> <journal> Aritificial Intelligence, </journal> <volume> 21 </volume> <pages> 245-269, </pages> <year> 1983. </year>
Reference-contexts: Some such functions that satisfy U min 4 U are easy to compute. The intersection of two such functions U 1 f U 2 is also guaranteed to be at least as coarse as U min . Such functions are called vertex invariants <ref> [FH + 83] </ref>. Some vertex invariants that can be computed in O (m + n) time are the in-degree and out-degree of vertices, the set of degrees of vertices incident at a vertex and the set of degrees of vertices which a vertex is incident upon. <p> Some more expensive vertex invariants are discussed in <ref> [SD76, FH + 83, McK90] </ref>. An important trick is to treat a unipartition U as a labeling function and use it to refine itself. For a vertex v, let U 0 compute the set of labels of vertices incident upon v. <p> For a vertex v, let U 0 compute the set of labels of vertices incident upon v. Then U 0 is a vertex invariant such that U min 4 U 0 <ref> [FH + 83] </ref>. U can be refined by computing U f U 0 in O (m + n) time repeatedly. At most n 1 iterations are required. In practice, a few iterations suffice.
Reference: [Gap] <author> GAP: </author> <title> Groups, Algorithms and Programs, </title> <note> Version 3, Release 4. Available via ftp from ftp.math.rwth-aachen.de, </note> <institution> Lehrstuhl D fuer Mathe-matik, RWTH Aachen, Germany; directory /pub/gap. </institution>
Reference-contexts: As we backtrack, we dynamically change base using the algorithms in [BFJ89]. As we branch, we use the pruning mechanism described in [BL85] to avoid rediscovering any automorphism already in the group. We initially experimented with a software package for manipulating graphs and groups, GAP <ref> [Gap] </ref>, which has a graph automorphism program called nauti [McK90] based on one of the earliest such programs written by McKay [McK81]. A natural question to ask is: Why write another graph automorphism program? Existing packages are general purpose and carry around a lot of baggage.
Reference: [GS97] <author> V. Gyuris and A. P. Sistla. </author> <title> On-the-Fly Model Checking under Fairness that Exploits Symmetry. </title> <booktitle> In Proc. 9th Intl. Conf. on Computer Aided Verification, </booktitle> <address> Haifa, Israel, </address> <month> June </month> <year> 1997, </year> <booktitle> volume 1254 of Lecture Notes in Computer Science, </booktitle> <pages> pages 232-243. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: In both works, symmetries are specified by hand by the designer. Emerson and Sistla [ES95] have developed theory for using symmetries with fairness constraints. Gyuris and Sistla <ref> [GS97] </ref> have developed an on-the-fly model checker that utilizes symmetries under fairness. Emer-son, Jha and Peled [EJP97] have developed theory for combining partial orders and symmetries. Ip and Dill [ID96] use symmetries for speeding up verification of safety properties using explicit techniques for designs specified in a guarded command language.
Reference: [HJJ84] <author> P. Huber, L. Jepsen, and K. Jensen. </author> <title> Towards Reachability Trees for High-level Petri Nets. </title> <editor> In G. Rozenberg, editor, </editor> <booktitle> Advances on Petri Nets, </booktitle> <pages> pages 215-233, </pages> <year> 1984. </year>
Reference-contexts: This is commonly known as State Space Explosion. Among the techniques being developed for countering this problem are partial order methods, abstraction, compositional approaches, and symmetry reductions. Symmetries abound in hardware circuits, distributed algorithms and concurrent programs. Huber, Jepsen and Jensen <ref> [HJJ84] </ref> and Starke [Sta91] have investigated the use of symmetries for expediting reachability analysis for Petri nets. An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan [Kur87] and Attie and Emerson [AE89]. The approach uses quotient structures induced by au-tomorphisms of the system.
Reference: [Hof80] <author> C. M. Hoffman. </author> <title> On the Complexity of Intersecting Permutation Groups and its Relationship with Graph Isomorphism. </title> <type> Technical Report 4/80, </type> <institution> Institut for Informatik und Praktische Mathematik, Christian-Albrechts-Universitat Kiel, </institution> <year> 1980. </year>
Reference-contexts: An advantage of this idea is that we would need to compute G only once. We can compute different groups H for different formulas f . However, computing group intersections is as hard as graph isomorphism <ref> [Hof80] </ref>, though polynomial time algorithms do exist for special cases. A simpler approach is to join the two graphs corresponding to G and H together at the vertices corresponding to AP .
Reference: [ID96] <author> C. N. Ip and D. L. Dill. </author> <title> Better Verification Through Symmetry. </title> <booktitle> Formal Methods in System Design, </booktitle> 9(1/2):41-76, 1996. 
Reference-contexts: Emerson and Sistla [ES95] have developed theory for using symmetries with fairness constraints. Gyuris and Sistla [GS97] have developed an on-the-fly model checker that utilizes symmetries under fairness. Emer-son, Jha and Peled [EJP97] have developed theory for combining partial orders and symmetries. Ip and Dill <ref> [ID96] </ref> use symmetries for speeding up verification of safety properties using explicit techniques for designs specified in a guarded command language. They propose augmentation of the language itself by introducing a new data type with syntactic constraints for sets of fully symmetric variables called scalarsets.
Reference: [Jer86] <author> M. Jerrum. </author> <title> A Compact Representation for Permutation Groups. </title> <journal> J. Algorithms, </journal> <volume> 27 </volume> <pages> 60-78, </pages> <year> 1986. </year>
Reference-contexts: See [But91] for a good exposition. We run the algorithm in Figure 3 on the page before. We also maintain the group formed by automorphisms discovered so far using Jerrum's labeled branchings <ref> [Jer86] </ref>, which we augment as new automorphisms are discovered. As we backtrack, we dynamically change base using the algorithms in [BFJ89]. As we branch, we use the pruning mechanism described in [BL85] to avoid rediscovering any automorphism already in the group.
Reference: [Kur87] <author> R. P. Kurshan. </author> <title> Testing Containment of Omega-regular Languages. In Reducibility in Analysis of Coordination, </title> <booktitle> volume 103 of Lecture Notes in Computer Science, </booktitle> <pages> pages 19-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Symmetries abound in hardware circuits, distributed algorithms and concurrent programs. Huber, Jepsen and Jensen [HJJ84] and Starke [Sta91] have investigated the use of symmetries for expediting reachability analysis for Petri nets. An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan <ref> [Kur87] </ref> and Attie and Emerson [AE89]. The approach uses quotient structures induced by au-tomorphisms of the system. The survey by Pong and Dubois [PD97] shows how symmetries can benefit verification of cache consistency protocols. Symmetries have also been shown to speedup transistor-level verification of digital circuits [PB97].
Reference: [Man97] <author> Gurmeet Singh Manku. </author> <title> Structural Symmetries and Model Checking. </title> <type> Master's thesis UCB/ERL M97/92, </type> <institution> University of California at Berkeley, </institution> <year> 1997. </year> <note> Available as http://www.cs.berkeley.edu/~manku/papers/ ms-thesis.ps.gz. </note>
Reference-contexts: A detailed proof can be found in <ref> [Man97] </ref>. For a Kripke structure M and CTL* formula f defined on AP , let SF denote the set of all sub-formulas of f , including any atomic propositions in AP that occur in f . Recall the definitions of logical and structural equivalence from Section 2.2. <p> If we replace G by G s , the problem is as hard as graph isomorphism <ref> [Man97] </ref>. We now outline a technique that can identify symmetric sub-formulas if the symmetry in the specification is reflected in the formula as well, which is true in practice. <p> Briefly, we need to compute the canonical state function ~ G1H and modify the model checker so that it canonicalizes every state encountered during state space traversal. The problem of computing ~ G1H has not been completely solved. See <ref> [Man97] </ref> for a summary of results and a new but untested algorithm for computing ~ G1H . 5 Structural Symmetries In Section 3.2, we saw how knowledge of groups G Aut M L AP and H Aut f AP SF would help us partition sub-formulas of a CTL* formula f into <p> Let Aut C L AP denote the set of all such permutations. It can be verified that Theorem 5 still holds. A detailed proof can be found in <ref> [Man97] </ref>, which also shows how multiple-output tables, the "=" construct [B + 91], pseudo inputs and other special cases 5 can be handled. The size of the graph is linear in the size of the flattened BLIF-MV description. Here are two interesting theoretical questions: 1. <p> Is there any group G &lt;L&gt; that does not correspond to any BLIF-MV circuit? If so, we can focus on the remaining groups to solve the canonical state problem. How ever, the answer is negative <ref> [Man97] </ref>. 2. Identifying scalarsets: A scalarset is an automorphism of the graph A C such that the automorphism can be written as a product of disjoint transpositions. Note that A C is not an arbitrary directed graph. It has been derived from a valid BLIF-MV circuit. See [Man97] for a simple <p> answer is negative <ref> [Man97] </ref>. 2. Identifying scalarsets: A scalarset is an automorphism of the graph A C such that the automorphism can be written as a product of disjoint transpositions. Note that A C is not an arbitrary directed graph. It has been derived from a valid BLIF-MV circuit. See [Man97] for a simple proof that the problem is as hard as graph isomorphism. 5.3 Graphs for CTL* Formulas To compute H Aut f AP SF (defined in Section 3.2), draw the parse tree for the formula f . Label each internal node with the operator it corresponds to. <p> A detailed description of an algorithm for computing Aut A, that draws ideas from computational group theory and uses the algorithm in Figure 3 as a backbone, is given in <ref> [Man97] </ref>. Here is a brief description: Permutation groups are typically represented using a base and strong generating set [Sim70]. See [But91] for a good exposition. We run the algorithm in Figure 3 on the page before. <p> We found GAP to be slow. We can exploit a lot of structure in the kind of graphs we generate as input. For a detailed description of several motivating reasons for writing a new program, see <ref> [Man97] </ref>. 6.3 Refinement For a graph A, the function Refine in Figure 3 on the preceding page computes a unipartition U such that U min 4 U 4 U max . <p> Identification of symmetries might also help speedup combinational verification and several other VLSI-CAD algorithms from high level design to layout. Please see <ref> [Man97] </ref> for further details.
Reference: [McK81] <author> B. D. McKay. </author> <title> Practical Graph Isomorphism. </title> <booktitle> In Proc. Tenth Manitoba Conf. on Numerical Math. and Computing, Winnepeg, 1980, </booktitle> <volume> vol 1, </volume> <booktitle> volume 30 of Congr. Numer., </booktitle> <pages> pages 45-87, </pages> <year> 1981. </year>
Reference-contexts: We initially experimented with a software package for manipulating graphs and groups, GAP [Gap], which has a graph automorphism program called nauti [McK90] based on one of the earliest such programs written by McKay <ref> [McK81] </ref>. A natural question to ask is: Why write another graph automorphism program? Existing packages are general purpose and carry around a lot of baggage. We found GAP to be slow. We can exploit a lot of structure in the kind of graphs we generate as input.
Reference: [McK90] <author> B. D. McKay. </author> <title> Nauty Users Guide (Version 1.5). </title> <type> Technical Report TR-CS-90-02, </type> <institution> Computer Science Department, Australian National University, Australia, </institution> <year> 1990. </year>
Reference-contexts: As we branch, we use the pruning mechanism described in [BL85] to avoid rediscovering any automorphism already in the group. We initially experimented with a software package for manipulating graphs and groups, GAP [Gap], which has a graph automorphism program called nauti <ref> [McK90] </ref> based on one of the earliest such programs written by McKay [McK81]. A natural question to ask is: Why write another graph automorphism program? Existing packages are general purpose and carry around a lot of baggage. We found GAP to be slow. <p> Some more expensive vertex invariants are discussed in <ref> [SD76, FH + 83, McK90] </ref>. An important trick is to treat a unipartition U as a labeling function and use it to refine itself. For a vertex v, let U 0 compute the set of labels of vertices incident upon v.
Reference: [PB97] <author> M. Pandey and E. Bryant. </author> <title> Exploiting Symmetry when Verifying Transistor-Level Circuits by Symbolic Trajectory Evaluation. </title> <booktitle> In Proc. 9th Intl. Conf. on Computer Aided Verification, </booktitle> <address> Haifa, Israel, </address> <month> June </month> <year> 1997, </year> <booktitle> volume 1254 of Lecture Notes in Computer Science, </booktitle> <pages> pages 244-255. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: The approach uses quotient structures induced by au-tomorphisms of the system. The survey by Pong and Dubois [PD97] shows how symmetries can benefit verification of cache consistency protocols. Symmetries have also been shown to speedup transistor-level verification of digital circuits <ref> [PB97] </ref>. Emerson and Sistla [ES96] and Clarke et al [CEFJ96] show how symmetries in Kripke structures and CTL* formulas allow the construction of a smaller sized quotient structure such that the formula need be verified only for the quotient. In both works, symmetries are specified by hand by the designer.
Reference: [PD97] <author> F. Pong and M. Dubois. </author> <title> Verification Techniques for Cache Coherence Protocols. </title> <journal> ACM Computing Surveys, </journal> <volume> 29(1) </volume> <pages> 82-126, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan [Kur87] and Attie and Emerson [AE89]. The approach uses quotient structures induced by au-tomorphisms of the system. The survey by Pong and Dubois <ref> [PD97] </ref> shows how symmetries can benefit verification of cache consistency protocols. Symmetries have also been shown to speedup transistor-level verification of digital circuits [PB97].
Reference: [SD76] <author> D. C. Schmidt and L. E. Druffel. </author> <title> A Fast Backtrack Algorithm to Test Directed Graphs for Isomorphism using Distance Matrices. </title> <journal> J. of the ACM, </journal> <volume> 23 </volume> <pages> 433-445, </pages> <year> 1976. </year>
Reference-contexts: Some more expensive vertex invariants are discussed in <ref> [SD76, FH + 83, McK90] </ref>. An important trick is to treat a unipartition U as a labeling function and use it to refine itself. For a vertex v, let U 0 compute the set of labels of vertices incident upon v.
Reference: [Sim70] <author> C. C. Sims. </author> <title> Computational Methods in the Study of Permutation Groups. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pages 169-183. </pages> <publisher> Pergamon, </publisher> <address> Elmsford, N.Y., </address> <year> 1970. </year>
Reference-contexts: A detailed description of an algorithm for computing Aut A, that draws ideas from computational group theory and uses the algorithm in Figure 3 as a backbone, is given in [Man97]. Here is a brief description: Permutation groups are typically represented using a base and strong generating set <ref> [Sim70] </ref>. See [But91] for a good exposition. We run the algorithm in Figure 3 on the page before. We also maintain the group formed by automorphisms discovered so far using Jerrum's labeled branchings [Jer86], which we augment as new automorphisms are discovered.
Reference: [Sta91] <author> P. Starke. </author> <title> Reachability Analysis of Petri Nets using Symmetries. Syst. Anal. Model. </title> <journal> Simul., </journal> 8(4/5):293-303, 1991. 
Reference-contexts: This is commonly known as State Space Explosion. Among the techniques being developed for countering this problem are partial order methods, abstraction, compositional approaches, and symmetry reductions. Symmetries abound in hardware circuits, distributed algorithms and concurrent programs. Huber, Jepsen and Jensen [HJJ84] and Starke <ref> [Sta91] </ref> have investigated the use of symmetries for expediting reachability analysis for Petri nets. An algebraic approach for reducing the cost of protocol analysis has been proposed by Kurshan [Kur87] and Attie and Emerson [AE89]. The approach uses quotient structures induced by au-tomorphisms of the system.
Reference: [TS + 90] <author> H. Touati, H. Savoj, et al. </author> <title> Implicit State Enumeration of Finite State Machines using BDD's. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Temporal model checking algorithms <ref> [CES86, CMB90, TS + 90, BCL + 94] </ref> typically explore the states of a non-deterministic finite state machine that represents the system under scrutiny. A major bottleneck is the exponential number of states that need be explored. This is commonly known as State Space Explosion.
Reference: [vL90] <author> J. van Leeuwen. </author> <title> Graph Algorithms. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Algorithms and Complexity, volume A of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 525-631. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year> <month> 11 </month>
Reference-contexts: Ideally, we would like to start with U min , as defined in Lemma 3, as it is the finest such partition. However, computing U min itself is as hard as graph isomor-phism <ref> [vL90] </ref>. Therefore, we compute an approximation U such that U min 4 U 4 U max using the function Refine, which we describe in detail in Section 6.3. Note that U is consistent with every automorphism of A. After computing U , we check whether P and U are compatible.
References-found: 35

