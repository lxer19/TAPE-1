URL: http://www.cse.psu.edu/~ugrain/vlsi-cad/MGAP/camp95.ps
Refering-URL: http://www.cse.psu.edu/~ugrain/publications.html
Root-URL: 
Email: info.pub.permission@ieee.org.  
Note: Copyright 1995 IEEE. All rights reserved. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution must be obtained from the IEEE. For information on obtaining permission, send a blank email message to  By choosing to view this document, you agree to all provisions of the copyright laws protecting it.  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> R. Bajwa, R.M. Owens, and M.J. Irwin, </author> <title> Image processing with the MGAP: A cost effective approach, </title> <booktitle> in Proc. Intl. Parallel Processing Symposium, </booktitle> <address> pp.439-443, Apr.1993. </address>
Reference-contexts: Since these operations require local information only, they can be performed on all the pixels of an image in unison. Some example of low-level tasks are thresholding, filtering, smoothing, edge extraction, image enhancement, convolution, image transforms, etc. In <ref> [1] </ref>, algorithms for many such tasks and the performance numbers for the MGAP-1 are given and compared with other massively parallel architectures. The intermediate-level tasks provide an interface between low and high levels and generate a structure of symbolic elements representing visual knowledge. <p> This algorithm requires 266 cycles per iteration or 5.3 msec per iteration. The average number of iterations is equal to the half of the width in pixels of the broadest section of the object. Histogramming is used to gather spatially independent statistics about the image. In <ref> [1] </ref>, a recursive doubling structure was used to sum the pixels corresponding to each gray level. For a n x n array with g gray levels, this algo <p>- rithm needs O (g log n) additions and O (g n) shifts.
Reference: [2] <author> R. Bajwa, R.M. Owens, and M.J. Irwin, </author> <title> Area Time Trade-offs in Micro-Grained VLSI Array Architectures, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 43, </volume> <pages> pp. 1121-1128, </pages> <month> Oct. </month> <year> 1994. </year>
Reference: [3] <author> R. Bajwa, R.M. Owens, and M.J. Irwin, </author> <title> The MGAPs Programming Environment and the *C++ Language, </title> <booktitle> in Proc. Intl. Conf. on Application-Specific Array Processors, </booktitle> <month> Jul. </month> <year> 1995. </year>
Reference-contexts: The MGAP is supported by an easy-to-use programming environment that allows a relatively naive user to develop applications in a high level language (*C++) <ref> [3] </ref>. 3: Image Processing Algorithms The subtasks in computer vision are generally grouped into 3 levels, low-level, intermediate-level, and high-level tasks. The low-level subtasks involves point and local operations on the image. Therefore the massively parallel MGAP mesh is ideally suited for this purpose.
Reference: [4] <author> K.E. Batcher, </author> <title> Design of a Massively Parallel Processor, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 29, </volume> <pages> pp. 836-840, </pages> <month> Sep. </month> <year> 1980. </year>
Reference-contexts: Most of these applications require real-time processing of images. Since image processing tasks are computationally intensive by nature, massively parallel processing has been employed to exploit the inherent parallelism. Some pioneering researchers have designed and developed massively parallel processing systems including the CLIP family [5], the MPP <ref> [4] </ref>, and the CM [7]. All of these systems, however, are hard to use in machine perception systems because of their expensiveness and physical size. To tackle these problems we developed the inexpensive and easily portable massively parallel processing system, the MGAP (Micro Grained Array Processor) [2][8].
Reference: [5] <author> M.J.B. Duff and T.J. Fountain, </author> <title> Computing Structures for Image Processing, </title> <publisher> Academic Press, </publisher> <year> 1983. </year>
Reference-contexts: Most of these applications require real-time processing of images. Since image processing tasks are computationally intensive by nature, massively parallel processing has been employed to exploit the inherent parallelism. Some pioneering researchers have designed and developed massively parallel processing systems including the CLIP family <ref> [5] </ref>, the MPP [4], and the CM [7]. All of these systems, however, are hard to use in machine perception systems because of their expensiveness and physical size. To tackle these problems we developed the inexpensive and easily portable massively parallel processing system, the MGAP (Micro Grained Array Processor) [2][8]. <p> After that, it takes 25 cycles to add them up to get final results. The total cycles required are 257 cycles or 5.14 msec. Other operators like Prewitt, Roberts, and Laplacian can be solved in a same fashion. Median filtering can be done using a at pixel parallel algorithm <ref> [5] </ref>. For an image with 256 gray levels eight bits are needed per pixel. The algorithm looks at these bits sequentially for all pixels in a window to determine the median. It counts #_of_1s among the most significant bits in a window.
Reference: [6] <author> R.C. Gonzalez and R.E. Woods, </author> <title> Digital Image Processing, </title> <publisher> Addison-Wesley Publishing Com., </publisher> <year> 1992 </year>
Reference-contexts: Then the Rank_of_median is updated with (Rank_of_median - #_of_1s). These steps are iterated 8 times. One iteration takes 82 cycles and the total time is 656 cycles or 13.1 msec. Thinning of objects in images is also performed using spatial operators <ref> [6] </ref>. The basic idea is that the thinned version of the object are those points which are at the same distance from two or more boundary points. This algorithm requires 266 cycles per iteration or 5.3 msec per iteration.
Reference: [7] <author> W.D. Hillis, </author> <title> The Connection Machine, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: Since image processing tasks are computationally intensive by nature, massively parallel processing has been employed to exploit the inherent parallelism. Some pioneering researchers have designed and developed massively parallel processing systems including the CLIP family [5], the MPP [4], and the CM <ref> [7] </ref>. All of these systems, however, are hard to use in machine perception systems because of their expensiveness and physical size. To tackle these problems we developed the inexpensive and easily portable massively parallel processing system, the MGAP (Micro Grained Array Processor) [2][8].
Reference: [8] <author> M.J. Irwin and R.M. Owens, </author> <title> A micro-grained VLSI signal processor, </title> <booktitle> in Proc. ICASSP 92, </booktitle> <pages> pp. </pages> <address> V.641-V.644, </address> <month> Mar. </month> <year> 1992. </year>
Reference: [9] <author> H.N. Kim, M.J. Irwin, R.M. Owens, and C.M. Wu, </author> <title> Dynamic Space Warping Algorithms on Fine-Grain Array Processors, </title> <booktitle> in Proc. 8th Intl. Parallel Processing Symposium, </booktitle> <pages> pp. 921-925, </pages> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: The DSWA is the two- dimensional analog to the dynamic time warping algorithm (DTWA) which is used in speech recognition systems. It solves space warping problems such as shrinking, enlarging, distortion, and noise problem. The original DSWA requires four-dimensional array and we mapped it onto our two-dimensional MGAP <ref> [9] </ref>. The DSWA is to compute the distance between two two-dimensional sequences based on the recursive distance equation with dynamic programming. The DSWA is pipelined.
Reference: [10] <author> H.N. Kim, R.M. Owens, and M.J. Irwin, </author> <title> 2-D Discrete Cosine Transforms on Fine-Grain Array Processors, </title> <booktitle> in Proc. VLSI Signal Processing VII, </booktitle> <pages> pp. 356-367, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: We developed an efficient systolic 2-D DCT algorithm on a mesh fine-grained array processor <ref> [10] </ref>. It reads non-skewed input subimages and generates the output in non-skewed form with only a small amount of extra processors. It uses the minimum number of multiplications by employing modified small n algorithms. 2-D DCT can be written as: .
Reference: [11] <author> J. Lim, </author> <title> Two-Dimensional Signal and Image Processing, </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference: [12] <author> C. Nagendra, R.M. Owens, and M.J. Irwin, </author> <title> Digit Systolic Algorithms for Fine-grain Architectures, </title> <booktitle> in Proc. Application Specific Array Processors, </booktitle> <pages> pp. 466-477, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: A radix 4, fully redundant number system is used to allow constant time addition and linear time multiplication <ref> [12] </ref>. Table 1 shows the cycles and Ops/sec for some relevant operations for image processing algorithms when p=16 on the MGAP.
Reference: [13] <author> C. Nagendra, M. Borah, M. Vishwanath, R.M. Owens, and M.J. Irwin, </author> <title> Edge detection using fine-grain parallelism in VLSI, </title> <booktitle> in Proc. ICASSP 93, </booktitle> <address> pp.I.401-404, Apr.1993 </address>
Reference-contexts: The intermediate-level tasks provide an interface between low and high levels and generate a structure of symbolic elements representing visual knowledge. Some examples of intermediate-level tasks are histo- gramming, region labelling, and Hough transforms. In <ref> [13] </ref>, the fully systolic, multiplication-free algorithm for computing the Hough transform was described. The high- level subtasks accept the output of the intermediate level subtasks which is a symbolic representation of the image and classify features into known classes. Using this information the object recognition can be done.
References-found: 13

