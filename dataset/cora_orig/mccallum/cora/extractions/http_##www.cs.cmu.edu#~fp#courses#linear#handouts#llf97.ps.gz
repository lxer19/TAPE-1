URL: http://www.cs.cmu.edu/~fp/courses/linear/handouts/llf97.ps.gz
Refering-URL: http://www.cs.cmu.edu/~fp/courses/linear/lectures/lecture22.html
Root-URL: 
Email: filianojfpg@cs.cmu.edu  
Title: A Linear Logical Framework  
Author: Iliano Cervesato and Frank Pfenning 
Address: Pittsburgh, PA 15213-3891  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: We present the linear type theory ffi&&gt; as the formal basis for LLF, a conservative exten Submitted to Information & Computation. Comments are welcome! sion of the logical framework LF . LLF combines the expressive power of dependent types with linear logic to permit the natural and concise representation of a whole new class of deductive systems, namely those dealing with state. As an example we encode a version of Mini-ML with mutable references including its type system and its operational semantics, and describe how to take practical advantage of the representation of its computations.
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [Bar80] <author> H. P. Barendregt. </author> <title> The Lambda-Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1980. </year>
Reference: [Bar96] <author> Andrew Barber. </author> <title> Dual intuitionistic linear logic. </title> <type> Technical Report ECS-LFCS-96-347, </type> <institution> Laboratory for Foundations of Computer Sciences, University if Edinburgh, </institution> <year> 1996. </year>
Reference: [CDCV81] <author> Mario Coppo, Maria Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional character of solvable terms. </title> <journal> Zeitschrift fur mathematische Logic und Grundlagen der Mathematik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year>
Reference: [CDDK86] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming, </booktitle> <pages> pages 13-27. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Finally, we show how to encode these different aspects in LLF in Section 3.3. Appendix A contains the complete LLF signature for this example. In the following, we will concentrate mainly on the novel constructions available in MLR, referring the reader to the literature <ref> [CDDK86, HM90, MP91, Pfe92] </ref> for aspects already present in Mini-ML. 40 3 THE METHODOLOGY OF LINEAR META-REPRESENTATION 3.1 Judgments-as-Types Revisited A logical framework consists of a representation language and a methodology that prescribes how to best take advantage of the constructs it offers when encoding an object formalism. <p> We will point out differences and similarities with other approaches as they arise. Expressions and Store Since its introduction in <ref> [CDDK86] </ref>, the language Mini-ML and variants of it have been used for case studies in the presentation of logical frameworks [HM90, MP91, Pfe92]. Mini-ML is a purely functional restriction of the programming language ML [MTHM96]. More specifically, it is a small functional programming language based on a simply typed -calculus.
Reference: [Cer96] <author> Iliano Cervesato. </author> <title> A Linear Logical Framework. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Torino, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: We will rely on a canonical system adapted from [Pfe92] for our comparison. Details can be found in <ref> [Cer96] </ref>. We will distinguish the equivalents of the judgments presented earlier by annotating them with the superscript LF . As already pointed out in Section 2.1, LLF enriches the language of LF with a number of linear type constructors and the corresponding object level operators. <p> Furthermore, linearity in our logical framework can be integrated into higher-order abstract syntax as a convenient manner of encoding languages relying on linear binders <ref> [Cer96] </ref>. <p> Not only does return operates only on values, but computation places a value at the heart of answers and the contents of every cell in the store is a value. See <ref> [Cer96] </ref> for a formal statement of these properties. <p> For reasons of space, we will not formalize the proof of these results in LLF . The interested reader can find an encoding of this proof in our linear logical framework in <ref> [Cer96] </ref>. 3 THE METHODOLOGY OF LINEAR META-REPRESENTATION The type preservation theorem states that the type of an expression does not change as the result of evaluation. The proof of the type preservation theorem relies on a number of auxiliary lemmas. <p> Note that compositionality is not needed for cells since they are never subject to substitution. Due to the complexity of our object language, we do not display the simple but long and somewhat tedious inductive proof of this statement. The interested reader is referred to <ref> [Cer96] </ref> for a full treatment. The techniques used in order to prove adequacy theorems for LLF encodings naturally extends the methods successfully applied for years in the more restricted setting of LF . In particular, they retain their simplicity in our richer applicative arena. <p> The LLF declarations for the constants needed in their encoding can be found in Appendix A. We omit displaying the statements of the respective adequacy theorems since they do not introduce new concepts. They can be found in <ref> [Cer96] </ref>. The formalization of MLR we propose relies on two distinct representations of the store. In most circumstances, the store is efficiently encoded in a distributed fashion in the context of LLF . We refer to this encoding as the internal representation. <p> The declarations for these constants are repeated in Appendix A. The adequacy theorems that link them to the syntax of MLR are reported in <ref> [Cer96] </ref>. Static Semantics On the basis of the above encoding of the syntax of MLR, we will now describe the meta-representation of the static semantics of this language. As for syntax, the representation of the static semantics of MLR does not rely on the linear features of LLF . <p> The role of the linear features of our formalism is crucial for this purpose. Using LF on this problem would have produced awkward encodings with prohibitive consequence for the development of the meta-theory of MLR <ref> [Cer96] </ref>: a first alternative would have relied entirely on the external representation of the store, implementing all the operations required to access and modify it explicitly. <p> We conclude this section by illustrating how to take advantage of this internal representation of MLR computations. We only give a small example here|more interesting examples such as the proof of type preservation, or a cut elimination procedure for classical linear logic can be found in <ref> [Cer96] </ref>. Specifically, we will give LLF declarations that permit counting the number of reference cells dynamically allocated during the evaluation. In order to achieve this purpose, we first give the following declarations for natural numbers: num : type. zero : num. succ : num -&gt; num. <p> demonstrated its expressive power by providing a usable representation of the syntax and the semantics of an imperative variant of the functional programming language Mini-ML; space reasons prevented us from extending this encoding to aspects of the meta-theory of this language, such as a proof of its type preservation property <ref> [Cer96] </ref>. Additional substantial case studies we have completed include the formalization of a proof of cut elimination for classical linear logic, translations between minimal linear natural deduction and sequent calculus, as well as a number of puzzles and solitaires. <p> The interested reader may access them on the World-Wide Web at [CP] or in <ref> [Cer96] </ref>. The representation language of LLF, ffi&&gt; , conservatively extends LF 's with constructs from linear logic. We can think of it as the type theory freely generated from the type constructors &gt;, &, ffi, and .
Reference: [Chi95] <author> Jawahar Lal Chirimar. </author> <title> Proof Theoretic Approach to Specification Languages. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: The proofs of these properties are long and error-prone. Therefore, recent work has investigated the possibility of partially automating their generation or at least their verification. Chir-imar gives Forum specifications for a language with references, exceptions and continuations and uses the meta-theory of Forum [Mil94] to study program equivalence <ref> [Chi95] </ref>. VanInwe-gen [Van96] formally proved properties such as value soundness for most of Standard ML with the help of the HOL theorem prover [GM93]. In this section, we define MLR as an extension of Mini-ML with references and imperative instructions, and study aspects of its meta-theory. <p> Although on a much simpler fragment, our use of higher-order abstract syntax, of parametric and hypothetical judgments, and of the linear features of LLF avoids these difficulties completely. Chirimar used Forum [Mil94] to represent a language similar to MLR with the addition of exceptions and continuations <ref> [Chi95] </ref>, but without any emphasis on typing. He took advantage of the higher-order nature of Forum and of its linear constructs. The resulting program is as elegant as our code and is proved adequate with respect to the informal specification of the object language.
Reference: [CHP96] <author> Iliano Cervesato, Joshua S. Hodas, and Frank Pfenning. </author> <title> Efficient resource management for linear logic proof search. </title> <editor> In R. Dyckhoff, H. Herre, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the 5th International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 67-81, </pages> <address> Leipzig, Germany, March 1996. </address> <publisher> Springer-Verlag LNAI 1050. </publisher>
Reference-contexts: LLF maintains the computational nature of LF and is amenable to an efficient implementation as a logic programming language in the style of Elf [Pfe91, Pfe94a]. The experience gained with linearity in the language Lolli <ref> [HM94, CHP96] </ref> applies directly to our formalism. New aspects, in particular the definition of effective algorithms for performing linear higher-order unification, are under investigation [CP96].
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of a simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: With a careful encoding, the validity of this property in our language will be reduced to the fact that it holds in fi! , which we assume from the literature. The language fi! is an extension of Church's simply typed -calculus <ref> [Chu40] </ref> with product types of the form 1 fi 2 and the corresponding object level entities, namely pairs and the two projections. Product types are needed to encode the additive type constructor & of ffi&&gt; . As a matter of convenience, we distinguish between constants and variables.
Reference: [Coq91] <author> Thierry Coquand. </author> <title> An algorithm for testing conversion in type theory. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 255-279. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference: [CP] <author> Iliano Cervesato and Frank Pfenning. </author> <title> The linear logical framework LLF. </title> <note> Accessible on the World-Wide Web as http://www.cs.cmu.edu/~iliano/LLF/. </note>
Reference-contexts: Additional substantial case studies we have completed include the formalization of a proof of cut elimination for classical linear logic, translations between minimal linear natural deduction and sequent calculus, as well as a number of puzzles and solitaires. The interested reader may access them on the World-Wide Web at <ref> [CP] </ref> or in [Cer96]. The representation language of LLF, ffi&&gt; , conservatively extends LF 's with constructs from linear logic. We can think of it as the type theory freely generated from the type constructors &gt;, &, ffi, and .
Reference: [CP96] <author> Iliano Cervesato and Frank Pfenning. </author> <title> Linear higher-order pre-unification. </title> <editor> In D. Galmiche, editor, </editor> <booktitle> Informal Proceedings of the Workshop on Proof Search in Type-Theoretic Language, </booktitle> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: The experience gained with linearity in the language Lolli [HM94, CHP96] applies directly to our formalism. New aspects, in particular the definition of effective algorithms for performing linear higher-order unification, are under investigation <ref> [CP96] </ref>. LLF generalizes other formalisms based on linear logic such as Forum [Mil94] by making linear objects available for representations, by permitting proof terms and by providing linear types. It is closely related to the system RLF of Ishtiaq and Pym [IP96].
Reference: [Dam85] <author> Luis M.M. Damas. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1985. </year>
Reference-contexts: The addition of references and their interaction with polymorphism has been analyzed with different tools, ranging from the complex domain-theoretic approach of Damas <ref> [Dam85] </ref> to the syntactic formulation of Harper [Har94]. The latter idea was adapted from Wright and Felleisen, who additionally consider continuations and exceptions [WF94]. The proofs of these properties are long and error-prone. Therefore, recent work has investigated the possibility of partially automating their generation or at least their verification.
Reference: [DJ90] <editor> Nachum Dershowitz and Jean-Pierre Jouannaud. </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter Rewrite Systems, </booktitle> <pages> pages 243-320. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [Dyc92] <author> Roy Dyckhoff. </author> <title> Contraction-free sequent calculi for intuitionistic logic. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 57(3) </volume> <pages> 795-807, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Most real-world problems carry a state that changes with time. Many new logics and type theories are inherently bound to destructive context manipulations. Permanent contexts are insufficient even for more traditional formalisms, for example when studying efficient proof-search procedures for intuitionistic logic <ref> [Dyc92] </ref>. These applications are encoded awkwardly not only in LF, but in general in all intuitionistic frameworks based on traditional languages.
Reference: [Fel91] <author> Amy Felty. </author> <title> Encoding dependent types in an intuitionistic logic. </title> <editor> In Gerard Huet and Gor-don D. Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 214-251. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference: [Gan80] <author> R.O. </author> <title> Gandy. Proofs of strong normalization. </title> <editor> In J.P. Seldin and J.R. Hindley, editors, </editor> <booktitle> To H.B. Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 457-477. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year> <note> 65 REFERENCES </note>
Reference-contexts: A further property that fi! enjoys is strong normalization: if ` M : , then every reduction sequence on M terminates and, by confluence, yields a unique normal form for this term. Proofs of this and stronger properties for extensions of this language can be found in the literature <ref> [Gan80, Tro86] </ref>. The encoding we propose transforms LLF judgments ` U * -# - V into fi! judgments of 22 2 THE LINEAR TYPE THEORY ffi&&gt; the form ` 0 M : . <p> This form of non-determinism does not arise with strongly normalizing terms since the choice of the fi-redex to reduce at every step is arbitrary. The strong normalization theorem states that every derivable term is strongly normalizing. This property holds in fi! , as proved for example in <ref> [Gan80, Tro86] </ref>, and we use this fact to prove that it is valid also for ffi&&gt; . Theorem 2.16 (Strong normalization) If ` U * -# - V , then U is strongly normalizing. Proof.
Reference: [Geu93] <author> Herman Geuvers. </author> <title> Logics and Type Systems. </title> <type> PhD thesis, </type> <institution> Katholieke Universiteit Nijmegen, </institution> <year> 1993. </year>
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference: [Gir93] <author> Jean-Yves Girard. </author> <title> On the unity of logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 59 </volume> <pages> 201-217, </pages> <year> 1993. </year>
Reference-contexts: It is closely related to the system RLF of Ishtiaq and Pym [IP96]. Our approach is orthogonal to general logics in the style of LU <ref> [Gir93] </ref>. We plan to release in the near future an interpreter for LLF in the style of the current implementation of Elf. We are also considering implementing a WAM -like compiler for this language, although numerous theoretical issues still need to be settled.
Reference: [GM93] <author> M.J.C. Gordon and T.F. Melham. </author> <title> Introduction to HOL: a Theorem Proving Environment for Higher-order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Chir-imar gives Forum specifications for a language with references, exceptions and continuations and uses the meta-theory of Forum [Mil94] to study program equivalence [Chi95]. VanInwe-gen [Van96] formally proved properties such as value soundness for most of Standard ML with the help of the HOL theorem prover <ref> [GM93] </ref>. In this section, we define MLR as an extension of Mini-ML with references and imperative instructions, and study aspects of its meta-theory. <p> A complete treatment can be found in Appendix A. It is interesting to compare the result of our encoding with similar endeavors in the literature. VanInwegen used the HOL theorem prover <ref> [GM93] </ref> to verify properties about a substantial portion of Standard ML [Van96]. She adopted a brute-force approach to the meta-representation problem, encoding, for example, contexts as terms.
Reference: [Har94] <author> Robert Harper. </author> <title> A simplified account of polymorphic references. </title> <journal> Information Processing Letter, </journal> <volume> 51 </volume> <pages> 201-206, </pages> <year> 1994. </year>
Reference-contexts: The addition of references and their interaction with polymorphism has been analyzed with different tools, ranging from the complex domain-theoretic approach of Damas [Dam85] to the syntactic formulation of Harper <ref> [Har94] </ref>. The latter idea was adapted from Wright and Felleisen, who additionally consider continuations and exceptions [WF94]. The proofs of these properties are long and error-prone. Therefore, recent work has investigated the possibility of partially automating their generation or at least their verification. <p> The returned value is hi. We conclude our discussion about evaluation with a few words about the interaction of references and polymorphism. The question is subtle and has received great attention in the literature <ref> [Tof90, Har94, LW91] </ref>. Consider for example the following MLR expression. letname f = ref (lam x: x) in f := lam x: s x; At first sight, this expression allocates a cell and initializes it with the identity function, which has polymorphic type t ! t for any t . <p> c := fl (S; c = v; S 0 ) fl K ` return hi ,! a ev assign fl 2 (S; c = v 0 ; S 0 ) fl K ` c := fl plicative and imperative type variables in order to avoid problems such as the above <ref> [MTHM96, Har94] </ref>. Restricting polymorphism to values has also been proposed as a solution to this prob lem [Tof90] and has been adopted in the current definition of Standard ML [MTHM96].
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: In order to prove this property, we adapt the technique originally proposed for LF in <ref> [HHP93] </ref>. We will present a translation of ffi&&gt; into the simply typed -calculus with pairs fi! . The effect of this encoding will be to eliminate dependencies and linearity, considerably simplifying the treatment of the calculus. <p> The former are declared in a signature, while the latter are assumed in the context. The choice of using a calculus a la Church or in the style of Curry is arbitrary. Harper, Honsell and Plotkin adopted the latter solution in the original LF paper <ref> [HHP93] </ref>. We rely on the former only because it makes the types of the bound variables in the encoding below directly available. <p> Following the terminology of <ref> [HHP93] </ref>, we call this system, somewhat improperly, algorithmic. The properties of this system will also permit us to eventually prove the validity of strengthening for our language. <p> The range of practical applicability of these formalisms is limited by their foundation on intuitionistic type theory. All the formal systems that have been successfully encoded in LF (functional and logic programming languages [MP91, Pfe92], -calculi [Pfe99] and a number of logics <ref> [HHP93, Pfe95] </ref>) share a fundamental characteristic: whenever a judgment mentions a context, a bottom-up reading of the inference rules for it may add items, but they never remove assumptions. We call contexts with this property permanent, in contrast with volatile contexts, free from this restriction. <p> LF <ref> [HHP93] </ref> relies on as its meta-language and the judgments-as-types methodology for achieving effective meta-representations.
Reference: [HM90] <author> John Hannan and Dale Miller. </author> <title> From operational semantics to abstract machines: Preliminary results. </title> <editor> In M. Wand, editor, </editor> <booktitle> Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 323-332, </pages> <address> Nice, France, </address> <year> 1990. </year>
Reference-contexts: The present section illustrates the added expressiveness of LLF as a logical framework by describing the meta-representation methodology it adopts first abstractly and then on a concrete case study. The formalism we want to represent is an imperative extension of Mini-ML <ref> [HM90, MP91, Pfe92] </ref>, a purely functional restriction of the programming language ML [MTHM96]. <p> Finally, we show how to encode these different aspects in LLF in Section 3.3. Appendix A contains the complete LLF signature for this example. In the following, we will concentrate mainly on the novel constructions available in MLR, referring the reader to the literature <ref> [CDDK86, HM90, MP91, Pfe92] </ref> for aspects already present in Mini-ML. 40 3 THE METHODOLOGY OF LINEAR META-REPRESENTATION 3.1 Judgments-as-Types Revisited A logical framework consists of a representation language and a methodology that prescribes how to best take advantage of the constructs it offers when encoding an object formalism. <p> We will point out differences and similarities with other approaches as they arise. Expressions and Store Since its introduction in [CDDK86], the language Mini-ML and variants of it have been used for case studies in the presentation of logical frameworks <ref> [HM90, MP91, Pfe92] </ref>. Mini-ML is a purely functional restriction of the programming language ML [MTHM96]. More specifically, it is a small functional programming language based on a simply typed -calculus. It includes numerals, conditional expressions, pairs, polymorphic definitions, recursion and functional expressions. <p> This formulation extends the traditional evaluation judgment for Mini-ML <ref> [HM90, MP91, Pfe92] </ref>. The dynamic semantics of functional languages enriched with imperative features, such as MLR's references, is normally expressed in the literature in this manner. We will instead adopt a different strategy and present the reductions occurring during the execution of an MLR program as continuation-based evaluation rules.
Reference: [HM94] <author> Joshua Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year> <booktitle> A preliminary version appeared in the Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: LLF maintains the computational nature of LF and is amenable to an efficient implementation as a logic programming language in the style of Elf [Pfe91, Pfe94a]. The experience gained with linearity in the language Lolli <ref> [HM94, CHP96] </ref> applies directly to our formalism. New aspects, in particular the definition of effective algorithms for performing linear higher-order unification, are under investigation [CP96].
Reference: [Hod94] <author> Joshua S. Hodas. </author> <title> Logic Programming in Intuitionistic Linear Logic: Theory, Design, and Implementation. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, Department of Computer and Information Science, </institution> <year> 1994. </year>
Reference: [IP96] <author> Samin Ishtiaq and David Pym. </author> <title> A relevant analysis of natural deduction, </title> <month> December </month> <year> 1996. </year> <note> Unpublished. </note>
Reference-contexts: LLF generalizes other formalisms based on linear logic such as Forum [Mil94] by making linear objects available for representations, by permitting proof terms and by providing linear types. It is closely related to the system RLF of Ishtiaq and Pym <ref> [IP96] </ref>. Our approach is orthogonal to general logics in the style of LU [Gir93]. We plan to release in the near future an interpreter for LLF in the style of the current implementation of Elf.
Reference: [LW91] <author> Xavier Leroy and Pierre Weis. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 291-302, </pages> <address> Orlando, Florida, </address> <month> January 21-23 </month> <year> 1991. </year> <note> ACM press. </note>
Reference-contexts: The meta-variable v denotes values, that we will define shortly. The polymorphism in MLR is restricted to values, which is generally accepted as superior to the imperative type variables present in previous versions of SML <ref> [LW91] </ref>. We achieve this by distinguishing two forms of let. The expression ref e dynamically allocates a cell and initializes it with the value of e. The contents of a cell can be inspected by dereferencing it with ! and modified with an assignment (:=). <p> The returned value is hi. We conclude our discussion about evaluation with a few words about the interaction of references and polymorphism. The question is subtle and has received great attention in the literature <ref> [Tof90, Har94, LW91] </ref>. Consider for example the following MLR expression. letname f = ref (lam x: x) in f := lam x: s x; At first sight, this expression allocates a cell and initializes it with the identity function, which has polymorphic type t ! t for any t .
Reference: [Mil94] <editor> Dale Miller. A multiple-conclusion meta-logic. In S. Abramsky, editor, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: The proofs of these properties are long and error-prone. Therefore, recent work has investigated the possibility of partially automating their generation or at least their verification. Chir-imar gives Forum specifications for a language with references, exceptions and continuations and uses the meta-theory of Forum <ref> [Mil94] </ref> to study program equivalence [Chi95]. VanInwe-gen [Van96] formally proved properties such as value soundness for most of Standard ML with the help of the HOL theorem prover [GM93]. <p> Although on a much simpler fragment, our use of higher-order abstract syntax, of parametric and hypothetical judgments, and of the linear features of LLF avoids these difficulties completely. Chirimar used Forum <ref> [Mil94] </ref> to represent a language similar to MLR with the addition of exceptions and continuations [Chi95], but without any emphasis on typing. He took advantage of the higher-order nature of Forum and of its linear constructs. <p> The experience gained with linearity in the language Lolli [HM94, CHP96] applies directly to our formalism. New aspects, in particular the definition of effective algorithms for performing linear higher-order unification, are under investigation [CP96]. LLF generalizes other formalisms based on linear logic such as Forum <ref> [Mil94] </ref> by making linear objects available for representations, by permitting proof terms and by providing linear types. It is closely related to the system RLF of Ishtiaq and Pym [IP96]. Our approach is orthogonal to general logics in the style of LU [Gir93].
Reference: [MP91] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: The range of practical applicability of these formalisms is limited by their foundation on intuitionistic type theory. All the formal systems that have been successfully encoded in LF (functional and logic programming languages <ref> [MP91, Pfe92] </ref>, -calculi [Pfe99] and a number of logics [HHP93, Pfe95]) share a fundamental characteristic: whenever a judgment mentions a context, a bottom-up reading of the inference rules for it may add items, but they never remove assumptions. <p> The present section illustrates the added expressiveness of LLF as a logical framework by describing the meta-representation methodology it adopts first abstractly and then on a concrete case study. The formalism we want to represent is an imperative extension of Mini-ML <ref> [HM90, MP91, Pfe92] </ref>, a purely functional restriction of the programming language ML [MTHM96]. <p> Finally, we show how to encode these different aspects in LLF in Section 3.3. Appendix A contains the complete LLF signature for this example. In the following, we will concentrate mainly on the novel constructions available in MLR, referring the reader to the literature <ref> [CDDK86, HM90, MP91, Pfe92] </ref> for aspects already present in Mini-ML. 40 3 THE METHODOLOGY OF LINEAR META-REPRESENTATION 3.1 Judgments-as-Types Revisited A logical framework consists of a representation language and a methodology that prescribes how to best take advantage of the constructs it offers when encoding an object formalism. <p> We will point out differences and similarities with other approaches as they arise. Expressions and Store Since its introduction in [CDDK86], the language Mini-ML and variants of it have been used for case studies in the presentation of logical frameworks <ref> [HM90, MP91, Pfe92] </ref>. Mini-ML is a purely functional restriction of the programming language ML [MTHM96]. More specifically, it is a small functional programming language based on a simply typed -calculus. It includes numerals, conditional expressions, pairs, polymorphic definitions, recursion and functional expressions. <p> This formulation extends the traditional evaluation judgment for Mini-ML <ref> [HM90, MP91, Pfe92] </ref>. The dynamic semantics of functional languages enriched with imperative features, such as MLR's references, is normally expressed in the literature in this manner. We will instead adopt a different strategy and present the reductions occurring during the execution of an MLR program as continuation-based evaluation rules. <p> The representation we propose is a natural extension of the LF code for Mini-ML found in the literature <ref> [MP91] </ref>. In particular, it retains its structure, its elegance, and the ease of proving its adequacy with respect to the informal presentation we just concluded. We describe the main issues in the representation by displaying fragments of the code and a limited number of adequacy statements.
Reference: [MPP92] <author> Dale Miller, Gordon Plotkin, and David Pym. </author> <title> A relevant analysis of natural deduction. Talk given at the Workshop on Logical Frameworks, </title> <address> B-astad, Sweden, </address> <month> May </month> <year> 1992. </year>
Reference: [MTHM96] <author> Robin Milner, Mads Tofte, Robert Harper, and Dave McQueen. </author> <title> The Definition of Standard ML, Revised 1996. </title> <publisher> MIT Press, </publisher> <year> 1996. </year> <month> Forthcoming. </month>
Reference-contexts: The formalism we want to represent is an imperative extension of Mini-ML [HM90, MP91, Pfe92], a purely functional restriction of the programming language ML <ref> [MTHM96] </ref>. More precisely, we augment that language with a store and imperative instructions to access and modify the values it contains, we formalize the typing and evaluation semantics of these constructs and show that this extended language enjoys the type preservation property. <p> Type preservation in Standard ML <ref> [MTHM96] </ref>, for example, guarantees that no typing error can arise during evaluation; therefore execution can be sped up significantly by disregarding type information at run-time. <p> Expressions and Store Since its introduction in [CDDK86], the language Mini-ML and variants of it have been used for case studies in the presentation of logical frameworks [HM90, MP91, Pfe92]. Mini-ML is a purely functional restriction of the programming language ML <ref> [MTHM96] </ref>. More specifically, it is a small functional programming language based on a simply typed -calculus. It includes numerals, conditional expressions, pairs, polymorphic definitions, recursion and functional expressions. <p> The contents of a cell can be inspected by dereferencing it with ! and modified with an assignment (:=). Differently from [WF94], but consistently with the main stream in the literature (including the definition of Standard ML <ref> [MTHM96] </ref>), we choose this operation not to return the assigned object, but the unit element hi. <p> As is normally the case in functional languages, MLR does not offer explicit means to deallocate memory cells. All these constructs are available in Standard ML <ref> [MTHM96] </ref> with the exception of addresses themselves (c), which cannot be manipulated directly in that language. We require MLR programs not to mention locations directly so that cells are always guaranteed to be initialized. <p> c := fl (S; c = v; S 0 ) fl K ` return hi ,! a ev assign fl 2 (S; c = v 0 ; S 0 ) fl K ` c := fl plicative and imperative type variables in order to avoid problems such as the above <ref> [MTHM96, Har94] </ref>. Restricting polymorphism to values has also been proposed as a solution to this prob lem [Tof90] and has been adopted in the current definition of Standard ML [MTHM96]. <p> Restricting polymorphism to values has also been proposed as a solution to this prob lem [Tof90] and has been adopted in the current definition of Standard ML <ref> [MTHM96] </ref>. This language offers only one form of let, but it takes different courses of action depending on whether it defines a value or an arbitrary expression.
Reference: [Pfe99] <author> Frank Pfenning. </author> <title> A proof of the Church-Rosser theorem and its representation in a logical framework. </title> <journal> Journal of Automated Reasoning, </journal> <note> 199? To appear. A preliminary version is available as Carnegie Mellon Technical Report CMU-CS-92-186, September 1992. 66 REFERENCES </note>
Reference-contexts: The range of practical applicability of these formalisms is limited by their foundation on intuitionistic type theory. All the formal systems that have been successfully encoded in LF (functional and logic programming languages [MP91, Pfe92], -calculi <ref> [Pfe99] </ref> and a number of logics [HHP93, Pfe95]) share a fundamental characteristic: whenever a judgment mentions a context, a bottom-up reading of the inference rules for it may add items, but they never remove assumptions.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: We retain from Elf the use of % for comments and interpreter directives. We adopt the conventions available in that language in order to enhance the readability of LLF programs <ref> [Pfe91] </ref>. In particular, we permit keeping the type of bound variables implicit whenever they can be effectively reconstructed. We write -x-B, [x]B and [x^]B when maintaining implicit the type A of the variable x in -x:A-B, [x:A]B and [x^A]B, respectively. Similar conventions apply to dependent kinds. <p> The resulting representations retain the elegance and immediacy that characterize LF encodings, and the ease of proving their adequacy. LLF maintains the computational nature of LF and is amenable to an efficient implementation as a logic programming language in the style of Elf <ref> [Pfe91, Pfe94a] </ref>. The experience gained with linearity in the language Lolli [HM94, CHP96] applies directly to our formalism. New aspects, in particular the definition of effective algorithms for performing linear higher-order unification, are under investigation [CP96].
Reference: [Pfe92] <author> Frank Pfenning. </author> <title> Computation and deduction. </title> <note> Unpublished lecture notes, revised May 1994, </note> <month> May </month> <year> 1992. </year>
Reference-contexts: We will rely on a canonical system adapted from <ref> [Pfe92] </ref> for our comparison. Details can be found in [Cer96]. We will distinguish the equivalents of the judgments presented earlier by annotating them with the superscript LF . <p> The range of practical applicability of these formalisms is limited by their foundation on intuitionistic type theory. All the formal systems that have been successfully encoded in LF (functional and logic programming languages <ref> [MP91, Pfe92] </ref>, -calculi [Pfe99] and a number of logics [HHP93, Pfe95]) share a fundamental characteristic: whenever a judgment mentions a context, a bottom-up reading of the inference rules for it may add items, but they never remove assumptions. <p> The present section illustrates the added expressiveness of LLF as a logical framework by describing the meta-representation methodology it adopts first abstractly and then on a concrete case study. The formalism we want to represent is an imperative extension of Mini-ML <ref> [HM90, MP91, Pfe92] </ref>, a purely functional restriction of the programming language ML [MTHM96]. <p> Finally, we show how to encode these different aspects in LLF in Section 3.3. Appendix A contains the complete LLF signature for this example. In the following, we will concentrate mainly on the novel constructions available in MLR, referring the reader to the literature <ref> [CDDK86, HM90, MP91, Pfe92] </ref> for aspects already present in Mini-ML. 40 3 THE METHODOLOGY OF LINEAR META-REPRESENTATION 3.1 Judgments-as-Types Revisited A logical framework consists of a representation language and a methodology that prescribes how to best take advantage of the constructs it offers when encoding an object formalism. <p> We will point out differences and similarities with other approaches as they arise. Expressions and Store Since its introduction in [CDDK86], the language Mini-ML and variants of it have been used for case studies in the presentation of logical frameworks <ref> [HM90, MP91, Pfe92] </ref>. Mini-ML is a purely functional restriction of the programming language ML [MTHM96]. More specifically, it is a small functional programming language based on a simply typed -calculus. It includes numerals, conditional expressions, pairs, polymorphic definitions, recursion and functional expressions. <p> This formulation extends the traditional evaluation judgment for Mini-ML <ref> [HM90, MP91, Pfe92] </ref>. The dynamic semantics of functional languages enriched with imperative features, such as MLR's references, is normally expressed in the literature in this manner. We will instead adopt a different strategy and present the reductions occurring during the execution of an MLR program as continuation-based evaluation rules.
Reference: [Pfe93] <author> Frank Pfenning. </author> <title> Refinement types for logical frameworks. </title> <editor> In Herman Geuvers, editor, </editor> <booktitle> Informal Proceedings of the Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 285-299, </pages> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1993. </year>
Reference: [Pfe94a] <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: This inheritance endows our formalism with a rich library of concrete applications. 2.9 A Concrete Syntax for LLF In this section, we extend the concrete syntax of Elf <ref> [Pfe94a] </ref> to express the linear operators of LLF . <p> The resulting representations retain the elegance and immediacy that characterize LF encodings, and the ease of proving their adequacy. LLF maintains the computational nature of LF and is amenable to an efficient implementation as a logic programming language in the style of Elf <ref> [Pfe91, Pfe94a] </ref>. The experience gained with linearity in the language Lolli [HM94, CHP96] applies directly to our formalism. New aspects, in particular the definition of effective algorithms for performing linear higher-order unification, are under investigation [CP96].
Reference: [Pfe94b] <author> Frank Pfenning. </author> <title> Structural cut elimination in linear logic. </title> <type> Technical Report CMU-CS-94-222, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: In particular, they retain their simplicity in our richer applicative arena. This contrasts with other proposals, e.g., the treatment of linearity in LF itself <ref> [Pfe94b] </ref>, where adequacy theorems have complex proofs even for simple object languages. 56 3 THE METHODOLOGY OF LINEAR META-REPRESENTATION Types, instructions and continuations are represented in a similar way. The LLF declarations for the constants needed in their encoding can be found in Appendix A.
Reference: [Pfe94c] <author> Frank Pfenning. </author> <title> A structural proof of cut elimination and its representation in a logical framework. </title> <type> Technical Report CMU-CS-94-218, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> November </month> <year> 1994. </year>
Reference: [Pfe95] <author> Frank Pfenning. </author> <title> Structural cut elimination. </title> <editor> In D. Kozen, editor, </editor> <booktitle> Proceedings of the Tenth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 156-166, </pages> <address> San Diego, California, June 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The range of practical applicability of these formalisms is limited by their foundation on intuitionistic type theory. All the formal systems that have been successfully encoded in LF (functional and logic programming languages [MP91, Pfe92], -calculi [Pfe99] and a number of logics <ref> [HHP93, Pfe95] </ref>) share a fundamental characteristic: whenever a judgment mentions a context, a bottom-up reading of the inference rules for it may add items, but they never remove assumptions. We call contexts with this property permanent, in contrast with volatile contexts, free from this restriction.
Reference: [Pfe96] <author> Frank Pfenning. </author> <title> The practice of logical frameworks. </title> <editor> In Helene Kirchner, editor, </editor> <booktitle> Proceedings of the Colloquium on Trees in Algebra and Programming, </booktitle> <pages> pages 119-134, </pages> <address> Linkoping, Sweden, </address> <month> April </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1059. Invited talk. </note>
Reference: [Roh97] <author> Ekkehard Rohwedder. </author> <title> Verifying the Meta-Theory of Deductive Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1997. </year> <month> Forthcoming. </month>
Reference-contexts: We would also like to explore the possibility of automatically verifying that a signature implements a meta-proof of a meta-theorem analogously to schema-checking for LF <ref> [Roh97] </ref>. 64
Reference: [Sal90] <author> Anne Salvesen. </author> <title> The Church-Rosser theorem for LF with fi-reduction. Unpublished notes to a talk given at the First Workshop on Logical Frameworks in Antibes, </title> <address> France, </address> <month> May </month> <year> 1990. </year>
Reference: [Tof90] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information & Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: The returned value is hi. We conclude our discussion about evaluation with a few words about the interaction of references and polymorphism. The question is subtle and has received great attention in the literature <ref> [Tof90, Har94, LW91] </ref>. Consider for example the following MLR expression. letname f = ref (lam x: x) in f := lam x: s x; At first sight, this expression allocates a cell and initializes it with the identity function, which has polymorphic type t ! t for any t . <p> Restricting polymorphism to values has also been proposed as a solution to this prob lem <ref> [Tof90] </ref> and has been adopted in the current definition of Standard ML [MTHM96]. This language offers only one form of let, but it takes different courses of action depending on whether it defines a value or an arbitrary expression.
Reference: [Tro86] <author> Anne S. Troelstra. </author> <title> Strong normalization for typed terms with surjective pairing. </title> <journal> Notre Dame Journal of Formal Logic, </journal> <volume> 27(4) </volume> <pages> 547-550, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: A further property that fi! enjoys is strong normalization: if ` M : , then every reduction sequence on M terminates and, by confluence, yields a unique normal form for this term. Proofs of this and stronger properties for extensions of this language can be found in the literature <ref> [Gan80, Tro86] </ref>. The encoding we propose transforms LLF judgments ` U * -# - V into fi! judgments of 22 2 THE LINEAR TYPE THEORY ffi&&gt; the form ` 0 M : . <p> This form of non-determinism does not arise with strongly normalizing terms since the choice of the fi-redex to reduce at every step is arbitrary. The strong normalization theorem states that every derivable term is strongly normalizing. This property holds in fi! , as proved for example in <ref> [Gan80, Tro86] </ref>, and we use this fact to prove that it is valid also for ffi&&gt; . Theorem 2.16 (Strong normalization) If ` U * -# - V , then U is strongly normalizing. Proof.
Reference: [Van96] <author> Myra VanInwegen. </author> <title> The Machine-Assisted Proof of Programming Language Properties. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, Department of Computer and Information Science, </institution> <year> 1996. </year>
Reference-contexts: Therefore, recent work has investigated the possibility of partially automating their generation or at least their verification. Chir-imar gives Forum specifications for a language with references, exceptions and continuations and uses the meta-theory of Forum [Mil94] to study program equivalence [Chi95]. VanInwe-gen <ref> [Van96] </ref> formally proved properties such as value soundness for most of Standard ML with the help of the HOL theorem prover [GM93]. In this section, we define MLR as an extension of Mini-ML with references and imperative instructions, and study aspects of its meta-theory. <p> A complete treatment can be found in Appendix A. It is interesting to compare the result of our encoding with similar endeavors in the literature. VanInwegen used the HOL theorem prover [GM93] to verify properties about a substantial portion of Standard ML <ref> [Van96] </ref>. She adopted a brute-force approach to the meta-representation problem, encoding, for example, contexts as terms.
Reference: [Wad90] <author> Philip Wadler. </author> <title> Linear types can change the world. </title> <editor> In M. Broy and C. B. Jones, editors, </editor> <booktitle> IFIP TC 2 Working Conference on Programming Concepts and Methods, </booktitle> <pages> pages 561-581, </pages> <address> Sea of Gallilee, Israel, April 1990. </address> <publisher> North-Holland. </publisher>
Reference: [WF94] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <journal> Information & Computation, </journal> <volume> 115(1) </volume> <pages> 38-94, </pages> <month> November </month> <year> 1994. </year> <month> 67 </month>
Reference-contexts: The addition of references and their interaction with polymorphism has been analyzed with different tools, ranging from the complex domain-theoretic approach of Damas [Dam85] to the syntactic formulation of Harper [Har94]. The latter idea was adapted from Wright and Felleisen, who additionally consider continuations and exceptions <ref> [WF94] </ref>. The proofs of these properties are long and error-prone. Therefore, recent work has investigated the possibility of partially automating their generation or at least their verification. <p> We achieve this by distinguishing two forms of let. The expression ref e dynamically allocates a cell and initializes it with the value of e. The contents of a cell can be inspected by dereferencing it with ! and modified with an assignment (:=). Differently from <ref> [WF94] </ref>, but consistently with the main stream in the literature (including the definition of Standard ML [MTHM96]), we choose this operation not to return the assigned object, but the unit element hi.
References-found: 48

