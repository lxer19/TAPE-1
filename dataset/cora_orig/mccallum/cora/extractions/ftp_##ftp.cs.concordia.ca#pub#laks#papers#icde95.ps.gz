URL: ftp://ftp.cs.concordia.ca/pub/laks/papers/icde95.ps.gz
Refering-URL: http://karna.cs.umd.edu:3264/papers/GG97:disassembly/paper.html
Root-URL: 
Email: laks@cs.concordia.ca missaoui.rokia@uqam.ca  
Title: Pushing Semantics inside Recursion: A General Framework for Semantic Optimization of Recursive Queries  
Author: Laks V.S. Lakshmanan Rokia Missaoui 
Address: Quebec a Montreal Montreal, Canada Montreal, Canada  
Affiliation: Dept. of Comp. Sci. Dep. d'Informatique Concordia University Univ. du  
Note: Appears in: ICDE'95.  
Abstract: We consider a class of linear query programs and integrity constraints and develop methods for (i) computing the residues and (ii) pushing them inside the recursive programs, minimizing redundant computation and run-time overhead. We also discuss applications of our strategy to intelligent query answering. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon and R. Ramakrishnan, </author> <title> "An amateur's introduction to recursive query processing strategies," </title> <booktitle> ACM-SIGMOD Conf., </booktitle> <year> 1986, </year> <pages> 16-52. </pages>
Reference-contexts: This situation is similar to the differences and tradeoffs between the two paradigms <ref> [1, 2] </ref> for (conventional) recursive query processing evaluation (e.g., semi-naive evaluation) and rewriting (e.g., magic sets). Semantic optimization by program transformation is comparable to the magic sets method.
Reference: [2] <author> S. Ceri, G. Gottlob, and L. Tanca, </author> <title> "What You Al ways Wanted to Know About Datalog (And Never Dared to Ask)," </title> <journal> IEEE Trans. Knowledge and Data Eng., </journal> <month> (March </month> <year> 1989), </year> <pages> 146-166. </pages>
Reference-contexts: This situation is similar to the differences and tradeoffs between the two paradigms <ref> [1, 2] </ref> for (conventional) recursive query processing evaluation (e.g., semi-naive evaluation) and rewriting (e.g., magic sets). Semantic optimization by program transformation is comparable to the magic sets method.
Reference: [3] <author> U.S. Chakravarthy, J. Grant, and J. Minker, </author> <title> "Logic Based Approach to Semantic Query Optimization," </title> <journal> ACM TODS, </journal> <month> (June </month> <year> 1990), </year> <pages> 162-207. </pages>
Reference-contexts: The notion of residues (free or otherwise) can be associated with expansion sequences in the obvious manner. We remark that the same algorithm given in <ref> [3] </ref> for partial subsumption and residue generation can be used for testing free subsumption and generating free residues, with minor modifications. <p> For testing maximal subsumption, one can use a minor variant of the subsumption algorithm in <ref> [3] </ref>. For more details on the algorithm, its efficiency, and its proof of correctness, the reader is referred to [8]. Suppose that an IC generates a residue R w.r.t. an expansion sequence s, and that R has a database atom A in its head. Let be the subsuming substitution. <p> It can be verified that ic 1e and hence ic 1 partially subsumes r 1 in the sense of <ref> [3] </ref>, giving rise to the residue P = P 0 ! expert (P; F ). However, notice that this residue is trivial in the context of the recursive rule r 1 , and is hence not useful for optimization. Now, let us consider free subsumption. <p> Further, it is a conditional null residue if m &gt; 0 (unconditional, otherwise). 2 We discuss the types of fundamental optimizations suggested by the various types of residues. We shall see that they generalize the operations discussed in Chakravarthy et al <ref> [3] </ref> to the recursive case. (1) Atom Elimination: An atom deduced to be redundant in an expansion sequence of the program is deleted. The atom may be database or evalu-able. Atom elimination may be conditional or unconditional, depending on the type of the fact residue that induces it. <p> This essentially says the proof tree r 1 r 1 r 1 can be pruned whenever Y a 50 holds. This example illustrates (conditional) subtree pruning. 2 We have seen the fundamental types of optimization induced by the residues. A key difference between the approach of <ref> [3] </ref> and ours is that our residues are not just w.r.t. rules but are rather w.r.t. expansion sequences. Hence the optimization we suggest is not directly on the program, but on the proof trees generated by it. <p> in the residue associated with the third proof tree, since the latter, being an empty conjunction, corresponds to true. 6 Summary and Future Research In this paper, we have developed techniques for generating residues as well pushing them inside recursion, as an alternative to the evaluation based approach developed by <ref> [3, 9] </ref>. This situation is similar to the differences and tradeoffs between the two paradigms [1, 2] for (conventional) recursive query processing evaluation (e.g., semi-naive evaluation) and rewriting (e.g., magic sets). Semantic optimization by program transformation is comparable to the magic sets method.
Reference: [4] <author> T. Gaasterland, P. Godfrey and J. Minker, </author> <title> "Relaxation as a Platform for Cooperative Answering," </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1, </volume> <year> (1992), </year> <pages> 293-321. </pages>
Reference-contexts: Intelligent query answering has been studied by several researchers <ref> [4, 5, 11] </ref> In this section, we shall show via examples that some of the techniques studied by Motro and Yuan [11] can be captured within our framework for semantic query optimization.
Reference: [5] <author> T. Imielinski, </author> <title> "Intelligent query answering in rule based systems," </title> <journal> Journal of Logic Programming, </journal> <volume> 4, 3, </volume> <month> (September </month> <year> 1987), </year> <pages> 229-257. </pages>
Reference-contexts: Intelligent query answering has been studied by several researchers <ref> [4, 5, 11] </ref> In this section, we shall show via examples that some of the techniques studied by Motro and Yuan [11] can be captured within our framework for semantic query optimization.
Reference: [6] <author> V.S. Lakshmanan and H. Hernandez, </author> <title> "Structural Query Optimization: A Uniform Framework for Semantic Query Optimization in Deductive Databases," </title> <booktitle> Proc. ACM SIGACT-SIGMOD Symp. Principles of Database Systems, </booktitle> <address> Denver, </address> <month> May 29-31, </month> <year> 1991, </year> <pages> 102-114. </pages>
Reference: [7] <author> V.S. Lakshmanan and R. Missaoui, </author> <title> "On Semantic Query Optimization in Deductive Databases," </title> <booktitle> Proc. IEEE Int. Conf. Data Eng., </booktitle> <year> 1992, </year> <pages> 368-375. </pages>
Reference: [8] <author> V.S. Lakshmanan and R. Missaoui, </author> <title> "Semantic Optimization of Recursive Queries Pushing Semantics inside Recursion," </title> <type> Tech. Report, </type> <institution> Dept. of Comp. Science, Concordia University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: This still covers a wide class of ICs of practical interest. Let P be a program and ic be an IC of the above form. The idea behind generating residues <ref> [8] </ref> is to determine if the IC (partially) subsumes any rule or any expansion sequence. In general, an IC may well (partially) subsume more than one expansion sequence, where the subsumption is free in the sense of Section 2. <p> For testing maximal subsumption, one can use a minor variant of the subsumption algorithm in [3]. For more details on the algorithm, its efficiency, and its proof of correctness, the reader is referred to <ref> [8] </ref>. Suppose that an IC generates a residue R w.r.t. an expansion sequence s, and that R has a database atom A in its head. Let be the subsuming substitution. <p> In the sequel, we only consider residues that are useful for their expansion sequences. Detecting useful residues for expansion sequences is discussed in detail in <ref> [8] </ref> and is beyond the scope of this paper. In the next section, we classify residues generated by maximal (free) subsumption into different types, depending on the kind of optimization they can lead to. <p> Theorem 4.1. The transformation described by Algorithm 4.1 preserves equivalence. Proof. The proof is by showing that every proof tree generated by the original program is generated by the transformed program and vice versa. The complete details and illustrative examples can be found in <ref> [8] </ref>. 2 We next discuss Stage 2 of our transformation process. Optimization by Pushing: The optimizing transformation evidently depends on the type of the residue. In the discussion below, we assume that the residues have at most one subgoal in their body. This is only for simplicity.
Reference: [9] <author> S. Lee and J. Han, </author> <title> "Semantic query optimization in recursive databases," </title> <booktitle> Proc. IEEE Int. Conf. Data Eng., </booktitle> <year> 1988, </year> <pages> 444-451. </pages>
Reference-contexts: in the residue associated with the third proof tree, since the latter, being an empty conjunction, corresponds to true. 6 Summary and Future Research In this paper, we have developed techniques for generating residues as well pushing them inside recursion, as an alternative to the evaluation based approach developed by <ref> [3, 9] </ref>. This situation is similar to the differences and tradeoffs between the two paradigms [1, 2] for (conventional) recursive query processing evaluation (e.g., semi-naive evaluation) and rewriting (e.g., magic sets). Semantic optimization by program transformation is comparable to the magic sets method.
Reference: [10] <author> S.-G. Lee, L.J. Henschen, and G.Z. Qadah, </author> <title> "Semantic Query Reformulation in Deductive Databases," </title> <booktitle> Proc. IEEE Int. Conf. Data Eng., </booktitle> <address> April 8-12, 1991, Kobe, Japan, </address> <pages> 232-239. </pages>
Reference: [11] <author> Motro, A. and Yuan, </author> <title> "Querying database knowledge", </title> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: Intelligent query answering has been studied by several researchers <ref> [4, 5, 11] </ref> In this section, we shall show via examples that some of the techniques studied by Motro and Yuan [11] can be captured within our framework for semantic query optimization. <p> Intelligent query answering has been studied by several researchers [4, 5, 11] In this section, we shall show via examples that some of the techniques studied by Motro and Yuan <ref> [11] </ref> can be captured within our framework for semantic query optimization. The basic idea in intelligent query answering is that it must be possible to elicit answers from the database that describe the "objects" (or tuples) which would constitute answers in a conventional sense of the term. <p> The difference between such queries and conventional queries is that answers to these queries are not expected in the traditional form of sets of tuples satisfying query bindings. Rather, some explanation or summary information regarding the (conventional types of) answers to queries is what is expected. Motro and Yuan <ref> [11] </ref> proposed the following special syntax for formulating the so-called knowledge queries, which expect intelligent answers. describe '(X) where (X). <p> The associated residue is helpful in generating descriptive answers to the original query. Example 5.1. Consider the following deductive database, adapted from Motro and Yuan <ref> [11] </ref>. r 0 : honors (Stud) :- transcript (Stud; M ajor; Cred; Gpa); Cred 30; Gpa 3:8 r 1 : honors (Stud) :- transcript (Stud; M ajor; Cred; Gpa); Gpa 3:8; exceptional (Stud). r 2 : exceptional (Stud) : publication (Stud; P ); appears (P; Jl); reputed (J l). r 3
Reference: [12] <author> J. F. Naughton, R. Ramakrishnan, Y. Sagiv, and J.D. Ullman, </author> <title> "Efficient evaluation of right-, left-, and multi-linear rules," </title> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1989, </year> <pages> 235-242. </pages>
Reference: [13] <author> Y. Sagiv, </author> <title> "Optimizing datalog programs," </title> <booktitle> 6th ACM PODS, </booktitle> <year> 1987, </year> <pages> 349-362. </pages>
Reference: [14] <author> J.D. Ullman, </author> <title> Principles of Database and Knowledge-Base Systems, vol I & II, Comp. </title> <publisher> Sci. Press, </publisher> <address> MD., </address> <year> 1988. </year>
Reference-contexts: We assume that the rules are rectified so that all rules defining the same predicate have an identical head, and X i appears in column i of the head predicate <ref> [14] </ref>. This assumption is not restrictive since it is well known that all programs can be rectified. We shall denote by p i , 1 i n, the ith argument position of p in the body of a recursive rule.
References-found: 14

