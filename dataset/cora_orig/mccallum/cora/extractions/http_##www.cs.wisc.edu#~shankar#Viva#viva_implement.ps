URL: http://www.cs.wisc.edu/~shankar/Viva/viva_implement.ps
Refering-URL: http://www.cs.wisc.edu/~shankar/Viva/viva.html
Root-URL: 
Email: (shankar@pop.uky.edu)  
Title: Implementing the VIVA filesystem in the Linux kernel  
Author: Shankar Pasupathy Advisor: Dr. Raphael Finkel 
Date: July 1996  
Address: Lexington, KY 40506.  
Affiliation: University of Kentucky,  
Abstract: The Viva filesystem was designed to minimize the time taken for file operations. Viva achieves this goal by using an allocation policy that clusters sequentially accessed disk blocks so that disk-head movement is minimized. Viva also uses this clustering to compress block addresses in an inode from 32 bits to 1 bit, relative to traditional filesystems. This compression allows us to access about 800KB of data without using indirect blocks. Benchmark results of our implementation of Viva in the Linux kernel show that it is faster than Ext2, the default Linux filesystem, for common file operations. 
Abstract-found: 1
Intro-found: 1
Reference: [Bach 86] <author> Maurice J. Bach. </author> <title> The design of the UNIX operating system. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Our experience shows that for small files, indexing is not useful. We didn't implement indexing of sparse bitmaps in the Linux version of Viva. 2.6 Inodes An inode in Viva contains a sparse bitmap (described earlier) and other information <ref> [Bach 86] </ref>. Sparse bitmaps tend to make Viva inodes roughly twice as large as traditional Unix inodes, so care must be taken while determining the proportion of inodes in a Viva file system. Viva's original design stores some file data in the inode itself.
Reference: [Card 95] <author> Remy Card. </author> <title> The Second Extended File System current state, </title> <booktitle> future devel opment. Second International Linux and Internet Conference, </booktitle> <address> Berlin, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The Fast File System attempts to allocate data blocks within a file contiguously on disk, by using cylinder groups [McKusick 84]. The Ext2 filesystem allocates disk blocks contiguously using group descriptors and bitmaps for allocation <ref> [Card 95] </ref>. Viva increases data throughput by using bitmaps for allocation, and a very efficient. allocation algorithm to lay out a file's data blocks quickly, and contiguously on disk. It then uses this contiguity to compress disk block addresses in the file's inode. <p> It might be useful to create a library of routines to read the superblock, allocation bitmaps and segment information in a Viva filesystem. Such a library already exists for the Ext2 system and has proven to be useful in writing Ext2's mkfs and fsck programs <ref> [Card 95] </ref>. We will also re-evaluate our benchmarks on a larger disk partition, after aging the partition to reflect regular use of the disk.
Reference: [Card 96] <author> Remy Card. </author> <title> File Management in the Linux kernel. </title> <note> Slides available via ftp from masi.ibp.fr </note>
Reference: [Johnson 96] <author> Michael K. Johnson. </author> <title> Kernel Hackers Guide. Linux Documentation Project. Available from http://sunsite.unc.edu/mdw Implementing VIVA in the Linux kernel 18 </title>
Reference-contexts: Linux's VFS is one of the most poorly documented parts of the kernel and is difficult to understand unless one already knows how Unix filesystems work. The best way to learn about VFS is to read the source code. There is also some limited documentation available on the Internet <ref> [Johnson 96] </ref>. The VFS layer also implements Linux's buffer cache. File systems read data from and write to buffers, not the disk. The VFS layer manages buffers by organizing the into LRU lists.
Reference: [Herrin 93] <author> Eric H. Herrin II and Raphael A. Finkel. </author> <title> The Viva filesystem. </title> <type> Technical Report 225-93, </type> <institution> University of Kentucky. </institution> <year> 1993. </year>
Reference-contexts: Viva was designed by Eric Herrin II, and Raphael Finkel in 1993. Eric implemented Viva in the BSD kernel, but could not release the code publicly due to some copyright problems. My implementation of Viva is based on the original paper <ref> [Herrin 93] </ref>. 2.2 The superblock and inodes The structure of every filesystem is described in a special block called the superblock. It stores the number of blocks used by the filesystem, pointers to structures used to allocate blocks, and various other useful pieces of information. <p> Each entry 5 consists of a starting data block address, length of 4 It's called a sparse bitmap since it is not in 1-1 correspondence with the block allocation bitmap, which would be a full or complete bitmap. 5 Our entries are implemented a bit differently from their original implementation <ref> [Herrin 93] </ref>. Implementing VIVA in the Linux kernel 5 the entry's bitmap in bytes, and up to 256 bytes of allocation bitmap from the start address. For example, consider a traditional inode, with 8 pointers to data blocks. Suppose those pointers contained the disk addresses 2135, 2136,: : : ,2142. <p> These data blocks make up a pseudo-file which is represented by a fragment sparse bitmap. The fragment allocation bitmap keeps track of which fragments are in use. We did not implement fragments in the Linux version of Viva. For details on implementing fragments, see the original paper on Viva <ref> [Herrin 93] </ref>. Implementing VIVA in the Linux kernel 7 2.8 Block allocation algorithm The goal of Viva's block allocation algorithm is to cluster data blocks of a file together on the disk, and to place inodes of a directory close to each other.
Reference: [McKusick 84] <author> Marshall K. McKusick, William N. Joy, Samuel J. Le*er and Robert S. Fabry. </author> <title> A fast filesystem for Unix. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-197. </pages>
Reference-contexts: To improve performance, some filesystems, such as log-structured file systems, buffer sequential writes and write them out in one operation. The Fast File System attempts to allocate data blocks within a file contiguously on disk, by using cylinder groups <ref> [McKusick 84] </ref>. The Ext2 filesystem allocates disk blocks contiguously using group descriptors and bitmaps for allocation [Card 95]. Viva increases data throughput by using bitmaps for allocation, and a very efficient. allocation algorithm to lay out a file's data blocks quickly, and contiguously on disk.
Reference: [Le*er 89] <author> Samuel J. Le*er, Marshall K. McKusick, Michael J. Karels and John S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX operating system. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
References-found: 7

