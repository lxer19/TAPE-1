URL: http://www.cs.sunysb.edu/~abhik/transform/tr98.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~abhik/transform/papers.html
Root-URL: http://www.cs.sunysb.edu
Email: fabhik,kumar,cram,ramg@cs.sunysb.edu  
Title: A Generalized Unfold/Fold Transformation System for Defi- nite Logic Programs  
Author: Abhik Roychoudhury K. Narayan Kumar C.R. Ramakrishnan I.V. Ramakrishnan 
Address: NY 11794, USA.  
Affiliation: Department of Computer Science SUNY at Stony Brook,  
Abstract-found: 0
Intro-found: 1
Reference: [AD95] <author> C. Aravindan and P.M. Dung. </author> <title> On the correctness of unfold/fold transformations of normal and extended logic programs. </title> <journal> In Journal of Logic Programming, </journal> <pages> pages 295-322, </pages> <year> 1995. </year>
Reference-contexts: Kanamori and Fujita [KF87] proposed a transformation system that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation <ref> [AD95, Sek91, Sek93] </ref>) and applied to practical problems (e.g., [BCD90, BB93, PPR97]).
Reference: [BB93] <author> D. Boulanger and M. Bruynooghe. </author> <title> Deriving unfold/fold transformations of logic programs using extended OLDT-based abstract interpretation. </title> <journal> Journal of Symbolic Computation, </journal> <pages> pages 495-521, </pages> <year> 1993. </year>
Reference-contexts: Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., <ref> [BCD90, BB93, PPR97] </ref>). All the above systems differ from each other mainly in terms of the fold operations they permit. fl Research done while on leave from SPIC Mathematical Institute, Chennai, India. 1 Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1.
Reference: [BCD90] <author> A. Bossi, N. Cocco, and S. Dulli. </author> <title> A method of specializing logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <pages> pages 253-302, </pages> <year> 1990. </year>
Reference-contexts: Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., <ref> [BCD90, BB93, PPR97] </ref>). All the above systems differ from each other mainly in terms of the fold operations they permit. fl Research done while on leave from SPIC Mathematical Institute, Chennai, India. 1 Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1.
Reference: [BD77] <author> R.M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> In Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <year> 1977. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation [LS95, LSdW96, JGS93, Sch81]) and deriving efficient programs from high-level specifications (e.g., program synthesis <ref> [BD77, DL94] </ref>). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [DL94] <author> Y. Deville and K.-K. Lau. </author> <title> Logic program synthesis. </title> <journal> In Journal of Logic Programming, </journal> <pages> pages 321-350, </pages> <year> 1994. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation [LS95, LSdW96, JGS93, Sch81]) and deriving efficient programs from high-level specifications (e.g., program synthesis <ref> [BD77, DL94] </ref>). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [GK94] <author> M. Gergatsoulis and M. Katzouraki. </author> <title> Unfold/fold transformations for definite clause programs. </title> <booktitle> In PLILP'94, </booktitle> <volume> LNCS 844, </volume> <pages> pages 340-354, </pages> <year> 1994. </year>
Reference-contexts: Kanamori and Fujita [KF87] proposed a transformation system that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses <ref> [GK94] </ref>, negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., [BCD90, BB93, PPR97]). <p> In order to ensure that folding is still totally correct, these systems permit folding using only clauses with certain (syntactic) properties. Thus, the original Tamaki-Sato system permits folding using a single clause only (conjunctive folding) and this clause is required to be non-recursive. In <ref> [GK94] </ref> the above system was extended to allow folding with multiple clauses (disjunctive folding) but all of these clauses are required to be be non-recursive. Kanamori and Fujita [KF87] as well Tamaki and Sato in a later paper [TS86] gave two different approaches for conjunctive folding using recursive clauses. <p> Design of such a transformation system has remained open. We describe one such system in this paper. We describe SCOUT ( Strata and COunter based Unfold/fold Transformations), a transformation system that is strictly more powerful (in terms of transformation sequences permitted) than existing irreversible unfold/fold systems, such as <ref> [TS86, KF87, GK94] </ref>. SCOUT is based on counters due to Kanamori and Fujita [KF87] and the notion of strata introduced by Tamaki and Sato in [TS86]. <p> The above instantiations com pletely specify the Kanamori-Fujita system as an instance of our framework. Along similar lines, we can instantiate our framework to obtain other unfold/fold systems such as <ref> [TS86, GK94] </ref>. 2.3 Goal Replacement Goal replacement is a powerful transformation that allows semantically equivalent conjunctions of atoms to be freely interchanged. <p> The current literature for unfold-fold transformations of logic programs contains either systems allowing disjunctive folding by multiple non-recursive folder clauses, such as <ref> [GK94] </ref> or systems allowing conjunctive folding by a potentially recursive folder clause. Thus, to the best of our knowledge, the basic system presented in section 3 is the first fold-unfold transformation system which allows disjunctive folding using multiple and potentially recursive folder clauses. <p> We then proceed to show that any unfold-fold transformation sequence covered by either [KF87] or [TS86] (i.e. existing techniques for conjunctive folding) is covered by SCOUT. Also, the proof that SCOUT covers existing techniques for disjunctive folding, like <ref> [GK94] </ref> is trivial, since [GK94] restricts the folder clauses to be non-recursive. SCOUT differs from the basic transformation system presented before only in the annotation of the program clauses. Previously, each clause was annotated with a counter (fl; fl 0 ) where fl; fl 0 2 Z. <p> We then proceed to show that any unfold-fold transformation sequence covered by either [KF87] or [TS86] (i.e. existing techniques for conjunctive folding) is covered by SCOUT. Also, the proof that SCOUT covers existing techniques for disjunctive folding, like <ref> [GK94] </ref> is trivial, since [GK94] restricts the folder clauses to be non-recursive. SCOUT differs from the basic transformation system presented before only in the annotation of the program clauses. Previously, each clause was annotated with a counter (fl; fl 0 ) where fl; fl 0 2 Z. <p> The only canonical form that is considered here (expressed by predicate canonical/1) are strings of the form b fl . Finally, the predicate spec red/1 is a specialization of reducible/1. Typically a fold/unfold transformation system, such as the ones described in <ref> [TS84, GK94] </ref> includes a definition transformation, which allows us to define new predicates. In our system SCOUT, we have got rid of the definition trasformation for the sake of clarity of presentation of the system and its correctness proof.
Reference: [JGS93] <author> N.D. Jones, C.K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation <ref> [LS95, LSdW96, JGS93, Sch81] </ref>) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [KF86] <author> T. Kanamori and H. Fujita. </author> <title> Unfold/fold Transformation of Logic Programs with Counters. </title> <type> Technical report, </type> <institution> ICOT, </institution> <year> 1986. </year>
Reference: [KF87] <author> T. Kanamori and H. Fujita. </author> <title> Unfold/fold Transformation of Logic Programs with Counters. In USA-Japan Seminar on Logics of Programs, </title> <note> Available at http://www.cs.sunysb.edu/~abhik/transform/papers.html, 1987. </note>
Reference-contexts: A unfold/fold transformation system for definite logic programs was first described in a seminal paper by Tamaki and Sato [TS84]. In the flurry of research activity that followed, a number of unfold/fold transformation systems were developed. Kanamori and Fujita <ref> [KF87] </ref> proposed a transformation system that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. <p> Many program transformation systems permit irreversible folding, by allowing folding at step i using clauses that are not in P i . For example, in the original and extended Tamaki-Sato systems [TS84, TS86] folding always uses clauses in P 0 whereas in the Kanamori-Fujita system <ref> [KF87] </ref> the clauses can come from any P j (j i). In order to ensure that folding is still totally correct, these systems permit folding using only clauses with certain (syntactic) properties. <p> In [GK94] the above system was extended to allow folding with multiple clauses (disjunctive folding) but all of these clauses are required to be be non-recursive. Kanamori and Fujita <ref> [KF87] </ref> as well Tamaki and Sato in a later paper [TS86] gave two different approaches for conjunctive folding using recursive clauses. In many examples, such as the one we describe in Section 6, folding in presence of both disjunction and recursion is crucial. <p> Design of such a transformation system has remained open. We describe one such system in this paper. We describe SCOUT ( Strata and COunter based Unfold/fold Transformations), a transformation system that is strictly more powerful (in terms of transformation sequences permitted) than existing irreversible unfold/fold systems, such as <ref> [TS86, KF87, GK94] </ref>. SCOUT is based on counters due to Kanamori and Fujita [KF87] and the notion of strata introduced by Tamaki and Sato in [TS86]. <p> We describe SCOUT ( Strata and COunter based Unfold/fold Transformations), a transformation system that is strictly more powerful (in terms of transformation sequences permitted) than existing irreversible unfold/fold systems, such as [TS86, KF87, GK94]. SCOUT is based on counters due to Kanamori and Fujita <ref> [KF87] </ref> and the notion of strata introduced by Tamaki and Sato in [TS86]. <p> The proof of SCOUT subsuming some of the existing unfold/fold systems (in terms of the transformation sequences allowed) is also presented in this section. Finally, in section 6, we present an example to illustrate the use of SCOUT, our new unfold/fold transformation system. 2 A Parameterized Transformation Framework Following <ref> [KF87, TS84] </ref> we first develop our abstract framework using two transformations: Unfolding and Folding. Subsequently, we show how Goal Replacement transformation can be added to this framework. Throughout we will draw on the Kanamori-Fujita system [KF87] for illustrating the abstract concepts in our framework. <p> Subsequently, we show how Goal Replacement transformation can be added to this framework. Throughout we will draw on the Kanamori-Fujita system <ref> [KF87] </ref> for illustrating the abstract concepts in our framework. We assume familiarity with the standard notions of terms, models, substitutions, unification, most general unifier (mgu), definite clauses, SLD resolution, and proof trees [Llo93]. <p> It is worth noting that we do not attempt to translate every proof of A in P i to a proof of A in P i+1 . Instead, following <ref> [KF87, TS86, TS84] </ref> we consider a "special proof" called strongly measure-consistent proof (see Definition 6) of A in P i and construct a proof of A in P i+1 . <p> We use to denote the inverse operation of the group hM; i. We also use as a binary operator, with a b meaning a (b) (where (b) is the inverse of b). The Kanamori-Fujita system <ref> [KF87] </ref> keeps track of integer counters. Thus the corresponding measure structure is hZ; +; ; Ni, where Z and N are the set of integers and natural numbers respectively, + denotes integer addition, and is the arithmetic comparison operator. <p> ; : : : ; A n of a clause C 2 P used in T satisfies: (i) ff (A i ) ff (A) and (ii) fl lo (C) P We point out that our abstract notion of strong measure consistency relaxes the concrete notion of rank consistency used in <ref> [KF87] </ref>. While rank consistency of [KF87] imposes a strict equality constraint on ff (A), strong consistency only bounds it from above and below. As we will show later, this facilitates maintenance of approximate information which is crucial to permit disjunctive folding. Weak consistency corresponds to invariant I3 used in [KF87]. <p> A n of a clause C 2 P used in T satisfies: (i) ff (A i ) ff (A) and (ii) fl lo (C) P We point out that our abstract notion of strong measure consistency relaxes the concrete notion of rank consistency used in <ref> [KF87] </ref>. While rank consistency of [KF87] imposes a strict equality constraint on ff (A), strong consistency only bounds it from above and below. As we will show later, this facilitates maintenance of approximate information which is crucial to permit disjunctive folding. Weak consistency corresponds to invariant I3 used in [KF87]. <p> in <ref> [KF87] </ref>. While rank consistency of [KF87] imposes a strict equality constraint on ff (A), strong consistency only bounds it from above and below. As we will show later, this facilitates maintenance of approximate information which is crucial to permit disjunctive folding. Weak consistency corresponds to invariant I3 used in [KF87]. For proving total correctness, we need : Definition 7 (Measure consistent Program) A program P is said to be measure consistent w.r.t. atom measure ff and clause measure (fl lo ; fl hi ), if for all A 2 M (P ), we have: 1. <p> The clause measures of the other clauses of P i+1 are inherited from P i . 2 Observe that, similar to the goal replacement transformation in <ref> [KF87, TS84, TS86] </ref> the conditions under which the above rule may be applied are not testable at transformation time. <p> is the clause in S i and C is the clause in S i+1 , so C 0 is replaced to get C. 16 5 Generalizations of the Basic Transformation System The basic transformation system presented in section 3 is essentially an extension of the system of Kanamori and Fujita <ref> [KF87] </ref> which allows conjunctive folding by a folder clause with recursive calls. The current literature for unfold-fold transformations of logic programs contains either systems allowing disjunctive folding by multiple non-recursive folder clauses, such as [GK94] or systems allowing conjunctive folding by a potentially recursive folder clause. <p> These transformations are particularly useful for applications such as reachability analysis of parametrized systems. Conjunctive folding using a recursive folder clause has been studied in two different approaches which are theoretically incomparable (in terms of the transformation sequences that each one covers). Kanamori and Fujita's approach <ref> [KF87] </ref> annotates each program clause C with a counter which roughly denotes the amount of savings (in execution steps) incurred by applying C as compared to the application of the clause in the original program from which C is derived. <p> SCOUT is a transformation system which combines the two seemingly disjoint notions, namely stratification and counters. We present only the unfolding and folding rules first and show that our fold/unfold system is strictly more powerful than the systems reported in <ref> [KF87] </ref> and [TS86]. This is done in section 5.1. Then, we show that how a simple modification of the unfold/fold rules also allows us to embed certain kinds of semantic reasoning within these syntactic transformations. <p> This is done in section 5.2. 5.1 Combining stratification and counters In this section, we present SCOUT, a generalization of the basic system presented in section 3. We then proceed to show that any unfold-fold transformation sequence covered by either <ref> [KF87] </ref> or [TS86] (i.e. existing techniques for conjunctive folding) is covered by SCOUT. Also, the proof that SCOUT covers existing techniques for disjunctive folding, like [GK94] is trivial, since [GK94] restricts the folder clauses to be non-recursive. <p> The proof for Lemma 4 proceeds as in section 4 except for the interpretation of the inequalities and the arithmetic operations. 2 We now proceed to show that SCOUT covers any fold/unfold transformation sequence which is allowed in the systems reported in <ref> [KF87] </ref> and [TS86]. We can trivially show this for the system reported in [KF87] since that is special case of SCOUT where folding is conjunctive and all the predicate symbols of the initial program are placed in a single stratum. 11 For proving that SCOUT covers any transformation sequence S 0 <p> proceeds as in section 4 except for the interpretation of the inequalities and the arithmetic operations. 2 We now proceed to show that SCOUT covers any fold/unfold transformation sequence which is allowed in the systems reported in <ref> [KF87] </ref> and [TS86]. We can trivially show this for the system reported in [KF87] since that is special case of SCOUT where folding is conjunctive and all the predicate symbols of the initial program are placed in a single stratum. 11 For proving that SCOUT covers any transformation sequence S 0 ! S 1 ! S 2 ; ::: which is allowed by the <p> Recall that in [TS86] each clause in any S i is associated with a strata number, also called the descent level. Also, since [TS86] 11 In fact, strictly speaking, certain variants of the folding rule in <ref> [KF87] </ref> also allows folding when ffi = fl + n provided A H in some irreflexive antisymmetric, transitive order (where A is the head of the folded clause, H is the folded atom, ffi and fl are the counters of folder and folded clauses respectively, and n + 1 is the
Reference: [Llo93] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming, Second Edition. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Throughout we will draw on the Kanamori-Fujita system [KF87] for illustrating the abstract concepts in our framework. We assume familiarity with the standard notions of terms, models, substitutions, unification, most general unifier (mgu), definite clauses, SLD resolution, and proof trees <ref> [Llo93] </ref>.
Reference: [LS95] <author> J.W. Lloyd and J.C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> In Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 295-322, </pages> <year> 1995. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation <ref> [LS95, LSdW96, JGS93, Sch81] </ref>) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [LSdW96] <author> M. Leuschel, D. De Schreye, and A. de Waal. </author> <title> A conceptual embedding of folding into partial deduction : Towards a maximal integration. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 319-332, </pages> <year> 1996. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation <ref> [LS95, LSdW96, JGS93, Sch81] </ref>) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [Mah87] <author> M. J. Maher. </author> <title> Correctness of a Logic Program Transformation System. </title> <type> Technical report, </type> <institution> IBM T.J. Watson Research Center, </institution> <year> 1987. </year>
Reference-contexts: In the flurry of research activity that followed, a number of unfold/fold transformation systems were developed. Kanamori and Fujita [KF87] proposed a transformation system that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding <ref> [Mah87] </ref>. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., [BCD90, BB93, PPR97]). <p> Now folding q (X) in the second clause of q in P 0 2 (using clauses defining p in P 1 ), we get P 0 3 , whose least model differs from that of P 0 . Maher's reversible transformation system <ref> [Mah87] </ref> ensures total correctness by exploiting the prop erty of reversibility: since the effect of any reversible transformation can be undone by applying another transformation, all partially correct transformation sequences are also totally correct [PP98].
Reference: [PP98] <author> A. Pettorossi and M. Proietti. </author> <title> Transformation of Logic Programs, </title> <booktitle> volume 5 of Handbook of Logic in Artificial Intelligence, </booktitle> <pages> pages 697-787. </pages> <publisher> Oxford University Press, </publisher> <year> 1998. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation [LS95, LSdW96, JGS93, Sch81]) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see <ref> [PP98] </ref> for an excellent survey of research done on this topic over the past decade). Unfold/Fold Transformations Some of the most extensively studied transformation systems for logic programs are the so called unfold/fold transformation systems, which consist of two elementary transformations unfolding and folding. <p> Maher's reversible transformation system [Mah87] ensures total correctness by exploiting the prop erty of reversibility: since the effect of any reversible transformation can be undone by applying another transformation, all partially correct transformation sequences are also totally correct <ref> [PP98] </ref>. However, for reversibility, folding at step i of the transformation can only use the clauses in P i . A new unfold/fold transformation system Reversibility is a strict condition and disallows many correct folding transformations.
Reference: [PPR97] <author> A. Pettorossi, M. Proietti, and S. Renault. </author> <title> Reducing nondeterminism while specializing logic programs. </title> <booktitle> In 24th POPL, </booktitle> <pages> pages 414-427, </pages> <year> 1997. </year>
Reference-contexts: Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation [AD95, Sek91, Sek93]) and applied to practical problems (e.g., <ref> [BCD90, BB93, PPR97] </ref>). All the above systems differ from each other mainly in terms of the fold operations they permit. fl Research done while on leave from SPIC Mathematical Institute, Chennai, India. 1 Correctness of Unfold/Fold Transformations Consider the sequence of programs in Figure 1.
Reference: [Ram98] <author> C.R. Ramakrishnan et. al. </author> <title> Logic programming and Model checking. </title> <booktitle> Proceedings of PLILP/ALP, </booktitle> <volume> LNCS 1490, </volume> <pages> pages 1-20, </pages> <year> 1998. </year> <month> 28 </month>
Reference-contexts: : C15 theorem (0). (9,9) C16 theorem (0) : reducible ([b]): (10; 10) C29 theorem (s (N)) : theorem (N): (3; 1) Folding using recursive and disjunctive clauses is particularly important for verifying parametrized systems (such as a n-process token ring for arbitrary n) using logic program evaluation and deduction <ref> [RRRS98, Ram98] </ref>. For instance, the underlying "inductive structure" of answer-set of theorem (N) in the above example is made explicit by applying unfold, fold and goal replacement transformations.
Reference: [RRRS98] <author> A. Roychoudhury, C. R. Ramakrishnan, I. V. Ramakrishnan, and S. A. Smolka. </author> <title> Tabulation based Induction proofs with applications to Automated Verification. International Workshop on Tabulation in Parsing and Deduction, </title> <note> Available at http://www.cs.sunysb.edu/~abhik/transform/papers.html, 1998. </note>
Reference-contexts: : C15 theorem (0). (9,9) C16 theorem (0) : reducible ([b]): (10; 10) C29 theorem (s (N)) : theorem (N): (3; 1) Folding using recursive and disjunctive clauses is particularly important for verifying parametrized systems (such as a n-process token ring for arbitrary n) using logic program evaluation and deduction <ref> [RRRS98, Ram98] </ref>. For instance, the underlying "inductive structure" of answer-set of theorem (N) in the above example is made explicit by applying unfold, fold and goal replacement transformations.
Reference: [Sch81] <author> W.L. Scherlis. </author> <title> Program improvement by internal specialization. </title> <booktitle> In POPL'81, </booktitle> <pages> pages 41-49, </pages> <year> 1981. </year>
Reference-contexts: Program transformation techniques have been used for program optimization (e.g., partial evaluation <ref> [LS95, LSdW96, JGS93, Sch81] </ref>) and deriving efficient programs from high-level specifications (e.g., program synthesis [BD77, DL94]). Development of transformation techniques is an active area of research in logic programming (see [PP98] for an excellent survey of research done on this topic over the past decade).
Reference: [Sek91] <author> H. Seki. </author> <title> Unfold/fold transformation of startified programs. </title> <booktitle> In Theoretical Computer Science, </booktitle> <pages> pages 107-139, </pages> <year> 1991. </year>
Reference-contexts: Kanamori and Fujita [KF87] proposed a transformation system that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation <ref> [AD95, Sek91, Sek93] </ref>) and applied to practical problems (e.g., [BCD90, BB93, PPR97]).
Reference: [Sek93] <author> H. Seki. </author> <title> Unfold/fold transformation of general logic programs for well-founded semantics. </title> <journal> In Journal of Logic Programming, </journal> <pages> pages 5-23, </pages> <year> 1993. </year>
Reference-contexts: Kanamori and Fujita [KF87] proposed a transformation system that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. The basic Tamaki-Sato system itself was extended in several directions (e.g., to handle folding with multiple clauses [GK94], negation <ref> [AD95, Sek91, Sek93] </ref>) and applied to practical problems (e.g., [BCD90, BB93, PPR97]).
Reference: [TS84] <author> H. Tamaki and T. Sato. </author> <title> Unfold/Fold Transformations of Logic Programs. </title> <booktitle> In Second International Conference on Logic Programming, </booktitle> <pages> pages 127-138, </pages> <year> 1984. </year>
Reference-contexts: As explained below, folding transformations may introduce circularities in definitions and hence may not preserve the meaning of a program. A unfold/fold transformation system for definite logic programs was first described in a seminal paper by Tamaki and Sato <ref> [TS84] </ref>. In the flurry of research activity that followed, a number of unfold/fold transformation systems were developed. Kanamori and Fujita [KF87] proposed a transformation system that was based on maintaining counters to guide folding. Maher described a system that permits only reversible folding [Mah87]. <p> A new unfold/fold transformation system Reversibility is a strict condition and disallows many correct folding transformations. Many program transformation systems permit irreversible folding, by allowing folding at step i using clauses that are not in P i . For example, in the original and extended Tamaki-Sato systems <ref> [TS84, TS86] </ref> folding always uses clauses in P 0 whereas in the Kanamori-Fujita system [KF87] the clauses can come from any P j (j i). In order to ensure that folding is still totally correct, these systems permit folding using only clauses with certain (syntactic) properties. <p> The proof of SCOUT subsuming some of the existing unfold/fold systems (in terms of the transformation sequences allowed) is also presented in this section. Finally, in section 6, we present an example to illustrate the use of SCOUT, our new unfold/fold transformation system. 2 A Parameterized Transformation Framework Following <ref> [KF87, TS84] </ref> we first develop our abstract framework using two transformations: Unfolding and Folding. Subsequently, we show how Goal Replacement transformation can be added to this framework. Throughout we will draw on the Kanamori-Fujita system [KF87] for illustrating the abstract concepts in our framework. <p> It is worth noting that we do not attempt to translate every proof of A in P i to a proof of A in P i+1 . Instead, following <ref> [KF87, TS86, TS84] </ref> we consider a "special proof" called strongly measure-consistent proof (see Definition 6) of A in P i and construct a proof of A in P i+1 . <p> The clause measures of the other clauses of P i+1 are inherited from P i . 2 Observe that, similar to the goal replacement transformation in <ref> [KF87, TS84, TS86] </ref> the conditions under which the above rule may be applied are not testable at transformation time. <p> The only canonical form that is considered here (expressed by predicate canonical/1) are strings of the form b fl . Finally, the predicate spec red/1 is a specialization of reducible/1. Typically a fold/unfold transformation system, such as the ones described in <ref> [TS84, GK94] </ref> includes a definition transformation, which allows us to define new predicates. In our system SCOUT, we have got rid of the definition trasformation for the sake of clarity of presentation of the system and its correctness proof.
Reference: [TS86] <author> H. Tamaki and T. Sato. </author> <title> A Generalized correctness proof of the unfold/ fold logic program transformation. </title> <type> Technical report, </type> <institution> Ibaraki University, </institution> <address> Japan, </address> <year> 1986. </year> <month> 29 </month>
Reference-contexts: A new unfold/fold transformation system Reversibility is a strict condition and disallows many correct folding transformations. Many program transformation systems permit irreversible folding, by allowing folding at step i using clauses that are not in P i . For example, in the original and extended Tamaki-Sato systems <ref> [TS84, TS86] </ref> folding always uses clauses in P 0 whereas in the Kanamori-Fujita system [KF87] the clauses can come from any P j (j i). In order to ensure that folding is still totally correct, these systems permit folding using only clauses with certain (syntactic) properties. <p> In [GK94] the above system was extended to allow folding with multiple clauses (disjunctive folding) but all of these clauses are required to be be non-recursive. Kanamori and Fujita [KF87] as well Tamaki and Sato in a later paper <ref> [TS86] </ref> gave two different approaches for conjunctive folding using recursive clauses. In many examples, such as the one we describe in Section 6, folding in presence of both disjunction and recursion is crucial. Design of such a transformation system has remained open. We describe one such system in this paper. <p> Design of such a transformation system has remained open. We describe one such system in this paper. We describe SCOUT ( Strata and COunter based Unfold/fold Transformations), a transformation system that is strictly more powerful (in terms of transformation sequences permitted) than existing irreversible unfold/fold systems, such as <ref> [TS86, KF87, GK94] </ref>. SCOUT is based on counters due to Kanamori and Fujita [KF87] and the notion of strata introduced by Tamaki and Sato in [TS86]. <p> SCOUT is based on counters due to Kanamori and Fujita [KF87] and the notion of strata introduced by Tamaki and Sato in <ref> [TS86] </ref>. <p> It is worth noting that we do not attempt to translate every proof of A in P i to a proof of A in P i+1 . Instead, following <ref> [KF87, TS86, TS84] </ref> we consider a "special proof" called strongly measure-consistent proof (see Definition 6) of A in P i and construct a proof of A in P i+1 . <p> The above instantiations com pletely specify the Kanamori-Fujita system as an instance of our framework. Along similar lines, we can instantiate our framework to obtain other unfold/fold systems such as <ref> [TS86, GK94] </ref>. 2.3 Goal Replacement Goal replacement is a powerful transformation that allows semantically equivalent conjunctions of atoms to be freely interchanged. <p> The clause measures of the other clauses of P i+1 are inherited from P i . 2 Observe that, similar to the goal replacement transformation in <ref> [KF87, TS84, TS86] </ref> the conditions under which the above rule may be applied are not testable at transformation time. <p> Intuitively, this approach allows folding as long as the benefits from unfolding are not offset by the losses from folding. On the other hand, Tamaki and Sato <ref> [TS86] </ref> perform a stratification of the predicates of the original program. In this approach, each program clause is identified with a strata, and this gets updated on folding and unfolding. Folding is allowed if the strata of the folder clause strictly exceeds the strata of the clause which is folded. <p> In this approach, each program clause is identified with a strata, and this gets updated on folding and unfolding. Folding is allowed if the strata of the folder clause strictly exceeds the strata of the clause which is folded. Also, in <ref> [TS86] </ref>, folder clauses are picked only from the initial program. We now present the SCOUT (Strata and COunter based Unfold/fold Transformations) system. SCOUT is a transformation system which combines the two seemingly disjoint notions, namely stratification and counters. <p> SCOUT is a transformation system which combines the two seemingly disjoint notions, namely stratification and counters. We present only the unfolding and folding rules first and show that our fold/unfold system is strictly more powerful than the systems reported in [KF87] and <ref> [TS86] </ref>. This is done in section 5.1. Then, we show that how a simple modification of the unfold/fold rules also allows us to embed certain kinds of semantic reasoning within these syntactic transformations. <p> This is done in section 5.2. 5.1 Combining stratification and counters In this section, we present SCOUT, a generalization of the basic system presented in section 3. We then proceed to show that any unfold-fold transformation sequence covered by either [KF87] or <ref> [TS86] </ref> (i.e. existing techniques for conjunctive folding) is covered by SCOUT. Also, the proof that SCOUT covers existing techniques for disjunctive folding, like [GK94] is trivial, since [GK94] restricts the folder clauses to be non-recursive. <p> The proof for Lemma 4 proceeds as in section 4 except for the interpretation of the inequalities and the arithmetic operations. 2 We now proceed to show that SCOUT covers any fold/unfold transformation sequence which is allowed in the systems reported in [KF87] and <ref> [TS86] </ref>. <p> special case of SCOUT where folding is conjunctive and all the predicate symbols of the initial program are placed in a single stratum. 11 For proving that SCOUT covers any transformation sequence S 0 ! S 1 ! S 2 ; ::: which is allowed by the fold/unfold system of <ref> [TS86] </ref>, we define the invariants given below. Recall that in [TS86] each clause in any S i is associated with a strata number, also called the descent level. Also, since [TS86] 11 In fact, strictly speaking, certain variants of the folding rule in [KF87] also allows folding when ffi = fl <p> the predicate symbols of the initial program are placed in a single stratum. 11 For proving that SCOUT covers any transformation sequence S 0 ! S 1 ! S 2 ; ::: which is allowed by the fold/unfold system of <ref> [TS86] </ref>, we define the invariants given below. Recall that in [TS86] each clause in any S i is associated with a strata number, also called the descent level. Also, since [TS86] 11 In fact, strictly speaking, certain variants of the folding rule in [KF87] also allows folding when ffi = fl + n provided A H in some irreflexive antisymmetric, transitive <p> transformation sequence S 0 ! S 1 ! S 2 ; ::: which is allowed by the fold/unfold system of <ref> [TS86] </ref>, we define the invariants given below. Recall that in [TS86] each clause in any S i is associated with a strata number, also called the descent level. Also, since [TS86] 11 In fact, strictly speaking, certain variants of the folding rule in [KF87] also allows folding when ffi = fl + n provided A H in some irreflexive antisymmetric, transitive order (where A is the head of the folded clause, H is the folded atom, ffi and fl are the <p> In that case, we can also straightforwardly augment SCOUT by considering such an order . handles only conjunctive folding, any fold/unfold transformation sequence of <ref> [TS86] </ref>, if executable in SCOUT, will always produce clauses with counters of the form (fl; fl); in other words, the two counters of any clause will always be equal. <p> We now consider the following invariants : * J 1 (S i ) Any fold/unfold transformation in program S i which is allowed by <ref> [TS86] </ref> is allowed by SCOUT. * J 2 (S i ) Let C be any clause in program S i with strata number (i.e. descent level in the terminology of [TS86]) j. <p> following invariants : * J 1 (S i ) Any fold/unfold transformation in program S i which is allowed by <ref> [TS86] </ref> is allowed by SCOUT. * J 2 (S i ) Let C be any clause in program S i with strata number (i.e. descent level in the terminology of [TS86]) j. Then C has a counter (fl; fl), where fl = (fl 1 ; :::; fl I ) and (fl j &gt; 0 ^ (81 k &lt; j: fl k = 0)) To prove that any unfold/fold transformation sequence covered by [TS86] is also covered by SCOUT, it is sufficient <p> number (i.e. descent level in the terminology of <ref> [TS86] </ref>) j. Then C has a counter (fl; fl), where fl = (fl 1 ; :::; fl I ) and (fl j &gt; 0 ^ (81 k &lt; j: fl k = 0)) To prove that any unfold/fold transformation sequence covered by [TS86] is also covered by SCOUT, it is sufficient to prove that J 1 (S i ) is an invariant, which we prove below. Theorem 5 Let S 0 ! S 1 ! S 2 ! ::: be a unfold/fold transformation sequence of [TS86]. <p> that any unfold/fold transformation sequence covered by <ref> [TS86] </ref> is also covered by SCOUT, it is sufficient to prove that J 1 (S i ) is an invariant, which we prove below. Theorem 5 Let S 0 ! S 1 ! S 2 ! ::: be a unfold/fold transformation sequence of [TS86]. Then, 8i 0: J 1 (S i ) ^ J 2 (S i ) Proof : By induction on i. For the base case, J 1 (S 0 ) is trivially true by the definition of the fold/unfold transformations in [TS86] and SCOUT. <p> 2 ! ::: be a unfold/fold transformation sequence of <ref> [TS86] </ref>. Then, 8i 0: J 1 (S i ) ^ J 2 (S i ) Proof : By induction on i. For the base case, J 1 (S 0 ) is trivially true by the definition of the fold/unfold transformations in [TS86] and SCOUT. Also, if a clause in S 0 has descent level j, then it has a counter (fl; fl) where fl = (fl 1 ; :::; fl I ), fl j = 1 and fl l = 0 when l 6= j. <p> Then, fl = fl 0 + fl 00 . Also let the descent level of C, C 0 and C 00 be k,k 0 and k 00 respectively. Then, by <ref> [TS86] </ref>, k = min (k 0 ; k 00 ). Again the property in J 2 is true for both C 0 and C 00 (induction hypothesis). Then, since fl = fl 0 + fl 00 , the property must be true of C as well. <p> Hence the property in J 2 holds for C as well. We now show that J 2 (S m+1 ) ) J 1 (S m+1 ). Since the unfolding transformation is independent of any condition on the counter (or descent level) in SCOUT or <ref> [TS86] </ref>, therefore any unfolding allowed by 20 [TS86] in S m+1 is also allowed by SCOUT. For folding, let C 2 S m+1 be folded using the folder D 2 S 0 in the system of [TS86]. <p> We now show that J 2 (S m+1 ) ) J 1 (S m+1 ). Since the unfolding transformation is independent of any condition on the counter (or descent level) in SCOUT or <ref> [TS86] </ref>, therefore any unfolding allowed by 20 [TS86] in S m+1 is also allowed by SCOUT. For folding, let C 2 S m+1 be folded using the folder D 2 S 0 in the system of [TS86]. <p> is independent of any condition on the counter (or descent level) in SCOUT or <ref> [TS86] </ref>, therefore any unfolding allowed by 20 [TS86] in S m+1 is also allowed by SCOUT. For folding, let C 2 S m+1 be folded using the folder D 2 S 0 in the system of [TS86]. Let the counters of C and D be (fl; fl) and (ffi; ffi) repsectively and their descent levels be k and l respectively. Then, k &lt; l (by [TS86]) and the property of J2 is true for both C and D (since J2 (S m+1 ) holds). <p> For folding, let C 2 S m+1 be folded using the folder D 2 S 0 in the system of <ref> [TS86] </ref>. Let the counters of C and D be (fl; fl) and (ffi; ffi) repsectively and their descent levels be k and l respectively. Then, k &lt; l (by [TS86]) and the property of J2 is true for both C and D (since J2 (S m+1 ) holds). <p> Then, fl &gt; lex ffi and hence C can be folded using D as folder in SCOUT. This completes the proof. 2 Thus, we have proved that SCOUT allows all unfold/fold transformation sequences allowed by <ref> [TS86] </ref>. To prove that it is strictly more powerful, we need to give an example transformation sequence which is allowed by SCOUT, but not by [TS86]. Again, any example requiring disjunctive folding serves this purpose. Hence we conclude that SCOUT is strictly more powerful than [TS86]. 5.2 Refinements of SCOUT 5.2.1 <p> This completes the proof. 2 Thus, we have proved that SCOUT allows all unfold/fold transformation sequences allowed by <ref> [TS86] </ref>. To prove that it is strictly more powerful, we need to give an example transformation sequence which is allowed by SCOUT, but not by [TS86]. Again, any example requiring disjunctive folding serves this purpose. Hence we conclude that SCOUT is strictly more powerful than [TS86]. 5.2 Refinements of SCOUT 5.2.1 Goal Replacement We now discuss how we can extend SCOUT to incorporate goal replacement. <p> unfold/fold transformation sequences allowed by <ref> [TS86] </ref>. To prove that it is strictly more powerful, we need to give an example transformation sequence which is allowed by SCOUT, but not by [TS86]. Again, any example requiring disjunctive folding serves this purpose. Hence we conclude that SCOUT is strictly more powerful than [TS86]. 5.2 Refinements of SCOUT 5.2.1 Goal Replacement We now discuss how we can extend SCOUT to incorporate goal replacement. First, we straightforwardly augment transformation 9 of section 3 to consider the situation where the counters associated with each clause is an I-tuple (as is the case in SCOUT).
References-found: 22

