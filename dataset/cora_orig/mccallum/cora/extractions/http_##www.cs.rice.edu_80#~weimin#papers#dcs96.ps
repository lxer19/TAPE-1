URL: http://www.cs.rice.edu:80/~weimin/papers/dcs96.ps
Refering-URL: http://www.cs.rice.edu:80/~weimin/
Root-URL: 
Email: fweimin, alcg@cs.rice.edu  
Title: Conservative Garbage Collection on Distributed Shared Memory Systems  
Author: Weimin Yu and Alan Cox 
Address: Houston, TX 77251  
Affiliation: Department of Computer Science Rice University  
Abstract: In this paper we present the design and implementation of a conservative garbage collection algorithm for distributed shared memory (DSM) applications that use weakly-typed languages like C or C++, and evaluate its performance. In the absence of language support to identify references, our algorithm constructed a conservative approximation of the set of cross-node references based on local information only. It was also designed to tolerate memory inconsistency on DSM systems that use relaxed consistency protocols. These techniques enabled every node to perform garbage collections without communicating with others, effectively avoiding the high cost of cross-node communication in networks of workstations. We measured the performance of our garbage collector against explicit programmer management using three application programs. In two out of the three programs the performance of the GC version is within 15% of the explicit version. The results showed that the garbage collector has two effects on application programs. On one hand, it tends to reduce memory locality, increasing the communication cost; on the other hand, it may eliminate synchronization and memory accesses that would be incurred if memory were managed by the programmer, reducing the communication cost. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Abdullahi, E. Miranda, and G. Ringwood. </author> <title> Collection schemes for distributed garbage. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: We will explore if some simple and reasonable restrictions exist that can provide enough information to the garbage collector while not excessively restricting the freedom of the programmers. 5. Related work Concurrent garbage collection for shared-memory multiprocessors [2, 7] and distributed systems <ref> [1] </ref> has been an active area of research. We are, however, aware of only three attempts to design garbage collectors for DSM systems. None of these report on the cost of garbage collection.
Reference: [2] <author> A. Appel, J. Ellis, and K. Li. </author> <title> Real-time concurrent collection on stock multiprocessors. </title> <booktitle> In Proceedings of the SIGPLAN `88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: We will explore if some simple and reasonable restrictions exist that can provide enough information to the garbage collector while not excessively restricting the freedom of the programmers. 5. Related work Concurrent garbage collection for shared-memory multiprocessors <ref> [2, 7] </ref> and distributed systems [1] has been an active area of research. We are, however, aware of only three attempts to design garbage collectors for DSM systems. None of these report on the cost of garbage collection.
Reference: [3] <author> J. Barlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> DEC Western Research Lab, </institution> <year> 1988. </year>
Reference-contexts: Conservative GC is a technique that does not require any support from the language implementation, enabling the use of GC with programs written in weakly-typed languages, like C or C++. Several conservative garbage collection algorithms have been implemented in the past few years <ref> [9, 4, 3, 8] </ref>. Zorn [22] compared the Boehm-Weiser algorithm [8] with a few explicit management algorithms used to implement malloc () and concluded that conservative garbage collection is a vi-able alternative to explicit memory management for many programs.
Reference: [4] <author> J. Barlett. </author> <title> Mostly-copying garbage collection picks up generations and C++. </title> <type> Technical Report TN-12, </type> <institution> DEC Western Research Lab, </institution> <year> 1989. </year>
Reference-contexts: Conservative GC is a technique that does not require any support from the language implementation, enabling the use of GC with programs written in weakly-typed languages, like C or C++. Several conservative garbage collection algorithms have been implemented in the past few years <ref> [9, 4, 3, 8] </ref>. Zorn [22] compared the Boehm-Weiser algorithm [8] with a few explicit management algorithms used to implement malloc () and concluded that conservative garbage collection is a vi-able alternative to explicit memory management for many programs.
Reference: [5] <author> D. I. Bevan. </author> <title> Distributed garbage collection using reference counting. In Parallel Arch. and Lang. </title> <booktitle> Europe, </booktitle> <pages> pages 117-187, </pages> <address> Eindhoven, The Netherlands, </address> <month> June </month> <year> 1987. </year> <note> Spring-Verlag Lecture Notes in Computer Science 259. </note>
Reference-contexts: Then N 3 passes obj to N 2 and removes its own references to obj. Even though N 1 has received nacks from both nodes, the owner, N 1 , must recognize that there is still a valid reference to obj. A technique called weighted reference counting <ref> [19, 20, 5] </ref> solves this problem.
Reference: [6] <author> R. Bixby, W. Cook, A. Cox, and E. Lee. </author> <title> Parallel mixed integer programming. </title> <note> Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: The computed score of one subtree can be used as the cutoff value in subsequent computations. This program allocates a lot of objects in shared memory, but in the end most of the objects are accessed by only one process. MIP solves the Mixed Integer Programming problem <ref> [6] </ref>, a form of linear programming in which many of the variables are restricted to have integer values. It uses branch and bound to find the optimal solution to the problem. Nodes in the search space are kept in a doubly-linked queue.
Reference: [7] <author> H. Boehm, A. Demeres, and S. Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proceedings of the SIGPLAN `91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: We will explore if some simple and reasonable restrictions exist that can provide enough information to the garbage collector while not excessively restricting the freedom of the programmers. 5. Related work Concurrent garbage collection for shared-memory multiprocessors <ref> [2, 7] </ref> and distributed systems [1] has been an active area of research. We are, however, aware of only three attempts to design garbage collectors for DSM systems. None of these report on the cost of garbage collection.
Reference: [8] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software: Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Conservative GC is a technique that does not require any support from the language implementation, enabling the use of GC with programs written in weakly-typed languages, like C or C++. Several conservative garbage collection algorithms have been implemented in the past few years <ref> [9, 4, 3, 8] </ref>. Zorn [22] compared the Boehm-Weiser algorithm [8] with a few explicit management algorithms used to implement malloc () and concluded that conservative garbage collection is a vi-able alternative to explicit memory management for many programs. <p> Several conservative garbage collection algorithms have been implemented in the past few years [9, 4, 3, 8]. Zorn [22] compared the Boehm-Weiser algorithm <ref> [8] </ref> with a few explicit management algorithms used to implement malloc () and concluded that conservative garbage collection is a vi-able alternative to explicit memory management for many programs. In contrast to shared-memory multiprocessors, interpro-cessor communication is quite expensive on general-purpose networks of workstations.
Reference: [9] <author> M. Caplinger. </author> <title> A memory allocator with garbage collection for C. </title> <booktitle> In Proceedings of the 1988 Winter Usenix Conference, </booktitle> <pages> pages 325-330, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Conservative GC is a technique that does not require any support from the language implementation, enabling the use of GC with programs written in weakly-typed languages, like C or C++. Several conservative garbage collection algorithms have been implemented in the past few years <ref> [9, 4, 3, 8] </ref>. Zorn [22] compared the Boehm-Weiser algorithm [8] with a few explicit management algorithms used to implement malloc () and concluded that conservative garbage collection is a vi-able alternative to explicit memory management for many programs.
Reference: [10] <author> J. Carter, J. Bennett, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Our garbage collector has been implemented on the TreadMarks DSM system [13]. TreadMarks is a high-performance DSM system that runs on standard workstations connected by general-purpose networks. It uses the lazy release consistency algorithm [12] and a multiple-writer protocol <ref> [10] </ref> to minimize the number of messages and the amount of data communicated, resulting in good performance on a large class of applications [16]. Using our garbage collector, two out of the three application programs used in this study performed within 15% of explicit memory management by the programmer.
Reference: [11] <author> P. Ferreira and M. Shapiro. </author> <title> Garbage collection and DSM consistency. </title> <booktitle> In The 1st International Conference on Operating Systems Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Furthermore, none of the published work that we are aware of <ref> [18, 14, 11] </ref> has measured the performance of an implementation on any application programs. Neither have they addressed the design of a garbage collector for weakly-typed languages such as C and C++. <p> The garbage collector also locks pages while scanning. It cannot be used with weakly-typed languages like C. Kordale's GC design [14] for DSM is based on the mark and sweep technique. The design is very complex and relies on a large amount of auxiliary information. Ferreira and Shapiro <ref> [11] </ref> discussed a copying garbage collector for weakly consistent DSM systems. They were the first to point out that garbage collectors can be designed to tolerate memory inconsistency.
Reference: [12] <author> P. Keleher, A. L. Cox, and W. Zwaenepoel. </author> <title> Lazy release consistency for software distributed shared memory. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 13-21, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Our garbage collector has been implemented on the TreadMarks DSM system [13]. TreadMarks is a high-performance DSM system that runs on standard workstations connected by general-purpose networks. It uses the lazy release consistency algorithm <ref> [12] </ref> and a multiple-writer protocol [10] to minimize the number of messages and the amount of data communicated, resulting in good performance on a large class of applications [16].
Reference: [13] <author> P. Keleher, S. Dwarkadas, A. Cox, and W. Zwaenepoel. Treadmarks: </author> <title> Distributed shared memory on standard workstations and operating systems. </title> <booktitle> In Proceedings of the 1994 Winter Usenix Conference, </booktitle> <pages> pages 115-131, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Instead of requiring global synchronization to bring the nodes up to date, our algorithm is designed to tolerate memory inconsistency. Our garbage collector has been implemented on the TreadMarks DSM system <ref> [13] </ref>. TreadMarks is a high-performance DSM system that runs on standard workstations connected by general-purpose networks.
Reference: [14] <author> R. Kordale, M. Ahamad, and J. Shilling. </author> <title> Distributed/concurrent garbage collection in distributed shared memory systems. </title> <booktitle> In Proceedings of the International Workshop on Object Orientation and Operating Systems, </booktitle> <month> Decem-ber </month> <year> 1993. </year>
Reference-contexts: Furthermore, none of the published work that we are aware of <ref> [18, 14, 11] </ref> has measured the performance of an implementation on any application programs. Neither have they addressed the design of a garbage collector for weakly-typed languages such as C and C++. <p> Their design entails collecting the entire address space across all nodes at the same time. The garbage collector also locks pages while scanning. It cannot be used with weakly-typed languages like C. Kordale's GC design <ref> [14] </ref> for DSM is based on the mark and sweep technique. The design is very complex and relies on a large amount of auxiliary information. Ferreira and Shapiro [11] discussed a copying garbage collector for weakly consistent DSM systems.
Reference: [15] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: A DSM system handles the communication of data between machines, eliminating the need for the programmer to write message-passing code. Roughly speaking, a DSM system enables processes on different machines to share virtual memory, even though no physical memory is shared by the machines <ref> [15] </ref>. It is widely accepted that it is easier to program with shared memory than message passing: Instead of sending and receiving messages explicitly, programs can use ordinary loads and stores to access shared data.
Reference: [16] <author> H. Lu, S. Dwarkadas, A. Cox, and W. Zwaenepoel. </author> <title> Message passing vs distributed shared memory on networks of workstations. </title> <note> To appear in Supercomputing 95. </note>
Reference-contexts: It uses the lazy release consistency algorithm [12] and a multiple-writer protocol [10] to minimize the number of messages and the amount of data communicated, resulting in good performance on a large class of applications <ref> [16] </ref>. Using our garbage collector, two out of the three application programs used in this study performed within 15% of explicit memory management by the programmer. This paper is organized as follows. Section 2 describes our conservative garbage collection algorithm; and Section 3 describes its implementation.
Reference: [17] <author> B. Nitzberg and V. Lo. </author> <title> Distributed shared memory: A survey of issues and algorithms. </title> <journal> IEEE Computer, </journal> <volume> 24(8) </volume> <pages> 52-60, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: 1. Introduction Over the last decade, both distributed garbage collection and distributed shared memory have become increasingly active areas of research <ref> [21, 17] </ref>. Despite the activity in these 1 This research was supported in part by the National Science Foundation under NYI Award CCR-945770 and by the Texas Advanced Technology Program and Tech-Sym Inc. under Grant 003604012. areas individually, their intersection has received relatively little attention.
Reference: [18] <author> T. L. Sergent and B. Berthomieu. </author> <title> Incremental multi-threaded garbage collection on virtually shared memory architectures. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Furthermore, none of the published work that we are aware of <ref> [18, 14, 11] </ref> has measured the performance of an implementation on any application programs. Neither have they addressed the design of a garbage collector for weakly-typed languages such as C and C++. <p> Related work Concurrent garbage collection for shared-memory multiprocessors [2, 7] and distributed systems [1] has been an active area of research. We are, however, aware of only three attempts to design garbage collectors for DSM systems. None of these report on the cost of garbage collection. Le Sergent <ref> [18] </ref> described an extension of a copying collector originally designed for a multiprocessor to a DSM system. Their design entails collecting the entire address space across all nodes at the same time. The garbage collector also locks pages while scanning. It cannot be used with weakly-typed languages like C.
Reference: [19] <author> R. Thomas. </author> <title> A dataflow computer with improved asymptotic performance. </title> <type> Technical Report TR-265, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1981. </year>
Reference-contexts: Then N 3 passes obj to N 2 and removes its own references to obj. Even though N 1 has received nacks from both nodes, the owner, N 1 , must recognize that there is still a valid reference to obj. A technique called weighted reference counting <ref> [19, 20, 5] </ref> solves this problem.
Reference: [20] <author> P. Watson and I. Watson. </author> <title> An efficient garbage collection scheme for parallel computer architectures. </title> <booktitle> In PARLE'87 Parallel Architectures and Languages Europe,number 259 in Lecture Notes in Computer Science, </booktitle> <address> Eindhoven (the Nether-lands), June 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Then N 3 passes obj to N 2 and removes its own references to obj. Even though N 1 has received nacks from both nodes, the owner, N 1 , must recognize that there is still a valid reference to obj. A technique called weighted reference counting <ref> [19, 20, 5] </ref> solves this problem.
Reference: [21] <author> P. R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <month> Septem-ber </month> <year> 1992. </year>
Reference-contexts: 1. Introduction Over the last decade, both distributed garbage collection and distributed shared memory have become increasingly active areas of research <ref> [21, 17] </ref>. Despite the activity in these 1 This research was supported in part by the National Science Foundation under NYI Award CCR-945770 and by the Texas Advanced Technology Program and Tech-Sym Inc. under Grant 003604012. areas individually, their intersection has received relatively little attention.
Reference: [22] <author> B. Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <journal> Software: Practice and Experience, </journal> <volume> 23(7) </volume> <pages> 733-756, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Conservative GC is a technique that does not require any support from the language implementation, enabling the use of GC with programs written in weakly-typed languages, like C or C++. Several conservative garbage collection algorithms have been implemented in the past few years [9, 4, 3, 8]. Zorn <ref> [22] </ref> compared the Boehm-Weiser algorithm [8] with a few explicit management algorithms used to implement malloc () and concluded that conservative garbage collection is a vi-able alternative to explicit memory management for many programs. In contrast to shared-memory multiprocessors, interpro-cessor communication is quite expensive on general-purpose networks of workstations.
Reference: [23] <author> B. Zorn and D. Grunwald. </author> <title> Empirical measurements of six allocation-intensive c programs. </title> <journal> SIGPLAN NOTICES, </journal> <volume> 27(12) </volume> <pages> 71-80, </pages> <month> Dec </month> <year> 1992. </year>
Reference-contexts: This is repeated until the solution is found. This application allocates relatively fewer objects, but most of them are shared. Pcfrac is a naive parallelization of a large number factoring program called cfrac <ref> [23] </ref>. The main data structures in Pcfrac include a task array and a result array. It works as follows: 1. The master process generates some tasks and puts them in the task array while other processes wait. 2.
References-found: 23

