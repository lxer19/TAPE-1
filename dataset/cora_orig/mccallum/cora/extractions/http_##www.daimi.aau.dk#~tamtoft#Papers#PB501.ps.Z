URL: http://www.daimi.aau.dk/~tamtoft/Papers/PB501.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: e-mail: -hrnielson,fnielson,tamtoft-@daimi.aau.dk  
Title: Polymorphic Subtyping for Eoeect Analysis: the Integration  
Author: H.R.Nielson F.Nielson T.Amtoft 
Date: April 15, 1996  
Address: Denmark  
Affiliation: Computer Science Department, Aarhus University,  
Abstract: The integration of polymorphism (in the style of the ML let-construct), subtyping, and eoeects (modelling assignment or communication) into one common type system has proved remarkably diOEcult. One line of research has succeeded in integrating polymorphism and subtyping; adding eoeects in a straightforward way results in a semantically unsound system. Another line of research has succeeded in integrating polymorphism, eoeects, and subeoeecting; adding subtyping in a straightforward way invalidates the construction of the inference algorithm. This paper integrates all of poly-morphism, eoeects, and subtyping into an annotated type and eoeect system for Concurrent ML and shows that the resulting system is a conservative extension of the ML type system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T.Amtoft, F.Nielson, H.R.Nielson, J.Ammann: </author> <title> Polymorphic Subtypes for Eoeect Analysis: the Semantics, </title> <year> 1996. </year>
Reference-contexts: Finally, we show that the system is a iconservative extensionj of the usual type system for Standard ML. The formal demonstration of semantic soundness, as well as the construction of the inference algorithm, are dealt with in companion papers <ref> [1, 13] </ref>. 2 Inference System The fragment of Concurrent ML [14] we have chosen for illustrating our approach has expressions (e 2 Exp) and constants (c 2 Con) given by the following syntax: e ::= c j x j fn x ) e j e 1 e 2 j let x
Reference: [2] <author> L. Damas and R. Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Proc. of POPL '82. </booktitle> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: State of the art. One of the pioneering papers in the area is [8] that developed the orst polymorphic type inference and algorithm for the applicative fragment of ML; a shorter presentation for the typed -calculus with let is given in <ref> [2] </ref>. Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let [9, 4]. Later papers have treated polymorphism in full generality [15, 6].
Reference: [3] <author> Y.-C. Fuh and P. Mishra. </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In Proc. TAPSOFT '89. </booktitle> <volume> SLNCS 352, </volume> <year> 1989. </year>
Reference-contexts: Later papers have treated polymorphism in full generality [15, 6]. A key ingredient in these approaches are the techniques for simplifying the enormous set of constraints into something manageable <ref> [3, 15] </ref>. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. A pioneering paper in the area is [18] that developes a distinction between imperative and applicative type variables and that characterises expressions as being expansive or non-expansive.
Reference: [4] <author> Y.-C. Fuh and P. Mishra. </author> <title> Type inference with subtypes. </title> <journal> Theoretical Computer Science, </journal> <volume> 73, </volume> <year> 1990. </year>
Reference-contexts: Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let <ref> [9, 4] </ref>. Later papers have treated polymorphism in full generality [15, 6]. A key ingredient in these approaches are the techniques for simplifying the enormous set of constraints into something manageable [3, 15]. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types.
Reference: [5] <author> F. Henglein and C. Mossin. </author> <title> Polymorphic binding-time analysis. </title> <booktitle> In Proc. ESOP '94, </booktitle> <pages> pages 287301. </pages> <address> SLNCS 788, </address> <year> 1994. </year>
Reference-contexts: In the area of static program analysis, annotated type and eoeect systems have been used as the basis for variations of control AEow analysis [17] and binding time analysis <ref> [11, 5] </ref>. These papers typically make use of a polymorphic type system with subtyping and no eoeects or a non-polymorphic type system with eoeects and subtyping.
Reference: [6] <author> M. P. Jones. </author> <title> A theory of qualioed types. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 287306. </pages> <address> SLNCS 582, </address> <year> 1992. </year>
Reference-contexts: Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let [9, 4]. Later papers have treated polymorphism in full generality <ref> [15, 6] </ref>. A key ingredient in these approaches are the techniques for simplifying the enormous set of constraints into something manageable [3, 15]. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. <p> This presents a major step forward in generalising the subeoeecting approach of [16] and in admitting eoeects into the subtyping approaches of <ref> [15, 6] </ref>. The development is not only applicable to Concurrent ML (with communication) but also Standard ML (with references) and similar settings. Overview. <p> Finally 1 the type of fork indicates that the argument may have any behaviour whatsoever, in particular this means that e in fork (fn dummy ) e) is free to create new channels. Following the approach of <ref> [15, 6] </ref> we will incorporate the eoeects of [16, 12] by deoning a type inference system with judgements of the form C; A ` e : oe & b where C is a constraint set, A is an environment i.e. a list [x 1 : oe 1 ; ; x n <p> The overall structure of the type inference system of Figure 2 is very close to those of <ref> [15, 6] </ref> with a few components from [16, 12] thrown in; the novel ideas of our 1 As discussed previously one might add wrap to the language: this constant transforms delayed communications of type t com b into delayed communications of type t 0 com b 0 ; here b 0
Reference: [7] <author> X. Leroy and P. Weis. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proc. POPL '91, </booktitle> <pages> pages 291302. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year> <month> 19 </month>
Reference-contexts: A number of papers have tried to improve upon this work by allowing to type programs that are rejected according to the expansiveness distinction; this includes <ref> [7, 19, 16] </ref> but all of these systems (as well as the one we develop) fail to fully generalise the expansiveness distinction as is discussed in [16, section 11].
Reference: [8] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer Systems, </journal> <volume> 17:348375, </volume> <year> 1978. </year>
Reference-contexts: This will facilitate modular proofs of correctness while at the same time allowing the inference algorithms to generate syntax-free constraints that can be solved eOEciently. State of the art. One of the pioneering papers in the area is <ref> [8] </ref> that developed the orst polymorphic type inference and algorithm for the applicative fragment of ML; a shorter presentation for the typed -calculus with let is given in [2]. Since then many papers have studied how to integrate subtyping.
Reference: [9] <author> J. C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3), </volume> <year> 1991. </year>
Reference-contexts: Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let <ref> [9, 4] </ref>. Later papers have treated polymorphism in full generality [15, 6]. A key ingredient in these approaches are the techniques for simplifying the enormous set of constraints into something manageable [3, 15]. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types.
Reference: [10] <author> F. Nielson and H.R. Nielson. </author> <title> Constraints for polymorphic behaviours for Concurrent ML. </title> <booktitle> In Proc. </booktitle> <address> CCL'94. SLNCS 845, </address> <year> 1994. </year>
Reference-contexts: A more ambitious analysis is the approach of [12] to let annotated type and eoeect systems extract terms of a process algebra from programs with communication; this involves polymorphism and subeoeecting but some algorithmic problems remain <ref> [10] </ref>. A step forward. In this paper we take an important step towards integrating polymorphism, subtyping, and eoeects into one common type system.
Reference: [11] <author> H.R. Nielson and F. Nielson. </author> <title> Automatic binding analysis for a typed - calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 10:139176, </address> <year> 1988. </year>
Reference-contexts: In the area of static program analysis, annotated type and eoeect systems have been used as the basis for variations of control AEow analysis [17] and binding time analysis <ref> [11, 5] </ref>. These papers typically make use of a polymorphic type system with subtyping and no eoeects or a non-polymorphic type system with eoeects and subtyping.
Reference: [12] <author> H.R. Nielson and F. Nielson. </author> <title> Higher-order concurrent programs with onite communication topology. </title> <booktitle> In Proc. POPL'94, </booktitle> <pages> pages 8497. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: These papers typically make use of a polymorphic type system with subtyping and no eoeects or a non-polymorphic type system with eoeects and subtyping. A more ambitious analysis is the approach of <ref> [12] </ref> to let annotated type and eoeect systems extract terms of a process algebra from programs with communication; this involves polymorphism and subeoeecting but some algorithmic problems remain [10]. A step forward. <p> The role of the b-component is to express the dynamic eoeect that takes place when the function is applied or the delayed communication synchronised. Motivated by [16] and (a simplioed version of) <ref> [12] </ref> the syntax of eoeects, or behaviours, (b 2 Beh ) is given by: b ::= ft chang j fi j ; j b 1 [ b 2 Here ft chang records the allocation of a channel of type t chan; behaviour variables are denoted fi; ; denotes the minimal behaviour <p> Finally 1 the type of fork indicates that the argument may have any behaviour whatsoever, in particular this means that e in fork (fn dummy ) e) is free to create new channels. Following the approach of [15, 6] we will incorporate the eoeects of <ref> [16, 12] </ref> by deoning a type inference system with judgements of the form C; A ` e : oe & b where C is a constraint set, A is an environment i.e. a list [x 1 : oe 1 ; ; x n : oe n ] of typing assumptions for <p> The overall structure of the type inference system of Figure 2 is very close to those of [15, 6] with a few components from <ref> [16, 12] </ref> thrown in; the novel ideas of our 1 As discussed previously one might add wrap to the language: this constant transforms delayed communications of type t com b into delayed communications of type t 0 com b 0 ; here b 0 (and thus also b) may be non-trivial. <p> The system developed here includes no causality concerning the temporal order of eoeects; a future goal is to incorporate aspects of the causality information for the communication structure of Concurrent ML that was developed in <ref> [12] </ref>. Another (and harder) goal is to incorporate decidable fragments of polymorphic recursion. Finally, it should prove interesting to apply these ideas also to strongly typed languages with object-oriented features.
Reference: [13] <author> F.Nielson, H.R.Nielson, T.Amtoft: </author> <title> Polymorphic Subtypes for Eoeect Analysis: the Algorithm, </title> <year> 1996. </year>
Reference-contexts: Finally, we show that the system is a iconservative extensionj of the usual type system for Standard ML. The formal demonstration of semantic soundness, as well as the construction of the inference algorithm, are dealt with in companion papers <ref> [1, 13] </ref>. 2 Inference System The fragment of Concurrent ML [14] we have chosen for illustrating our approach has expressions (e 2 Exp) and constants (c 2 Con) given by the following syntax: e ::= c j x j fn x ) e j e 1 e 2 j let x
Reference: [14] <author> J. H. Reppy. </author> <title> Concurrent ML: Design, application and semantics. </title> <booktitle> In Proc. Functional Programming, Concurrency, Simulation and Automated Reasoning, </booktitle> <pages> pages 165198. </pages> <address> SLNCS 693, </address> <year> 1993. </year>
Reference-contexts: Finally, we show that the system is a iconservative extensionj of the usual type system for Standard ML. The formal demonstration of semantic soundness, as well as the construction of the inference algorithm, are dealt with in companion papers [1, 13]. 2 Inference System The fragment of Concurrent ML <ref> [14] </ref> we have chosen for illustrating our approach has expressions (e 2 Exp) and constants (c 2 Con) given by the following syntax: e ::= c j x j fn x ) e j e 1 e 2 j let x = e 1 in e 2 j rec f x <p> The non-sequential constructors are send and receive: rather than actually enabling a communication they create delayed communications which are orst-class entities that can be passed around freely. This leads to a very powerful programming discipline (in particular in the presence of choose and wrap) as is discussed in <ref> [14] </ref>. The non-sequential base functions are sync, channel, fork and these are explained below. The function sync synchronises a delayed communication. Thus one process can send the value of e to another process by the expression sync (send (ch,e)) where communication takes place along the channel ch. <p> Except for the presence of a b-component in t 1 ! b t 2 and t com b this is much the same type structure that is actually used in Concurrent ML <ref> [14] </ref>. The role of the b-component is to express the dynamic eoeect that takes place when the function is applied or the delayed communication synchronised.
Reference: [15] <author> G. S. Smith. </author> <title> Polymorphic inference with overloading and subtyping. </title> <booktitle> In SLNCS 668, Proc. TAPSOFT '93, </booktitle> <year> 1993. </year> <title> Also see: Principal Type Schemes for Functional Programs with Overloading and Subtyping: </title> <booktitle> Science of Computer Programming 23, </booktitle> <pages> pp. 197-226, </pages> <year> 1994. </year>
Reference-contexts: Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only brieAEy dealing with let [9, 4]. Later papers have treated polymorphism in full generality <ref> [15, 6] </ref>. A key ingredient in these approaches are the techniques for simplifying the enormous set of constraints into something manageable [3, 15]. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. <p> Later papers have treated polymorphism in full generality [15, 6]. A key ingredient in these approaches are the techniques for simplifying the enormous set of constraints into something manageable <ref> [3, 15] </ref>. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. A pioneering paper in the area is [18] that developes a distinction between imperative and applicative type variables and that characterises expressions as being expansive or non-expansive. <p> This presents a major step forward in generalising the subeoeecting approach of [16] and in admitting eoeects into the subtyping approaches of <ref> [15, 6] </ref>. The development is not only applicable to Concurrent ML (with communication) but also Standard ML (with references) and similar settings. Overview. <p> Finally 1 the type of fork indicates that the argument may have any behaviour whatsoever, in particular this means that e in fork (fn dummy ) e) is free to create new channels. Following the approach of <ref> [15, 6] </ref> we will incorporate the eoeects of [16, 12] by deoning a type inference system with judgements of the form C; A ` e : oe & b where C is a constraint set, A is an environment i.e. a list [x 1 : oe 1 ; ; x n <p> The overall structure of the type inference system of Figure 2 is very close to those of <ref> [15, 6] </ref> with a few components from [16, 12] thrown in; the novel ideas of our 1 As discussed previously one might add wrap to the language: this constant transforms delayed communications of type t com b into delayed communications of type t 0 com b 0 ; here b 0 <p> We then have separate rules for subtyping, instantiation and generalisation and we shall explain their side conditions shortly. 2.2 Subtyping Rule (sub) generalises the subeoeecting rule of [16] by incorporating subtyping and extends the subtyping rule of <ref> [15] </ref> to deal with eoeects. To do this we associate two kinds of judgements with a constraint set: the relations C ` b 1 b 2 and C ` t 1 t 2 are deoned by the rules and axioms of Figure 3. <p> The identity substitution is denoted Id and we sometimes write Inv (S) = Dom (S) [ Ran (S) for the set of variables that are involved in the substitution S. Rule (ins) is much as in <ref> [15] </ref> and merely says that to take an instance of a type scheme we must ensure that the constraints are satisoed; this is expressed using the notion of solvability: Deonition 2.2 The type scheme 8 (~ff ~ fi : C 0 ): t 0 is solvable from C by the sub <p> Except for the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in <ref> [15] </ref>: clearly we cannot generalise over variables free in the global type assumptions or global constraint sets, and as in eoeect systems (e.g. [16]) we cannot generalise over variables visible in the eoeect. Furthermore, as in [15] solvability is imposed to ensure that we do not create type schemes that have <p> the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in <ref> [15] </ref>: clearly we cannot generalise over variables free in the global type assumptions or global constraint sets, and as in eoeect systems (e.g. [16]) we cannot generalise over variables visible in the eoeect. Furthermore, as in [15] solvability is imposed to ensure that we do not create type schemes that have no instances; this condition ensures that the expressions let x = e 1 in e 2 and let x = e 1 in x;e 2 are going to be equivalent in the type system.
Reference: [16] <author> J. P. Talpin and P. Jouvelot. </author> <title> The type and eoeect discipline. </title> <journal> Information and Computation, </journal> <volume> 111, </volume> <year> 1994. </year>
Reference-contexts: A number of papers have tried to improve upon this work by allowing to type programs that are rejected according to the expansiveness distinction; this includes <ref> [7, 19, 16] </ref> but all of these systems (as well as the one we develop) fail to fully generalise the expansiveness distinction as is discussed in [16, section 11]. <p> of papers have tried to improve upon this work by allowing to type programs that are rejected according to the expansiveness distinction; this includes [7, 19, 16] but all of these systems (as well as the one we develop) fail to fully generalise the expansiveness distinction as is discussed in <ref> [16, section 11] </ref>. In the area of static program analysis, annotated type and eoeect systems have been used as the basis for variations of control AEow analysis [17] and binding time analysis [11, 5]. <p> This presents a major step forward in generalising the subeoeecting approach of <ref> [16] </ref> and in admitting eoeects into the subtyping approaches of [15, 6]. The development is not only applicable to Concurrent ML (with communication) but also Standard ML (with references) and similar settings. Overview. <p> function except that it attempts to send the argument to id over a newly created channel. (To be able to execute one would need to fork a process that could read over the same channel.) This program is of interest because it will be rejected in the subeoeecting approach of <ref> [16] </ref> whereas it will be accepted in the system of [18]. <p> The role of the b-component is to express the dynamic eoeect that takes place when the function is applied or the delayed communication synchronised. Motivated by <ref> [16] </ref> and (a simplioed version of) [12] the syntax of eoeects, or behaviours, (b 2 Beh ) is given by: b ::= ft chang j fi j ; j b 1 [ b 2 Here ft chang records the allocation of a channel of type t chan; behaviour variables are denoted <p> Finally 1 the type of fork indicates that the argument may have any behaviour whatsoever, in particular this means that e in fork (fn dummy ) e) is free to create new channels. Following the approach of [15, 6] we will incorporate the eoeects of <ref> [16, 12] </ref> by deoning a type inference system with judgements of the form C; A ` e : oe & b where C is a constraint set, A is an environment i.e. a list [x 1 : oe 1 ; ; x n : oe n ] of typing assumptions for <p> The overall structure of the type inference system of Figure 2 is very close to those of [15, 6] with a few components from <ref> [16, 12] </ref> thrown in; the novel ideas of our 1 As discussed previously one might add wrap to the language: this constant transforms delayed communications of type t com b into delayed communications of type t 0 com b 0 ; here b 0 (and thus also b) may be non-trivial. <p> We then have separate rules for subtyping, instantiation and generalisation and we shall explain their side conditions shortly. 2.2 Subtyping Rule (sub) generalises the subeoeecting rule of <ref> [16] </ref> by incorporating subtyping and extends the subtyping rule of [15] to deal with eoeects. <p> Except for the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in [15]: clearly we cannot generalise over variables free in the global type assumptions or global constraint sets, and as in eoeect systems (e.g. <ref> [16] </ref>) we cannot generalise over variables visible in the eoeect. <p> Since ff y is not free in the type of f we may use generalisation to give id the type scheme 8 (ff y : ;): ff y ! ; ff y . This then suOEces for typing the application of id to itself. The approach of <ref> [16] </ref> lacks subtyping although it has subeoeecting. Consequently for the type of f to match that of the locally deoned function we have to give f the type ff x ! b ff x where b = fff y chang.
Reference: [17] <author> Y.-M. Tang. </author> <title> Control Flow Analysis by Eoeect Systems and Abstract Interpretation. </title> <type> PhD thesis, </type> <institution> Ecoles des Mines de Paris, </institution> <year> 1994. </year>
Reference-contexts: In the area of static program analysis, annotated type and eoeect systems have been used as the basis for variations of control AEow analysis <ref> [17] </ref> and binding time analysis [11, 5]. These papers typically make use of a polymorphic type system with subtyping and no eoeects or a non-polymorphic type system with eoeects and subtyping.
Reference: [18] <author> M. Tofte. </author> <title> Type inference for polymorphic references. Information and Computation, </title> <address> 89:134, </address> <year> 1990. </year>
Reference-contexts: A key ingredient in these approaches are the techniques for simplifying the enormous set of constraints into something manageable [3, 15]. Already ML necessitates an incorporation of imperative eoeects due to the presence of ref-types. A pioneering paper in the area is <ref> [18] </ref> that developes a distinction between imperative and applicative type variables and that characterises expressions as being expansive or non-expansive. <p> id over a newly created channel. (To be able to execute one would need to fork a process that could read over the same channel.) This program is of interest because it will be rejected in the subeoeecting approach of [16] whereas it will be accepted in the system of <ref> [18] </ref>. We shall see that we will be able to type this program in our system as well! 2 2.1 Annotated Types To prepare for the type inference system we must clarify the syntax of types, eoeects, type schemes, and constraints. <p> out that if one changed the applied occurrence of f in the program to the expression fn z =&gt; f z then subeoeecting would suOEce for generalising over ff y and hence would allow to type the self-application of id.) We should also point out that in the approach of <ref> [18] </ref> one can generalise over ff y as well and hence type the self-application of id to itself. <p> We refer to <ref> [18] </ref> for the details. 2 2.4 Properties of the Inference System We now list a few basic properties of the inference system that we shall use later. Fact 2.13 For all constants c of Figure 1, the type scheme TypeOf (c) is closed, well-formed and solvable from ;.
Reference: [19] <author> A. K. Wright. </author> <title> Typing references by eoeect inference. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 473491. </pages> <address> SLNCS 582, </address> <year> 1992. </year> <month> 20 </month>
Reference-contexts: A number of papers have tried to improve upon this work by allowing to type programs that are rejected according to the expansiveness distinction; this includes <ref> [7, 19, 16] </ref> but all of these systems (as well as the one we develop) fail to fully generalise the expansiveness distinction as is discussed in [16, section 11].
References-found: 19

