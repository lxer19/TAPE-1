URL: http://www.cs.utexas.edu/users/liugt/publications/rtas97.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/liugt/publications/rtas97.html
Root-URL: 
Email: E-mail: fmok,liugtg@cs.utexas.edu  
Title: Efficient Run-Time Monitoring of Timing Constraints  
Author: Aloysius K. Mok and Guangtian Liu 
Address: Austin, TX 78712  
Affiliation: Department of Computer Sciences University of Texas at Austin  
Abstract: A real-time system operates under timing constraints which it may be unable to meet under some circumstances. The criticality of a timing constraint determines how a system is to react when a timing failure happens. For critical timing constraints, a timing failure should be detected as soon as possible. However, early detection of timing failures requires more resource usage which may be deemed excessive. While work in real-time system monitoring has progressed in recent years, the issue of tradeoff between detection latency and resource overhead has not been adequately considered. This paper presents an approach for monitoring timing constraints in real-time systems which is based on a simple and expressive specification method for defining the timing constraints to be monitored. Efficient algorithms are developed to catch violations of timing constraints at the earliest possible time. These algorithms have been implemented in a tool called JRTM (Java Run-time Timing-constraint Monitor) in the language Java. This tool can be used to specify and monitor timing constraints of Java applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W.C. Brantley, K.P. McAuliffe, and T.A. Ngo, </author> <title> RP3 Performance Monitoring Hardware, in Instrumentation for Future Parallel Computing Systems, </title> <editor> M. Sim-mons, R. Koskela, and I. Bucher, eds., </editor> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989, </year> <month> pp.35-47. </month>
Reference-contexts: We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1. Related Work Significant work has been done in recent years on monitoring real-time systems [27]. Hardware monitoring approaches are proposed in <ref> [1, 11, 13, 21, 26] </ref>. These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive.
Reference: [2] <author> S.E. Chodrow, F. Jahanian, and M. Donner, </author> <title> Run-Time Monitoring of Real-Time Systems, </title> <booktitle> Proc. Real-Time Systems Symp., </booktitle> <year> 1991, </year> <month> pp.74-83. </month>
Reference-contexts: In FLEX [9], certain predefined timing constraints can be monitored for violation. The work closest to our research is <ref> [2] </ref> which presents an event-based model for specifying timing constraints to be monitored and proposes two methods for synchronous or asynchronous monitoring of real-time constraints. A timing constraint satisfiability checking algorithm is also described in that paper. In [22], the model of [2] is extended to distributed systems and the problem <p> The work closest to our research is <ref> [2] </ref> which presents an event-based model for specifying timing constraints to be monitored and proposes two methods for synchronous or asynchronous monitoring of real-time constraints. A timing constraint satisfiability checking algorithm is also described in that paper. In [22], the model of [2] is extended to distributed systems and the problem of detecting timing constraint violations in a distributed environment is discussed. It shows that the problem of minimizing the number of messages among processors in order to detect a violation as early as possible is NP-hard. <p> It shows that the problem of minimizing the number of messages among processors in order to detect a violation as early as possible is NP-hard. But for a sub-class of timing constraints, this problem is in PTime. Our approach is heavily influenced by the work in <ref> [2, 16, 22] </ref>. We extend previous work by providing a more expressive language for timing constraint specification which allows using future relative event occurrences in the definition of timing constraints. <p> Definition 2 For event e and time t during a computation, we define #-function as #(e; t) = 0 if t &lt; @(e; 1) <ref> [2, 22] </ref> extends the @-function to represent occurrence times of past relative instances. We further extend it to represent future relative instances. <p> We call a cycle in a constraint graph with negative weight a negative cycle. The following theorem regarding negative cycles is immediate: Theorem 1 1 If a negative cycle exists in a constraint graph, then the corresponding constraint conjunction is un satisfiable. 3.3. Compiling Constraint Graphs In <ref> [2] </ref> Chodrow et al described a satisfiability checking algorithm which instantiates a constraint graph at each check point and searches for negative cycles on the instan tiated graph by using the Floyd-Warshall algorithm.
Reference: [3] <author> P.S. Dodd and C.V. Ravishankar, </author> <title> Monitoring and Debugging Distributed Real-Time Programs, </title> <journal> Software Practice and Experience, Vol.22, </journal> <volume> No.10, </volume> <month> Oct. </month> <year> 1992, </year> <month> pp.863-877. </month>
Reference-contexts: These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive. In <ref> [3, 8, 25] </ref>, software monitoring approaches are proposed which insert event-detection and event-data-collecting code into application programs, operating system kernels or monitoring systems. In [25], a real-time monitor (ARM) for a distributed real-time operating system (ARTS) is described. <p> In [25], a real-time monitor (ARM) for a distributed real-time operating system (ARTS) is described. Events, which are generated whenever a process changes state, are captured by the ARTS kernel and sent to a visualizer on another machine for displaying and analysis. In <ref> [3] </ref>, a monitoring system is described that monitors events in a distributed environment. In this system, code for generating events are inserted into the kernel, system call library, interrupt handlers, shared variable access methods as well as application programs.
Reference: [4] <editor> M.M. Gorlick, </editor> <title> The Flight Recorder: An Architectural Aid for System Monitoring, </title> <booktitle> Proc. ACM/ONR Workshop Parallel and Distributed Debugging, </booktitle> <year> 1991, </year> <month> pp.175-183. </month>
Reference-contexts: Less interference to the target systems can be achieved by systems which use special hardware for event detection and event data collection but nevertheless instrument target programs to trigger events. Examples of this type of hybrid monitoring approach can be seen in <ref> [4, 5, 14] </ref>. Most of the forementioned research mainly addresses various problems in event detection and event data collection. The event data collected during monitoring is usually used for postmortem analysis for violation of timing constraints. Work on run-time detection of timing constraint violation has received less attention.
Reference: [5] <author> D. Haban and D. Wybranietz, </author> <title> A Hybrid Monitor for Behavior and Performance Analysis of Distributed Systems, </title> <journal> IEEE Trans. Software Eng., Vol.16, No.2, </journal> <month> Feb. </month> <year> 1990, </year> <month> pp.197-211. </month>
Reference-contexts: Less interference to the target systems can be achieved by systems which use special hardware for event detection and event data collection but nevertheless instrument target programs to trigger events. Examples of this type of hybrid monitoring approach can be seen in <ref> [4, 5, 14] </ref>. Most of the forementioned research mainly addresses various problems in event detection and event data collection. The event data collected during monitoring is usually used for postmortem analysis for violation of timing constraints. Work on run-time detection of timing constraint violation has received less attention.
Reference: [6] <author> F. Jahanian and A. K. Mok, </author> <title> Safety Analysis of Timing Properties in Real-Time Systems, </title> <journal> IEEE Trans. Software Eng., Vol.SE-12, </journal> <volume> No.9, </volume> <month> Sept. </month> <year> 1986, </year> <month> pp.890-904. </month>
Reference-contexts: Informally, events represent state changes of interests that may occur in a system. For example, received a message from process A, start the execution of function foo () can be defined as events. We adopt the event model first proposed in <ref> [6, 15] </ref>. Events are a finite set of names specified by the user and are generally recurrent, i.e., an event may occur multiple times during a computation. We shall not concern ourselves with the specific syntactic rules in application programs for defining the occurrence of events. <p> The computation of a real-time system can be viewed as a sequence of sets of event occurrences. To capture the relationship between event instances and their occurrence time during a computation, we introduce below an uninterpreted function symbol: the @ function which we call the event occurrence function <ref> [6, 15] </ref>. Definition 1 For event e and integer i 2 N + , we define @-function as @(e; i) = occurrence time of the ith instance of event e i is called the occurrence parameter of the @-function.
Reference: [7] <author> F. Jahanian and A. Goyal, </author> <title> A Formalism for Monitor--ing Real-Time Constraints at Runtime, </title> <booktitle> Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <month> June </month> <year> 1990, </year> <month> pp.148-155. </month>
Reference: [8] <author> J. Joyce, G. Lomow, K. Slind, and B. Unger, </author> <title> Monitoring Distributed Systems, </title> <journal> ACM Trans. Computer Systems, Vol.5, No.2, </journal> <month> May </month> <year> 1987, </year> <month> pp.121-150. </month>
Reference-contexts: These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive. In <ref> [3, 8, 25] </ref>, software monitoring approaches are proposed which insert event-detection and event-data-collecting code into application programs, operating system kernels or monitoring systems. In [25], a real-time monitor (ARM) for a distributed real-time operating system (ARTS) is described.
Reference: [9] <author> K.B. Kenny and K.-J. Lin, </author> <title> Building Flexible Real-Time Systems using the Flex Language, </title> <booktitle> Computer, </booktitle> <address> Vol.24, No.5, </address> <month> May </month> <year> 1991, </year> <month> pp.70-78. </month>
Reference-contexts: Work on run-time detection of timing constraint violation has received less attention. In [16], an annotation method was introduced which marks the events of interests in Ada programs and uses Real Time Logic (RTL) formulas to specify the timing constraints to be enforced. In FLEX <ref> [9] </ref>, certain predefined timing constraints can be monitored for violation. The work closest to our research is [2] which presents an event-based model for specifying timing constraints to be monitored and proposes two methods for synchronous or asynchronous monitoring of real-time constraints.
Reference: [10] <author> R.J. LeBlanc and A.D. Robbins, </author> <title> Event-Driven Monitoring of Distributed Programs, </title> <booktitle> Proc. 5th Int'l Conf. Distributed Computing Systems, </booktitle> <year> 1985, </year> <month> pp.515-522. </month>
Reference: [11] <author> A.-C. Liu and R. Parthasarathi, </author> <title> Hardware Monitoring of a Multiprocessor System, </title> <booktitle> IEEE Micro, </booktitle> <address> Vol.9, No.5, </address> <month> Oct. </month> <year> 1989, </year> <month> pp.44-51. </month>
Reference-contexts: We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1. Related Work Significant work has been done in recent years on monitoring real-time systems [27]. Hardware monitoring approaches are proposed in <ref> [1, 11, 13, 21, 26] </ref>. These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive.
Reference: [12] <author> J.E. Lumpp et al., </author> <title> Specification and Identification of Events for Debugging and Performance Monitoring of Distributed Multiprocessor Systems, </title> <booktitle> Proc. 10th Int'l Conf. Distributed Computing Systems, </booktitle> <year> 1990, </year> <month> pp.477-483. </month>
Reference: [13] <author> D.C. Marinescu, J.E. Lumpp, Jr., T.L. Casavant, and H.J. Siegel, </author> <title> Models for Monitoring and Debugging Tools for Parallel and Distributed Software, </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> Vol.9, </volume> <month> June </month> <year> 1990, </year> <month> pp.171-183. </month>
Reference-contexts: We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1. Related Work Significant work has been done in recent years on monitoring real-time systems [27]. Hardware monitoring approaches are proposed in <ref> [1, 11, 13, 21, 26] </ref>. These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive.
Reference: [14] <author> A. Mink, R. Carpenter, G. Nacht, and J. Roberts, </author> <title> Multiprocessor Performance-Measurement Instrumentation, </title> <booktitle> Computer, </booktitle> <address> Vol.23, No.9, </address> <month> Sept. </month> <year> 1990, </year> <month> pp.63-75. </month>
Reference-contexts: Less interference to the target systems can be achieved by systems which use special hardware for event detection and event data collection but nevertheless instrument target programs to trigger events. Examples of this type of hybrid monitoring approach can be seen in <ref> [4, 5, 14] </ref>. Most of the forementioned research mainly addresses various problems in event detection and event data collection. The event data collected during monitoring is usually used for postmortem analysis for violation of timing constraints. Work on run-time detection of timing constraint violation has received less attention.
Reference: [15] <author> A.K. Mok, </author> <title> A Graph-Based Computation Model for Real-Time Systems, </title> <booktitle> Proc. IEEE Parallel Processing, </booktitle> <month> August </month> <year> 1985, </year> <month> pp.619-623, </month> . 
Reference-contexts: Informally, events represent state changes of interests that may occur in a system. For example, received a message from process A, start the execution of function foo () can be defined as events. We adopt the event model first proposed in <ref> [6, 15] </ref>. Events are a finite set of names specified by the user and are generally recurrent, i.e., an event may occur multiple times during a computation. We shall not concern ourselves with the specific syntactic rules in application programs for defining the occurrence of events. <p> The computation of a real-time system can be viewed as a sequence of sets of event occurrences. To capture the relationship between event instances and their occurrence time during a computation, we introduce below an uninterpreted function symbol: the @ function which we call the event occurrence function <ref> [6, 15] </ref>. Definition 1 For event e and integer i 2 N + , we define @-function as @(e; i) = occurrence time of the ith instance of event e i is called the occurrence parameter of the @-function.
Reference: [16] <author> A.K. Mok, </author> <title> Annotating Ada for Real-Time Program Synthesis, </title> <booktitle> Proc. Computer Assurance, </booktitle> <year> 1987 </year>
Reference-contexts: Most of the forementioned research mainly addresses various problems in event detection and event data collection. The event data collected during monitoring is usually used for postmortem analysis for violation of timing constraints. Work on run-time detection of timing constraint violation has received less attention. In <ref> [16] </ref>, an annotation method was introduced which marks the events of interests in Ada programs and uses Real Time Logic (RTL) formulas to specify the timing constraints to be enforced. In FLEX [9], certain predefined timing constraints can be monitored for violation. <p> It shows that the problem of minimizing the number of messages among processors in order to detect a violation as early as possible is NP-hard. But for a sub-class of timing constraints, this problem is in PTime. Our approach is heavily influenced by the work in <ref> [2, 16, 22] </ref>. We extend previous work by providing a more expressive language for timing constraint specification which allows using future relative event occurrences in the definition of timing constraints.
Reference: [17] <author> A.K. Mok and G. Liu, </author> <title> Early Detection of Timing Constraint Violations, </title> <type> Technical Report, </type> <institution> Real-Time System Lab, Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1997 </year>
Reference-contexts: Compiling Constraint Graphs In [2] Chodrow et al described a satisfiability checking algorithm which instantiates a constraint graph at each check point and searches for negative cycles on the instan tiated graph by using the Floyd-Warshall algorithm. If a 1 See <ref> [17] </ref> for proof of all theorems and corollaries. negative cycle is found, then the corresponding instanti-ated constraint conjunction is unsatisfiable and a violation is detected. <p> Hence, it is important for us to know the necessary length of an event log, i.e., the minimum number of occurrences we need to record in such a log so that no violation will be missed. As we have proven in <ref> [17] </ref>, an upper bound for the necessary length can be determined for each event log at compile time. Since timers are used in our constraint checking algorithm in Section 4.1, the careful reader may also be concerned about the number of outstanding timers during the monitoring. <p> Similar to the necessary event log length, it turns out that we can also determine at compile time an upper bound for the number of outstanding timers <ref> [17] </ref>. 5. JRTM A Java Run-time Timing constraint Monitor Java is a popular object-oriented programming language introduced by Sun Microsystems in May, 1995.
Reference: [18] <author> K. Nilsen, </author> <title> Issues in the Design and Implementation of Real-Time Java, </title> <institution> Iowa State University: Ames, Iowa, </institution> <year> 1995. </year>
Reference-contexts: With the increasing popularity of Java in Internet applications, we can expect more and more real-time, multimedia applications to be developed in Java in the near future. Besides the built-in multi-threading feature, work is going on to provide real-time support for Java <ref> [18, 19, 20] </ref>. As pointed out in [18, 19, 20], many potential Java applications have timing constraints associated with them. As such, we see Java as a good candidate for timing constraint monitoring. <p> With the increasing popularity of Java in Internet applications, we can expect more and more real-time, multimedia applications to be developed in Java in the near future. Besides the built-in multi-threading feature, work is going on to provide real-time support for Java <ref> [18, 19, 20] </ref>. As pointed out in [18, 19, 20], many potential Java applications have timing constraints associated with them. As such, we see Java as a good candidate for timing constraint monitoring. We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1.
Reference: [19] <author> K. Nilsen, </author> <title> Real-Time Java, </title> <institution> Iowa State University: Ames, Iowa, </institution> <year> 1996. </year>
Reference-contexts: With the increasing popularity of Java in Internet applications, we can expect more and more real-time, multimedia applications to be developed in Java in the near future. Besides the built-in multi-threading feature, work is going on to provide real-time support for Java <ref> [18, 19, 20] </ref>. As pointed out in [18, 19, 20], many potential Java applications have timing constraints associated with them. As such, we see Java as a good candidate for timing constraint monitoring. <p> With the increasing popularity of Java in Internet applications, we can expect more and more real-time, multimedia applications to be developed in Java in the near future. Besides the built-in multi-threading feature, work is going on to provide real-time support for Java <ref> [18, 19, 20] </ref>. As pointed out in [18, 19, 20], many potential Java applications have timing constraints associated with them. As such, we see Java as a good candidate for timing constraint monitoring. We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1.
Reference: [20] <author> K. Nilsen, </author> <title> Embedded Real-Time Development in the Java Language, </title> <institution> Iowa State University: Ames, Iowa, </institution> <year> 1996. </year>
Reference-contexts: With the increasing popularity of Java in Internet applications, we can expect more and more real-time, multimedia applications to be developed in Java in the near future. Besides the built-in multi-threading feature, work is going on to provide real-time support for Java <ref> [18, 19, 20] </ref>. As pointed out in [18, 19, 20], many potential Java applications have timing constraints associated with them. As such, we see Java as a good candidate for timing constraint monitoring. <p> With the increasing popularity of Java in Internet applications, we can expect more and more real-time, multimedia applications to be developed in Java in the near future. Besides the built-in multi-threading feature, work is going on to provide real-time support for Java <ref> [18, 19, 20] </ref>. As pointed out in [18, 19, 20], many potential Java applications have timing constraints associated with them. As such, we see Java as a good candidate for timing constraint monitoring. We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1.
Reference: [21] <author> B. Plattner, </author> <title> Real-Time Execution Monitoring, </title> <journal> IEEE Trans. Software Eng., Vol.SE-10, </journal> <volume> No.6, </volume> <month> Nov. </month> <year> 1984, </year> <month> pp.756-764. </month>
Reference-contexts: We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1. Related Work Significant work has been done in recent years on monitoring real-time systems [27]. Hardware monitoring approaches are proposed in <ref> [1, 11, 13, 21, 26] </ref>. These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive.
Reference: [22] <author> S.C.V. Raju, R. Rajkumar, and F. Jahanian, </author> <title> Monitoring Timing Constraints in Distributed Real-Time Systems, </title> <booktitle> Proc. Real-Time Systems Symp., </booktitle> <year> 1992, </year> <month> pp.57-67. </month>
Reference-contexts: The work closest to our research is [2] which presents an event-based model for specifying timing constraints to be monitored and proposes two methods for synchronous or asynchronous monitoring of real-time constraints. A timing constraint satisfiability checking algorithm is also described in that paper. In <ref> [22] </ref>, the model of [2] is extended to distributed systems and the problem of detecting timing constraint violations in a distributed environment is discussed. It shows that the problem of minimizing the number of messages among processors in order to detect a violation as early as possible is NP-hard. <p> It shows that the problem of minimizing the number of messages among processors in order to detect a violation as early as possible is NP-hard. But for a sub-class of timing constraints, this problem is in PTime. Our approach is heavily influenced by the work in <ref> [2, 16, 22] </ref>. We extend previous work by providing a more expressive language for timing constraint specification which allows using future relative event occurrences in the definition of timing constraints. <p> Definition 2 For event e and time t during a computation, we define #-function as #(e; t) = 0 if t &lt; @(e; 1) <ref> [2, 22] </ref> extends the @-function to represent occurrence times of past relative instances. We further extend it to represent future relative instances.
Reference: [23] <author> J.D. Schoeffler, </author> <title> A Real-Time Programming Event Monitor, </title> <journal> IEEE Trans. Education, Vol.31, </journal> <volume> No.4, </volume> <month> Nov. </month> <year> 1988, </year> <month> pp.245-250. </month>
Reference: [24] <author> R. Snodgrass, </author> <title> A Relational Approach to Monitoring Complex Systems, </title> <journal> ACM Trans. Computer Systems, Vol.6, No.2, </journal> <month> May </month> <year> 1988, </year> <month> pp.157-196. </month>
Reference: [25] <author> H. Tokuda, M. Kotera, and C.W. Mercer, </author> <title> A Real-Time Monitor for a Distributed Real-Time Operating System, </title> <booktitle> Proc. ACM Workshop Parallel and Distributed Debugging, </booktitle> <year> 1988, </year> <month> pp.68-77. </month>
Reference-contexts: These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive. In <ref> [3, 8, 25] </ref>, software monitoring approaches are proposed which insert event-detection and event-data-collecting code into application programs, operating system kernels or monitoring systems. In [25], a real-time monitor (ARM) for a distributed real-time operating system (ARTS) is described. <p> These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive. In [3, 8, 25], software monitoring approaches are proposed which insert event-detection and event-data-collecting code into application programs, operating system kernels or monitoring systems. In <ref> [25] </ref>, a real-time monitor (ARM) for a distributed real-time operating system (ARTS) is described. Events, which are generated whenever a process changes state, are captured by the ARTS kernel and sent to a visualizer on another machine for displaying and analysis.
Reference: [26] <author> J.J.P. Tsai, K.-Y. Fang, and H.-Y. Chen, </author> <title> A Nonin-vasive Architecture to Monitor Real-Time Distributed Systems, </title> <journal> Computer, Vol.23, </journal> <volume> No.3, </volume> <month> Mar. </month> <year> 1990, </year> <month> pp.11-23. </month>
Reference-contexts: We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1. Related Work Significant work has been done in recent years on monitoring real-time systems [27]. Hardware monitoring approaches are proposed in <ref> [1, 11, 13, 21, 26] </ref>. These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive.
Reference: [27] <author> J.J.P. Tsai and S.J.H. Yang, eds, </author> <title> Monitoring and Debugging of Distributed Real-Time Systems, </title> <publisher> IEEE CS Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1995. </year>
Reference-contexts: As such, we see Java as a good candidate for timing constraint monitoring. We have implemented our monitoring approach in Java in a package called JRTM (Java Run-time Timing-constraint Monitor). 1.1. Related Work Significant work has been done in recent years on monitoring real-time systems <ref> [27] </ref>. Hardware monitoring approaches are proposed in [1, 11, 13, 21, 26]. These approaches use dedicated hardware to detect event occurrences by snooping and matching bus signals of target systems and storing event data for post-processing. These methods are especially suitable for monitoring hard real-time systems because they are non-intrusive.
References-found: 27

