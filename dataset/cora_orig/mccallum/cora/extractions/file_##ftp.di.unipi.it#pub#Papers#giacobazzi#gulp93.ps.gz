URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/gulp93.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: gabbri@cwi.nl  (giaco,montesi)@di.unipi.it  
Title: Modular Logic Programs over Finite Domains  
Author: Maurizio Gabbrielli Roberto Giacobazzi Danilo Montesi 
Keyword: Datalog programs.  
Address: 1009 AB Amsterdam, The Netherlands.  Corso Italia 40, 56125 Pisa Italy  
Affiliation: CWI,  Dipartimento di Informatica Universita di Pisa  
Abstract: In this paper we study the properties of a compositional semantics for logic programs and its applications to modular analysis and logic-based databases, focusing on programs defined on a finite domain (i.e. on a function free finite signature). By this restriction we obtain a finite characterization of the compositional semantics which has the same correctness and compositionality properties of the original (fixpoint-based) definition, even if the latter could introduce infinite denotations also for finite domains programs. This property is particularly suitable for semantics-based program analysis, since it allows to identify a class of abstract domains for which the same finite characterization of the (abstract) compositional semantics holds. By combining this result with an existing framework for the modular analysis of logic programs, we can obtain a compositional analysis without requiring an additional level of abstraction. The finiteness of our characterization can also be useful for the modular construction and the uniform compilation of 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Then we consider the case of Datalog programs. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs. The standard reference works by Apt <ref> [1] </ref> and Lloyd [22] provide the necessary background material. Throughout we denote by (; ; Var ) a first-order language defined over a signature (a set of function symbols with their arity), a set of predicate symbols and a denumerable set of variables Var .
Reference: [2] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> Performance Evaluation of Data Intensive Logic Programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundation of Deductive Databases and Logic Programming, </booktitle> <pages> pages 439519. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: The standard fixpoint semantics for logic programs ([1, 22]) as introduced by van Emden and Kowalski, provides a bottom-up execution model which is strongly related to the interpretation view. Several evaluation strategies have been developed to improve the naive strategies based on the immediate consequence operator <ref> [2] </ref>. However, interpretation methods are very inefficient and therefore most systems approach the problem of query processing by means of compilation. The main problem for compilation methods is the treatment of recursive clauses.
Reference: [3] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1993. </year>
Reference: [4] <author> E. Bertino, M. Martelli, and D. Montesi. </author> <title> An Incremental Semantics for CLP(AD). </title> <editor> In A. Marchetti, Spaccamela, P. Mentrasti, and M. Venturini Zilli, editors, </editor> <booktitle> Proc. Fourth Italian Conference on Theoretical Computer Science, </booktitle> <pages> pages 53-67. </pages> <publisher> World Scientific, </publisher> <year> 1992. </year>
Reference: [5] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 570-580, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Module systems and data abstraction are powerful methods for managing the complexity of large programs. Recently, a new semantics for modular logic programs has been introduced in <ref> [5] </ref>. The essential idea is to enhance the semantics proposed in [14] by allowing clauses in the semantic domain. The meaning of a module is given by the least fixpoint F (P ) of a suitable operator T P . <p> As specified by the following definition, the composition of open programs is simply union of clauses modified in order to take into account the "interface" described by the set . Definition 2.1 (-union) <ref> [5] </ref> Let P 1 be an 1 -program and P 2 be an 2 -program. If 1 [ 2 and (pred (P 1 ) " pred (P 2 )) ( 1 " 2 ) then P 1 [ P 2 is the -open program P 1 [ P 2 . <p> Otherwise P 1 [ P 2 is not defined. A semantics which is compositional wrt the [ operator is obtained in <ref> [5] </ref> by using a domain based on clauses. This semantics is formalized in terms of unfolding of clauses. The unfolding operator unf specifies the result of unfolding clauses from a program P 1 with clauses from a program P 2 . <p> Definition 2.3 (Interpretations) <ref> [5] </ref> An interpretation is any element in -(C). Remark To simplify the notation we will denote both a clause c and its ~ equivalence class by c and we will consider a program P both as a set of clauses and as an interpretation. <p> Below we show the bottom-up construction of the semantics for the open-programs. For a set of predicate symbols we denote by id the set fp (~x ) : p (~x ) 2 C j p 2 g. Definition 2.4 (Fixpoint semantics <ref> [5] </ref>) The fixpoint semantics of an -open program P is given by the function F : -(C) ! -(C), defined as F (P ) = lfp (T P ), where T P : -(C) ! -(C) is defined as T P (I ) = unf P (I [ id ). <p> Moreover, each successful derivation for the goal G in P [ Q , where Q A , can equivalently be performed by using parallel derivation steps in F (P [ Q ). The following are the formal results. Theorem 2.6 (Compositionality <ref> [5] </ref>) Let P 1 be an 1 -open program and P 2 be an 2 -open program such that, for a set of predicates , P 1 [ P 2 is defined. <p> Then F (P 1 [ P 2 ) = F (F 1 (P 1 ) [ F 2 (P 2 )). Theorem 2.7 (Correctness <ref> [5] </ref>) Let P ; P 0 be -open programs. Then 1.
Reference: [6] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretations of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference: [7] <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> What You Always Wanted to Know About Datalog And Never Dared to Ask. </title> <journal> IEEE Tran. on Knowledge and Data Eng., </journal> <volume> 1(1) </volume> <pages> 146-164, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: P sort , in both the cases, we obtain: fhsort (x 1 ; x 2 ) : ; ;i ; hsort (x 1 ; x 2 ) : ; ffx 1 ; x 2 ggig. 2 4.2 Databases A Datalog program is a function-free logic program consisting of two components <ref> [7] </ref>: the extensional database (EDB ) and the intensional database (IDB ). The set of predicate symbols is partitioned into EDB and IDB . EDB uses only predicate symbols of EDB and defines extensional relations.
Reference: [8] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Weizmann Institute, Rehovot, </institution> <year> 1990. </year> <note> To appear in Theoretical Computer Science. </note>
Reference: [9] <author> M. Codish, S. K. Debray, and R. Giacobazzi. </author> <title> Compositional Analysis of Modular Logic Programs. </title> <booktitle> In Proc. Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 451-464. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The second one is a finite description of sequences of atoms. Indeed, even if the set of abstract substitutions is finite, the abstract version of the compositional fixpoint semantics may introduce arbitrary large clauses in the abstract semantics, so that the analysis may not terminate. In <ref> [9] </ref> this problem has been tackled by introducing an additional layer of abstraction which is obtained by applying fixpont acceleration techniques such as the so called ?-abstraction. This is applied to provide finitary descriptions for arbitrary large clauses, thus introducing a further approximation which make the analysis less precise. <p> This kind of compositionality is a desirable property since it allows an incremental and modular definition of programs and of their semantics, and, as shown in <ref> [9] </ref>, it provides a semantic base for modular program analysis. In the case of logic languages, a typical partially defined program could be a program where the intensional definitions are completely known while extensional definitions are only partially known and can be further specified by adding new clauses. <p> From a practical point of view the notion of predicate disjoint module is relevant since often module based implementations of logic programming languages assume this kind of separation. A similar restriction is also considered in [17] and in <ref> [9] </ref>. A typical example of predicate disjoint program is provided by a Datalog program, where intensional and extensional predicates are disjoint, and where the extensional predicates are considered partially defined (see Section 4.2). Let us now prove the mentioned equality. Proposition 3.7 Let P be an -open predicate disjoint program. <p> This approach is often unpractical for large programs or for software developed by teams, either because the resource requirements are prohibitively high, or because not all program components are available at the same time for analysis. The relevance of compositionality in logic program analysis has been firstly addressed in <ref> [9] </ref> by introducing a framework which is based on the compositional semantics F and which formalizes the analysis in terms of the standard theory of abstract interpretation ([11]). The abstract meaning of a module corresponds to its analysis and composition of abstract semantics corresponds to composition of analyses. <p> In the following we will briefly describe this framework. Then, using the results of previous section, we will show how for a wide class of abstract domains the analysis can be performed by avoiding a further level of abstraction on clauses which was introduced in <ref> [9] </ref> in order to treat any generic (possibly infinite) abstract domain. An abstract semantics typically associate programs with entities which capture the essence of "what they do" while abstracting away from the concrete details related with its execution model. <p> The meaning of I a is specified by the following concretization function fl: fl (I a ) = c fi fi hc; i 2 I a ) Several abstract objects may represent the same concrete interpretation (i.e. fl may not be in- jective). This problem is solved in <ref> [9] </ref> by defining an equivalence relation ~ fl on -(LC fi ASub) such that I a 1 ~ fl I a 1 ) = fl (I a 2 ). Notice that the equivalence ~ fl provides variable re <br>- striction and equivalence up to renaming. <p> Based on this observations, the following abstract composition theorem guarantees the cor-rectness of the analysis. We denote t the abstract version of [ . Theorem 4.1 (Correctness <ref> [9] </ref>) Let P 1 and P 2 be 1 and 2 -open programs respectively and such that P 1 [ P 2 is defined. <p> Thus, due to the base semantics construction, an additional layer of abstraction or the use of extrapolation techniques like widening/narrowing ([11]) is required. The solution adopted in <ref> [9] </ref> is a further abstraction performed by using these techniques (i.e. ?-abstraction). Abstract clauses are allowed to contain at most one occurrence of the same predicate symbol. Multiple occurrences of atoms for the same predicate in a body are then "compressed" to a single atom.
Reference: [10] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional Formula as Abstract Domain for Groundness Analysis. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 322-327. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: To provide convergence in solving semantic fixpoint equations, the abstract domain is usually required to satisfy the ascending chain condition. Most of the existing abstract domains for substitutions are studied to satisfy this condition (e.g. Prop <ref> [10] </ref> 2 , affine relations [20] 3 and Sharing [19] which is discussed later in the paper). Even if ASub satisfies this 2 The abstract domain Prop provides a concise representation for abstract substitutions able to describe ground dependency relations among their arguments.
Reference: [11] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: They are defined by describing sets of substitutions in -(Sub) by (abstract) descriptions of substitutions in a lattice ASub. We denote by t S the corresponding lub. As the standard theory of abstract interpretation is formalized in terms Galois insertions <ref> [11] </ref>, specifying the relation between abstract and concrete semantics objects, we assume (-(Sub); ff S ; fl S ; ASub) be a Galois insertion 1 . <p> (Q ) fl (unf a ff (P) (ff (Q ))) it follows that for each logic program P and interpretation I : T ff (P) (ff (I ))): 1 i.e. ff S and fl S are monotonic functions, ff S ffifl S = id and fl S ffiff S id <ref> [11] </ref>. Based on this observations, the following abstract composition theorem guarantees the cor-rectness of the analysis. We denote t the abstract version of [ .
Reference: [12] <author> S. K. Debray. </author> <title> Efficient Dataflow Analysis of Logic Programs. </title> <journal> Journal of the ACM, </journal> <volume> 39(4):949984, </volume> <year> 1992. </year>
Reference: [13] <author> F. Denis and J.-P. Delahaye. </author> <title> Unfolding, Procedural and Fixpoint Semantics of Logic Programs. </title> <editor> In C. Choffrut and M. Jantzen, editors, </editor> <booktitle> STACS 91, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 511-522. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference: [14] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Module systems and data abstraction are powerful methods for managing the complexity of large programs. Recently, a new semantics for modular logic programs has been introduced in [5]. The essential idea is to enhance the semantics proposed in <ref> [14] </ref> by allowing clauses in the semantic domain. The meaning of a module is given by the least fixpoint F (P ) of a suitable operator T P . <p> In the case of logic programs, the problematic syntactic construct is the union of clauses. Indeed, it is easy to see that the usual semantics based on atoms, such as the least Herbrand model and the s-semantics <ref> [14] </ref> are not compositional wrt [. <p> For the particular case of = ; we have the following version of previous theorem which shows the full abstraction of the s-semantics. Theorem 2.8 <ref> [14] </ref> Let P 1 ; P 2 be programs.
Reference: [15] <author> B. Freitag. </author> <title> A Deductive Database Language Supporting Modules. </title> <booktitle> In Proc. Second Int'l Computer Science Conference, </booktitle> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: To the best of our knowledge, the only existing approach to modular databases is in <ref> [15] </ref>, but it does not support a modular bottom-up execution model such as the one considered above.
Reference: [16] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming, </booktitle> <pages> pages 131-145. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: Theorem 2.9 <ref> [16] </ref> Let P 1 ; P 2 be programs.
Reference: [17] <author> H. Gaifman and E. Shapiro. </author> <title> Fully abstract compositional semantics for logic programs. </title> <booktitle> In Proc. Sixteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 134-142. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Theorem 2.8 [14] Let P 1 ; P 2 be programs. Then P 1 ; P 2 iff F ; (P 1 ) = F ; (P 2 ) Finally note that, as shown by the following theorem (which generalize a theorem given in <ref> [17] </ref> for the case = ), the composition [ of two -open programs induce the same equivalence on programs as the union of an -open program with set of atoms whose predicates are in . Theorem 2.9 [16] Let P 1 ; P 2 be programs. <p> From a practical point of view the notion of predicate disjoint module is relevant since often module based implementations of logic programming languages assume this kind of separation. A similar restriction is also considered in <ref> [17] </ref> and in [9]. A typical example of predicate disjoint program is provided by a Datalog program, where intensional and extensional predicates are disjoint, and where the extensional predicates are considered partially defined (see Section 4.2). Let us now prove the mentioned equality.
Reference: [18] <author> H. Gaifman and E. Shapiro. </author> <title> Proof theory and semantics of logic programs. </title> <booktitle> In Proc. Fourth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 50-62. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference: [19] <author> D. Jacobs and A. Langen. </author> <title> Static Analysis of Logic Programs for Independent AND Parallelism. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):291-314, 1992. 
Reference-contexts: To provide convergence in solving semantic fixpoint equations, the abstract domain is usually required to satisfy the ascending chain condition. Most of the existing abstract domains for substitutions are studied to satisfy this condition (e.g. Prop [10] 2 , affine relations [20] 3 and Sharing <ref> [19] </ref> which is discussed later in the paper). Even if ASub satisfies this 2 The abstract domain Prop provides a concise representation for abstract substitutions able to describe ground dependency relations among their arguments. A propositional formula with connectives f$; _; ^g is associated with each substitution. <p> Several abstract domains for logic program are compositionally tractable. As an example of a domain of abstract substitutions, in the following we consider the domain Sharing, proposed by Jacobs and Langen in <ref> [19] </ref>. Sharing has been introduced to identify aliasing between variables with a great deal of accuracy. Let be a (concrete) substitution: x and y share the variable w if w 2 var ((x ))"var ((y)). The sharing information description is based on the notion of sharing group. <p> The sharing information description is based on the notion of sharing group. The sharing group of a variable w (denoted by sg (; w )) is the set of variables in the domain of that share w <ref> [19] </ref>. A suitable representation for aliasing is provided by defining Sharing = -(-(Var )). Intuitively, if S 2 Sharing, each of the X 2 S represents a sharing group for a given variable name. <p> Because of the use of flat clauses as semantic objects, abstract unification is much simpler than the one defined in <ref> [19] </ref>. We follow Jacobs and Langen in the definition of mgu a . Let S 2 Sharing, x 2 Var and in (x ; S ) = n fi fi x 2 X . <p> fl if n = 1 unify (x 2 ; :::; x n ; x 0 2 ; :::; x 0 n ; unify (x 1 ; x 0 1 ; S )) if n &gt; 1 The correctness of mgu a is a consequence of the correctness condition proved in <ref> [19] </ref>. The same holds for additivity, commutativity and associativity of mgu a . The relevance of Sharing in data-flow analysis of logic programs has been considered in [23] to exploit independent AND- parallelism. Other important optimizations can be obtained from the ground dependency information.
Reference: [20] <author> M. Karr. </author> <title> Affine Relationships Among Variables of a Program. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 133-151, </pages> <year> 1976. </year>
Reference-contexts: To provide convergence in solving semantic fixpoint equations, the abstract domain is usually required to satisfy the ascending chain condition. Most of the existing abstract domains for substitutions are studied to satisfy this condition (e.g. Prop [10] 2 , affine relations <ref> [20] </ref> 3 and Sharing [19] which is discussed later in the paper). Even if ASub satisfies this 2 The abstract domain Prop provides a concise representation for abstract substitutions able to describe ground dependency relations among their arguments.
Reference: [21] <author> G. Levi. </author> <title> Models, Unfolding Rules and Fixpoint Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1649-1665. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Note that, according to previous remark, unf denotes also a binary (semantic) operator on interpretations. The unfolding operator is of interest as it can be applied to formalize both top-down and bottom-up semantics for logic programs <ref> [21] </ref>. Below we show the bottom-up construction of the semantics for the open-programs. For a set of predicate symbols we denote by id the set fp (~x ) : p (~x ) 2 C j p 2 g.
Reference: [22] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: Then we consider the case of Datalog programs. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs. The standard reference works by Apt [1] and Lloyd <ref> [22] </ref> provide the necessary background material. Throughout we denote by (; ; Var ) a first-order language defined over a signature (a set of function symbols with their arity), a set of predicate symbols and a denumerable set of variables Var .
Reference: [23] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-time derivation of variable dependency using abstract interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):315-347, 1992. 
Reference-contexts: The same holds for additivity, commutativity and associativity of mgu a . The relevance of Sharing in data-flow analysis of logic programs has been considered in <ref> [23] </ref> to exploit independent AND- parallelism. Other important optimizations can be obtained from the ground dependency information. In the following we consider an example for compositional sharing analysis defined in terms of T -stable abstract interpretations.
References-found: 23

