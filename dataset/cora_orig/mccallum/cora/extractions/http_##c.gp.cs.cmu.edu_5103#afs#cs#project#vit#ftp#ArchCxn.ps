URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/vit/ftp/ArchCxn.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/vit/www/paper_abstracts/ArchCxn.html
Root-URL: http://www.cs.cmu.edu
Title: Abstractions and Implementations for Architectural Connections  
Author: Mary Shaw Robert DeLine, Gregory Zelesnik 
Keyword: K eyword s: software architecture, connectors, software system organization, architectural abstraction, architecture description language, system configuration  
Date: November 29, 1995  
Address: Pittsburgh PA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: The architecture of a software system shows how the system is realized by a collection of components and the interactions among these components. Conventional design focuses on defining the components, but the properties of the system depend critically on the character of the interactions. Although software designers have good informal abstractions for these interactions, the abstractions are poorly supported by the available languages and tools. As a result, the choice of interaction is often defaulted or implicit rather than deliberate choice; further, interactions may be defined in terms of underlying mechanisms rather than the designers natural abstractions. UniCon provides a rich selection of abstractions for the connectors that mediate interactions among components. To create systems using these connector abstractions, you need to produce and integrate not only the object code for components, but also a variety of other runtime products. To extend the set of connectors supported by UniCon, you need to identify and isolate many kinds of information in the compiler, graphical editor, and associated tools. This paper describes the role of connector abstractions in software design, the connector abstractions currently supported by UniCon, and implementation issues associated with supporting an open-ended collection of connectors. 
Abstract-found: 1
Intro-found: 1
Reference: [AG94] <author> Robert Allen and David Garlan. </author> <title> Formalizing Architectural Connection. </title> <booktitle> In Proc Sixteenth International Conference on Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: A connectors type, for example, indicates which roles must be satisfied for the connector to operate properly, together with the types of players that are eligible to play the roles (and which component types may define those players). Allen and Garlan have explored formal specifications of the roles <ref> [AG94] </ref>. Property lists are used to refine the types to subtypes or to specialize a type to a particular use. Several broad classes of connectors are currently supported, and the set grows steadily. Data flow connectors support systems in which the computation is paced by availability of data (Pipe).
Reference: [Co79] <author> L. W. Cooprider. </author> <title> The Representation of Families of Software Systems. </title> <type> PhD Thesis, </type> <institution> Carnegie Mellon University. </institution> <month> April </month> <year> 1979. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada [CE78], and have provided a base from which to support software construction [Th76], version control <ref> [Co79] </ref>, system families [Ti79], and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86]. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [CE78] <institution> SARA Aided Design of Software for Concurrent Systems. </institution> <note> Proc. National Computer Conference, </note> <year> 1978. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada <ref> [CE78] </ref>, and have provided a base from which to support software construction [Th76], version control [Co79], system families [Ti79], and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86].
Reference: [Cl95] <author> Goeffrey H. Clemm. </author> <title> The Odin System. </title> <booktitle> Proc. 5th Software Configuration Management Workshop (SCM5), </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: In addition to the glue code, UniCon generates special initialization source code for each process making RPCs. This initialization 2 Odin is a system construction utility similar to the make utility in Unix <ref> [Cl95] </ref>. System construction instructions are specified in an Odinfile, similar to a Makefile, which Odin uses to compute complete dependency information automatically. Odins scripts are shorter and simpler than makes.
Reference: [CP91] <author> John R. Callahan and James M. Purtilo. </author> <title> "A Packaging System for Heterogeneous Execution Environments." </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 17(6): </volume> <pages> 626-635, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Newer work has begun to soften these restrictions. In the Darwin language, modules can be dynamically instantiated and bound at runtime [MDK93]. Polygen <ref> [CP91] </ref> augments a module interconnection language with an inference engine that deduces from a user-defined set of rules how (or whether) a system can be integrated from set of modules.
Reference: [DK76] <author> Frank DeRemer and Hans H. Kron. </author> <title> Programming-in-the-Large versus Programming-in-the-Small. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-2(2):80-86, </volume> <month> June </month> <year> 1976. </year>
Reference-contexts: This knowledge is realized as Odin instructions that are executed to build the final system. Shaw et al Architectural Connectiosn: Abstractions and Implementations 16 4 Related Work Notations for describing the configuration of software systems has a long history. In 1975, DeRemer and Kron <ref> [DK76] </ref> created a notation for describing the structure module-based programs, called a module interconnection language (MIL). In an MIL notation, modules import and export resources, which are named elements such as type definitions, constants, variables, and functions.
Reference: [Gar95] <author> David Garlan (ed) First International Workshop on Architectures for Software Systems, </author> <title> Workshop Summary. </title> <journal> ACM Software Engineering Notes, </journal> <volume> vol 20, no 3,July 1995, </volume> <pages> pp. 84-89. </pages>
Reference-contexts: These configuration notations have recently matured enough to describe both statically and dynamically structured distributed systems [MDK94]. More recently, languages such as UniCon for describing system architectures have started to emerge <ref> [Gar95] </ref>. 5 Conclusion Our objective is to support the abstractions actually used by software designers to describe the architectures of their software systems. These abstractions are at a considerably higher level than the code.
Reference: [GS93] <author> David Garlan and Mary Shaw. </author> <title> An Introduction to Software Architecture. </title> <editor> In V. Ambriola and G. Tortora (eds), </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> vol. 1, </volume> <publisher> World Scientific Publishing Company, </publisher> <year> 1993, </year> <editor> pp.1-39. Shaw et al Architectural Connectiosn: </editor> <title> Abstractions and Implementations 18 </title>
Reference-contexts: For example, a designer may describe a system as a set of real-time processes interacting via remote procedure calls; or as a set of independent experts interacting through a shared blackboard; or as a dataflow architecture with information flowing via pipes through a set of filters <ref> [GS93, PW92] </ref>. The designer typically focuses on the components: decomposing system functionality into components, choosing representations, defining interfaces. The choice of how the components should interactthe connectorsis often made implicitly or by default.
Reference: [KRPOH93] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. G. Harobur. </author> <title> A Practitioners Handbook for Real-Time Analysis: Guide to Rate Monotonic Analysis for Real-Time Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Analysis Expertise Some parts of a design lend themselves to certain types of analyses. For example, the execution time, priority, and period attributes of a set of schedulable processes can be analyzed using rate monotonic analysis (RMA) to see if they will all meet their deadlines <ref> [KRPOH93] </ref>. The knowledge of how to perform applicable analyses is contained in the connector experts.
Reference: [MDK93] <author> J. Magee, N. Dulay, and J. Kramer. </author> <title> Structuring parallel and distributed programs. </title> <journal> Software Engineering Journal, </journal> <volume> 8(2) </volume> <pages> 73-82, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Newer work has begun to soften these restrictions. In the Darwin language, modules can be dynamically instantiated and bound at runtime <ref> [MDK93] </ref>. Polygen [CP91] augments a module interconnection language with an inference engine that deduces from a user-defined set of rules how (or whether) a system can be integrated from set of modules.
Reference: [MDK94] <author> J. Magee, N. Dulay, and J. Kramer. </author> <title> A constructive development evironment for parallel and distributed programs. </title> <booktitle> Proc. Second International Workshop on Configurable Distributed Systems, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: These configuration notations have recently matured enough to describe both statically and dynamically structured distributed systems <ref> [MDK94] </ref>. More recently, languages such as UniCon for describing system architectures have started to emerge [Gar95]. 5 Conclusion Our objective is to support the abstractions actually used by software designers to describe the architectures of their software systems. These abstractions are at a considerably higher level than the code.
Reference: [MKS89] <author> J. Magee, J. Kramer, and M. Sloman. </author> <title> Constructing distributed systems in CONIC. </title> <journal> IEEE Tr. on Software Engineering, </journal> <volume> SE-15(6):663-675, </volume> <year> 1989. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada [CE78], and have provided a base from which to support software construction [Th76], version control [Co79], system families [Ti79], and dynamic configuration <ref> [MKS89] </ref>. Enough examples are available to develop models of the design space [Pe87, PN86]. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [MMS79] <author> J. G. Mitchell, W. Maybury, and R. E. Sweet, </author> <title> Mesa Language Manual. </title> <type> Tech. Report CSL-79-3, </type> <institution> Xerox Corporation, Palo Alto Research Center, </institution> <month> April </month> <year> 1979. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa <ref> [MMS79] </ref> and Ada [CE78], and have provided a base from which to support software construction [Th76], version control [Co79], system families [Ti79], and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86].
Reference: [Pe87] <author> Dewayne E. Perry. </author> <title> Software Interconnection Models. </title> <booktitle> In Proc. Ninth International Conference on Software Engineering, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: Enough examples are available to develop models of the design space <ref> [Pe87, PN86] </ref>. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [PN86] <author> R. Prieto-Diaz and J. M. Neighbors. </author> <title> Module Interconnection Languages. </title> <journal> Journal of Systems and Software, </journal> <volume> 6(4), </volume> <month> November </month> <year> 1986, </year> <pages> pp. 307-333. </pages>
Reference-contexts: Enough examples are available to develop models of the design space <ref> [Pe87, PN86] </ref>. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [Pu90] <author> James Purtilo. </author> <title> "The Polylith Software Bus." </title> <institution> Dept. of Computer Science, Univ. Maryland, </institution> <type> Tech. Rep. 2469, </type> <year> 1990. </year>
Reference-contexts: These modules can be implemented in multiple programming languages, and the machinery needed to connect them can be richer than the usual procedure linkage, for example, a software bus <ref> [Pu90] </ref>. This kind of system requires expanding the notion of a MIL to include specifics about a module's implementation, such as its programming language, its hardware/operating system platform, and the communication media needed to access it.
Reference: [PW92] <author> Dewayne E. Perry and Alexander L. Wolf. </author> <title> Foundations for the Study of Software Architecture. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For example, a designer may describe a system as a set of real-time processes interacting via remote procedure calls; or as a set of independent experts interacting through a shared blackboard; or as a dataflow architecture with information flowing via pipes through a set of filters <ref> [GS93, PW92] </ref>. The designer typically focuses on the components: decomposing system functionality into components, choosing representations, defining interfaces. The choice of how the components should interactthe connectorsis often made implicitly or by default.
Reference: [SDKRYZ95] <author> Mary Shaw, Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, Gregory Zelesnik. </author> <title> Abstractions for Software Architectures and Tools to Support Them. </title> <journal> IEEE Tr. on Software Engineering, </journal> <volume> 21(4): </volume> <pages> 314-335, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: When the checks are satisfied, UniCon creates the intermediate and final products (e.g., parts and scripts) required to construct and execute the system. The details of the language and its compiler appear in a more complete description of UniCon <ref> [SDKRYZ95] </ref>. Here we focus on the connector abstractions and their implementation issues. A software system can be represented interchangeably as graphics or text in UniCon. via RPC as well as competing for real-time response from the processor. <p> UniCon also supports schedulability analysis for real-time systems. When the RTScheduler is invoked, UniCon extracts information from the property lists and creates an input file for a rate monotonic analysis (RMA) tool <ref> [SDKRYZ95] </ref>. The RMA tool analyzes the data and returns a result indicating whether or not the schedule is achievable. 3.2. Development Strategy The UniCon implementation is evolving in three stages.
Reference: [Sh93] <author> Mary Shaw. </author> <title> Procedure Calls are the Assembly Language of Software Interconnection: Connectors Deserve First-Class Status. Proc Workshop on Studies of Software Design 1993, </title> <note> to be published by Springer-Verlag 1995. </note>
Reference-contexts: Moreover, even when designers think about component interactions in terms of abstract relations, the system description itself usually refers directly to low-level mechanisms for communication or data sharing. Such design relegates architectural connections to second-class status and leads to several problems <ref> [Sh93] </ref>. First, conventional design methods make it hard to localize information about interactions among components. These methods make it easy to identify the parts of the implementation that represent particular components, because components are usually manifest in the source code.
Reference: [Sh95] <author> Mary Shaw. </author> <title> Architectural Issues in Software Reuse: Its Not Just the Functionality, Its the Packaging. </title> <booktitle> Proc SSR95: Symposium on Software Reuse, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: When packaging and connection expectations are hidden, systems may unintentionally use components with heterogeneous and Shaw et al Architectural Connectiosn: Abstractions and Implementations 2 incompatible packaging, and serious integration problems may result. We believe that this is a significant source of difficulties with software reuse <ref> [Sh95] </ref>. We are addressing these problems in UniCon, an architectural description language that makes connectorsrelations between componentsfirst-class constructs in the language. Section 2 summarizes the UniCon language and describes the connectors currently supported in UniCon.
Reference: [Th76] <author> J. W. Thomas. </author> <title> Module Interconnection in Programming Systems Supporting Abstraction. </title> <type> PhD Thesis, </type> <institution> Brown University. </institution> <month> June, </month> <year> 1976. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada [CE78], and have provided a base from which to support software construction <ref> [Th76] </ref>, version control [Co79], system families [Ti79], and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86]. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [Ti79] <author> Walter F. Tichy. </author> <title> Software Development Control Based on Module Interconnection. </title> <booktitle> Proc. 4th International Conference on Software Engineering, </booktitle> <address> Munich, </address> <year> 1979, </year> <pages> pp. 29-41. </pages>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada [CE78], and have provided a base from which to support software construction [Th76], version control [Co79], system families <ref> [Ti79] </ref>, and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86]. These early module interconnection languages require considerable prior agreement between the developers of different modules.
References-found: 22

