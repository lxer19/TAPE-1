URL: http://www.cs.cmu.edu/~necula/tr97-172.ps.gz
Refering-URL: http://www.cs.cmu.edu/~necula/cv.html
Root-URL: 
Title: Efficient Representation and Validation of Logical Proofs  
Author: George C. Necula Peter Lee 
Note: This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software," ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Advanced Research Projects Agency or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: October 1997  
Pubnum: CMU-CS-97-172  
Abstract: This report describes a framework for representing and validating formal proofs in various axiomatic systems. The framework is based on the Edinburgh Logical Framework (LF) but is optimized for minimizing the size of proofs and the complexity of proof validation, by removing redundant representation components. Several variants of representation algorithms are presented with the resulting representations being a factor of 15 smaller than similar LF representations. The validation algorithm is a reconstruction algorithm that runs about 7 times faster than LF typechecking. We present a full proof of correctness of the reconstruction algorithm and hints for the efficient implementation using explicit substitutions. We conclude with a quantitative analysis of the algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abadi, M., Cardelli, L., Curien, P.-L., and L evy, J.-J. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming 1, </journal> <month> 4 (Oct. </month> <year> 1991), </year> <pages> 375-416. </pages>
Reference-contexts: A concrete implementation must deal with these issues explicitly. The essence of our implementation choices is best modeled abstractly by a normal-form variant of the calculus with explicit substitutions and De Bruijn indices as presented in <ref> [1] </ref>. However, the presence of type reconstruction makes our implementation more complex than the one suggested by [1]. For the implementation of bound variables we use De Bruijn [2] indices. In such an implementation each bound variable is represented as a positive integer. <p> The essence of our implementation choices is best modeled abstractly by a normal-form variant of the calculus with explicit substitutions and De Bruijn indices as presented in <ref> [1] </ref>. However, the presence of type reconstruction makes our implementation more complex than the one suggested by [1]. For the implementation of bound variables we use De Bruijn [2] indices. In such an implementation each bound variable is represented as a positive integer. In this representation the De Bruijn index n denotes the variable bound by the n th enclosing -abstraction. <p> At that point, we lookup the substitution and we continue our current operation on the body of the substitution. Such an implementation is modeled very closely by the calculus of explicit substitutions <ref> [1] </ref>. Our variant of the calculus is slightly more complicated than that presented in [1] because we want it to model closely our implementation of unification. <p> At that point, we lookup the substitution and we continue our current operation on the body of the substitution. Such an implementation is modeled very closely by the calculus of explicit substitutions <ref> [1] </ref>. Our variant of the calculus is slightly more complicated than that presented in [1] because we want it to model closely our implementation of unification. On the other hand, during type 52 reconstruction all the terms are preserved in normal form and therefore our variant uses only one substitution operator. <p> We present next the syntax of the calculus and proceed then to show how it is used in the implementation of the type reconstruction algorithm. See <ref> [1] </ref> for formal results about the adequacy of the calculus for implementing dependent-typed calculus. At the level of syntax we replace variables with De Bruijn indices, we change the formal of term and type abstraction accordingly and we also introduce a distinguished term constant fl. <p> As an introduction to explicit substitution in the indirect form, we show how the fi-reduction rule would be implemented. For a gentler introduction and formal correctness proofs see <ref> [1] </ref>. Consider 53 that the current substitution state is and the fi-redex is (M )N accompanied by the substitution s.
Reference: [2] <author> DeBruijn, N. </author> <title> Lambda-calculus notation with nameless dummies, a tool for automatic formula manipulation. </title> <journal> Indag. Mat. </journal> <volume> 34 (1972), </volume> <pages> 381-392. </pages>
Reference-contexts: However, the presence of type reconstruction makes our implementation more complex than the one suggested by [1]. For the implementation of bound variables we use De Bruijn <ref> [2] </ref> indices. In such an implementation each bound variable is represented as a positive integer. In this representation the De Bruijn index n denotes the variable bound by the n th enclosing -abstraction.
Reference: [3] <author> Dowek, G., Felty, A., Herbelin, H., Huet, G. P., Murthy, C., Parent, C., Paulin-Mohring, C., and Werner, B. </author> <title> The Coq proof assistant user's guide. Version 5.8. </title> <type> Tech. rep., </type> <institution> INRIA - Rocquencourt, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Without a form of implicit representation the interaction with these systems is very verbose. This led the implementors to consider implicit representations that are similar in spirit to the one presented in this report. For example, the LEGO [7, 18] and Coq <ref> [3] </ref> proof assistants implement algorithms for argument synthesis and term reconstruction. However, for the task of representing proofs these algorithms are both less effective, in the sense that fewer proof subterms can be omitted, and less efficient.
Reference: [4] <author> Elliott, C. </author> <title> Higher-order unification with dependent types. In Rewriting Techniques and Applications (Chapel Hill, </title> <publisher> North Carolina, </publisher> <month> Apr. </month> <year> 1989), </year> <editor> N. Dershowitz, Ed., </editor> <publisher> Springer-Verlag LNCS 355, </publisher> <pages> pp. 121-136. </pages>
Reference-contexts: In particular, the whole proof might be missing, in which case Elf tries to reconstruct it. To achieve this level of flexibility, Elf type reconstruction employs depth-first search and higher-order unification with dependent types <ref> [4] </ref>, followed by a constraint solver [16, 15].
Reference: [5] <author> Harper, R., Honsell, F., and Plotkin, G. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery 40, </journal> <month> 1 (Jan. </month> <year> 1993), </year> <pages> 143-184. </pages>
Reference-contexts: M : x : A:B ` N : A LF ` M : A A fi B LF Equivalence : (x : A:M )N fi [N=x]M Table 1: Type checking in the LF type discipline The following theorems can be proven using techniques which are similar to those used in <ref> [5, 13] </ref>. These theorems establish that LF type-checking is an adequate procedure for checking the validity of LF representations of proofs in L. As mentioned before, the adequacy of LF type-checking holds even if L is extended with additional boolean connectives and function symbols. <p> These theorems establish that LF type-checking is an adequate procedure for checking the validity of LF representations of proofs in L. As mentioned before, the adequacy of LF type-checking holds even if L is extended with additional boolean connectives and function symbols. The adequacy holds even for higher-order logics <ref> [5] </ref>. Theorem 4.1 (Adequacy of Expression Representation.) 1. If e has free variables among x 1 ; : : : ; x n , then x 1 : exp; : : : ; x n : exp ` LF 2. <p> The reason is that the LF representation function only produces objects that do not contain fi-redices (canonical objects). In fact the adequacy proofs in <ref> [5, 13] </ref> introduce first the notion of canonical LF objects and then prove that pq is a bijective function.
Reference: [6] <author> Huet, G. </author> <title> A unification algorithm for typed lambda calculus. </title> <booktitle> Theoretical Computer Science 1, 1 (1973), </booktitle> <pages> 27-57. </pages>
Reference-contexts: These simplifications enable us to implement a more efficient reconstruction algorithm. Because higher-order unification is undecidable <ref> [6] </ref> and expensive in general, Miller [10] proposes syntactic restrictions so that to ensure that the only unification problems that occur can be solved by a simple extension of the first-order unification, as in our case. This approach is the approach taken in the language L .
Reference: [7] <author> Luo, Z., and Pollack, R. </author> <title> The LEGO proof development system: A user's manual. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-92-211, University of Edinburgh, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Without a form of implicit representation the interaction with these systems is very verbose. This led the implementors to consider implicit representations that are similar in spirit to the one presented in this report. For example, the LEGO <ref> [7, 18] </ref> and Coq [3] proof assistants implement algorithms for argument synthesis and term reconstruction. However, for the task of representing proofs these algorithms are both less effective, in the sense that fewer proof subterms can be omitted, and less efficient.
Reference: [8] <author> Michaylov, S., and Pfenning, F. </author> <title> An empirical study of the runtime behavior of higher-order logic programs. </title> <booktitle> In Proceedings of the Workshop on the Prolog Programming Language (Philadelphia, </booktitle> <address> Pennsylvania, </address> <month> July </month> <year> 1992), </year> <editor> D. Miller, Ed., </editor> <publisher> University of Pennsylvania, </publisher> <pages> pp. 257-271. </pages> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: This obstacle can be overcome by implementing term level substitution, but only at the expense of more complicated programs and a significant loss in performance <ref> [8, 9] </ref>. We too recognize the benefits of implementing the reconstruction algorithm for a syntactically-restricted subset of LF, but we do it in such a way that any (explicit) LF term can still be type-checked in our system.
Reference: [9] <author> Michaylov, S., and Pfenning, F. </author> <title> Higher-order logic programming as constraint logic programming. </title> <booktitle> In PPCP'93: First Workshop on Principles and Practice of Constraint Programming (Newport, </booktitle> <address> Rhode Island, </address> <month> Apr. </month> <title> 1993), </title> <publisher> Brown University, </publisher> <pages> pp. 221-229. </pages>
Reference-contexts: This obstacle can be overcome by implementing term level substitution, but only at the expense of more complicated programs and a significant loss in performance <ref> [8, 9] </ref>. We too recognize the benefits of implementing the reconstruction algorithm for a syntactically-restricted subset of LF, but we do it in such a way that any (explicit) LF term can still be type-checked in our system.
Reference: [10] <author> Miller, D. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation 1, </journal> <month> 4 (Sept. </month> <year> 1991), </year> <pages> 497-536. </pages>
Reference-contexts: These simplifications enable us to implement a more efficient reconstruction algorithm. Because higher-order unification is undecidable [6] and expensive in general, Miller <ref> [10] </ref> proposes syntactic restrictions so that to ensure that the only unification problems that occur can be solved by a simple extension of the first-order unification, as in our case. This approach is the approach taken in the language L .
Reference: [11] <author> Miller, D. A. </author> <title> A compact representation of proofs. </title> <journal> Studia Logica 46, </journal> <volume> 4 (1987), </volume> <pages> 347-370. </pages>
Reference-contexts: We expect similar situations to occur in most practical situations involving PCC and first-order logics. 65 12 Related Work We are not the first to address the elimination of redundancy in proof representations. Miller <ref> [11] </ref> approaches the problem by noting that it should be possible to greatly simplify the representation of proofs in classical logic by simply recording the substitutions that were performed when building the proof instead of recording all the basic proof steps.
Reference: [12] <author> Necula, G. C. </author> <title> Proof-carrying code. </title> <booktitle> In The 24th Annual ACM Symposium on Principles of Programming Languages (Jan. 1997), ACM, </booktitle> <pages> pp. 106-119. </pages>
Reference-contexts: Then, we conclude the performance analysis with the presentation of the benefits gained using the optimizations presented in Section 9. The data set used for the measurements presented in this report is obtained from our case studies of Proof-Carrying Code (PCC) <ref> [12] </ref>. PCC is a technique that a server can use to ensure with absolute certainty that the code provided by an untrusted client is safe to run, for a previously defined notion of safety. <p> The packet filters 3 and 4 are also described in [13]. The Ping experiment is the largest PCC experiment to date and involves checking both safety and liveness properties of a simple implementation of the ping network protocol. The experiment Safe ML is described in <ref> [12] </ref>. In the rest of this section we shall focus on relative performance comparisons. All the reported results are based on 32 experiments that include all those described here and others that are similar but generally smaller.
Reference: [13] <author> Necula, G. C., and Lee, P. </author> <title> Proof-carrying code. </title> <type> Technical Report CMU-CS-96-165, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> Dec. </month> <year> 1996. </year> <note> Also appeared as FOX memorandum CMU-CS-FOX-96-03. </note>
Reference-contexts: M : x : A:B ` N : A LF ` M : A A fi B LF Equivalence : (x : A:M )N fi [N=x]M Table 1: Type checking in the LF type discipline The following theorems can be proven using techniques which are similar to those used in <ref> [5, 13] </ref>. These theorems establish that LF type-checking is an adequate procedure for checking the validity of LF representations of proofs in L. As mentioned before, the adequacy of LF type-checking holds even if L is extended with additional boolean connectives and function symbols. <p> The reason is that the LF representation function only produces objects that do not contain fi-redices (canonical objects). In fact the adequacy proofs in <ref> [5, 13] </ref> introduce first the notion of canonical LF objects and then prove that pq is a bijective function. <p> We extracted the PCC safety proof for 32 experimental programs written in the DEC Alpha assembly language. These programs include several variants of network packet filters [14], several variants of the IP checksum routine <ref> [13] </ref> and other PCC experiments presented in [13]. The sizes of these programs range from 10 to 50 assembly language instructions. <p> We extracted the PCC safety proof for 32 experimental programs written in the DEC Alpha assembly language. These programs include several variants of network packet filters [14], several variants of the IP checksum routine <ref> [13] </ref> and other PCC experiments presented in [13]. The sizes of these programs range from 10 to 50 assembly language instructions. In all the experiments considered in this report the LF objects to be reconstructed are implicit representations of proofs in first-order logics similar to the logic L presented in Section 2. <p> Table 3 shows absolute performance data for the fully-explicit representation and the one-bit global representation. We only show in this table only a handful of representative cases. The experiment entitled Cap is the resource access service from [14]. The packet filters 3 and 4 are also described in <ref> [13] </ref>. The Ping experiment is the largest PCC experiment to date and involves checking both safety and liveness properties of a simple implementation of the ping network protocol. The experiment Safe ML is described in [12]. In the rest of this section we shall focus on relative performance comparisons.
Reference: [14] <author> Necula, G. C., and Lee, P. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Second Symposium on Operating Systems Design and Implementations (Oct. 1996), Usenix, </booktitle> <pages> pp. 229-243. </pages>
Reference-contexts: We extracted the PCC safety proof for 32 experimental programs written in the DEC Alpha assembly language. These programs include several variants of network packet filters <ref> [14] </ref>, several variants of the IP checksum routine [13] and other PCC experiments presented in [13]. The sizes of these programs range from 10 to 50 assembly language instructions. <p> Table 3 shows absolute performance data for the fully-explicit representation and the one-bit global representation. We only show in this table only a handful of representative cases. The experiment entitled Cap is the resource access service from <ref> [14] </ref>. The packet filters 3 and 4 are also described in [13]. The Ping experiment is the largest PCC experiment to date and involves checking both safety and liveness properties of a simple implementation of the ping network protocol. The experiment Safe ML is described in [12].
Reference: [15] <author> Pfenning, F. </author> <title> Logic programming in the LF logical framework. In Logical Frameworks (1991), </title> <editor> G. Huet and G. Plotkin, Eds., </editor> <publisher> Cambridge University Press, </publisher> <pages> pp. 149-181. 69 </pages>
Reference-contexts: In particular, the whole proof might be missing, in which case Elf tries to reconstruct it. To achieve this level of flexibility, Elf type reconstruction employs depth-first search and higher-order unification with dependent types [4], followed by a constraint solver <ref> [16, 15] </ref>.
Reference: [16] <author> Pfenning, F. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science (Amsterdam, </booktitle> <address> The Netherlands, </address> <month> July </month> <year> 1991), </year> <pages> pp. 74-85. </pages>
Reference-contexts: In particular, the whole proof might be missing, in which case Elf tries to reconstruct it. To achieve this level of flexibility, Elf type reconstruction employs depth-first search and higher-order unification with dependent types [4], followed by a constraint solver <ref> [16, 15] </ref>.
Reference: [17] <author> Pfenning, F. </author> <title> Elf: A meta-language for deductive systems (system description). </title> <booktitle> In 12th International Conference on Automated Deduction (Nancy, </booktitle> <address> France, June 26-July 1, </address> <year> 1994), </year> <editor> A. Bundy, Ed., </editor> <publisher> LNAI 814, Springer-Verlag, </publisher> <pages> pp. 811-815. </pages>
Reference-contexts: These algorithms are also less efficient than ours because they implement more general unification algorithms that lift some of the syntactic restrictions that we impose. The implementation of Elf <ref> [17] </ref>, a logic programming language based on LF, contains a reconstruction algorithm that is similar to the one presented here in the sense that missing arguments can be recovered also from the context, not only from the other arguments.
Reference: [18] <author> Pollack, R. </author> <title> Implicit syntax. </title> <booktitle> Informal Proceedings of First Workshop on Logical Frameworks, Antibes, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: Without a form of implicit representation the interaction with these systems is very verbose. This led the implementors to consider implicit representations that are similar in spirit to the one presented in this report. For example, the LEGO <ref> [7, 18] </ref> and Coq [3] proof assistants implement algorithms for argument synthesis and term reconstruction. However, for the task of representing proofs these algorithms are both less effective, in the sense that fewer proof subterms can be omitted, and less efficient.
Reference: [19] <author> Statman, R. </author> <title> The typed -calculus is not elementary recursive. </title> <booktitle> Theoretical Computer Science 9 (1979), </booktitle> <pages> 73-81. </pages>
Reference-contexts: These results are not possible to generalize to all LF reconstruction tasks because, in the worst case, the complexity of the reconstruction is superexponential. This is hinted by the fact 64 that reconstruction involves fi-reduction which has been shown by Statman to be not elementary recursive <ref> [19] </ref>. There are several aspects of using reconstruction for validating first-order logic proofs that suggest a better behavior that in the general case. First, the reconstruction algorithm only works on canonical terms. Because of substitution in types the reconstruction creates fi-redices.
Reference: [20] <author> Wadsworth, C. P. </author> <title> Semantics and Pragmatics of the Lambda Calculus. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <year> 1971. </year> <month> 70 </month>
Reference-contexts: This causes a size explosion and excessive memory usage unless sophisticated structure-sharing mechanisms are used <ref> [20] </ref>. We chose to perform substitution in a lazy fashion, postponing a substitution until we come across a substituted variable. At that point, we lookup the substitution and we continue our current operation on the body of the substitution.
References-found: 20

