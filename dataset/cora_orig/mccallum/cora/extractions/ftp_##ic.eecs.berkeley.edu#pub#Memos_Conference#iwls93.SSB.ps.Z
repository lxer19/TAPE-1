URL: ftp://ic.eecs.berkeley.edu/pub/Memos_Conference/iwls93.SSB.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~vigyan/publications/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Multiple Boolean Relations  
Author: Ellen M. Sentovich, Vigyan Singhal, and Robert K. Brayton 
Date: May 1, 1993  
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Science University of California,  
Abstract: Flexibility in selecting the Boolean functions to implement a digital circuit has various forms which have been studied in the literature such as don't care conditions, Boolean relations, and synchronous recurrence equations. Each of these represents a particular degree of flexibility that may be given in the description, inherent in the current representation, or derived from the surrounding environment. This flexibility is used to find an optimal implementation. In this paper, we propose a Multiple Boolean Relation (MBR) as a model that encompasses all degrees of freedom in choosing a set of Boolean functions to implement. This formulation unifies some of the recent work in logic synthesis, which has introduced new types of flexibility. We give examples of synthesis problems in which Multiple Boolean Relations arise and are the only model that represents all the flexibility available. We offer algorithms for obtaining an optimal solution to an MBR. 
Abstract-found: 1
Intro-found: 1
Reference: [BBH + 88] <author> K.A. Bartlett, R.K. Brayton, G.D. Hachtel, R.M. Jacoby, C.R. Morrison, R.L. Rudell, A.L. Sangiovanni-Vincentelli, and A.R. Wang. </author> <title> Multilevel Logic Minimization Using Implicit Don't Cares. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 7(6) </volume> <pages> 723-740, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational <ref> [BHMSV84, BBH + 88, MKLC89, Sav92] </ref> and sequential [DM92a, RHS91] two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in
Reference: [BHMSV84] <author> R.K. Brayton, G.D. Hachtel, C.T. McMullen, and A.L. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational <ref> [BHMSV84, BBH + 88, MKLC89, Sav92] </ref> and sequential [DM92a, RHS91] two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in <p> Multiple output Multi-function (inputs correlated) x 1 x 2 z 1 2 z 2 2 0 1 0 0 1 0 1 1 1 0 0 0 3 A single solution is given by the description itself, and an optimal implementation is obtained by using standard two-level minimization techniques (e.g., <ref> [BHMSV84] </ref>). (While completely specified functions can be represented in multi-level form, this introduces new variables which in turn introduces some don't care conditions inherent in the representation. <p> They have represented and manipulated both the synchronous relation and the compatible function implicitly using Binary Decision Diagrams [Bry86]. Their basic methodology is based on the espresso paradigm <ref> [BHMSV84] </ref> which manipulates one product term at a time, maintaining compatibility with the desired specification and reducing cost greedily. It is interesting to understand the relation between the multiple Boolean relations and the depth d required to represent them as a synchronous relation.
Reference: [Bry86] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35:677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Thus, it might be better to minimize the synchronous relation directly. [SWB93] have presented a heuristic method to optimize synchronous relations directly. They have represented and manipulated both the synchronous relation and the compatible function implicitly using Binary Decision Diagrams <ref> [Bry86] </ref>. Their basic methodology is based on the espresso paradigm [BHMSV84] which manipulates one product term at a time, maintaining compatibility with the desired specification and reducing cost greedily.
Reference: [BS89a] <author> R.K. Brayton and F. Somenzi. </author> <title> An Exact Minimizer for Boolean Relations. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 316-319, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential [DM92a, RHS91] two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations <ref> [BS89b, BS89a, WB91] </ref> which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time. <p> A single solution to a Boolean relation is found by selecting a function for one output, and successively choosing functions for the remaining outputs while satisfying the constraints between outputs. Both exact <ref> [BS89a] </ref> and heuristic [WB91] techniques for finding optimum and optimal solutions based on two-level implementations have been published. These techniques are similar to two-level minimization techniques. 4 3 Multiple Boolean Relations Multiple Boolean relations can arise in several ways as discussed in Section 1. <p> Minimizing f mv using espresso-mv [RSV87] yields a minimum set of prime relations. An exact Boolean relations minimizer such as <ref> [BS89a] </ref> or a heuristic minimizer such as gyocro [WB91] is called on each Boolean relation (each product term in f mv ) to find a minimal function satisfying the Boolean relation, and the minimum of these over all Boolean relations is taken as the best solution. <p> Note that this provides a new way of finding an exact minimum solution to a single Boolean relation: form the binary-valued function representation, find the prime incompletely specified functions, and find the minimum solution to each. For some problems, this method may be faster than <ref> [BS89a] </ref> while providing a better solution than [WB91]; however, the number of prime incompletely specified functions may be prohibitively large. For the MBR in Figure 2, the two Boolean relations (which constitute all prime relations) represent 32 functions and 12 prime incompletely specified functions.
Reference: [BS89b] <author> R.K. Brayton and F. Somenzi. </author> <title> Boolean Relations and the Incomplete Specification of Logic Networks. </title> <booktitle> In Proceedings of the International Conference on VLSI'89, </booktitle> <address> Munich, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential [DM92a, RHS91] two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations <ref> [BS89b, BS89a, WB91] </ref> which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time. <p> Recall from <ref> [BS89b] </ref> that a function f : B n ! B m is compatible with a Boolean relation R, f / R, if and only if 8x i 2 B n , (x i ; z i ) 2 R, where z i = f (x i ).
Reference: [DM92a] <author> M. Damiani and G. De Micheli. </author> <title> Don't care Set Specifications in Combinational and Synchronous Logic Circuits. </title> <type> Technical Report CSL-TR-92-531, </type> <institution> Stanford University, Computer Systems Laboratory, Stanford, </institution> <address> CA 94305-4055, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential <ref> [DM92a, RHS91] </ref> two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time.
Reference: [DM92b] <author> M. Damiani and G. De Micheli. </author> <title> Recurrence Equations and the Optimization of Synchronous Logic Circuits. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 556-561, </pages> <month> June </month> <year> 1992. </year> <month> 12 </month>
Reference-contexts: care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential [DM92a, RHS91] two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations <ref> [DM92b] </ref> for optimization of sequential circuits in the context of continuous operation over time. A Multiple Boolean Relation (MBR) is a set of Boolean relations that encompasses all possible flexibility in choosing the functions to be implemented. It is a way of representing any collection of multi-output functions. <p> Each output function is chosen independent of the others. While this can be viewed as choosing an output minterm for a given input minterm, the choices over all input minterms are not independent. As Damiani et al. observed in <ref> [DM92b] </ref> in the context of synchronous recurrence equations, the inputs are correlated. In the multiple output multi-function example in Figure 2, a choice of z 1 = 0 for x 1 x 2 = 10 forces the choice of z 1 = 1 for x 1 x 2 = 11. <p> The goal is to optimize a subcircuit using information from the surrounding logic. The flexibility in the input/output specification for the subcircuit can be completely specified in terms of finite sequential input/output traces. Damiani and De Micheli <ref> [DM92b] </ref> have demonstrated how one can derive such traces (which they call synchronous recurrence equations). The depth of these traces is no greater than the number of latches in the surrounding logic. 7 The target logic for the subcircuit under consideration will have md outputs and nd inputs. <p> The synchronous relation represents a set of functions which cannot be represented using an ordinary Boolean relation. Synchronous relations can be converted to a Boolean function of Boolean variables as done in <ref> [DM92b] </ref>. We will discuss that method in more detail in Section 4. If the number of latches in the surrounding logic is small, or if only a partial optimization is desired (only part of the solution space is considered), the depth of the synchronous relation can be small. <p> For this particular type of constraint, merging is more practical than enumerating constraints and intersecting them with the Boolean relation. 10 x 2 x 2 x 1 x 2 x 1 x 1 x 2 z 4.2 Synchronous Recurrence Equations In <ref> [DM92b] </ref>, the notion of synchronous recurrence equations is used to optimize sequential subnetworks at the gate level. The goal is to reimplement a subnetwork in an optimal way, given information about the environment. <p> Solution <ref> [DM92b] </ref>: 1. Form a Boolean relation between the inputs x and the intermediate variables y that represents all valid conditions in which the terminal behavior is unchanged. 2. <p> There is some flexibility in choosing Boolean relation R above. In particular, the depth d is chosen for both the input and output variables; the larger the depth value, the greater the amount of flexibility in implementation. See <ref> [DM92b] </ref> for a detailed explanation. Example 4.1 In the example in Figure 5 [DM92b], the goal is to reimplement y n without changing the behavior at z. <p> In particular, the depth d is chosen for both the input and output variables; the larger the depth value, the greater the amount of flexibility in implementation. See <ref> [DM92b] </ref> for a detailed explanation. Example 4.1 In the example in Figure 5 [DM92b], the goal is to reimplement y n without changing the behavior at z. <p> In <ref> [DM92b] </ref>, the function K is built by assigning a new variable to each input minterm for each output, and generating constraints directly from the Boolean relation. <p> From Example 4.1, line 2 of the relation table, if f is chosen to be 1 at x 2 n = 0, x 1 n1 = 1, then f must be chosen to be 0 at x 2 n1 = 1, x 1 x 2 n2 = 0. <ref> [DM92b] </ref> uses all such constraints to extract a function representing all valid solutions, and finds a two-level function of minimum cost function that satisfies the function.
Reference: [KF92] <author> Y. Kukimoto and M. Fujita. </author> <title> Rectification Method for Lookup-Table Type FPGA's. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 54-61, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Depending on the application, it may be possible to add the set of constraints in a more efficient way (perhaps implicitly, as sets) or to incorporate them directly in the representative function while it is being constructed. This latter technique is used in <ref> [KF92] </ref>. 4 Applications Multiple Boolean relations have arisen in a number of synthesis problems. One example was shown in Section 1. The multi-function in Example 1.1 was derived by analysis of don't care sequences in finite state machines. <p> However, depending on the origin of the Boolean relations and the additional constraints, more efficient techniques may be applied to specific problems. 4.1 FPGA Rectification The goal of FPGA rectification as given in <ref> [KF92] </ref> is to change the output functions of the FPGA by modifying the functions of certain LUT's (look-up tables) within the FPGA, while maintaining the interconnections between LUT's. <p> Solution <ref> [KF92] </ref>: 1. Form a Boolean relation R containing all (u i ; v j ) pairs, where u i 2 B s , v j 2 B t , that satisfy the specification SP EC given that the rest of the network is unchanged. 2. <p> The Boolean relation arises from the encapsulation of the environmental information used to determine functions for implementing the u i 's; the constraints on it arise from the support constraints in reimplementing the LUT functions of the subnetwork. The exact solution in <ref> [KF92] </ref> is similar to the Boolean function formulation from Sections 3.2 and 3.3.2, but the support of each v i is limited by the number of inputs to the LUT so the number of new Boolean variables is 2 jSUP P j t (for outputs v 1 ; v 2 ; <p> In <ref> [KF92] </ref>, the constraints are merged directly into the Boolean relation by variable substitution.
Reference: [MKLC89] <author> S. Muroga, Y. Kambayashi, H. C. Lai, and J. N. Culliney. </author> <title> The Transduction Method Design of Logic Networks Based on Permissible Functions. </title> <journal> In IEEE Transactions on Computers, </journal> <month> October </month> <year> 1989. </year>
Reference-contexts: Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational <ref> [BHMSV84, BBH + 88, MKLC89, Sav92] </ref> and sequential [DM92a, RHS91] two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in
Reference: [RHS91] <author> J.-K. Rho, G. Hachtel, and F. Somenzi. </author> <title> Don't Care Sequences and the Optimization of Interacting Finite State Machines. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 418-421, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential <ref> [DM92a, RHS91] </ref> two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time. <p> This formulation has an equivalent single multi-valued function f mv that can be used to find an optimum solution. 4.3 Don't Care Sequences In <ref> [RHS91] </ref>, the problem of optimizing interacting finite state machines in considered. In the presence of a surrounding environment of interacting finite state machines, the observability and the controllability of a finite state machine is reduced. <p> In the presence of a surrounding environment of interacting finite state machines, the observability and the controllability of a finite state machine is reduced. This sequential flexibility is referred to as sequential controllability and observability don't cares, quite similar to the case for combinational circuits [Sav92]. As <ref> [RHS91] </ref> have shown, the sequential don't cares for the interacting finite state machine environment can be represented as finite sequences of input-output pairs. This can be naturally cast into the synchronous recurrence equations that we discussed in the last section.
Reference: [RSV87] <author> R. Rudell and A. Sangiovanni-Vincentelli. </author> <title> Exact Minimization of Multiple-Valued Functions. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 5 </volume> <pages> 727-750, </pages> <year> 1987. </year>
Reference-contexts: Borrowing the terminology for multi-valued variables and literals from <ref> [RSV87] </ref>, a i is a variable taking a value from M , J i M , and a i J i is a literal of variable a i representing the Boolean function a i 1 if a i 2 J i For MBR1, the literal a 0 f0;3g represents the two <p> Proof. Suppose p is not a prime implicant. Thus there exists a product term ~p p ( ~p contains p <ref> [RSV87] </ref>), such that ~p is an implicant of f mv . Consider the set of minterms fm 1 ; m 2 ; : : : ; m q g covered by the product term ~p. <p> Minimizing f mv using espresso-mv <ref> [RSV87] </ref> yields a minimum set of prime relations.
Reference: [Sav92] <author> Hamid Savoj. </author> <title> Don't Cares in Multi-Level Network Optimization. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Here, flexibility means choice in the actual function implemented (as opposed to choice in how that function is implemented). Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational <ref> [BHMSV84, BBH + 88, MKLC89, Sav92] </ref> and sequential [DM92a, RHS91] two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations [BS89b, BS89a, WB91] which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in <p> In the presence of a surrounding environment of interacting finite state machines, the observability and the controllability of a finite state machine is reduced. This sequential flexibility is referred to as sequential controllability and observability don't cares, quite similar to the case for combinational circuits <ref> [Sav92] </ref>. As [RHS91] have shown, the sequential don't cares for the interacting finite state machine environment can be represented as finite sequences of input-output pairs. This can be naturally cast into the synchronous recurrence equations that we discussed in the last section.
Reference: [SWB93] <author> V. Singhal, Y. Watanabe, and R.K. Brayton. </author> <title> Heuristic Minimization of Synchronous Relations. </title> <note> In submitted to IWLS 93, </note> <year> 1993. </year>
Reference-contexts: of minterms (x 1 ; x 2 ; : : :; x d ) 2 B nd , S (x 1 ; x 2 ; : : : ; x d ; f (x 1 ); f (x 2 ); : : : ; f (x d )) = 1 <ref> [SWB93] </ref>. The synchronous relation represents a set of functions which cannot be represented using an ordinary Boolean relation. Synchronous relations can be converted to a Boolean function of Boolean variables as done in [DM92b]. We will discuss that method in more detail in Section 4. <p> In such situations, the representation of the multiple Boolean relation as a synchronous relation will be more compact, i.e., it will require fewer variables ((m + n)d as opposed to m 2 n ). Thus, it might be better to minimize the synchronous relation directly. <ref> [SWB93] </ref> have presented a heuristic method to optimize synchronous relations directly. They have represented and manipulated both the synchronous relation and the compatible function implicitly using Binary Decision Diagrams [Bry86]. <p> It is interesting to understand the relation between the multiple Boolean relations and the depth d required to represent them as a synchronous relation. It has been shown in <ref> [SWB93] </ref> that any arbitrary set of Boolean functions (i.e., any arbitrary MBR) can be represented as a synchronous relation. <p> However the depth required to express the synchronous relation is dependent on the particular relations in the set. In particular, <ref> [SWB93] </ref> have shown that that the depth can be as large as the cardinality of the number of Boolean relations needed to represent the MBR.
Reference: [Wan93] <author> Huey-Yih Wang. </author> <type> Personal communication, </type> <month> February </month> <year> 1993. </year>
Reference-contexts: While we address only Boolean functions and relations, any solution to a multi-valued function or relation is contained in the MBR representation. Example 1.1 A system of two interacting finite state machines is shown in Figure 1 (a) <ref> [Wan93] </ref>. Machine M 1 has a single output that is connected to the input of Machine M 2. Analysis of this system reveals that the output of M 1 can be changed slightly without affecting the I/O behavior of the combined machines.
Reference: [WB91] <author> Y. Watanabe and R.K. Brayton. </author> <title> Heuristic Minimization of Multiple-Valued Relations. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 126-129, </pages> <month> November </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: Flexibility in various forms has been studied extensively, and includes don't care conditions for optimization of combinational [BHMSV84, BBH + 88, MKLC89, Sav92] and sequential [DM92a, RHS91] two-level and multi-level circuits as single entities (each output can be optimized independently), Boolean relations <ref> [BS89b, BS89a, WB91] </ref> which express relationships between outputs and are derived from the surrounding environment, and synchronous recurrence equations [DM92b] for optimization of sequential circuits in the context of continuous operation over time. <p> A single solution to a Boolean relation is found by selecting a function for one output, and successively choosing functions for the remaining outputs while satisfying the constraints between outputs. Both exact [BS89a] and heuristic <ref> [WB91] </ref> techniques for finding optimum and optimal solutions based on two-level implementations have been published. These techniques are similar to two-level minimization techniques. 4 3 Multiple Boolean Relations Multiple Boolean relations can arise in several ways as discussed in Section 1. <p> Minimizing f mv using espresso-mv [RSV87] yields a minimum set of prime relations. An exact Boolean relations minimizer such as [BS89a] or a heuristic minimizer such as gyocro <ref> [WB91] </ref> is called on each Boolean relation (each product term in f mv ) to find a minimal function satisfying the Boolean relation, and the minimum of these over all Boolean relations is taken as the best solution. <p> For some problems, this method may be faster than [BS89a] while providing a better solution than <ref> [WB91] </ref>; however, the number of prime incompletely specified functions may be prohibitively large. For the MBR in Figure 2, the two Boolean relations (which constitute all prime relations) represent 32 functions and 12 prime incompletely specified functions.
References-found: 15

