URL: http://www.cl.cam.ac.uk/ftp/hvg/papers/PIinHOL.ps.gz
Refering-URL: http://www.cl.cam.ac.uk/Research/HVG/FTP/FTP.html
Root-URL: 
Title: of the -calculus in HOL  
Author: T. F. Melham 
Address: Glasgow, Scotland, G12 8QQ  
Affiliation: Department of Computing Science University of Glasgow  
Note: A Mechanized Theory  
Abstract: Revised version of T. F. Melham, `A Mechanized Theory of the -calculus in HOL', Technical Report No. 244, University of Cambridge Computer Laboratory (January 1992). Submitted for publication in the Nordic Journal of Computing. Abstract: The -calculus is a process algebra for modelling concurrent systems in which the pattern of communication between processes may change over time. This paper describes the results of preliminary work on a definitional formal theory of the -calculus in higher order logic using the HOL theorem prover. The ultimate goal of this work is to provide practical mechanized support for reasoning with the -calculus about applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. J. R. Back and J. von Wright, </author> <title> `Refinement Concepts Formalised in Higher Order Logic', </title> <journal> Formal Aspects of Computing, </journal> <volume> Vol. 2, No. 3 (July-September 1990), </volume> <pages> pp. 247-272. 20 </pages>
Reference-contexts: This is an example of a so-called deep embedding of a formal system in HOL. A similar approach is taken by Camilleri [3] in his formalization of CSP in higher order logic, by Back and von Wright <ref> [1] </ref> in their work on mechanized program transformation in HOL, and in the present author's work on reasoning about circuit models [14]. All this work, however, contrives to avoid explicit definitions of substitution, essentially by inheriting it from higher order logic.
Reference: [2] <author> R. Boulton, A. Gordon, M. Gordon, J. Harrison, J. Herbert, and J. Van Tassel, </author> <title> `Experi--ence with embedding hardware description languages in HOL', in Theorem Provers in Circuit Design: Theory, Practice and Experience: </title> <booktitle> Proceedings of the IFIP WG10.2 International Conference, </booktitle> <address> Nijmegen, </address> <month> June </month> <year> 1992, </year> <title> edited by V. Stavridou, </title> <editor> T. F. Melham, and R. T. </editor> <publisher> Boute (North-Holland, </publisher> <year> 1992), </year> <pages> pp. 129-156. </pages>
Reference-contexts: The result is a system particularly well suited to reasoning about applications, since the HOL system provides highly optimized proof support for these basic syntactic notions. This is sometimes called the shallow embedding approach to mechanizing another formal system in HOL <ref> [2] </ref>. The disadvantage of direct translation is that it does not allow metatheoretic reasoning about the embedded formal system to be carried out within higher order logic itself.
Reference: [3] <author> A. J. Camilleri, </author> <title> `Mechanizing CSP Trace Theory in Higher Order Logic', </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, No. </volume> <month> 9 (September </month> <year> 1990), </year> <pages> pp. 993-1004. </pages>
Reference-contexts: Meaning is then given to these expressions by defining the labelled transition semantics, strong bisimulation, and the relations _~ and ~ within the logic itself. This is an example of a so-called deep embedding of a formal system in HOL. A similar approach is taken by Camilleri <ref> [3] </ref> in his formalization of CSP in higher order logic, by Back and von Wright [1] in their work on mechanized program transformation in HOL, and in the present author's work on reasoning about circuit models [14].
Reference: [4] <author> A. Church, </author> <title> `A Formulation of the Simple Theory of Types', </title> <journal> The Journal of Symbolic Logic, </journal> <volume> Vol. 5 (1940), </volume> <pages> pp. 56-68. </pages>
Reference-contexts: Furthermore, because of the way the logic is represented in ML, such user-defined proof strategies are guaranteed to perform only valid logical inferences. 1.1 Higher order logic The version of higher order logic supported by the HOL theorem prover is based on Church's formulation of simple type theory <ref> [4] </ref>. For the purposes of this paper, the logic can be viewed as a typed extension of the conventional syntax of predicate calculus in which functions may be curried and one may quantify over functions.
Reference: [5] <author> J. A. Goguen, J. W. Thatcher, and E. G. Wagner, </author> <title> `An initial algebra approach to the specification, correctness, and implementation of abstract data types', in Current Trends in Programming Methodology, edited by R.T. </title> <booktitle> Yeh (Prentice-Hall, 1978), </booktitle> <volume> Vol. iv, </volume> <pages> pp. 80-149. </pages>
Reference-contexts: It can be viewed as slight extension of the initiality property by which structures are characterized in the `initial algebra' approach to specifying abstract data types <ref> [5] </ref>. 4.2.1 Primitive recursion and induction over agents As was discussed in section 1.1.1, function constants that satisfy recursive defining equations are not directly definable by the primitive rule for constant definitions.
Reference: [6] <author> A. Gordon, </author> <title> `A Mechanisation of Name-carrying Syntax up to Alpha-conversion' in Higher-order logic theorem proving and its applications, </title> <booktitle> Proceedings 1993, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 780 (Springer-Verlag, </publisher> <year> 1994). </year>
Reference-contexts: As well as being rather dull, these technicalities are notoriously easy to make mistakes about. A general solution to these problems is one of the aims of Andy Gordon's work on representing syntax in a mechanized logic <ref> [6] </ref>. The goal is to define a general theory of syntax and to construct tools to automatically define specific syntaxes in logic and to reason about them. There is, therefore, some hope that theory developments of the kind described in the present paper can be made considerably easier in future.
Reference: [7] <author> M. J. C. Gordon, </author> <title> `Mechanizing Programming Logics in Higher Order Logic', in: Current Trends in Hardware Verification and Automated Theorem Proving, edited by G. Birtwistle and P.A. </title> <publisher> Subrahmanyam (Springer-Verlag, </publisher> <year> 1989), </year> <pages> pp. 387-439. </pages>
Reference-contexts: This approach is exemplified by Mike Gordon's work on mechanizing Hoare logic <ref> [7] </ref>. Meaning is given to partial correctness statements in Hoare logic by translating them into propositions of higher order logic that capture their intended semantics. <p> Partial correctness statements are represented directly by their denotations in logic; with sufficient parser and pretty-printer support, these can be made to look like assertions in Hoare logic (see <ref> [7] </ref>). The advantage of this approach is that the embedded formal system inherits a certain amount of syntactic infrastructure from the underlying logic. For example, -abstraction and fi-reduction in higher order logic can be used to simulate variable binding and substitution in the language being mechanized.
Reference: [8] <author> M. J. C. Gordon and T. F. Melham, eds. </author> <title> Introduction to HOL: A theorem proving environment for higher order logic (Cambridge University Press, </title> <year> 1993). </year>
Reference-contexts: This paper describes work on a mechanized formal theory of the -calculus in higher order logic using the HOL theorem prover <ref> [8] </ref>. The main aim of this work is to construct a practical and sound theorem-proving tool to support reasoning about applications using the -calculus, as well as metatheoretic reasoning about the -calculus itself. Four general principles have been adopted in this project. <p> The aim is to avoid simplifying the calculus merely in order to make the job of mechanizing it easier. One point at which we have compromised this last principle is discussed in section 4.3. 1 The HOL system The HOL system <ref> [8] </ref> is a mechanized proof-assistant for generating proofs in higher order logic. HOL is based on the LCF approach to interactive theorem proving and has many features in common with the LCF systems developed at Cambridge [21] and Edinburgh [9]. <p> A full description of these rules and details of the rest of the logic, including a set-theoretic semantics, can be found in <ref> [8] </ref>. 1.1.1 Primitive rules of definition The HOL user community has a strong tradition of taking a purely definitional approach to using higher order logic, and this is the way in which the logic is used in the present work on the -calculus. <p> It relies heavily on the derived principles of definition available in HOL, which are therefore briefly explained as they used in the sections that follow. Details of these derived rules can be found in the HOL system documentation <ref> [8] </ref> or the papers [12, 14]. 2 A sketch of the -calculus This section provides a summary overview of the -calculus in just enough detail for a reader familiar with (for example) CCS [15] to follow the HOL mechanization described in later sections. <p> This induction theorem can, in turn, be used with another built-in proof tool to automatically construct a HOL tactic for interactive goal-directed proofs by structural induction on agents. (See any one of <ref> [8, 9, 21] </ref> for an explanation of tactics.) As one might expect, this tactic is invaluable for proving many of the basic syntactic theorems about the -calculus in HOL. 4.3 Agent identifiers and replication The -calculus syntax shown in section 2.1 includes defined agents of the form A (x 1 ;
Reference: [9] <author> M. J. Gordon, A. J. Milner, and C. P. Wadsworth, </author> <title> Edinburgh LCF: A Mechanised Logic of Computation, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 78 (Springer-Verlag, </publisher> <year> 1979). </year>
Reference-contexts: HOL is based on the LCF approach to interactive theorem proving and has many features in common with the LCF systems developed at Cambridge [21] and Edinburgh <ref> [9] </ref>. Like LCF, the HOL 1 system supports secure theorem proving by representing its logic in the strongly-typed functional programming language ML. <p> The HOL logic extends Church's formulation in two significant ways: the syntax of types includes the polymorphic type discipline developed by Milner for the LCF logic PP <ref> [9] </ref>, and the primitive basis of the logic includes explicitly-stated rules of definition for consistently extending the logic with new constants and new types. <p> This induction theorem can, in turn, be used with another built-in proof tool to automatically construct a HOL tactic for interactive goal-directed proofs by structural induction on agents. (See any one of <ref> [8, 9, 21] </ref> for an explanation of tactics.) As one might expect, this tactic is invaluable for proving many of the basic syntactic theorems about the -calculus in HOL. 4.3 Agent identifiers and replication The -calculus syntax shown in section 2.1 includes defined agents of the form A (x 1 ;
Reference: [10] <author> R. Harper, F. Honsell, and G. Plotkin, </author> <title> `A Framework for Defining Logics', </title> <type> Report no. </type> <institution> ECS-LFCS-87-23, Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh (March 1987). </institution>
Reference-contexts: It would also be interesting to compare the practical utility of the HOL mechanization with a proof system for the -calculus implemented using a more general logical framework, such as Isabelle [20] or the Edinburgh Logical Framework <ref> [10] </ref>. The research most closely related to the theory described in this paper is Monica Nesi's work on a theory of CCS in HOL [19].
Reference: [11] <author> M. Hennessy and R. Milner, </author> <title> `Algebraic Laws for Nondeterminism and Concurrency', </title> <journal> Journal of the ACM, </journal> <volume> Vol. 32, No. </volume> <month> 1 (January </month> <year> 1985), </year> <pages> pp. 137-161. </pages>
Reference-contexts: This work parallels ours; essentially the same techniques are used to define the syntax and transitional semantics of CCS and to derive rules for observation congruence. A modal logic for CCS (a variant of Hennessy-Milner logic <ref> [11] </ref>) is also included in Nesi's theory. One of the main technical differences between the two formalizations is that the CCS theory has 19 managed to avoid the difficulties connected with substitution.
Reference: [12] <author> T. F. Melham, </author> <title> `Automating Recursive Type Definitions in Higher Order Logic', in Current Trends in Hardware Verification and Automated Theorem Proving, </title> <editor> edited by G. Birtwistle and P. A. </editor> <publisher> Subrahmanyam (Springer-Verlag, </publisher> <year> 1989), </year> <pages> pp. 341-386. </pages>
Reference-contexts: This restriction is necessary because the HOL logic does not allow empty types. The rule of type definition can also be used to define new type operators; one can define, for example, the Cartesian product 1 fi 2 of two types, or the type of finite lists (ff)list. See <ref> [12] </ref> for a series of detailed examples. 1.1.2 Derived rules of definition The primitive rules outlined above disallow the direct use of many commonly-used principles of definition|for example, the definition of functions by primitive recursion. <p> It relies heavily on the derived principles of definition available in HOL, which are therefore briefly explained as they used in the sections that follow. Details of these derived rules can be found in the HOL system documentation [8] or the papers <ref> [12, 14] </ref>. 2 A sketch of the -calculus This section provides a summary overview of the -calculus in just enough detail for a reader familiar with (for example) CCS [15] to follow the HOL mechanization described in later sections. <p> So to define a type of agent expressions a rather complex encoding into values of an existing logical type is required. The HOL system, however, provides a derived principle of definition that automates all the formal inference necessary to define an arbitrary concrete recursive type in higher order logic <ref> [12] </ref>. The user supplies a specification of the required type in a form similar to a datatype declaration in Standard ML [22].
Reference: [13] <author> T. Melham, </author> <title> `A Package for Inductive Relation Definitions in HOL', </title> <booktitle> in Proceedings of the 1991 International Workshop on the HOL Theorem Proving System and its Applications, </booktitle> <address> Davis, </address> <month> August </month> <year> 1991, </year> <title> edited by M. Archer, </title> <editor> J. J. Joyce, K. N. Levitt, and P. J. </editor> <publisher> Windley (IEEE Computer Society Press, </publisher> <year> 1992), </year> <pages> pp. 350-357. </pages>
Reference-contexts: In the mechanized theory of the -calculus this relation is also defined inductively, using a derived principle of inductive predicate definition implemented in HOL <ref> [13] </ref>. Given the user's specification of a desired set of rules, this derived principle of definition automatically proves the existence of the relation inductively defined by them. More precisely, the system constructs a term that explicitly denotes the smallest relation closed under the rules specified by the user.
Reference: [14] <author> T. F. Melham, </author> <title> `Using Recursive Types to Reason about Hardware in Higher Order Logic', </title> <booktitle> in Proceedings of the IFIP WG 10.2 Working Conference on the Fusion of Hardware Design and Verification, </booktitle> <editor> edited by G. J. </editor> <publisher> Milne (North-Holland, </publisher> <year> 1988), </year> <pages> pp. 51-75. </pages>
Reference-contexts: It relies heavily on the derived principles of definition available in HOL, which are therefore briefly explained as they used in the sections that follow. Details of these derived rules can be found in the HOL system documentation [8] or the papers <ref> [12, 14] </ref>. 2 A sketch of the -calculus This section provides a summary overview of the -calculus in just enough detail for a reader familiar with (for example) CCS [15] to follow the HOL mechanization described in later sections. <p> A similar approach is taken by Camilleri [3] in his formalization of CSP in higher order logic, by Back and von Wright [1] in their work on mechanized program transformation in HOL, and in the present author's work on reasoning about circuit models <ref> [14] </ref>. All this work, however, contrives to avoid explicit definitions of substitution, essentially by inheriting it from higher order logic.
Reference: [15] <author> R. Milner, </author> <title> Communication and Concurrency (Prentice Hall, </title> <year> 1989). </year>
Reference-contexts: Details of these derived rules can be found in the HOL system documentation [8] or the papers [12, 14]. 2 A sketch of the -calculus This section provides a summary overview of the -calculus in just enough detail for a reader familiar with (for example) CCS <ref> [15] </ref> to follow the HOL mechanization described in later sections. For full details of the -calculus and for motivational discussion, the reader should consult the papers by Milner, Parrow and Walker [17, 18].
Reference: [16] <author> R. Milner, </author> <title> `The Polyadic -Calculus: a Tutorial', </title> <type> Report no. </type> <institution> ECS-LFCS-91-180, Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh (October 1991). </institution> <month> 21 </month>
Reference-contexts: Preliminary experiments indicate that this approach is feasible, but to date little work has been done on this in the HOL mechanization. For an explanation of how at least some recursive definitions can be encoded using replication, see Milner's tutorial <ref> [16] </ref>. Using replication departs from the formulation in the original exposition of the -calculus. In subsequent work, however, replication has in any case largely replaced agent identifier definitions 10 as the chosen primitive for infinite behaviours. Replication is used in the polyadic -calculus [16], a generalization allowing simultaneous communication of several <p> be encoded using replication, see Milner's tutorial <ref> [16] </ref>. Using replication departs from the formulation in the original exposition of the -calculus. In subsequent work, however, replication has in any case largely replaced agent identifier definitions 10 as the chosen primitive for infinite behaviours. Replication is used in the polyadic -calculus [16], a generalization allowing simultaneous communication of several names, as well as more recent formulations of the original -calculus. 4.4 Elementary syntactic theory Having defined the type (ff)agent in logic, it is straightforward, if somewhat tedious, to develop the elementary theory of the syntax of agents in HOL. <p> Furthermore, one could also reason about -calculus agents without finite control. The automatic parts of any HOL-based tool are, however, likely to be considerably slower than the more specialized system. As a further development of this work, a HOL mechanization of the polyadic -calculus <ref> [16] </ref> should be considered. The formulation of this calculus employs the notion of structural congruence to separate the laws dealing with the structure of groups of agents from those describing how these agents interact.
Reference: [17] <author> R. Milner, J. Parrow, and D. Walker, </author> <title> `A Calculus of Mobile Processes, I', </title> <journal> Information and Computation, </journal> <volume> Vol. 100, No. </volume> <month> 1 (September, </month> <year> 1992), </year> <pages> pp. 1-40. </pages>
Reference-contexts: Introduction The -calculus <ref> [17, 18] </ref> is a process algebra proposed by Milner, Parrow and Walker for modelling concurrent systems in which the pattern of interconnection between processes may change over time. This paper describes work on a mechanized formal theory of the -calculus in higher order logic using the HOL theorem prover [8]. <p> The hope is that this will facilitate experimental investigations in HOL of minor variants of the calculus. Finally, the -calculus as mechanized in HOL is intended to be as nearly identical as possible to the calculus as described in the papers <ref> [17, 18] </ref>. The aim is to avoid simplifying the calculus merely in order to make the job of mechanizing it easier. <p> For full details of the -calculus and for motivational discussion, the reader should consult the papers by Milner, Parrow and Walker <ref> [17, 18] </ref>. <p> The algebraic theory of equivalence is similar (but not identical) to the theory of bisimilarity. For a presentation of the full algebraic theory, detailed proofs of soundness and of completeness for finite agents, and for a discussion of other notions of equivalence for the -calculus, see the papers <ref> [17, 18] </ref>. 3 Mechanizing the -calculus in HOL One possible approach to mechanizing a formal system in HOL is to translate its syntactic objects directly into appropriate denotations in higher order logic. This approach is exemplified by Mike Gordon's work on mechanizing Hoare logic [7]. <p> For clarity of notation, as well as for fidelity to the presentation in <ref> [17, 18] </ref>, the theory makes use of a predefined logical type (ff)set, values of which are sets of elements of type ff. This type is defined formally in the built-in HOL `set theory' library, which contains a substantial collection of basic theorems about sets. <p> In the HOL mechanization, however, agent identifiers are replaced by an alternative way of providing unbounded behaviour, namely the replication of agents. This difference represents the only significant point at which the principle that the HOL theory should be as close as possible to the calculus as presented in <ref> [17, 18] </ref> has been compromised. The replication of an agent P is written `!P ' and is represented in logic by `Repl P '. The agent !P can be thought of as the parallel composition of as many instances of P as desired. <p> In this theorem, the infinity hypothesis is essential. 4.4.4 Substitution for a single name Simultaneous substitution of names for names is needed for only certain parts of the theory developed in <ref> [17, 18] </ref>. In the absence of agent identifiers, full simultaneous substitution is not needed for defining the transition relation, strong bisimulation and the relation _~. Substitution for a single name will suffice. <p> As usual, the choice function ch becomes a parameter. 7 The algebraic theory Having defined strong bisimulation and equivalence in HOL, one may then proceed to develop the algebraic theory presented in <ref> [17, 18] </ref> as a collection of theorems about the relations Bisim and Equiv. Proofs have been completed in HOL for many of the simpler equivalences in this theory, but work on the theory is still in progress.
Reference: [18] <author> R. Milner, J. Parrow, and D. Walker, </author> <title> `A Calculus of Mobile Processes, II', </title> <journal> Information and Computation, </journal> <volume> Vol. 100, No. </volume> <month> 1 (September, </month> <year> 1992), </year> <pages> pp. 41-77. </pages>
Reference-contexts: Introduction The -calculus <ref> [17, 18] </ref> is a process algebra proposed by Milner, Parrow and Walker for modelling concurrent systems in which the pattern of interconnection between processes may change over time. This paper describes work on a mechanized formal theory of the -calculus in higher order logic using the HOL theorem prover [8]. <p> The hope is that this will facilitate experimental investigations in HOL of minor variants of the calculus. Finally, the -calculus as mechanized in HOL is intended to be as nearly identical as possible to the calculus as described in the papers <ref> [17, 18] </ref>. The aim is to avoid simplifying the calculus merely in order to make the job of mechanizing it easier. <p> For full details of the -calculus and for motivational discussion, the reader should consult the papers by Milner, Parrow and Walker <ref> [17, 18] </ref>. <p> ) ! P 0 A (x 1 ; : : : ; x n ) = P P ! P 0 ff ! P 0 match: P ! P 0 ff input-act: x (z):P ! P fw=zg tau-act: t output-act: xy:P ! P The following notation, which is introduced in <ref> [18] </ref>, is used in defining the transition relation for the -calculus. The set of bound names of an action ff is written bn (ff), and the set of free names of an action ff is written fn (ff). <p> The algebraic theory of equivalence is similar (but not identical) to the theory of bisimilarity. For a presentation of the full algebraic theory, detailed proofs of soundness and of completeness for finite agents, and for a discussion of other notions of equivalence for the -calculus, see the papers <ref> [17, 18] </ref>. 3 Mechanizing the -calculus in HOL One possible approach to mechanizing a formal system in HOL is to translate its syntactic objects directly into appropriate denotations in higher order logic. This approach is exemplified by Mike Gordon's work on mechanizing Hoare logic [7]. <p> For clarity of notation, as well as for fidelity to the presentation in <ref> [17, 18] </ref>, the theory makes use of a predefined logical type (ff)set, values of which are sets of elements of type ff. This type is defined formally in the built-in HOL `set theory' library, which contains a substantial collection of basic theorems about sets. <p> In the HOL mechanization, however, agent identifiers are replaced by an alternative way of providing unbounded behaviour, namely the replication of agents. This difference represents the only significant point at which the principle that the HOL theory should be as close as possible to the calculus as presented in <ref> [17, 18] </ref> has been compromised. The replication of an agent P is written `!P ' and is represented in logic by `Repl P '. The agent !P can be thought of as the parallel composition of as many instances of P as desired. <p> This comprises the various definitions and theorems about free and bound names, substitution, and ff-equivalence of agents needed for later proofs|matters that are covered in a mere page or so in the paper <ref> [18] </ref>, but which naturally take considerably longer to treat formally. The following sections outline the HOL theory of free and bound names and substitution; the definition of ff-equivalence is omitted. 4.4.1 Free and bound names Development of the theory begins with defining the function constants Fn, Bn and N. <p> The second theorem merely states that the function N, which is defined recursively in HOL, satisfies the more direct definition used in <ref> [18] </ref>. 11 4.4.2 Substitution One of the more complex definitions in the syntactic theory is the definition of simultaneous substitution of names for free occurrences of names in an agent. The complexity is due, of course, to the name binding constructs of the -calculus. <p> In this theorem, the infinity hypothesis is essential. 4.4.4 Substitution for a single name Simultaneous substitution of names for names is needed for only certain parts of the theory developed in <ref> [17, 18] </ref>. In the absence of agent identifiers, full simultaneous substitution is not needed for defining the transition relation, strong bisimulation and the relation _~. Substitution for a single name will suffice. <p> Given these definitions and the characterizing theorem for the type (ff)action, it is trivial to develop a basic theory of actions for the -calculus in HOL. 5.2 Defining the labelled transition relation In the paper <ref> [18] </ref>, the transition relation ! is defined inductively by the rules reproduced in the present paper in figure 1. In the mechanized theory of the -calculus this relation is also defined inductively, using a derived principle of inductive predicate definition implemented in HOL [13]. <p> Many of the proofs about the -calculus in <ref> [18] </ref> are done by induction on the depth of inference, so this tactic is of primary importance in mechanizing these proofs in HOL. Other proof tools associated with the transition relation include a set of HOL tactics for proving that specific labelled transitions hold between agents of the calculus. <p> n S 2 S)) 8P a P 0 : Trans ch P a P 0 (Fn P 0 (Fn P [ bn a)) ^ (fn a Fn P ) This is one in a series of lemmas for the proof that ff-equivalence is a strong bisimulation presented in the paper <ref> [18] </ref>. The HOL proof was done using the rule induction tactic described above; this is very natural, since the theorem to be proved is an implication of precisely the form one can infer using the rule indiction theorem for Trans. The HOL proof closely follows the detailed proof given in [18], <p> <ref> [18] </ref>. The HOL proof was done using the rule induction tactic described above; this is very natural, since the theorem to be proved is an implication of precisely the form one can infer using the rule indiction theorem for Trans. The HOL proof closely follows the detailed proof given in [18], which proceeds by induction on the depth of inference. <p> As usual, the choice function ch becomes a parameter. 7 The algebraic theory Having defined strong bisimulation and equivalence in HOL, one may then proceed to develop the algebraic theory presented in <ref> [17, 18] </ref> as a collection of theorems about the relations Bisim and Equiv. Proofs have been completed in HOL for many of the simpler equivalences in this theory, but work on the theory is still in progress. <p> P ) P ` 8ch P Q: Bisim ch (Plus P Q) (Plus Q P ) ` 8ch P Q R: Bisim ch (Plus P (Plus Q R)) (Plus (Plus P Q) R) These theorems were proved in HOL in the same way that the corresponding laws are proved in <ref> [18] </ref>, namely by explicitly producing an appropriate strong bisimulation in each case. For example, the bisimulation used to prove the commutative law of summation is presented in [18] as f (P 1 + P 2 ; P 2 + P 1 ) j P 1 ; P 2 agentsg [ Id <p> R)) (Plus (Plus P Q) R) These theorems were proved in HOL in the same way that the corresponding laws are proved in <ref> [18] </ref>, namely by explicitly producing an appropriate strong bisimulation in each case. For example, the bisimulation used to prove the commutative law of summation is presented in [18] as f (P 1 + P 2 ; P 2 + P 1 ) j P 1 ; P 2 agentsg [ Id 18 where Id is the identity relation on agents. <p> The proof that this is indeed a strong bisimulation proceeds essentially by rewriting, making extensive use of the theory of the transition system discussed above in section 5.2. Several other laws are may be proved in HOL in exactly the same way|that is, by exhibiting an appropriate bisimulation. Following <ref> [18] </ref>, many of the laws for equivalence may be easily derived in HOL from corresponding laws for bisimilarity.
Reference: [19] <author> M. Nesi, </author> <title> `A Formalization of the Process Algebra CCS in Higher Order Logic', </title> <type> Technical report no. 278, </type> <institution> Computer Laboratory, University of Cambridge (December 1992). </institution>
Reference-contexts: The research most closely related to the theory described in this paper is Monica Nesi's work on a theory of CCS in HOL <ref> [19] </ref>. This work parallels ours; essentially the same techniques are used to define the syntax and transitional semantics of CCS and to derive rules for observation congruence. A modal logic for CCS (a variant of Hennessy-Milner logic [11]) is also included in Nesi's theory.
Reference: [20] <author> L. C. Paulson, </author> <title> `Isabelle: The Next 700 Theorem Provers', </title> <booktitle> in Logic and Computer Science, edited by P. </booktitle> <publisher> Odifreddi (Academic Press, </publisher> <year> 1990), </year> <pages> pp. 361-386. </pages>
Reference-contexts: Once the theory is complete, we intend to test it on a realistic application. It would also be interesting to compare the practical utility of the HOL mechanization with a proof system for the -calculus implemented using a more general logical framework, such as Isabelle <ref> [20] </ref> or the Edinburgh Logical Framework [10]. The research most closely related to the theory described in this paper is Monica Nesi's work on a theory of CCS in HOL [19].
Reference: [21] <author> L. C. Paulson, </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF, </title> <institution> Cambridge Tracts in Theoretical Computer Science 2 (Cambridge University Press, </institution> <year> 1987). </year>
Reference-contexts: HOL is based on the LCF approach to interactive theorem proving and has many features in common with the LCF systems developed at Cambridge <ref> [21] </ref> and Edinburgh [9]. Like LCF, the HOL 1 system supports secure theorem proving by representing its logic in the strongly-typed functional programming language ML. <p> This induction theorem can, in turn, be used with another built-in proof tool to automatically construct a HOL tactic for interactive goal-directed proofs by structural induction on agents. (See any one of <ref> [8, 9, 21] </ref> for an explanation of tactics.) As one might expect, this tactic is invaluable for proving many of the basic syntactic theorems about the -calculus in HOL. 4.3 Agent identifiers and replication The -calculus syntax shown in section 2.1 includes defined agents of the form A (x 1 ;
Reference: [22] <author> L. C. Paulson, </author> <title> ML for the Working Programmer (Cambridge University Press, </title> <year> 1991). </year>
Reference-contexts: The HOL system, however, provides a derived principle of definition that automates all the formal inference necessary to define an arbitrary concrete recursive type in higher order logic [12]. The user supplies a specification of the required type in a form similar to a datatype declaration in Standard ML <ref> [22] </ref>. The system then constructs an appropriate encoding for values of the required type, defines the type using this encoding and the primitive rule of type definition, and automatically proves an abstract characterization of the newly-defined type.
Reference: [23] <author> D. Sangiorgi, </author> <title> `A Theory of Bisimulation for the -calculus', </title> <booktitle> in CONCUR'93: 4th International Conference on Concurrency Theory, </booktitle> <address> Hildesheim, </address> <month> August </month> <year> 1993, </year> <title> Proceedings, edited by E. Best, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 715 (Springer-Verlag, </publisher> <year> 1993), </year> <pages> pp. 127-142. </pages>
Reference-contexts: This gives a decision procedure for equivalence in a certain class of agents with finite control (similar to finite state systems in CCS). The exact equivalence employed is Sangiorgi's open bisimulation relation <ref> [23] </ref>. The basic strategy of proving equivalences by constructing bisimulations is, of course, also technically possible in the HOL mechanization|it was used `manually' in the proofs discussed in section 7, for example.
Reference: [24] <author> B. Victor and F. Moller, </author> <title> `The Mobility Workbench: A Tool for the -calculus', </title> <type> Report no. </type> <institution> ECS-LFCS-94-285, Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh (February 1994). </institution> <month> 22 </month>
Reference-contexts: By contrast, the present theory deals with the possibility of free variable capture explicitly and formally. A very different approach to providing theorem-proving support for the -calculus is that of the Mobility Workbench <ref> [24] </ref>. This is a special-purpose tool for automated reasoning about equivalences between agents.
References-found: 24

