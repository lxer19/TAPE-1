URL: http://www.cs.rice.edu/CS/PLT/Publications/ic94-ccf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Fully Abstract Semantics for Observably Sequential Languages  
Author: Robert Cartwright Pierre-Louis Curien Matthias Felleisen 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: Rice University Technical Report # 93-219 To appear in Information and Computation 1994 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Barendregt, </author> <title> H.P. The Lambda Calculus: Its Syntax and Semantics. Revised Edition. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: Thus, a rough outline of N fl is let w = "probe argument x i " in Fully Abstract Semantics for Observably Sequential Languages 61 (if0 "w indicates r 1 2 x i " ; <ref> [1] </ref> . . . ; (if0 "w indicates r m 2 x i " ; [m] (if0 "w indicates r m+1 2 x i " ; [m + 1] . . . ; (if0 "w indicates r m+n 2 x i " ; [m + n] ) . . .)) . <p> Without loss of generality, we assume that the final answers are sorted: a 1 &lt; a 2 &lt; . . . &lt; a n . Then N fl = let w = (catch N @ ) in (if0 w ; <ref> [1] </ref> (if0 (sub1 m1 w) ; [m] . . . ) . . .)) . . .) where the expression (sub1 b L) abbreviates the b-fold application of sub1 to the argument expression L.
Reference: 2. <author> Berry, G. Sequentialite de l'evaluation formelle des -expressions. </author> <booktitle> In Proc. 3rd International Colloquium on Programming, </booktitle> <year> 1978. </year>
Reference-contexts: Plotkin [24:Activity Lemma] and Berry [6:Theorem 3.6.4] proved that PCF is sequential, using an adequate 6 operational semantics for PCF. Plotkin's proof is direct, while Berry's proof is obtained as a corollary of a general syntactic sequentiality theorem <ref> [2, 6 : Theorem 3.6.2, 1 : Theorem 14.4.8] </ref>. We conclude the section with two useful examples of PCF procedures.
Reference: 3. <author> Berry, G. </author> <title> Modeles completement adequats et stables des lambda-calculus types. </title> <institution> These d'Etat, Universite Paris VII, </institution> <year> 1979. </year>
Reference-contexts: Unfortunately, neither Milner's nor Plotkin's result showed how to construct a fully abstract denotational semantics for a sequential language like PCF. In a subsequent investigation of sequential languages, Berry and Curien <ref> [3, 4, 6, 8] </ref> constructed a semantics for PCF with more restrictive domains for procedure denotations.
Reference: 4. <author> Berry, G. and P.-L. Curien. </author> <title> Sequential algorithms on concrete data structures. </title> <journal> Theor. Comput. Sci. </journal> <volume> 20, </volume> <year> 1982, </year> <pages> 265-321. </pages>
Reference-contexts: Unfortunately, neither Milner's nor Plotkin's result showed how to construct a fully abstract denotational semantics for a sequential language like PCF. In a subsequent investigation of sequential languages, Berry and Curien <ref> [3, 4, 6, 8] </ref> constructed a semantics for PCF with more restrictive domains for procedure denotations. <p> Berry introduced the stable function space construction, which eliminated many|but not all|parallel functions. 2 To address this problem and to produce a semantic characterization of sequentiality, Berry and Curien <ref> [4, 5] </ref> proposed interpreting procedures as sequential algorithms over concrete domains [18]. Roughly speaking, a concrete domain is a domain that is isomorphic to a domain consisting of potentially infinite trees. A sequential algorithm is a continuous function plus a strategy for evaluating its arguments. <p> The remainder of the paper is devoted to constructing a fully abstract semantics for the family of languages SPCF (E), which extend PCF by the control operators catch t and the error elements E. This work expands and generalizes the work by Berry and Curien <ref> [4] </ref> on semantics for sequential languages based on sequential algorithms over concrete data structures. The next section presents a new framework derived from concrete data structures|called sequential data structures|suitable for defining both Berry and Curien's sequential algorithms and our manifestly sequential functions.
Reference: 5. <author> Berry, G. and P.-L. Curien. </author> <title> Theory and practice of sequential algorithms: the kernel of the applicative language CDS. In Algebraic Methods in Semantics, edited by J. </title> <editor> Reynolds and M. Nivat. </editor> <publisher> Cambridge University Press. </publisher> <address> London, </address> <year> 1985, </year> <pages> 35-88. </pages>
Reference-contexts: Berry introduced the stable function space construction, which eliminated many|but not all|parallel functions. 2 To address this problem and to produce a semantic characterization of sequentiality, Berry and Curien <ref> [4, 5] </ref> proposed interpreting procedures as sequential algorithms over concrete domains [18]. Roughly speaking, a concrete domain is a domain that is isomorphic to a domain consisting of potentially infinite trees. A sequential algorithm is a continuous function plus a strategy for evaluating its arguments.
Reference: 6. <author> Berry, G., P.-L. Curien, and J.-J. L evy. </author> <title> Full abstraction of sequential languages: the state of the art. In Algebraic Methods in Semantics, edited by J. </title> <editor> Reynolds and M. Nivat. </editor> <publisher> Cambridge University Press. </publisher> <address> London, </address> <year> 1985, </year> <pages> 89-131. </pages>
Reference-contexts: Unfortunately, neither Milner's nor Plotkin's result showed how to construct a fully abstract denotational semantics for a sequential language like PCF. In a subsequent investigation of sequential languages, Berry and Curien <ref> [3, 4, 6, 8] </ref> constructed a semantics for PCF with more restrictive domains for procedure denotations. <p> For more details on the history of the full abstraction problem for sequential languages, we refer the reader to three extensive surveys <ref> [6, 9, 32] </ref>. 1.2 Summary of Results This paper integrates recent work by Cartwright and Felleisen [7] and by Curien [10] on fully abstract semantics for simple, sequential extensions of PCF.
Reference: 7. <author> Cartwright, R.S. and M. Felleisen. </author> <title> Observable sequentiality and full abstraction. </title> <type> Technical Report 91-167. </type> <institution> Rice University Department of Computer Science, </institution> <year> 1991. </year> <title> Preliminary version: </title> <booktitle> In Proc. 19th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1992, </year> <pages> 328-342. </pages>
Reference-contexts: For more details on the history of the full abstraction problem for sequential languages, we refer the reader to three extensive surveys [6, 9, 32]. 1.2 Summary of Results This paper integrates recent work by Cartwright and Felleisen <ref> [7] </ref> and by Curien [10] on fully abstract semantics for simple, sequential extensions of PCF. It solves an important form of the full abstraction problem, namely the construction of a fully abstract semantics for a realistic functional language extending PCF. <p> The manifestly sequential functions form a projective subspace [19] of the continuous functions|provided that the domain and codomain meet certain topological constraints. By drawing on their intuitions as programmers, Cartwright and Felleisen <ref> [7] </ref> invented the manifestly sequential functions to construct a fully abstract denotational semantics for a sequential extension of PCF called SPCF. <p> In the framework of sequential data structures, manifestly sequential functions are represented as decision trees, formalized as sets of paths. Sequential 3 The term manifestly sequential was coined by the authors in the process of writing this paper. Cartwright and Felleisen <ref> [7] </ref> defined the manifestly sequential functions in the context of two error elements. They called these functions error-sensitive functions. Manifest sequentiality is a generalization of the original notion of error-sensitivity that is applicable to domains with a single error element. <p> Felleisen thank Rama Kanneganti and Dorai Sitaram for helping hone their intuitions about manifest sequentiality, sequential functions, and for numerous discussions about SPCF. Steve Brookes pointed out a mistake in our original definition of syntactic sequentiality. John Gately and Trevor Jim discovered inconsistencies in the first versions of <ref> [7] </ref> and [10]. The authors gratefully acknowledge comments by Trevor Jim and Robert Harper on an early version of this manuscript. Finally, the authors want to thank the referees for their very careful readings. A Sequential Data Structures vs.
Reference: 8. <author> Curien, P.-L. </author> <title> Categorical Combinators, Sequential Algorithms, </title> <booktitle> and Functional Programming. Research Notes in Theoretical Computer Science. </booktitle> <publisher> Pitman, </publisher> <address> London. </address> <year> 1986. </year> <note> Birkhauser, Revised Edition, </note> <year> 1993. </year>
Reference-contexts: Unfortunately, neither Milner's nor Plotkin's result showed how to construct a fully abstract denotational semantics for a sequential language like PCF. In a subsequent investigation of sequential languages, Berry and Curien <ref> [3, 4, 6, 8] </ref> constructed a semantics for PCF with more restrictive domains for procedure denotations. <p> The semantics of a program P is C [[ ` P ]], an arrow in 1 ! C o . A semantics validates the (fi) and (fix ) axioms of the typed -calculus with Y as well as its inference rules <ref> [8] </ref>. Lemma 3.6 Let C be a semantics for PCF. <p> The first part of this section explains that representation and identifies its important technical properties. The second part uses these properties to prove that SEQ (E) is cartesian-closed provided E is non-empty. For a general treatment of the case E = ; we refer to Curien's monograph <ref> [8] </ref> and Appendix A. 6.2.1 An Extensional Representation of Functions as Trees The informal description of the decision tree representation for functions in the preceding two sections referred to the strategy that a function uses to explore its argument. <p> The main theorem of this appendix states that Seq (E) is cartesian-closed, for any E. This fact can be proved uniformly for any E by faithfully imitating the proofs of Curien <ref> [8] </ref>. In this subsection, we merely sketch the proof by partititioning it into two cases: E = ; and E 6= ;. In each case, we show that the category Seq (E) is equivalent to a category which we already know to be cartesian-closed. <p> Proof. If E = ;, we proceed as follows. The mapping H from sds's to fcds's defined in the previous subsection extends to a full and faithful functor from Seq (;) to the category ALGO of stable cds's and sequential algorithms, shown to be cartesian closed <ref> [8] </ref>. The functor H is actually into the full subcategory fALGO of fcds's. This full subcategory is also cartesian-closed (the product and exponent of two fcds's is filiform) [8: Theorem 2.6.7].
Reference: 9. <author> Curien, P.-L. </author> <title> Sequentiality and full abstraction. </title> <booktitle> In Applications of Categories in Computer Science, </booktitle> <publisher> M.P. </publisher> <editor> Fourman, P.T. Johnstone, and A.M. Pitts (Eds). </editor> <publisher> Cambridge University Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: For more details on the history of the full abstraction problem for sequential languages, we refer the reader to three extensive surveys <ref> [6, 9, 32] </ref>. 1.2 Summary of Results This paper integrates recent work by Cartwright and Felleisen [7] and by Curien [10] on fully abstract semantics for simple, sequential extensions of PCF.
Reference: 10. <author> Curien, P.-L. </author> <title> Observable algorithms on concrete data structures. </title> <booktitle> In Proc. 7th Symposium on Logic in Computer Science, </booktitle> <year> 1992, </year> <pages> 432-443. </pages>
Reference-contexts: For more details on the history of the full abstraction problem for sequential languages, we refer the reader to three extensive surveys [6, 9, 32]. 1.2 Summary of Results This paper integrates recent work by Cartwright and Felleisen [7] and by Curien <ref> [10] </ref> on fully abstract semantics for simple, sequential extensions of PCF. It solves an important form of the full abstraction problem, namely the construction of a fully abstract semantics for a realistic functional language extending PCF. <p> By drawing on their intuitions as programmers, Cartwright and Felleisen [7] invented the manifestly sequential functions to construct a fully abstract denotational semantics for a sequential extension of PCF called SPCF. Curien <ref> [10] </ref> recognized that the manifestly sequential functions were an extensional refinement of the sequential algorithms that he and Berry had developed in an attempt to construct a fully abstract semantics for PCF. <p> Section 7 is devoted to the proof of full abstraction for SPCF. Finally, Section 8 presents an operational semantics and an adequacy theorem for SPCF. The adequacy proof uses a strong normalization argument for bounded recursion, simplifying Curien's original proof <ref> [10] </ref>. The appendix relates the sequential data structures presented in this paper to the original concrete data structures used by Berry and Curien. 2 Mathematical Preliminaries Before we present the syntax and semantics of PCF and SPCF, we need to introduce some definitions and notation. Sets. <p> Steve Brookes pointed out a mistake in our original definition of syntactic sequentiality. John Gately and Trevor Jim discovered inconsistencies in the first versions of [7] and <ref> [10] </ref>. The authors gratefully acknowledge comments by Trevor Jim and Robert Harper on an early version of this manuscript. Finally, the authors want to thank the referees for their very careful readings. A Sequential Data Structures vs.
Reference: 11. <author> Curien, P.-L. </author> <title> On the symmetry of sequentiality. </title> <booktitle> In Proc. Mathematical Foundations of Programming Semantics 1993. Springer Lecture Notes in Computer Science, </booktitle> <address> Berlin. </address> <note> To appear. </note>
Reference-contexts: One can show that the two ways of constructing the function space yield isomorphic results, an idea that naturally leads to the construction of a model of affine and possibly linear logic. This decomposition is explored in forthcoming papers by Lamarche [20] and by the second author <ref> [11] </ref>. 36 R. Cartwright, P.-L. Curien, M. Felleisen "functional tree" is a sequence starting with an address a on an output path, continued with a strategy, eventually followed by a datum that could be associated with a on the output path. <p> assumption of the corollary, t v t 0 iff t ? x v t 0 ? x for all x (by Extensionality) iff Fun (t)(x) v Fun (t 0 )(x) for all x (by Lemma 6.18). 15 Interestingly the Berry-Curien stable ordering for this space coincides with the pointwise ordering <ref> [11] </ref>. 48 R. Cartwright, P.-L. Curien, M.
Reference: 12. <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 180-190. </pages>
Reference-contexts: Definition 4.2). Consequently, the decision tree semantics for PCF is not fully abstract. However, the interesting question is which practical programming languages with non-local control operators are not manifestly sequential or observably sequential. At this point we know of one prominent example: sequential languages with control delimiters <ref> [12] </ref>, also called prompts. The task of a control delimiter is to mask any control operation that happens during the dynamic extent of some expression. Some typical examples in practical languages are Lisp's errset, Common Lisp's unwind-protect and ML's wild-card error-handler. Pragmatically, 80 R. Cartwright, P.-L. Curien, M.
Reference: 13. <author> Felleisen, M. and D.P. Friedman. </author> <title> Control operators, the SECD-machine, and the -calculus. In Formal Description of Programming Concepts III , edited by M. Wirsing. </title> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <address> Amsterdam, </address> <year> 1986, </year> <pages> 193-217. </pages>
Reference-contexts: Moreover, when defined via the reductions of a calculus, an operational semantics also provides a simple equational theory that is useful for proving many observational equivalences. To equip SPCF with an operational semantics, we follow Plotkin's program [25]|as extended by Felleisen, Friedman and Hieb <ref> [13, 14, 15] </ref>|on relating -calculi and abstract machines. More specifically, we define an extension of the typed -calculus and, based on it, a deterministic text rewriting machine for SPCF programs. <p> Fully Abstract Semantics for Observably Sequential Languages 69 8.1 Operational Semantics The description of the operational semantics relies on the notion of an evaluation context <ref> [13] </ref> for two separate purposes. First, the notion of an evaluation context is useful for defining notions of reduction that capture the behavior of error elements and control facilities like catch in a context-free manner. <p> To avoid the introduction of an additional syntactic object, we employ variables as tags and use the notation catch x 1 . . . x m : to mark the evaluation context at the appropriate place. In an abstract machine with an explicit control stack, like the CEK <ref> [13] </ref> machine, this implementation technique corresponds to marking the control stack (K) and binding the variables of the catch argument to these tags. When an environment lookup produces a tag, the control stack is erased to an appropriate extent. 70 R. Cartwright, P.-L. Curien, M. Felleisen Proof.
Reference: 14. <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <institution> Theor. Comput. Sci. </institution> <month> 102, </month> <year> 1992, </year> <pages> 235-271. </pages>
Reference-contexts: Moreover, when defined via the reductions of a calculus, an operational semantics also provides a simple equational theory that is useful for proving many observational equivalences. To equip SPCF with an operational semantics, we follow Plotkin's program [25]|as extended by Felleisen, Friedman and Hieb <ref> [13, 14, 15] </ref>|on relating -calculi and abstract machines. More specifically, we define an extension of the typed -calculus and, based on it, a deterministic text rewriting machine for SPCF programs.
Reference: 15. <author> Felleisen, M., D.P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theor. Comput. Sci. </journal> <volume> 52(3), </volume> <year> 1987, </year> <pages> 205-237. </pages> <note> Preliminary version in: Proc. Symposium on Logic in Computer Science, 1986, 131-141. 86 R. Cartwright, </note> <editor> P.-L. Curien, M. </editor> <publisher> Felleisen </publisher>
Reference-contexts: Moreover, when defined via the reductions of a calculus, an operational semantics also provides a simple equational theory that is useful for proving many observational equivalences. To equip SPCF with an operational semantics, we follow Plotkin's program [25]|as extended by Felleisen, Friedman and Hieb <ref> [13, 14, 15] </ref>|on relating -calculi and abstract machines. More specifically, we define an extension of the typed -calculus and, based on it, a deterministic text rewriting machine for SPCF programs.
Reference: 16. <author> Jim, T. and A. Meyer. </author> <title> Full abstraction and the context lemma. </title> <booktitle> In Proc. International Conference on Theoretical Aspects of Computer Software (TACS). Lecture Notes in Computer Science 526. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin Heidelberg 1991. </address> <pages> 131-151. </pages>
Reference-contexts: In addition, PCF cannot express all of the observations that characterize sequential algorithms, such as the order of 2 Indeed, it even introduces new distinctions, which are impossible in the continuous function space construction. This observation is due to Jim and Meyer <ref> [16] </ref>; for details on this observation, we refer to their paper. 4 R. Cartwright, P.-L. Curien, M. Felleisen argument evaluation. As a result, the sequential algorithm semantics for PCF is not fully abstract.
Reference: 17. <author> Jung, A., and A. Stoughton. </author> <title> Studying the fully abstract model of PCF within its continuous function model. </title> <booktitle> In Proc. Conference on Typed Lambda Calculi and Applications. Lecture Notes in Computer Science 664. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin Heidelberg 1993. </address>
Reference-contexts: He defined a retraction on the conventional semantics that equates all parallel functions with the "overdefined" element top (&gt;). Jung and Stoughton <ref> [17] </ref> recently extended Mulmuley's work by directly constructing a projection from the inductively reachable subal-gebra of the continuous function semantics to the fully abstract semantics for PCF.
Reference: 18. <author> Kahn, G. and G. Plotkin. Domaines Concrets. </author> <type> IRIA Report 336. </type> <year> 1978. </year> <title> English translation: Concrete domains, </title> <note> to appear in C. Boehm Festschrift, special volume of Theoretical Computer Science. </note>
Reference-contexts: Berry introduced the stable function space construction, which eliminated many|but not all|parallel functions. 2 To address this problem and to produce a semantic characterization of sequentiality, Berry and Curien [4, 5] proposed interpreting procedures as sequential algorithms over concrete domains <ref> [18] </ref>. Roughly speaking, a concrete domain is a domain that is isomorphic to a domain consisting of potentially infinite trees. A sequential algorithm is a continuous function plus a strategy for evaluating its arguments.
Reference: 19. <author> Kanneganti, R., R. Cartwright, and M. Felleisen. SPCF: </author> <title> its model, calculus, and computational power. </title> <booktitle> In Proc. REX Workshop on Semantics and Concurrency. Lecture Notes in Computer Science 666. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin Heidelberg 1993. </address> <pages> 318-347. </pages>
Reference-contexts: The key insight underlying this work is the invention of a new form of function space: the domain of manifestly sequential functions. The manifestly sequential functions form a projective subspace <ref> [19] </ref> of the continuous functions|provided that the domain and codomain meet certain topological constraints. By drawing on their intuitions as programmers, Cartwright and Felleisen [7] invented the manifestly sequential functions to construct a fully abstract denotational semantics for a sequential extension of PCF called SPCF. <p> For reasons that will become clear later, we have elected to represent trees as sets of paths. Each path consists of an alternating sequence of 9 Kanneganti, Cartwright, and Felleisen <ref> [19] </ref> developed an alternate characterization of the same categorical framework using a topological formulation of the function space construction. 24 R. Cartwright, P.-L. Curien, M. Felleisen addresses and data items.
Reference: 20. <author> Lamarche, M. </author> <title> Sequentiality, games and linear logic. </title> <type> Unpublished manuscript. </type> <institution> Ecole Normale Superieure, </institution> <year> 1992. </year>
Reference-contexts: One can show that the two ways of constructing the function space yield isomorphic results, an idea that naturally leads to the construction of a model of affine and possibly linear logic. This decomposition is explored in forthcoming papers by Lamarche <ref> [20] </ref> and by the second author [11]. 36 R. Cartwright, P.-L. Curien, M. Felleisen "functional tree" is a sequence starting with an address a on an output path, continued with a strategy, eventually followed by a datum that could be associated with a on the output path.
Reference: 21. <author> Meyer, A. R. and K. Sieber. </author> <title> Towards a fully abstract semantics for local variables. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 191-203. </pages>
Reference-contexts: Consequently, the conventional semantics for language L fails to identify p i and p. Essentially the same example can be constructed in any practical deterministic programming language where procedures can be passed as parameters <ref> [21, 30] </ref>. For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments [30, 29]. Indeed, all commonly used deterministic languages are sequential.
Reference: 22. <author> Milner, R. </author> <title> Fully abstract models of typed -calculi. </title> <journal> Theor. Comput. Sci. </journal> <volume> 4, </volume> <year> 1977, </year> <pages> 1-22. </pages>
Reference-contexts: Moreover, the additional expressiveness is not useful in practice, because it applies only to computations that are unbounded. For this reason, parallel functions have not been included in any practical language. 1.1 History of Previous Work Milner <ref> [22] </ref>, Plotkin [24], and Sazonov [26] were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing a fully abstract semantics for PCF, a call-by-name functional language based on the typed -calculus.
Reference: 23. <author> Mulmuley, K. </author> <title> Full Abstraction and Semantic Equivalence. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: CDS0 differs from conventional functional languages like PCF because it relies on sequential algorithms|represented as decision trees|rather than PCF-like procedures as higher order data objects. Hence, higher order data objects in CDS0 are not extensional. Mulmuley <ref> [23] </ref> generalized Milner's work by showing how to construct a fully abstract semantics for PCF as a quotient of a conventional semantics based on lattices instead of cpos. He defined a retraction on the conventional semantics that equates all parallel functions with the "overdefined" element top (&gt;).
Reference: 24. <author> Plotkin, G.D. </author> <title> LCF considered as a programming language. </title> <journal> Theor. Comput. Sci. </journal> <volume> 5, </volume> <year> 1977, </year> <pages> 223-255. </pages>
Reference-contexts: In this equation, denotes any divergent phrase and i denotes an arbitrary natural number. By a proof technique due to Plotkin <ref> [24] </ref>, p i is observationally equivalent to the procedure p defined by p (f ) = . In essence, the procedures p i diverge for all inputs because the only possible inputs f are sequential procedures. <p> Moreover, the additional expressiveness is not useful in practice, because it applies only to computations that are unbounded. For this reason, parallel functions have not been included in any practical language. 1.1 History of Previous Work Milner [22], Plotkin <ref> [24] </ref>, and Sazonov [26] were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing a fully abstract semantics for PCF, a call-by-name functional language based on the typed -calculus. <p> 1 . . . x t k ~ x t 1 k :N , which by the preceding arguments for closed terms is equivalent to x t 1 1 . . . x k :M v SEQ x t 1 t k k :N and hence, M v SEQ N <ref> [24] </ref>. Lemma 7.7 (Discriminator) If f; g are elements in SEQ t (Seq t ) and f 6v g then for some finite, error-free F 2 D t!o , F ? f v F ? g. <p> For the only-if part of the Adequacy Theorem, we slightly modify Plotkin's computability method originally developed for the adequacy theorem for PCF <ref> [24] </ref>. We proceed in two steps. First, we prove an adequacy theorem for SPCF 1 , which is SPCF without the Y operators. It has the same operational semantics as SPCF.
Reference: 25. <author> Plotkin, G.D. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theor. Comput. Sci. </journal> <volume> 1, </volume> <year> 1975, </year> <pages> 125-159. </pages>
Reference: 26. <author> Sazonov, V.Y. </author> <title> Expressibility of functions in D.Scott's LCF language. Algebra i Logika 15(3), </title> <booktitle> 1976, </booktitle> <pages> 308-330. </pages>
Reference-contexts: Moreover, the additional expressiveness is not useful in practice, because it applies only to computations that are unbounded. For this reason, parallel functions have not been included in any practical language. 1.1 History of Previous Work Milner [22], Plotkin [24], and Sazonov <ref> [26] </ref> were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing a fully abstract semantics for PCF, a call-by-name functional language based on the typed -calculus.
Reference: 27. <author> Scott, D. S. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. International Conference on Automata, Languages, and Programming, Lecture Notes in Mathematics 140, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1982, </year> <pages> 577-613. </pages>
Reference-contexts: In denotational semantics, domains are usually constructed as the ideal completions of finitary bases. The completion process adds infinite elements as limit points for directed sets of finite elements <ref> [27] </ref>. Our construction of domains of trees follows the same general pattern, but relies on smaller bases consisting exclusively of prime elements. 9 This construction is less general than the usual one, but it yields a simpler representation for domain elements in terms of the original basis. <p> Felleisen Proof. It is easy to verify that the union of a bounded set of trees is a tree, that is, that the union is also prefix- and glb-closed. Hence, the proof of the proposition is a variation of the proof for the standard meta-theorem on ideal constructions <ref> [27] </ref>. After establishing what the domains for the semantics of SPCF are, we turn to functions between domains. Specifically, we must formalize the notion of a manifestly sequential function, which we sketched in the previous section. We begin by introducing some auxiliary terminology and notation.
Reference: 28. <author> Scott, </author> <title> D.S. Lectures on a Mathematical Theory of Computation. </title> <type> Techn. Monograph PRG-19, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <year> 1981. </year>
Reference: 29. <author> Sieber, K. </author> <title> Relating full abstraction results for different programming languages. </title> <booktitle> In 10th Conference on Foundations of Software Engineering and Theoretical Computer Science. </booktitle> <editor> K.V. Nori and C.E. Veni Madhavan, Eds. </editor> <booktitle> Lecture Notes in Computer Science 472. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> 373-387. </pages>
Reference-contexts: For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments <ref> [30, 29] </ref>. Indeed, all commonly used deterministic languages are sequential. In rough terms, a language is sequential if it can be implemented without time-slicing among multiple threads of control.
Reference: 30. <author> Sitaram, D. and M. Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990, </year> <month> 161-175. </month> <title> Corrections posted to the "continuations" email list on September Fully Abstract Semantics for Observably Sequential Languages 87 22, </title> <note> 1992 (also available from titan.cs.rice.edu via anonymous ftp in public/languages as lfp90-sf-correction.fps,dvig.Z). </note>
Reference-contexts: Consequently, the conventional semantics for language L fails to identify p i and p. Essentially the same example can be constructed in any practical deterministic programming language where procedures can be passed as parameters <ref> [21, 30] </ref>. For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments [30, 29]. Indeed, all commonly used deterministic languages are sequential. <p> For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments <ref> [30, 29] </ref>. Indeed, all commonly used deterministic languages are sequential. In rough terms, a language is sequential if it can be implemented without time-slicing among multiple threads of control. <p> In a continuation semantics, control operators like Catch are interpreted as functions that "grab" the continuation argument and pass it to other higher order arguments. For sequential languages, continuation-passing semantics are not fully abstract because they rely on continuous function spaces containing parallel functions (as well as control delimiters) <ref> [30] </ref>. Consequently, to construct a fully abstract semantics for SPCF, we must devise a more restrictive collection of domains that 7 If E contains at least two elements, a weaker property of languages called error-sensitivity is equivalent to manifest sequentiality. <p> Languages with control delimiters are designed not to be manifestly sequential because the very task of control delimiters is to swallow all errors generated within their dynamic extent. Consider the following example. Let PCF 0 be PCF augmented by the control delimiter % and indexed error constants <ref> [30] </ref>.
Reference: 31. <author> Steele, G.L., Jr. and G.J. Sussman. </author> <title> The revised report on Scheme, a dialect of Lisp. Memo 452, </title> <publisher> MIT AI-Lab, </publisher> <year> 1978. </year>
Reference-contexts: Since knowledge of the evaluation order can lead to shorter, more expressive, and faster programs, many practical languages include a non-local control operator that can propagate ordinary data values along the evaluation path that an error value would take. The original version of Scheme <ref> [31] </ref>, for example, contained a lexically-scoped Catch construct for implementing non-local exits from expressions.
Reference: 32. <author> Stoughton, A. </author> <title> Fully Abstract Models of Programming Languages. </title> <booktitle> Research Notes in Theoretical Computer Science. </booktitle> <publisher> Pitman, </publisher> <address> London. </address> <year> 1986. </year>
Reference-contexts: For more details on the history of the full abstraction problem for sequential languages, we refer the reader to three extensive surveys <ref> [6, 9, 32] </ref>. 1.2 Summary of Results This paper integrates recent work by Cartwright and Felleisen [7] and by Curien [10] on fully abstract semantics for simple, sequential extensions of PCF.

References-found: 32

