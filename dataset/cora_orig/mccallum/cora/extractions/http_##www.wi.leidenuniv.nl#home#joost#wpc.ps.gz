URL: http://www.wi.leidenuniv.nl/home/joost/wpc.ps.gz
Refering-URL: http://www.wi.leidenuniv.nl/home/joost/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Formal Aspects of  The Weakest Precondition Calculus: Recursion and Duality  
Author: Marcello M. Bonsangue + and Joost N. Kok 
Keyword: weakest (liberal) preconditions; refinement; fixed point transformations; Smyth power domain; Egli-Milner power domain; recursion; denotational semantics;  
Address: NL  
Affiliation: Department of Computer Science, Vrije Universiteit Amsterdam, NL; Department of Computer Science, Utrecht University,  
Note: c  
Pubnum: Computing  
Date: (1994) 3: 1-000  1994 BCS  
Abstract: An extension of Dijkstra's guarded command language is studied, including unbounded demonic choice and a backtrack operator. We consider three orderings on this language: a refinement ordering defined by Back, a new deadlock ordering, and an approximation ordering of Nelson. The deadlock ordering is in between the two other orderings. All operators are monotonic in the Nelson ordering, but backtracking is not monotonic in the Back ordering and sequential composition is not monotonic for the deadlock ordering. At first sight recursion can only be added using the Nelson ordering. We show that, under certain circumstances, least fixed points for non-monotonic functions can be obtained by iteration from the least element. This permits the addition of recursion even using the Back ordering or the deadlock ordering in a fully compositional way. In order to give a semantic characterization of the three orderings in terms of semantics that relate initial states to possible outcomes of the computation, the relation between predicate transformers and discrete power domains is studied. We consider (two versions of) the Smyth power domain and the Egli-Milner power domain. 
Abstract-found: 1
Intro-found: 1
Reference: [AP81] <author> K.R. Apt and G. Plotkin. </author> <title> A Cook's tour of Countable Nondeterminism. </title> <editor> In S. Evens and O. Kariv, editors, </editor> <booktitle> Proc. 8th ICALP, volume 115 of Lecture Notes in Computer Science, </booktitle> <address> Akko, Israel, 1981. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This result was extended by Hitchcock and Park [HP72] showing that also a monotone function from a complete partial order to itself has a least fixed point. Then Apt and Ploktin <ref> [AP81, AP86] </ref> showed that the least fixed point property can be transferred, via a commutative diagram, to monotone functions from a poset (not necessarily complete) to itself. This transfer lemma is explored in detail by Meyer in [Mey85]. <p> If P is a pointed dcpo and f is monotone then f &lt;&gt; always exists. In this case there is an ordinal k such that whenever k we have f &lt;&gt; = f &lt;k&gt; [HP72]. The following theorem, taken from <ref> [AP81, AP86] </ref>, shows that under certain circumstances g &lt;&gt; always exists and stabilizes for a monotone function g : Q ! Q even if Q is not a directed complete partial order: Theorem 4.2.
Reference: [AP86] <author> K.R. Apt and G. Plotkin. </author> <title> Countable Nondeterminism and Random Assignment. </title> <journal> Journal of the ACM, </journal> <volume> 33(4) </volume> <pages> 724-767, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in <ref> [AP86] </ref>, and recursion with unbounded nondeterminism in [DG86, Hes89]. Recursion is added in a fully compositional way by Nelson in [Nel89]: the guarded command language is embedded in a language with sequential composition, binary demonic choice and a backtrack operator in which the operators can be used freely. <p> This result was extended by Hitchcock and Park [HP72] showing that also a monotone function from a complete partial order to itself has a least fixed point. Then Apt and Ploktin <ref> [AP81, AP86] </ref> showed that the least fixed point property can be transferred, via a commutative diagram, to monotone functions from a poset (not necessarily complete) to itself. This transfer lemma is explored in detail by Meyer in [Mey85]. <p> Programs are hence represented by state transforming functions. One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, AP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> In [Wan77, Plo79] predicate transformers satisfy the properties 1., 2., 4. and 5. For countable non-determinism predicate transformers are required to satisfy the properties 1., 2. and 6. in [Bes83] and <ref> [AP86] </ref>. Finally, for a rich specification language with both unbounded angelic and demonic choice in [BW90] predicate transformers are required to satisfy only property 3. Multiplicative predicate transformers are of special interest for our purpose because of the following lemma. This lemma is a variation of the stability lemma in [AP86]: <p> <ref> [AP86] </ref>. Finally, for a rich specification language with both unbounded angelic and demonic choice in [BW90] predicate transformers are required to satisfy only property 3. Multiplicative predicate transformers are of special interest for our purpose because of the following lemma. This lemma is a variation of the stability lemma in [AP86]: Lemma 3.3. Let : Pred ! Pred be a -multiplicative predicate transformer and let 2 be such that 2 (true). Then there is a set min (; ) such that 8Q 2 Pred : 2 (Q) , (min (; ) ) Q): Proof. <p> If P is a pointed dcpo and f is monotone then f &lt;&gt; always exists. In this case there is an ordinal k such that whenever k we have f &lt;&gt; = f &lt;k&gt; [HP72]. The following theorem, taken from <ref> [AP81, AP86] </ref>, shows that under certain circumstances g &lt;&gt; always exists and stabilizes for a monotone function g : Q ! Q even if Q is not a directed complete partial order: Theorem 4.2. <p> We have g &lt;ff&gt; = h (f &lt;ff&gt; ) = h (f &lt;ff+1&gt; ) = h (f (f &lt;ff&gt; )) = g (h (f &lt;ff&gt; )) = g (g &lt;ff&gt; ): So g &lt;ff&gt; is a fixed point of g. In <ref> [AP86] </ref> this is enough to prove that g &lt;ff&gt; = g because g is monotone. In our case, we still have to prove it. Let y 2 Q be another fixed point for g, that is, g (y) = y, and consider the partial order generated by h 1 (y). <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, AP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Figure 2 summarizes the relationships. <p> For example, let N be the set of natural numbers and consider in S ffi (N ? ) the following directed set which has no upper bound: N v N n f0g v N n f0; 1g v :::; (this example is taken from <ref> [AP86] </ref>). We denote by STran ffi the state transformers ! S ffi ( ? ), ordered pointwise. The identity function from STran ffi to STran is trivially onto, continuous, and the inverse image has finite upper fringe, lower fringe and finite antichains for every A 2 S ( ? ).
Reference: [Bac78] <author> R.-J.R. </author> <title> Back. On the Correctness of Refinement Steps in Program Development. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Helsinki, </institution> <year> 1978. </year> <note> Report A-1978-4. </note>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [BW90, Bac90] and also [MRG88, Mor87]). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. <p> M. Bonsangue and J. N. Kok 3. Orderings In this section we introduce three pre-orders on Stat . The first pre-order v B was proposed by Back <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [Bac90] and also [Mor87, MRG88]). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one. <p> Conclusion and Future Work At least four different, but related, topics have been treated in this paper: 1. We proposed an extension of Dijkstra's Weakest Precondition Calculus in order to treat recursion in a fully compositional way with respect to three different orders: a refinement order as introduced in <ref> [Bac78] </ref>, a new refinement order that respects deadlock, and an approximation order as introduced in [Nel89]. 2. We showed that (under certain circumstances), least fixed points of functions (even non-monotone) between posets exist and that they can be obtained by iteration from the least element. 3.
Reference: [Bac80] <author> R.-J.R. </author> <title> Back. Correctness Preserving Program Refinements: Proof Theory and Applications, volume 131 of Mathematical Centre Tracts. </title> <publisher> Mathematical Centre, </publisher> <address> Amsterdam, </address> <year> 1980. </year> <note> 30 M. </note> <editor> M. Bonsangue and J. N. </editor> <publisher> Kok </publisher>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [BW90, Bac90] and also [MRG88, Mor87]). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. <p> M. Bonsangue and J. N. Kok 3. Orderings In this section we introduce three pre-orders on Stat . The first pre-order v B was proposed by Back <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [Bac90] and also [Mor87, MRG88]). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one.
Reference: [Bac81] <author> R.-J.R. </author> <title> Back. On Correct Refinement of Programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 23(1) </volume> <pages> 49-68, </pages> <year> 1981. </year>
Reference-contexts: Programs are hence represented by state transforming functions. One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, AP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, AP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Figure 2 summarizes the relationships.
Reference: [Bac90] <author> R.-J.R. </author> <title> Back. Refinement Calculus, part II: Parallel and Reactive Programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 67-93. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see <ref> [BW90, Bac90] </ref> and also [MRG88, Mor87]). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. For example, for each set of guards there is a different conditional command. <p> M. Bonsangue and J. N. Kok 3. Orderings In this section we introduce three pre-orders on Stat . The first pre-order v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see <ref> [Bac90] </ref> and also [Mor87, MRG88]). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one.
Reference: [Bak80] <author> J.W. de Bakker. </author> <title> Mathematical Theory of Program Correctness. </title> <publisher> Prentice-Hall, </publisher> <year> 1980. </year>
Reference-contexts: For example, for each set of guards there is a different conditional command. An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in [Heh79] and <ref> [Bak80] </ref>. Recursion together with countable nondeterminism is studied in [AP86], and recursion with unbounded nondeterminism in [DG86, Hes89]. <p> The proof proceeds by structural induction on S 2 Stat . We treat only the case S = S 1 3S 2 , since the other cases are standard and can be found, for example, in <ref> [Bak80] </ref>. Let S 1 ; S 2 be two statements.
Reference: [Bes83] <author> E. </author> <title> Best. Relational Semantic of Concurrent Programs (with some Applications). </title> <editor> In D. Bjorner, editor, </editor> <booktitle> Proc. of the IFIP Working Conference on on Formal Description of Programming Concepts - II, </booktitle> <pages> pages 431-452, </pages> <address> Garmisch-Partenkirchen, FRG, 1983. </address> <publisher> North-Holland Publishing Company. </publisher>
Reference-contexts: Programs are hence represented by state transforming functions. One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, AP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> In [Wan77, Plo79] predicate transformers satisfy the properties 1., 2., 4. and 5. For countable non-determinism predicate transformers are required to satisfy the properties 1., 2. and 6. in <ref> [Bes83] </ref> and [AP86]. Finally, for a rich specification language with both unbounded angelic and demonic choice in [BW90] predicate transformers are required to satisfy only property 3. Multiplicative predicate transformers are of special interest for our purpose because of the following lemma. <p> Let be a countable set of states and let 1. - 8. be the list of properties defined above. Then we have The Weakest Precondition Calculus 11 (4: ^ 5:) ) 6: , 7: , 8: ) 3: Proof. For a proof of (4: ^ 5:) ) 8 see <ref> [Bes83] </ref>. We prove only 7: ) 8. The other implications are clear and are left to the reader. Let (P i ) i2I be a set of predicates on where I 6= ; (but possibly, I is uncountable) and let be a predicate transformer satisfying the -multiplicativity law. <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, AP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Figure 2 summarizes the relationships.
Reference: [BK93] <author> M.M. Bonsangue and J.N. Kok. </author> <title> Isomorphisms between State and Predicate Transformers. </title> <editor> In A.M. Borzyszkowski and S. Sokolowoski, editors, </editor> <booktitle> Proc. MFCS '93, Gdansk, Poland, volume 711 of Lecture Notes in Computer Science, </booktitle> <pages> pages 301-310. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> Extended version available through anonymous ftp from ftp.cs.vu.nl as /pub/bonsangue/isomorph.ps.Z. </note>
Reference-contexts: Therefore V i2I (P i ) ) ( i2I P i ). Notice that if is uncountable then (4: ^ 5:) ) 8: , 7: ) 6: ) 3: and that in this case the first implication needs the axiom of choice <ref> [BK93] </ref>. Next we define the three domains of predicate transformers (with associated orders) which we will use in the rest of the paper. Definition 3.5. <p> We would like to consider further extensions of the language, like arbitrary parallelism and angelic choice. Further results on the relationships between predicate transformers and state transformers based on the Smyth, Hoare and Plotkin power domains on algebraic directed complete partial orders can be found in <ref> [BK93] </ref>. Acknowledgements We like to acknowledge the members of the Amsterdam Concurrency Group especially Jaco de Bakker, Franck van Breugel, Jan Rutten, and Daniele Turi for discussions and suggestions about the contents of this paper. Thanks also to two anonymous referees for their useful comments.
Reference: [BW90] <author> R.-J.R. Back and J. von Wright. </author> <title> Refinement Calculus, part I: Sequential Nondeterministic Programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozen-berg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 42-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see <ref> [BW90, Bac90] </ref> and also [MRG88, Mor87]). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. For example, for each set of guards there is a different conditional command. <p> The ordering uses the additional notion of weakest liberal precondition, and is an approximation ordering of the kind used in denotational semantics. It is not suited for refinement in the sense of <ref> [BW90] </ref>. Our starting point is the language of [Nel89]. In this language there is a form of infinite behavior (a divergence construct) and atomic actions that can deadlock (to initiate backtracking). The main operators present in the language are sequential composition, unbounded demonic choice and a backtrack operator. <p> If we identify statements with their weakest preconditions then we have that our language is a subset of the monotonic predicate transformers of <ref> [BW90, Wri90] </ref> because we do not consider angelic choice and multiple assignment statements. The guard statement [b] is b ! and the assert statement fbg is b ! 3div . <p> For the pre-orders v B and v N we refer to <ref> [BW90] </ref> and [Nel89], respectively. We prove only (ii) and (v). Let I be a non-empty index set and let S i ; S 0 i 2 Stat be statements for each i 2 I such that S i v D S 0 i . <p> In [Wan77, Plo79] predicate transformers satisfy the properties 1., 2., 4. and 5. For countable non-determinism predicate transformers are required to satisfy the properties 1., 2. and 6. in [Bes83] and [AP86]. Finally, for a rich specification language with both unbounded angelic and demonic choice in <ref> [BW90] </ref> predicate transformers are required to satisfy only property 3. Multiplicative predicate transformers are of special interest for our purpose because of the following lemma. This lemma is a variation of the stability lemma in [AP86]: Lemma 3.3.
Reference: [DG86] <author> E.W. Dijkstra and A.J.M. van Gasteren. </author> <title> A Simple Fixpoint Argument without the Restriction to Continuity. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 1-7, </pages> <year> 1986. </year>
Reference-contexts: An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in [AP86], and recursion with unbounded nondeterminism in <ref> [DG86, Hes89] </ref>. Recursion is added in a fully compositional way by Nelson in [Nel89]: the guarded command language is embedded in a language with sequential composition, binary demonic choice and a backtrack operator in which the operators can be used freely.
Reference: [Dij76] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: 1. Introduction The weakest precondition calculus of Dijkstra identifies statements in the guarded command language with predicate transformers <ref> [Dij76] </ref> such that program synthesis from specifications is supported. The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. <p> M. Bonsangue and J. N. Kok One difference with the language studied in [Nel89] is that there are two kinds of atomic actions: the assignment action v := t and the test action b !. Another difference is that we allow unbounded demonic choice. Dijkstra's guarded command language <ref> [Dij76, DS90] </ref> can be seen as a subset of this language, except for the do od construct which will be handled when we add recursion. <p> The kind of restrictions depends on the kind of (specification) language one wants to model. For example in <ref> [Dij76] </ref> predicate transformers satisfy the properties 1. - 5. and are used to model a language with at most a countable number of states and with finite nondeterministic demonic choice. In [Wan77, Plo79] predicate transformers satisfy the properties 1., 2., 4. and 5.
Reference: [DS90] <author> E.W. Dijkstra and C.S. Scholten. </author> <title> Predicate Calculus and Program Semantics. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: M. Bonsangue and J. N. Kok One difference with the language studied in [Nel89] is that there are two kinds of atomic actions: the assignment action v := t and the test action b !. Another difference is that we allow unbounded demonic choice. Dijkstra's guarded command language <ref> [Dij76, DS90] </ref> can be seen as a subset of this language, except for the do od construct which will be handled when we add recursion.
Reference: [EM85] <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specification I, volume 6 of EATCS monographs. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In this section we study sufficient conditions on functions that relate semantic domains such that compositionality and least fixed point properties of semantic functions are preserved. We start by giving some general definitions (cf. [GTWW77], <ref> [EM85] </ref> and references contained in these papers). A signature S = (F; r) consists of function names (f 2)F , and a rank function r, giving for each function symbol its arity. Function names with arity 0 are called constants. <p> (f) ; v 1 ; :::; v r (f) (81 i r (f ) : u i v i ) f (u 1 ; ::; u r (f) ) f (v 1 ; :::; v r (f) )): The following lemma is standard, and can be found for example in <ref> [EM85] </ref>: Lemma 6.2. Let S = (F; r) be a signature such that F is a set and every function symbol has finite arity.
Reference: [GTWW77] <author> J.A. Goguen, J.W. Thatcher, E.G. Wagner, and J.B. Wright. </author> <title> Initial Algebra Semantics and Continuous Algebras. </title> <journal> Journal of the ACM, </journal> <volume> 24 </volume> <pages> 68-95, </pages> <year> 1977. </year>
Reference-contexts: In this section we study sufficient conditions on functions that relate semantic domains such that compositionality and least fixed point properties of semantic functions are preserved. We start by giving some general definitions (cf. <ref> [GTWW77] </ref>, [EM85] and references contained in these papers). A signature S = (F; r) consists of function names (f 2)F , and a rank function r, giving for each function symbol its arity. Function names with arity 0 are called constants.
Reference: [Heh79] <author> E.C.R. Hehner. </author> <title> do considered od: a Contribution to Programming Calculus. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 287-304, </pages> <year> 1979. </year>
Reference-contexts: For example, for each set of guards there is a different conditional command. An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in <ref> [Heh79] </ref> and [Bak80]. Recursion together with countable nondeterminism is studied in [AP86], and recursion with unbounded nondeterminism in [DG86, Hes89].
Reference: [Hes89] <author> W.H. Hesselink. </author> <title> Predicate Transformer Semantics of General Recursion. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 309-332, </pages> <year> 1989. </year>
Reference-contexts: An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in [AP86], and recursion with unbounded nondeterminism in <ref> [DG86, Hes89] </ref>. Recursion is added in a fully compositional way by Nelson in [Nel89]: the guarded command language is embedded in a language with sequential composition, binary demonic choice and a backtrack operator in which the operators can be used freely.
Reference: [HP72] <author> P. Hitchcock and D. Park. </author> <title> Induction Rules and Termination Proofs. </title> <editor> In M. Nivat, editor, </editor> <booktitle> Proc. 1st ICALP, </booktitle> <address> Rocquencourt, France, 1972. </address> <publisher> North-Holland. </publisher>
Reference-contexts: This result is proved using an extension of fixed point theory. It is well known that a continuous function from a complete partial order to itself has a least fixed point that can be obtained by iteration from the least element. This result was extended by Hitchcock and Park <ref> [HP72] </ref> showing that also a monotone function from a complete partial order to itself has a least fixed point. Then Apt and Ploktin [AP81, AP86] showed that the least fixed point property can be transferred, via a commutative diagram, to monotone functions from a poset (not necessarily complete) to itself. <p> If P is a pointed dcpo and f is monotone then f &lt;&gt; always exists. In this case there is an ordinal k such that whenever k we have f &lt;&gt; = f &lt;k&gt; <ref> [HP72] </ref>. The following theorem, taken from [AP81, AP86], shows that under certain circumstances g &lt;&gt; always exists and stabilizes for a monotone function g : Q ! Q even if Q is not a directed complete partial order: Theorem 4.2.
Reference: [Mey85] <author> J.-J.Ch. Meyer. </author> <title> Programming Calculi Based on Fixed Point Transformations: Semantics and Applications. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, </address> <year> 1985. </year>
Reference-contexts: Then Apt and Ploktin [AP81, AP86] showed that the least fixed point property can be transferred, via a commutative diagram, to monotone functions from a poset (not necessarily complete) to itself. This transfer lemma is explored in detail by Meyer in <ref> [Mey85] </ref>. We show that the least fixed point property can be transferred to arbitrary functions from a partial order to itself. We also provide state transformer models for three weakest precondition semantics. <p> In particular if f exists (and hence f = f &lt;&gt; for some ordinal ) then so does g and g = h (f ). 2 Several generalizations, where g is always a monotone function, and applications of this theorem (often called transfer lemma) can be found in <ref> [Mey85] </ref>. In the next theorem we show that we can drop the condition of g to be monotone provided that h satisfies some extra conditions. Theorem 4.3. Let P be a pointed dcpo and Q be poset.
Reference: [Mor87] <author> J. Morris. </author> <title> A Theoretical Basis for Stepwise Refinement and the Programming Calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9 </volume> <pages> 287-306, </pages> <year> 1987. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see [BW90, Bac90] and also <ref> [MRG88, Mor87] </ref>). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. For example, for each set of guards there is a different conditional command. <p> M. Bonsangue and J. N. Kok 3. Orderings In this section we introduce three pre-orders on Stat . The first pre-order v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see [Bac90] and also <ref> [Mor87, MRG88] </ref>). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one.
Reference: [MRG88] <author> C.C. Morgan, K.A. Robinson, and P.H.B. Gardiner. </author> <title> On the Refinement Calculus. </title> <type> Technical Report PRG-70, </type> <institution> Programming Research Group, </institution> <year> 1988. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see [BW90, Bac90] and also <ref> [MRG88, Mor87] </ref>). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. For example, for each set of guards there is a different conditional command. <p> M. Bonsangue and J. N. Kok 3. Orderings In this section we introduce three pre-orders on Stat . The first pre-order v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see [Bac90] and also <ref> [Mor87, MRG88] </ref>). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one.
Reference: [Nel89] <author> G. Nelson. </author> <title> A Generalization of Dijkstra's Calculus. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 517-561, </pages> <year> 1989. </year>
Reference-contexts: More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in [AP86], and recursion with unbounded nondeterminism in [DG86, Hes89]. Recursion is added in a fully compositional way by Nelson in <ref> [Nel89] </ref>: the guarded command language is embedded in a language with sequential composition, binary demonic choice and a backtrack operator in which the operators can be used freely. An ordering on predicate transformers is given, and all the operators are monotonic with respect to this ordering. <p> The ordering uses the additional notion of weakest liberal precondition, and is an approximation ordering of the kind used in denotational semantics. It is not suited for refinement in the sense of [BW90]. Our starting point is the language of <ref> [Nel89] </ref>. In this language there is a form of infinite behavior (a divergence construct) and atomic actions that can deadlock (to initiate backtracking). The main operators present in the language are sequential composition, unbounded demonic choice and a backtrack operator. <p> This gives semantic models for the Back and the deadlock ordering. The Egli-Milner power domain (extended with the empty set too, in order to treat deadlock) is treated by giving an isomorphism between the Egli-Milner state transformers and the Nelson predicate transformers (cf. <ref> [Nel89] </ref>). For the state transformer models we define operations that are isomorphic to the corresponding operations between predicate transformers. 2. <p> The only atomic action that can deadlock is b !: it deadlocks in a state in which the boolean expression b does not evaluate to true. 4 M. M. Bonsangue and J. N. Kok One difference with the language studied in <ref> [Nel89] </ref> is that there are two kinds of atomic actions: the assignment action v := t and the test action b !. Another difference is that we allow unbounded demonic choice. <p> is similar to that of wp given in Definition 2.3, except for the cases wlp (div )(Q) = true; and wlp (S 1 3S 2 )(Q) = wlp (S 1 )(Q) ^ (wp (S 1 )(false) ) wlp (S 2 )(Q)): The next lemma, which proof can be found in <ref> [Nel89] </ref>, relates wp and wlp. It states the familiar termination law of Dijkstra. Lemma 3.1. <p> Now we can define the third pre-order, which was introduced in <ref> [Nel89] </ref>: S 1 v N S 2 , def S 1 v B S 2 ^ 8Q 2 Pred : wlp (S 2 )(Q) ) wlp (S 1 )(Q): By definition we have that the Nelson pre-order v N is included in the deadlock pre-order v D , which in turn <p> For the pre-orders v B and v N we refer to [BW90] and <ref> [Nel89] </ref>, respectively. We prove only (ii) and (v). Let I be a non-empty index set and let S i ; S 0 i 2 Stat be statements for each i 2 I such that S i v D S 0 i . <p> We generalize the relationship between the Smyth power domain and the predicate transformers [Wan77, Plo79, Bac81, Bes83, AP86, Smy83] to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also <ref> [Nel89] </ref>). For further reference, the diagram in Figure 2 summarizes the relationships. All the arrows in this diagram are monotone functions. <p> We proposed an extension of Dijkstra's Weakest Precondition Calculus in order to treat recursion in a fully compositional way with respect to three different orders: a refinement order as introduced in [Bac78], a new refinement order that respects deadlock, and an approximation order as introduced in <ref> [Nel89] </ref>. 2. We showed that (under certain circumstances), least fixed points of functions (even non-monotone) between posets exist and that they can be obtained by iteration from the least element. 3. We gave three isomorphisms between domains of predicate transformers and domains of state transformers.
Reference: [Plo79] <author> G.D. Plotkin. </author> <title> Dijkstra's Predicate Transformer and Smyth's Powerdomain. </title> <booktitle> In Proc. of the Winter School on Abstract Software Specification, volume 86 of Lecture Notes in Computer Science, </booktitle> <pages> pages 527-553. </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Programs are hence represented by state transforming functions. One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, AP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> The kind of restrictions depends on the kind of (specification) language one wants to model. For example in [Dij76] predicate transformers satisfy the properties 1. - 5. and are used to model a language with at most a countable number of states and with finite nondeterministic demonic choice. In <ref> [Wan77, Plo79] </ref> predicate transformers satisfy the properties 1., 2., 4. and 5. For countable non-determinism predicate transformers are required to satisfy the properties 1., 2. and 6. in [Bes83] and [AP86]. <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, AP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Figure 2 summarizes the relationships.
Reference: [Plo81] <editor> G.D. Plotkin. </editor> <booktitle> Post-Graduate Lecture Notes in Advanced Domain Theory (incorporating the "Pisa Notes"). </booktitle> <institution> Department of Computer Science, Univ. of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: M. Bonsangue and J. N. Kok 4.1. Order Theory We first recall some of the standard notions in domain theory. A good reference for domain theory is <ref> [Plo81] </ref>. Let P be a poset and S be a non-empty subset of P . Then S is said to be directed if every finite subset of S has an upper bound. <p> by E (X ? ) the poset whose elements are subsets of X ? ordered as follows: A v B , (? 62 A ^ A = B) _ (? 2 A ^ (A n f?g) B): Note that this differs from the usual definition of the Egli-Milner power domain <ref> [Plo81] </ref> because we add the empty set and we have no restriction on the cardinality of subsets of X ? . The poset E (X ? ) is pointed and directed com plete.
Reference: [Roe76] <author> W.P. de Roever. </author> <title> Dijkstra's Predicate Transformer, Non-Determinism, Recursion, </title> <booktitle> and Terminations. In Proc. 5th MFCS, volume 45 of Lecture Notes in Computer Science, </booktitle> <pages> pages 472-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference-contexts: For example, for each set of guards there is a different conditional command. An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in <ref> [Roe76] </ref>. More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in [AP86], and recursion with unbounded nondeterminism in [DG86, Hes89].
Reference: [Smy78] <author> M.B. Smyth. </author> <title> Power Domains. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16(1) </volume> <pages> 23-36, </pages> <year> 1978. </year>
Reference-contexts: Programs are hence represented by state transforming functions. One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain <ref> [Smy78] </ref> and Dijkstra's predicate transformers [Wan77, Plo79, Bac81, Smy83, Bes83, AP86]. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> This definition differs from the original definition of the Smyth power domain <ref> [Smy78] </ref> because we add the empty set as a top element and there is no restriction on the cardinality of the subsets of X.
Reference: [Smy83] <author> M.B. Smyth. </author> <title> Power Domains and Predicate Transformers: A Topological View. </title> <editor> In J. Diaz, editor, </editor> <booktitle> Proc. 10th ICALP, volume 154 of Lecture Notes in Computer Science, </booktitle> <pages> pages 662-675, </pages> <address> Barcelona, Spain, 1983. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Programs are hence represented by state transforming functions. One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, AP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, AP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Figure 2 summarizes the relationships.
Reference: [Wan77] <author> M. Wand. </author> <title> A Characterisation of Weakest Preconditions. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 15 </volume> <pages> 209-212, </pages> <year> 1977. </year>
Reference-contexts: Programs are hence represented by state transforming functions. One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, AP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> The kind of restrictions depends on the kind of (specification) language one wants to model. For example in [Dij76] predicate transformers satisfy the properties 1. - 5. and are used to model a language with at most a countable number of states and with finite nondeterministic demonic choice. In <ref> [Wan77, Plo79] </ref> predicate transformers satisfy the properties 1., 2., 4. and 5. For countable non-determinism predicate transformers are required to satisfy the properties 1., 2. and 6. in [Bes83] and [AP86]. <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, AP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Figure 2 summarizes the relationships.
Reference: [Wri90] <author> J. von Wright. </author> <title> A Lattice-theoretical Basis for Program Refinement. </title> <type> PhD thesis, </type> <note> The Weakest Precondition Calculus 31 Abo Akademi, </note> <year> 1990. </year>
Reference-contexts: If we identify statements with their weakest preconditions then we have that our language is a subset of the monotonic predicate transformers of <ref> [BW90, Wri90] </ref> because we do not consider angelic choice and multiple assignment statements. The guard statement [b] is b ! and the assert statement fbg is b ! 3div . <p> Moreover, if we extend the language with multiple assignment statements, then it is possible to prove that for every multiplicative predicate transformer 2 MPTran there exists a statement S such that = wp (S) <ref> [Wri90] </ref>. A number of different restrictions on predicate transformers can be found in the literature. Next we give a list of some possible requirements on the function space Pred ! Pred that are used in the various definitions: 1. is countable, 10 M. M. Bonsangue and J. N.
References-found: 29

