URL: http://www.cc.gatech.edu/fac/Mustaque.Ahamad/pubs/adaptive.ps
Refering-URL: http://www.cs.gatech.edu/fac/Mustaque.Ahamad/pubs.html
Root-URL: 
Email: mustaq@cc.gatech.edu fraynal,thiakimeg@irisa.fr  
Title: An Adaptive Protocol for Implementing Causally Consistent Distributed Services  
Author: Mustaque AHAMAD Michel RAYNAL and Gerard THIA-KIME 
Note: tem.  
Address: Atlanta, GA 30332 U.S.A 35042 Rennes Cedex France  
Affiliation: College of Computing IRISA Equipe ADP Georgia Institute of Technology Campus de Beaulieu  
Abstract: Distributed services that are accessed by widely distributed clients are becoming common place (e.g., especially services targeted to the home). Such services cannot be provided at the needed level of performance and availability (1) without replicating the service at multiple nodes, and (2) without allowing a "relatively" weak level of consistency among replicated copies of the state of a service. The latter is especially important in large scale systems where communication latencies can be high and communication may not be possible between service instances at all times. In this paper we explore causally consistent distributed services when multiple related services are replicated to meet performance and availability requirements. This consistency criterion is particularly well suited for some distributed services (e.g., cooperative document sharing), and it is attractive because of the efficient implementations that are allowed by it. We develop a new protocol for implementing causally consistent services that has several novel features. First, service instances can be created and deleted dynamically according to service access patterns in the distributed system. Also, when different services are related and consistency is needed across replicated copies of such services, our protocol handles the case where different but related services are replicated independently. Another novel aspect of our protocol lies in its ability to use both push and pull mechanisms for disseminating updates to objects that encapsulate service state. Key-words: Distributed Services, Causality, Causal Consistency, Client-Server Distributed Sys 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Sarita V. Adve and Mark D. Hill. </author> <title> Weak ordering anew definition. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 2-14, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: In weakly ordered shared memory systems, accesses to shared objects are classified as synchronization accesses and data accesses. It is assumed that programs are written such that synchronization accesses, which are strongly consistent, interleave with data accesses such that data races are avoided <ref> [7, 1, 10] </ref>. When this is assumed, it is not necessary to update copies of a data item at the time it is written. Thus, systems such as release consistency [10], ensure consistency of shared object copies only when certain synchronization operations complete (e.g., release on a lock).
Reference: [2] <author> M. Ahamad, P.W. Hutto, G. Neiger, J.E. Burns, and P. Kohli. </author> <title> Causal Memory: Definitions, Implementations and Programming. </title> <journal> Distributed Computing, </journal> <volume> 9 </volume> <pages> 37-49, </pages> <year> 1995. </year>
Reference-contexts: We explore causal consistency (CC) because it appears that it has two main advantages: (1) CC is meaningful for several applications <ref> [2, 9, 16, 30] </ref>, and (2) protocols that implement CC require only weak synchronization that permits the design of efficient implementations. 2 Thus, in this paper we explore the design of a protocol that can be used to provide causally consistent distributed services. <p> Section 5 presents discussion of the protocol, including performance related issues. Section 6 compares the proposed approach with previous works. Finally Section 7 concludes the paper. 2 Causal Consistency Causal consistency (CC), which is based on causality in distributed systems [17], has been explored in a number of contexts <ref> [16, 5, 2, 23, 15] </ref>. <p> If there are no concurrent updates (e.g., concurrent-write-free application), it has been shown that executions permitted by CC can also be obtained in a system that provides strong consistency <ref> [2, 24] </ref>. 2.2 Definition of Causal Consistency We consider a system composed of a finite set of sequential processes (nodes) s 1 ; s 2 ; : : : ; s n which interact through a finite set O of shared objects. <p> It is slightly different from the one introduced in <ref> [2] </ref>. 6 update local copy of x with new value val x . A proof of this protocol can be found in [2, 23]. <p> It is slightly different from the one introduced in [2]. 6 update local copy of x with new value val x . A proof of this protocol can be found in <ref> [2, 23] </ref>. It is interesting to note that this protocol provides wait-free implementation of read and write operations: no synchronization is necessary to schedule a read or a write. <p> Finally, the use of both pull and push mechanisms ensures that all updates need not be propagated to all nodes having copies of the updated object (nodes that do not receive updates can pull them on demand). Other related works that explore implementations of causal consistency are described in <ref> [23, 2, 15] </ref>. They do not explore creation and deletion of server instances and most protocols are either pull or push based. Thus, they include a particular policy for propagating updates whereas our protocol can exploit a policy that makes use of both according to service access patterns.
Reference: [3] <author> O. Babaoglu and A. Schiper. </author> <title> On Group Communication in Large Scale Distributed Systems. </title> <journal> ACM Operating Systems Review, </journal> <volume> 29(1) </volume> <pages> 62-76, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: They do not explore creation and deletion of server instances and most protocols are either pull or push based. Thus, they include a particular policy for propagating updates whereas our protocol can exploit a policy that makes use of both according to service access patterns. The work in <ref> [3] </ref> also divides nodes into categories that bear some resemblance to permanent and potential servers, and clients. For example, the members of the core group can be viewed as permanent servers. However, the emphasis of the paper is on developing a communication infrastructure for information dissemination in large scale systems. <p> The reliability of the permanent servers of a service, which constitute a group, can be addressed using concepts and techniques described in [6, 20, 22, 29]. Fault- tolerance problems related to potential servers of a service can be solved by using solutions inspired from <ref> [3] </ref>. We will explore the application of these techniques to our protocol in the future.
Reference: [4] <author> Sumeer Bhola, Sri Doddapaneni, and Bodhi Mukherjee. Villa: </author> <title> Event and state sharing mechanisms for building interactive collaborations. </title> <note> Submitted for Publication. </note>
Reference-contexts: Furthermore, such applications require good response time (e.g., effects of local actions should become visible immediately) which makes it difficult to provide strong consistency. As a result, systems such as COAST [26], DECAF [27] and Villa <ref> [4] </ref> use optimistic schemes to provide good response time. These systems provide eventual consistency by resolving conflicts when they do arise.
Reference: [5] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year>
Reference-contexts: Section 5 presents discussion of the protocol, including performance related issues. Section 6 compares the proposed approach with previous works. Finally Section 7 concludes the paper. 2 Causal Consistency Causal consistency (CC), which is based on causality in distributed systems [17], has been explored in a number of contexts <ref> [16, 5, 2, 23, 15] </ref>. <p> v i [1::n] (where n is number of nodes) such that: v i [j] = # object updates issued by s j and known by s i . v i is similar to vector clocks defined in [19, 8] and used is a variety of distributed algorithms (e.g., CBCAST delivery <ref> [5] </ref>). <p> This Section presents a protocol implementing this consistency criterion in this architecture. 4.1 Tracking Causality The most fundamental data structure to track causality relations and implement causally consistent objects is a two dimensional matrix of integers <ref> [9, 30, 5, 23] </ref>. Although a version vector is sufficient for tracking causality in the full replication case that was discussed previously, partial replication requires that updates to objects be recorded separately. <p> (x a ) := yes fi; last writer i (x a ) := j; 8 (b; k) : CM i [b; k] := max (CM i [b; k]; CM a [b; k]) od; 14 statement (S2) disappear; the resulting protocol becomes similar to the one used in the Isis system <ref> [5] </ref> for delivering causally ordered messages across overlapping groups (the set P ermanent Servers (x a ) constituting the group associated with x a ). 4.4 Creation and Deletion of Objects The procedures Create and Delete are used by potential servers of objects to add or remove a copy of an <p> Since all updated values are sent to permanent servers of an object and communication is reliable, these updates will arrive and be applied. (A more precise argument can be constructed similar to the argument that all messages are delivered by the CBCAST protocol of Isis <ref> [5] </ref>.) Notice that updates to objects for which s i is a potential server may not be received. However, copies of such objects are deleted (statement S2) when causally overwritten and hence they do not contribute to the delay experienced in processing a message. <p> As mentioned earlier, several papers have presented implementations of causal consistency. In this section, we compare our protocol with these implementations. The Isis system <ref> [5] </ref> (and others that include Horus [29], Transis [6], Totem [20], Psynch [22]) 8 provides causally ordered group communication which can be used to maintain causal consistency among replicated objects. <p> For example, a multicast group can be associated with nodes that have copies of an object and updates to this object can be propagated by using a primitive like CBCAST <ref> [5] </ref>. To maintain consistency across multiple related objects, causal ordering has to be guaranteed across messages that are sent to different groups. The control information required by the Isis CBCAST implementation in this case is the same as the matrix used by our protocol.
Reference: [6] <author> D. Dolev and D. Malki. </author> <title> The Transis Approach to High Availability Cluster Communication. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 64-69, </pages> <year> 1996. </year> <month> 20 </month>
Reference-contexts: As mentioned earlier, several papers have presented implementations of causal consistency. In this section, we compare our protocol with these implementations. The Isis system [5] (and others that include Horus [29], Transis <ref> [6] </ref>, Totem [20], Psynch [22]) 8 provides causally ordered group communication which can be used to maintain causal consistency among replicated objects. <p> Such membership changes can also be induced by failures. The reliability of the permanent servers of a service, which constitute a group, can be addressed using concepts and techniques described in <ref> [6, 20, 22, 29] </ref>. Fault- tolerance problems related to potential servers of a service can be solved by using solutions inspired from [3]. We will explore the application of these techniques to our protocol in the future.
Reference: [7] <author> M. Dubois, C. Scheurich, and F. A. Briggs. </author> <title> Memory access buffering in multiprocessors. </title> <booktitle> In Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: In weakly ordered shared memory systems, accesses to shared objects are classified as synchronization accesses and data accesses. It is assumed that programs are written such that synchronization accesses, which are strongly consistent, interleave with data accesses such that data races are avoided <ref> [7, 1, 10] </ref>. When this is assumed, it is not necessary to update copies of a data item at the time it is written. Thus, systems such as release consistency [10], ensure consistency of shared object copies only when certain synchronization operations complete (e.g., release on a lock).
Reference: [8] <author> C. Fidge. </author> <title> Timestamps in message-passing systems that preserve the partial ordering. </title> <booktitle> Australian Computer Science Conf., </booktitle> <year> 1988. </year>
Reference-contexts: Each node s i is endowed with a version vector v i [1::n] (where n is number of nodes) such that: v i [j] = # object updates issued by s j and known by s i . v i is similar to vector clocks defined in <ref> [19, 8] </ref> and used is a variety of distributed algorithms (e.g., CBCAST delivery [5]).
Reference: [9] <author> M.J. Fischer and A. Michael. </author> <title> Sacrificing Serializability to Attain High Availability of Data in an Unreliable Network. </title> <booktitle> In Proc. ACM Symposium on Principles of Data Base Systems, </booktitle> <year> 1982, </year> <pages> pp. 70-75. </pages>
Reference-contexts: We explore causal consistency (CC) because it appears that it has two main advantages: (1) CC is meaningful for several applications <ref> [2, 9, 16, 30] </ref>, and (2) protocols that implement CC require only weak synchronization that permits the design of efficient implementations. 2 Thus, in this paper we explore the design of a protocol that can be used to provide causally consistent distributed services. <p> This Section presents a protocol implementing this consistency criterion in this architecture. 4.1 Tracking Causality The most fundamental data structure to track causality relations and implement causally consistent objects is a two dimensional matrix of integers <ref> [9, 30, 5, 23] </ref>. Although a version vector is sufficient for tracking causality in the full replication case that was discussed previously, partial replication requires that updates to objects be recorded separately.
Reference: [10] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In ISCA 1990. </booktitle>
Reference-contexts: In weakly ordered shared memory systems, accesses to shared objects are classified as synchronization accesses and data accesses. It is assumed that programs are written such that synchronization accesses, which are strongly consistent, interleave with data accesses such that data races are avoided <ref> [7, 1, 10] </ref>. When this is assumed, it is not necessary to update copies of a data item at the time it is written. Thus, systems such as release consistency [10], ensure consistency of shared object copies only when certain synchronization operations complete (e.g., release on a lock). <p> When this is assumed, it is not necessary to update copies of a data item at the time it is written. Thus, systems such as release consistency <ref> [10] </ref>, ensure consistency of shared object copies only when certain synchronization operations complete (e.g., release on a lock). Such memory systems provide sequential consistency like guarantees to applications that are properly synchronized or data-race-free.
Reference: [11] <author> R. G. Guy, J.S. Heidemann, W. Mak, T. W. Page, G. J. Popek, and D. Rothmeier. </author> <title> Implementation of the Ficus Replicated File System. </title> <booktitle> In USENIX Conference Proceeding, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: However, their results can be applied in our work. In particular, permanent servers can be created and deleted using the view management techniques developed for core members. Weaker consistency levels have been also explored by other systems that include Ficus <ref> [11] </ref>, Bayou [28] and others. Dynamic object copies due to caching are also permitted in systems such as Coda [14] and Rover [13].
Reference: [12] <author> M. Herlihy and J. Wing. </author> <title> Linearizability: a Correctness Condition for Concurrent Objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <year> 1990. </year>
Reference-contexts: Mutual consistency considers a collection of related services and defines consistency across a set of such services. Many consistency criteria have been developed for replicated objects. Linearizability <ref> [12] </ref> is the most used (most of the time in an implicit way) consistency criterion. Intuitively, it says that when reading an object, the value returned must be the last one that has been written into the object, where "last" refers to physical time.
Reference: [13] <author> A. D. Joseph, A. F. de Lespinasse, J. A. Tauber, D. K. Gifford and M. F. Kaashoek. </author> <title> Rover: A Toolkit for Mobile Information Access. </title> <booktitle> In Proc. 15th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Weaker consistency levels have been also explored by other systems that include Ficus [11], Bayou [28] and others. Dynamic object copies due to caching are also permitted in systems such as Coda [14] and Rover <ref> [13] </ref>.
Reference: [14] <author> J. Kistler and M. Satyanarayanan. </author> <title> Disconnected Operation in the Coda File System. </title> <booktitle> In Proc. 13th ACM Symposium on Operating Systems Principles, </booktitle> <address> Pacific Grove CA, </address> <month> December </month> <year> 1995, </year> <pages> pp. 213-225. </pages>
Reference-contexts: Weaker consistency levels have been also explored by other systems that include Ficus [11], Bayou [28] and others. Dynamic object copies due to caching are also permitted in systems such as Coda <ref> [14] </ref> and Rover [13].
Reference: [15] <author> R. Kordale and M. Ahamad. </author> <title> A Scalable Technique for Implementing Multiple Consistency Levels. </title> <booktitle> In Proc. of 16th IEEE International Conference on Distributed Computing Systems (ICDCS), </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Section 5 presents discussion of the protocol, including performance related issues. Section 6 compares the proposed approach with previous works. Finally Section 7 concludes the paper. 2 Causal Consistency Causal consistency (CC), which is based on causality in distributed systems [17], has been explored in a number of contexts <ref> [16, 5, 2, 23, 15] </ref>. <p> Finally, the use of both pull and push mechanisms ensures that all updates need not be propagated to all nodes having copies of the updated object (nodes that do not receive updates can pull them on demand). Other related works that explore implementations of causal consistency are described in <ref> [23, 2, 15] </ref>. They do not explore creation and deletion of server instances and most protocols are either pull or push based. Thus, they include a particular policy for propagating updates whereas our protocol can exploit a policy that makes use of both according to service access patterns.
Reference: [16] <author> R. Ladin, B. Liskov, L. Shrira and S. Ghemawat. </author> <title> Providing Availability Using Lazy Replication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(4) </volume> <pages> 360-392, </pages> <year> 1992. </year>
Reference-contexts: We explore causal consistency (CC) because it appears that it has two main advantages: (1) CC is meaningful for several applications <ref> [2, 9, 16, 30] </ref>, and (2) protocols that implement CC require only weak synchronization that permits the design of efficient implementations. 2 Thus, in this paper we explore the design of a protocol that can be used to provide causally consistent distributed services. <p> Section 5 presents discussion of the protocol, including performance related issues. Section 6 compares the proposed approach with previous works. Finally Section 7 concludes the paper. 2 Causal Consistency Causal consistency (CC), which is based on causality in distributed systems [17], has been explored in a number of contexts <ref> [16, 5, 2, 23, 15] </ref>. <p> Although we do not use a view change protocol when potential servers create and delete service instances, such a protocol will be necessary in the less frequent cases when permanent servers have to be added or deleted or to handle failures of permanent servers. In the lazy replication protocol <ref> [16] </ref>, causal consistency is provided among replicated copies along with operations that provide stronger consistency guarantees. There are two major issues that this protocol does not handle which are addressed by our protocol.
Reference: [17] <author> L. Lamport. </author> <title> Time, Clocks and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <year> 1978. </year>
Reference-contexts: Section 5 presents discussion of the protocol, including performance related issues. Section 6 compares the proposed approach with previous works. Finally Section 7 concludes the paper. 2 Causal Consistency Causal consistency (CC), which is based on causality in distributed systems <ref> [17] </ref>, has been explored in a number of contexts [16, 5, 2, 23, 15].
Reference: [18] <author> L. Lamport. </author> <title> How to Make a Multiprocessor Computer that Correctly Executes Multiprocess Programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C28(9):690-691, </volume> <year> 1979. </year>
Reference-contexts: Intuitively, it says that when reading an object, the value returned must be the last one that has been written into the object, where "last" refers to physical time. This consistency criterion can be weakened by considering "last" referring to logical time; in that case, we obtain sequential consistency <ref> [18] </ref>. These two consistency criteria are called strong.
Reference: [19] <author> F. Mattern. </author> <title> Time and global states of distributed systems. </title> <booktitle> In Proceedings of the International Workshop on Parallel and Distributed Algorithms, </booktitle> <year> 1989. </year>
Reference-contexts: Each node s i is endowed with a version vector v i [1::n] (where n is number of nodes) such that: v i [j] = # object updates issued by s j and known by s i . v i is similar to vector clocks defined in <ref> [19, 8] </ref> and used is a variety of distributed algorithms (e.g., CBCAST delivery [5]).
Reference: [20] <author> L. Moser, P.M. Melliar-Smith, D.A. Agarwal, R.K. Budhia and C.A. Lingley-Papadopoulos. Totem: </author> <title> a Fault-Tolerant Multicast Group Communication System. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 54-63, </pages> <year> 1996. </year>
Reference-contexts: As mentioned earlier, several papers have presented implementations of causal consistency. In this section, we compare our protocol with these implementations. The Isis system [5] (and others that include Horus [29], Transis [6], Totem <ref> [20] </ref>, Psynch [22]) 8 provides causally ordered group communication which can be used to maintain causal consistency among replicated objects. <p> Such membership changes can also be induced by failures. The reliability of the permanent servers of a service, which constitute a group, can be addressed using concepts and techniques described in <ref> [6, 20, 22, 29] </ref>. Fault- tolerance problems related to potential servers of a service can be solved by using solutions inspired from [3]. We will explore the application of these techniques to our protocol in the future.
Reference: [21] <author> D.J. Parker et al. </author> <title> Detection of Mutual Inconsistency in Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE9(3): </volume> <pages> 240-246, </pages> <year> 1983. </year>
Reference-contexts: As in the previous case, this ensures all permanent servers 5 Such version vectors are used in <ref> [21] </ref> to detect mutual inconsistencies among the copies of a single object.
Reference: [22] <author> L.L. Peterson, N.C. Buchholz and R.D. Schilchting. </author> <title> Preserving and Using Context Information in Interprocess Communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <year> 1989. </year>
Reference-contexts: As mentioned earlier, several papers have presented implementations of causal consistency. In this section, we compare our protocol with these implementations. The Isis system [5] (and others that include Horus [29], Transis [6], Totem [20], Psynch <ref> [22] </ref>) 8 provides causally ordered group communication which can be used to maintain causal consistency among replicated objects. For example, a multicast group can be associated with nodes that have copies of an object and updates to this object can be propagated by using a primitive like CBCAST [5]. <p> Such membership changes can also be induced by failures. The reliability of the permanent servers of a service, which constitute a group, can be addressed using concepts and techniques described in <ref> [6, 20, 22, 29] </ref>. Fault- tolerance problems related to potential servers of a service can be solved by using solutions inspired from [3]. We will explore the application of these techniques to our protocol in the future.
Reference: [23] <author> M. Raynal, A. Schiper and S. Toueg. </author> <title> The Causal Ordering Abstraction and a Simple Way to Implement it. </title> <journal> Information Processing Letters, </journal> <volume> 39 </volume> <pages> 343-350, </pages> <year> 1991. </year>
Reference-contexts: Section 5 presents discussion of the protocol, including performance related issues. Section 6 compares the proposed approach with previous works. Finally Section 7 concludes the paper. 2 Causal Consistency Causal consistency (CC), which is based on causality in distributed systems [17], has been explored in a number of contexts <ref> [16, 5, 2, 23, 15] </ref>. <p> Basically, it extends to objects the protocol introduced in <ref> [23] </ref> that implements causal delivery of messages. <p> It is slightly different from the one introduced in [2]. 6 update local copy of x with new value val x . A proof of this protocol can be found in <ref> [2, 23] </ref>. It is interesting to note that this protocol provides wait-free implementation of read and write operations: no synchronization is necessary to schedule a read or a write. <p> This Section presents a protocol implementing this consistency criterion in this architecture. 4.1 Tracking Causality The most fundamental data structure to track causality relations and implement causally consistent objects is a two dimensional matrix of integers <ref> [9, 30, 5, 23] </ref>. Although a version vector is sufficient for tracking causality in the full replication case that was discussed previously, partial replication requires that updates to objects be recorded separately. <p> Finally, the use of both pull and push mechanisms ensures that all updates need not be propagated to all nodes having copies of the updated object (nodes that do not receive updates can pull them on demand). Other related works that explore implementations of causal consistency are described in <ref> [23, 2, 15] </ref>. They do not explore creation and deletion of server instances and most protocols are either pull or push based. Thus, they include a particular policy for propagating updates whereas our protocol can exploit a policy that makes use of both according to service access patterns.
Reference: [24] <author> M. Raynal and A. Schiper. </author> <title> From Causal Consistency to Sequential Consistency in Shared Memory Systems. </title> <booktitle> Proc. 15th Int. Conf. FST&TCS (Foundations of Software Technology and Theoretical Computer Science), </booktitle> <address> Bangalore, India, </address> <publisher> Springer-Verlag LNCS 1026, (P.S. Thiagarajan Ed.), </publisher> <pages> pp. 180-194, </pages> <month> dec. </month> <year> 1995. </year> <month> 21 </month>
Reference-contexts: If there are no concurrent updates (e.g., concurrent-write-free application), it has been shown that executions permitted by CC can also be obtained in a system that provides strong consistency <ref> [2, 24] </ref>. 2.2 Definition of Causal Consistency We consider a system composed of a finite set of sequential processes (nodes) s 1 ; s 2 ; : : : ; s n which interact through a finite set O of shared objects. <p> val x ; j; v); delay the processing of the message until (v i [j] + 1 = v [j] and 8k 6= j : v i [k] v [k]); v i [j] := v i [j] + 1; 1 This definition of causal consistency is the one used in <ref> [24] </ref>. It is slightly different from the one introduced in [2]. 6 update local copy of x with new value val x . A proof of this protocol can be found in [2, 23].
Reference: [25] <author> F. Ruget. </author> <title> Cheaper Matrix Clock. </title> <booktitle> In Proc. 8th Int. Workshop on Distributed Algorithms, </booktitle> <publisher> Springer-Verlag LNCS 857 (G. </publisher> <editor> Tel and P. </editor> <booktitle> Vityani Eds), </booktitle> <pages> pp. 355-369, </pages> <year> 1994. </year>
Reference-contexts: For example, if writes are infrequent, few entries of the matrix will change between successive communications between nodes. In this case, only the changed entries, which can be stored in an update list, need to be sent. Other optimizations explored by Ruget in <ref> [25] </ref> can also be used to reduce the size of the matrix. We feel that the cost of the matrix is fundamental to providing flexible and efficient implementations of replicated objects. Reducing the number of rows by grouping objects restricts the ability to replicate them independently.
Reference: [26] <author> Christian Schuckmann, Lutz Kirchner, Jan Schummer, and Jorg M. Haake. </author> <title> Designing object-oriented synchronous groupware with COAST. </title> <booktitle> In ACM CSCW'96, </booktitle> <year> 1996. </year>
Reference-contexts: Furthermore, such applications require good response time (e.g., effects of local actions should become visible immediately) which makes it difficult to provide strong consistency. As a result, systems such as COAST <ref> [26] </ref>, DECAF [27] and Villa [4] use optimistic schemes to provide good response time. These systems provide eventual consistency by resolving conflicts when they do arise.
Reference: [27] <author> Robert Strom, Guruduth Banavar, Kevan Miller, Atul Prakash, and Michael Ward. </author> <title> Concurrency control and view notification algorithms for collaborative replicated objects. </title> <booktitle> In Proceedings of the 17th ICDCS, </booktitle> <year> 1997. </year>
Reference-contexts: Furthermore, such applications require good response time (e.g., effects of local actions should become visible immediately) which makes it difficult to provide strong consistency. As a result, systems such as COAST [26], DECAF <ref> [27] </ref> and Villa [4] use optimistic schemes to provide good response time. These systems provide eventual consistency by resolving conflicts when they do arise.
Reference: [28] <author> D. Terry, A. Demers, K. Petersen, M. Spreitzer, M. Theimer, and B. Welch. </author> <title> Session Guarantees for Weakly Consistent Replicated Data. </title> <booktitle> In Proc. of International Conference on Parallel and Distributed Data Systems, </booktitle> <month> September </month> <year> 1994, </year> <pages> pp. 140-149. </pages>
Reference-contexts: However, their results can be applied in our work. In particular, permanent servers can be created and deleted using the view management techniques developed for core members. Weaker consistency levels have been also explored by other systems that include Ficus [11], Bayou <ref> [28] </ref> and others. Dynamic object copies due to caching are also permitted in systems such as Coda [14] and Rover [13].
Reference: [29] <author> R. Van Renesse, K.P. Birman and S. Maffeis. Horus: </author> <title> a Flexible Group Communication System. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <year> 1996. </year>
Reference-contexts: As mentioned earlier, several papers have presented implementations of causal consistency. In this section, we compare our protocol with these implementations. The Isis system [5] (and others that include Horus <ref> [29] </ref>, Transis [6], Totem [20], Psynch [22]) 8 provides causally ordered group communication which can be used to maintain causal consistency among replicated objects. <p> Such membership changes can also be induced by failures. The reliability of the permanent servers of a service, which constitute a group, can be addressed using concepts and techniques described in <ref> [6, 20, 22, 29] </ref>. Fault- tolerance problems related to potential servers of a service can be solved by using solutions inspired from [3]. We will explore the application of these techniques to our protocol in the future.
Reference: [30] <author> G.T. Wuu and A.J. Berntsein. </author> <title> Efficient Solutions to the Replicated Log and Dictionary Problems. </title> <booktitle> In Proc. 3rd ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, </address> <year> 1984, </year> <pages> pp. 233-242. 22 </pages>
Reference-contexts: We explore causal consistency (CC) because it appears that it has two main advantages: (1) CC is meaningful for several applications <ref> [2, 9, 16, 30] </ref>, and (2) protocols that implement CC require only weak synchronization that permits the design of efficient implementations. 2 Thus, in this paper we explore the design of a protocol that can be used to provide causally consistent distributed services. <p> This Section presents a protocol implementing this consistency criterion in this architecture. 4.1 Tracking Causality The most fundamental data structure to track causality relations and implement causally consistent objects is a two dimensional matrix of integers <ref> [9, 30, 5, 23] </ref>. Although a version vector is sufficient for tracking causality in the full replication case that was discussed previously, partial replication requires that updates to objects be recorded separately.
References-found: 30

