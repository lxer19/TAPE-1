URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR516.ps.Z
Refering-URL: http://www.cs.indiana.edu/ftp/techreports/index.html
Root-URL: http://www.cs.indiana.edu
Title: One-bit Counts between Unique and Sticky  
Author: David J. Roth and David S. Wise 
Keyword: CCS categories and Subject Descriptors: D.4.2 [Storage Management]: Allocation/Deallocation strategies; E.2 [Data Storage Representations]: Linked representations. General Term: Algorithms. Additional Key Words and Phrases: multiple reference bit, MRB, garbage collection, storage management.  
Address: Bloomington, Indiana 474054101 USA  
Affiliation: Indiana University  
Pubnum: Technical Report 516  
Email: Email: droth, dswise@cs.indiana.edu  
Date: July 1998  
Abstract: Stoye's one-bit reference tagging scheme can be extended to local counts of two or more via two strategies. The first, suited to pure register transactions, is a cache of referents to two shared references. The analog of Deutsch's and Bobrow's multiple-reference table, this cache is sufficient to manage small counts across successive assignment statements. Thus, accurate reference counts above one can be tracked for short intervals, like those bridging one function's environment to its successor's. The second, motivated by runtime stacks that duplicate references, avoids counting any references from the stack. It requires a local pointer-inversion protocol in the mutator, but one still local to the referent and the stack frame. Thus, an accurate reference count of one can be maintained regardless of references from the recursion stack. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. G. Baker. </author> <title> Lively linear lisp`Look Ma, no garbage!' SIG-PLAN Not. </title> <type> 27, </type> <month> 8 (August </month> <year> 1992), </year> <month> 8998. </month>
Reference-contexts: Efforts to use linear logic [11] on this problem led to the introduction of monads [23]. This approach is, in effect, a constraint on programming style, and a bit more drastic than what is wanted <ref> [1] </ref>, even in functional languages. CLEAN [18] is not so restrictive, but depends on the programmer for advice. Jones and Le Metayer [15] offer an abstract semantics to expose many instances of unique reference as a type.
Reference: [2] <author> J. Barth. </author> <title> Shifting garbage collection overhead to compile time. </title> <journal> Commun. ACM 20, </journal> <month> 7 (July </month> <year> 1977), </year> <month> 513518. </month>
Reference-contexts: The first proposal for one-bit reference counting [27] mentions a similar table, pointing to nodes whose count ought to be two, but this doesn't work where the UNIQUE count is a remote tag on two different references. Barth <ref> [2] </ref>, Bloss [3], and others have focused on compile-time analysis to determine the point that storage can be released without run-time counting. Barth, in effect, moves Deutsch-Bobrow counting back to the compiler.
Reference: [3] <author> A. Bloss & P. Hudak. </author> <title> Variations on strictness analysis. </title> <booktitle> Conf. Rec. 1986 ACM Symp. on Lisp and Functional Programming, </booktitle> <pages> 132142. </pages>
Reference-contexts: The first proposal for one-bit reference counting [27] mentions a similar table, pointing to nodes whose count ought to be two, but this doesn't work where the UNIQUE count is a remote tag on two different references. Barth [2], Bloss <ref> [3] </ref>, and others have focused on compile-time analysis to determine the point that storage can be released without run-time counting. Barth, in effect, moves Deutsch-Bobrow counting back to the compiler.
Reference: [4] <author> T. Chikayama & Y. Kimura. </author> <title> Multiple reference management in flat GHC. </title> <editor> In J.L. Lassez (ed.), </editor> <booktitle> Logic Programming, Proc. 4th Intl. Conf. 1. </booktitle> <address> Cambridge, MA: </address> <publisher> M.I.T. Press (1987), </publisher> <pages> 276293. </pages>
Reference-contexts: The smallest possible reference count is a single bit [27, 20], also called the multiple-reference bit (MRB) <ref> [4, 13] </ref>. Of course, 2 and cached count of two. such a count distinguishes between only two values: UNIQUE and STICKY, or 1 and &gt;. The original proposal for 1-bit reference counts [27] located the count at the referenced node. <p> The second entry is from a simple Cheney two-semispace collector. For the measures in this table, a Pointer is half of a CONS box. With capacity for recovering only one node at a time, we nearly reproduce the 30%40% recovery of others <ref> [20, 4, 13] </ref>. Certainly there are more nodes to be recovered via the limited queue of Section 2. The collector has the additional burden of restoring accurate one-bit counts. Still, in the AVL tests, the real-time recovery more than compensated for the time in the slower collection.
Reference: [5] <author> D. W. Clark & C. C. Green. </author> <title> A note on shared list structure in LISP. </title> <journal> Inf. Process. Lett. </journal> <volume> 7, </volume> <month> 6 (October </month> <year> 1978), </year> <month> 312315. </month>
Reference-contexts: The focus of attention in reference-counting storage management [7] is on nodes that are uniquely referenced. Those are the ones that can soon be reallocated, and Clark and Green <ref> [5] </ref> showed that there are lots of them. If the compile- or run-time system can detect the release of those last references in real time, then those nodes can be recycled on the spot. <p> In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures [19, 26, 28] leak away space, or after too-small counters get stuck <ref> [5, 9] </ref>.
Reference: [6] <author> J. Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> ACM Comput Surv. </journal> <volume> 13, </volume> <month> 3 (September </month> <year> 1981), </year> <month> 341367. </month>
Reference-contexts: If no nodes are known to be free, then it contains 0; if a node is to be allocated then, the node must be allocated from the usual memory 1 We use Knuth's original terminology that distinguishes reference counting from garbage collection [16, p. 413]. Cohen <ref> [6] </ref> later merged both concepts under the latter term, and the generalization is now widespread [25, 14]. pool.
Reference: [7] <author> G. E. Collins. </author> <title> A method for overlapping and erasure of lists. </title> <journal> Commun. ACM 3, </journal> <month> 12 (December </month> <year> 1960), </year> <month> 655657. </month>
Reference-contexts: Finally, it is possible to create more than one avail structuresay, one for each type of high-traffic object. 3 Storage management. The focus of attention in reference-counting storage management <ref> [7] </ref> is on nodes that are uniquely referenced. Those are the ones that can soon be reallocated, and Clark and Green [5] showed that there are lots of them.
Reference: [8] <author> D. Culler, R. Karp, D. Patterson, A. Sahay, K. E. Schauser, E. Santos, R. Subramonian, & T. von Eicken. </author> <title> LogP: a practical model of parallel computation. </title> <journal> Commun. ACM 39, </journal> <month> 11 (November </month> <year> 1996), </year> <month> 7885. </month>
Reference-contexts: The friendly metaphor of ecological recycling implies a more local reuse of freed space, enhancing locality. Locality of reference is important to speed cached and paged memories <ref> [8] </ref>, so compact structure and its reuse in situ is desirable. A familiar example of compaction from recycling is use of a sequential stack of frames for implementing nested function calls; popping the stack recycles contiguous space for immediate reuse as environments terminate whenever a function returns.
Reference: [9] <author> L. P. Deutsch & D. G. Bobrow. </author> <title> An efficient, incremental, automatic garbage collector. </title> <journal> Commun. ACM 19, </journal> <month> 9 (September </month> <year> 1976), </year> <month> 522526. </month>
Reference-contexts: In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures [19, 26, 28] leak away space, or after too-small counters get stuck <ref> [5, 9] </ref>. <p> Of what practical use, then, are one-bit counts? There have many been many efforts at several levels to answer this question. A common way to avoid premature nailing is to share a node via a dead pointer. Deutsch and Bobrow <ref> [9] </ref> use a run-time table to track only nodes with counts above one. Nodes with momentary counts of two pass through their Multiple Reference Table (MRT).
Reference: [10] <author> R. Gillam. </author> <title> The anatomy of the assignment operator. C++ Report 9, </title> <booktitle> 10 (November-December 1997), </booktitle> <pages> 1523. </pages>
Reference-contexts: In low-level languages like C, pointer assignment, p=q, is a simple integer assignment. In C++, however, overloading the assignment operator for references to objects gets complicated <ref> [10] </ref>; one must deal with the former referent of p as it is dereferenced, as well as the either new or newly shared referent, q.
Reference: [11] <author> J.Y. Girard. </author> <title> Linear logic. </title> <journal> Theor. Comput. Sci. </journal> <volume> 50 (1987), 1 102. </volume>
Reference-contexts: Barth, in effect, moves Deutsch-Bobrow counting back to the compiler. Suzuki [21] generalized the assignment statement to handle multiple assignments and, in particular, the ubiquitous pointer rotations [17, pp. 89 e.g.] that change no reference counts, in aggregate. Efforts to use linear logic <ref> [11] </ref> on this problem led to the introduction of monads [23]. This approach is, in effect, a constraint on programming style, and a bit more drastic than what is wanted [1], even in functional languages. CLEAN [18] is not so restrictive, but depends on the programmer for advice.
Reference: [12] <author> D. Gries. </author> <title> An exercise in proving programs correct. </title> <booktitle> Com-mun. ACM 20, </booktitle> <month> 12 (December </month> <year> 1977), 921930. </year>
Reference: [13] <author> Y. Inamura, N. Ichiyoshi, K. Rokusawa, & K. Nakajima. </author> <title> Optimization techniques using the MRB and their evaluation on the MultiPSI/V2. </title> <editor> In E. L. Lusk & R. A. Overbeek, </editor> <booktitle> Logic Programming, Proc. of North American Conf. 1989 2, </booktitle> <address> Cam-bridge, MA: </address> <publisher> M.I.T. Press (1989), </publisher> <pages> 907921. </pages>
Reference-contexts: They constitute another type of reference one that the programmer explicitly declares to be redundant and, therefore, exempt from the attention of the storage manager. These can be recognized as Thornton's threads [22, 16, 29] and have also been called special or dead pointers. 2 Inamura et al. <ref> [13] </ref> use such dead links as the second reference necessary to logic programming. Assignment to the user's dead pointers is not treated further, but they are used by our compiler, described in Section 9. <p> The smallest possible reference count is a single bit [27, 20], also called the multiple-reference bit (MRB) <ref> [4, 13] </ref>. Of course, 2 and cached count of two. such a count distinguishes between only two values: UNIQUE and STICKY, or 1 and &gt;. The original proposal for 1-bit reference counts [27] located the count at the referenced node. <p> The second entry is from a simple Cheney two-semispace collector. For the measures in this table, a Pointer is half of a CONS box. With capacity for recovering only one node at a time, we nearly reproduce the 30%40% recovery of others <ref> [20, 4, 13] </ref>. Certainly there are more nodes to be recovered via the limited queue of Section 2. The collector has the additional burden of restoring accurate one-bit counts. Still, in the AVL tests, the real-time recovery more than compensated for the time in the slower collection.
Reference: [14] <author> R. Jones & R. Lins. </author> <title> Garbage Collection. </title> <address> Chichester: </address> <publisher> Wiley (1996). </publisher>
Reference-contexts: Cohen [6] later merged both concepts under the latter term, and the generalization is now widespread <ref> [25, 14] </ref>. pool.
Reference: [15] <author> S. B. Jones & D. Le Metayer. </author> <title> Compile-time garbage collection by sharing analysis. </title> <booktitle> Functional Programming and Computer Architecture, </booktitle> <address> New York: </address> <note> ACM (1989) 5474. </note>
Reference-contexts: This approach is, in effect, a constraint on programming style, and a bit more drastic than what is wanted [1], even in functional languages. CLEAN [18] is not so restrictive, but depends on the programmer for advice. Jones and Le Metayer <ref> [15] </ref> offer an abstract semantics to expose many instances of unique reference as a type. Deutch's and Bobrow's remains the most representative of methodical strategies that work uniformly for all assignment statements. Most of the other techniques try to restrain the growth of counts unnecessarily.
Reference: [16] <author> D. E. </author> <title> Knuth The Art of Computer Programming I, Fundamental Algorithms (3rd ed.), </title> <address> Reading MA: </address> <publisher> Addison-Wesley (1997). </publisher>
Reference-contexts: If no nodes are known to be free, then it contains 0; if a node is to be allocated then, the node must be allocated from the usual memory 1 We use Knuth's original terminology that distinguishes reference counting from garbage collection <ref> [16, p. 413] </ref>. Cohen [6] later merged both concepts under the latter term, and the generalization is now widespread [25, 14]. pool. <p> They constitute another type of reference one that the programmer explicitly declares to be redundant and, therefore, exempt from the attention of the storage manager. These can be recognized as Thornton's threads <ref> [22, 16, 29] </ref> and have also been called special or dead pointers. 2 Inamura et al. [13] use such dead links as the second reference necessary to logic programming. Assignment to the user's dead pointers is not treated further, but they are used by our compiler, described in Section 9.
Reference: [17] <author> H. R. Lewis & L. Dennenberg. </author> <title> Data Structures & Their Algorithms. </title> <address> New York: </address> <month> HarperCollins </month> <year> (1991). </year>
Reference-contexts: (q-&gt;refct)++; if (p-&gt;refct == 1) delete (p); else if (p-&gt;refct != stickyCount) (p-&gt;refct)--; p=q; These three steps proceed in just this order to allow evaluation of values for q that depend on the dying p, and to correctly handle assignments whose semantics is p=p where node p is uniquely referenced <ref> [17, p. 372 e.g.] </ref>. That is the count of greatest interest, and it is the focus of this paper. The right side of the assignment, q below, has already been evaluated. <p> Barth, in effect, moves Deutsch-Bobrow counting back to the compiler. Suzuki [21] generalized the assignment statement to handle multiple assignments and, in particular, the ubiquitous pointer rotations <ref> [17, pp. 89 e.g.] </ref> that change no reference counts, in aggregate. Efforts to use linear logic [11] on this problem led to the introduction of monads [23].
Reference: [18] <author> R. Plasmiejer & M. van Eekelen. </author> <title> Functional Programming and Parallel Graph Rewriting, </title> <address> Workingham, UK: </address> <publisher> Addison-Wesley (1993), x8.5. </publisher>
Reference-contexts: Efforts to use linear logic [11] on this problem led to the introduction of monads [23]. This approach is, in effect, a constraint on programming style, and a bit more drastic than what is wanted [1], even in functional languages. CLEAN <ref> [18] </ref> is not so restrictive, but depends on the programmer for advice. Jones and Le Metayer [15] offer an abstract semantics to expose many instances of unique reference as a type. Deutch's and Bobrow's remains the most representative of methodical strategies that work uniformly for all assignment statements.
Reference: [19] <author> M. G. Sobel. </author> <title> A Practical Guide to the UNIX System (3rd ed.) </title> <address> Redwood City, CA: </address> <month> Benjamin/Cummings </month> <year> (1995), </year> <month> 609611. </month>
Reference-contexts: Applications that are real-time or asynchronously parallel need the locality available from on-line reference counting. In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures <ref> [19, 26, 28] </ref> leak away space, or after too-small counters get stuck [5, 9].
Reference: [20] <author> W. R. Stoye, T. J. W. Clarke, & A. C. Norman. </author> <title> Some practical methods for rapid combinator reduction. </title> <booktitle> Conf. Rec. 1984 ACM Symp. on Lisp and Functional Programming, </booktitle> <pages> 159166. </pages>
Reference-contexts: The smallest possible reference count is a single bit <ref> [27, 20] </ref>, also called the multiple-reference bit (MRB) [4, 13]. Of course, 2 and cached count of two. such a count distinguishes between only two values: UNIQUE and STICKY, or 1 and &gt;. The original proposal for 1-bit reference counts [27] located the count at the referenced node. <p> Of course, 2 and cached count of two. such a count distinguishes between only two values: UNIQUE and STICKY, or 1 and &gt;. The original proposal for 1-bit reference counts [27] located the count at the referenced node. A much better strategy <ref> [20] </ref> is to place this bit as a tag on each reference to the nodeillustrated in the first two sketches of Figure 1 rather than at the node, itself. Although this needs another MRB bit in every reference, it saves the random fetch whenever that count is inspected. <p> The second entry is from a simple Cheney two-semispace collector. For the measures in this table, a Pointer is half of a CONS box. With capacity for recovering only one node at a time, we nearly reproduce the 30%40% recovery of others <ref> [20, 4, 13] </ref>. Certainly there are more nodes to be recovered via the limited queue of Section 2. The collector has the additional burden of restoring accurate one-bit counts. Still, in the AVL tests, the real-time recovery more than compensated for the time in the slower collection.
Reference: [21] <author> N. Suzuki. </author> <title> Analysis of pointer `rotation.' </title> <journal> Commun. ACM 25, </journal> <month> 5 (May </month> <year> 1982), </year> <month> 330335. </month>
Reference-contexts: Barth [2], Bloss [3], and others have focused on compile-time analysis to determine the point that storage can be released without run-time counting. Barth, in effect, moves Deutsch-Bobrow counting back to the compiler. Suzuki <ref> [21] </ref> generalized the assignment statement to handle multiple assignments and, in particular, the ubiquitous pointer rotations [17, pp. 89 e.g.] that change no reference counts, in aggregate. Efforts to use linear logic [11] on this problem led to the introduction of monads [23].
Reference: [22] <author> A. J. Perlis & C. Thornton. </author> <title> Symbol manipulation by threaded lists. </title> <journal> Commun. ACM 3, </journal> <month> 4 (April </month> <year> 1960), 195204. </year>
Reference-contexts: They constitute another type of reference one that the programmer explicitly declares to be redundant and, therefore, exempt from the attention of the storage manager. These can be recognized as Thornton's threads <ref> [22, 16, 29] </ref> and have also been called special or dead pointers. 2 Inamura et al. [13] use such dead links as the second reference necessary to logic programming. Assignment to the user's dead pointers is not treated further, but they are used by our compiler, described in Section 9.
Reference: [23] <author> D. N. Turner & P. Wadler. </author> <title> Once upon a type. </title> <booktitle> Conf. Rec. of FPCA '95: Functional Programming Languages and Computer Architecture, </booktitle> <address> New York: </address> <publisher> ACM Press (1995), </publisher> <pages> 111. </pages>
Reference-contexts: Suzuki [21] generalized the assignment statement to handle multiple assignments and, in particular, the ubiquitous pointer rotations [17, pp. 89 e.g.] that change no reference counts, in aggregate. Efforts to use linear logic [11] on this problem led to the introduction of monads <ref> [23] </ref>. This approach is, in effect, a constraint on programming style, and a bit more drastic than what is wanted [1], even in functional languages. CLEAN [18] is not so restrictive, but depends on the programmer for advice.
Reference: [24] <author> J. Weizenbaum. </author> <title> Symmetric list processor. </title> <journal> Commun. ACM 6, </journal> <month> 9 (September </month> <year> 1963), </year> <month> 524554. </month>
Reference-contexts: "p = new Object ();" */ if (p-&gt;refct != 1)- if (p-&gt;refct != stickyCount) (p-&gt;refct)--; p = new Object (); - The whole point of counting is to reuse space in situ like this! Other references inside the reused node will be handled later as they, themselves, are subsequently initialized/assigned <ref> [24, 28] </ref>. 5 One-bit reference counting. The smallest possible reference count is a single bit [27, 20], also called the multiple-reference bit (MRB) [4, 13]. Of course, 2 and cached count of two. such a count distinguishes between only two values: UNIQUE and STICKY, or 1 and &gt;.
Reference: [25] <author> P. R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Y. Bekkers & J. Cohen (eds.) </editor> <booktitle> Memory Management, LNCS 637, </booktitle> <address> Berlin: </address> <publisher> Springer (1992), </publisher> <pages> 142. </pages>
Reference-contexts: Cohen [6] later merged both concepts under the latter term, and the generalization is now widespread <ref> [25, 14] </ref>. pool.
Reference: [26] <author> D. S. Wise. </author> <title> Stop-and-copy and one-bit reference counting. </title> <journal> Inf. Process. Lett. </journal> <volume> 46, </volume> <month> 5 (July </month> <year> 1993), </year> <note> 243249. Also ftp://ftp.cs.indiana.edu/pub/techreports/TR360.ps.Z </note>
Reference-contexts: Applications that are real-time or asynchronously parallel need the locality available from on-line reference counting. In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures <ref> [19, 26, 28] </ref> leak away space, or after too-small counters get stuck [5, 9]. <p> The reference count on any node (e.g. referenced by p above) is known as soon as it becomes accessible, allowing it to be recycled without even touching it. Moreover, a recopying garbage collector <ref> [26] </ref> can easily correct STICKY tags back to UNIQUE. The idea is that each newly marked node remembers the source of its first (original) reference along with its UNIQUE forwarding address. Any second reference updates the forwarding address to be STICKY and also overwrites it at the original source.
Reference: [27] <author> D. S. Wise & D. P. Friedman. </author> <title> The one-bit reference count. </title> <type> BIT 17, </type> <month> 3 (September </month> <year> 1977), </year> <month> 351359. </month>
Reference-contexts: The smallest possible reference count is a single bit <ref> [27, 20] </ref>, also called the multiple-reference bit (MRB) [4, 13]. Of course, 2 and cached count of two. such a count distinguishes between only two values: UNIQUE and STICKY, or 1 and &gt;. The original proposal for 1-bit reference counts [27] located the count at the referenced node. <p> The smallest possible reference count is a single bit [27, 20], also called the multiple-reference bit (MRB) [4, 13]. Of course, 2 and cached count of two. such a count distinguishes between only two values: UNIQUE and STICKY, or 1 and &gt;. The original proposal for 1-bit reference counts <ref> [27] </ref> located the count at the referenced node. A much better strategy [20] is to place this bit as a tag on each reference to the nodeillustrated in the first two sketches of Figure 1 rather than at the node, itself. <p> Deutsch and Bobrow [9] use a run-time table to track only nodes with counts above one. Nodes with momentary counts of two pass through their Multiple Reference Table (MRT). The first proposal for one-bit reference counting <ref> [27] </ref> mentions a similar table, pointing to nodes whose count ought to be two, but this doesn't work where the UNIQUE count is a remote tag on two different references.
Reference: [28] <author> D. S. Wise, C. Hess, W. Hunt, & E. </author> <title> Ost. Research demonstration of a hardware reference-counting heap. </title> <journal> Lisp Symb. Comp. </journal> <volume> 10, </volume> <month> 2 (July </month> <year> 1997), </year> <month> 159181. </month>
Reference-contexts: Applications that are real-time or asynchronously parallel need the locality available from on-line reference counting. In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures <ref> [19, 26, 28] </ref> leak away space, or after too-small counters get stuck [5, 9]. <p> "p = new Object ();" */ if (p-&gt;refct != 1)- if (p-&gt;refct != stickyCount) (p-&gt;refct)--; p = new Object (); - The whole point of counting is to reuse space in situ like this! Other references inside the reused node will be handled later as they, themselves, are subsequently initialized/assigned <ref> [24, 28] </ref>. 5 One-bit reference counting. The smallest possible reference count is a single bit [27, 20], also called the multiple-reference bit (MRB) [4, 13]. Of course, 2 and cached count of two. such a count distinguishes between only two values: UNIQUE and STICKY, or 1 and &gt;.
Reference: [29] <author> D. S. Wise & J. Walgenbach. </author> <title> Static and dynamic partitioning of pointers as links and threads. </title> <booktitle> Proc. 1996 ACM SIGPLAN Intl. Conf. on Functional Programming, SIGPLAN Not. </booktitle> <volume> 31, </volume> <month> 6 (June </month> <year> 1996), </year> <pages> 4249. 8 </pages>
Reference-contexts: They constitute another type of reference one that the programmer explicitly declares to be redundant and, therefore, exempt from the attention of the storage manager. These can be recognized as Thornton's threads <ref> [22, 16, 29] </ref> and have also been called special or dead pointers. 2 Inamura et al. [13] use such dead links as the second reference necessary to logic programming. Assignment to the user's dead pointers is not treated further, but they are used by our compiler, described in Section 9.
References-found: 29

