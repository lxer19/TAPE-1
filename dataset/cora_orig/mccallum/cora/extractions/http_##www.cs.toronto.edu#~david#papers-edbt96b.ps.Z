URL: http://www.cs.toronto.edu/~david/papers-edbt96b.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: boehlen@iesd.auc.dk  chomicki@moncol.monmouth.edu  rts@cs.arizona.edu  
Phone: 2  3  4  
Title: Querying TSQL2 Databases with Temporal Logic  
Author: Michael H. Bohlen Jan Chomicki Richard T. Snodgrass and David Toman 
Address: Fredrik Bajers Vej 7E, DK-9220 Aalborg Ost, Denmark,  West Long Branch, NJ 07764,  Tucson, AZ 85721,  Toronto, Ontario M5S 1A4, Canada  
Affiliation: 1 Dept. of Mathematics and Computer Science, Aalborg University  Department of Computer Science, Monmouth University  Department of Computer Science, University of Arizona  Department of Computer Science, University of Toronto  
Abstract: We establish an exact correspondence between temporal logic and a subset of TSQL2, a consensus temporal extension of SQL-92. The translation from temporal logic to TSQL2 developed here enables a user to write high-level queries which can be evaluated against a space-efficient representation of the database. The reverse translation, also provided, makes it possible to characterize the expressive power of TSQL2. We demonstrate that temporal logic is equal in expressive power to a syntactically defined subset of TSQL2.
Abstract-found: 1
Intro-found: 1
Reference: [AHV95] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: We show here how to translate temporal logic queries into TSQL2, enabling the user to write high-level queries which will be evaluated against a space-efficient representation of the database. While translations of first order logic to SQL have been previously discussed <ref> [AHV95, VGT91] </ref>, we know of no translations from temporal logic to a temporal query language. We start with a discussion of the basic framework in Section 2. We define the syntax and semantics of the two languages in question, temporal logic and TSQL2. <p> The previous observations are used to define the translation of temporal logic formulas to TSQL2 and prove its correctness. The translation uses an extension of existing methods for translating first-order logic formulas to SQL-92, e.g., <ref> [VGT91, AHV95, Wut91] </ref> as one of its steps. We also give a syntactic criterion for identifying (a subset of) domain independent formulas of temporal logic. 3.1 Temporal Logic to TSQL2 Translation The translation of temporal logic formulas to TSQL2 is defined by induction on the structure of the formula. <p> Finally, we assume here that the valid-time is at a granularity of a year. Thus +1 is shorthand for +INTERVAL '1' YEAR and -1 for -INTERVAL '1' YEAR. Mapping of first-order (sub-)formulas. The mapping of first-order formu-las to relational algebra has been described in several papers and books, e.g., <ref> [VGT91, AHV95] </ref>. As our target language is (T)SQL2 rather than relational algebra, we map maximal first-order subformulas to directly to SQL [Wut91], thereby exploiting the syntactic features of the latter and achieving efficient SQL queries. 3.2 Domain independence Similarly to the first-order case [VGT91, AHV95], not all formulas expressible in temporal <p> described in several papers and books, e.g., <ref> [VGT91, AHV95] </ref>. As our target language is (T)SQL2 rather than relational algebra, we map maximal first-order subformulas to directly to SQL [Wut91], thereby exploiting the syntactic features of the latter and achieving efficient SQL queries. 3.2 Domain independence Similarly to the first-order case [VGT91, AHV95], not all formulas expressible in temporal logic are domain-independent. We identify (a subset of) the domain-independent formulas of temporal logic using an extension of the syntactic criteria defined for first-order formulas. Proposition 4. Let ' be a temporal formula and Alwd be a domain-independence criterion for first-order formulas.
Reference: [AHVdB95] <author> S. Abiteboul, L. Herr, and J. Van den Bussche. </author> <title> Temporal Connectives versus Explicit Timestamps in Temporal Query Languages (unpublished manuscript). </title>
Reference-contexts: The restriction to local queries is also critical. Pure TSQL2 has the same expressive power as two-sorted first-order logic in which there is a separate sort for time [Tom95]. It has been recently shown <ref> [AHVdB95, TN96] </ref> that temporal logic is strictly less expressive than the above two-sorted logic. Thus, there can be no translation from TSQL2 to temporal logic that works for all pure queries. 5 Summary We have established an exact correspondence between temporal logic and a syntactically defined subset of TSQL2.
Reference: [All83] <author> J. F. Allen. </author> <title> Maintaining Knowledge about Temporal Intervals. </title> <journal> Communications of the ACM, </journal> <volume> 16(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: Temporal built-in predicates, which can be used in the WHERE clause in order to specify temporal relationships between pairs of periods. To be consistent with SQL2, the relationships below have a somewhat different meaning than the identically-named relationships in <ref> [All83] </ref>. <p> In this way, all the relationships in <ref> [All83] </ref> can be expressed. 3. A valid clause, which can be placed in front of queries. 5 It is to specify whether a query expression should be evaluated with temporal semantics (no valid clause) or with standard Codd semantics (valid clause). <p> We first describe the mapping of the temporal connectives to TSQL2. This mapping links the translations of the (essentially) first-order pieces of the original query together. Mapping since and until. Figure 1 graphically illustrates the semantics of since and until. We have listed all possible temporal relationships <ref> [All83] </ref> be Temporal relationship between formulas A and B A A A A A A A A A A A A A Temporal logic formula F A since B A until B A since B A until B A until B A since B A until B A since B A
Reference: [BJS95] <author> M. H. Bohlen, C. S. Jensen, and R. T. Snodgrass. </author> <title> Evaluating and Enhancing the Completeness of TSQL2. </title> <type> Technical Report TR 95-5, </type> <institution> Computer Science Department, University of Arizona, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: A valid-time relation is a relation where tuples are implicitly timestamped with periods 3 . Example 5. Table 2 contains a concrete TSQL2 relation representing the abstract temporal database shown in Table 1. 3 In this paper, we use a slight variant of TSQL2 named Applied TSQL2 (ATSQL2) <ref> [BJS95] </ref>. ATSQL2 modifies TSQL2 in a few minor ways. ATSQL2 timestamps tuples with periods rather than with temporal elements; ATSQL2 adds support for duplicates (though we will consider only ATSQL2 queries that remove duplicates); and ATSQL2 changes the syntax of the valid clause. <p> We use (PERIOD) throughout because temporal logic does not allow duplicates or uncoalesced periods. 5. Other facilities not relevant here, including temporal indeterminacy, schema evolution, user-defined granularities, and extensible literal syntax. Semantics. TSQL2 has been given a formal denotational semantics that maps TSQL2 statements to (temporal) relational algebra expressions <ref> [BJS95] </ref>. Example 6. In order to determine the name of the city that superseded Cracow as Poland's capital (c.f., Example 3), different database states have to be related.
Reference: [CC87] <author> J. Clifford and A. Croker. </author> <title> The Historical Relational Data Model (HRDM) and Algebra based on Lifespans. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 528-537, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1987. </year>
Reference-contexts: various proposals have associated with each fact a concise description of the set of points over which the fact holds, such as a period 1 [NA93, Sar90, Sno87, Tan86] or a finite union of periods 1 We use the term `period' in this paper rather than the term `interval' commonly <ref> [CC87, Gad88, Sno95] </ref>. We show here how to translate temporal logic queries into TSQL2, enabling the user to write high-level queries which will be evaluated against a space-efficient representation of the database.
Reference: [CCT94] <author> J. Clifford, A. Croker, and A. Tuzhilin. </author> <title> On Completeness of Historical Relational Query Languages. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(1) </volume> <pages> 64-116, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: The issues addressed include space-efficient storage, effective implementation techniques, and handling large amounts of data. This approach includes the consensus temporal query language TSQL2 [Sno95], whose practical implementations should be forthcoming. The second direction is concerned with defining high-level query languages with logical semantics, e.g., temporal logic <ref> [TC90, GM91, CCT94] </ref>. The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible [CT95].
Reference: [Cho94] <author> J. Chomicki. </author> <title> Temporal Query Languages: a Survey. </title> <booktitle> Proceedings of the First International Conference on Temporal Logic, </booktitle> <pages> pages 506-534, </pages> <year> 1994. </year>
Reference-contexts: In particular, transaction time, which relates when facts are stored in the database, is not considered. 2.1 Temporal logic Temporal logic is an abstract language, i.e., a language which is defined with respect to abstract temporal databases <ref> [Cho94] </ref>. An abstract temporal database, in turn, is a database which captures the formal semantics of a temporal database without considering representation issues. It is possible to view an abstract temporal database in several different but equivalent ways. We choose here the timeslice view (called snapshot in [Cho94]) in which every <p> abstract temporal databases <ref> [Cho94] </ref>. An abstract temporal database, in turn, is a database which captures the formal semantics of a temporal database without considering representation issues. It is possible to view an abstract temporal database in several different but equivalent ways. We choose here the timeslice view (called snapshot in [Cho94]) in which every time instant is associated with a (finite) set of facts that hold at it. For integer-like time, this view leads to an infinite sequence of finite database states (D 0 ; D 1 ; D 2 ; : : :). Example 1. <p> Example 1. Table 1 presents an example of an abstract temporal database, viewed as a sequence of states. The database represents information about Eastern European history, modeling the independence of various countries <ref> [Cho94] </ref>. Each fact indicates an independent nation and its capital. <p> The second example relates different database states. The query (indep (`P oland`; City) ^ City 6= `Cracow`) since indep (`P oland`; `Cracow`) returns the name of the city that superseded Cracow as Poland's capital and the years when this city was the capital. Example 4. Consider the query <ref> [Cho94, p.515] </ref> "list all countries that lost and regained independence" over the abstract temporal database shown in Table 1.
Reference: [Cho95] <author> J. Chomicki. </author> <title> Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> (20) 2, </volume> <pages> 149-186, </pages> <year> 1995. </year>
Reference-contexts: The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible [CT95]. For instance, temporal logic has been proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to sequences of database states [GHR94]. In temporal databases we do not want to construct and store all the states explicitly.
Reference: [CT95] <author> J. Chomicki and D. Toman. </author> <title> Implementing Temporal Integrity Constraints Using an Active DBMS. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Vol. 7, No. 4, </volume> <month> August </month> <year> 1995. </year>
Reference-contexts: The second direction is concerned with defining high-level query languages with logical semantics, e.g., temporal logic [TC90, GM91, CCT94]. The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible <ref> [CT95] </ref>. For instance, temporal logic has been proposed as the language of choice for formulating temporal integrity constraints and triggers [Cho95, CT95, GL93, LS87, SW95]. The semantics of temporal logic queries is defined with respect to sequences of database states [GHR94]. <p> The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible [CT95]. For instance, temporal logic has been proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to sequences of database states [GHR94]. In temporal databases we do not want to construct and store all the states explicitly.
Reference: [EN94] <author> R. Elmasri and S. B. Navathe. </author> <title> Fundamentals of Database Systems. </title> <publisher> Ben-jamin/Cummings Publishing Company, </publisher> <address> 2nd edition, </address> <year> 1994. </year>
Reference: [Gad88] <author> S. K. Gadia. </author> <title> A Homogeneous Relational Model and Query Language for Temporal Databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(4) </volume> <pages> 418-448, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: various proposals have associated with each fact a concise description of the set of points over which the fact holds, such as a period 1 [NA93, Sar90, Sno87, Tan86] or a finite union of periods 1 We use the term `period' in this paper rather than the term `interval' commonly <ref> [CC87, Gad88, Sno95] </ref>. We show here how to translate temporal logic queries into TSQL2, enabling the user to write high-level queries which will be evaluated against a space-efficient representation of the database.
Reference: [GHR94] <author> D.M. Gabbay, I. Hodkinson, and M. Reynolds. </author> <title> Temporal Logic: Mathematical Foundations and Computational Aspects. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: This approach includes the consensus temporal query language TSQL2 [Sno95], whose practical implementations should be forthcoming. The second direction is concerned with defining high-level query languages with logical semantics, e.g., temporal logic [TC90, GM91, CCT94]. The advantages of using logic languages come from their well-understood mathematical properties <ref> [GHR94] </ref>. Logic languages are easy to use and make algebraic query transformation possible [CT95]. For instance, temporal logic has been proposed as the language of choice for formulating temporal integrity constraints and triggers [Cho95, CT95, GL93, LS87, SW95]. <p> For instance, temporal logic has been proposed as the language of choice for formulating temporal integrity constraints and triggers [Cho95, CT95, GL93, LS87, SW95]. The semantics of temporal logic queries is defined with respect to sequences of database states <ref> [GHR94] </ref>. In temporal databases we do not want to construct and store all the states explicitly.
Reference: [GL93] <author> M. Gertz and U.W. Lipeck. </author> <title> Deriving Integrity Maintaining Triggers from Transition Graphs. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible [CT95]. For instance, temporal logic has been proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to sequences of database states [GHR94]. In temporal databases we do not want to construct and store all the states explicitly.
Reference: [GM91] <author> D. Gabbay and P. McBrien. </author> <title> Temporal Logic and Historical Databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1991. </year>
Reference-contexts: The issues addressed include space-efficient storage, effective implementation techniques, and handling large amounts of data. This approach includes the consensus temporal query language TSQL2 [Sno95], whose practical implementations should be forthcoming. The second direction is concerned with defining high-level query languages with logical semantics, e.g., temporal logic <ref> [TC90, GM91, CCT94] </ref>. The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible [CT95].
Reference: [GN93] <author> S. K. Gadia and S. S. Nair. </author> <title> Temporal Databases: A Prelude to Parametric Data. </title> <editor> In A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass, editors, </editor> <title> Temporal Databases: Theory, </title> <booktitle> Design, and Implementation, </booktitle> <pages> pages 28-66. </pages> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper, we bring together two research directions in temporal databases. The first direction is concerned with temporal extensions to calculus-based query languages such as SQL (e.g., <ref> [GN93, NA93, Sar93] </ref>). The issues addressed include space-efficient storage, effective implementation techniques, and handling large amounts of data. This approach includes the consensus temporal query language TSQL2 [Sno95], whose practical implementations should be forthcoming.
Reference: [JCE + 94] <author> C. S. Jensen, J. Clifford, R. Elmasri, S. K. Gadia, P. Hayes, and S. Jajodia editors. </author> <title> A Glossary of Temporal Database Concepts. </title> <journal> ACM SIG-MOD Record, </journal> <volume> 23(1) </volume> <pages> 52-64, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: This view means that the truth-values of facts are associated with individual time points (also called instants). We assume a fixed time granularity. We will consider only valid-time, which relates when facts are valid in reality <ref> [JCE + 94] </ref>. In particular, transaction time, which relates when facts are stored in the database, is not considered. 2.1 Temporal logic Temporal logic is an abstract language, i.e., a language which is defined with respect to abstract temporal databases [Cho94].
Reference: [Klu82] <author> A. Klug. </author> <title> Equivalence of Relational Algebra and Relational Calculus Query Languages Having Aggregate Functions. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 699-717, </pages> <year> 1982. </year>
Reference-contexts: The following is a natural next question to ask: Is there a logical query language equivalent to full TSQL2? The lack of aggregates in temporal logic can be remedied by a syntactic extension of the language, along the lines of one proposed for relational calculus <ref> [Klu82] </ref>. The requirement of maximal periods is more fundamental. In fact, allowing noncoalesced periods calls for a temporal logic that is not point- but period-based [Tom95]. Thus in this case, there can be no translation from full TSQL2 to the temporal logic discussed in this paper, even for local queries.
Reference: [LM93] <author> T. Y. C. Leung and R. R. Muntz. </author> <title> Stream Processing: Temporal Query Processing and Optimization. </title> <editor> In A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass, editors, </editor> <title> Temporal Databases: Theory, </title> <booktitle> Design, and Implementation, chapter 14, </booktitle> <pages> pages 329-355. </pages> <publisher> Benjamin/Cummings Pub--lishing Company, </publisher> <year> 1993. </year>
Reference: [LS87] <author> U.W. Lipeck and G. Saake. </author> <title> Monitoring Dynamic Integrity Constraints Based on Temporal Logic. </title> <journal> Information Systems, </journal> <volume> 12(3) </volume> <pages> 255-269, </pages> <year> 1987. </year>
Reference-contexts: The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible [CT95]. For instance, temporal logic has been proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to sequences of database states [GHR94]. In temporal databases we do not want to construct and store all the states explicitly.
Reference: [MS93] <author> J. Melton and A. R. Simon. </author> <title> Understanding the New SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Eastern European history: the concrete TSQL2 relation Syntax. TSQL2 extends the query language of SQL-92 <ref> [MS93] </ref> with the following constructs: 1. Syntactic constructs to manipulate timestamps (e.g., extract the start and end point of a period, construct a period out of two time points, etc.) 4 . 2.
Reference: [NA93] <author> S. Navathe and R. Ahmed. </author> <title> Temporal Extensions to the Relational Model and SQL. </title> <editor> In A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass, editors, </editor> <title> Temporal Databases: Theory, </title> <booktitle> Design, and Implementation, </booktitle> <pages> pages 92-109. </pages> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper, we bring together two research directions in temporal databases. The first direction is concerned with temporal extensions to calculus-based query languages such as SQL (e.g., <ref> [GN93, NA93, Sar93] </ref>). The issues addressed include space-efficient storage, effective implementation techniques, and handling large amounts of data. This approach includes the consensus temporal query language TSQL2 [Sno95], whose practical implementations should be forthcoming. <p> In temporal databases we do not want to construct and store all the states explicitly. Instead, various proposals have associated with each fact a concise description of the set of points over which the fact holds, such as a period 1 <ref> [NA93, Sar90, Sno87, Tan86] </ref> or a finite union of periods 1 We use the term `period' in this paper rather than the term `interval' commonly [CC87, Gad88, Sno95].
Reference: [Sar90] <author> N. Sarda. </author> <title> Extensions to SQL for Historical Databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(2) </volume> <pages> 220-230, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In temporal databases we do not want to construct and store all the states explicitly. Instead, various proposals have associated with each fact a concise description of the set of points over which the fact holds, such as a period 1 <ref> [NA93, Sar90, Sno87, Tan86] </ref> or a finite union of periods 1 We use the term `period' in this paper rather than the term `interval' commonly [CC87, Gad88, Sno95].
Reference: [Sar93] <author> N. Sarda. HSQL: </author> <title> A Historical Query Language. </title> <editor> In A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass, editors, </editor> <title> Temporal Databases: Theory, Design, and Implementation. </title> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper, we bring together two research directions in temporal databases. The first direction is concerned with temporal extensions to calculus-based query languages such as SQL (e.g., <ref> [GN93, NA93, Sar93] </ref>). The issues addressed include space-efficient storage, effective implementation techniques, and handling large amounts of data. This approach includes the consensus temporal query language TSQL2 [Sno95], whose practical implementations should be forthcoming.
Reference: [Sno87] <author> R. T. Snodgrass. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: In temporal databases we do not want to construct and store all the states explicitly. Instead, various proposals have associated with each fact a concise description of the set of points over which the fact holds, such as a period 1 <ref> [NA93, Sar90, Sno87, Tan86] </ref> or a finite union of periods 1 We use the term `period' in this paper rather than the term `interval' commonly [CC87, Gad88, Sno95]. <p> A valid clause, which can be placed in front of queries. 5 It is to specify whether a query expression should be evaluated with temporal semantics (no valid clause) or with standard Codd semantics (valid clause). Intuitively, temporal semantics corresponds to snapshot reducibility <ref> [Sno87] </ref> which means that, conceptually, the respective query is evaluated over every 4 These features are briefly discussed where used the first time. 5 The same syntactic extension is allowed for queries in the FROM clause defining a derived table.
Reference: [Sno95] <author> R. T. Snodgrass, </author> <title> editor. The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> 674+xxiv pages, </address> <year> 1995. </year>
Reference-contexts: The first direction is concerned with temporal extensions to calculus-based query languages such as SQL (e.g., [GN93, NA93, Sar93]). The issues addressed include space-efficient storage, effective implementation techniques, and handling large amounts of data. This approach includes the consensus temporal query language TSQL2 <ref> [Sno95] </ref>, whose practical implementations should be forthcoming. The second direction is concerned with defining high-level query languages with logical semantics, e.g., temporal logic [TC90, GM91, CCT94]. The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. <p> various proposals have associated with each fact a concise description of the set of points over which the fact holds, such as a period 1 [NA93, Sar90, Sno87, Tan86] or a finite union of periods 1 We use the term `period' in this paper rather than the term `interval' commonly <ref> [CC87, Gad88, Sno95] </ref>. We show here how to translate temporal logic queries into TSQL2, enabling the user to write high-level queries which will be evaluated against a space-efficient representation of the database. <p> However, the state-based semantics of temporal logic does not suggest an efficient implementation of such queries. A period-based implementation, in which the period over which each fact was valid is used directly in the evaluation, promises much faster execution. 2.2 TSQL2 TSQL2 <ref> [Sno95] </ref> is the consensus temporal extension of SQL-92 and, therefore, we use it as our target database query language when translating temporal logic. A valid-time relation is a relation where tuples are implicitly timestamped with periods 3 . Example 5.
Reference: [SW95] <author> A.P. Sistla and O. Wolfson. </author> <title> Temporal Triggers in Active Databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(3) </volume> <pages> 471-486, </pages> <month> June, </month> <year> 1995. </year>
Reference-contexts: The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible [CT95]. For instance, temporal logic has been proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to sequences of database states [GHR94]. In temporal databases we do not want to construct and store all the states explicitly.
Reference: [Tan86] <author> A. U. Tansel. </author> <title> Adding time dimension to relational model and extending relational algebra. </title> <journal> Information Systems, </journal> <volume> 11(4) </volume> <pages> 343-355, </pages> <year> 1986. </year>
Reference-contexts: In temporal databases we do not want to construct and store all the states explicitly. Instead, various proposals have associated with each fact a concise description of the set of points over which the fact holds, such as a period 1 <ref> [NA93, Sar90, Sno87, Tan86] </ref> or a finite union of periods 1 We use the term `period' in this paper rather than the term `interval' commonly [CC87, Gad88, Sno95].
Reference: [Tom95] <author> D. Toman. </author> <title> Point-based vs. Interval-based Temporal Query Languages. </title> <institution> TR-CS-95-15, Kansas State University, </institution> <year> 1995. </year>
Reference-contexts: The requirement of maximal periods is more fundamental. In fact, allowing noncoalesced periods calls for a temporal logic that is not point- but period-based <ref> [Tom95] </ref>. Thus in this case, there can be no translation from full TSQL2 to the temporal logic discussed in this paper, even for local queries. The restriction to local queries is also critical. <p> The restriction to local queries is also critical. Pure TSQL2 has the same expressive power as two-sorted first-order logic in which there is a separate sort for time <ref> [Tom95] </ref>. It has been recently shown [AHVdB95, TN96] that temporal logic is strictly less expressive than the above two-sorted logic.
Reference: [TN96] <author> D. Toman and D. Niwinski. </author> <title> First-Order Temporal Queries Inexpressible in Temporal Logic. </title> <note> Proc. EDBT'96 (to appear), </note> <year> 1996. </year>
Reference-contexts: The restriction to local queries is also critical. Pure TSQL2 has the same expressive power as two-sorted first-order logic in which there is a separate sort for time [Tom95]. It has been recently shown <ref> [AHVdB95, TN96] </ref> that temporal logic is strictly less expressive than the above two-sorted logic. Thus, there can be no translation from TSQL2 to temporal logic that works for all pure queries. 5 Summary We have established an exact correspondence between temporal logic and a syntactically defined subset of TSQL2.
Reference: [TC90] <author> A. Tuzhilin and J. Clifford. </author> <title> A Temporal Relational Algebra as a Basis for Temporal Relational Completeness. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1990. </year>
Reference-contexts: The issues addressed include space-efficient storage, effective implementation techniques, and handling large amounts of data. This approach includes the consensus temporal query language TSQL2 [Sno95], whose practical implementations should be forthcoming. The second direction is concerned with defining high-level query languages with logical semantics, e.g., temporal logic <ref> [TC90, GM91, CCT94] </ref>. The advantages of using logic languages come from their well-understood mathematical properties [GHR94]. Logic languages are easy to use and make algebraic query transformation possible [CT95].
Reference: [VGT91] <author> A. Van Gelder and R.W. Topor. </author> <title> Safety and Translation of Relational Calculus Queries. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 16(2) </volume> <pages> 235-278, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: We show here how to translate temporal logic queries into TSQL2, enabling the user to write high-level queries which will be evaluated against a space-efficient representation of the database. While translations of first order logic to SQL have been previously discussed <ref> [AHV95, VGT91] </ref>, we know of no translations from temporal logic to a temporal query language. We start with a discussion of the basic framework in Section 2. We define the syntax and semantics of the two languages in question, temporal logic and TSQL2. <p> The previous observations are used to define the translation of temporal logic formulas to TSQL2 and prove its correctness. The translation uses an extension of existing methods for translating first-order logic formulas to SQL-92, e.g., <ref> [VGT91, AHV95, Wut91] </ref> as one of its steps. We also give a syntactic criterion for identifying (a subset of) domain independent formulas of temporal logic. 3.1 Temporal Logic to TSQL2 Translation The translation of temporal logic formulas to TSQL2 is defined by induction on the structure of the formula. <p> Finally, we assume here that the valid-time is at a granularity of a year. Thus +1 is shorthand for +INTERVAL '1' YEAR and -1 for -INTERVAL '1' YEAR. Mapping of first-order (sub-)formulas. The mapping of first-order formu-las to relational algebra has been described in several papers and books, e.g., <ref> [VGT91, AHV95] </ref>. As our target language is (T)SQL2 rather than relational algebra, we map maximal first-order subformulas to directly to SQL [Wut91], thereby exploiting the syntactic features of the latter and achieving efficient SQL queries. 3.2 Domain independence Similarly to the first-order case [VGT91, AHV95], not all formulas expressible in temporal <p> described in several papers and books, e.g., <ref> [VGT91, AHV95] </ref>. As our target language is (T)SQL2 rather than relational algebra, we map maximal first-order subformulas to directly to SQL [Wut91], thereby exploiting the syntactic features of the latter and achieving efficient SQL queries. 3.2 Domain independence Similarly to the first-order case [VGT91, AHV95], not all formulas expressible in temporal logic are domain-independent. We identify (a subset of) the domain-independent formulas of temporal logic using an extension of the syntactic criteria defined for first-order formulas. Proposition 4. Let ' be a temporal formula and Alwd be a domain-independence criterion for first-order formulas.
Reference: [Wut91] <author> B. Wuthrich. </author> <title> Large Deductive Databases with Constraints. </title> <type> PhD thesis, </type> <institution> Department Informatik, ETH Zurich, </institution> <year> 1991. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The previous observations are used to define the translation of temporal logic formulas to TSQL2 and prove its correctness. The translation uses an extension of existing methods for translating first-order logic formulas to SQL-92, e.g., <ref> [VGT91, AHV95, Wut91] </ref> as one of its steps. We also give a syntactic criterion for identifying (a subset of) domain independent formulas of temporal logic. 3.1 Temporal Logic to TSQL2 Translation The translation of temporal logic formulas to TSQL2 is defined by induction on the structure of the formula. <p> Mapping of first-order (sub-)formulas. The mapping of first-order formu-las to relational algebra has been described in several papers and books, e.g., [VGT91, AHV95]. As our target language is (T)SQL2 rather than relational algebra, we map maximal first-order subformulas to directly to SQL <ref> [Wut91] </ref>, thereby exploiting the syntactic features of the latter and achieving efficient SQL queries. 3.2 Domain independence Similarly to the first-order case [VGT91, AHV95], not all formulas expressible in temporal logic are domain-independent.
References-found: 32

