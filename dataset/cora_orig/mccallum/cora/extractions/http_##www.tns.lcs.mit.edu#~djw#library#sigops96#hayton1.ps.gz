URL: http://www.tns.lcs.mit.edu/~djw/library/sigops96/hayton1.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/sigops96/index.html
Root-URL: 
Title: Using Events to Build Large Scale Distributed Applications notified. Alternative approaches lead to polling, mining
Author: Richard Hayton, Jean Bacon, John Bates and Ken Moody 
Note: The approach is inherently scalable in that only events in which an interest has been registered are  
Address: Pembroke Street, Cambridge CB2 3QG, United Kingdom  
Affiliation: University of Cambridge Computer Laboratory  
Abstract: We have extended an Interface Definition Language to handle event registration and notification. Clients register interest in specified classes of events, and servers then notify them of any occurrence asynchronously. Event occurrences are identified by parameters which conform to IDL typing constraints and can therefore be used in synchronous method invocations. Methods to handle registration and notification are generic and can be inherited by objects of any class: as a by-product of IDL processing the stubs to handle event creation and decoding are generated automatically. We have implemented a prototype composite event recogniser based on nested finite state machines and have defined an event algebra and language to specify composite events. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and specification. </title> <type> Technical Report 91.9.1, </type> <institution> Object Management Group, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Current OODP technology is based on objects with typed interfaces together with support for providers to advertise them, and for users to locate and invoke them <ref> [1, 2] </ref>. This object-orientated paradigm is well established but does not capture fully the dynamic, event-driven behaviour of many systems. Some "active" objects monitor continuously for specific occurrences and may then notify interested clients asynchronously.
Reference: [2] <institution> Architecture Projects Management Limited Advanced Networked Systems Architecture Testbench Implementation Manual, </institution> <year> 1993. </year>
Reference-contexts: Current OODP technology is based on objects with typed interfaces together with support for providers to advertise them, and for users to locate and invoke them <ref> [1, 2] </ref>. This object-orientated paradigm is well established but does not capture fully the dynamic, event-driven behaviour of many systems. Some "active" objects monitor continuously for specific occurrences and may then notify interested clients asynchronously.
Reference: [3] <author> R. Hayton and K. Moody, </author> <title> An Open Architecture for Secure Interworking Services, </title> <booktitle> ACM SIGOPS European Workshop, </booktitle> <month> September 96. </month>
Reference-contexts: We outline the design of a composite event language in section 4. 1 The security architecture is described in another paper at this workshop <ref> [3] </ref>, and a description of the event extensions can be found in [4, chapter 7]. void print_document (Printer *p, char *filename) - int jobno; Event *e; jobno = p-&gt;Print (filename); e = new Printer_Finished ("",jobno); p-&gt;Register (e,(void*) filename); - void Printer_Proxy::Finished (Printer_Finished *e, void *state) - int jobno; char *filename = <p> For example, in the badge system we may wish to detect sightings of two users Giles and Roger, in order to detect if Giles ever enters a room in which Roger is situated. This could be represented by the expression 2 Described in the companion paper <ref> [3] </ref> Whenever Seen (Roger,x) Repeat If Seen (Giles,x) then Signal Together (x) Until Seen (Roger,y) Consider the situation in which Roger and Giles are first seen in room T14, and then seen in room T15.
Reference: [4] <author> R. Hayton, OASIS, </author> <title> An Open Architecture for Secure Interworking Services, University of Cambridge PhD thesis March 1996, </title> <type> Technical Report TR399. </type>
Reference-contexts: We outline the design of a composite event language in section 4. 1 The security architecture is described in another paper at this workshop [3], and a description of the event extensions can be found in <ref> [4, chapter 7] </ref>. void print_document (Printer *p, char *filename) - int jobno; Event *e; jobno = p-&gt;Print (filename); e = new Printer_Finished ("",jobno); p-&gt;Register (e,(void*) filename); - void Printer_Proxy::Finished (Printer_Finished *e, void *state) - int jobno; char *filename = (char*) state; jobno = event-&gt;jobno (); printf ("File %s (job %d) has <p> our language require only pairwise comparison of (some) event time stamps, and this lesser requirement is easier to justify in a wide-area environment where clocks are not completely synchronised. 4 A Composite Event Language A composite event specification language based on modifications to regular expressions is given in detail in <ref> [4] </ref>. It is of equal expressive power to regular expressions, but has the advantages of clarity and use of parameters. In addition it has an efficient evaluation machine and may easily be extended to deal with operational criteria, such as network delay, that might lead to the misordering of events.
Reference: [5] <author> S. Gatziu and K.R. Dittrich. </author> <title> Detecting composite events in active database systems using Petri nets. </title> <booktitle> In Proceedings of the 4th International Conference on Research Issues in Data Engineering: Active Database Systems, </booktitle> <address> Houston, Texas, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: Monitoring applications are generally interested in particular sequences of events, rather than the occurrence of a single event. Although each application could be designed in an ad-hoc manner, it is advantageous to design a general purpose composite event recogniser. There are several existing architectures for composite event recognition <ref> [5, 6] </ref>, but these were designed for centralised event systems and are unsuitable for distributed event recognition.
Reference: [6] <author> N.H. Gehani, H.V. Jagadish, and O. Shmueli. </author> <title> Composite event specification in active databases: Model & imple-mentation. </title> <booktitle> In Proceedings of the 18th VLDB Conference, </booktitle> <address> Vancouver, British Columbia, Canada, </address> <year> 1992. </year>
Reference-contexts: Monitoring applications are generally interested in particular sequences of events, rather than the occurrence of a single event. Although each application could be designed in an ad-hoc manner, it is advantageous to design a general purpose composite event recogniser. There are several existing architectures for composite event recognition <ref> [5, 6] </ref>, but these were designed for centralised event systems and are unsuitable for distributed event recognition.
References-found: 6

