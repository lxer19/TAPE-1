URL: http://www.irisa.fr/EXTERNE/projet/lande/consel/papers/planp-bridge.ps.gz
Refering-URL: http://www.cs.washington.edu/research/projects/unisw/DynComp/www/Related/papers.html
Root-URL: 
Email: fsthibaul,consel,mullerg@irisa.fr  
Title: Safe and Efficient Active Network Programming incorporating programmability into the network to achieve extensibility. An
Author: Scott Thibault, Charles Consel, and Gilles Muller 
Note: Active networks are aimed at  
Date: February 11, 1998  
Web: http://www.irisa.fr/compose  
Address: 35042 Rennes cedex, France  
Affiliation: IRISA INRIA Universite de Rennes 1 Campus universitaire de Beaulieu  
Abstract: IRISA/INRIA Technical Report 1170 Abstract This paper makes contributions to all three issues above. Expressiveness. We have extended PLAN, an active network language for diagnostics, so that the language can express application protocols. These extensions are illustrated with two protocols: adaptive compression and active bridging. Safety and security. To address these critical aspects, we give examples of properties of PLAN programs that can be automatically checked due to the use of a restricted language. Efficiency. We show that an automatically generated run-time compiler for PLAN and our extensions produces code with similar performance to an equivalent compiled Java program. Measurements are presented for an active bridge.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Scott Alexander, Marianne Shaw, Scott M. Nettles, and Jonathan M. Smith. </author> <title> Active bridging. </title> <booktitle> In Proceedings of the 1997 SIGCOMM Conference. </booktitle> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: That is, it can specialize a program with respect to values which are not available until run-time. As discussed in section 5, our experiments show that the PLAN-P interpreter specialized with respect to a learning bridge program <ref> [1] </ref> achieves up to 85% of the throughput obtained with an equivalent bridge written in C. More importantly, we implemented a bridge in Java to assess the performance of a highly-portable language. We compiled this bridge with an optimizing off-line Java compiler [7] to get the best possible performance. <p> We compiled this bridge with an optimizing off-line Java compiler [7] to get the best possible performance. When compared to our specialized PLAN-P interpreter, the compiled Java bridge has similar performance. In comparison to results on the Pentium architecture presented by Alexander et al. <ref> [1] </ref>, we achieve twice as much throughput. These performance measurements demonstrate that program specialization is a key technology to enable simultaneously late checking of source programs and efficiency. Furthermore, efficiency is obtained without sacrificing portability since an interpreter is used to implement our extension of PLAN. <p> A learning bridge keeps track of where packets come from in order to determine which LAN a host is connected to, so that packets for that host are only repeated on the LAN it is on. al. <ref> [1] </ref>. This example uses the predefined channel system to modify the behavior of an existing protocol. Packet processing for system channels is as follows. <p> We take as an example the active bridge. A bridge is a node which connects two or more LANs together to form an extended LAN. In our experiment, we implement the learning algorithm described by Alexander et al. <ref> [1] </ref>. The learning algorithm uses a hash table to record the source address and the LAN of received packets 3 , thus learning which hosts are on which LANs rather than repeating packets on all LANs. <p> The average loss of throughput for packets of 256 bytes and larger is 6.3Mbps with respect to the learning bridge written in C. Packets of 1024 bytes have a throughput of 3450 frames per second. In comparison to results on the Pentium architecture presented by Alexander et al. <ref> [1] </ref>, we achieve twice as much throughput. The following table compares our results with the results of Alexander.
Reference: [2] <author> C. Consel, L. Hornof, J. Lawall, R. Marlet, G. Muller, J. Noye, S. Thibault, and N. Volanschi. Tempo: </author> <title> Specializing systems applications and beyond. </title> <booktitle> ACM Computing Surveys, Symposium on Partial Evaluation, </booktitle> <year> 1998. </year> <note> To appear. 12 </note>
Reference-contexts: Because the program is bound late, a run-time form of program specialization is used. Our approach relies on a program specializer for C called Tempo <ref> [2] </ref>. Unlike other existing program specializers, Tempo is not limited to specializing programs at compile time; it is also capable of specializing programs at run-time. That is, it can specialize a program with respect to values which are not available until run-time. <p> It performs specialization both at compile time and at run time <ref> [2, 3, 6] </ref> It has been successfully used for various applications ranging from systems programs to scientific code [2]. For example, Tempo has been applied to the XDR layer of the SUN Remote Procedure Call (RPC). <p> It performs specialization both at compile time and at run time [2, 3, 6] It has been successfully used for various applications ranging from systems programs to scientific code <ref> [2] </ref>. For example, Tempo has been applied to the XDR layer of the SUN Remote Procedure Call (RPC). The specialized version of the RPC is up to 3.5 times faster than the original XDR layer and up to 1.5 times faster than the original RPC for a round-trip [8, 6].
Reference: [3] <author> C. Consel, L. Hornof, F. Noel, J. </author> <title> Noye, and E.N. Volanschi. A uniform approach for compile-time and run-time specialization. </title> <editor> In O. Danvy, R. Gluck, and P. Thiemann, editors, </editor> <title> Partial Evaluation, </title> <booktitle> International Seminar, Dagstuhl Castle, number 1110 in LNCS, </booktitle> <pages> pages 54-72, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: It performs specialization both at compile time and at run time <ref> [2, 3, 6] </ref> It has been successfully used for various applications ranging from systems programs to scientific code [2]. For example, Tempo has been applied to the XDR layer of the SUN Remote Procedure Call (RPC).
Reference: [4] <author> C. Consel and F. Noel. </author> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In Conference Record of the 23 rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 145-156, </pages> <address> St. Petersburg Beach, FL, USA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: This transformation results in performing all the operations which depend on the program argument of the interpreter. Traditionally, program specialization is performed at compile time. However, Consel and Noel extended this technique to allow programs to be specialized at run time <ref> [4] </ref>. In their approach, given a program and a description of the known inputs (not the actual values), templates which represent the building blocks of all possible specialized programs, are automatically generated.
Reference: [5] <author> Michael Hicks, Pankaj Kakkar, and Jonathan T Moore. </author> <title> Plan: A programming language for active networks. </title> <type> Technical report, </type> <institution> University of Pennsylvania. </institution>
Reference-contexts: In fact, most existing approaches to active networks are based on DSLs. An example of such a DSL, of particular interest for the present work, is PLAN <ref> [5] </ref>. This language is concerned with programming network routers for diagnostics. Safety and security are achieved by restricting the semantics of the language: it is a first-order, strict functional language | essentially a subset of ML [5]. <p> example of such a DSL, of particular interest for the present work, is PLAN <ref> [5] </ref>. This language is concerned with programming network routers for diagnostics. Safety and security are achieved by restricting the semantics of the language: it is a first-order, strict functional language | essentially a subset of ML [5]. To achieve flexibility, the primary motivation of active networks, PLAN is defined in two levels: first, a PLAN program represents the glue between coarse-grained operations, called services; second, services are node-resident primitives which are intended to be written in a general-purpose language. <p> Safety and security. The restrictions of PLAN, combined with its two-level implementation (program and services), has proved to ensure important safety and security properties. Other safety and security issues still need to be addressed such as global termination and packet duplication. Efficiency. As noted by Hicks et al. <ref> [5] </ref>, the performance of PLAN processing needs to be improved. The authors mention the fundamental conflict between sending the PLAN source program to nodes to allow them to do defensive checking for safety and security reasons, and sending lower-level representations making defensive checking difficult, if not impossible. <p> This paper makes contributions to all the challenges listed above. PLAN-P: an extension for application protocols. The first contribution of this paper aims at broadening the applicability of PLAN. Indeed, this language, as described in <ref> [5] </ref>, mainly targets diagnostic network applications. We have extended the language to make it possible to express protocols. More precisely, we introduce the concepts of packets as first-class objects, persistent state, and channels in response to specific needs of protocol development. Strengthening safety and security in PLAN. <p> Furthermore, techniques to overcome security problems often merely transform the problem to be one of safety. For example, a resource bound, like the time-to-live field of IP or that of PLAN <ref> [5] </ref>, solve the security problem of packets infinitely looping and consuming resources, but transforms it into one of safety: packets may be unintentionally terminated. PLAN and PLAN-P are examples that demonstrate how DSLs can provide programmability while at the same time satisfying security and safety demands. <p> Recursive calls, however, are allowed for remote calls and thus, a packet may cycle forever on the network. One solution to this problem is to introduce a resource bound which is decremented on each hop as the time-to-live field of IP <ref> [5] </ref>. This is not entirely satisfying because it introduces a safety problem of unintended program termination. However, by making an assumption that the IP routing tables do not contain cycles, we can use the knowledge about the domain to prove that PLAN (-P) programs do not cycle. <p> As a result, a representation close to the source program must be used. This constraint naturally suggests the use of an interpreter to run programs. In fact, this is the approach used for PLAN where the interpreter is written in Java to ease portability <ref> [5] </ref>. However, as noted by Hicks et al. [5], this double layer of interpretation calls for performance improvement. Our approach to address this critical issue is to use program specialization. This program transformation is aimed at specializing an interpreter with respect to a given PLAN-P program. <p> This constraint naturally suggests the use of an interpreter to run programs. In fact, this is the approach used for PLAN where the interpreter is written in Java to ease portability <ref> [5] </ref>. However, as noted by Hicks et al. [5], this double layer of interpretation calls for performance improvement. Our approach to address this critical issue is to use program specialization. This program transformation is aimed at specializing an interpreter with respect to a given PLAN-P program.
Reference: [6] <author> G. Muller, R. Marlet, E.N. Volanschi, C. Consel, C. Pu, and A. Goel. </author> <title> Fast, optimized Sun RPC using automatic program specialization. </title> <booktitle> In Proceedings of the 18th International Conference on Distributed Computing Systems, </booktitle> <address> Amsterdam, The Netherlands, May 1998. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The templates and run-time specializer are compiled and linked prior to run-time. The template approach uses existing compilers for portability. Noel et al. demonstrate the low cost of run-time specialization and the efficiency of the run-time specialized code on various scientific and graphics programs <ref> [6] </ref>. <p> It performs specialization both at compile time and at run time <ref> [2, 3, 6] </ref> It has been successfully used for various applications ranging from systems programs to scientific code [2]. For example, Tempo has been applied to the XDR layer of the SUN Remote Procedure Call (RPC). <p> For example, Tempo has been applied to the XDR layer of the SUN Remote Procedure Call (RPC). The specialized version of the RPC is up to 3.5 times faster than the original XDR layer and up to 1.5 times faster than the original RPC for a round-trip <ref> [8, 6] </ref>. Tempo operates on both the SPARC and Pentium architectures under Solaris and Linux. It is critical that Tempo allows programs to be specialized at run time in order to enable late program 8 checking.
Reference: [7] <author> G. Muller, B. Moura, F. Bellard, and C. Consel. Harissa: </author> <title> A flexible and efficient Java environment mixing bytecode and compiled code. </title> <booktitle> In Proceedings of the 3rd Conference on Object-Oriented Technologies and Systems, </booktitle> <pages> pages 1-20, </pages> <address> Portland (Oregon), USA, June 1997. </address> <publisher> Usenix. </publisher>
Reference-contexts: More importantly, we implemented a bridge in Java to assess the performance of a highly-portable language. We compiled this bridge with an optimizing off-line Java compiler <ref> [7] </ref> to get the best possible performance. When compared to our specialized PLAN-P interpreter, the compiled Java bridge has similar performance. In comparison to results on the Pentium architecture presented by Alexander et al. [1], we achieve twice as much throughput. <p> The C version represents the upper bound of the performance one could obtain with the particular algorithm used. The Java version was compiled using Harissa, an off-line optimizing Java compiler <ref> [7] </ref>. It represents the upper bound of the performance of the Java/JIT approach to mobile code.
Reference: [8] <author> G. Muller, E.N. Volanschi, and R. Marlet. </author> <title> Scaling up partial evaluation for optimizing the Sun commercial RPC protocol. </title> <booktitle> In ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 116-125. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: For example, Tempo has been applied to the XDR layer of the SUN Remote Procedure Call (RPC). The specialized version of the RPC is up to 3.5 times faster than the original XDR layer and up to 1.5 times faster than the original RPC for a round-trip <ref> [8, 6] </ref>. Tempo operates on both the SPARC and Pentium architectures under Solaris and Linux. It is critical that Tempo allows programs to be specialized at run time in order to enable late program 8 checking.
Reference: [9] <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Conference Record of the 24 th Symposium on Principles Of Programming Languages, </booktitle> <pages> pages 106-116, </pages> <address> Paris, France, </address> <month> January </month> <year> 1997. </year> <note> ACM Press. </note>
Reference-contexts: As a result, it is safer to confine programs written in a language such as Java to the service level rather than using it as a "glue" language. An alternative to the late program checking approach is proof-carrying code (PCC) <ref> [9, 10] </ref>. PCC consists of sending together with a program (possibly in binary form) the proof of some property. As a result, a code receiver can accept code from an untrusted producer provided its proof can be validated.
Reference: [10] <author> G. Necula and Peter Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In ACM SIGSOFT Second Symposium on Operating Systems Design and Implementation, </booktitle> <address> Seattle, Washington, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: As a result, it is safer to confine programs written in a language such as Java to the service level rather than using it as a "glue" language. An alternative to the late program checking approach is proof-carrying code (PCC) <ref> [9, 10] </ref>. PCC consists of sending together with a program (possibly in binary form) the proof of some property. As a result, a code receiver can accept code from an untrusted producer provided its proof can be validated.
Reference: [11] <author> M. Poletto, D. Engler, and M. Frans Kaashoek. tcc: </author> <title> A system for fast, flexible, and high-level dynamic code generation. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 109-121, </pages> <address> Las Vegas, Nevada, June 1997. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Yet, this property checking can be a fast process (e.g., syntactic) if the language has been appropriately defined. Run-time specialization can be seen as an automatic approach to dynamic code generation. Poletto et al. propose a manual approach to dynamic code generation <ref> [11] </ref>. To do so, they extend the C programming language with constructs and types which allow the programmer to directly express the computations which construct program fragments dynamically.
Reference: [12] <author> D. Tennenhouse, J. Smith, W. Sincoskie, D. Wetherall, and G. Minden. </author> <title> A survey of active network research. </title> <journal> IEEE Communications Magazine, </journal> <volume> 35(1) </volume> <pages> 80-86, </pages> <month> jan </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Active networks <ref> [12] </ref> enable rapid network evolution by making routers programmable. Programs can be downloaded into network routers to control the processing of packets. A router program can be associated to a packet, an application or some other entity. As a result, the network becomes flexible and can adapt to specific needs. <p> As a result, the network becomes flexible and can adapt to specific needs. Also, it is extensible since new functionalities can be introduced dynamically. The introduction of highly-programmable networks, however, raises a number of issues <ref> [12] </ref>. First, safety and security should be ensured because network routers are shared resources. Second, given the heterogeneity of the network, the module executing router programs should be highly portable. <p> A disadvantage of this approach, however, is that it introduces additional security risks <ref> [12] </ref>. Security is particularly important in the context of active networks because the system is shared by many users and the users are typically not the owner of the network. In addition to security, we are also interested in the safety of active network programs.
Reference: [13] <author> Scott Thibault and Charles Consel. </author> <title> A framework for application generator design. </title> <booktitle> In Proceedings of the Symposium on Software Reusability, </booktitle> <address> Boston, MA, USA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: These advantages are important since DSLs evolve frequently, and the network is heterogeneous. 4.3 The PLAN-P interpreter The structure of the interpreter for PLAN-P follows the methodology defined by Thibault and Consel <ref> [13] </ref>. It consists of dividing the interpreter into two parts: the top part is concerned with operations dependent on the input program whereas the bottom part includes operations dependent on the program's input values.
Reference: [14] <author> Scott Thibault, Renaud Marlet, and Charles Consel. </author> <title> A domain-specific language for video device driver: from design to implementation. </title> <booktitle> In Proceedings of the 1st USENIX Conference on Domain-Specific Languages, </booktitle> <address> Santa Barbara, California, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: Assuming the program to be known at specialization time, the top part of the interpreter is eliminated (the interpretation layer) whereas the bottom part (the dynamic computations) remains. Thibault, Marlet, and Consel successfully applied their approach to the automatic generation of efficient video device drivers <ref> [14] </ref>. One of the advantages of dividing an interpreter into two parts is to clearly identify a priori the interpretation layer and the dynamic computations. This division is then checked by Tempo's dependency analysis which propagates the description of the known inputs and visually displays the results.
Reference: [15] <author> D. Wetherall and D. Tennenhouse. </author> <title> The ACTIVE IP Option. </title> <booktitle> In 7th ACM SIGOPS European Workshop, </booktitle> <address> Connemara, Ireland, </address> <year> 1996. </year>
Reference-contexts: Thus, multi-channel protocols, like the compression example, define a new protocol with an extended packet type. The local execution of a protocol is as follows. The protocol is identified by a unique key stored in the IP header as an IP option as described by Wetherall and Tennenhouse <ref> [15] </ref>. The implicit state of the packet, identifying the channel it belongs to, is extracted from the packet and the corresponding function is invoked with the current state (protocol and channel) and the packet as arguments. The returned value is used to update the current state and processing is complete. <p> Platform Direct C-Repeater Active bridge 8k bytes Throughput Throughput packets A B C Alexander-97 Pentium-166 76Mb/s 36.6Mb/s 16Mb/s 44% of A 43% of B PLAN-P Sun Ultra 170 73.7Mb/s 42.9Mb/s 35.6Mb/s 58% of A 82% of B 6 Related Work An Active Network node was developed by Wetherall and Tennenhouse <ref> [15] </ref> based on a TCL interpreter. The emphasis of this work was the validation of the idea. The most related work to PLAN-P is naturally the PLAN project.
Reference: [16] <author> David J. Wetherall, John Guttag, and David L. Tennenhouse. </author> <title> ANTS: A toolkit for building and dynamically deploying network protocols. </title> <booktitle> In IEEE OPENARCH, </booktitle> <month> April </month> <year> 1998. </year>
Reference-contexts: Java is used to develop protocols for active nodes in the Active Network Transfer System project <ref> [16] </ref>; a toolkit has been developed for the deployment of protocols. As for any general-purpose language, strong properties like termination cannot be ensured about programs.
References-found: 16

