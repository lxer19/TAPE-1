URL: http://www.cs.rice.edu/CS/PLT/Publications/tr98-299.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Synthesizing Object-Oriented and Functional Design to Promote Re-Use  
Author: Shriram Krishnamurthi Matthias Felleisen Daniel P. Friedman 
Date: April 9, 1998  
Affiliation: Department of Computer Science Rice University  
Abstract: A preliminary version of this paper appeared in the European Conference on Object-Oriented Programming, 1998 Abstract Many problems require recursively specified types of data and a collection of tools that operate on those data. Over time, these problems evolve so that the programmer must extend the toolkit or extend the types and adjust the existing tools accordingly. Ideally, this should be done without modifying existing code. Unfortunately, the prevailing program design strategies do not support both forms of extensibility: functional programming accommodates the addition of tools, while object-oriented programming supports either adding new tools or extending the data set, but not both. In this paper, we present a composite design pattern that synthesizes the best of both approaches and in the process resolves the tension between the two design strategies. We also show how this protocol suggests a new set of linguistic facilities for languages that support class systems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Baumgartner, G., K. Laufer and V. F. Russo. </author> <title> On the interaction of object-oriented design patterns and programming languages. </title> <type> Technical Report CSD-TR-96-020, </type> <institution> Purdue University, </institution> <month> Feburary </month> <year> 1996. </year>
Reference-contexts: The literature on design patterns contains many other attempts to define and implement patterns similar to Interpreter and Visitor. The primary presentation of the Visitor pattern [13] states that datatype extension is difficult, but does not solve the problems that arise. Baumgartner, Laufer and Russo <ref> [1] </ref> propose an implementation of Visitor based on multi-method dispatch and claim that it makes datatype and toolkit extension easy, but they do not recognize the problems that arise when extending tools or coordinating multiple tools.
Reference: [2] <author> Cartwright, R. S. and M. Felleisen. </author> <title> Extensible denotational language specifications. </title> <editor> In Hagiya, M. and J. C. Mitchell, editors, </editor> <booktitle> Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 244-272. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year> <note> LNCS 789. </note>
Reference-contexts: In such cases, a more sophisticated protocol is necessary, such as that specified by Cartwright and Felleisen <ref> [2] </ref>. 4 The Composite pattern [13] is sometimes used instead. 4 abstract class Shape f Shape shrink (double pct ); g class extends Shape f double s; (double s) f this.s = s ; g boolean containsPt (Point p) f g g class fl extends Shape f double r ; fl <p> We can alternatively view the variants of a datatype as specifying the terms of a language, and interpreters as tools. The functional language community has been interested in the problem of creating interpreters from fragments that interpret portions of the language <ref> [2, 8, 19, 30] </ref>. These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them [2, 8, 30] do not address the problem of extending the datatype either. <p> These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them <ref> [2, 8, 30] </ref> do not address the problem of extending the datatype either. Duggan and Sourelis [6], Findler [10], and Liang, Hudak, and Jones [19] describe methods for creating restricted notions of extensible datatypes. None of these approaches, however, produce datatypes that are extensible in the sense of our protocol. <p> As a result, it is not possible to extend the variants of an existing datatype. Any further additions require access to the source code. Cartwright and Felleisen's work on extensible interpreters <ref> [2] </ref>, if translated into an object-oriented framework, would probably resemble the Extensible Visitor protocol in an untyped setting. 8 Conclusions and Future Work We have presented a programming protocol, Extensible Visitor, that can be used to construct systems with extensible recursive data domains and toolkits.
Reference: [3] <editor> Clinger, W. and J. Rees. </editor> <title> The revised 4 report on the algorithmic language Scheme. </title> <journal> ACM Lisp Pointers, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: Zodiac expands the Extensible Visitor specification into a collection of classes and interfaces that is ff-equivalent to the code in Sect. 3. 6 Implementation and Performance Zodiac is currently implemented as a language extension to MzScheme [12], a version of Scheme <ref> [3] </ref> extended with a Java-like object system. A preliminary version of Zodiac has been used to implement DrScheme, a Scheme programming environment [11]. DrScheme is a pedagogically-motivated system that helps beginners by presenting Scheme as a succession of increasingly complex languages.
Reference: [4] <author> Cook, W. R. </author> <title> Object-oriented programming versus abstract data types. </title> <booktitle> In Foundations of Object-Oriented Languages, </booktitle> <pages> pages 151-178, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: We discuss both the functional and the object-oriented design methods in this context and expose their failings. 1 Cook <ref> [4] </ref> devotes his tutorial to this problem, which was first anticipated by Reynolds [27]. 2 datatype Shape = of num j fl of num j ; of Point fi Shape ContainsPt : Point fi Shape ! boolean ContainsPt p ( s) = j p (fl r ) = j p ( <p> The overall cost of this indirection depends on how often an application constructs data, and on the implementation model used for objects and methods. In our experience, this cost has been negligible. 7 Background and Related Work Several researchers, including Cook <ref> [4] </ref>, Kuhne [18], Palsberg and Jay [23], and Remy [26], have observed the trade-offs between the functional and object-oriented design approaches, and have noted the relative strengths and weaknesses of each method at datatype and toolkit extension. Of them, only Kuhne [18] and Palsberg and Jay [23] suggest a solution.
Reference: [5] <author> Coplien, J. O. and D. C. Schmidt, </author> <title> editors. Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference: [6] <author> Duggan, D. and C. Sourelis. </author> <title> Mixin modules. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 262-273, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Unfortunately, it is impossible to add a variant to Shape without modifying existing code. First, the datatype representing shapes must be modified because most existing functional languages do not offer an extensible datatype mechanism at all or do so in a restricted manner <ref> [6, 19, 20] </ref>. <p> These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them [2, 8, 30] do not address the problem of extending the datatype either. Duggan and Sourelis <ref> [6] </ref>, Findler [10], and Liang, Hudak, and Jones [19] describe methods for creating restricted notions of extensible datatypes. None of these approaches, however, produce datatypes that are extensible in the sense of our protocol.
Reference: [7] <author> Eifrig, J., S. Smith and V. Trifonov. </author> <title> Type inference for recursively constrained types and its application to OOP. </title> <booktitle> Mathematical Foundations of Program Semantics, </booktitle> <year> 1995. </year>
Reference-contexts: Also, the methods inside a processor need type declarations, even though the return type is the same as the parameter of the interface. A powerful type inference mechanism, such as those of Eifrig, Smith, and Trifonov <ref> [7] </ref> and Palsberg [22], can alleviate many of these problems, especially in the context of dynamically-typed object-oriented languages. 5 A Language for Extensible Systems Although the Extensible Visitor pattern solves our problem, it requires the management of numerous mundane details, such as writing class declarations to define the datatype and its
Reference: [8] <author> Espinosa, D. </author> <title> Building interpreters by transforming stratified monads. </title> <type> Unpublished manuscript, </type> <month> June </month> <year> 1994. </year>
Reference-contexts: We can alternatively view the variants of a datatype as specifying the terms of a language, and interpreters as tools. The functional language community has been interested in the problem of creating interpreters from fragments that interpret portions of the language <ref> [2, 8, 19, 30] </ref>. These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them [2, 8, 30] do not address the problem of extending the datatype either. <p> These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them <ref> [2, 8, 30] </ref> do not address the problem of extending the datatype either. Duggan and Sourelis [6], Findler [10], and Liang, Hudak, and Jones [19] describe methods for creating restricted notions of extensible datatypes. None of these approaches, however, produce datatypes that are extensible in the sense of our protocol.
Reference: [9] <author> Felleisen, M. and D. P. Friedman. </author> <title> A Little Java, A Few Patterns. </title> <publisher> MIT Press, </publisher> <year> 1998. </year> <month> 18 </month>
Reference-contexts: In the absence of a parametrically polymorphic type system, however, it is difficult to specify the types for the Visitor pattern. Section 4 discusses this issue in detail. 5 A preliminary version of this protocol appears in the book by Felleisen and Friedman <ref> [9] </ref>. 6 abstract class Shape f abstract hffi ff process (ShapeProcessorhffi p) ; g class extends Shape f double s; (double s) f this.s = s ; g hffi ff process (ShapeProcessorhffi p) f return p.forSquare (this) ; g g class fl extends Shape f double r ; fl (double r
Reference: [10] <author> Findler, R. B. </author> <title> Modular abstract interpreters. </title> <type> Unpublished manuscript, </type> <institution> Carnegie Mellon Uni--versity, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them [2, 8, 30] do not address the problem of extending the datatype either. Duggan and Sourelis [6], Findler <ref> [10] </ref>, and Liang, Hudak, and Jones [19] describe methods for creating restricted notions of extensible datatypes. None of these approaches, however, produce datatypes that are extensible in the sense of our protocol.
Reference: [11] <author> Findler, R. B., C. Flanagan, M. Flatt, S. Krishnamurthi and M. Felleisen. DrScheme: </author> <title> A pedagogic programming environment for Scheme. </title> <booktitle> In Ninth International Symposium on Programming Languages, Implementations, Logics, and Programs, </booktitle> <year> 1997. </year>
Reference-contexts: A preliminary version of Zodiac has been used to implement DrScheme, a Scheme programming environment <ref> [11] </ref>. DrScheme is a pedagogically-motivated system that helps beginners by presenting Scheme as a succession of increasingly complex languages. It also supports several tools such as a syntax checker, a program analyzer, etc. <p> We have also described Zodiac, a language extension for writing extensible programs. Zodiac manages the mundane and potentially error-prone administrative tasks that arise when implementing the Extensible Visitor. A variant of Zodiac has been in use for about two years in our programming environment DrScheme <ref> [11] </ref>. Through it, DrScheme is able to offer a hierarchy of language levels that facilitate a pedagogically sound introduction to programming. It supports multiple program-processing tools that operate over this range of language levels.
Reference: [12] <author> Flatt, M. PLT MzScheme: </author> <title> Language manual. </title> <type> Technical Report TR97-280, </type> <institution> Rice University, </institution> <year> 1997. </year>
Reference-contexts: Zodiac expands the Extensible Visitor specification into a collection of classes and interfaces that is ff-equivalent to the code in Sect. 3. 6 Implementation and Performance Zodiac is currently implemented as a language extension to MzScheme <ref> [12] </ref>, a version of Scheme [3] extended with a Java-like object system. A preliminary version of Zodiac has been used to implement DrScheme, a Scheme programming environment [11]. DrScheme is a pedagogically-motivated system that helps beginners by presenting Scheme as a succession of increasingly complex languages.
Reference: [13] <author> Gamma, E., R. Helm, R. Johnson and J. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley Personal Computing Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: In the parlance of object-oriented design patterns <ref> [13] </ref>, this approach is known as the Interpreter pattern. <p> Abstract classes introduce new collections of data and specify signatures for the operations that are common to all variants. Concrete classes represent the variants and provide implementations of the actual operations. This is known as the Interpreter pattern <ref> [13] </ref>. 4 For instance, the SML program from Figs. 1 and 2 corresponds to the Java [14] program shown in Fig. 4. The recursive references among the collection of classes lead to corresponding recursive calls among methods, analogous to the recursion in the functional program. <p> In such cases, a more sophisticated protocol is necessary, such as that specified by Cartwright and Felleisen [2]. 4 The Composite pattern <ref> [13] </ref> is sometimes used instead. 4 abstract class Shape f Shape shrink (double pct ); g class extends Shape f double s; (double s) f this.s = s ; g boolean containsPt (Point p) f g g class fl extends Shape f double r ; fl (double r ) f this.r <p> We can encode this idea to create the Extensible Visitor protocol as follows: 1. The creation of new processors is performed via a separate method: a virtual constructor (or Factory Method <ref> [13] </ref>), called makeContainsPt in our example. 9 Shape . . . ; fl process fl ShapeProcessorhffi ContainsPt process fl UnionShapeProcessorhffi - ContainsPtUnion 2. <p> In contrast, our method both assumes an open-ended program and allows the distribution and extension of object code. The literature on design patterns contains many other attempts to define and implement patterns similar to Interpreter and Visitor. The primary presentation of the Visitor pattern <ref> [13] </ref> states that datatype extension is difficult, but does not solve the problems that arise.
Reference: [14] <author> Gosling, J., B. Joy and G. L. Steele, Jr. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Concrete classes represent the variants and provide implementations of the actual operations. This is known as the Interpreter pattern [13]. 4 For instance, the SML program from Figs. 1 and 2 corresponds to the Java <ref> [14] </ref> program shown in Fig. 4. The recursive references among the collection of classes lead to corresponding recursive calls among methods, analogous to the recursion in the functional program. In this setting, it is straightforward to extend the set of shapes. <p> Hence, virtual types are not yet a viable alternative for our Extensible Visitor. 8 The choice of Object still cannot accommodate processors (such as ContainsPt) that return primitive types, which are not subtypes of any other type, including Object <ref> [14] </ref>.
Reference: [15] <author> Hudak, P. and M. P. Jones. </author> <title> Haskell vs. Ada vs. C++ vs. Awk vs. . . . An experiment in software prototyping productivity. </title> <institution> Research Report YALEU/DCS/RR-1049, Department of Computer Science, Yale University, </institution> <address> New Haven, CT, USA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: The last two sections describe related work and summarize the ideas in this paper. 2 Existing Design Approaches To illustrate the design problem with a concrete example, we present a simplistic "geometry manager" program, derived from a US Department of Defense programming contest <ref> [15] </ref>.
Reference: [16] <author> Hudak, P., S. Peyton Jones and P. Wadler. </author> <title> Report on the programming language Haskell: a non-strict, purely functional language. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year> <note> Version 1.2. </note>
Reference-contexts: Such a declaration introduces a new type with one or more variants. In Haskell <ref> [16] </ref> or SML [20], for example, a programmer could use the data or datatype construct, respectively, to represent the set of shapes, as shown in Fig. 1. 2 Each variant introduces a new tag to distinguish it from the other forms of data.
Reference: [17] <author> Kernighan, B. W. and D. M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: For example, the pattern ( s) in the first line of the function matches only squares and binds s to the length of the square's side. Since the datatype definition of a shape is recursive, the corresponding tools are usually recursive, 2 In C <ref> [17] </ref>, one would use (recursive) pointers, structures and unions to represent this set of constructs. 3 too. The recursive calls in a tool match the recursive structure of the datatype.
Reference: [18] <author> Kuhne, T. </author> <title> The translator pattern|external functionality with homomorphic mappings. </title> <booktitle> In Proceedings of TOOLS 23, USA, </booktitle> <pages> pages 48-62, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: The overall cost of this indirection depends on how often an application constructs data, and on the implementation model used for objects and methods. In our experience, this cost has been negligible. 7 Background and Related Work Several researchers, including Cook [4], Kuhne <ref> [18] </ref>, Palsberg and Jay [23], and Remy [26], have observed the trade-offs between the functional and object-oriented design approaches, and have noted the relative strengths and weaknesses of each method at datatype and toolkit extension. Of them, only Kuhne [18] and Palsberg and Jay [23] suggest a solution. Kuhne's solution [18] <p> 7 Background and Related Work Several researchers, including Cook [4], Kuhne <ref> [18] </ref>, Palsberg and Jay [23], and Remy [26], have observed the trade-offs between the functional and object-oriented design approaches, and have noted the relative strengths and weaknesses of each method at datatype and toolkit extension. Of them, only Kuhne [18] and Palsberg and Jay [23] suggest a solution. Kuhne's solution [18] is to replace the dispatching in the Visitor protocol with generic functions that perform double-dispatch. <p> <ref> [18] </ref>, Palsberg and Jay [23], and Remy [26], have observed the trade-offs between the functional and object-oriented design approaches, and have noted the relative strengths and weaknesses of each method at datatype and toolkit extension. Of them, only Kuhne [18] and Palsberg and Jay [23] suggest a solution. Kuhne's solution [18] is to replace the dispatching in the Visitor protocol with generic functions that perform double-dispatch.
Reference: [19] <author> Liang, S., P. Hudak and M. Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <pages> pages 333-343, </pages> <year> 1992. </year>
Reference-contexts: Unfortunately, it is impossible to add a variant to Shape without modifying existing code. First, the datatype representing shapes must be modified because most existing functional languages do not offer an extensible datatype mechanism at all or do so in a restricted manner <ref> [6, 19, 20] </ref>. <p> We can alternatively view the variants of a datatype as specifying the terms of a language, and interpreters as tools. The functional language community has been interested in the problem of creating interpreters from fragments that interpret portions of the language <ref> [2, 8, 19, 30] </ref>. These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them [2, 8, 30] do not address the problem of extending the datatype either. <p> Most of them [2, 8, 30] do not address the problem of extending the datatype either. Duggan and Sourelis [6], Findler [10], and Liang, Hudak, and Jones <ref> [19] </ref> describe methods for creating restricted notions of extensible datatypes. None of these approaches, however, produce datatypes that are extensible in the sense of our protocol. The programmer may specify variants of the datatype separately, but the final datatype must be assembled and "closed" before it can be used.
Reference: [20] <author> Milner, R., M. Tofte and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Such a declaration introduces a new type with one or more variants. In Haskell [16] or SML <ref> [20] </ref>, for example, a programmer could use the data or datatype construct, respectively, to represent the set of shapes, as shown in Fig. 1. 2 Each variant introduces a new tag to distinguish it from the other forms of data. <p> Unfortunately, it is impossible to add a variant to Shape without modifying existing code. First, the datatype representing shapes must be modified because most existing functional languages do not offer an extensible datatype mechanism at all or do so in a restricted manner <ref> [6, 19, 20] </ref>.
Reference: [21] <author> Odersky, M. and P. Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <pages> pages 146-159, </pages> <month> Janurary </month> <year> 1997. </year>
Reference-contexts: Finally, we demonstrate how the protocol can accommodate extensions across multiple tools and mutually-referential data domains. The ideas are illustrated with fragments of code written in Pizza <ref> [21] </ref>, a parametrically polymorphic extension of Java. The choice of Pizza is explained in Sect. 4.
Reference: [22] <author> Palsberg, J. </author> <title> Efficient inference of object types. </title> <journal> Information & Computation, </journal> <volume> 123(2) </volume> <pages> 198-209, </pages> <year> 1995. </year>
Reference-contexts: Also, the methods inside a processor need type declarations, even though the return type is the same as the parameter of the interface. A powerful type inference mechanism, such as those of Eifrig, Smith, and Trifonov [7] and Palsberg <ref> [22] </ref>, can alleviate many of these problems, especially in the context of dynamically-typed object-oriented languages. 5 A Language for Extensible Systems Although the Extensible Visitor pattern solves our problem, it requires the management of numerous mundane details, such as writing class declarations to define the datatype and its variants, defining and
Reference: [23] <author> Palsberg, J. and C. B. Jay. </author> <title> The essence of the Visitor pattern. </title> <type> Technical Report 05, </type> <institution> University of Technology, </institution> <address> Sydney, </address> <year> 1997. </year>
Reference-contexts: The overall cost of this indirection depends on how often an application constructs data, and on the implementation model used for objects and methods. In our experience, this cost has been negligible. 7 Background and Related Work Several researchers, including Cook [4], Kuhne [18], Palsberg and Jay <ref> [23] </ref>, and Remy [26], have observed the trade-offs between the functional and object-oriented design approaches, and have noted the relative strengths and weaknesses of each method at datatype and toolkit extension. Of them, only Kuhne [18] and Palsberg and Jay [23] suggest a solution. <p> Several researchers, including Cook [4], Kuhne [18], Palsberg and Jay <ref> [23] </ref>, and Remy [26], have observed the trade-offs between the functional and object-oriented design approaches, and have noted the relative strengths and weaknesses of each method at datatype and toolkit extension. Of them, only Kuhne [18] and Palsberg and Jay [23] suggest a solution. Kuhne's solution [18] is to replace the dispatching in the Visitor protocol with generic functions that perform double-dispatch. <p> Palsberg and Jay <ref> [23] </ref> propose to use reflection to implement a Visitor-like protocol. In their protocol, all visitors are subclasses of the Walkabout class, which provides a default visitor.
Reference: [24] <author> Palsberg, J., C. Xiao and K. Lieberherr. </author> <title> Efficient implementation of adaptive software. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 264-292, </pages> <year> 1995. </year>
Reference-contexts: Finally, their system is over two orders of magnitude slower than a plain Visitor, making it unsuitable for practical use. In contrast, Extensible Visitor works with generic object-oriented languages, and incurs a negligible overhead beyond that of Visitor. Lieberherr and his colleagues have built a system for adaptive programming <ref> [24] </ref>, which addresses the structural and behavioral adaptation of systems. Using their system, Demeter, programmers write separate specifications of traversals and actions, and Demeter combines these to generate a complete program.
Reference: [25] <author> Portner, N. </author> <title> Flexible command interpreter: A pattern for an extensible and language-independent interpreter system, </title> <note> 1995. Appears in [5]. </note>
Reference-contexts: The current implementation of Extensible Visitor incurs an execution penalty due to dispatching. Indeed many design patterns suffer similar overheads, but their popularity suggests that users are more interested in design and extensibility considerations than in fine-grained efficiency. For example, Portner <ref> [25] </ref> reports that his use of the Interpreter pattern to implement a command language is up to 30% slower than a hand-crafted C implementation; still, he states that the low development cost far outweighs the execution penalty.
Reference: [26] <author> Remy, D. </author> <title> Introduction aux objets. </title> <type> Unpublished manuscript, </type> <institution> lecture notes for course de mag-istere, Ecole Normale Superieure, </institution> <year> 1996. </year>
Reference-contexts: In our experience, this cost has been negligible. 7 Background and Related Work Several researchers, including Cook [4], Kuhne [18], Palsberg and Jay [23], and Remy <ref> [26] </ref>, have observed the trade-offs between the functional and object-oriented design approaches, and have noted the relative strengths and weaknesses of each method at datatype and toolkit extension. Of them, only Kuhne [18] and Palsberg and Jay [23] suggest a solution.
Reference: [27] <author> Reynolds, J. C. </author> <title> User-defined types and procedural data structures as complementary approaches to data abstraction. </title> <editor> In Schuman, S. A., editor, </editor> <booktitle> New Directions in Algorithmic Languages, </booktitle> <pages> pages 157-168. </pages> <booktitle> IFIP Working Group 2.1 on Algol, </booktitle> <year> 1975. </year> <month> 19 </month>
Reference-contexts: We discuss both the functional and the object-oriented design methods in this context and expose their failings. 1 Cook [4] devotes his tutorial to this problem, which was first anticipated by Reynolds <ref> [27] </ref>. 2 datatype Shape = of num j fl of num j ; of Point fi Shape ContainsPt : Point fi Shape ! boolean ContainsPt p ( s) = j p (fl r ) = j p ( ; d s) = ContainsPt p 0 s Shrink : num fi Shape
Reference: [28] <author> Riehle, D. </author> <title> Composite design patterns. </title> <booktitle> In ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages & Applications, </booktitle> <pages> pages 218-228, </pages> <year> 1997. </year>
Reference-contexts: In short, the two design styles suffer from a serious problem. Each style accommodates one form of extension easily and renders the other nearly impossible. 1 This paper presents the Extensible Visitor pattern, a new composite design pattern <ref> [28] </ref>, which provides an elegant solution to the above dilemma. The composite pattern is a combination of the Visitor and Factory Method patterns. Its implementation in any class-based object-oriented programming language is straightforward.
Reference: [29] <author> Seiter, L. M., J. Palsberg and K. J. Lieberherr. </author> <title> Evolution of object behavior using context relations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1998. </year>
Reference-contexts: Baumgartner, Laufer and Russo [1] propose an implementation of Visitor based on multi-method dispatch and claim that it makes datatype and toolkit extension easy, but they do not recognize the problems that arise when extending tools or coordinating multiple tools. Seiter, Palsberg, and Lieberherr <ref> [29] </ref> describe how dynamic relationships between classes can be captured more expressively using context relations, which extend and override the behavior of classes and decouple behavioral evolution and inheritance hierarchies.
Reference: [30] <author> Steele, G. L., Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <pages> pages 472-492, </pages> <month> Janurary </month> <year> 1994. </year>
Reference-contexts: We can alternatively view the variants of a datatype as specifying the terms of a language, and interpreters as tools. The functional language community has been interested in the problem of creating interpreters from fragments that interpret portions of the language <ref> [2, 8, 19, 30] </ref>. These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them [2, 8, 30] do not address the problem of extending the datatype either. <p> These approaches are orthogonal to ours in that they can handle semantic extensions to the interpreters, but none of them consider the problem of an extensible toolkit. Most of them <ref> [2, 8, 30] </ref> do not address the problem of extending the datatype either. Duggan and Sourelis [6], Findler [10], and Liang, Hudak, and Jones [19] describe methods for creating restricted notions of extensible datatypes. None of these approaches, however, produce datatypes that are extensible in the sense of our protocol.
Reference: [31] <author> Stroustrup, B. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: If we translate ContainsPt to return Boolean instead of boolean, the Java version of the forUnion method in ContainsPtUnion is: public Object forUnion ( fl u) f return new Boolean ((((Boolean) (u.lhs.process (this))).booleanValue ()) _ (((Boolean) (u.rhs.process (this))).booleanValue ())) ; g 6 C++'s <ref> [31] </ref> template mechanism provides a limited amount of parametric polymorphism. 7 Thorup [33] has proposed a different style of type parameterization for Java: virtual types.
Reference: [32] <author> Sun Microsystems. </author> <title> Java core reflection. API and Specification, </title> <year> 1997. </year>
Reference-contexts: In their protocol, all visitors are subclasses of the Walkabout class, which provides a default visitor. The 16 default visitor examines the argument; if the argument is not a base class, the Walkabout obtains the argument's fields using Java's reflection facility <ref> [32] </ref>, and then recursively visits each field. While Palsberg and Jay's approach also scales to legacy classes, it is unclear how well their system works when the variants have instance variables unrelated to the fields of the variant, or when they have multiple fields with the same type.
Reference: [33] <author> Thorup, K. K. </author> <title> Genericity in Java with virtual types. </title> <booktitle> In European Conference on Object-Oriented Programming, </booktitle> <pages> pages 444-471, </pages> <year> 1997. </year> <month> 20 </month>
Reference-contexts: return Boolean instead of boolean, the Java version of the forUnion method in ContainsPtUnion is: public Object forUnion ( fl u) f return new Boolean ((((Boolean) (u.lhs.process (this))).booleanValue ()) _ (((Boolean) (u.rhs.process (this))).booleanValue ())) ; g 6 C++'s [31] template mechanism provides a limited amount of parametric polymorphism. 7 Thorup <ref> [33] </ref> has proposed a different style of type parameterization for Java: virtual types.
References-found: 33

