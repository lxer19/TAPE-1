URL: http://www.cs.wisc.edu/~solomon/odysseas/vldb-journal.ps.gz
Refering-URL: http://www.cs.wisc.edu/~solomon/solomon.html
Root-URL: 
Email: fodysseas,solomon,yannisg@cs.wisc.edu  
Title: The GMAP: A Versatile Tool for Physical Data Independence  
Author: Odysseas G. Tsatalos Marvin H. Solomon and Yannis E. Ioannidis 
Note: Partially supported by the Advanced Research Project Agency, ARPA order number 018 (formerly 8230), monitored by the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518 Partially supported by the National Science Foundation under Grants IRI-9113736, IRI-9224741, and IRI-9157368 (PYI Award) and by grants from DEC, IBM, HP, AT&T, and Informix.  
Date: October 18, 1994  
Address: Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract: Physical data independence is touted as a central feature of modern database systems. It allows users to frame queries in terms of the logical structure of the data, letting a query processor automatically translate them into optimal plans that access physical storage structures. Both relational and object-oriented systems, however, force users to frame their queries in terms of a logical schema that is directly tied to physical structures. We present an approach that eliminates this dependence. All storage structures are defined in a declarative language based on relational algebra as functions of a logical schema. We present an algorithm, integrated with a conventional query optimizer, that translates queries over this logical schema into plans that access the storage structures. We also show how to compile update requests into plans that update all relevant storage structures consistently and optimally. Finally, we report on experiments with a prototype implementation of our approach that demonstrate how it allows storage structures to be tuned to the expected or observed workload to achieve significantly better performance than is possible with conventional techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU79] <author> A. Aho, Y. Sagiv, and J. Ullman. </author> <title> Equivalences Among Relational Expressions. </title> <journal> SIAM Journal of Computing, </journal> <volume> 8(2) </volume> <pages> 218-247, </pages> <year> 1979. </year>
Reference-contexts: Two psj-queries Q 1 and Q 2 are equivalent, denoted Q 1 Q 2 , if they produce the same result for any valid instance of the database schema. Equivalence testing of arbitrary conjunctive queries, even without taking into account any dependencies, is NP-complete <ref> [ASU79, CM77] </ref>. On the other hand, we can efficiently compare two psj-queries syntactically to see if they are identical (up to trivial differences such as the ordering of the join terms). This is a sufficient condition for equivalence, which we use in our translation algorithm.
Reference: [BCL89] <author> J. Blakeley, N. Coburn, and P. Larson. </author> <title> Updating derived relations. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: In addition, updates become much simpler. Translating them into the physical schema turns into the materialized view maintenance problem, which admits simple solutions. As discussed elsewhere <ref> [BCL89] </ref>, propagating updates into materialized views requires the execution of queries over the base relations and the inserted or deleted tuples. However, here we do not necessarily have the base relations stored, and the actual data may be replicated in many places. <p> However, since gmap queries do not support unions, they cannot represent outer joins, and therefore cannot store incomplete instances of chains. With respect to the translation algorithm, our work most closely resembles research at the University of Waterloo on materialized views <ref> [BCL89, YL87] </ref>. Our algorithm supports a more restricted query language, but uses information about inclusion and functional dependencies as well as "topological" information implicit in a graph-based logical schema. This information allows us to identify solutions that would be missed by the more general algorithm. <p> In addition to the work on materialized views <ref> [BCL89, YL87] </ref>, such efforts include research whose goal was not physical data independence but simply processing efficiency. Examples include research on reusing common subexpressions within a query [Hal76] or between multiple queries [Sel86], reusing results of previous queries [Fin82], and using integrity constraints for semantic query optimization [Cha90].
Reference: [BK89] <author> E. Bertino and W. Kim. </author> <title> Indexing Techniques for Queries on Nested Objects. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 196-214, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: In this paper, we restrict both gmap definitions and queries to project-select-join (psj) expressions over a simple semantic data model. We demonstrate that such expressions are powerful enough to express most conventional storage structures, as well as more "exotic" techniques such as path indices <ref> [BK89, MS86] </ref>, field replication [KM92, SC89], and more. We present an algorithm to translate user queries, expressed as psj-queries over structures in the logical schema, into relational expressions over the gmaps. We also show how this translation can be integrated into a conventional query optimizer. <p> Similarly, suppose applications frequently ask for the listing of the faculty of a specific department. In this case we need a fast access path from the department name to the faculty domain. A structure for accelerating such path expressions is called a nested index <ref> [MS86, BK89] </ref>, which allows indexing on a nested attribute of a domain. Such an index is easily specified as a gmap (Figure 5): def_gmap faculty_nested_index as btree by given Dept.name select Faculty where Faculty works_in Dept. In the previous examples, the gmap data included all Faculty instances. <p> Second, we consider replicating attributes over paths that are not functional by associating multiple values with each instance of the root of the path. Such replication is very beneficial 1 We use the term path indices collectively for what Bertino and Kim <ref> [BK89] </ref> call path indices, nested indices, and multi-indices. 19 for our workload since it can eliminate the most expensive step of the medium and large queries Q5, Q7, and Q8. The altered gmap definitions are shown in Appendix B.4. <p> Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices <ref> [BK89, KBG89, MS86] </ref>, join indices [Val87], and field replication [KM92, SC89], noting their restrictions and comparing their performance to our scheme.
Reference: [Cat93] <author> R.G.G. Catel. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan-Kaufman, Inc., </publisher> <year> 1993. </year>
Reference-contexts: Throughout this paper we illustrate our approach with an example database describing a university and its personnel (see Figure 1). The textual form of the schema is given in Appendix A using ODL <ref> [Cat93] </ref>. Nodes in this graph represent domains and solid edges represent relationships between them. Leaves represent primitive domains such as integers, character strings, or real numbers. Internal nodes represent domains populated with identity surrogates (tuple or object identifiers).
Reference: [CDF + 94] <author> M. Carey, D. DeWitt, M. Franklin, N. Hall, M. McAuliffe, J. Naughton, D. Schuh, M. Solomon, C. Tan, O. Tsatalos, S. White, and M. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Any available bulk-loading interfaces to these structures can be exploited. 7 Implementation To verify the applicability and practicality of our algorithms and obtain a feeling for their performance, we built a prototype implementation of our system on top of SHORE <ref> [CDF + 94] </ref>. SHORE is an object-oriented database system under construction at the University of Wisconsin. We extended SHORE with facilities to support gmaps and translate and execute queries and updates. Logical schema definitions are parsed and stored in a logical-schema catalog. Physical storage structures are created from gmap definitions.
Reference: [CDV88] <author> M. Carey, D. DeWitt, and S. Vandenberg. </author> <title> A Data Model and Query Language for Exodus. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 413-423, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: In the previous examples, the gmap data included all Faculty instances. However, there are cases where we frequently access only some instances of a domain. Object-oriented systems that store instances in explicit collections rather than class extents <ref> [CDV88, MS86, OHMS92] </ref> allow the creation of collection indices, which 4 provide fast access paths only to the subsets of the domains that are included in the collection. Our gmap definition language is powerful enough to express such indices by using restrictions. <p> For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion [KGBW90], and Zoo [ILH + 93]) and every collection in collection-based OO systems (e.g., GemStone [MS86], Extra/Excess <ref> [CDV88] </ref>, and ObjectStore [OHMS92]) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files.
Reference: [Cha90] <author> U. Chakravarthy. </author> <title> Logic-Based Approach to Semantic Query Optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(2) </volume> <pages> 163-207, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Examples include research on reusing common subexpressions within a query [Hal76] or between multiple queries [Sel86], reusing results of previous queries [Fin82], and using integrity constraints for semantic query optimization <ref> [Cha90] </ref>. Kemper and Moerkotte [KM90b] opt for a unified approach of translation and optimization for the ASRs by extending a rule based optimizer to include appropriate rewriting rules.
Reference: [CM77] <author> A. Chandra and P. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational data bases. </title> <booktitle> In Proc. of Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 77-90, </pages> <month> May </month> <year> 1977. </year> <month> 22 </month>
Reference-contexts: Two psj-queries Q 1 and Q 2 are equivalent, denoted Q 1 Q 2 , if they produce the same result for any valid instance of the database schema. Equivalence testing of arbitrary conjunctive queries, even without taking into account any dependencies, is NP-complete <ref> [ASU79, CM77] </ref>. On the other hand, we can efficiently compare two psj-queries syntactically to see if they are identical (up to trivial differences such as the ordering of the join terms). This is a sufficient condition for equivalence, which we use in our translation algorithm.
Reference: [CSL + 90] <author> M. Carey, E. Shekita, G. Lapis, B. Lindsay, and J. McPherson. </author> <title> An Incremental Join Attachment for Starburst. </title> <booktitle> In Proc. of the Int. VLDB Conf., </booktitle> <pages> pages 662-673, </pages> <year> 1990. </year>
Reference-contexts: add a gmap from faculty to courses: def_gmap courses_index as hash_table given Faculty select Course where Faculty teaches Course Although the performance of this approach may not match that of a pointer join (it has been shown that pointer joins are generally faster than joins accelerated through an external index <ref> [CSL + 90] </ref>), it offers significant advantages. First, the gmaps can be used not only for updating the structure but by any other query as well. Second, if usage patterns change so that maintenance of the accelerator is not beneficial, we can simply remove it.
Reference: [Fin82] <author> S. Finkelstein. </author> <title> Common expression analysis in database applications. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 364-374, </pages> <year> 1982. </year>
Reference-contexts: Query signatures, an encoding of the names of all the relations used by the query, can be used to perform these comparisons efficiently <ref> [Fin82] </ref>. It is interesting to see how the new algorithm behaves when it is given a set of gmaps that represents a traditional relational physical schema. <p> In addition to the work on materialized views [BCL89, YL87], such efforts include research whose goal was not physical data independence but simply processing efficiency. Examples include research on reusing common subexpressions within a query [Hal76] or between multiple queries [Sel86], reusing results of previous queries <ref> [Fin82] </ref>, and using integrity constraints for semantic query optimization [Cha90]. Kemper and Moerkotte [KM90b] opt for a unified approach of translation and optimization for the ASRs by extending a rule based optimizer to include appropriate rewriting rules.
Reference: [Hal76] <author> P.V. Hall. </author> <title> Optimization of a single relational expression in a RDBMS. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 20(3), </volume> <month> May </month> <year> 1976. </year>
Reference-contexts: In addition to the work on materialized views [BCL89, YL87], such efforts include research whose goal was not physical data independence but simply processing efficiency. Examples include research on reusing common subexpressions within a query <ref> [Hal76] </ref> or between multiple queries [Sel86], reusing results of previous queries [Fin82], and using integrity constraints for semantic query optimization [Cha90]. Kemper and Moerkotte [KM90b] opt for a unified approach of translation and optimization for the ASRs by extending a rule based optimizer to include appropriate rewriting rules.
Reference: [ILH + 93] <author> Y. Ioannidis, M. Livny, E. Haber, R. Miller, O. Tsatalos, and J. Wiener. </author> <title> Desktop Experiment Management. </title> <journal> IEEE Data Engineering, </journal> <volume> 16(1) </volume> <pages> 19-23, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion [KGBW90], and Zoo <ref> [ILH + 93] </ref>) and every collection in collection-based OO systems (e.g., GemStone [MS86], Extra/Excess [CDV88], and ObjectStore [OHMS92]) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files.
Reference: [KBG89] <author> W. Kim, E. Bertino, and J. Garza. </author> <title> Composite Objects Revisited. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 337-347, </pages> <year> 1989. </year>
Reference-contexts: Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices <ref> [BK89, KBG89, MS86] </ref>, join indices [Val87], and field replication [KM92, SC89], noting their restrictions and comparing their performance to our scheme.
Reference: [KGBW90] <author> W. Kim, J. F. Garza, N. Ballou, and D. Woelk. </author> <title> Architecture of the ORION Next-generation Database System. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2 </volume> <pages> 109-124, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion <ref> [KGBW90] </ref>, and Zoo [ILH + 93]) and every collection in collection-based OO systems (e.g., GemStone [MS86], Extra/Excess [CDV88], and ObjectStore [OHMS92]) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files.
Reference: [KM90a] <author> A. Kemper and G. Moerkotte. </author> <title> Access Support in Object Bases. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 290-301, </pages> <year> 1990. </year>
Reference-contexts: Another approach to decomposing the database is hierarchical join indices [VKC86], a generalization of join indices that allows one to build an index over identity surrogates that populate trees of the logical schema graph. Access Support Relations (ASR) offer a different generalization of join indices <ref> [KM90a] </ref>, which allows the definition of indices over the instances of arbitrary chains of logical schema nodes. This scheme offers a higher degree of flexibility and allows the definition of indices that store both complete and partial instances of each chain.
Reference: [KM90b] <author> A. Kemper and G. Moerkotte. </author> <title> Advanced Query Processing in Object Bases Using Access Support Relations. </title> <booktitle> In Proc. of the Int. VLDB Conf., </booktitle> <pages> pages 290-301, </pages> <year> 1990. </year>
Reference-contexts: Examples include research on reusing common subexpressions within a query [Hal76] or between multiple queries [Sel86], reusing results of previous queries [Fin82], and using integrity constraints for semantic query optimization [Cha90]. Kemper and Moerkotte <ref> [KM90b] </ref> opt for a unified approach of translation and optimization for the ASRs by extending a rule based optimizer to include appropriate rewriting rules.
Reference: [KM92] <author> K. Kato and T. Masuda. </author> <title> Persistent Caching. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(7) </volume> <pages> 631-645, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: In this paper, we restrict both gmap definitions and queries to project-select-join (psj) expressions over a simple semantic data model. We demonstrate that such expressions are powerful enough to express most conventional storage structures, as well as more "exotic" techniques such as path indices [BK89, MS86], field replication <ref> [KM92, SC89] </ref>, and more. We present an algorithm to translate user queries, expressed as psj-queries over structures in the logical schema, into relational expressions over the gmaps. We also show how this translation can be integrated into a conventional query optimizer. <p> The department name is, in this case, a nested attribute of the Faculty domain. This essentially implements field replication <ref> [KM92, SC89] </ref>, which has been shown to offer several advantages. The only change necessary is to add "Dept.name" to the select clause. <p> The data replication adds 2MB of additional space bringing the total database size to 77MB. The new database offers a 7% performance gain over the previous one. It is interesting to note that the technique of field replication as originally described <ref> [KM92, SC89] </ref> cannot be applied to any other field in our database because it is restricted to edges from classes to single-valued attributes. Similar restrictions also prohibit any useful application of path indices in our database. <p> Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices [BK89, KBG89, MS86], join indices [Val87], and field replication <ref> [KM92, SC89] </ref>, noting their restrictions and comparing their performance to our scheme. Another approach to decomposing the database is hierarchical join indices [VKC86], a generalization of join indices that allows one to build an index over identity surrogates that populate trees of the logical schema graph.
Reference: [MIR93] <author> R. Miller, Y. Ioannidis, and R. Ramakrishnan. </author> <title> The Use of Information Capacity in Schema Integration and Translation. </title> <booktitle> In Proc. of the Int. VLDB Conf., </booktitle> <pages> pages 120-133, </pages> <year> 1993. </year>
Reference-contexts: Although the semantics of the update query depends only on the logical schema, its validity may depend on the choice of gmaps used to define the physical schema. In particular, the physical schema must have sufficient "information capacity" to hold the inserted data <ref> [MIR93] </ref>. These issues are not addressed in this paper and are subject of the authors' ongoing research. Furthermore, we do not address the question of whether the update conforms with the integrity constraints of the database. Specific gmap structures or gmap combinations may help accelerate testing the integrity constraints.
Reference: [MS86] <author> D. Maier and J. Stein. </author> <title> Indexing in an Object-Oriented DBMS. </title> <booktitle> In 2nd Int. Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 171-182, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: In this paper, we restrict both gmap definitions and queries to project-select-join (psj) expressions over a simple semantic data model. We demonstrate that such expressions are powerful enough to express most conventional storage structures, as well as more "exotic" techniques such as path indices <ref> [BK89, MS86] </ref>, field replication [KM92, SC89], and more. We present an algorithm to translate user queries, expressed as psj-queries over structures in the logical schema, into relational expressions over the gmaps. We also show how this translation can be integrated into a conventional query optimizer. <p> Similarly, suppose applications frequently ask for the listing of the faculty of a specific department. In this case we need a fast access path from the department name to the faculty domain. A structure for accelerating such path expressions is called a nested index <ref> [MS86, BK89] </ref>, which allows indexing on a nested attribute of a domain. Such an index is easily specified as a gmap (Figure 5): def_gmap faculty_nested_index as btree by given Dept.name select Faculty where Faculty works_in Dept. In the previous examples, the gmap data included all Faculty instances. <p> In the previous examples, the gmap data included all Faculty instances. However, there are cases where we frequently access only some instances of a domain. Object-oriented systems that store instances in explicit collections rather than class extents <ref> [CDV88, MS86, OHMS92] </ref> allow the creation of collection indices, which 4 provide fast access paths only to the subsets of the domains that are included in the collection. Our gmap definition language is powerful enough to express such indices by using restrictions. <p> For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion [KGBW90], and Zoo [ILH + 93]) and every collection in collection-based OO systems (e.g., GemStone <ref> [MS86] </ref>, Extra/Excess [CDV88], and ObjectStore [OHMS92]) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files. <p> Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices <ref> [BK89, KBG89, MS86] </ref>, join indices [Val87], and field replication [KM92, SC89], noting their restrictions and comparing their performance to our scheme.
Reference: [OHMS92] <author> J. Orenstein, S. Haradhvala, B. Marguiles, and D. Sakahara. </author> <title> Query Processing in the ObjectStore Database System. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <year> 1992. </year>
Reference-contexts: In the previous examples, the gmap data included all Faculty instances. However, there are cases where we frequently access only some instances of a domain. Object-oriented systems that store instances in explicit collections rather than class extents <ref> [CDV88, MS86, OHMS92] </ref> allow the creation of collection indices, which 4 provide fast access paths only to the subsets of the domains that are included in the collection. Our gmap definition language is powerful enough to express such indices by using restrictions. <p> For example, every relation in most relational systems, every class extent in extent-based OO systems (e.g., Orion [KGBW90], and Zoo [ILH + 93]) and every collection in collection-based OO systems (e.g., GemStone [MS86], Extra/Excess [CDV88], and ObjectStore <ref> [OHMS92] </ref>) is stored in a separate file. The main flexibility at the physical level comes from secondary access paths to these files.
Reference: [RES93] <author> N. Roussopoulos, N. Economou, and A. Stamenas. ADMS: </author> <title> A Testbed for Incremental Access Methods. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(5) </volume> <pages> 762-773, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: As long as the data contents of all these distinct sources can be described by psj-queries over a single logical schema, the query optimizer can translate logical queries into access plans over them. This strategy has many similarities with the ADMS system <ref> [RES93] </ref>, which uses the concept of view indexing [Rou82] to efficiently represent materialized views, together with a semantic query optimizer to support database interoperability. 6.3 Main Memory Caching Another application of gmaps is to support cached data in transient main-memory data structures such as arrays or hash tables.
Reference: [Rou82] <author> N. Roussopoulos. </author> <title> View Indexing in Relational Database. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2) </volume> <pages> 259-290, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: This strategy has many similarities with the ADMS system [RES93], which uses the concept of view indexing <ref> [Rou82] </ref> to efficiently represent materialized views, together with a semantic query optimizer to support database interoperability. 6.3 Main Memory Caching Another application of gmaps is to support cached data in transient main-memory data structures such as arrays or hash tables.
Reference: [SAC + 79] <author> P.G. Selinger, M.M. Astrahan, D.D. Chamberlin, R.A. Lorie, and T.G. Price. </author> <title> Access Path Selection in a Relational Database Management System. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 23-34, </pages> <year> 1979. </year>
Reference-contexts: All subsets that pass the test are feasible plans. The version of the algorithm that is actually implemented by our system is considerably more sophisticated. It is integrated with a conventional dynamic-programming query optimizer <ref> [SAC + 79] </ref>, which controls the order in which subsets are evaluated and uses cost information and intermediate results to prune the search space. 9 A conventional dynamic-programming optimizer iteratively finds optimal access plans for increasingly larger parts of a query. <p> We follow these steps in more detail, showing at each step what needs to be changed for a gmap-equipped database (Table 1). We then identify the pieces of Algorithm 1 that correspond to these changes. In what follows, for simplicity, we avoid any discussion of "interesting orders" <ref> [SAC + 79] </ref>.
Reference: [SC89] <author> E. Shekita and M. Carey. </author> <title> Performance Enhancement Through Replication in an Object-Oriented DBMS. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 325-336, </pages> <year> 1989. </year>
Reference-contexts: In this paper, we restrict both gmap definitions and queries to project-select-join (psj) expressions over a simple semantic data model. We demonstrate that such expressions are powerful enough to express most conventional storage structures, as well as more "exotic" techniques such as path indices [BK89, MS86], field replication <ref> [KM92, SC89] </ref>, and more. We present an algorithm to translate user queries, expressed as psj-queries over structures in the logical schema, into relational expressions over the gmaps. We also show how this translation can be integrated into a conventional query optimizer. <p> The department name is, in this case, a nested attribute of the Faculty domain. This essentially implements field replication <ref> [KM92, SC89] </ref>, which has been shown to offer several advantages. The only change necessary is to add "Dept.name" to the select clause. <p> Shekita and Carey <ref> [SC89] </ref> suggest adding backward links from faculty to their respective courses, in effect, advocating a pointer-based join. <p> The data replication adds 2MB of additional space bringing the total database size to 77MB. The new database offers a 7% performance gain over the previous one. It is interesting to note that the technique of field replication as originally described <ref> [KM92, SC89] </ref> cannot be applied to any other field in our database because it is restricted to edges from classes to single-valued attributes. Similar restrictions also prohibit any useful application of path indices in our database. <p> Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices [BK89, KBG89, MS86], join indices [Val87], and field replication <ref> [KM92, SC89] </ref>, noting their restrictions and comparing their performance to our scheme. Another approach to decomposing the database is hierarchical join indices [VKC86], a generalization of join indices that allows one to build an index over identity surrogates that populate trees of the logical schema graph.
Reference: [Sel86] <author> T. Sellis. </author> <title> Global Query Optimization. </title> <booktitle> In Proc. of the ACM SIGMOD Conf., </booktitle> <pages> pages 191-205, </pages> <year> 1986. </year>
Reference-contexts: In addition to the work on materialized views [BCL89, YL87], such efforts include research whose goal was not physical data independence but simply processing efficiency. Examples include research on reusing common subexpressions within a query [Hal76] or between multiple queries <ref> [Sel86] </ref>, reusing results of previous queries [Fin82], and using integrity constraints for semantic query optimization [Cha90]. Kemper and Moerkotte [KM90b] opt for a unified approach of translation and optimization for the ASRs by extending a rule based optimizer to include appropriate rewriting rules.
Reference: [TI94] <author> O. Tsatalos and Y. Ioannidis. </author> <title> A Unified Framework for Indexing in Database Systems. </title> <booktitle> In Proc. of the Int. Conf. on Database and Expert System Applications, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: A complete taxonomy of existing indexing schemes and other advanced storage structures that can be defined by using gmaps is presented elsewhere <ref> [TI94] </ref>. 3 Query translation In this section we present the translation algorithm of a logical query into queries over gmaps.
Reference: [TSI94] <author> O. Tsatalos, M. Solomon, and Y. Ioannidis. </author> <title> PSJ-Query Translation in the Presence of Logical Schema Constraints. </title> <note> Submitted for publication, </note> <month> October </month> <year> 1994. </year>
Reference-contexts: An algorithm that implements necessary and sufficient conditions for testing coverage is presented elsewhere <ref> [TSI94] </ref>. The algorithm makes use of the inclusion dependencies of the schema. 3.3.2 Natural join vs. Add-Join In general, if Q 1 and Q 2 are two psj-queries, Q 1 Q 2 Q 1 1 Q 2 . <p> As a sufficient condition for guaranteeing that the natural join of two queries is a psj-query, we test if it is equivalent to the add-join of the queries in question. An algorithm that implements a sufficient condition for testing this equivalence is presented elsewhere <ref> [TSI94] </ref>. 7 3.4 Query Translation Algorithm Below we present an algorithm to translate a logical psj-query into queries over gmaps. For the sake of clarity we defer most efficiency considerations to Section 4.
Reference: [Ull88] <author> J. Ullman. </author> <booktitle> Principles of Database and Knowledge-base Systems, </booktitle> <volume> volume 1, </volume> <pages> pages 423-425. </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year> <month> 23 </month>
Reference-contexts: Such an update has ambiguous semantics and thus should not be allowed. * No tuple-generating dependencies: The relation defined by the update query should not satisfy any tuple generating dependencies <ref> [Ull88] </ref>. For example, the relation defined by the update query def_query assign_work_to_faculty as select Faculty, Student, Course where Faculty advises Student Faculty teaches Course, satisfies the multivalued dependency Faculty !! Student.
Reference: [Val87] <author> P. Valduriez. </author> <title> Join Indices. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 218-246, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: This construct, called a join index, has been shown to offer advantages over the conventional relational approach <ref> [Val87] </ref>. Thus, we replaced the attends relation with two gmaps that simulate the definition of a join index over the attends relationship. The results showed that the join index performed better than a combination of a relation clustered on one of the two names and a pair of secondary indices. <p> Several extensions of both the primary physical structure and the secondary access paths have been recently proposed in the literature that allow storing together data from more than one logical construct. In Sections 2 and 8, we discussed path indices [BK89, KBG89, MS86], join indices <ref> [Val87] </ref>, and field replication [KM92, SC89], noting their restrictions and comparing their performance to our scheme. Another approach to decomposing the database is hierarchical join indices [VKC86], a generalization of join indices that allows one to build an index over identity surrogates that populate trees of the logical schema graph.
Reference: [VKC86] <author> P. Valduriez, S. Khoshafian, and G. Copeland. </author> <title> Implementation Techniques of Complex Objects. </title> <booktitle> In Proc. of the Int. VLDB Conf., </booktitle> <pages> pages 101-109, </pages> <year> 1986. </year>
Reference-contexts: In Sections 2 and 8, we discussed path indices [BK89, KBG89, MS86], join indices [Val87], and field replication [KM92, SC89], noting their restrictions and comparing their performance to our scheme. Another approach to decomposing the database is hierarchical join indices <ref> [VKC86] </ref>, a generalization of join indices that allows one to build an index over identity surrogates that populate trees of the logical schema graph.
Reference: [YL87] <author> H.Z. Yang and P.A. Larson. </author> <title> Query transformation for PSJ-queries. </title> <booktitle> In Proc. of the Int. VLDB Conf., </booktitle> <year> 1987. </year> <month> 24 </month>
Reference-contexts: However, since gmap queries do not support unions, they cannot represent outer joins, and therefore cannot store incomplete instances of chains. With respect to the translation algorithm, our work most closely resembles research at the University of Waterloo on materialized views <ref> [BCL89, YL87] </ref>. Our algorithm supports a more restricted query language, but uses information about inclusion and functional dependencies as well as "topological" information implicit in a graph-based logical schema. This information allows us to identify solutions that would be missed by the more general algorithm. <p> In addition to the work on materialized views <ref> [BCL89, YL87] </ref>, such efforts include research whose goal was not physical data independence but simply processing efficiency. Examples include research on reusing common subexpressions within a query [Hal76] or between multiple queries [Sel86], reusing results of previous queries [Fin82], and using integrity constraints for semantic query optimization [Cha90].
References-found: 31

