URL: http://charm.cs.uiuc.edu/version2/papers/AgentsLCPC95.ps
Refering-URL: http://charm.cs.uiuc.edu/version2/papers/AgentsLCPC95.html
Root-URL: http://www.cs.uiuc.edu
Email: jyelon@cs.uiuc.edu, kale@cs.uiuc.edu  
Title: Agents: an Undistorted Representation of Problem Structure  
Author: J. Yelon and L. V. Kale 
Address: Urbana Illinois 61801,  
Affiliation: Dept. of Computer Science, University of Illinois,  
Abstract: It has been observed that data-parallel languages are only suited to problems with "regular" structures. This observation prompts a question: to what extent are other parallel programming languages specialized to specific problem structures, and are there any truly general-purpose parallel programming languages, suited to all problem structures? In this paper, we define our concept of "problem structure". Given this definition, we describe what it means for a language construct to "directly reflect" a problem structure, and we argue the importance of using a language construct which reflects the problem structure. We describe the difficulties that arise when the language construct and the problem structure do not fit each other. We consider existing language constructs to identify the structures they fit, and we note that language constructs are often designed with little regard for such generality. Finally, we describe a parallel language construct which is designed specif ically with the goal of being able to reflect arbitrary problem structures.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Gul Agha and Carl Hewitt. </author> <title> Concurrent Programming Using Actors: Exploiting Large-Scale Parallelism, </title> <booktitle> volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 19-40. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelberg-New York, </address> <month> October </month> <year> 1985. </year>
Reference-contexts: Such concrete reassurance is offered by the linked data structures, which can obviously be connected into any shape imaginable. Therefore, linked structures promise to singlehandedly cover the entire space of possible problem shapes. 2.3 Object-Based Languages and Linked Structures Parallel Object-based languages (Actors <ref> [1] </ref>, ABCL/1 [16], Mentat [8], etc.) rely on linked data structures to represent problem structure. Linked data structures, because of their incredibly flexible shape, are the sequential programmer's tool of choice for clear representation of complicated shapes such as trees and graphs. <p> The process is initiated by the sends on line 15-16, which trigger the handler on lines 8-11. This causes value tuples containing fib (0) and fib (1) to be sent to calcfib <ref> [1] </ref> through calcfib [3]. These in turn produce value tuples, which are received by the handler on lines 5-7, are forwarded as fib eq tuples to the handler on lines 8-11, which again feeds them back to the calcfib agents as value tuples. <p> There are also the sends in the relay handlers on lines 5-11. Together they provide two induction hypotheses, one of which is: if calcfib [i] is used, and (i+1&lt;=n), then calcfib [i+1] is used. Therefore, the range of agents that is used is calcfib <ref> [1] </ref> through calcfib [n]. Similar inductive proofs can be made for 2D agent matrices, to verify that they are finite, and to determine the ranges of the indices. If the indices are not finite, tiling is aborted. Finally, tiling is implemented by choosing a size for each tile.
Reference: 2. <author> F. Bodin, P. Beckman, D. B. Gannon, S. Narayana, and S. X. Yang. </author> <title> Distributed pC++: Basic ideas for an object parallel language. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <pages> pages 273-282, </pages> <year> 1991. </year>
Reference-contexts: We term these languages the "agglomerate" languages. Such languages seem to be quite popular right now: consider Charm [10], HPC++ <ref> [2] </ref> [3], and HPF+Fortran-M [6]. By includ-ing different constructs for different problem structures, these languages aim to support a broader class of problems than their predecessors. Some would say that designers of agglomerate languages are haphazardly adding constructs, each of which is only useful for one problem structure.
Reference: 3. <author> K. M. Chandy and C. Kesselman. </author> <title> CC++: A declarative concurrent object-oriented programming notation. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: We term these languages the "agglomerate" languages. Such languages seem to be quite popular right now: consider Charm [10], HPC++ [2] <ref> [3] </ref>, and HPF+Fortran-M [6]. By includ-ing different constructs for different problem structures, these languages aim to support a broader class of problems than their predecessors. Some would say that designers of agglomerate languages are haphazardly adding constructs, each of which is only useful for one problem structure. <p> The process is initiated by the sends on line 15-16, which trigger the handler on lines 8-11. This causes value tuples containing fib (0) and fib (1) to be sent to calcfib [1] through calcfib <ref> [3] </ref>. These in turn produce value tuples, which are received by the handler on lines 5-7, are forwarded as fib eq tuples to the handler on lines 8-11, which again feeds them back to the calcfib agents as value tuples.
Reference: 4. <author> A. A. Chien. </author> <title> Concurrent Aggregates: Supporting Modularity in Massively-Parallel Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: This will become an increasingly onerous burden as we seek higher levels of performance and ease of use through smarter compilers. To solve these problems, we advocate the use of language features that enable direct representation of the structure of the dataflow graph. 1 The "aggregates" in Concurrent Aggregates <ref> [4] </ref> are vectors, the "branch offices" in Charm [10] are vectors, the "replicated nodes" in TDFL [15] are vectors, etc. 1.2 Programming: Trying to Express Problem Structure Optimizers benefit from clear expression of the problem structure. But perhaps more importantly, the programmer benefits as well. <p> The begin tuples, since they are not handled, cause no effect other than to wake up the agents to which they are sent. Note that the fib agent is serving as a dispatcher for large numbers of messages. As pointed out by Chien <ref> [4] </ref>, any individual object acting as a dispatcher or interface for a large number of other objects can be a bottleneck. <p> Agents also extends the Petri net model, however, it extends it in a manner specifically designed to handle arbitrary problem structures: it allows arbitrarily-sized networks, having arbitrarily large numbers of arcs, with arbitrary connectivity. One parallel programming system, Concert <ref> [4] </ref>, attempts to predict inter-object data relationships despite its programming model, in which every structure must either be built dynamically of linked objects or mapped onto a vector of objects. As a result, Concert relies on sophisticated techniques to extract structural knowledge about linked structures [12].
Reference: 5. <author> A. A. Chien, M. Straka, J. Dolby, V. Karamcheti, J. Plevyak, and X. Zhang. </author> <title> A case study in irregular parallel programming. </title> <booktitle> DIMACS Workshop on the Specification of Parallel Agorithms, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: It might be possible to express this recursive algorithm concurrently using arrays, do-loops, and barrier synchronization. However, doing so would require transformations which, as other researchers have noted, tend to leave the actual problem structure completely obscured <ref> [5] </ref>. The program would run in parallel (perhaps with poor speedups), but only because humans gritted their teeth and did the necessary convoluted analyses on behalf of the compiler. However, the data-parallel languages are by no means the only ones that tend to distort problem structures.
Reference: 6. <author> I. Foster, B. Avalani, A. Choudhary, and M. Xu. </author> <title> A compilation system that integrates high performance fortran and fortran M. </title> <booktitle> In Proceedings 1994 Scalable High Performance Computing Conference, </booktitle> <year> 1994. </year>
Reference-contexts: We term these languages the "agglomerate" languages. Such languages seem to be quite popular right now: consider Charm [10], HPC++ [2] [3], and HPF+Fortran-M <ref> [6] </ref>. By includ-ing different constructs for different problem structures, these languages aim to support a broader class of problems than their predecessors. Some would say that designers of agglomerate languages are haphazardly adding constructs, each of which is only useful for one problem structure.
Reference: 7. <author> David Gelernter, Nicholas Carriero, S. Chandran, , and Silva Chang. </author> <title> Parallel programming in Linda. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages 255-263, </pages> <month> Aug </month> <year> 1985. </year>
Reference-contexts: Also importantly, compiler technology for data-parallel languages is advancing by leaps and bounds, since it is possible to extract quite a bit of knowledge about the problem structure from the language constructs. Two parallel programming systems, Linda <ref> [7] </ref> and Distributed Memo [11], can represent data of arbitrary structure without mapping or distortion. Both have a globally-accessible storage space for data items wherein items can be accessed by name. In both languages, the naming scheme is infinite.
Reference: 8. <author> A. S. Grimshaw and J. W. Liu. </author> <title> Mentat: An object-oriented data-flow system. </title> <booktitle> Proceedings of the 1987 Object-Oriented Programming Systems, Languages and Applications Conference, </booktitle> <pages> pages 35-47, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Such concrete reassurance is offered by the linked data structures, which can obviously be connected into any shape imaginable. Therefore, linked structures promise to singlehandedly cover the entire space of possible problem shapes. 2.3 Object-Based Languages and Linked Structures Parallel Object-based languages (Actors [1], ABCL/1 [16], Mentat <ref> [8] </ref>, etc.) rely on linked data structures to represent problem structure. Linked data structures, because of their incredibly flexible shape, are the sequential programmer's tool of choice for clear representation of complicated shapes such as trees and graphs.
Reference: 9. <author> A. Gursoy and L.V. Kale. </author> <title> High-level support for divide-and-conquer parallelism. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <pages> pages 283-292. </pages>
Reference-contexts: The only case where such routing is not necessary is when an object is only connected to its parent and its children | in other words, in tree-structured problems. Indeed, the fact that pure objects seem to be best for tree-processing has been noted by other researchers <ref> [9] </ref>. Both limitations of linked structures are rooted in a single property: dynamic creation. Both can therefore be eliminated by doing away with dynamic creation.
Reference: 10. <author> L. V. Kale. </author> <title> The Chare Kernel parallel programming language and system. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 17-25, </pages> <year> 1990. </year>
Reference-contexts: To solve these problems, we advocate the use of language features that enable direct representation of the structure of the dataflow graph. 1 The "aggregates" in Concurrent Aggregates [4] are vectors, the "branch offices" in Charm <ref> [10] </ref> are vectors, the "replicated nodes" in TDFL [15] are vectors, etc. 1.2 Programming: Trying to Express Problem Structure Optimizers benefit from clear expression of the problem structure. But perhaps more importantly, the programmer benefits as well. <p> We now discuss the effects of such a philosophy. 2.2 Agglomerate Languages Many languages are being created containing a collection of constructs, each construct appropriate to a different problem structure. We term these languages the "agglomerate" languages. Such languages seem to be quite popular right now: consider Charm <ref> [10] </ref>, HPC++ [2] [3], and HPF+Fortran-M [6]. By includ-ing different constructs for different problem structures, these languages aim to support a broader class of problems than their predecessors. Some would say that designers of agglomerate languages are haphazardly adding constructs, each of which is only useful for one problem structure.
Reference: 11. <author> W. O'Connell, G. Thiruvathukal, and T. Christopher. </author> <title> Distributed Memo: A het-erogenously distributed parallel software development environment. </title> <booktitle> In Proceedings of the 23rd International Conference on Parallel Processing, </booktitle> <month> Aug </month> <year> 1994. </year>
Reference-contexts: Also importantly, compiler technology for data-parallel languages is advancing by leaps and bounds, since it is possible to extract quite a bit of knowledge about the problem structure from the language constructs. Two parallel programming systems, Linda [7] and Distributed Memo <ref> [11] </ref>, can represent data of arbitrary structure without mapping or distortion. Both have a globally-accessible storage space for data items wherein items can be accessed by name. In both languages, the naming scheme is infinite.
Reference: 12. <author> J. Plevyak, V. Karamcheti, and A. Chien. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <booktitle> Languages and Compilers for Parallel Machines, </booktitle> <year> 1993. </year>
Reference-contexts: Such work has seen some success, although only certain kinds of information are made available through these techniques. <ref> [12] </ref> The second flaw in linked structures is that they are quite difficult to con-struct concurrently. Consider the problem of adding a single object to an existing linked structure in such a way that the new object is accessible from (pointed to by) several old objects. <p> As a result, Concert relies on sophisticated techniques to extract structural knowledge about linked structures <ref> [12] </ref>. This is a significant accomplishment. However, we feel that the Concert programming model is not as expressive as it could be, given its requirement that all problems be mapped onto vectors or built from linked structures, and we feel that this limitation hinders both the programmer and the optimizer.
Reference: 13. <author> Lawrence Snyder. </author> <title> Introduction to the Poker programming environment. </title> <booktitle> Proceedings of the 1983 International Conference on Parallel Processing, </booktitle> <pages> pages 289-292, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Instead, we refer to languages that explicitly reveal their dataflow underpinnings at the language level. Probably the best examples of such languages are the visual dataflow languages like TDFL [15], PFG [14], and Poker <ref> [13] </ref>. These languages are loosely based on the Petri net programming model.
Reference: 14. <author> P. David Stotts. </author> <title> The PFG language: Visual programming for concurrent computation. </title> <booktitle> Proceedings of the 1988 International Conference on Parallel Processing, II, </booktitle> <address> Software:72-79, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Instead, we refer to languages that explicitly reveal their dataflow underpinnings at the language level. Probably the best examples of such languages are the visual dataflow languages like TDFL [15], PFG <ref> [14] </ref>, and Poker [13]. These languages are loosely based on the Petri net programming model.
Reference: 15. <author> Paul A. Suhler, Jit Biswas, and Kim M. Korner. TDFL: </author> <title> A task-level data flow language. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9(2), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: To solve these problems, we advocate the use of language features that enable direct representation of the structure of the dataflow graph. 1 The "aggregates" in Concurrent Aggregates [4] are vectors, the "branch offices" in Charm [10] are vectors, the "replicated nodes" in TDFL <ref> [15] </ref> are vectors, etc. 1.2 Programming: Trying to Express Problem Structure Optimizers benefit from clear expression of the problem structure. But perhaps more importantly, the programmer benefits as well. <p> Instead, we refer to languages that explicitly reveal their dataflow underpinnings at the language level. Probably the best examples of such languages are the visual dataflow languages like TDFL <ref> [15] </ref>, PFG [14], and Poker [13]. These languages are loosely based on the Petri net programming model.
Reference: 16. <author> A. Yonezawa, J.-P. Briot, and E. </author> <title> Shibayama. </title> <booktitle> Object-oriented concurrent programming in ABCL/1. ACM SIGPLAN Notices, Proceedings OOPSLA '86, </booktitle> <volume> 21(11) </volume> <pages> 258-268, </pages> <month> Nov </month> <year> 1986. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Such concrete reassurance is offered by the linked data structures, which can obviously be connected into any shape imaginable. Therefore, linked structures promise to singlehandedly cover the entire space of possible problem shapes. 2.3 Object-Based Languages and Linked Structures Parallel Object-based languages (Actors [1], ABCL/1 <ref> [16] </ref>, Mentat [8], etc.) rely on linked data structures to represent problem structure. Linked data structures, because of their incredibly flexible shape, are the sequential programmer's tool of choice for clear representation of complicated shapes such as trees and graphs.
References-found: 16

