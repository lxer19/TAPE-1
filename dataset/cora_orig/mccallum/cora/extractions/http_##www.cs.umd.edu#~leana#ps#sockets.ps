URL: http://www.cs.umd.edu/~leana/ps/sockets.ps
Refering-URL: http://www.cs.umd.edu/~leana/417/
Root-URL: 
Title: Berkeley UNIX System Calls and Interprocess Communication  
Author: by Lawrence Besaw by Marvin Solomon 
Keyword: int socket_descriptor, domain, type, protocol;  struct sockaddr  
Note: BSD Socket Reference Page 1  1.1. Domains The communication domain or address family to which a socket belongs specifies a certain address format. All later operations on a socket will interpret the supplied address according to this specified format. The various  short sa_family; address family char sa_data[14]; up to 14 bytes of direct address UNIX is a trademark of AT&T Bell Laboratories.  
Date: 640 Fall 1994  January, 1987 Revised, September 1987, January 1991  
Pubnum: CS  
Abstract: The purpose of this paper is to discuss interprocess communication in the context of Berkeley UNIX. Special emphasis will be given to those system calls concerned with the creation, management, and use of sockets. There will also be a discussion of signals and selected other system calls that will be useful to those working on the network project assigned for this course. More information on all the system calls mentioned below can be found in the UNIX Programmer's Manual. Periodic mention will be made of other manual page entries that might be consulted. System header files are designated by enclosing angle brackets; they reside in /usr/include and its subdirectories. The most general mechanism for interprocess communication offered by Berkeley UNIX is the socket. A socket is an endpoint for communication. Two processes can communicate by creating sockets and sending messages between them. There are a variety of different types of sockets, differing in the way the address space of the sockets is defined and the kind of communication that is allowed between sockets. A socket type is uniquely determined by a &lt;domain, type, protocol&gt; triple. In order for a remote socket to be reached, it must be possible to assign a name to it. The form that this name assumes is determined by the communication domain or address family to which the socket belongs. There is also an abstract type or style of communication associated with each socket. This dictates the semantics of communication for that socket. Finally, there is a specific protocol that is used with the socket. A socket can be created with the socket system call by specifying the desired address family, socket type, and protocol. This call returns a small positive integer called a socket descriptor that can be used as a parameter to reference the socket in subsequent system calls. Socket descriptors are similar to file descriptors returned by the open system call. Each open or socket call will return the smallest unused integer. Thus a given number denotes either an open file, a socket, or neither (but never both). Socket and file descriptors may be used interchangeably in many system calls. For example, the close system call is used to destroy sockets. address formats are defined as manifest constants in the file &lt;sys/socket.h&gt;. 1 Examples are AF_UNIX (UNIX path names), AF_INET (DARPA Internet addresses), and AF_OSI (as specified by the international standards for Open Systems Interconnection). AF_UNIX and AF_INET are the most important address families. The general form of an address is represented by the sockaddr structure defined in &lt;sys/socket.h&gt;. socket_descriptor = socket(domain, type, protocol)
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Hall, </author> <title> "The IPC Interface Under Berkeley Unit", </title> <institution> CS838 Handout #3, UW-Madison Computer Science Department, </institution> <month> April </month> <year> 1986. </year>
Reference-contexts: int nfound, bytesread; if (argc != 3) - (void) fprintf (stderr,"usage: %s service host"n",argv [0]); exit (1); - if ((sock = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) - perror ("socket"); exit (1); - if (isdigit (argv <ref> [1] </ref>[0])) - static struct servent s; servp = &s; s.s_port = htons ((u_short)atoi (argv [1])); else if ((servp = getservbyname (argv [1], "tcp")) == 0) - fprintf (stderr,"%s: unknown service"n",argv [1]); exit (1); - if ((hostp = gethostbyname (argv [2])) == 0) - fprintf (stderr,"%s: unknown host"n",argv [2]); exit (1); - memset ((void *) &server, 0, sizeof server); CS 640 Fall 1994 BSD Socket Reference <p> - (void) fprintf (stderr,"usage: %s service host"n",argv [0]); exit (1); - if ((sock = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) - perror ("socket"); exit (1); - if (isdigit (argv <ref> [1] </ref>[0])) - static struct servent s; servp = &s; s.s_port = htons ((u_short)atoi (argv [1])); else if ((servp = getservbyname (argv [1], "tcp")) == 0) - fprintf (stderr,"%s: unknown service"n",argv [1]); exit (1); - if ((hostp = gethostbyname (argv [2])) == 0) - fprintf (stderr,"%s: unknown host"n",argv [2]); exit (1); - memset ((void *) &server, 0, sizeof server); CS 640 Fall 1994 BSD Socket Reference Page 11 server.sin_family = AF_INET; memcpy ((void <p> (1); - if ((sock = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) - perror ("socket"); exit (1); - if (isdigit (argv <ref> [1] </ref>[0])) - static struct servent s; servp = &s; s.s_port = htons ((u_short)atoi (argv [1])); else if ((servp = getservbyname (argv [1], "tcp")) == 0) - fprintf (stderr,"%s: unknown service"n",argv [1]); exit (1); - if ((hostp = gethostbyname (argv [2])) == 0) - fprintf (stderr,"%s: unknown host"n",argv [2]); exit (1); - memset ((void *) &server, 0, sizeof server); CS 640 Fall 1994 BSD Socket Reference Page 11 server.sin_family = AF_INET; memcpy ((void *) &server.sin_addr, hostp-&gt;h_addr, hostp-&gt;h_length); server.sin_port = servp-&gt;s_port; if (connect <p> */ char buf [BUFSIZ]; if (argc != 2) - (void) fprintf (stderr,"usage: %s service"n",argv [0]); exit (1); - if ((request_sock = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) - perror ("socket"); exit (1); - if (isdigit (argv <ref> [1] </ref>[0])) - static struct servent s; servp = &s; s.s_port = htons ((u_short)atoi (argv [1])); else if ((servp = getservbyname (argv [1], "tcp")) == 0) - fprintf (stderr,"%s: unknown service"n"); exit (1); - memset ((void *) &server, sizeof server); server.sin_family = AF_INET; server.sin_addr.s_addr = INADDR_ANY; server.sin_port = servp-&gt;s_port; if (bind (request_sock, (struct sockaddr *)&server, sizeof server) &lt; 0) - perror ("bind"); exit (1); - if <p> 2) - (void) fprintf (stderr,"usage: %s service"n",argv [0]); exit (1); - if ((request_sock = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) - perror ("socket"); exit (1); - if (isdigit (argv <ref> [1] </ref>[0])) - static struct servent s; servp = &s; s.s_port = htons ((u_short)atoi (argv [1])); else if ((servp = getservbyname (argv [1], "tcp")) == 0) - fprintf (stderr,"%s: unknown service"n"); exit (1); - memset ((void *) &server, sizeof server); server.sin_family = AF_INET; server.sin_addr.s_addr = INADDR_ANY; server.sin_port = servp-&gt;s_port; if (bind (request_sock, (struct sockaddr *)&server, sizeof server) &lt; 0) - perror ("bind"); exit (1); - if (listen (request_sock, SOMAXCONN) &lt; 0) - perror
Reference: [2] <author> B.W. Kernighan and R. Pike, </author> <title> The UNIX Programming Environment, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1984. </year>
Reference-contexts: &lt; 0) - perror ("socket"); exit (1); - if (isdigit (argv [1][0])) - static struct servent s; servp = &s; s.s_port = htons ((u_short)atoi (argv [1])); else if ((servp = getservbyname (argv [1], "tcp")) == 0) - fprintf (stderr,"%s: unknown service"n",argv [1]); exit (1); - if ((hostp = gethostbyname (argv <ref> [2] </ref>)) == 0) - fprintf (stderr,"%s: unknown host"n",argv [2]); exit (1); - memset ((void *) &server, 0, sizeof server); CS 640 Fall 1994 BSD Socket Reference Page 11 server.sin_family = AF_INET; memcpy ((void *) &server.sin_addr, hostp-&gt;h_addr, hostp-&gt;h_length); server.sin_port = servp-&gt;s_port; if (connect (sock, (struct sockaddr *)&server, sizeof server) &lt; 0) - <p> if (isdigit (argv [1][0])) - static struct servent s; servp = &s; s.s_port = htons ((u_short)atoi (argv [1])); else if ((servp = getservbyname (argv [1], "tcp")) == 0) - fprintf (stderr,"%s: unknown service"n",argv [1]); exit (1); - if ((hostp = gethostbyname (argv <ref> [2] </ref>)) == 0) - fprintf (stderr,"%s: unknown host"n",argv [2]); exit (1); - memset ((void *) &server, 0, sizeof server); CS 640 Fall 1994 BSD Socket Reference Page 11 server.sin_family = AF_INET; memcpy ((void *) &server.sin_addr, hostp-&gt;h_addr, hostp-&gt;h_length); server.sin_port = servp-&gt;s_port; if (connect (sock, (struct sockaddr *)&server, sizeof server) &lt; 0) - (void) close (sock); perror ("connect"); exit (1); -
Reference: [3] <author> S.J Leffler, W.N. Joy, </author> <title> and M.K. McKusick, UNIX Programmer's Manual, </title> <institution> Computer Systems Research Group, Department of Electrical Engineering and Computer Science, University of California, Berkeley, </institution> <year> 1983. </year>
Reference: [4] <author> S. Sechrest, </author> <title> "Tutorial Examples of Interprocess Communication in Berkeley UNIX 4.2bsd", </title> <institution> Computer Systems Research Group, Department of Electrical Engineering and Computer Science, University of California, Berkeley, </institution> <year> 1984. </year>
References-found: 4

