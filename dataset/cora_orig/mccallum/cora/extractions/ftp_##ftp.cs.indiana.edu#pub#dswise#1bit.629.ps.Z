URL: ftp://ftp.cs.indiana.edu/pub/dswise/1bit.629.ps.Z
Refering-URL: http://www.cs.indiana.edu/l/www/classes/b629-memory/index.html
Root-URL: http://www.cs.indiana.edu
Title: The Three-Register Garbage Recycler, or Nodes for Free  
Author: David S. Wise 
Keyword: CR categories and Subject Descriptors: D.4.2 [Storage Management]: Allocation/Deallocation strategies; E.2 [Data Storage Representations]: Linked representations. General Term: Algorithms.  
Note: (abridged for B629)  
Address: Bloomington, Indiana 47405 USA  
Affiliation: Indiana University  
Pubnum: Technical Report 4XX  
Email: Email: dswise@cs.indiana.edu  
Phone: Fax: +1 (812) 855-4829  
Date: January 27, 1998  
Abstract: Stoye's one-bit reference tagging scheme can be extended to local counts of two with a cache of referents to the two shared references. The analog of Deutch's and Bobrow's multiple-reference table, this cache is sufficient to manage small counts across successive assignment statements without restrictions on uncounted references (dead pointers). Thus, accurate reference counts above one can be tracked for short intervals, like that bridging one function's environment to its successor's. Three registers then suffice for recycling nodes via processor-local operations without accessing the referenced memory, itself. fl c fl1998 by the author. This document is made available by the author as a means to ensure timely dissemination of scholarly and technical work on a non-commercial basis. Copyright and all other rights are maintained by the author or by other copyright holders, notwithstanding that they have offered their work electronically. It is understood that all persons copying this information will adhere to the terms and constraints invoked by the author's copyright. This work may not be reposted without the explicit permission of the copyright holder. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. G. Baker. </author> <title> Lively linear lisp|`Look Ma, </title> <journal> no garbage!' SIGPLAN Notices 27, </journal> <month> 8 (August </month> <year> 1992), </year> <pages> 89-98. </pages>
Reference: [2] <author> J. Barth. </author> <title> Shifting garbage collection overhead to compile time. </title> <journal> Comm. ACM 20, </journal> <month> 7 (July </month> <year> 1977), </year> <pages> 513-518. </pages>
Reference: [3] <author> T. Chikayama & Y. Kimura. </author> <title> Multiple reference management in flat GHC. </title> <editor> In J.-L. Lassez (ed.), </editor> <booktitle> Logic Programming, Proc. 4th Intl. Conf. 1. </booktitle> <address> Cambridge, MA: </address> <publisher> M.I.T. Press (1987), </publisher> <pages> 276-293. </pages>
Reference-contexts: The smallest possible reference count is a single bit [25, 18], also called the multiple-reference bit (MRB) <ref> [3, 12] </ref>. Of course, such a count distinguishes between only two values: unique and sticky, or 1 and &gt;. The original proposal for 1-bit reference counts [25] located the count at the referenced node.
Reference: [4] <author> D. W. Clark & C. C. Green. </author> <title> A note on shared list structure in Lisp. </title> <journal> Inf. Proc. Lett. </journal> <volume> 7, </volume> <month> 6 (October </month> <year> 1978), </year> <pages> 312-315. </pages>
Reference-contexts: Finally, more than one avail register is possible; one could be provided for each type of object. 3 Storage management. The focus of attention in reference-counting storage management [6] is on nodes that are uniquely referenced. Those are the ones that can soon be reallocated. Clark and Green <ref> [4] </ref> showed that there are lots of them. If the run-time system detects the release of those last references in real time, then they can be recycled on the spot. And|important to real-time systems|such notice can result from gathering purely local information. <p> In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures [17, 24, 26] leak away space, or after too small counters get stuck <ref> [4, 8] </ref>. Similarly, any counting that postpones garbage collection at the cost of a few local transactions makes collection more suitable to real-time and parallel performance; it improves the amortized cost of memory-cycles-per-allocated-node by increasing the number of nodes reallocated without additional memory cycles and by reusing memory locally.
Reference: [5] <author> J. Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> Comput Surveys 13, </journal> <month> 3 (September </month> <year> 1981), </year> <pages> 341-367. </pages>
Reference-contexts: Such a structure is the usual result of a garbage collection, but incrementally sustaining such nonlocal structures, itself, generates too much memory traffic for the goals of recycling. 1 I use Knuth's original terminology that distinguishes reference counting from garbage collection [14, p. 413]. Cohen <ref> [5] </ref> later merged both concepts under the latter term, and the generalization is now widespread [23, 13]. 2 As described, these algorithms allow each processor to recycle only one node at a time. One of its registers, avail, is dedicated to remembering the address of some single free node.
Reference: [6] <author> G. E. Collins. </author> <title> A method for overlapping and erasure of lists. </title> <journal> Comm. ACM 3, </journal> <month> 12 (December </month> <year> 1960), </year> <pages> 655-657. </pages>
Reference-contexts: Finally, more than one avail register is possible; one could be provided for each type of object. 3 Storage management. The focus of attention in reference-counting storage management <ref> [6] </ref> is on nodes that are uniquely referenced. Those are the ones that can soon be reallocated. Clark and Green [4] showed that there are lots of them. If the run-time system detects the release of those last references in real time, then they can be recycled on the spot.
Reference: [7] <author> D. Culler, R. Karp, D. Patterson, A. Sahay, K. E. Schauser, E. Santos, R. Subramonian, & T. von Eicken. </author> <title> LogP: a practical model of parallel computation. </title> <journal> Comm. ACM 39, </journal> <month> 11 (November </month> <year> 1996), </year> <pages> 78-85. </pages>
Reference-contexts: The friendly metaphor of ecological recycling implies an immediate reuse of freed space, to enhance locality. Locality of reference is important to speed cached and paged memories <ref> [7] </ref>, so compact structure and its reuse in situ is desirable. A familiar example of compaction from recycling is use of a sequential stack of frames for implementing nested function calls; popping the stack releases contiguous space for immediate reuse as environments terminate whenever a function returns.
Reference: [8] <author> L. P. Deutsch & D. G. Bobrow. </author> <title> An efficient, incremental, automatic garbage collector. </title> <journal> Comm. ACM 19, </journal> <month> 9 (September </month> <year> 1976), </year> <pages> 522-526. </pages>
Reference-contexts: In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures [17, 24, 26] leak away space, or after too small counters get stuck <ref> [4, 8] </ref>. Similarly, any counting that postpones garbage collection at the cost of a few local transactions makes collection more suitable to real-time and parallel performance; it improves the amortized cost of memory-cycles-per-allocated-node by increasing the number of nodes reallocated without additional memory cycles and by reusing memory locally.
Reference: [9] <author> R. Gillam. </author> <title> The anatomy of the assignment operator. C++ Report 9, </title> <booktitle> 10 (November-December 1997), </booktitle> <pages> 15-23. </pages>
Reference-contexts: In low-level languages like C, pointer assignment, p=q, is a simple integer 4 assignment. In C++, however, overloading the assignment operator for references to objects gets complicated <ref> [9] </ref>; one must deal with the former referent of p as it is dereferenced, as well as the either new or newly shared referent, q.
Reference: [10] <author> J.-Y. Girard. </author> <title> Linear logic. </title> <type> Theoret. </type> <institution> Comput. Sci. </institution> <month> 50 </month> <year> (1987), </year> <pages> 1-102. </pages>
Reference: [11] <author> D. Gries. </author> <title> An exercise in proving programs correct. </title> <journal> Comm. ACM 20, </journal> <month> 12 (December </month> <year> 1977), </year> <pages> 921-930. </pages>
Reference-contexts: Whatever the strategy, the storage manager is often called the collector (of the heap) to distinguish it from the user process or mutator (that changes linked structure) <ref> [11, pp. 923-924] </ref>. 4 Reference assignment. Two sorts or reference assignment are common in any system, and might be distinguished here. The first is a temporary assignment to ephemeral pointers, whose contents are unimportant to the integrity of any data structures.
Reference: [12] <author> Y. Inamura, N. Ichiyoshi, K. Rokusawa, & K. Nakajima. </author> <title> Optimization techniques using the MRB and their evaluation on the Multi-PSI/V2. </title> <editor> In E. L. Lusk & R. A. Overbeek, </editor> <booktitle> Logic Programming, Proc. of North American Conf. 1989 2, </booktitle> <address> Cambridge, MA: </address> <publisher> M.I.T. Press (1989), </publisher> <pages> 907-921. </pages>
Reference-contexts: These can be recognized as Thornton's threads [20, 14, 27] (a word now overloaded under multitasking), and have also been called "special" or "dead" pointers. Inamura et al. <ref> [12] </ref> use such dead links as the second reference necessary to logic programming. Assignment to dead pointers is not treated further here. The second type of assignment is to pointer variables, "live" links that hold data structures together and that, therefore, must be counted. <p> The smallest possible reference count is a single bit [25, 18], also called the multiple-reference bit (MRB) <ref> [3, 12] </ref>. Of course, such a count distinguishes between only two values: unique and sticky, or 1 and &gt;. The original proposal for 1-bit reference counts [25] located the count at the referenced node.
Reference: [13] <author> R. Jones & R. Lins. </author> <title> Garbage Collection. </title> <address> Chichester: </address> <publisher> Wiley (1996). </publisher>
Reference-contexts: Cohen [5] later merged both concepts under the latter term, and the generalization is now widespread <ref> [23, 13] </ref>. 2 As described, these algorithms allow each processor to recycle only one node at a time. One of its registers, avail, is dedicated to remembering the address of some single free node. If no nodes are known to be free, then it contains null.
Reference: [14] <author> D. E. </author> <title> Knuth The Art of Computer Programming I, Fundamental Algorithms (3rd ed.), </title> <address> Reading MA: </address> <publisher> Addison-Wesley (1997). </publisher> <pages> 10 </pages>
Reference-contexts: Such a structure is the usual result of a garbage collection, but incrementally sustaining such nonlocal structures, itself, generates too much memory traffic for the goals of recycling. 1 I use Knuth's original terminology that distinguishes reference counting from garbage collection <ref> [14, p. 413] </ref>. Cohen [5] later merged both concepts under the latter term, and the generalization is now widespread [23, 13]. 2 As described, these algorithms allow each processor to recycle only one node at a time. <p> They constitute another type of reference|one that the programmer explicitly declares to be redundant and, therefore, exempt from the attention of the storage manager. These can be recognized as Thornton's threads <ref> [20, 14, 27] </ref> (a word now overloaded under multitasking), and have also been called "special" or "dead" pointers. Inamura et al. [12] use such dead links as the second reference necessary to logic programming. Assignment to dead pointers is not treated further here.
Reference: [15] <author> H. R. Lewis & L. Dennenberg. </author> <title> Data Structures & Their Algorithms. </title> <address> New York: </address> <month> HarperCollins </month> <year> (1991). </year>
Reference-contexts: (q-&gt;refct)++; if (p-&gt;refct == 1) delete (p); else if (p-&gt;refct != stickyCount) (p-&gt;refct)--; p=q; These three steps proceed in just this order to allow evaluation of values for q that depend on the dying p, and to correctly handle assignments whose semantics is "p=p" where node p is uniquely referenced <ref> [15, p. 372 e.g.] </ref>. That is the count of greatest interest, and it is the focus of this paper. Assume below that the right side of the assignment, q has already been evaluated.
Reference: [16] <author> R. Plasmiejer & M. van Eekelen. </author> <title> Functional Programming and Parallel Graph Rewriting, </title> <address> Workingham, UK: </address> <publisher> Addison-Wesley (1993), x8.5. </publisher>
Reference: [17] <author> M. G. Sobel. </author> <title> A Practical Guide to the UNIX System (3rd ed.) </title> <address> Redwood City, CA: </address> <month> Benjamin/Cummings </month> <year> (1995), </year> <pages> 609-611. </pages>
Reference-contexts: In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures <ref> [17, 24, 26] </ref> leak away space, or after too small counters get stuck [4, 8].
Reference: [18] <author> W. R. Stoye, T. J. W. Clarke, & A. C. Norman. </author> <title> Some practical methods for rapid combinator reduction. </title> <booktitle> Conf. Rec. 1984 ACM Symp. on Lisp and Functional Programming, </booktitle> <pages> 159-166. </pages>
Reference-contexts: The smallest possible reference count is a single bit <ref> [25, 18] </ref>, also called the multiple-reference bit (MRB) [3, 12]. Of course, such a count distinguishes between only two values: unique and sticky, or 1 and &gt;. The original proposal for 1-bit reference counts [25] located the count at the referenced node. <p> Of course, such a count distinguishes between only two values: unique and sticky, or 1 and &gt;. The original proposal for 1-bit reference counts [25] located the count at the referenced node. A much better strategy <ref> [18] </ref> is to place this bit as a tag on each reference to the node|illustrated in the first two sketches of Figure 1| rather than at the node, itself. Although this needs another MRB bit in every reference, it saves the random fetch whenever that count is inspected.
Reference: [19] <author> N. Suzuki. </author> <title> Analysis of pointer `rotation.' </title> <journal> Comm. ACM 25, </journal> <month> 5 (May </month> <year> 1982), </year> <pages> 330-335. </pages>
Reference: [20] <author> A. J. Perlis & C. Thornton. </author> <title> Symbol manipulation by threaded lists. </title> <journal> Comm. ACM 3, </journal> <month> 4 (April </month> <year> 1960), </year> <pages> 195-204. </pages>
Reference-contexts: They constitute another type of reference|one that the programmer explicitly declares to be redundant and, therefore, exempt from the attention of the storage manager. These can be recognized as Thornton's threads <ref> [20, 14, 27] </ref> (a word now overloaded under multitasking), and have also been called "special" or "dead" pointers. Inamura et al. [12] use such dead links as the second reference necessary to logic programming. Assignment to dead pointers is not treated further here.
Reference: [21] <author> D. N. Turner & P. Wadler. </author> <title> Once upon a type. </title> <booktitle> Conf. Rec. of FPCA '95: Functional Programming Languages and Computer Architecture, </booktitle> <address> New York: </address> <publisher> ACM Press (1995), </publisher> <pages> 1-11. </pages>
Reference: [22] <author> J. Weizenbaum. </author> <title> Symmetric list processor. </title> <journal> Comm. ACM 6, </journal> <volume> 9 (Septem-ber 1963), </volume> <pages> 524-554. </pages>
Reference-contexts: Object ();" if (p-&gt;refct != 1)- 5 count of two. if (p-&gt;refct != stickyCount) (p-&gt;refct)--; p = new Object (); - The whole point of counting is to reuse space in situ like this! Other references inside the reused node will be handled later as they, themselves, are subsequently initialized/assigned <ref> [22, 26] </ref>. 5 One-bit reference counting. The smallest possible reference count is a single bit [25, 18], also called the multiple-reference bit (MRB) [3, 12]. Of course, such a count distinguishes between only two values: unique and sticky, or 1 and &gt;.
Reference: [23] <author> P. R. Wilson. </author> <title> Uniporcessor garbage collection techniques. </title> <editor> In Y. Bekkers & J. Cohen (eds.) </editor> <booktitle> Memory Management, LNCS 637, </booktitle> <address> Berlin: </address> <publisher> Springer (1992), </publisher> <pages> 1-42. </pages>
Reference-contexts: Cohen [5] later merged both concepts under the latter term, and the generalization is now widespread <ref> [23, 13] </ref>. 2 As described, these algorithms allow each processor to recycle only one node at a time. One of its registers, avail, is dedicated to remembering the address of some single free node. If no nodes are known to be free, then it contains null.
Reference: [24] <author> D. S. Wise. </author> <title> Stop-and-copy and one-bit reference counting. </title> <journal> Information Processing Lett. </journal> <volume> 46, </volume> <month> 5 (July </month> <year> 1993), </year> <pages> 243-249. </pages> <note> Also ftp://ftp.cs.indiana.edu/pub/techreports/TR360.ps.Z </note>
Reference-contexts: In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures <ref> [17, 24, 26] </ref> leak away space, or after too small counters get stuck [4, 8]. <p> The reference count on any node (e.g. referenced by p above) is known as soon as it becomes accessible, allowing it to be recycled without even touching it. Moreover, a recopying garbage collector <ref> [24] </ref> can easily correct sticky tags back to unique. The idea is that each newly "marked" node remembers the source of its first reference, as well as its unique forwarding address.
Reference: [25] <author> D. S. Wise & D. P. Friedman. </author> <title> The one-bit reference count. </title> <type> BIT 17, </type> <month> 3 (September </month> <year> 1977), </year> <pages> 351-359. </pages>
Reference-contexts: The smallest possible reference count is a single bit <ref> [25, 18] </ref>, also called the multiple-reference bit (MRB) [3, 12]. Of course, such a count distinguishes between only two values: unique and sticky, or 1 and &gt;. The original proposal for 1-bit reference counts [25] located the count at the referenced node. <p> The smallest possible reference count is a single bit [25, 18], also called the multiple-reference bit (MRB) [3, 12]. Of course, such a count distinguishes between only two values: unique and sticky, or 1 and &gt;. The original proposal for 1-bit reference counts <ref> [25] </ref> located the count at the referenced node. A much better strategy [18] is to place this bit as a tag on each reference to the node|illustrated in the first two sketches of Figure 1| rather than at the node, itself.
Reference: [26] <author> D. S. Wise, C. Hess, W. Hunt, & E. </author> <title> Ost. Research demonstration of a hardware reference-counting heap. </title> <journal> LISP & Symbolic Comp. </journal> <volume> 10, </volume> <month> 2 (July </month> <year> 1997), </year> <pages> 159-181. </pages>
Reference-contexts: In hybrid systems garbage collection remains important to the algorithms below, where reference counting and garbage collection complement each other in several ways. Garbage collection is used behind reference counting after cyclic structures <ref> [17, 24, 26] </ref> leak away space, or after too small counters get stuck [4, 8]. <p> Object ();" if (p-&gt;refct != 1)- 5 count of two. if (p-&gt;refct != stickyCount) (p-&gt;refct)--; p = new Object (); - The whole point of counting is to reuse space in situ like this! Other references inside the reused node will be handled later as they, themselves, are subsequently initialized/assigned <ref> [22, 26] </ref>. 5 One-bit reference counting. The smallest possible reference count is a single bit [25, 18], also called the multiple-reference bit (MRB) [3, 12]. Of course, such a count distinguishes between only two values: unique and sticky, or 1 and &gt;.
Reference: [27] <author> D. S. Wise & J. Walgenbach. </author> <title> Static and dynamic partitioning of pointers as links and threads. </title> <booktitle> Proc. 1996 ACM SIGPLAN Intl. Conf. on Functional Programming, SIGPLAN Notices 31, </booktitle> <month> 6 (June </month> <year> 1996), </year> <pages> 42-49. 11 </pages>
Reference-contexts: They constitute another type of reference|one that the programmer explicitly declares to be redundant and, therefore, exempt from the attention of the storage manager. These can be recognized as Thornton's threads <ref> [20, 14, 27] </ref> (a word now overloaded under multitasking), and have also been called "special" or "dead" pointers. Inamura et al. [12] use such dead links as the second reference necessary to logic programming. Assignment to dead pointers is not treated further here.
References-found: 27

