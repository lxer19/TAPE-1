URL: ftp://ftp.research.microsoft.com/users/rusa/popl96.ps
Refering-URL: http://www.research.microsoft.com/analysts/
Root-URL: http://www.research.microsoft.com
Email: rusa@research.microsoft.com  
Title: Points-to Analysis in Almost Linear Time  
Author: Bjarne Steensgaard 
Address: One Microsoft Way Redmond, WA 98052, USA  
Affiliation: Microsoft Research  
Abstract: We present an interprocedural flow-insensitive points-to analysis based on type inference methods with an almost linear time cost complexity. To our knowledge, this is the asymptotically fastest non-trivial interprocedural points-to analysis algorithm yet described. The algorithm is based on a non-standard type system. The type inferred for any variable represents a set of locations and includes a type which in turn represents a set of locations possibly pointed to by the variable. The type inferred for a function variable represents a set of functions it may point to and includes a type signature for these functions. The results are equivalent to those of a flow-insensitive alias analysis (and control flow analysis) that assumes alias relations are reflexive and transitive. This work makes three contributions. The first is a type system for describing a universally valid storage shape graph for a program in linear space. The second is a constraint system which often leads to better results than the obvious constraint system for the given type system. The third is an almost linear time algorithm for points-to analysis by solving a constraint system. 
Abstract-found: 1
Intro-found: 1
Reference: [ABS94] <author> Todd M. Austin, Scott E. Breach, and Gurindar S. Sohi. </author> <title> Efficient detection of all pointer and array access errors. </title> <booktitle> In SIGPLAN'94: Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 290-301, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Table 1, Table 2, and Table 3 illustrate the distribution of program variables per type variable for a number of benchmark programs. The programs are from Bill Landi's and Todd Austin's benchmark suites for their analyses <ref> [LRZ93, ABS94] </ref> as well as the SPEC'92 benchmark suite. LambdaMOO is a large C program available from Xerox PARC (we used version 1.7.1). Table 1 gives the raw distribution for the total analysis solution when performed on an (almost) unoptimized version of the program representation.
Reference: [And94] <author> Lars Ole Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Whether their work can be generalized to work for general imperative programs is an open question. Andersen defines context-sensitive and context-insensitive analyses that are flow-insensitive 4 points-to analysis in terms of constraints and constraint solving <ref> [And94] </ref>. The context-sensitive algorithm distinguishes between immediate calling contexts in a 1-limited version of the static program call graph, effectively taking two layers of context into consideration. The values being constrained are sets of abstract locations. Andersen's algorithm allows an abstract location to be a member of non-identical sets.
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ull-man. CompilersPrinciples, </author> <title> Techniques, and Tools. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Function calls have call-by-value semantics <ref> [ASU86] </ref>. Both formal and return parameter variables may appear in left-hand-side position in statements in the function body.
Reference: [BCCH95] <author> Michael Burke, Paul Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Proceedings from the 7th International Workshop on Languages and Compilers for Parallel Computing, volume 892 of Lecture Notes in Computer Science, </booktitle> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <note> Extended version published as Research Report RC 19546, </note> <institution> IBM T.J. Watson Research Center, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: In contrast, the size of the solution of our algorithm is O (N ). Choi et al. present both flow-sensitive and flow-insensitive analyses [CBC93]. The flow-insensitive analysis algorithm is described in more detail in <ref> [BCCH95] </ref>. Their algorithm computes alias information rather than points-to information but uses a representation that shares many properties with the storage shape graph. The representation allows abstract locations to be members of non-identical sets.
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: In contrast, the size of the solution of our algorithm is O (N ). Choi et al. present both flow-sensitive and flow-insensitive analyses <ref> [CBC93] </ref>. The flow-insensitive analysis algorithm is described in more detail in [BCCH95]. Their algorithm computes alias information rather than points-to information but uses a representation that shares many properties with the storage shape graph. The representation allows abstract locations to be members of non-identical sets.
Reference: [CR91] <editor> William Clinger and Jonathan Rees (editors). </editor> <title> Revised 4 report on the algorithmic language Scheme, </title> <month> November </month> <year> 1991. </year>
Reference-contexts: where N is the size of the input program (almost linear in the size of the input program). 6 Experience We have implemented a slightly improved version of the above algorithm in our prototype programming system based on the Value Dependence Graph [WCES94] and implemented in the programming language Scheme <ref> [CR91] </ref>. The implementation uses a weaker typing rule than presented above for primitive operations returning boolean values and uses predetermined transfer functions for direct calls of library functions (the algorithm is thus context-sensitive/polymorhpic for calls to library functions).
Reference: [CWZ90] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>). Most current compilers and programming tools use only in-traprocedural analyses, as the polynomial time and space complexity of the common data-flow based analyses prevents the use of interprocedural analyses for large programs. <p> The algorithm, which is inspired by Henglein's binding time analysis by type inference [Hen91], uses a non-standard type system to describe the store usage at runtime by using types to construct a storage shape graph <ref> [CWZ90] </ref>. While we describe the principles behind the algorithm in terms of types and typing rules, we also provide a detailed description of the algorithm which can be used almost directly to implement the algorithm in a compiler. <p> Locations of variables and locations created by dynamic allocation are all described by types. Each type describes a set of locations as well as the possible runtime contents of those locations. A type can be viewed as a node in a storage shape graph <ref> [CWZ90] </ref>. Each node may have edges to other nodes, which is modelled in the type system by letting types have type components. The storage shape graph may be cyclic for some programs, so the types may also be recursive. <p> His algorithm has a time cost complexity that is cubic in the size of the input program whereas our algorithm has an almost linear time cost complexity. More precise points-to analysis exist, e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>. These analyses are all flow-sensitive interprocedu-ral data flow analyses. Both Chase's algorithm [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. <p> His algorithm has a time cost complexity that is cubic in the size of the input program whereas our algorithm has an almost linear time cost complexity. More precise points-to analysis exist, e.g., [CWZ90, EGH94, WL95, Ruf95]. These analyses are all flow-sensitive interprocedu-ral data flow analyses. Both Chase's algorithm <ref> [CWZ90] </ref> and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive, meaning that the algorithm distinguishes between effects of different calls of the same function instead of computing just one effect that is valid for all calls of the function 3 .
Reference: [Deu92] <author> Alain Deutsch. </author> <title> A storeless model of aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 2-13. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: The most relevant alias analysis algorithms are [LR92, LRZ93]. The length of access-paths are k-limited, using a relatively simple truncation mechanism to eliminate extra path elements. Deutsch presents an alias analysis for an imperative subset of ML <ref> [Deu92] </ref>. Access paths are defined in terms of monomial relations (a kind of multi-variable polynomial expression with structure accessors as the variables).
Reference: [Deu94] <author> Alain Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In SIGPLAN'94: Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June 20-24 </month> <year> 1994. </year>
Reference-contexts: Access paths are defined in terms of monomial relations (a kind of multi-variable polynomial expression with structure accessors as the variables). The analysis is therefore only relevant for strongly typed languages such as ML and strongly typable programs written in weakly typed languages such as C (as shown in <ref> [Deu94] </ref>). Access paths are combined by unification. A higher order (context-sensitive) points-to analysis by type inference has been developed by Tofte and Talpin for the purposes of creating an ML interpreter without a garbage collector [TT94]. The analysis is based on polymorphic type inference over a nonstandard set of types.
Reference: [EGH94] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In SIGPLAN'94: Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June 20-24 </month> <year> 1994. </year>
Reference-contexts: Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>). Most current compilers and programming tools use only in-traprocedural analyses, as the polynomial time and space complexity of the common data-flow based analyses prevents the use of interprocedural analyses for large programs. <p> The set of types inferred for the variables of a program represents a storage shape graph which is valid at all program points. The storage shape graph conservatively models all the points-to relations that may hold at runtime. Alias relations can also be extracted from the storage shape graph <ref> [EGH94] </ref>. Our goal is a points-to analysis with an almost linear time cost complexity. The size of the storage shape graph represented by types must therefore be linear in the size of the input program. <p> His algorithm has a time cost complexity that is cubic in the size of the input program whereas our algorithm has an almost linear time cost complexity. More precise points-to analysis exist, e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>. These analyses are all flow-sensitive interprocedu-ral data flow analyses. Both Chase's algorithm [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. <p> The two other algorithms are context-sensitive, meaning that the algorithm distinguishes between effects of different calls of the same function instead of computing just one effect that is valid for all calls of the function 3 . The algorithm by Emami, et. al., <ref> [EGH94] </ref> has a exponential time complexity, as it performs a virtual unfolding of all non-recursive calls.
Reference: [Gri95] <author> William G. Griswold. </author> <title> Use of algorithm from [Ste95a] in a program restructuring tool. </title> <type> Personal communication at PLDI'95, </type> <month> June </month> <year> 1995. </year>
Reference-contexts: The analysis algorithm is routinely applied to the C programs processed by the system. Two implementations of an earlier type inference based points-to analysis algorithm [Ste95a] have been performed at University of California, San Diego; one in C [Mor95] and one in Scheme <ref> [Gri95] </ref>. Both implementations have been augmented to model slots of structured objects independently. Our earlier algorithm was based on the same non-standard type system as used in the present algorithm but used stricter typing rules, implying that the results are more conservative than they need be.
Reference: [Hen91] <author> Fritz Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <pages> pages 448-472, </pages> <year> 1991. </year>
Reference-contexts: The analysis results are often not as accurate as those obtained by flow-sensitive analyses. However, the results are roughly comparable to those of, e.g., the cubic time complexity flow insensitive analysis of [Wei80]. The algorithm, which is inspired by Henglein's binding time analysis by type inference <ref> [Hen91] </ref>, uses a non-standard type system to describe the store usage at runtime by using types to construct a storage shape graph [CWZ90]. <p> However, many programs use data structures such as trees and lists as central data structures. For these programs the inability to distinguish between structure elements is a serious loss. 7 Related work Henglein used type inference to perform a binding time analysis in almost linear time <ref> [Hen91] </ref>. His types represent binding time values. He presents a set of typing rules, extract constraints from the typing rules, and finally solve the constraints by using fast union/find data structures. Our points-to analysis algorithm was inspired by Henglein's type inference algorithm.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language, Second edition. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Modern optimizing compilers and program understanding and browsing tools for pointer languages such as C <ref> [KR88] </ref> are dependent on semantic information obtained by either an alias analysis or a points-to analysis. Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., [CWZ90, EGH94, WL95, Ruf95]). <p> In Section 7 we describe related work, and in Section 8 we present our conclusions and point out directions for future work. 2 The source language We describe the points-to analysis for a small imperative pointer language which captures the important properties of languages like C <ref> [KR88] </ref>. The language includes pointers to locations, pointers to functions, dynamic allocation, and computing addresses of variables. Since the analysis is flow insensitive, the control structures of the language are irrelevant. The abstract syntax of the relevant statements of the language is shown in Figure 1. <p> Since the analysis is flow insensitive, the control structures of the language are irrelevant. The abstract syntax of the relevant statements of the language is shown in Figure 1. The syntax for computing the addresses of variables and for pointer indirection is borrowed from the C programming language <ref> [KR88] </ref>. All variables are assumed to have unique names. The op (: : : ) expression form is used to describe primitive computations such as arithmetic operations and computing offsets into aggregate objects. The allocate (y) expression dynamically allocates a block of memory of size y.
Reference: [Lan95] <author> William Landi. </author> <title> Almost linear time points-to analyses. </title> <type> Personal communication at POPL'95, </type> <month> January </month> <year> 1995. </year>
Reference-contexts: The algorithm presented in this paper is an extension of another almost linear points-to analysis algorithm [Ste95a]. Bill Landi has independently arrived at the same earlier algorithm <ref> [Lan95] </ref>.
Reference: [LR92] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Modern optimizing compilers and program understanding and browsing tools for pointer languages such as C [KR88] are dependent on semantic information obtained by either an alias analysis or a points-to analysis. Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., <ref> [LR92, LRZ93] </ref>). Points-to analyses compute a store model using abstract locations (e.g., [CWZ90, EGH94, WL95, Ruf95]). Most current compilers and programming tools use only in-traprocedural analyses, as the polynomial time and space complexity of the common data-flow based analyses prevents the use of interprocedural analyses for large programs. <p> Whereas a points-to analysis builds and maintains a model of the store during analysis, an alias analysis builds and maintains a list of access path expressions that may evaluate to the same location (in other words: they are aliased). The most relevant alias analysis algorithms are <ref> [LR92, LRZ93] </ref>. The length of access-paths are k-limited, using a relatively simple truncation mechanism to eliminate extra path elements. Deutsch presents an alias analysis for an imperative subset of ML [Deu92].
Reference: [LRZ93] <author> William A. Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Modern optimizing compilers and program understanding and browsing tools for pointer languages such as C [KR88] are dependent on semantic information obtained by either an alias analysis or a points-to analysis. Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., <ref> [LR92, LRZ93] </ref>). Points-to analyses compute a store model using abstract locations (e.g., [CWZ90, EGH94, WL95, Ruf95]). Most current compilers and programming tools use only in-traprocedural analyses, as the polynomial time and space complexity of the common data-flow based analyses prevents the use of interprocedural analyses for large programs. <p> Table 1, Table 2, and Table 3 illustrate the distribution of program variables per type variable for a number of benchmark programs. The programs are from Bill Landi's and Todd Austin's benchmark suites for their analyses <ref> [LRZ93, ABS94] </ref> as well as the SPEC'92 benchmark suite. LambdaMOO is a large C program available from Xerox PARC (we used version 1.7.1). Table 1 gives the raw distribution for the total analysis solution when performed on an (almost) unoptimized version of the program representation. <p> Whereas a points-to analysis builds and maintains a model of the store during analysis, an alias analysis builds and maintains a list of access path expressions that may evaluate to the same location (in other words: they are aliased). The most relevant alias analysis algorithms are <ref> [LR92, LRZ93] </ref>. The length of access-paths are k-limited, using a relatively simple truncation mechanism to eliminate extra path elements. Deutsch presents an alias analysis for an imperative subset of ML [Deu92].
Reference: [Mor95] <author> David Morgenthaler. </author> <note> Poster presentation at PLDI'95, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: The analysis algorithm is routinely applied to the C programs processed by the system. Two implementations of an earlier type inference based points-to analysis algorithm [Ste95a] have been performed at University of California, San Diego; one in C <ref> [Mor95] </ref> and one in Scheme [Gri95]. Both implementations have been augmented to model slots of structured objects independently. <p> Counting only the extra time for performing the analysis, emacs (127,000 non-empty lines of code) could be analyzed in approximately 50 seconds, and FElt (273,000 non-empty lines of code) could be analyzed in approximately 82 seconds on a SparcStation 10 <ref> [Mor95] </ref>. The present algorithm can also easily be implemented to process the statements during parsing. The running times of the previous and the present algorithm are roughly the same (only minor fluctuations).
Reference: [Ruf95] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>). Most current compilers and programming tools use only in-traprocedural analyses, as the polynomial time and space complexity of the common data-flow based analyses prevents the use of interprocedural analyses for large programs. <p> His algorithm has a time cost complexity that is cubic in the size of the input program whereas our algorithm has an almost linear time cost complexity. More precise points-to analysis exist, e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>. These analyses are all flow-sensitive interprocedu-ral data flow analyses. Both Chase's algorithm [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. <p> More precise points-to analysis exist, e.g., [CWZ90, EGH94, WL95, Ruf95]. These analyses are all flow-sensitive interprocedu-ral data flow analyses. Both Chase's algorithm [CWZ90] and Ruf's algorithm <ref> [Ruf95] </ref> are context-insensitive and have polynomial time complexity. The two other algorithms are context-sensitive, meaning that the algorithm distinguishes between effects of different calls of the same function instead of computing just one effect that is valid for all calls of the function 3 .
Reference: [Ste95a] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <type> Technical Report MSR-TR-95-08, </type> <institution> Microsoft Research, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Previous work has used this typing rule for simple assignment <ref> [Ste95a] </ref>. The above typing rule is, however, too strict. This is illustrated by the following sequence of statements: a = 4 y = a Using the above rule, the content components of the types for a, x, and y must all be the same. <p> The analysis algorithm is routinely applied to the C programs processed by the system. Two implementations of an earlier type inference based points-to analysis algorithm <ref> [Ste95a] </ref> have been performed at University of California, San Diego; one in C [Mor95] and one in Scheme [Gri95]. Both implementations have been augmented to model slots of structured objects independently. <p> The algorithm presented in this paper is an extension of another almost linear points-to analysis algorithm <ref> [Ste95a] </ref>. Bill Landi has independently arrived at the same earlier algorithm [Lan95].
Reference: [Ste95b] <author> Bjarne Steensgaard. </author> <title> Sparse functional stores for imperative programs. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representations (IR'95), </booktitle> <pages> pages 62-70, </pages> <address> San Francisco, CA, </address> <month> January 22 </month> <year> 1995. </year> <note> Proceedings appear as March 1995 issue of SIGPLAN Notices. </note>
Reference-contexts: The results from the algorithm presented in the present paper can be used to prime a data flow analysis algorithm or otherwise reduce the amount of work to be done by the algorithm. One possible method is splitting of functional stores as suggested in <ref> [Ste95b] </ref>. Another way to obtain improved results is to develop an efficient flow-insensitive, context-sensitive algorithm. This can be done using types to represent sets of locations, as in the almost linear time algorithm, but using polymorphic instead of monomorphic type inference methods. We are currently pursuing both directions of research.
Reference: [Tar83] <author> Robert E. Tarjan. </author> <title> Data structures and network flow algorithms. </title> <booktitle> In Regional Conference Series in Applied Mathematics, volume CMBS 44 of Regional Conference Series in Applied Mathematics. </booktitle> <publisher> SIAM, </publisher> <year> 1983. </year>
Reference-contexts: The cost of performing join operations is a constant plus the cost of ECR find operations. The average cost of N ECR find operations are O (N ff (N; N )), where ff is a (very slowly increasing) inverse Ackermann's function <ref> [Tar83] </ref>.
Reference: [TT94] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementation of the typed call-by-value -calculus using a stack of regions. </title> <booktitle> In Proceedings 21st SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Access paths are combined by unification. A higher order (context-sensitive) points-to analysis by type inference has been developed by Tofte and Talpin for the purposes of creating an ML interpreter without a garbage collector <ref> [TT94] </ref>. The analysis is based on polymorphic type inference over a nonstandard set of types. They assume a runtime model that makes allocation regions explicit, where allocation regions resemble the storage shape graph nodes of our algorithm.
Reference: [WCES94] <author> Daniel Weise, Roger F. Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Proceedings 21st SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-310, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: is consequently O (N ff (N; N )), where N is the size of the input program (almost linear in the size of the input program). 6 Experience We have implemented a slightly improved version of the above algorithm in our prototype programming system based on the Value Dependence Graph <ref> [WCES94] </ref> and implemented in the programming language Scheme [CR91]. The implementation uses a weaker typing rule than presented above for primitive operations returning boolean values and uses predetermined transfer functions for direct calls of library functions (the algorithm is thus context-sensitive/polymorhpic for calls to library functions). <p> They do not necessarily represent all the program variables that are pointed to in the program, as minor optimizations are performed on the VDG program representation as it is being built; some of these optimizations eliminate storing values in variables if this is trivial to avoid, as described in <ref> [WCES94] </ref>. The number of type variables describing more than one program location is reduced relative to Table 1. The reduction is mostly caused by eliminating type variables for values passed to functions but never pointed to by a pointer.
Reference: [Wei80] <author> William E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <booktitle> In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: The algorithm is easily applicable to programs with many hundreds of thousands of lines of code. The analysis results are often not as accurate as those obtained by flow-sensitive analyses. However, the results are roughly comparable to those of, e.g., the cubic time complexity flow insensitive analysis of <ref> [Wei80] </ref>. The algorithm, which is inspired by Henglein's binding time analysis by type inference [Hen91], uses a non-standard type system to describe the store usage at runtime by using types to construct a storage shape graph [CWZ90]. <p> He presents a set of typing rules, extract constraints from the typing rules, and finally solve the constraints by using fast union/find data structures. Our points-to analysis algorithm was inspired by Henglein's type inference algorithm. The points-to analysis that closest resembles our analysis is Weihl's <ref> [Wei80] </ref>. His analysis is also flow-insensitive, interpro-cedural, and deals with pointers to functions.
Reference: [WL95] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In SIG-PLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Alias analyses compute pairs of expressions (or access paths) that may be aliased (e.g., [LR92, LRZ93]). Points-to analyses compute a store model using abstract locations (e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>). Most current compilers and programming tools use only in-traprocedural analyses, as the polynomial time and space complexity of the common data-flow based analyses prevents the use of interprocedural analyses for large programs. <p> His algorithm has a time cost complexity that is cubic in the size of the input program whereas our algorithm has an almost linear time cost complexity. More precise points-to analysis exist, e.g., <ref> [CWZ90, EGH94, WL95, Ruf95] </ref>. These analyses are all flow-sensitive interprocedu-ral data flow analyses. Both Chase's algorithm [CWZ90] and Ruf's algorithm [Ruf95] are context-insensitive and have polynomial time complexity. <p> The algorithm by Emami, et. al., [EGH94] has a exponential time complexity, as it performs a virtual unfolding of all non-recursive calls. The algorithm by Wilson and Lam <ref> [WL95] </ref> also has exponential time complexity but is likely to exhibit polynomial time complexity in practice as it uses partial transfer functions to summarize the behavior of already analyzed functions and procedures.
Reference: [Zha95] <author> Sean Zhang. </author> <note> Poster presentation at PLDI'95, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: Bill Landi has independently arrived at the same earlier algorithm [Lan95]. Bar-bara Ryder and Sean Zhang are also working on a version of the earlier algorithm with the extension that elements of composite objects are represented by separate type components <ref> [Zha95] </ref>. 8 Conclusion and Future Work We have presented a flow-insensitive, interprocedural, context-insensitive points-to analysis based on type inference methods with an almost linear time complexity.
References-found: 26

