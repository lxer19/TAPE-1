URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3489/3489.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: Configuration-Level Programming of Distributed Applications Using Implicit Invocation  
Author: Chen Chen 
Address: College Park, MD 20742  
Affiliation: Computer Science Department University of Maryland  
Abstract: An event-based distributed application is a group of software components interacting with each other by producing events that in turn trigger the invocation of procedures. In this work, we are concerned with the technology and methods for integrating an event-based application, whether that application is being constructed from scratch or synthesized from existing systems. Developing an event-based application is a complex task for programmers, who must address several issues not found in traditional systems and, currently, must do so without much assistance. These issues include event declaration, structure, binding, and naming. Our objective is to provide the same software engineering benefits to programmers of event-based applications as are currently provided to programmers of applications using traditional RPC or message-passing mechanisms. In this work, we broaden the technology for integration to encompass event-based programming. A method is described for separating event interaction properties from the implementation of the application modules so that system integration can be performed using only the abstractions. Then based upon the abstract aggregate, all interface software needed to validly implement the system can be generated automatically. A software bus model has been enhanced to accommodate the models which drive event-based distributed applications. In this way, designers may define complex event-based interactions abstractly, thus making it easier to integrate and experiment with event-based distributed applications. This paper is the author's PhD dissertation, as supervised by James M. Purtilo. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Barrett, L. Clarke, P. Tarr. </author> <title> "An Event-Based Software Integration Framework," </title> <type> Technical Report UM-94-47, </type> <institution> Computer Science Department, University of Massachusetts, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: In order to achieve a better level of event granularity, each operation needs a unique command-line interface. There are also efforts to formalize design spaces of implicit invocation mechanisms and event-based software integration frameworks [17] <ref> [1] </ref>. The goal of such research is to identify common properties of these systems so that researchers can reason about the properties of certain systems as well as the relationships among different systems. <p> It is difficult to facilitate interoperation among different integration mechanisms, because as yet there is no consistent model for describing existing event-based integration framework. Barrett et al. at University of Massachusetts attempt to address this problem by specifying a generic, event-based integration framework <ref> [1] </ref>. They provide an abstract data type based model for discussing and comparing event-based integration approaches. They intend to explore issues of interoperability and examine the extent to which the model can be used directly to support interoperability. <p> It flattens the record structure, constructs an array, and rearranges the order of the coordinates. The clause map VEAR obj (point: integer [3]) to VE3D ext obj (string (`liz'); point [2]; point <ref> [1] </ref>; point [0]) to VE2D ext obj (string (`liz'); fpoint [2]; point [1]; point [0]g) to VE2D ext obj xy (string (`liz'); fpoint [2]; point [1]g) to VE2D ext obj yz (string (`liz'); fpoint [1]; point [0]g) to VE2D ext obj xz (string (`liz'); fpoint [2]; point [0]g) maps event obj <p> It flattens the record structure, constructs an array, and rearranges the order of the coordinates. The clause map VEAR obj (point: integer [3]) to VE3D ext obj (string (`liz'); point [2]; point <ref> [1] </ref>; point [0]) to VE2D ext obj (string (`liz'); fpoint [2]; point [1]; point [0]g) to VE2D ext obj xy (string (`liz'); fpoint [2]; point [1]g) to VE2D ext obj yz (string (`liz'); fpoint [1]; point [0]g) to VE2D ext obj xz (string (`liz'); fpoint [2]; point [0]g) maps event obj in VEAR to five events: 1. <p> clause map VEAR obj (point: integer [3]) to VE3D ext obj (string (`liz'); point [2]; point <ref> [1] </ref>; point [0]) to VE2D ext obj (string (`liz'); fpoint [2]; point [1]; point [0]g) to VE2D ext obj xy (string (`liz'); fpoint [2]; point [1]g) to VE2D ext obj yz (string (`liz'); fpoint [1]; point [0]g) to VE2D ext obj xz (string (`liz'); fpoint [2]; point [0]g) maps event obj in VEAR to five events: 1. Event ext obj in VE3D consists of a string initialized to `liz', followed by three integers of event obj. <p> It flattens the array structure, constructs a record structure, and rearranges the order of the two integers. The second element of the array point <ref> [1] </ref> is masked out. 5.3 Integration Figures C.1 through C.7 show the production graph for the VE3D/VE2D/VEAR example.
Reference: [2] <author> B. Bershad, D. Ching, E. Lazowska, J. Sanislo and M. Schwartz. </author> <title> "A Remote Procedure Call Facility for Interconnecting Heterogeneous Computer Systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 13, </volume> <pages> pp. 880-894, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: It flattens the record structure, constructs an array, and rearranges the order of the coordinates. The clause map VEAR obj (point: integer [3]) to VE3D ext obj (string (`liz'); point <ref> [2] </ref>; point [1]; point [0]) to VE2D ext obj (string (`liz'); fpoint [2]; point [1]; point [0]g) to VE2D ext obj xy (string (`liz'); fpoint [2]; point [1]g) to VE2D ext obj yz (string (`liz'); fpoint [1]; point [0]g) to VE2D ext obj xz (string (`liz'); fpoint [2]; point [0]g) maps <p> It flattens the record structure, constructs an array, and rearranges the order of the coordinates. The clause map VEAR obj (point: integer [3]) to VE3D ext obj (string (`liz'); point <ref> [2] </ref>; point [1]; point [0]) to VE2D ext obj (string (`liz'); fpoint [2]; point [1]; point [0]g) to VE2D ext obj xy (string (`liz'); fpoint [2]; point [1]g) to VE2D ext obj yz (string (`liz'); fpoint [1]; point [0]g) to VE2D ext obj xz (string (`liz'); fpoint [2]; point [0]g) maps event obj in VEAR to five events: 1. <p> The clause map VEAR obj (point: integer [3]) to VE3D ext obj (string (`liz'); point <ref> [2] </ref>; point [1]; point [0]) to VE2D ext obj (string (`liz'); fpoint [2]; point [1]; point [0]g) to VE2D ext obj xy (string (`liz'); fpoint [2]; point [1]g) to VE2D ext obj yz (string (`liz'); fpoint [1]; point [0]g) to VE2D ext obj xz (string (`liz'); fpoint [2]; point [0]g) maps event obj in VEAR to five events: 1. <p> (string (`liz'); point <ref> [2] </ref>; point [1]; point [0]) to VE2D ext obj (string (`liz'); fpoint [2]; point [1]; point [0]g) to VE2D ext obj xy (string (`liz'); fpoint [2]; point [1]g) to VE2D ext obj yz (string (`liz'); fpoint [1]; point [0]g) to VE2D ext obj xz (string (`liz'); fpoint [2]; point [0]g) maps event obj in VEAR to five events: 1. Event ext obj in VE3D consists of a string initialized to `liz', followed by three integers of event obj. It flattens the array structure and rearranges the order of the three integers. 67 2. <p> It flattens the array structure, constructs a record structure, and rearranges the order of the two integers. The third element of the array point <ref> [2] </ref> is masked out. 5. Event ext obj xz in VE2D consists of a string initialized to `liz', followed by a record consisting of the third and first elements of event obj. It flattens the array structure, constructs a record structure, and rearranges the order of the two integers.
Reference: [3] <author> J. Bloch. </author> <title> "The Camelot library: C Language Extensions for Programming General Purpose Distributed Transaction Systems," </title> <booktitle> Proceedings of the 9th Conference on Distributed Computing Systems, </booktitle> <pages> pp. 172-180, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: When the complexity of building a large program became too great, our research field quickly shifted to building systems of smaller components instead. This was enabled by the use of module interconnection languages and by technology for integrating those components <ref> [3] </ref> [5] [12] [28] [35] [41]. In particular, software packaging [4] | that is, reasoning about compatibility of software modules in order to determine valid means for integrating and interconnecting them | has been successful in simplifying system design and implementation, with all the benefits widely known about modular programs. <p> The event structures of obj and ext obj in the VEAR are different from those of VE3D and VE2D. For example, event obj in VEAR is defined to be an array of three integers: obj (point:integer <ref> [3] </ref>) and event ext obj is defined to be a string followed by an array of three integers: ext obj (name:string; point:integer [3]) There are numerous ways in which the three applications can interact. <p> For example, event obj in VEAR is defined to be an array of three integers: obj (point:integer <ref> [3] </ref>) and event ext obj is defined to be a string followed by an array of three integers: ext obj (name:string; point:integer [3]) There are numerous ways in which the three applications can interact. We study the possible interactions among them and discuss how to capture the interaction in the specifications. First, we study the possible interactions at the configuration level or application level. <p> For example, event obj in VE3D is defined to be three integers: obj (x:integer; y:integer; z:integer) while in VEAR, its associated event ext obj is defined to be a string followed by an array of three integers: ext obj (name:string; point:integer <ref> [3] </ref>) and its matching event ext obj in VE2D is defined to be a string followed by a record consisting of three integers: ext obj (name:string; fx:integer; y:integer; z:integerg) Not only are the applications' event structures totally different, but the meaning of each coordinate is also different. <p> Event ext obj in VEAR consists of a string initialized to `jim', followed by an array of three integers of event obj. It flattens the record structure, constructs an array, and rearranges the order of the coordinates. The clause map VEAR obj (point: integer <ref> [3] </ref>) to VE3D ext obj (string (`liz'); point [2]; point [1]; point [0]) to VE2D ext obj (string (`liz'); fpoint [2]; point [1]; point [0]g) to VE2D ext obj xy (string (`liz'); fpoint [2]; point [1]g) to VE2D ext obj yz (string (`liz'); fpoint [1]; point [0]g) to VE2D ext obj
Reference: [4] <author> J. Callahan, J. Purtilo. </author> <title> "A Packaging System for Heterogeneous Execution Environments," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <pages> pp. 626-635, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This was enabled by the use of module interconnection languages and by technology for integrating those components [3] [5] [12] [28] [35] [41]. In particular, software packaging <ref> [4] </ref> | that is, reasoning about compatibility of software modules in order to determine valid means for integrating and interconnecting them | has been successful in simplifying system design and implementation, with all the benefits widely known about modular programs.
Reference: [5] <author> N. Carriero, D. Gelernter. </author> <title> "Linda in Context," </title> <journal> Communications of the ACM, </journal> <volume> vol. 32, </volume> <pages> pp. 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: When the complexity of building a large program became too great, our research field quickly shifted to building systems of smaller components instead. This was enabled by the use of module interconnection languages and by technology for integrating those components [3] <ref> [5] </ref> [12] [28] [35] [41]. In particular, software packaging [4] | that is, reasoning about compatibility of software modules in order to determine valid means for integrating and interconnecting them | has been successful in simplifying system design and implementation, with all the benefits widely known about modular programs.
Reference: [6] <author> C. Chen, A. Porter, J. Purtilo. </author> <title> "Tool Support for Tailored Software Prototyping," </title> <booktitle> Proceedings of the 3rd Symposium on Assessment of Quality Software Development Tools, </booktitle> <pages> pp. 171-181, </pages> <month> June </month> <year> 1994. </year>
Reference: [7] <author> C. Chen, J. Purtilo. </author> <title> "Configuration-level Programming of Distributed Applications Using Implicit Invocation," </title> <booktitle> Proceedings of IEEE Region 10's Annual International Conference, </booktitle> <pages> pp. 43-49, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: When there are different event naming systems and different event structures, we can map an event from one application to another. An earlier version of this language can only map events with different event names but the same event structures <ref> [7] </ref>, ENimble has advanced features for mapping events of different event structures. Figure 2.3 shows the composite interaction specification for the integrated VE3D/VE2D example. The application clauses enumerate the applications from which the composite application is built.
Reference: [8] <author> C. Chen, J. Purtilo. </author> <title> "Event Adaptation for Integrating Distributed Applications," </title> <booktitle> Proceedings of the 7th International Conference on Software Engineering and Knowledge Engineering, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: We have defined a composite interaction specification language called ENimble, which allows programmers to describe the way they want the existing applications to interact <ref> [8] </ref>. In this language, we specify applications from which the the composite application is built. Modules that no longer need to be in the composite application are identified. If there is a conflict between module names, we can rename the software modules.
Reference: [9] <author> C. Chen, E. White, J. Purtilo. </author> <title> "A Packager for Multicast Software in Distributed Systems," </title> <booktitle> Proceedings of the 5th International Conference on Software Engineering and Knowledge Engineering, </booktitle> <pages> pp. 612-621, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Distributed applications have been traditionally constructed out of modules that interact with each other by explicitly invoking procedures on named interfaces. Recently, however, software developers have shown increasing interest in an alternative integration technique, variously referred to as implicit invocation [16] [18], multicast <ref> [9] </ref>, or selective broadcast [38] [19]. The idea behind this integration technique is that instead of invoking a procedure directly on a named interface, events multicast by modules trigger the invocation of procedures.
Reference: [10] <author> E. Cooper. </author> <title> "Programming Language Support for Multicast Communication in Distributed System," </title> <booktitle> Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 450-457, </pages> <month> July </month> <year> 1990. </year> <month> 101 </month>
Reference: [11] <author> O. Dahl, K. Nygaard. </author> <title> "Simula An ALGOL Based Simulation Language," </title> <journal> Communications of ACM, </journal> <volume> Vol. 9, </volume> <pages> pp. 671-678, </pages> <year> 1966. </year>
Reference-contexts: These issues include event declaration, structure, binding, and also complexity in naming events used in communication. Several languages have been developed to enable programmers to build a single event-based program, intended to execute on one or a very small number of hosts <ref> [11] </ref> [18] [13] [27] [33] [39]. But a language-based approach does not scale up to systems of event-based components; where interaction among components is complex, application modules could be written in different programming languages and distributed across a network of possibly heterogeneous processors.
Reference: [12] <author> F. DeRemer, H. Kron. </author> <title> "Programming-in-the-Large Versus Programming-in-the-Small," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 2, </volume> <pages> pp. 80-86, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: When the complexity of building a large program became too great, our research field quickly shifted to building systems of smaller components instead. This was enabled by the use of module interconnection languages and by technology for integrating those components [3] [5] <ref> [12] </ref> [28] [35] [41]. In particular, software packaging [4] | that is, reasoning about compatibility of software modules in order to determine valid means for integrating and interconnecting them | has been successful in simplifying system design and implementation, with all the benefits widely known about modular programs.
Reference: [13] <author> P. Diviat, R. Villanueva, H. Markowitz. </author> <booktitle> "SIMSCRIPT II.5 Programming Language," </booktitle> <address> CACI, </address> <year> 1973. </year>
Reference-contexts: These issues include event declaration, structure, binding, and also complexity in naming events used in communication. Several languages have been developed to enable programmers to build a single event-based program, intended to execute on one or a very small number of hosts [11] [18] <ref> [13] </ref> [27] [33] [39]. But a language-based approach does not scale up to systems of event-based components; where interaction among components is complex, application modules could be written in different programming languages and distributed across a network of possibly heterogeneous processors.
Reference: [14] <author> B. Fromme. </author> <title> "HP Encapsulator: Bridging the Generation Gap," </title> <type> Technical Report SESD-89-26, </type> <institution> Hewlett-Packard Software Engineering Systems Division, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: As in Field, the SoftBench integration framework is also based on selective broadcast. The HP Encapsulator can build message-based application program interfaces to the tools <ref> [14] </ref>. To encapsulate a tool means to integrate it into the HP SoftBench architecture. The HP Encap-sulator does not require changes to the source code of the tools being encapsulated. It allows users to integrate tools for which no source code is available.
Reference: [15] <author> D. Garlan, R. Allen, J. Ockerbloom. </author> <title> "Architectural Mismatch or Why it's Hard to Build Systems out of Existing Parts," </title> <booktitle> Proceedings of the 17th International Conference on Software Engineering, </booktitle> <pages> pp. 179-185, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: By constructing new applications out of reusable software components, developers can build large, high-quality software applications using less time than building similar applications from scratch. These benefits led to a number of efforts to standardize component interaction [31] and to promote component-based software reuse <ref> [15] </ref> [44]. When programmers try to reuse software components, however, they cannot find exactly what they want; often such components need to be adapted before they can be reused. This is also the case when constructing event-based applications out of existing applications.
Reference: [16] <author> D. Garlan, E. Ilias. </author> <title> "Low-cost, Adaptable Tool Integration Policies for Integrated Environments," </title> <booktitle> Proceedings of SIGSOFT 4th Symposium on Software Development Environments, </booktitle> <pages> pp. 1-10, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Distributed applications have been traditionally constructed out of modules that interact with each other by explicitly invoking procedures on named interfaces. Recently, however, software developers have shown increasing interest in an alternative integration technique, variously referred to as implicit invocation <ref> [16] </ref> [18], multicast [9], or selective broadcast [38] [19]. The idea behind this integration technique is that instead of invoking a procedure directly on a named interface, events multicast by modules trigger the invocation of procedures. <p> These components interact with each other by multicasting events or messages. An agent implemented as a separate process is responsible for routing events through communication channels to the components. Examples are Field [38], Forest <ref> [16] </ref>, HP SoftBench [19], and Sun ToolTalk [26] [43]. Our work falls into the third category. Field [38] is a principal programming environment for teaching undergraduates. It is also a research programming environment and a testbed for developing new tools. <p> Since the interface software is part of the implementation, policies of when and how the tools are invoked are hand-coded in the program. Different tool interaction would require a change in the interface software. Forest is an extension of Field <ref> [16] </ref>. As in Field, Forest's tool integration framework is based on selective broadcast. Unlike Field, Forest separates policies of when and how the tools are invoked from what tools do when they are invoked, with the goal of allowing dynamic configurable policies of tool interaction.
Reference: [17] <author> D. Garlan, D. Notkin. </author> <title> "Formalizing Design Spaces: Implicit Invocation Mechanisms," </title> <booktitle> Proceedings of VDM'91: Formal Software Development Methods, </booktitle> <month> October, </month> <year> 1991. </year>
Reference-contexts: In order to achieve a better level of event granularity, each operation needs a unique command-line interface. There are also efforts to formalize design spaces of implicit invocation mechanisms and event-based software integration frameworks <ref> [17] </ref> [1]. The goal of such research is to identify common properties of these systems so that researchers can reason about the properties of certain systems as well as the relationships among different systems.
Reference: [18] <author> D. Garlan, C. Scott. </author> <title> "Adding Implicit Invocation to Traditional Programming Languages," </title> <booktitle> Proceedings of the 15th International Conference on Software Engineering, </booktitle> <pages> pp. 447-455, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Distributed applications have been traditionally constructed out of modules that interact with each other by explicitly invoking procedures on named interfaces. Recently, however, software developers have shown increasing interest in an alternative integration technique, variously referred to as implicit invocation [16] <ref> [18] </ref>, multicast [9], or selective broadcast [38] [19]. The idea behind this integration technique is that instead of invoking a procedure directly on a named interface, events multicast by modules trigger the invocation of procedures. <p> These issues include event declaration, structure, binding, and also complexity in naming events used in communication. Several languages have been developed to enable programmers to build a single event-based program, intended to execute on one or a very small number of hosts [11] <ref> [18] </ref> [13] [27] [33] [39]. But a language-based approach does not scale up to systems of event-based components; where interaction among components is complex, application modules could be written in different programming languages and distributed across a network of possibly heterogeneous processors. <p> These systems can be divided into three categories. The first category is based on special-purpose languages. Systems in this category use specialized notations and run-time support to access implicit invocation. The specialized notations are designed into the language from the start. Examples are given in <ref> [18] </ref>. The second category is adding implicit invocation to traditional programming languages, such as Ada [18], C++ [40], and Common Lisp [20]. The objective of work in this category is to make implicit invocation available in traditional programming languages without defining special-purpose mechanisms. <p> Systems in this category use specialized notations and run-time support to access implicit invocation. The specialized notations are designed into the language from the start. Examples are given in <ref> [18] </ref>. The second category is adding implicit invocation to traditional programming languages, such as Ada [18], C++ [40], and Common Lisp [20]. The objective of work in this category is to make implicit invocation available in traditional programming languages without defining special-purpose mechanisms. Notkin et al. [30] discuss design issues that arise when embedding implicit invocation in traditional programming languages. <p> Our discussion focuses on how the nature of a software bus influenced our design decisions. In the following discussion of each of the design issues, we first briefly introduce possible approaches as summarized by Garlan and Scott <ref> [18] </ref>; we then describe our approach and explain why this approach was chosen. * Event Declaration | fixed event vocabulary, static event declaration, dynamic event declaration, and no event declaration. A fixed event vocabulary allows programmers to use only a fixed set of events determined before the application is created.
Reference: [19] <author> C. Gerety. </author> <title> "A new Generation of Software Development Tools," </title> <type> Technical Report SESD-89-25, </type> <institution> Hewlett-Packard Software Engineering Systems Division, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: Distributed applications have been traditionally constructed out of modules that interact with each other by explicitly invoking procedures on named interfaces. Recently, however, software developers have shown increasing interest in an alternative integration technique, variously referred to as implicit invocation [16] [18], multicast [9], or selective broadcast [38] <ref> [19] </ref>. The idea behind this integration technique is that instead of invoking a procedure directly on a named interface, events multicast by modules trigger the invocation of procedures. <p> These components interact with each other by multicasting events or messages. An agent implemented as a separate process is responsible for routing events through communication channels to the components. Examples are Field [38], Forest [16], HP SoftBench <ref> [19] </ref>, and Sun ToolTalk [26] [43]. Our work falls into the third category. Field [38] is a principal programming environment for teaching undergraduates. It is also a research programming environment and a testbed for developing new tools.
Reference: [20] <author> W. Griswold, D. Notkin. </author> <title> "Automated Assistance for Program Restructuring," </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> July </month> <year> 1993. </year>
Reference-contexts: The specialized notations are designed into the language from the start. Examples are given in [18]. The second category is adding implicit invocation to traditional programming languages, such as Ada [18], C++ [40], and Common Lisp <ref> [20] </ref>. The objective of work in this category is to make implicit invocation available in traditional programming languages without defining special-purpose mechanisms. Notkin et al. [30] discuss design issues that arise when embedding implicit invocation in traditional programming languages.
Reference: [21] <author> C. Falkenberg, C. Hofmeister, C. Chen, E. White, J. Atlee, P. Hagger, and J. Purtilo. </author> <title> "The Polylith Interconnection System: Programming Manual for the Network Bus," </title> <institution> University of Maryland, College Park, </institution> <address> 3.0 edition, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: We use the Polylith Module Interconnection Language (MIL) [23] <ref> [21] </ref> to specify interfaces and attributes for each module; these specifications include the location of the executable code, the name of the host machine where it should run, and the interfaces of a module. <p> A detailed description of the multicast primitives is given in Appendix A and in the Polylith programming manual <ref> [21] </ref>. 3.1.2 The Database Example In this section, we introduce a database application in order to demonstrate the use of the multicast primitives.
Reference: [22] <author> S. Feldman. </author> <title> "Make: A Program for Maintaining Computer Programs," UNIX Programmer's Manual, </title> <booktitle> USENIX, </booktitle> <year> 1984. </year>
Reference: [23] <author> C. Hofmeister, J. Atlee and J. Purtilo. </author> <title> "Writing Distributed Programs in Polylith," </title> <institution> Dept of Computer Science, University of Maryland, CS-TR-2575, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: We use the Polylith Module Interconnection Language (MIL) <ref> [23] </ref> [21] to specify interfaces and attributes for each module; these specifications include the location of the executable code, the name of the host machine where it should run, and the interfaces of a module.
Reference: [24] <author> C. Hofmeister, E. White and J. Purtilo. "Surgeon: </author> <title> A Packager for Dynamically Reconfigurable Distributed Applications," </title> <journal> IEE Software Engineering Journal, </journal> <pages> pp. 95-101, </pages> <month> March </month> <year> 1993. </year>
Reference: [25] <author> J. Jones, R. Rashid, and M. Thompson. "Matchmaker: </author> <title> An Interface Specification Language for Distributed Processing," </title> <booktitle> Proceedings of the 12th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 225-235, </pages> <month> January </month> <year> 1985. </year> <month> 102 </month>
Reference: [26] <author> A. Julienne, L. Russell. </author> <title> "Why You Need ToolTalk," </title> <journal> SunEXPERT Magazine, </journal> <pages> pp. 51-58, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: These components interact with each other by multicasting events or messages. An agent implemented as a separate process is responsible for routing events through communication channels to the components. Examples are Field [38], Forest [16], HP SoftBench [19], and Sun ToolTalk <ref> [26] </ref> [43]. Our work falls into the third category. Field [38] is a principal programming environment for teaching undergraduates. It is also a research programming environment and a testbed for developing new tools.
Reference: [27] <author> D. Luckham, J. Vera. </author> <title> Event-based Concepts and Language for System Architecture. </title>
Reference-contexts: These issues include event declaration, structure, binding, and also complexity in naming events used in communication. Several languages have been developed to enable programmers to build a single event-based program, intended to execute on one or a very small number of hosts [11] [18] [13] <ref> [27] </ref> [33] [39]. But a language-based approach does not scale up to systems of event-based components; where interaction among components is complex, application modules could be written in different programming languages and distributed across a network of possibly heterogeneous processors.
Reference: [28] <author> J. Magee, J. Kramer and M. Sloman. </author> <title> "Constructing Distributed Systems in Conic," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 15, </volume> <pages> pp. 663-675, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: When the complexity of building a large program became too great, our research field quickly shifted to building systems of smaller components instead. This was enabled by the use of module interconnection languages and by technology for integrating those components [3] [5] [12] <ref> [28] </ref> [35] [41]. In particular, software packaging [4] | that is, reasoning about compatibility of software modules in order to determine valid means for integrating and interconnecting them | has been successful in simplifying system design and implementation, with all the benefits widely known about modular programs.
Reference: [29] <author> R. Nance. </author> <title> "Model Development Revisited," </title> <booktitle> Proceedings of 1984 Winter Simulation Conference, </booktitle> <pages> pp. 75-80, </pages> <year> 1984. </year>
Reference: [30] <author> D. Notkin, D. Garlan, W. Griswold, K. Sullivan. </author> <title> "Adding Implicit Invocation to Languages: Three Approaches", </title> <booktitle> Proceedings of the JSSST International Symposium on Object Technologies for Advanced Software, </booktitle> <month> November, </month> <year> 1993. </year>
Reference-contexts: The second category is adding implicit invocation to traditional programming languages, such as Ada [18], C++ [40], and Common Lisp [20]. The objective of work in this category is to make implicit invocation available in traditional programming languages without defining special-purpose mechanisms. Notkin et al. <ref> [30] </ref> discuss design issues that arise when embedding implicit invocation in traditional programming languages. Although the basic mechanisms have substantial similarities, the details differ significantly because of the natures of the underlying programming languages. The third category comprises systems which can be classified as integration frameworks. <p> These issues are event declaration, event structure, event bindings, multicast events, receive events, and concurrency. Garlan et al. discussed design considerations when adding implicit invocation to three traditional programming languages: Ada, C++, and Common Lisp <ref> [30] </ref>. Different design decisions were made because of the nature of the different languages. Our discussion focuses on how the nature of a software bus influenced our design decisions.
Reference: [31] <author> Object Management Group. </author> <title> "The Common Object Request Broker: Architecture and Specification," OMG Document Number 91.12.1, </title> <month> December </month> <year> 1991. </year>
Reference-contexts: By constructing new applications out of reusable software components, developers can build large, high-quality software applications using less time than building similar applications from scratch. These benefits led to a number of efforts to standardize component interaction <ref> [31] </ref> and to promote component-based software reuse [15] [44]. When programmers try to reuse software components, however, they cannot find exactly what they want; often such components need to be adapted before they can be reused. This is also the case when constructing event-based applications out of existing applications.
Reference: [32] <author> V. Paxson, C. Saltmarsh. "Glish: </author> <title> A User-Level Software Bus for Loosely Coupled Distributed Systems," </title> <booktitle> Proceedings of the Winter 1993 USENIX Conference, </booktitle> <pages> pp. 141-156, </pages> <month> January </month> <year> 1993. </year>
Reference: [33] <author> A. Pritsker. </author> <title> The GASP IV Simulation Language, </title> <publisher> Wiley, </publisher> <year> 1974. </year>
Reference-contexts: These issues include event declaration, structure, binding, and also complexity in naming events used in communication. Several languages have been developed to enable programmers to build a single event-based program, intended to execute on one or a very small number of hosts [11] [18] [13] [27] <ref> [33] </ref> [39]. But a language-based approach does not scale up to systems of event-based components; where interaction among components is complex, application modules could be written in different programming languages and distributed across a network of possibly heterogeneous processors.
Reference: [34] <author> L. Pollacia. </author> <title> "A Survey of Discrete Event Simulation and State-of-the-Art Discrete Event Languages," </title> <booktitle> Simulation Digest, </booktitle> <volume> Vol. 20, </volume> <year> 1989. </year>
Reference: [35] <author> J. Purtilo. </author> <title> "The Polylith Software Bus," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 16, </volume> <pages> pp. 663-675, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: When the complexity of building a large program became too great, our research field quickly shifted to building systems of smaller components instead. This was enabled by the use of module interconnection languages and by technology for integrating those components [3] [5] [12] [28] <ref> [35] </ref> [41]. In particular, software packaging [4] | that is, reasoning about compatibility of software modules in order to determine valid means for integrating and interconnecting them | has been successful in simplifying system design and implementation, with all the benefits widely known about modular programs.
Reference: [36] <author> J. Purtilo, J. Atlee. </author> <title> Module Reuse by Interface Adaptation. </title> <journal> Software: Practice & Experience, </journal> <volume> vol. 21, no. 6, </volume> <pages> pp. 539-556, </pages> <year> 1991. </year>
Reference-contexts: The event mapping notation in the ENimble language is similar to the interface mapping notation in Nimble, a language for declaring how the actual parameters in a procedure call are to be transformed at run time <ref> [36] </ref>. The BNF for the map clauses in ENimble is shown in Figure 2.4. In ENimble, each parameter in an event structure is assigned a unique name, either provided either by programmers or by the system.
Reference: [37] <author> J. Purtilo, C. Hofmeister. </author> <title> "Dynamic Reconfiguration of Distributed Programs," </title> <booktitle> Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 560-571, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: A fixed event vocabulary allows programmers to use only a fixed set of events determined before the application is created. Static event declaration requires that all events be declared at compile time. These two approaches do not fit well with a software bus model, which supports dynamic reconfiguration activities <ref> [37] </ref>. For example, modules that are added later to an application during dynamic reconfiguration could declare new events. Obviously, the first two approaches do not support this situation. Field and HP SoftBench took the fourth approach and chose not to declare events in their systems.
Reference: [38] <author> S. Reiss. </author> <title> "Connecting Tools Using Message Passing in the Field Environment," </title> <journal> IEEE Software, </journal> <volume> vol. 7, </volume> <pages> pp. 57-66, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Distributed applications have been traditionally constructed out of modules that interact with each other by explicitly invoking procedures on named interfaces. Recently, however, software developers have shown increasing interest in an alternative integration technique, variously referred to as implicit invocation [16] [18], multicast [9], or selective broadcast <ref> [38] </ref> [19]. The idea behind this integration technique is that instead of invoking a procedure directly on a named interface, events multicast by modules trigger the invocation of procedures. <p> In this category, a system is usually composed of a group of components running as separate processes. These components interact with each other by multicasting events or messages. An agent implemented as a separate process is responsible for routing events through communication channels to the components. Examples are Field <ref> [38] </ref>, Forest [16], HP SoftBench [19], and Sun ToolTalk [26] [43]. Our work falls into the third category. Field [38] is a principal programming environment for teaching undergraduates. It is also a research programming environment and a testbed for developing new tools. <p> An agent implemented as a separate process is responsible for routing events through communication channels to the components. Examples are Field <ref> [38] </ref>, Forest [16], HP SoftBench [19], and Sun ToolTalk [26] [43]. Our work falls into the third category. Field [38] is a principal programming environment for teaching undergraduates. It is also a research programming environment and a testbed for developing new tools. Field uses message passing to integrate a set of tools, including an annotation editor, a cross-referencer, a debugger, a viewer, etc.
Reference: [39] <author> T. Schriber. </author> <title> Simulation Using GPSS, </title> <publisher> Wiley, </publisher> <year> 1974. </year>
Reference-contexts: These issues include event declaration, structure, binding, and also complexity in naming events used in communication. Several languages have been developed to enable programmers to build a single event-based program, intended to execute on one or a very small number of hosts [11] [18] [13] [27] [33] <ref> [39] </ref>. But a language-based approach does not scale up to systems of event-based components; where interaction among components is complex, application modules could be written in different programming languages and distributed across a network of possibly heterogeneous processors.
Reference: [40] <author> S. Sullivan, D. Notkin. </author> " <title> Reconciling Environment Integration and Software Evolution," </title> <journal> ACM Transaction on Software Engineering and Methodology, </journal> <volume> vol. 1, no. 3, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: Systems in this category use specialized notations and run-time support to access implicit invocation. The specialized notations are designed into the language from the start. Examples are given in [18]. The second category is adding implicit invocation to traditional programming languages, such as Ada [18], C++ <ref> [40] </ref>, and Common Lisp [20]. The objective of work in this category is to make implicit invocation available in traditional programming languages without defining special-purpose mechanisms. Notkin et al. [30] discuss design issues that arise when embedding implicit invocation in traditional programming languages.
Reference: [41] <author> V. Sunderam. </author> <title> "PVM: A Framework for Parallel Distributed Computing," </title> <journal> Concurrency: Practice & Experience, </journal> <volume> Vol. 2, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: When the complexity of building a large program became too great, our research field quickly shifted to building systems of smaller components instead. This was enabled by the use of module interconnection languages and by technology for integrating those components [3] [5] [12] [28] [35] <ref> [41] </ref>. In particular, software packaging [4] | that is, reasoning about compatibility of software modules in order to determine valid means for integrating and interconnecting them | has been successful in simplifying system design and implementation, with all the benefits widely known about modular programs.
Reference: [42] <author> Sun Microsystems. </author> <title> Remote Procedure Call Protocol Specification. Sun Microsystems, </title> <month> January </month> <year> 1985. </year> <month> 103 </month>
Reference: [43] <author> SunSoft Inc. </author> <title> ToolTalk 1.0.2 Programmer's Guide. Sun Microsystems, </title> <year> 1992. </year>
Reference-contexts: These components interact with each other by multicasting events or messages. An agent implemented as a separate process is responsible for routing events through communication channels to the components. Examples are Field [38], Forest [16], HP SoftBench [19], and Sun ToolTalk [26] <ref> [43] </ref>. Our work falls into the third category. Field [38] is a principal programming environment for teaching undergraduates. It is also a research programming environment and a testbed for developing new tools.
Reference: [44] <author> D. Yellin, R. Strom. </author> <title> "Interfaces, Protocols, and the Semi-Automatic Construction of Software Adaptors," </title> <booktitle> Proceedings of Object-Oriented Programming Systems and Languages, </booktitle> <pages> pp. 176-190, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: By constructing new applications out of reusable software components, developers can build large, high-quality software applications using less time than building similar applications from scratch. These benefits led to a number of efforts to standardize component interaction [31] and to promote component-based software reuse [15] <ref> [44] </ref>. When programmers try to reuse software components, however, they cannot find exactly what they want; often such components need to be adapted before they can be reused. This is also the case when constructing event-based applications out of existing applications.
Reference: [45] <author> B. Zeigler, A. Louri. </author> <title> "A Simulation Environment for Intelligent Machine Architectures," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 18, </volume> <pages> pp. 77-88, </pages> <month> May </month> <year> 1993. </year> <month> 104 </month>
References-found: 45

