URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr94/tr94-031.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr94-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: su,rsj,pvc,ql,rn@cis.ufl.edu  
Title: OSAM*.KBMS/P: A Parallel, Active, Object-oriented Knowledge Base Server  
Author: Stanley Y.W. Su Ramamohanrao Jawadi Prashant Cherukuri Qiang Li Richard Nartey 
Address: Gainesville, FL 32611  
Affiliation: Database Systems Research and Development Center Department of Computer and Information Sciences University of Florida,  
Pubnum: Technical Report TR94-031  
Abstract: An active object-oriented knowledge base server can provide many desirable features for supporting a wide spectrum of advanced and complex database applications. Knowledge rules, which are used to define a variety of DB tasks to be performed automatically on the occurrence of some events, often need much more sophisticated rule specification and control mechanisms than the traditional priority-based mechanism to capture the control structural relationships and parallel execution properties among rules. The underlying object-oriented knowledge representation model must provide a means to model the structural relationships among data entities and the control structures among rules in a uniform fashion. The transaction execution model must provide a means to incorporate the execution of structured rules in a transaction framework. Also, a parallel implementation of an active knowledge base server is essential to achieve the needed efficiency in processing nested transactions and rules. In this paper, we present the design and implementation of a parallel active OO knowledge base server which has the following features. First, the server is developed based on an extended OO knowledge representation model which models rules as objects and their control structural relationships as association types. This is analogous to the modeling of entities as objects and their structural relationships as association types. Thus, entities and rules, and their structures can be uniformly modeled. Second, the server uses a graph-based transaction model which can naturally incorporate the control semantics of structured rules and guarantee the serializable execution of rules as subtransactions. Thus, the rule execution model is uniformly integrated with that of transactions. Third, it uses an asynchronous parallel execution model to process the graph-based transactions and structured rules. The server named OSAM*.KBMS/P has been implemented on a shared-nothing multiprocessor system (nCUBE2) to verify and evaluate the proposed knowledge representation model, graph-based transaction model, and asynchronous parallel execution model. The results of a performance evaluation are presented.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal, R. Cochrane, and B. Lindsay. </author> <title> On maintaining priorities in a production rule system. </title> <booktitle> In Proc. 17th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 479-487, </pages> <address> Barcelona (Catalonia, Spain), </address> <month> September </month> <year> 1991. </year>
Reference-contexts: The priority-based rule control mechanisms adopted by the existing active and/or object-oriented DBMSs (e.g. POSTGRES [42], HiPAC [13], Alert <ref> [1] </ref>, Starburst [8], Ariel [21] and Sentinel [9]), are not sufficient for capturing the complex control semantics of CA rules in current DB applications, because priorities are assigned to ECA rules and a set of CA rules associated with a number of events cannot follow different execution orders based on the <p> Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel [21], HiPAC [13], active OODB [6], ADAM [15], DOM [7], Starburst [49], Ode [19], Alert <ref> [1] </ref> and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all. However, the priority-based control mechanism is not flexible and 4 expressive enough to meet the requirement of structured rule execution found in some advanced DB applications.
Reference: [2] <author> A. M. Alashqur, S.Y.W. Su, and H. Lam. OQL: </author> <title> A query language for manipulating object-oriented databases. </title> <booktitle> In Proc. 15th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 433-442, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: The subgraph corresponding to the subdatabase of interest is specified by a Context expression 2 , e.g., the Context RA * Grad * Student * AND (Section,Department) means: Identify all object instances of RA, Grad, Student, Section and 2 See <ref> [2] </ref> for full details on the syntax and semantics of the Context expression. 22 Department which satisfy the query pattern given in Figure 12.c, i.e., the sections and departments of graduate students serving as RAs.
Reference: [3] <author> P. Attie, M. Singh, M. Rusinkiewicz, and A. Sheth. </author> <title> Specifying and enforcing intertask dependencies. </title> <booktitle> In Proc. 19th Int'l Conf. on Very Large Data Bases, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: Other significant works that propose powerful and expressive transaction models are reported in <ref> [11, 48, 23, 3] </ref>. However, the above works do not deal with the uniform incorporation of rules, rule control and rule trigger times in a transaction framework.
Reference: [4] <author> J. Banerjee, H. T. Chou, J. F. Garza, W. Kim, D. Woelk, N. Ballou, and H. J. Kim. </author> <title> Data model issues for object-oriented applications. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1), </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: The main goal of an object-oriented DBMS is to model and process the structural and behavioral properties of complex real world objects naturally and efficiently <ref> [4, 44, 5] </ref>. Although significant research has been carried out in the above areas separately, little attention has been given to the integration of all their features in a unified system.
Reference: [5] <author> C. Beeri. </author> <title> Formal models for Object Oriented Database Systems. </title> <editor> In W. Kim, J-M. Nicolas, and S. Nishio, editors, </editor> <booktitle> First Intl. Conf. on Deductive and Object Oriented Databases, </booktitle> <pages> pages 370-395, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction There are three important trends in the current database management research: (i) parallel database servers, (ii) active database management systems (DBMSs), and (iii) object-oriented (OO) DBMSs. Each focuses on enriching some aspects of the traditional DBMS technology <ref> [5, 14, 22] </ref>. Parallel data servers aim to achieve high performance by exploiting maximum parallelism using 1 multiprocessor architectures [14, 47]. The main feature of an active DBMS is to react autonomously (without user intervention) to different events that can occur in a DBMS [16, 30, 29]. <p> The main goal of an object-oriented DBMS is to model and process the structural and behavioral properties of complex real world objects naturally and efficiently <ref> [4, 44, 5] </ref>. Although significant research has been carried out in the above areas separately, little attention has been given to the integration of all their features in a unified system.
Reference: [6] <author> C. Beeri and T. Milo. </author> <title> A model for active object oriented database. </title> <booktitle> In Proc. 17th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 337-349, </pages> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Finally, in Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel [21], HiPAC [13], active OODB <ref> [6] </ref>, ADAM [15], DOM [7], Starburst [49], Ode [19], Alert [1] and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all. <p> Hsu, Ladin and McCarthy [24] describe a more expressive model, which is basically an extended nested transaction model (NTM) [31], to capture rules and nested triggerings of rules uniformly. Other significant works that use variants of NTM for modeling the execution of rules are reported in <ref> [6, 8, 36] </ref>. The tree-based structure of NTM is not expressive enough to capture graph-based control structures among rules in a uniform fashion. , Buchmann et al [7] present an extended NTM in which subtransactions of a transaction can have a graph-based control structure (specified by a precedence graph).
Reference: [7] <author> A. Buchmann, M. T. Ozsu, M. Hornick, D. Georgakopoulos, and F. A. Manola. </author> <title> A transaction model for active distributed object systems. </title> <editor> In A. Elmagarmid, editor, </editor> <booktitle> Database transaction models for advanced applications, </booktitle> <pages> pages 123-158. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Finally, in Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel [21], HiPAC [13], active OODB [6], ADAM [15], DOM <ref> [7] </ref>, Starburst [49], Ode [19], Alert [1] and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all. <p> Other significant works that use variants of NTM for modeling the execution of rules are reported in [6, 8, 36]. The tree-based structure of NTM is not expressive enough to capture graph-based control structures among rules in a uniform fashion. , Buchmann et al <ref> [7] </ref> present an extended NTM in which subtransactions of a transaction can have a graph-based control structure (specified by a precedence graph). Other significant works that propose powerful and expressive transaction models are reported in [11, 48, 23, 3]. <p> However, the above works do not deal with the uniform incorporation of rules, rule control and rule trigger times in a transaction framework. In our work, we use a graph-based transaction model which has the 5 same control structure as the models used in DOM <ref> [7] </ref> and ConTract [48]. In addition, we show how the graph-based transaction model can uniformly incorporate complex control structures among rules. We also show how rules can be placed at different control points in the transaction structure based on different trigger times.
Reference: [8] <author> S. Ceri and J. Widom. </author> <title> Production rules in parallel and distributed database environments. </title> <booktitle> In Proc. 18th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 339-352, </pages> <address> Vancouver, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: The priority-based rule control mechanisms adopted by the existing active and/or object-oriented DBMSs (e.g. POSTGRES [42], HiPAC [13], Alert [1], Starburst <ref> [8] </ref>, Ariel [21] and Sentinel [9]), are not sufficient for capturing the complex control semantics of CA rules in current DB applications, because priorities are assigned to ECA rules and a set of CA rules associated with a number of events cannot follow different execution orders based on the occurrence of <p> Hsu, Ladin and McCarthy [24] describe a more expressive model, which is basically an extended nested transaction model (NTM) [31], to capture rules and nested triggerings of rules uniformly. Other significant works that use variants of NTM for modeling the execution of rules are reported in <ref> [6, 8, 36] </ref>. The tree-based structure of NTM is not expressive enough to capture graph-based control structures among rules in a uniform fashion. , Buchmann et al [7] present an extended NTM in which subtransactions of a transaction can have a graph-based control structure (specified by a precedence graph).
Reference: [9] <author> S. Chakravarthy, V. Krishnaprasad, E. Anwar, and S.-K. Kim. </author> <title> Composite events for active databases: Semantics, contexts and detection. </title> <booktitle> In to appear in Proc. of 20th Int'l Conf. on Very Large Data Bases, </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year> <month> 29 </month>
Reference-contexts: The priority-based rule control mechanisms adopted by the existing active and/or object-oriented DBMSs (e.g. POSTGRES [42], HiPAC [13], Alert [1], Starburst [8], Ariel [21] and Sentinel <ref> [9] </ref>), are not sufficient for capturing the complex control semantics of CA rules in current DB applications, because priorities are assigned to ECA rules and a set of CA rules associated with a number of events cannot follow different execution orders based on the occurrence of different events.
Reference: [10] <author> P. V. Cherukuri. </author> <title> A task manager for parallel rule execution in multi-processor environments. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering, University of Florida, </institution> <year> 1993. </year>
Reference-contexts: A detailed discussion of recovery techniques is out of the scope of this paper. 5 Implementation on a Shared-nothing Computer The OSAM*.KBMS/P, a parallel active OOKBMS server, has been implemented on an nCUBE2 computer <ref> [10, 28, 33] </ref>. The parallel computer is suitable for parallel knowledge base servers because of its shared-nothing (distributed) architecture, scalability, availability and high performance [41].
Reference: [11] <author> P. K. Chrysanthis and K. Ramamritham. </author> <title> ACTA: The SAGA continues. </title> <editor> In A. Elmagarmid, editor, </editor> <booktitle> Database transaction models for advanced applications, </booktitle> <pages> pages 349-398. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Other significant works that propose powerful and expressive transaction models are reported in <ref> [11, 48, 23, 3] </ref>. However, the above works do not deal with the uniform incorporation of rules, rule control and rule trigger times in a transaction framework.
Reference: [12] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <booktitle> Introduction to Algorithms, </booktitle> <pages> pages 536-538. </pages> <publisher> McGraw Hill Book Company, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: The correct execution orders for the rule graph shown in Figure 7.a are (r1!r2!r3!r4!r5) and (r1!r3!r2!r4!r5). To be more general, the parallel/concurrent execution of rules is correct when the resultant execution order is equivalent to some topological order <ref> [12] </ref>. Since the above correctness criterion requires a topological serial order instead of an arbitrary serial order, we shall call it topological serializability.
Reference: [13] <author> U. Dayal, B. Blaustein, A. Buchmann, S. Chakravarthy, et al. </author> <title> The HiPAC project: Combining active databases and timing constraints. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 51-70, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: It uses a parallel version of an Object-oriented Semantic Association model (OSAM*/P) as its underlying knowledge representation model. Traditionally, event-condition-action (ECA) rules are used to implement active features in a DB environment <ref> [13] </ref>. An ECA rule consists of an event (E), a condition to be checked (C), and an action (A) to be executed if the condition is satisfied. In this paper, we shall separate the event part from the condition and action parts of an ECA rule. <p> The priority-based rule control mechanisms adopted by the existing active and/or object-oriented DBMSs (e.g. POSTGRES [42], HiPAC <ref> [13] </ref>, Alert [1], Starburst [8], Ariel [21] and Sentinel [9]), are not sufficient for capturing the complex control semantics of CA rules in current DB applications, because priorities are assigned to ECA rules and a set of CA rules associated with a number of events cannot follow different execution orders based <p> Finally, in Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel [21], HiPAC <ref> [13] </ref>, active OODB [6], ADAM [15], DOM [7], Starburst [49], Ode [19], Alert [1] and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all.
Reference: [14] <author> D. DeWitt and J. Gray. </author> <title> Parallel database systems: The future of high performance database systems. </title> <journal> Communications of the ACM, </journal> <volume> 35(6), </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction There are three important trends in the current database management research: (i) parallel database servers, (ii) active database management systems (DBMSs), and (iii) object-oriented (OO) DBMSs. Each focuses on enriching some aspects of the traditional DBMS technology <ref> [5, 14, 22] </ref>. Parallel data servers aim to achieve high performance by exploiting maximum parallelism using 1 multiprocessor architectures [14, 47]. The main feature of an active DBMS is to react autonomously (without user intervention) to different events that can occur in a DBMS [16, 30, 29]. <p> Each focuses on enriching some aspects of the traditional DBMS technology [5, 14, 22]. Parallel data servers aim to achieve high performance by exploiting maximum parallelism using 1 multiprocessor architectures <ref> [14, 47] </ref>. The main feature of an active DBMS is to react autonomously (without user intervention) to different events that can occur in a DBMS [16, 30, 29].
Reference: [15] <author> O. Diaz, N. Paton, and P. Gray. </author> <title> Rule management in object oriented databases: A uniform approach. </title> <booktitle> In Proc. 17th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 317-326, </pages> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Finally, in Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel [21], HiPAC [13], active OODB [6], ADAM <ref> [15] </ref>, DOM [7], Starburst [49], Ode [19], Alert [1] and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all.
Reference: [16] <author> K. P. Eswaran. </author> <title> Specifications, implementations and interactions of a trigger subsystem in an integrated database system. </title> <type> Technical report, </type> <institution> IBM Research Laboratory, </institution> <address> San Jose, CA, </address> <year> 1976. </year>
Reference-contexts: Parallel data servers aim to achieve high performance by exploiting maximum parallelism using 1 multiprocessor architectures [14, 47]. The main feature of an active DBMS is to react autonomously (without user intervention) to different events that can occur in a DBMS <ref> [16, 30, 29] </ref>. The main goal of an object-oriented DBMS is to model and process the structural and behavioral properties of complex real world objects naturally and efficiently [4, 44, 5].
Reference: [17] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The notions of consistency and predicate locks in database systems. </title> <journal> Communications of the ACM 19, </journal> <volume> 10(11), </volume> <month> Nov. </month> <year> 1976. </year>
Reference-contexts: Each rule-level control sphere may in turn generate a set of rule-level control spheres when an operation of the rule triggers another set of rules. At the transaction-level, the correctness criterion for a parallel execution of several TGs is standard serializability <ref> [17] </ref> which states that the interleaved execution of several TGs is correct when it is equivalent to some serial execution. This means that all transaction-level control spheres are clearly isolated from one another.
Reference: [18] <author> S. Gatziu and K. R. Dittrich. SAMOS: </author> <title> an active, object-oriented database system. </title> <journal> in IEEE Quarterly Bulletin on Data Engineering, </journal> <volume> 15(1) </volume> <pages> 23-26, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel [21], HiPAC [13], active OODB [6], ADAM [15], DOM [7], Starburst [49], Ode [19], Alert [1] and SAMOS <ref> [18] </ref>) use either priorities, to define the control structures among rules, or support no rule control mechanism at all. However, the priority-based control mechanism is not flexible and 4 expressive enough to meet the requirement of structured rule execution found in some advanced DB applications.
Reference: [19] <author> N. H. Gehani and H. V. Jagadish. </author> <title> Ode as an active database: Constraints and triggers. </title> <booktitle> In Proceedings 17th International Conference on Very Large Data Bases, </booktitle> <pages> pages 327-336, </pages> <address> Barcelona (Catalonia, Spain), </address> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: Finally, in Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel [21], HiPAC [13], active OODB [6], ADAM [15], DOM [7], Starburst [49], Ode <ref> [19] </ref>, Alert [1] and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all. However, the priority-based control mechanism is not flexible and 4 expressive enough to meet the requirement of structured rule execution found in some advanced DB applications.
Reference: [20] <author> J. Gray and A. Reuter. </author> <title> Transaction processing: Concepts and technques. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Traditional transaction models such as the flat transaction model <ref> [20] </ref> and the nested transaction model [31], and their variants [50] are not expressive enough to model the above scenario in a uniform fashion. A more expressive and powerful transaction model (e.g., a graph-based model) is needed for defining and processing graph-structured transactions and rules uniformly. <p> Many existing DBMSs use different transaction models to capture the complex execution of several interdependent DB tasks and rules. In POSTGRES and Ariel, the execution of rules is incorporated into a flat transaction model <ref> [20] </ref>. Hsu, Ladin and McCarthy [24] describe a more expressive model, which is basically an extended nested transaction model (NTM) [31], to capture rules and nested triggerings of rules uniformly. Other significant works that use variants of NTM for modeling the execution of rules are reported in [6, 8, 36].
Reference: [21] <author> E. N. Hanson. </author> <title> An initial report on the design of Ariel: a DBMS with an integrated production rule system. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 18(3) </volume> <pages> 12-19, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The priority-based rule control mechanisms adopted by the existing active and/or object-oriented DBMSs (e.g. POSTGRES [42], HiPAC [13], Alert [1], Starburst [8], Ariel <ref> [21] </ref> and Sentinel [9]), are not sufficient for capturing the complex control semantics of CA rules in current DB applications, because priorities are assigned to ECA rules and a set of CA rules associated with a number of events cannot follow different execution orders based on the occurrence of different events. <p> Finally, in Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel <ref> [21] </ref>, HiPAC [13], active OODB [6], ADAM [15], DOM [7], Starburst [49], Ode [19], Alert [1] and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all.
Reference: [22] <author> Eric N. Hanson and Jennifer Widom. </author> <title> Rule processing in active database systems. </title> <journal> International Journal of Expert Systems, </journal> <volume> 6(1) </volume> <pages> 83-119, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction There are three important trends in the current database management research: (i) parallel database servers, (ii) active database management systems (DBMSs), and (iii) object-oriented (OO) DBMSs. Each focuses on enriching some aspects of the traditional DBMS technology <ref> [5, 14, 22] </ref>. Parallel data servers aim to achieve high performance by exploiting maximum parallelism using 1 multiprocessor architectures [14, 47]. The main feature of an active DBMS is to react autonomously (without user intervention) to different events that can occur in a DBMS [16, 30, 29].
Reference: [23] <author> S. Heiler, S. Haradhvala, S. Zdonik, B. Blaustein, and A. Rosenthal. </author> <title> A flexible framework for transaction management in engineering environments. </title> <editor> In A. Elmagarmid, editor, </editor> <booktitle> Database transaction models for advanced applications, </booktitle> <pages> pages 87-122. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Other significant works that propose powerful and expressive transaction models are reported in <ref> [11, 48, 23, 3] </ref>. However, the above works do not deal with the uniform incorporation of rules, rule control and rule trigger times in a transaction framework.
Reference: [24] <author> M. Hsu, R. Ladin, and D. McCarthy. </author> <title> An execution model for active database management systems. </title> <booktitle> In Proceedings of the 3rd International Conference on Data and Knowledge Bases, </booktitle> <pages> pages 171-179, </pages> <address> Washington, DC, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Many existing DBMSs use different transaction models to capture the complex execution of several interdependent DB tasks and rules. In POSTGRES and Ariel, the execution of rules is incorporated into a flat transaction model [20]. Hsu, Ladin and McCarthy <ref> [24] </ref> describe a more expressive model, which is basically an extended nested transaction model (NTM) [31], to capture rules and nested triggerings of rules uniformly. Other significant works that use variants of NTM for modeling the execution of rules are reported in [6, 8, 36]. <p> In this way, the "after" rule graphs will be executed in the order they were triggered. The importance of maintaining such order is stressed in <ref> [24] </ref>. In the case of parallel as the trigger time, the triggered rule graph is executed as a separate transaction in parallel with the triggering transaction. It is completely detached from the triggering transaction/rule in all respects except a causal relationship.
Reference: [25] <author> T. Ishida. </author> <title> Parallel rule firing in production systems. </title> <journal> IEEE Trans. Knowledge Data Eng., </journal> <volume> 3(1) </volume> <pages> 11-17, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: In the field of Artificial Intelligence, a significant amount of research has been focused on executing rules in parallel and at the same time maintaining their control structures <ref> [38, 25, 40, 27] </ref>. Similar to our system, RUBIC [27] and PARULEL [40] provide several control constructs to control the parallel execution of rules. Nevertheless, they do not guarantee the serializable execution of rules. <p> Similar to our system, RUBIC [27] and PARULEL [40] provide several control constructs to control the parallel execution of rules. Nevertheless, they do not guarantee the serializable execution of rules. Rule systems presented in <ref> [38, 25] </ref> guarantee serializability during the parallel execution of rules by a static analysis of rules. However, they do not provide any rule control mechanism.
Reference: [26] <author> G. Kiernan, C. deMaindreville, and E. Simon. </author> <title> Making deductive database a practical technology: a step forward. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: As explained in the introduction, when using priorities, it is not possible to specify different control structures for rules triggered by different events. Additionally, since the control structures of rule execution are implicitly specified by rule priorities, it is quite difficult to understand or modify the rule structures. In <ref> [26, 39] </ref>, Simon et al emphasize the need for a more powerful rule control mechanism for making a rule system more practical. They propose a set of control constructs, namely 'sequence', 'disjunction' and 'saturate', for specifying the control structures among rules.
Reference: [27] <author> S. Kuo and D. Moldovan. </author> <title> Implementation of multiple rule firing production systems on hypercube. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 383-394, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: In the field of Artificial Intelligence, a significant amount of research has been focused on executing rules in parallel and at the same time maintaining their control structures <ref> [38, 25, 40, 27] </ref>. Similar to our system, RUBIC [27] and PARULEL [40] provide several control constructs to control the parallel execution of rules. Nevertheless, they do not guarantee the serializable execution of rules. <p> In the field of Artificial Intelligence, a significant amount of research has been focused on executing rules in parallel and at the same time maintaining their control structures [38, 25, 40, 27]. Similar to our system, RUBIC <ref> [27] </ref> and PARULEL [40] provide several control constructs to control the parallel execution of rules. Nevertheless, they do not guarantee the serializable execution of rules. Rule systems presented in [38, 25] guarantee serializability during the parallel execution of rules by a static analysis of rules.
Reference: [28] <author> Q. Li. </author> <title> Design and Implementation of a Parallel Object-Oriented Query Processor for OSAM*.KBMS/P. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering, University of Florida, </institution> <year> 1993. </year>
Reference-contexts: A detailed discussion of recovery techniques is out of the scope of this paper. 5 Implementation on a Shared-nothing Computer The OSAM*.KBMS/P, a parallel active OOKBMS server, has been implemented on an nCUBE2 computer <ref> [10, 28, 33] </ref>. The parallel computer is suitable for parallel knowledge base servers because of its shared-nothing (distributed) architecture, scalability, availability and high performance [41].
Reference: [29] <author> D. R. McCarthy and U. Dayal. </author> <title> The architecture of an active, object-oriented database system. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <pages> pages 142-151, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year> <month> 30 </month>
Reference-contexts: Parallel data servers aim to achieve high performance by exploiting maximum parallelism using 1 multiprocessor architectures [14, 47]. The main feature of an active DBMS is to react autonomously (without user intervention) to different events that can occur in a DBMS <ref> [16, 30, 29] </ref>. The main goal of an object-oriented DBMS is to model and process the structural and behavioral properties of complex real world objects naturally and efficiently [4, 44, 5].
Reference: [30] <author> M. Morgenstern. </author> <title> Active Databases as a Paradigm for Enhanced Computing Environments. </title> <booktitle> In Proceed--ings 9th International Conference on Very Large Data Bases, </booktitle> <pages> pages 34-42, </pages> <year> 1983. </year>
Reference-contexts: Parallel data servers aim to achieve high performance by exploiting maximum parallelism using 1 multiprocessor architectures [14, 47]. The main feature of an active DBMS is to react autonomously (without user intervention) to different events that can occur in a DBMS <ref> [16, 30, 29] </ref>. The main goal of an object-oriented DBMS is to model and process the structural and behavioral properties of complex real world objects naturally and efficiently [4, 44, 5].
Reference: [31] <author> E. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1985. </year>
Reference-contexts: Traditional transaction models such as the flat transaction model [20] and the nested transaction model <ref> [31] </ref>, and their variants [50] are not expressive enough to model the above scenario in a uniform fashion. A more expressive and powerful transaction model (e.g., a graph-based model) is needed for defining and processing graph-structured transactions and rules uniformly. An OODBMS is complex because of its powerful semantic features. <p> In POSTGRES and Ariel, the execution of rules is incorporated into a flat transaction model [20]. Hsu, Ladin and McCarthy [24] describe a more expressive model, which is basically an extended nested transaction model (NTM) <ref> [31] </ref>, to capture rules and nested triggerings of rules uniformly. Other significant works that use variants of NTM for modeling the execution of rules are reported in [6, 8, 36].
Reference: [32] <author> E. Moss. </author> <title> Log-based recovery for nested transactions. </title> <booktitle> In Proc. 13th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 427-432, </pages> <address> Brighton, England, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: The recovery of the graph-based transactions can be done using the standard recovery methods used for NTM <ref> [32, 37] </ref>. The only difference is that when a set of rules are being undone, they need to follow reverse topological order. <p> When a task is aborted, it can be recovered without affecting other tasks or transactions. Our recovery is based on a write ahead logging scheme and an UNDO/REDO strategy which is more efficient than the version approach. Similar recovery techniques have been used for nested transactions in <ref> [32, 37] </ref>. However, the recovery of a graph-based transaction is different from that of a nested transaction in that the tasks (or subtransactions) need to be undone in reverse of the order in which they were scheduled (reverse topological order), to maintain semantic consistency.
Reference: [33] <author> R. Nartey. </author> <title> The design and implementatation of a global transaction server and a lock manager for a parallel knowledge base management system. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering, University of Florida, </institution> <year> 1994. </year> <title> [34] nCUBE. nCUBE 2 Programmer's Guide, 1992. </title> <publisher> nCUBE Corporation, </publisher> <address> Foster City, CA. </address>
Reference-contexts: A detailed discussion of recovery techniques is out of the scope of this paper. 5 Implementation on a Shared-nothing Computer The OSAM*.KBMS/P, a parallel active OOKBMS server, has been implemented on an nCUBE2 computer <ref> [10, 28, 33] </ref>. The parallel computer is suitable for parallel knowledge base servers because of its shared-nothing (distributed) architecture, scalability, availability and high performance [41].
Reference: [35] <author> M.T. Ozsu and P. Valduriez. </author> <title> Principles of distributed database systems. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: A TG's execution is completed when the scheduler reaches the commit node. GTS requests all relevant LTM's to commit the transaction using the 2 phase commit protocol <ref> [35] </ref>. The committed TG is removed from WQ. It can be observed that TGs are being interleaved by the scheduler and also several tasks are being processed in parallel by the underlying LTMs.
Reference: [36] <author> L. Raschid, T. Sellis, and A. Delis. </author> <title> A simulation-based study on the concurrent execution of rules in a database environment. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 20(1) </volume> <pages> 20-42, </pages> <month> Jan </month> <year> 1994. </year>
Reference-contexts: Hsu, Ladin and McCarthy [24] describe a more expressive model, which is basically an extended nested transaction model (NTM) [31], to capture rules and nested triggerings of rules uniformly. Other significant works that use variants of NTM for modeling the execution of rules are reported in <ref> [6, 8, 36] </ref>. The tree-based structure of NTM is not expressive enough to capture graph-based control structures among rules in a uniform fashion. , Buchmann et al [7] present an extended NTM in which subtransactions of a transaction can have a graph-based control structure (specified by a precedence graph).
Reference: [37] <author> K. Rothermal and C. Mohan. ARIES/NT: </author> <title> A recovery method based on write ahead logging for nested transactions. </title> <booktitle> In Proc. 15th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 337-346, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: The recovery of the graph-based transactions can be done using the standard recovery methods used for NTM <ref> [32, 37] </ref>. The only difference is that when a set of rules are being undone, they need to follow reverse topological order. <p> When a task is aborted, it can be recovered without affecting other tasks or transactions. Our recovery is based on a write ahead logging scheme and an UNDO/REDO strategy which is more efficient than the version approach. Similar recovery techniques have been used for nested transactions in <ref> [32, 37] </ref>. However, the recovery of a graph-based transaction is different from that of a nested transaction in that the tasks (or subtransactions) need to be undone in reverse of the order in which they were scheduled (reverse topological order), to maintain semantic consistency.
Reference: [38] <author> J. G. Schmolze. </author> <title> Guaranteeing serializable results in synchronous parallel production systems. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 348-365, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: In the field of Artificial Intelligence, a significant amount of research has been focused on executing rules in parallel and at the same time maintaining their control structures <ref> [38, 25, 40, 27] </ref>. Similar to our system, RUBIC [27] and PARULEL [40] provide several control constructs to control the parallel execution of rules. Nevertheless, they do not guarantee the serializable execution of rules. <p> Similar to our system, RUBIC [27] and PARULEL [40] provide several control constructs to control the parallel execution of rules. Nevertheless, they do not guarantee the serializable execution of rules. Rule systems presented in <ref> [38, 25] </ref> guarantee serializability during the parallel execution of rules by a static analysis of rules. However, they do not provide any rule control mechanism.
Reference: [39] <author> E. Simon, J. Kiernan, and C. deMaindreville. </author> <title> Implementing high level active rules on top of a relational DBMS. </title> <booktitle> In Proc. 18th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 315-326, </pages> <address> Vancouver, </address> <year> 1992. </year>
Reference-contexts: As explained in the introduction, when using priorities, it is not possible to specify different control structures for rules triggered by different events. Additionally, since the control structures of rule execution are implicitly specified by rule priorities, it is quite difficult to understand or modify the rule structures. In <ref> [26, 39] </ref>, Simon et al emphasize the need for a more powerful rule control mechanism for making a rule system more practical. They propose a set of control constructs, namely 'sequence', 'disjunction' and 'saturate', for specifying the control structures among rules.
Reference: [40] <author> S. J. Stolfo, O. Wolfson, P. K. Chan, H. M. Dewan, L. Woodbury, J. S. Glazier, and D. A. Ohsie. PARULEL: </author> <title> Parallel rule processing using meta-rules for redaction. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 366-382, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: In the field of Artificial Intelligence, a significant amount of research has been focused on executing rules in parallel and at the same time maintaining their control structures <ref> [38, 25, 40, 27] </ref>. Similar to our system, RUBIC [27] and PARULEL [40] provide several control constructs to control the parallel execution of rules. Nevertheless, they do not guarantee the serializable execution of rules. <p> In the field of Artificial Intelligence, a significant amount of research has been focused on executing rules in parallel and at the same time maintaining their control structures [38, 25, 40, 27]. Similar to our system, RUBIC [27] and PARULEL <ref> [40] </ref> provide several control constructs to control the parallel execution of rules. Nevertheless, they do not guarantee the serializable execution of rules. Rule systems presented in [38, 25] guarantee serializability during the parallel execution of rules by a static analysis of rules.
Reference: [41] <author> M. Stonebraker. </author> <title> The case for shared nothing. </title> <journal> Database Engineering, </journal> <volume> 9(1), </volume> <year> 1986. </year>
Reference-contexts: The parallel computer is suitable for parallel knowledge base servers because of its shared-nothing (distributed) architecture, scalability, availability and high performance <ref> [41] </ref>. The main objectives of our implementation effort were to demonstrate the implementability of the presented transaction and rule modeling scheme, the knowledge definition language, the topological scheduling scheme and its corresponding locking scheme, the parallel rule and data processing algorithms and to gather performance data from the implemented system.
Reference: [42] <author> M. Stonebraker, E. Hanson, and S. Potamianos. </author> <title> The POSTGRES rule manager. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 897-907, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: The priority-based rule control mechanisms adopted by the existing active and/or object-oriented DBMSs (e.g. POSTGRES <ref> [42] </ref>, HiPAC [13], Alert [1], Starburst [8], Ariel [21] and Sentinel [9]), are not sufficient for capturing the complex control semantics of CA rules in current DB applications, because priorities are assigned to ECA rules and a set of CA rules associated with a number of events cannot follow different execution <p> Finally, in Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES <ref> [42] </ref>, Ariel [21], HiPAC [13], active OODB [6], ADAM [15], DOM [7], Starburst [49], Ode [19], Alert [1] and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all.
Reference: [43] <author> S. Y. W. Su, Y.-H. Chen, and H. Lam. </author> <title> Multiple wavefront algorithms for pattern-based processing of object-oriented databases. </title> <booktitle> In Proc. 1st Int'l Conf. on Parallel and Distributed Inf. Syst., </booktitle> <pages> pages 46-55, </pages> <address> Miami, FL, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: When a DB operation involves remote data, e.g. the operation is to form a subdatabase which involves multiple classes (analogous to joining multiple relations), the data processor uses asynchronous multiple wavefront algorithms <ref> [43, 46] </ref> to form the subdatabase in parallel. In an OO view, a database is viewed as a schema graph intensionally and an object graph extensionally. In a schema graph, nodes represent classes and edges represent the associations among the classes. <p> The resulting subdatabase for the above context expression is shown in Figure 12.b. In OSAM*.KBMS/P, two parallel multiple wavefront algorithms, namely, identification [46] and elimination <ref> [43] </ref> algorithms, are used for establishing a subdatabase specified by a Context expression. Since the papers describing these two algorithms have been published, we shall only briefly describe them here to give the reader a general idea of their functionalities.
Reference: [44] <author> S. Y. W. Su, V. Krishnamurthy, and H. Lam. </author> <title> An object-oriented semantic association model (OSAM*). </title> <editor> In S. Kumara, A. L. Soyster, and R. L. Kashyap, editors, </editor> <booktitle> Artificial intelligence: Manufacturing theory and practice, </booktitle> <pages> pages 463-494. </pages> <institution> Institute of Industrial Engineers, Industrial Engineering and Management Press, </institution> <address> Norcross, GA, </address> <year> 1989. </year>
Reference-contexts: The main goal of an object-oriented DBMS is to model and process the structural and behavioral properties of complex real world objects naturally and efficiently <ref> [4, 44, 5] </ref>. Although significant research has been carried out in the above areas separately, little attention has been given to the integration of all their features in a unified system.
Reference: [45] <author> S. Y.W. Su, H. Lam, S. Eddula J. Arroyo, N. Prasad, and R. Zhuang. OSAM*.KBMS: </author> <title> an object-oriented knowledge base management system for supporting advanced applications. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: OSAM*/P models the structural properties of entity types in an application domain using classes and associations, and their behavioural properties using rules and methods. In addition, OSAM*/P models complex control structures among rules using rule graphs. Since the other modeling features are explained in a previous paper <ref> [45] </ref>, we describe only rules and rule graphs 7 in detail, here. Mainly, we want to show the flexibility and expressiveness of rule graphs and how they are incorporated in OSAM*/P's OO model and language framework. Rule Associations: In OSAM*/P, rules are modeled as objects.
Reference: [46] <author> A.K. Thakore, S.Y.W. Su, and H. Lam. </author> <title> Algorithms for asynchronous parallel processing of object-oriented databases. </title> <journal> to appear in IEEE Trans. Knowledge Data Eng., </journal> <month> October </month> <year> 1994. </year>
Reference-contexts: When a DB operation involves remote data, e.g. the operation is to form a subdatabase which involves multiple classes (analogous to joining multiple relations), the data processor uses asynchronous multiple wavefront algorithms <ref> [43, 46] </ref> to form the subdatabase in parallel. In an OO view, a database is viewed as a schema graph intensionally and an object graph extensionally. In a schema graph, nodes represent classes and edges represent the associations among the classes. <p> Following the Context specification, a query would specify the system-defined or user-defined operations which are to be performed on the object instances in the subdatabase. The resulting subdatabase for the above context expression is shown in Figure 12.b. In OSAM*.KBMS/P, two parallel multiple wavefront algorithms, namely, identification <ref> [46] </ref> and elimination [43] algorithms, are used for establishing a subdatabase specified by a Context expression. Since the papers describing these two algorithms have been published, we shall only briefly describe them here to give the reader a general idea of their functionalities.
Reference: [47] <author> P. Valduriez. </author> <title> Parallel database systems: Open problems and new issues. </title> <booktitle> Distributed and Parallel Databases, </booktitle> <volume> 1(1) </volume> <pages> 137-165, </pages> <year> 1993. </year>
Reference-contexts: Each focuses on enriching some aspects of the traditional DBMS technology [5, 14, 22]. Parallel data servers aim to achieve high performance by exploiting maximum parallelism using 1 multiprocessor architectures <ref> [14, 47] </ref>. The main feature of an active DBMS is to react autonomously (without user intervention) to different events that can occur in a DBMS [16, 30, 29].
Reference: [48] <author> H. Wachter and A. Reuter. </author> <title> The ConTract model. </title> <editor> In A. Elmagarmid, editor, </editor> <booktitle> Database transaction models for advanced applications, </booktitle> <pages> pages 219-264. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Other significant works that propose powerful and expressive transaction models are reported in <ref> [11, 48, 23, 3] </ref>. However, the above works do not deal with the uniform incorporation of rules, rule control and rule trigger times in a transaction framework. <p> However, the above works do not deal with the uniform incorporation of rules, rule control and rule trigger times in a transaction framework. In our work, we use a graph-based transaction model which has the 5 same control structure as the models used in DOM [7] and ConTract <ref> [48] </ref>. In addition, we show how the graph-based transaction model can uniformly incorporate complex control structures among rules. We also show how rules can be placed at different control points in the transaction structure based on different trigger times.
Reference: [49] <author> J. Widom, R. J. Cochrane, and B. G. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to Starburst. </title> <booktitle> In Proc. 17th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 275-285, </pages> <address> Barcelona (Catalonia, Spain), </address> <month> September </month> <year> 1991. </year> <month> 31 </month>
Reference-contexts: Finally, in Section 6, we evaluate the system's performance, and give conclusions and directions for future research in Section 7. 2 Related Work The rule subsystems of the existing active and/or object-oriented DBMSs (e.g., POSTGRES [42], Ariel [21], HiPAC [13], active OODB [6], ADAM [15], DOM [7], Starburst <ref> [49] </ref>, Ode [19], Alert [1] and SAMOS [18]) use either priorities, to define the control structures among rules, or support no rule control mechanism at all.
Reference: [50] <author> D. R. Zertuche and A. P. Buchmann. </author> <title> Execution models for active database systems: A comparison. </title> <type> Technical Report TM-0238-01-90-165, </type> <institution> GTE Laboratories, </institution> <address> Waltham, MA, </address> <month> January </month> <year> 1990. </year> <month> 32 </month>
Reference-contexts: Traditional transaction models such as the flat transaction model [20] and the nested transaction model [31], and their variants <ref> [50] </ref> are not expressive enough to model the above scenario in a uniform fashion. A more expressive and powerful transaction model (e.g., a graph-based model) is needed for defining and processing graph-structured transactions and rules uniformly. An OODBMS is complex because of its powerful semantic features.
References-found: 49

