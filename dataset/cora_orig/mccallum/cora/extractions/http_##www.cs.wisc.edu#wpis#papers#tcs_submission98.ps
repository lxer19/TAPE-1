URL: http://www.cs.wisc.edu/wpis/papers/tcs_submission98.ps
Refering-URL: http://www.cs.wisc.edu/wpis/abstracts/tcs_submission98.abs.html
Root-URL: 
Title: Interconvertibility of Set Constraints and Context-Free Language Reachability 1  
Author: David Melski Thomas Reps 
Date: January 31, 1998  
Affiliation: Computer Sciences Department University of Wisconsin  Computer Sciences Department University of Wisconsin  
Abstract: We show the interconvertibility of context-free-language reachability problems and a class of set-constraint problems: given a context-free-language reachability problem, we show how to construct a set-constraint problem whose answer gives a solution to the reachability problem; given a set-constraint problem, we show how to construct a context-free-language reachability problem whose answer gives a solution to the set-constraint problem. The interconvertibility of these two formalisms offers an conceptual advantage akin to the advantage gained from the interconvertibility of finite-state automata and regular expressions in formal language theory, namely, a problem can be formulated in whichever formalism is most natural. It also offers some insight into the "O(n 3 ) bottleneck" for different types of program-analysis problems, and allows results previously obtained for context-free-language reachability problems to be applied to set-constraint problems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <year> 1988. </year>
Reference-contexts: This approach was later applied to intraprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [2] and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis <ref> [1] </ref> and Horwitz et al.'s work on interprocedural slicing [12, 13].
Reference: [2] <author> K.D. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 57-66, </pages> <year> 1988. </year>
Reference-contexts: Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis <ref> [2] </ref> and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing [12, 13].
Reference: [3] <author> K.D. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <year> 1989. </year>
Reference-contexts: Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [2] and alias analysis <ref> [3] </ref>. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing [12, 13].
Reference: [4] <author> M. J. Fischer and A. R. Meyer. </author> <title> Boolean matrix multiplication and transitive closure. </title> <booktitle> In Conference Record of the IEEE 12th Symposium on Switching and Automata Theory, </booktitle> <year> 1971. </year>
Reference-contexts: However, because transitive closure can be performed in sub-cubic time <ref> [4] </ref>, this is not the correct explanation. We have long believed that the real source of the O (n 3 ) bottleneck is that a CFL-reachability problem needs to be solved.
Reference: [5] <author> F. Gecseg and M. Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <year> 1984. </year>
Reference-contexts: Heintze formalizes this idea in [7]. The solution to a collection of set constraints can be written as a regular term grammar <ref> [5] </ref>, which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. There are standard algorithms for dealing with regular term grammars (e.g., for determining membership) [5]. <p> The solution to a collection of set constraints can be written as a regular term grammar <ref> [5] </ref>, which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. There are standard algorithms for dealing with regular term grammars (e.g., for determining membership) [5]. A regular term grammar consists of a finite, non-empty set of non-terminals, a set of function symbols, and a finite set of productions. Each function symbol has a fixed arity. Productions are of the form N ) term where N is a non-terminal.
Reference: [6] <author> M.S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou [19] and Hecht <ref> [6] </ref> gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [2] and alias analysis [3].
Reference: [7] <author> N. Heintze. </author> <title> Set-based program analysis. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Typically, a set variable is created for each program variable at each program point. Set constraints are then generated that approximate the program's behavior. Program analysis then becomes a problem of finding the least solution of the set-constraint problem <ref> [7] </ref>. The principal contribution of this paper is to relate these two techniques: * We give a construction for converting a CFL-reachability problem into a set-constraint problem. <p> an all-pairs CFL-reachability problem can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define a class of set constraints. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [7, 8, 9] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V <p> Heintze formalizes this idea in <ref> [7] </ref>. The solution to a collection of set constraints can be written as a regular term grammar [5], which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. <p> Such constraints are said to be in explicit form <ref> [7] </ref>: A constraint is in explicit form if it is of the form V c (V 1 ; : : : ; V r ). <p> When no more constraints can be added, the constraints in explicit form are converted to a regular term grammar; this describes the least solution <ref> [7] </ref>. 2 The SC-Reduction Algorithm never generates new atomic expressions; this means that when the algorithm finishes, for a fixed variable Y , the number of constraints of the form Y c (V 1 ; V 2 ; : : : ; V r ) in C is bound by O
Reference: [8] <author> N. Heintze. </author> <title> Set based analyis of ML programs. </title> <type> Technical Report CMU-CS-93-193, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: However, our interconvertibility results show that CFL-reachability can be used to analyze strict languages, and set constraints can be used to analyze lazy languages. A different class of set constraints has been used by Heintze to formulate analysis problems for a higher-order language (ML) <ref> [8] </ref>. In Section 5, we show how set-constraint problems of this class can be converted to CFL-reachability problems while preserving cubic-time solvability (i.e., cubic in the size of the original problem). <p> an all-pairs CFL-reachability problem can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define a class of set constraints. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [7, 8, 9] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V <p> is constant, and v and n are in the worst case proportional to t, the total running time of the algorithm is bounded by O (t 3 ). 5 Solving ML Set-Constraint Problems Using CFL-reachability Heintze has used a modified class of set constraints for set-based analysis of ML programs <ref> [8] </ref>. We refer to this class of set constraints as ML set constraints to distinguish them from the set constraints discussed in the earlier part of the paper. <p> Expressions of this form are used to model function application. * ifnonempty (se 1 ; se 2 ). Expressions of this form are used to make set based analysis more accurate by preventing constraints that correspond to dead code from contributing to the solution. See <ref> [8] </ref> for details. ML set constraints are of the form V se, where se is an ML set expression. A solution to a collection of ML set constraints is a mapping from set variables to a set of values such that the constraints are satisfied. <p> if X X 0 and X 0 se both appear it C, where X 0 se is in explicit form, then add X se to C When no more constraints can be added, the constraints in explicit form are converted to a regular term grammar; this describes the least solution <ref> [8] </ref>. 2 5.2 Solving ML Set-Constraint Problems Using CFL-reachability The idea for encoding an ML set-constraint problem is the same as in Section 4.1: we view the ML SC-Reduction Algorithm as computing what atomic expressions reach each set variable and construct a CFL-reachability problem that computes the same information.
Reference: [9] <author> N. Heintze and J. Jaffar. </author> <title> A decision procedure for a class of set constraints. </title> <type> Technical Report CMU-CS-91-110, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: an all-pairs CFL-reachability problem can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define a class of set constraints. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [7, 8, 9] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V
Reference: [10] <author> N. Heintze and D. McAllester. </author> <title> Linear-time subtransitive control flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1997. </year>
Reference-contexts: 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based analysis with data constructors <ref> [20, 10] </ref>. A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [18].
Reference: [11] <author> N. Heintze and D. McAllester. </author> <title> On the cubic bottleneck in subtyping and flow analysis. </title> <booktitle> In LICS '97: Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1997. </year>
Reference-contexts: of the algorithm is bounded by O (t 3 ). 6 Related Work and Concluding Remarks Heintze and McAllester have obtained results that have a bearing on the "O (n 3 ) program-analysis bottleneck" by considering the problem of determining membership for languages defined by 2-way nondeterministic pushdown automata (2NPDA-recognition) <ref> [11] </ref>. The best known algorithm for solving the 2NPDA-recognition problem runs in O (n 3 ) time and they observe that if there is a linear-time reduction from 2NPDA-recognition to a given problem, then that problem is unlikely to be solvable in better than O (n 3 ) time. In [11] <p> <ref> [11] </ref>. The best known algorithm for solving the 2NPDA-recognition problem runs in O (n 3 ) time and they observe that if there is a linear-time reduction from 2NPDA-recognition to a given problem, then that problem is unlikely to be solvable in better than O (n 3 ) time. In [11] reductions are given from 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based
Reference: [12] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <year> 1988. </year>
Reference-contexts: Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [2] and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing <ref> [12, 13] </ref>.
Reference: [13] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction This paper concerns algorithms for converting between two techniques for formalizing program-analysis problems: context-free-language reachability and a class of set constraints. Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing <ref> [13, 15] </ref>, interprocedural dataflow analysis [14], and shape analysis [22]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. <p> and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis [15] and interprocedural slicing <ref> [25, 13] </ref>. Set-constraints lead to natural formulations of shape analysis [17, 27]. <p> Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [2] and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing <ref> [12, 13] </ref>.
Reference: [14] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedural dataflow analysis. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 104-115, </pages> <month> October </month> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/fse95.ps). </note>
Reference-contexts: Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing [13, 15], interprocedural dataflow analysis <ref> [14] </ref>, and shape analysis [22]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. Typically, a set variable is created for each program variable at each program point. <p> These ideas were elaborated on in a sequence of papers <ref> [15, 14, 25] </ref>, and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability.
Reference: [15] <author> S. Horwitz, T. Reps, M. Sagiv, and G. Rosay. </author> <title> Speeding up slicing. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 11-20, </pages> <month> December </month> <year> 1994. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/fse94.ps). </note>
Reference-contexts: 1 Introduction This paper concerns algorithms for converting between two techniques for formalizing program-analysis problems: context-free-language reachability and a class of set constraints. Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing <ref> [13, 15] </ref>, interprocedural dataflow analysis [14], and shape analysis [22]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. <p> problem, one can think and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis <ref> [15] </ref> and interprocedural slicing [25, 13]. Set-constraints lead to natural formulations of shape analysis [17, 27]. <p> These ideas were elaborated on in a sequence of papers <ref> [15, 14, 25] </ref>, and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability.
Reference: [16] <author> N. D. Jones and W. T. Laaser. </author> <title> Complete problems for deterministic polynomial time. </title> <booktitle> Theoretical Computer Science 3, </booktitle> <pages> pages 105-117, </pages> <year> 1977. </year>
Reference-contexts: Note that O (log p n) O (log x 2 ) = O (2 log x). For any two log-space Turing machine programs Q and R, there is a log-space Turing machine program that is equivalent to the composition QffiR <ref> [16] </ref>. This means that there is a log-space Turing machine program P that is equivalent to P 2 ffi P 0 1 and performs the construction of this section for an arbitrary context-free grammar. <p> Since CFL-reachability problems are PTIME-complete (i.e., complete for PTIME under log-space reductions) [23], this means that the given class of set-constraint problems are also PTIME-complete <ref> [16] </ref>. 3.5 Analysis of the Running Time In general, an all-pairs CFL-reachability problem can be solved in time O (n 3 ), where n is the number of nodes in the graph.
Reference: [17] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Set-constraints lead to natural formulations of shape analysis <ref> [17, 27] </ref>.
Reference: [18] <author> U.P. Khedker and D.M. Dhamdhere. </author> <title> A generalized theory of bit vector data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1472-1511, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems <ref> [18] </ref>. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [2] and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing [12, 13].
Reference: [19] <author> L.T. Kou. </author> <title> On live-dead analysis for global data flow problems. </title> <journal> J. ACM, </journal> <volume> 24(3) </volume> <pages> 473-483, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou <ref> [19] </ref> and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interproce-dural side-effect analysis [2] and alias analysis [3].
Reference: [20] <author> D. McAllester and N. Heintze. </author> <title> On the complexity of set-based analysis. </title> <booktitle> In ICFP '97: Proceedings of the Second ACM SIGPLAN International Conference on Functional Programming, </booktitle> <year> 1997. </year>
Reference-contexts: 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based analysis with data constructors <ref> [20, 10] </ref>. A variety of work exists that has applied graph reachability (of various forms) to analysis of imperative programs. Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to intraprocedural bi-directional bit-vector problems [18].
Reference: [21] <author> T. Reps. </author> <title> Demand interprocedural program analysis using logic databases. </title> <editor> In R. Ramakrishnan, editor, </editor> <booktitle> Applications of Logic Databases. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: For example, a demand algorithm might be used to compute the results of a program analysis only for points in the innermost loops of a given program. Because CFL-reachability problems can be solved in a demand-driven fashion (e.g., see <ref> [22, 21] </ref>), this paper shows that (in principle) set-constraint problems can also be solved in a demand-driven fashion. To our knowledge, this has not been investigated before in the literature on set constraints. * CFL-reachability lends itself to analysis of languages with a lazy semantics [22]. <p> In fact, the CFL-reachability Algorithm presented here in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program. This suggests that the class of DATALOG programs that run in cubic time may be useful for program analysis (see also <ref> [21] </ref>). Many parts of a constructed CFL-reachability problem are more easily expressed in a DATALOG program. In particular, the addition of reverse edges, and the tracking of ground information is easy to express.
Reference: [22] <author> T. Reps. </author> <title> Shape analysis as a generalized path problem. </title> <booktitle> In PEPM '95: Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> New York, NY, 1995. </address> <publisher> ACM. </publisher>
Reference-contexts: Context-free-language reachability (CFL-reachability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing [13, 15], interprocedural dataflow analysis [14], and shape analysis <ref> [22] </ref>. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. Typically, a set variable is created for each program variable at each program point. <p> For example, a demand algorithm might be used to compute the results of a program analysis only for points in the innermost loops of a given program. Because CFL-reachability problems can be solved in a demand-driven fashion (e.g., see <ref> [22, 21] </ref>), this paper shows that (in principle) set-constraint problems can also be solved in a demand-driven fashion. To our knowledge, this has not been investigated before in the literature on set constraints. * CFL-reachability lends itself to analysis of languages with a lazy semantics [22]. <p> To our knowledge, this has not been investigated before in the literature on set constraints. * CFL-reachability lends itself to analysis of languages with a lazy semantics <ref> [22] </ref>. Set constraints are more readily used to analyze languages with a strict semantics. However, our interconvertibility results show that CFL-reachability can be used to analyze strict languages, and set constraints can be used to analyze lazy languages. <p> The basic technique is a modification of work done by Reps in using CFL-reachability to do shape analysis <ref> [22] </ref>. In essence, our encoding involves simulating the steps of the SC-Reduction Algorithm with the productions of a reachability problem. <p> These ideas were elaborated on in a sequence of papers [15, 14, 25], and also applied to shape analysis of functional programs <ref> [22] </ref>. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [22] and [24] mention CFL-reachability explicitly and <p> to shape analysis of functional programs <ref> [22] </ref>. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [22] and [24] mention CFL-reachability explicitly and reference Yannakakis's paper [29].) The constructions of the present paper for converting set-constraint problems to CFL-reachability problems|together with the fact that set constraints have been used for program analysis|show that CFL-reachability using path languages other than Dyck languages is also of utility for program
Reference: [23] <author> T. Reps. </author> <title> On the sequential nature of interprocedural program-analysis problems. </title> <journal> Acta Inf., </journal> <volume> 33 </volume> <pages> 739-757, </pages> <year> 1996. </year> <pages> 33 34 </pages>
Reference-contexts: This paper shows this to be the case for a class of set-constraint problems. * CFL-reachability is known to be log-space complete for polynomial time (or "PTIME-complete") <ref> [23] </ref>. Because the CFL-reachability to set-constraint construction can be performed in log-space, this paper demonstrates that a class of set-constraint problems are also PTIME-complete. <p> This means that there is a log-space Turing machine program P that is equivalent to P 2 ffi P 0 1 and performs the construction of this section for an arbitrary context-free grammar. Since CFL-reachability problems are PTIME-complete (i.e., complete for PTIME under log-space reductions) <ref> [23] </ref>, this means that the given class of set-constraint problems are also PTIME-complete [16]. 3.5 Analysis of the Running Time In general, an all-pairs CFL-reachability problem can be solved in time O (n 3 ), where n is the number of nodes in the graph.
Reference: [24] <author> T Reps. </author> <title> Program analysis via graph reachability. </title> <editor> In J. Maluszynski, editor, </editor> <booktitle> Proceedings of ILPS '97: Interna--tional Logic Programming Symposium, </booktitle> <pages> pages 5-19. </pages> <publisher> The M.I.T. Press, </publisher> <address> Cambridge, MA, </address> <year> 1997. </year>
Reference-contexts: kinds of nonexecutable paths should be filtered out [28]; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps et al. to be of utility for a wide variety of interprocedural program-analysis problems [26] (see also <ref> [24] </ref>). These ideas were elaborated on in a sequence of papers [15, 14, 25], and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. <p> All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability. The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [22] and <ref> [24] </ref> mention CFL-reachability explicitly and reference Yannakakis's paper [29].) The constructions of the present paper for converting set-constraint problems to CFL-reachability problems|together with the fact that set constraints have been used for program analysis|show that CFL-reachability using path languages other than Dyck languages is also of utility for program analysis.
Reference: [25] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/popl95.ps). 35 </note>
Reference-contexts: and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis [15] and interprocedural slicing <ref> [25, 13] </ref>. Set-constraints lead to natural formulations of shape analysis [17, 27]. <p> These ideas were elaborated on in a sequence of papers <ref> [15, 14, 25] </ref>, and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability.
Reference: [26] <author> T. Reps, M. Sagiv, and S. Horwitz. </author> <title> Interprocedural dataflow analysis via graph reachability. </title> <type> Technical Re--port TR 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, </institution> <year> 1994. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/diku-tr94-14.ps). </note>
Reference-contexts: contributions of certain kinds of nonexecutable paths should be filtered out [28]; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps et al. to be of utility for a wide variety of interprocedural program-analysis problems <ref> [26] </ref> (see also [24]). These ideas were elaborated on in a sequence of papers [15, 14, 25], and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachability.
Reference: [27] <author> J.C. Reynolds. </author> <title> Automatic computation of data set definitions. </title> <booktitle> In Information Processing 68: Proceedings of the IFIP Congress, </booktitle> <pages> pages 456-461, </pages> <address> New York, NY, 1968. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Set-constraints lead to natural formulations of shape analysis <ref> [17, 27] </ref>.
Reference: [28] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-234. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: various kinds of matched-parenthesis (Dyck) languages, and neither paper relates the work to the more general concept of CFL-reachability. (Dyck languages had been used in earlier work on interprocedural dataflow analysis by Sharir and Pnueli to specify that the contributions of certain kinds of nonexecutable paths should be filtered out <ref> [28] </ref>; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps et al. to be of utility for a wide variety of interprocedural program-analysis problems [26] (see also [24]).
Reference: [29] <author> M. Yannakakis. </author> <title> Graph-theoretic methods in database theory. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 230-242, </pages> <year> 1990. </year> <month> 36 </month>
Reference-contexts: The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [22] and [24] mention CFL-reachability explicitly and reference Yannakakis's paper <ref> [29] </ref>.) The constructions of the present paper for converting set-constraint problems to CFL-reachability problems|together with the fact that set constraints have been used for program analysis|show that CFL-reachability using path languages other than Dyck languages is also of utility for program analysis. <p> It is also interesting to note another fact about CFL-reachability: every CFL-reachability problem can be stated as a chain program in DATALOG <ref> [29] </ref>; edges are represented as facts, and productions are encoded as Horn clauses. In fact, the CFL-reachability Algorithm presented here in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program.
References-found: 29

