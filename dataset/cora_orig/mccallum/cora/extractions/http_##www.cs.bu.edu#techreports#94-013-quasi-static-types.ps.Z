URL: http://www.cs.bu.edu/techreports/94-013-quasi-static-types.ps.Z
Refering-URL: http://cs-www.bu.edu/techreports/Home.html
Root-URL: 
Title: An Algorithm for Inferring Quasi-Static Types  
Author: Alberto Oliart 
Date: December 14, 1994  
Abstract: This report presents an algorithm, and its implementation, for doing type inference in the context of Quasi-Static Typing (QST) [14]. The package infers types a la "QST" for the simply typed -calculus.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi, Luca Cardelli, Benjamin Pierce, Gordon Plotkin. </author> <title> Dynamic Typing in a Statically Typed Language ACM Transactions on Programming Languages and Systems Vol. </title> <journal> 13, </journal> <volume> No. 2, </volume> <month> April </month> <year> 1991 </year>
Reference-contexts: In these cases, some degree of dynamic typing is needed. As an example taken from <ref> [1] </ref> consider a program that reads a bitmap and displays it. If the bitmap is stored in an external file, the program has to read the contents of the file. If the contents is the representation of a bitmap, then there is no problem. <p> So some dynamic typing is needed even in statically typed languages. Another disadvantage of statically typed programming languages is the impossibility to have non homogeneous data objects. As an example, it is possible to handle the list <ref> [1; true; "string 00 ] </ref> in Lisp, but not in ML. This also motivates the addition of dynamics to static languages [13]. Our aim is to find a typing system that allows most programs to run but stops all programs it can guarantee will have type mismatches at run-time.
Reference: [2] <author> Luca Cardelli and Peter Wegner On Understanding Types, </author> <title> Data Abstractions, </title> <journal> and Polymorphism Computing Surveys, </journal> <volume> Vol 17, No. 4, </volume> <month> Dec. </month> <year> 1985 </year>
Reference: [3] <author> R. Cartwright and M. </author> <title> Fagan Soft Typing Proc. </title> <booktitle> ACM SIGPLAN '91 ACM Press 1991. </booktitle>
Reference: [4] <author> L. Damas, R. </author> <title> Milner Principal Type Schemes for Functional Programs 9th ACM Symp. </title> <booktitle> on Principles of Programming Languages 1982 </booktitle>
Reference: [5] <author> C. </author> <title> Gomard Partial Type Inference for Untyped Functional Languages (extended abstract) Proc.. </title> <booktitle> Lisp and Functional Programming 1990. </booktitle>
Reference: [6] <institution> Fritz Henglein Dynamic Typing To appear in European Symposioum on Programming 1992. </institution>
Reference-contexts: This creates problems for let-polymorphism. As an example consider the following expression (in the expression we make use of lists, not included in the original language, we do this because this example has been used elsewhere to illustrate the problem, see <ref> [6] </ref> and [14]): M = x:cons (1; x) The type of M is int-list ! int-list. But if we apply M to a boolean, say M true, then M could be modified as follows by the above system: x : -list:cons (1 " int ; x) with type list!-list.
Reference: [7] <institution> Fritz Henglein Global Tagging optimizations by Type Checking To appear in Lisp and Functional Programming 1992. </institution>
Reference: [8] <author> Dexter Kozen, Jens Palsberg, Michael I. </author> <title> Schwartzbach Efficient Inference of Partial Types to appear </title>
Reference: [9] <editor> Hans Leiss Combining Recursive and Dynamic Types Some Proceedings, </editor> <year> 1993. </year>
Reference: [10] <author> Xavier Leroy, </author> <booktitle> Michel Mauny Dynamics in ML 5Th ACM Conference onFunctional Progrmming Languages and Computer Architecture. Lecture Notes In Computer Science. </booktitle> <publisher> Springer Verlag 1991. </publisher>
Reference: [11] <author> Patrick M. O'Keefe, </author> <title> Mitchell Wand Type Inference for Partial Types is Decidable Proceedings of Fifth European Symposium on Programming, </title> <note> LNCS 582 1992 </note>
Reference: [12] <author> Plotkin, G. </author> <title> Call by Name, Call by Value, </title> <booktitle> and the -calculus Theoretical Computer Science, </booktitle> <month> 1 </month> <year> 1975 </year>
Reference: [13] <editor> Satish Thatte Type inference with partial types Proc. </editor> <booktitle> Int. Coll. on Automata, Languages and Programming, </booktitle> <year> 1988 </year>
Reference-contexts: Another disadvantage of statically typed programming languages is the impossibility to have non homogeneous data objects. As an example, it is possible to handle the list [1; true; "string 00 ] in Lisp, but not in ML. This also motivates the addition of dynamics to static languages <ref> [13] </ref>. Our aim is to find a typing system that allows most programs to run but stops all programs it can guarantee will have type mismatches at run-time. <p> The idea is to have a system that combines static and dynamic types, not accepting some expressions that will lead to run time type error, while accepting others that may lead to error at run time. Quasi Static Typing (QST) QST is a combination of Partial Types (see <ref> [13] </ref>) and automatic insertion of implicit positive (tagging) and negative (checking) coercions, see [14]. The system divides programs into three categories, well typed, ill typed and ambivalent. 2 The typing system has two phases, that can be integrated into one "pass". <p> Well typed programs will never produce a run time type error, whereas ambivalent programs may or may not end in a run time type error. The types assigned by QST are Partial Types, which were originally introduced in <ref> [13] </ref> with the intention of type checking heterogeneous objects. They include the type , which is a type assignable to all objects except the object called wrong that denotes run time type error, and a subtype relation.
Reference: [14] <editor> Satish Thatte Quasy-static Typing Prc. </editor> <booktitle> ACM Symp. om Principles of Programming Languages, </booktitle> <year> 1988 </year>
Reference-contexts: We present a type inference algorithm that infers types in the context of "Quasi Static Typing", which was introduced by Thatte in <ref> [14] </ref>. The idea is to have a system that combines static and dynamic types, not accepting some expressions that will lead to run time type error, while accepting others that may lead to error at run time. <p> Quasi Static Typing (QST) QST is a combination of Partial Types (see [13]) and automatic insertion of implicit positive (tagging) and negative (checking) coercions, see <ref> [14] </ref>. The system divides programs into three categories, well typed, ill typed and ambivalent. 2 The typing system has two phases, that can be integrated into one "pass". The first one inserts implicit coercions where there is the possibility of a type mismatch, and the other does "plausibility checking". <p> This phase, called plausibility checking, is described in <ref> [14] </ref> as a confluent terminating set of rewrite rules. These rules are given below. <p> following way, x : ! : x x, then the resulting internal expression is x : ! :x x " ! : Example 2 (x : ! : x x)(x : : x x) The resulting internal expression is: (x : ! :(xx " ! ))(x : :(x # In <ref> [14] </ref>, Thatte gives an algorithm called Type that tries to integrates in one pass the typing rules and the plausibility checking phase. Given an expression in the object language, this algorithm returns an expression in the internal language and a type for it. The algorithm, as it appears in [14] is <p> In <ref> [14] </ref>, Thatte gives an algorithm called Type that tries to integrates in one pass the typing rules and the plausibility checking phase. Given an expression in the object language, this algorithm returns an expression in the internal language and a type for it. The algorithm, as it appears in [14] is : T ype (T E; e) = case e of x : T E (x); x x : t:e body : let t b ; e b = T ype (T E [x t ]; e body ) in t ! x : t:e b in if t f <p> t:e b in if t f = t fa ! t fr then let e na = Simplif y (e a " t a # else if t f = then ; (e f # t a ! e a ) else f ail 4 Contrary to the claim in <ref> [14] </ref>, page 375, this algorithm does not type all expressions that can be typed by the typing rules, as shown by the following example. Consider the following expression: (x : int:succ x) true where succ is the succesor function with type int ! int. <p> We have also eliminated pairing because it adds nothing to the discussion. The idea is to integrate plausibility checking into a typing system that does type inference, extending the work in <ref> [14] </ref>. <p> In <ref> [14] </ref> there are two typing systems, one is defined by the typing rules and the other by the Type algorithm. The choice is maybe a matter of taste. <p> This creates problems for let-polymorphism. As an example consider the following expression (in the expression we make use of lists, not included in the original language, we do this because this example has been used elsewhere to illustrate the problem, see [6] and <ref> [14] </ref>): M = x:cons (1; x) The type of M is int-list ! int-list. But if we apply M to a boolean, say M true, then M could be modified as follows by the above system: x : -list:cons (1 " int ; x) with type list!-list.
Reference: [15] <author> David. A. </author> <title> Watt Programming Language Concepts and Paradigms Prentice Hall International, </title> <year> 1990 </year>
References-found: 15

