URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr93/tr93-021.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr93-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: Characterizing the Performance of Algorithms for Lock-free Objects  
Author: Theodore Johnson 
Address: Gainesville, Fl 32611-2024  
Affiliation: Dept. of CIS University of Florida  
Abstract: Concurrent access to shared data objects must be regulated by a concurrency control protocol to ensure correctness. Many concurrency control protocols require that a process set a lock on the data it accesses. Recently, there has been considerable interest in lock-free concurrency control algorithms. Lock-free algorithms offer the potential for better system performance because slow or failed processes do not block fast processes. Process "slowdowns" can occur due to cache line faults, memory and bus contention, page faults, context switching, NUMA architectures, heterogeneous architectures, or differences in operation execution time. Much work has been done to characterize the performance of locking algorithms, but little has been done to characterize the performance of lock-free algorithms. In this paper, we present a performance model for analyzing lock-free algorithms that studies the effects of slowdowns on performance. We find that lock-free algorithms are better than locking algorithms if the slowdowns are transient, but worse if the slowdowns are permanent. One implication of this result is that lock-free concurrent objects are appropriate for UMA architectures, but NUMA architectures require special protocols.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Agrawal and M. Cherian. </author> <title> Adaptive backoff synchronization techniques. </title> <booktitle> In Int'l Symposium on 26 Computer Architecture, </booktitle> <pages> pages 396-406, </pages> <year> 1989. </year>
Reference-contexts: Many analyses of synchronization methods have examined the relative performance of shared memory locks. Mellor-Crummey and Scott [39] present performance measurements to show the good performance of their algorithm relative to that of some test-and-set and ticket-based algorithms. Agrawal and Cherian <ref> [1] </ref> present simulation results and a simple analytical model to explore the performance of adaptive backoff synchronization schemes. Anderson [4] presents measurement results of the performance of several spin locks, and suggests a new ticket-based spin lock.
Reference: [2] <author> J. </author> <title> Alemany and E.W. Felton. Performance issues in non-blocking synchronization on shared memory multiprocessors. </title> <booktitle> In Proc. ACM Symp. Principles of Distributed Computing, </booktitle> <year> 1992. </year>
Reference-contexts: Herlihy has also proposed methods for wait-free concurrent objects, in which every operation is guaranteed of completion within a bounded number of steps. We do not address the performance of wait-free objects in this paper. Considerable research on lock-free concurrent algorithms has been done lately <ref> [25, 22, 58, 2, 23, 56] </ref>. The researchers who work on lock-free algorithms claim that lock-free algorithms can improve the performance of concurrent systems because fast operations execute at the expense of slow operations. <p> The contention for setting the lock is similar to the phenomena modeled in this work. Some researchers have investigated hybrid techniques that are primarily locking, but can force processes to release their locks when the process experiences a context switch <ref> [2, 11] </ref>. These methods use non-locking algorithms to ensure correctness. Several architectures that support lock-free algorithms have been proposed [56, 23]. <p> However, this approach has several drawbacks. It requires a more complex kernel, it requires a more complex user/kernel interaction, and it allows a user to grab control of the multiprocessor by having the processes lock "dummy" semaphores. Alemany and Felton <ref> [2] </ref> and Bershad [11] have proposed hybrid schemes that are primarily locking, but which force processes to release their locks on a context switch (using a technique similar to non-locking protocols to ensure correctness). <p> Thus, lock-free algorithms are not appropriate on heterogeneous or NUMA architectures, or when some types of operations require significantly more computation than others. In these cases, non-blocking algorithms must incorporate a fairness mechanism to provide good performance. Approachs to such mechanisms are described in <ref> [2, 11] </ref>.
Reference: [3] <author> R. Anderson and H. Woll. </author> <title> Wait-free algorithms for the union-find problem. </title> <booktitle> In Proc. ACM Symp. on Theory of Computation, </booktitle> <pages> pages 370-380, </pages> <year> 1991. </year>
Reference-contexts: Valois [59] has developed similar non-blocking algorithms for queues, linked lists, and binary search trees. Herlihy and Moss [25] present non-blocking algorithms for garbage collection. Anderson and Woll <ref> [3] </ref> present wait-free algorithms for the union-find problem. Turek, Shasha, and Prakash [58] have techniques for transforming concurrent objects implemented with locks into concurrent non-blocking objects. Every operation keeps its `program' in a publicly available location.
Reference: [4] <author> T. E. Anderson. </author> <title> The performance of spin lock alternatives for shared memory multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <year> 1990. </year>
Reference-contexts: Mellor-Crummey and Scott [39] present performance measurements to show the good performance of their algorithm relative to that of some test-and-set and ticket-based algorithms. Agrawal and Cherian [1] present simulation results and a simple analytical model to explore the performance of adaptive backoff synchronization schemes. Anderson <ref> [4] </ref> presents measurement results of the performance of several spin locks, and suggests a new ticket-based spin lock. Woest and Goodman [61] present simulation results to compare queue-on-lock-bit synchronization techniques against test-and-set spin locks, and the Mellor-Crummey and Scott lock.
Reference: [5] <author> T.E. Anderson, B.N. Bershad, E.D. Lazowska, and H.M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <year> 1992. </year>
Reference-contexts: Many researchers have worked on avoiding the problems caused by long slowdowns. One approach is to delay the context switch of a process while the process holds a lock <ref> [5, 38, 64] </ref>. These authors report a large improvement in efficiency in multitasking parallel processors by avoiding large slowdowns. However, this approach has several drawbacks.
Reference: [6] <author> T.E. Anderson, E.D. Lazowska, and H.M. Levy. </author> <title> The performance implications of thread management alternatives for shared memory multiprocessors. </title> <journal> IEEE Trans. on Computers, </journal> <volume> 38(12) </volume> <pages> 1631-1644, </pages> <year> 1989. </year>
Reference-contexts: They present analytical models to derive the best point for a blocked process to switch from spinning to blocking. Glenn, Pryor, Conroy, and Johnson [16] present analytical models which show that a thrashing phenomenon can occur due to contention for a synchronization variable. Anderson, Lazowska, and Levy <ref> [6] </ref> present some simple queuing models of critical section access to study thread management schemes. Zahoran, Lazowska, and Eager [64] present a variety on analytical and simulation models to study the interaction of synchronization and scheduling policies in a multitasking parallel processor.
Reference: [7] <author> K.E. Atkinson. </author> <title> An Introduction to Numerical Analysis. </title> <publisher> John Wiley and Sons, </publisher> <year> 1978. </year>
Reference-contexts: In the VF model, it is possible for the utilization to be greater than 1 (because of the bias towards fast executions), so the root finder must use one of the standard nonlinear equation solution methods <ref> [7] </ref>. 5.1.2 Solving The VV Model In the VV transaction model, when a transaction aborts, it leaves the system and a new transaction enters.
Reference: [8] <author> R. Bayer and M. Schkolnick. </author> <title> Concurrency of operations on B-trees. </title> <journal> Acta Informatica, </journal> <volume> 9 </volume> <pages> 1-21, </pages> <year> 1977. </year>
Reference-contexts: Locking protocols for concurrent database access are well-known [10]. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees [33, 37], AVL trees [15], B-trees <ref> [8, 53] </ref>, priority queues [12, 46, 30] and so on. Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47]. <p> The first transaction class models the fast processors. Its execution time is chosen uniformly randomly in [:8; 1:2], and f 1 = :9. The execution time of the second transaction class, which represents the slow processors, is chosen uniformly randomly in <ref> [8; 12] </ref>, and f 2 = :1. We plot the throughput of the nonblocking queue for the permanent and transient slowdown models (VF and VV) against increasing V in Figure 1. For comparison, we also plot the throughput of the locking algorithm algorithm, which is a constant 1=b = 1=1:9. <p> The third stage ends when the operation tries to commit its operation, and requires 8 instructions. Fast processors require a time uniformly randomly chosen in [:8; 1:2] to execute the instructions in a stage, and slow processors require a time uniformly randomly chosen between in <ref> [8; 12] </ref>. That is, the time to execute a stage is the number of instructions in the stage multiplied by a sample uniformly randomly selected from [lo; hi]. The results of the experiments are shown in Figures 7 and 8. These figures show the response times and idle probability, respectively.
Reference: [9] <author> Inc. </author> <title> BBN Advanced Computers. Tc2000 programming handbook. </title>
Reference-contexts: A typical non-blocking algorithm reads the state of the object, computes its modifications, then attempts to commit its modification. If no conflicting operation has modified the object, the commit is successful, and the operation is finished. Otherwise, the operation tries again. The operation typically uses the compare-and-swap <ref> [65, 9, 43] </ref> atomic read-modify-write instruction to try to commit its modifications (one work uses the load-locked/store-conditional instruction [22], and several special architecture that support lock-free algorithms have been developed [23, 56]). While many additional non-blocking and lock-free algorithms have been proposed, most have this essential form.
Reference: [10] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Shared locks are compatible with each other, but an exclusive lock is compatible with no other lock. Locking protocols for concurrent database access are well-known <ref> [10] </ref>. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees [33, 37], AVL trees [15], B-trees [8, 53], priority queues [12, 46, 30] and so on. <p> Since there is no queuing in lock-free algorithms, these techniques do not apply. Researchers [22] have observed that non-blocking data structure algorithms are similar to to optimistic concurrency control (OCC) in databases <ref> [10] </ref>. Optimistic concurrency control is so named because it makes the optimistic assumption that data conflicts are rare. A transaction accesses data without regard to possible conflicts. If a data conflict does occur, the transaction is aborted and restarted.
Reference: [11] <author> B. Bershad. </author> <title> Practical considerations for non-blocking concurrent objects. </title> <booktitle> In Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pages 264-273, </pages> <year> 1993. </year>
Reference-contexts: The contention for setting the lock is similar to the phenomena modeled in this work. Some researchers have investigated hybrid techniques that are primarily locking, but can force processes to release their locks when the process experiences a context switch <ref> [2, 11] </ref>. These methods use non-locking algorithms to ensure correctness. Several architectures that support lock-free algorithms have been proposed [56, 23]. <p> However, this approach has several drawbacks. It requires a more complex kernel, it requires a more complex user/kernel interaction, and it allows a user to grab control of the multiprocessor by having the processes lock "dummy" semaphores. Alemany and Felton [2] and Bershad <ref> [11] </ref> have proposed hybrid schemes that are primarily locking, but which force processes to release their locks on a context switch (using a technique similar to non-locking protocols to ensure correctness). <p> Thus, lock-free algorithms are not appropriate on heterogeneous or NUMA architectures, or when some types of operations require significantly more computation than others. In these cases, non-blocking algorithms must incorporate a fairness mechanism to provide good performance. Approachs to such mechanisms are described in <ref> [2, 11] </ref>.
Reference: [12] <author> J. Biswas and J.C. Browne. </author> <title> Simultaneous update of priority structures. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 124-131, </pages> <year> 1987. </year>
Reference-contexts: Locking protocols for concurrent database access are well-known [10]. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees [33, 37], AVL trees [15], B-trees [8, 53], priority queues <ref> [12, 46, 30] </ref> and so on. Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47]. <p> The first transaction class models the fast processors. Its execution time is chosen uniformly randomly in [:8; 1:2], and f 1 = :9. The execution time of the second transaction class, which represents the slow processors, is chosen uniformly randomly in <ref> [8; 12] </ref>, and f 2 = :1. We plot the throughput of the nonblocking queue for the permanent and transient slowdown models (VF and VV) against increasing V in Figure 1. For comparison, we also plot the throughput of the locking algorithm algorithm, which is a constant 1=b = 1=1:9. <p> The third stage ends when the operation tries to commit its operation, and requires 8 instructions. Fast processors require a time uniformly randomly chosen in [:8; 1:2] to execute the instructions in a stage, and slow processors require a time uniformly randomly chosen between in <ref> [8; 12] </ref>. That is, the time to execute a stage is the number of instructions in the stage multiplied by a sample uniformly randomly selected from [lo; hi]. The results of the experiments are shown in Figures 7 and 8. These figures show the response times and idle probability, respectively.
Reference: [13] <author> I.Y. Bucher and D.A. Calahan. </author> <title> Models of access delays in multiprocessor memories. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 3(3) </volume> <pages> 270-280, </pages> <year> 1992. </year>
Reference-contexts: The first type of processor slowdowns are `small' slowdowns. Small slowdowns can be caused by cache line faults, contention for the memory module, and contention for the bus or interconnection network <ref> [13] </ref>. Another source of small slowdowns lies in the dependence of the execution time of an operation on the data in the data structure. For example, a priority queue might be implemented as a sorted list.
Reference: [14] <author> H.A. David. </author> <title> Order Statistics. </title> <publisher> John Wiley, </publisher> <year> 1981. </year>
Reference-contexts: The distributions of the execution times of the successful and unsuccessful operations are calculated by taking order statistics <ref> [14] </ref>: 14 b s b f where K s and K f are normalizing constants computed by K s = 0 1 Z 1 (1 e fl c t )b c (t)dt If b s c are the expected values of b s c (t) and b f c (t), respectively,
Reference: [15] <author> C.S. Ellis. </author> <title> Concurrent search and insertion in AVL trees. </title> <journal> IEEE Transactions on Computers, </journal> <volume> c-29(9):811-817, </volume> <year> 1980. </year>
Reference-contexts: Locking protocols for concurrent database access are well-known [10]. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees [33, 37], AVL trees <ref> [15] </ref>, B-trees [8, 53], priority queues [12, 46, 30] and so on. Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47].
Reference: [16] <author> R.R. Glenn, D.V. Pryor, J.M. Conroy, and T. Johnson. </author> <title> A bistability throughput phenomenon in a shared-memory mimd machine. </title> <journal> The Journal of Supercomputing, </journal> <volume> 7 </volume> <pages> 357-375, </pages> <year> 1993. </year>
Reference-contexts: Other authors have examined particular aspects of synchronization performance. Lim and Agrawal [36] examine the performance tradeoffs between spinning and blocking. They present analytical models to derive the best point for a blocked process to switch from spinning to blocking. Glenn, Pryor, Conroy, and Johnson <ref> [16] </ref> present analytical models which show that a thrashing phenomenon can occur due to contention for a synchronization variable. Anderson, Lazowska, and Levy [6] present some simple queuing models of critical section access to study thread management schemes.
Reference: [17] <author> A. Gottlieb, B. D. Lubachevsky, and L. Rudolph. </author> <title> Coordinating large numbers of processors. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing. IEEE, </booktitle> <year> 1981. </year>
Reference-contexts: Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism <ref> [24, 17, 34] </ref>, most of the recently proposed methods [45, 58, 19, 55, 59, 60, 56, 23] are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object).
Reference: [18] <author> G. Graunke and S. Thakkar. </author> <title> Synchronization mechanisms for shared-memory multiprocessors. </title> <journal> IEEE Computer, </journal> <volume> 26(3) </volume> <pages> 60-69, </pages> <year> 1990. </year>
Reference-contexts: Anderson [4] presents measurement results of the performance of several spin locks, and suggests a new ticket-based spin lock. Woest and Goodman [61] present simulation results to compare queue-on-lock-bit synchronization techniques against test-and-set spin locks, and the Mellor-Crummey and Scott lock. Graunke and Thakkar <ref> [18] </ref> present performance measurements of test-and-set and ticket based locks. Other authors have examined particular aspects of synchronization performance. Lim and Agrawal [36] examine the performance tradeoffs between spinning and blocking. They present analytical models to derive the best point for a blocked process to switch from spinning to blocking.
Reference: [19] <author> K. Harathi and T. Johnson. </author> <title> A priority synchronization algorithm for multiprocessors. </title> <type> Technical Report tr93.005, </type> <institution> UF, </institution> <year> 1991. </year> <note> available at ftp.cis.ufl.edu:cis/tech-reports. </note>
Reference-contexts: Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism [24, 17, 34], most of the recently proposed methods <ref> [45, 58, 19, 55, 59, 60, 56, 23] </ref> are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object). <p> This approach is used by Herlihy [21], is a step in Turek's algorithms [58] and is an approximation to the algorithms proposed by Prakash et al. [45], Valois [59, 60], and Harathi and Johnson <ref> [19] </ref>. We want to model both transient and permanent slowdowns. The V/F model accounts for transient and permanent slowdowns, and the V/V model permits transient slowdowns only. We are modeling algorithms in which the snapshot is performed atomically, so the operations execute SS transactions. <p> figures also show that the VF model is too optimistic, and that the VF approx model makes poor predictions of the response times but good predictions of the system utilization. 8.2 Composite Snapshot Several non-blocking algorithms take a snapshot of several variables to determine the state of the data structure <ref> [45, 59, 60, 19, 22] </ref>. While taking an atomic composite snapshot requires a more complex algorithm, it reduces the amount of copying needed to perform an operation, which improves performance. In addition, architectures that support lock-free algorithms have been proposed [23, 56].
Reference: [20] <author> T. </author> <title> Harder. Observations on optimistic concurrency control schemes. </title> <journal> Inform. Systems, </journal> <volume> 9(2) </volume> <pages> 111-120, </pages> <year> 1984. </year>
Reference-contexts: We also distinguish between silent and broadcast concurrency control. The pseudo-code in Code 4 is silent optimistic concurrency control: an operation doesn't advertise its commit, and transactions that will abort continue to execute. Alternatively, a transaction can broadcast its commit, so that conflicting transactions can restart immediately <ref> [48, 20] </ref>. We model the transaction processing system as a closed system in which V transactions each execute one of C transaction types. When a new transaction enters the system, it is a class c transaction with probability f c , P C f c = 1.
Reference: [21] <author> M. Herlihy. </author> <title> A methodology for implementing highly concurrent data structures. </title> <booktitle> In Proceeding of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 197-206. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: The performance of locking protocols also has been well studied. Tay, Suri, and Goodman [57], and Ryu and Thomasian [52] have developed analytical models of the performance of Two-phase Locking variants in database systems. Herlihy has proposed general methods for implementing non-blocking concurrent objects (i.e., concurrent data structures) <ref> [21] </ref>. In a non-blocking object, one of the processes that accesses the object is guaranteed to make progress in its computation within a finite number of steps. A non-blocking algorithm is fault-tolerant, since a failed process will not make the object unavailable. <p> We find that lock-free algorithms are better than locking algorithms if the slowdowns are transient, but worse if the slowdowns are permanent. We extend the explanatory model to a model that accurately predicts the utilization of the shared object. 2 2 Lock-free Algorithms Herlihy <ref> [21] </ref> introduced the idea of a non-blocking algorithm for implementing concurrent data structures. A concurrent algorithm is nonblocking if it is guaranteed that some processor makes progress in its computation in a finite number of steps. If a process sets a lock and then fails, no process can make progress. <p> This approach is used by Herlihy <ref> [21] </ref>, is a step in Turek's algorithms [58] and is an approximation to the algorithms proposed by Prakash et al. [45], Valois [59, 60], and Harathi and Johnson [19]. We want to model both transient and permanent slowdowns.
Reference: [22] <author> M. Herlihy. </author> <title> A methodology for implementing highly concurrent data objects. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(5) </volume> <pages> 745-770, </pages> <year> 1993. </year>
Reference-contexts: If no conflicting operation has modified the object, the commit is successful, and the operation is finished. Otherwise, the operation tries again. The operation typically uses the compare-and-swap [65, 9, 43] atomic read-modify-write instruction to try to commit its modifications (one work uses the load-locked/store-conditional instruction <ref> [22] </ref>, and several special architecture that support lock-free algorithms have been developed [23, 56]). While many additional non-blocking and lock-free algorithms have been proposed, most have this essential form. <p> Herlihy has also proposed methods for wait-free concurrent objects, in which every operation is guaranteed of completion within a bounded number of steps. We do not address the performance of wait-free objects in this paper. Considerable research on lock-free concurrent algorithms has been done lately <ref> [25, 22, 58, 2, 23, 56] </ref>. The researchers who work on lock-free algorithms claim that lock-free algorithms can improve the performance of concurrent systems because fast operations execute at the expense of slow operations. <p> Process "slowdowns" can occur due to cache line faults, memory and bus contention, page faults, context switching, NUMA architectures, heterogeneous architectures, or differences in operation execution time. While some work has been done to measure the performance of lock-free algorithms <ref> [22, 23, 45] </ref>, the performance of lock-free algorithms relative to that of blocking algorithms has received little study [45]. In this work, we develop a performance model of lock-free algorithms. Our model studies the effects of both transient and permanent slowdowns in the speed of operation execution. <p> A process might experience a permanent slowdown while executing an operation because of the operation itself. Different operations on a shared object might require different times to compute. For example, Herlihy <ref> [22] </ref> observed that enqueues into a priority queue experienced discrimination because they take longer to compute. In an earlier work [45], we ran several simulation studies to compare the performance of our non-blocking queue to that of a lock-based implementation under different conditions. <p> Considerable work has been done to analyze the performance of concurrent data structure algorithms [29, 28]. These techniques assume that the algorithm is lock-based, and concentrate on analyzing waiting times in the lock queues. Since there is no queuing in lock-free algorithms, these techniques do not apply. Researchers <ref> [22] </ref> have observed that non-blocking data structure algorithms are similar to to optimistic concurrency control (OCC) in databases [10]. Optimistic concurrency control is so named because it makes the optimistic assumption that data conflicts are rare. A transaction accesses data without regard to possible conflicts. <p> ) read g into T 's local workspace access time (g)=Global time validate (T) for each g 2 R (T ) if access time (g)&lt;t (g) abort (T) for each g 2 W (T ) t (g)=Global time 9 commit (T) Code 4 OCC validation As has been noted elsewhere <ref> [22] </ref>, lock-free protocols of the types described in Code 2 and 3 are essentially similar to the OCC validation described in Code 4. Both types of algorithms read some data values, then commit if and only if no interfering writes have occurred. <p> figures also show that the VF model is too optimistic, and that the VF approx model makes poor predictions of the response times but good predictions of the system utilization. 8.2 Composite Snapshot Several non-blocking algorithms take a snapshot of several variables to determine the state of the data structure <ref> [45, 59, 60, 19, 22] </ref>. While taking an atomic composite snapshot requires a more complex algorithm, it reduces the amount of copying needed to perform an operation, which improves performance. In addition, architectures that support lock-free algorithms have been proposed [23, 56].
Reference: [23] <author> M. Herlihy and J.E.B. Moss. </author> <title> Transactional memory: Architectural support for lock-free data structures. </title> <booktitle> In Proc. Int'l Symp. on Computer Architecture, </booktitle> <pages> pages 289-300, </pages> <year> 1993. </year>
Reference-contexts: Otherwise, the operation tries again. The operation typically uses the compare-and-swap [65, 9, 43] atomic read-modify-write instruction to try to commit its modifications (one work uses the load-locked/store-conditional instruction [22], and several special architecture that support lock-free algorithms have been developed <ref> [23, 56] </ref>). While many additional non-blocking and lock-free algorithms have been proposed, most have this essential form. Herlihy has also proposed methods for wait-free concurrent objects, in which every operation is guaranteed of completion within a bounded number of steps. <p> Herlihy has also proposed methods for wait-free concurrent objects, in which every operation is guaranteed of completion within a bounded number of steps. We do not address the performance of wait-free objects in this paper. Considerable research on lock-free concurrent algorithms has been done lately <ref> [25, 22, 58, 2, 23, 56] </ref>. The researchers who work on lock-free algorithms claim that lock-free algorithms can improve the performance of concurrent systems because fast operations execute at the expense of slow operations. <p> Process "slowdowns" can occur due to cache line faults, memory and bus contention, page faults, context switching, NUMA architectures, heterogeneous architectures, or differences in operation execution time. While some work has been done to measure the performance of lock-free algorithms <ref> [22, 23, 45] </ref>, the performance of lock-free algorithms relative to that of blocking algorithms has received little study [45]. In this work, we develop a performance model of lock-free algorithms. Our model studies the effects of both transient and permanent slowdowns in the speed of operation execution. <p> Some researchers have investigated hybrid techniques that are primarily locking, but can force processes to release their locks when the process experiences a context switch [2, 11]. These methods use non-locking algorithms to ensure correctness. Several architectures that support lock-free algorithms have been proposed <ref> [56, 23] </ref>. <p> Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism [24, 17, 34], most of the recently proposed methods <ref> [45, 58, 19, 55, 59, 60, 56, 23] </ref> are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object). <p> While taking an atomic composite snapshot requires a more complex algorithm, it reduces the amount of copying needed to perform an operation, which improves performance. In addition, architectures that support lock-free algorithms have been proposed <ref> [23, 56] </ref>. These architectures allow a process to reserve several words of shared memory, and inform the processor if a conflicting write occurs. Code 5, taken from [45], shows a typical protocol to take an atomic snapshot for an algorithm that implements a non-blocking queue.
Reference: [24] <author> M. Herlihy and J. Wing. </author> <title> Axioms for concurrent objects. </title> <booktitle> In Fourteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 13-26, </pages> <year> 1987. </year>
Reference-contexts: Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism <ref> [24, 17, 34] </ref>, most of the recently proposed methods [45, 58, 19, 55, 59, 60, 56, 23] are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object).
Reference: [25] <author> M.P. Herlihy and J.E.B. Moss. </author> <title> Lock-free garbage collection for multiprocessors. </title> <booktitle> In Proc. ACM Symp. on Parallel Algorithms and Architectures, </booktitle> <pages> pages 229-236, </pages> <year> 1991. </year>
Reference-contexts: Herlihy has also proposed methods for wait-free concurrent objects, in which every operation is guaranteed of completion within a bounded number of steps. We do not address the performance of wait-free objects in this paper. Considerable research on lock-free concurrent algorithms has been done lately <ref> [25, 22, 58, 2, 23, 56] </ref>. The researchers who work on lock-free algorithms claim that lock-free algorithms can improve the performance of concurrent systems because fast operations execute at the expense of slow operations. <p> Valois [59] has developed similar non-blocking algorithms for queues, linked lists, and binary search trees. Herlihy and Moss <ref> [25] </ref> present non-blocking algorithms for garbage collection. Anderson and Woll [3] present wait-free algorithms for the union-find problem. Turek, Shasha, and Prakash [58] have techniques for transforming concurrent objects implemented with locks into concurrent non-blocking objects. Every operation keeps its `program' in a publicly available location.
Reference: [26] <institution> IBM T.J. Watson Research Center. System/370 Principles of Operations, </institution> <year> 1983. </year>
Reference-contexts: A typical non-blocking algorithm has the form of Herlihy's small-object protocol, which is shown in Code 2. In this paper, we are abstracting away the memory management problems that can result in the A-B-A problem <ref> [26] </ref>. object access (point,[parameters]) object **point f object *old object, *new object while (True) f old object := snapshot (point) new object := serial update (old object,[parameters]) 3 if (CNS (point,old object,new object) = True) break; g Code 2 Herlihy's small-object lock-free protocol.
Reference: [27] <author> T. Johnson. </author> <title> Approximate analysis of reader and writer access to a shared resource. </title> <booktitle> In ACM SIGMET-RICS Conference on Measuring and Modeling of Computer Systems, </booktitle> <pages> pages 106-114, </pages> <year> 1990. </year>
Reference-contexts: Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established <ref> [27, 28, 47] </ref>. A general analytical model for modeling the performance of lock-based concurrent data structure algorithms has been developed [29, 28]. The performance of locking protocols also has been well studied.
Reference: [28] <author> T. Johnson. </author> <title> The Performance of Concurrent Data Structure Algorithms. </title> <type> PhD thesis, </type> <institution> NYU Dept. of Computer Science, </institution> <year> 1990. </year> <month> 28 </month>
Reference-contexts: Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established <ref> [27, 28, 47] </ref>. A general analytical model for modeling the performance of lock-based concurrent data structure algorithms has been developed [29, 28]. The performance of locking protocols also has been well studied. <p> The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47]. A general analytical model for modeling the performance of lock-based concurrent data structure algorithms has been developed <ref> [29, 28] </ref>. The performance of locking protocols also has been well studied. Tay, Suri, and Goodman [57], and Ryu and Thomasian [52] have developed analytical models of the performance of Two-phase Locking variants in database systems. <p> Considerable work has been done to analyze the performance of concurrent data structure algorithms <ref> [29, 28] </ref>. These techniques assume that the algorithm is lock-based, and concentrate on analyzing waiting times in the lock queues. Since there is no queuing in lock-free algorithms, these techniques do not apply. <p> A class c transaction is assumed to have an execution time of fi (V )b c (x), where fi (V ) is the increase in execution time due to resource contention. Factoring out fi (V ) is an example of a resource contention decomposition approximation <ref> [57, 51, 28] </ref>, which lets us focus on the concurrency control mechanism, and which allows the analysis to be applied to different computer models. We will assume that fi (V ) = 1 in the analysis (i.e., one processor per operation).
Reference: [29] <author> T. Johnson and D. Shasha. </author> <title> The performance of concurrent data structure algorithms. </title> <journal> Transactions on Database Systems, </journal> <month> March </month> <year> 1993. </year>
Reference-contexts: The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47]. A general analytical model for modeling the performance of lock-based concurrent data structure algorithms has been developed <ref> [29, 28] </ref>. The performance of locking protocols also has been well studied. Tay, Suri, and Goodman [57], and Ryu and Thomasian [52] have developed analytical models of the performance of Two-phase Locking variants in database systems. <p> Considerable work has been done to analyze the performance of concurrent data structure algorithms <ref> [29, 28] </ref>. These techniques assume that the algorithm is lock-based, and concentrate on analyzing waiting times in the lock queues. Since there is no queuing in lock-free algorithms, these techniques do not apply.
Reference: [30] <author> D. Jones. </author> <title> Concurrent operations on priority queues. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 132-137, </pages> <year> 1989. </year>
Reference-contexts: Locking protocols for concurrent database access are well-known [10]. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees [33, 37], AVL trees [15], B-trees [8, 53], priority queues <ref> [12, 46, 30] </ref> and so on. Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47].
Reference: [31] <author> K. Kant. </author> <title> Introduction to Computer System Performance Evaluation. </title> <publisher> McGraw Hill, </publisher> <year> 1992. </year>
Reference-contexts: We can use the results 22 from the closed-system model to approximate the performance measures of an open system. The throughput values for the closed system are used for the state-dependent service rates in a flow-equivalent server <ref> [31] </ref>. The steps to compute open system response times in the FF and the VF transaction models are: 1. For V = 1; : : : ; M AX, calculate the per-class and average response times. 2. Model the number of jobs in the system as a finite-buffer queue.
Reference: [32] <author> L. Kleinrock. </author> <title> Queueing Systems, volume 1. </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: residence time of te fl c t , and class c transactions have a running time of R c (V ) = 0 te fl c t b c (t)dt c (fl c ) where B 1 c is the first derivative of the Laplace transform of b c (t) <ref> [32] </ref>. <p> Here we can see again that the VV model makes accurate predictions, while the VF model is too optimistic. We include in Figure 3 a plot of the response time of an equivalent locking algorithm (modeled by a M/G/1 queue <ref> [32] </ref>). The locking algorithm has a considerably better response time than the non-blocking algorithm under the permanent slowdown model. The non-blocking algorithm under the transient slowdown model has a similar response time under a light load, but a lower response time under a heavy load.
Reference: [33] <author> H.T. Kung and P.L. Lehman. </author> <title> Concurrent manipulation of binary search trees. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 5(3) </volume> <pages> 354-382, </pages> <year> 1980. </year>
Reference-contexts: Shared locks are compatible with each other, but an exclusive lock is compatible with no other lock. Locking protocols for concurrent database access are well-known [10]. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees <ref> [33, 37] </ref>, AVL trees [15], B-trees [8, 53], priority queues [12, 46, 30] and so on. Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms.
Reference: [34] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism <ref> [24, 17, 34] </ref>, most of the recently proposed methods [45, 58, 19, 55, 59, 60, 56, 23] are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object).
Reference: [35] <author> L. Lamport. </author> <title> A fast mutual exclusion algorithm. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 1-11, </pages> <year> 1987. </year>
Reference-contexts: Lock-free algorithms have a different nature, because a process attempting to perform an operation must complete its operation before another process performs a conflicting operation. Hence, the synchronization is competitive but non-atomic. Only two synchronization algorithms have a similar form. In Lamport's "Fast Mutual Exclusion" algorithm <ref> [35] </ref>, processes compete to obtain a lock using only read and write operations. However, the algorithm is not used in practice and its performance has not been studied by analytical or simulation models.
Reference: [36] <author> B.H. Lim and A. Agrawal. </author> <title> Waiting algorithms for synchronization in large-scale multiprocessors. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 11(3) </volume> <pages> 253-294, </pages> <year> 1993. </year>
Reference-contexts: Woest and Goodman [61] present simulation results to compare queue-on-lock-bit synchronization techniques against test-and-set spin locks, and the Mellor-Crummey and Scott lock. Graunke and Thakkar [18] present performance measurements of test-and-set and ticket based locks. Other authors have examined particular aspects of synchronization performance. Lim and Agrawal <ref> [36] </ref> examine the performance tradeoffs between spinning and blocking. They present analytical models to derive the best point for a blocked process to switch from spinning to blocking.
Reference: [37] <author> U. Manber and R.E. Ladner. </author> <title> Concurrency control in a dynamic search structure. </title> <booktitle> In Principles of the ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 268-282, </pages> <year> 1982. </year>
Reference-contexts: Shared locks are compatible with each other, but an exclusive lock is compatible with no other lock. Locking protocols for concurrent database access are well-known [10]. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees <ref> [33, 37] </ref>, AVL trees [15], B-trees [8, 53], priority queues [12, 46, 30] and so on. Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms.
Reference: [38] <author> C. McCann, R. Vaswami, and J. Zahoran. </author> <title> A dynamic processor allocation policy for multiprogrammed shared-memory multiprocessors. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 11(2) </volume> <pages> 146-176, </pages> <year> 1993. </year>
Reference-contexts: Many researchers have worked on avoiding the problems caused by long slowdowns. One approach is to delay the context switch of a process while the process holds a lock <ref> [5, 38, 64] </ref>. These authors report a large improvement in efficiency in multitasking parallel processors by avoiding large slowdowns. However, this approach has several drawbacks.
Reference: [39] <author> J.M. Mellor-Crummey and M.L. Scott. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 9(1) </volume> <pages> 21-65, </pages> <year> 1991. </year>
Reference-contexts: The models that we develop in this work will explore this phenomenon. 4 Previous Work Considerable work has been done to analyze the performance of synchronization methods. Many analyses of synchronization methods have examined the relative performance of shared memory locks. Mellor-Crummey and Scott <ref> [39] </ref> present performance measurements to show the good performance of their algorithm relative to that of some test-and-set and ticket-based algorithms. Agrawal and Cherian [1] present simulation results and a simple analytical model to explore the performance of adaptive backoff synchronization schemes.
Reference: [40] <author> D. Menasce and T. Nakanishi. </author> <title> Optimistic vs. pessimistic concurrency control mechanisms in database management systems. </title> <journal> Information Systems, </journal> <volume> 7(1) </volume> <pages> 13-27, </pages> <year> 1982. </year>
Reference-contexts: A transaction accesses data without regard to possible conflicts. If a data conflict does occur, the transaction is aborted and restarted. Given the relationship between OCC and non-locking algorithms, we can try to apply performance models developed to analyze OCC to analyze non-locking algorithms. Menasce and Nakanishi <ref> [40] </ref> present a Markov chain model of OCC in which aborted transactions leave, then reenter the transaction processing system as new transactions. Morris and Wong [41, 42] note that generating new transactions to replace aborted ones biases the transaction processing system towards executing short fast transactions. <p> Yu et al. [63, 62] develop approximate models of OCC and locking 8 concurrency control to evaluate their performance in transaction processing systems. Of these models, the approach of Ryu and Thomasian is the best suited for application to analyzing non-locking algorithms. Previous models of a similar nature <ref> [40, 41, 42] </ref> are not as general. Other analyses [63, 62] focus on issues such as buffering and resource contention, and assume that data conflicts are rare. In contrast, the Ryu and Thomasian abstracts away the operating environment and focuses on analyzing the effects of data conflicts only.
Reference: [41] <author> R. Morris and W. Wong. </author> <title> Performance of concurrency control algorithms with non-exclusive access. </title> <booktitle> In Performance '84, </booktitle> <pages> pages 87-101, </pages> <year> 1984. </year>
Reference-contexts: Menasce and Nakanishi [40] present a Markov chain model of OCC in which aborted transactions leave, then reenter the transaction processing system as new transactions. Morris and Wong <ref> [41, 42] </ref> note that generating new transactions to replace aborted ones biases the transaction processing system towards executing short fast transactions. These authors provide an alternative solution method that avoids the bias by requiring that the transaction that replaces the aborted transaction be identical to the aborted transaction. <p> Yu et al. [63, 62] develop approximate models of OCC and locking 8 concurrency control to evaluate their performance in transaction processing systems. Of these models, the approach of Ryu and Thomasian is the best suited for application to analyzing non-locking algorithms. Previous models of a similar nature <ref> [40, 41, 42] </ref> are not as general. Other analyses [63, 62] focus on issues such as buffering and resource contention, and assume that data conflicts are rare. In contrast, the Ryu and Thomasian abstracts away the operating environment and focuses on analyzing the effects of data conflicts only.
Reference: [42] <author> R. Morris and W. Wong. </author> <title> Performance analysis of locking and optimistic concurrency control algorithms. Performance Evaluation, </title> <booktitle> 5 </booktitle> <pages> 105-118, </pages> <year> 1985. </year>
Reference-contexts: Menasce and Nakanishi [40] present a Markov chain model of OCC in which aborted transactions leave, then reenter the transaction processing system as new transactions. Morris and Wong <ref> [41, 42] </ref> note that generating new transactions to replace aborted ones biases the transaction processing system towards executing short fast transactions. These authors provide an alternative solution method that avoids the bias by requiring that the transaction that replaces the aborted transaction be identical to the aborted transaction. <p> Yu et al. [63, 62] develop approximate models of OCC and locking 8 concurrency control to evaluate their performance in transaction processing systems. Of these models, the approach of Ryu and Thomasian is the best suited for application to analyzing non-locking algorithms. Previous models of a similar nature <ref> [40, 41, 42] </ref> are not as general. Other analyses [63, 62] focus on issues such as buffering and resource contention, and assume that data conflicts are rare. In contrast, the Ryu and Thomasian abstracts away the operating environment and focuses on analyzing the effects of data conflicts only.
Reference: [43] <author> Motorola. </author> <title> M68000 family programmer's reference manual. </title> <type> 29 </type>
Reference-contexts: A typical non-blocking algorithm reads the state of the object, computes its modifications, then attempts to commit its modification. If no conflicting operation has modified the object, the commit is successful, and the operation is finished. Otherwise, the operation tries again. The operation typically uses the compare-and-swap <ref> [65, 9, 43] </ref> atomic read-modify-write instruction to try to commit its modifications (one work uses the load-locked/store-conditional instruction [22], and several special architecture that support lock-free algorithms have been developed [23, 56]). While many additional non-blocking and lock-free algorithms have been proposed, most have this essential form.
Reference: [44] <author> S. Prakash, Y.H. Lee, and T. Johnson. </author> <title> A non-blocking algorithm for shared queues using compare-and--swap. </title> <booktitle> In Proc. Int'l Conf. on Parallel Processing, </booktitle> <pages> pages II68-II75, </pages> <year> 1991. </year>
Reference-contexts: Stone [55] proposes a queue that permits concurrent enqueues and dequeues. An enqueuer that puts a record into an empty queue can block dequeuers, so we categorize the algorithm as lock-free instead of non-blocking. Stone's algorithm has the performance characteristics of a non-blocking algorithm. Prakash, Lee, and Johnson <ref> [44, 45] </ref> give an algorithm for a non-blocking queue that permits concurrent enqueues and dequeues. Their solution is based on classifying every possible queue configuration into one of a finite number of states.
Reference: [45] <author> S. Prakash, Y.H. Lee, and T. Johnson. </author> <title> A non-blocking algorithm for shared queues using compare-and-swap. </title> <journal> IEEE Trans. on Computers, </journal> <volume> 43(5), </volume> <year> 1994. </year>
Reference-contexts: Process "slowdowns" can occur due to cache line faults, memory and bus contention, page faults, context switching, NUMA architectures, heterogeneous architectures, or differences in operation execution time. While some work has been done to measure the performance of lock-free algorithms <ref> [22, 23, 45] </ref>, the performance of lock-free algorithms relative to that of blocking algorithms has received little study [45]. In this work, we develop a performance model of lock-free algorithms. Our model studies the effects of both transient and permanent slowdowns in the speed of operation execution. <p> While some work has been done to measure the performance of lock-free algorithms [22, 23, 45], the performance of lock-free algorithms relative to that of blocking algorithms has received little study <ref> [45] </ref>. In this work, we develop a performance model of lock-free algorithms. Our model studies the effects of both transient and permanent slowdowns in the speed of operation execution. <p> Stone [55] proposes a queue that permits concurrent enqueues and dequeues. An enqueuer that puts a record into an empty queue can block dequeuers, so we categorize the algorithm as lock-free instead of non-blocking. Stone's algorithm has the performance characteristics of a non-blocking algorithm. Prakash, Lee, and Johnson <ref> [44, 45] </ref> give an algorithm for a non-blocking queue that permits concurrent enqueues and dequeues. Their solution is based on classifying every possible queue configuration into one of a finite number of states. <p> Different operations on a shared object might require different times to compute. For example, Herlihy [22] observed that enqueues into a priority queue experienced discrimination because they take longer to compute. In an earlier work <ref> [45] </ref>, we ran several simulation studies to compare the performance of our non-blocking queue to that of a lock-based implementation under different conditions. We expected that the non-blocking queue would perform better than the equivalent lock-based queue if the execution times of the operations varied considerably. <p> Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism [24, 17, 34], most of the recently proposed methods <ref> [45, 58, 19, 55, 59, 60, 56, 23] </ref> are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object). <p> This approach is used by Herlihy [21], is a step in Turek's algorithms [58] and is an approximation to the algorithms proposed by Prakash et al. <ref> [45] </ref>, Valois [59, 60], and Harathi and Johnson [19]. We want to model both transient and permanent slowdowns. The V/F model accounts for transient and permanent slowdowns, and the V/V model permits transient slowdowns only. <p> These running times are shown in Figure 2. The throughput of the transient slowdown model increases with increasing V , and is considerably greater than that of the locking queue. These model predictions are in agreement with our simulation results <ref> [45] </ref>. The Ryu and Thomasian models assume a closed system and calculate the throughput and response time as a function of the the number of competing operations. Access to a shared data structure can be better modeled as an open system, in which operations arrive, receive service, then depart. <p> figures also show that the VF model is too optimistic, and that the VF approx model makes poor predictions of the response times but good predictions of the system utilization. 8.2 Composite Snapshot Several non-blocking algorithms take a snapshot of several variables to determine the state of the data structure <ref> [45, 59, 60, 19, 22] </ref>. While taking an atomic composite snapshot requires a more complex algorithm, it reduces the amount of copying needed to perform an operation, which improves performance. In addition, architectures that support lock-free algorithms have been proposed [23, 56]. <p> In addition, architectures that support lock-free algorithms have been proposed [23, 56]. These architectures allow a process to reserve several words of shared memory, and inform the processor if a conflicting write occurs. Code 5, taken from <ref> [45] </ref>, shows a typical protocol to take an atomic snapshot for an algorithm that implements a non-blocking queue. The nonblocking queue needs to determine the simultaneous values of the three variables in order to determine the state of the queue.
Reference: [46] <author> V. Rao and V. Kumar. </author> <title> Concurrent access of priority queues. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(12) </volume> <pages> 1657-1665, </pages> <year> 1988. </year>
Reference-contexts: Locking protocols for concurrent database access are well-known [10]. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees [33, 37], AVL trees [15], B-trees [8, 53], priority queues <ref> [12, 46, 30] </ref> and so on. Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47].
Reference: [47] <author> M.I. Reiman and P.E. Wright. </author> <title> Performance analysis of concurrent-read exclusive-write. </title> <booktitle> In Proc. ACM Sigmetrics Conference on Measuring and Modeling of COmputer SYstems, </booktitle> <pages> pages 168-177, </pages> <year> 1991. </year>
Reference-contexts: Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established <ref> [27, 28, 47] </ref>. A general analytical model for modeling the performance of lock-based concurrent data structure algorithms has been developed [29, 28]. The performance of locking protocols also has been well studied.
Reference: [48] <author> J.T. Robinson. </author> <title> Experiments with transaction processing on a multiprocessor. </title> <type> Technical Report RC9725, </type> <institution> IBM, Yorktown Heights, </institution> <year> 1982. </year>
Reference-contexts: We also distinguish between silent and broadcast concurrency control. The pseudo-code in Code 4 is silent optimistic concurrency control: an operation doesn't advertise its commit, and transactions that will abort continue to execute. Alternatively, a transaction can broadcast its commit, so that conflicting transactions can restart immediately <ref> [48, 20] </ref>. We model the transaction processing system as a closed system in which V transactions each execute one of C transaction types. When a new transaction enters the system, it is a class c transaction with probability f c , P C f c = 1.
Reference: [49] <author> S.M. Ross. </author> <title> Stochastic Processes. </title> <publisher> John Wiley, </publisher> <year> 1983. </year>
Reference-contexts: Thus, the observation period would take P C i=1 M f i b i seconds, during which a class k transaction would be executed for M f k b k seconds. By the theory of alternating renewal processes <ref> [49] </ref>, we have S k = f k b k =b (3) If the process is executing a class k transaction, it will finish at rate 1=b k .
Reference: [50] <author> L. Rudolph and Z. Segall. </author> <title> Dynamic decentralized cache schemes for mimd parallel processors. </title> <booktitle> In Proc. Int'l Symp. on Computer Architecture, </booktitle> <pages> pages 340-347, </pages> <year> 1984. </year>
Reference-contexts: In Lamport's "Fast Mutual Exclusion" algorithm [35], processes compete to obtain a lock using only read and write operations. However, the algorithm is not used in practice and its performance has not been studied by analytical or simulation models. The test-and-test-and-set lock <ref> [50] </ref> is similar to lock-free algorithms in that blocked processors receive a signal that the lock is free (a cache line invalidation), then compete for the lock. The effect of slowdowns on the test-and-test-and-set lock has never been analyzed, though the methods described in this paper can be applied.
Reference: [51] <author> I.K. Ryu and A. Thomasian. </author> <title> Performance analysis of centralized database with optimistic concurrency control. Performance Evaluation, </title> <booktitle> 7 </booktitle> <pages> 195-211, </pages> <year> 1987. </year>
Reference-contexts: These authors provide an alternative solution method that avoids the bias by requiring that the transaction that replaces the aborted transaction be identical to the aborted transaction. Ryu and Thomasian <ref> [51] </ref> extend this model of OCC to permit a wide variety of execution time distributions and a variety of OCC execution models. Yu et al. [63, 62] develop approximate models of OCC and locking 8 concurrency control to evaluate their performance in transaction processing systems. <p> Furthermore, the Ryu and Thomasian model produces accurate results when the rate of data conflict is high. Our approach is to extend the simple but flexible model of Ryu and Thomasian <ref> [51] </ref> to analyze lock-free algorithms. The Ryu-Thomasian model requires that if a transaction is aborted, its execution time is identical to the first execution. <p> A class c transaction is assumed to have an execution time of fi (V )b c (x), where fi (V ) is the increase in execution time due to resource contention. Factoring out fi (V ) is an example of a resource contention decomposition approximation <ref> [57, 51, 28] </ref>, which lets us focus on the concurrency control mechanism, and which allows the analysis to be applied to different computer models. We will assume that fi (V ) = 1 in the analysis (i.e., one processor per operation). <p> We denote by (k; c) the probability that a committing class k transaction conflicts with an executing class c transaction. We model the stochastic process in which committing transactions conflict with an executing transaction as a Poisson process. Ryu and Thomasian <ref> [51] </ref> show that this assumption, which makes the analysis tractable, leads to accurate model predictions under a wide variety of conditions. 10 We differentiate between three models depending on the actions that occur when a transaction aborts. In [51], a transaction samples its execution time when it first enters the system. <p> Ryu and Thomasian <ref> [51] </ref> show that this assumption, which makes the analysis tractable, leads to accurate model predictions under a wide variety of conditions. 10 We differentiate between three models depending on the actions that occur when a transaction aborts. In [51], a transaction samples its execution time when it first enters the system. If the transaction is aborted, it is executed again with the same execution time as the first execution time. We call this transaction model the fixed time/fixed class model, or the FF model 1 . <p> The expected time that a transaction spends executing aborted attempts is denoted by R d c (V ), and the total residence time of a class c transaction is 1 Most of the results that we present for the FF model have been taken from <ref> [51] </ref>. 11 R c (V ) = R c d (V ). The utilization of a class is the proportion of its expected residence time spent in an execution that commits: U c = R c a (V )=(R c d (V )). <p> In the silent/static scheme, transactions access their entire data sets when they start their executions, and detect conflicts when they attempt to commit. 13 6.1.1 Fixed Time/Fixed Class In <ref> [51] </ref>, if a transaction executes for t seconds, then aborts, it will execute for t seconds when it restarts. If an operation requires t seconds, the probability that it will be commit is e flt , since we assume that conflicts form a Poisson process.
Reference: [52] <author> I.K. Ryu and A. Thomasian. </author> <title> Analysis of database performance with dynamic locking. </title> <journal> J. ACM, </journal> <volume> 37(3) </volume> <pages> 491-523, </pages> <year> 1990. </year>
Reference-contexts: A general analytical model for modeling the performance of lock-based concurrent data structure algorithms has been developed [29, 28]. The performance of locking protocols also has been well studied. Tay, Suri, and Goodman [57], and Ryu and Thomasian <ref> [52] </ref> have developed analytical models of the performance of Two-phase Locking variants in database systems. Herlihy has proposed general methods for implementing non-blocking concurrent objects (i.e., concurrent data structures) [21].
Reference: [53] <author> Y. Sagiv. </author> <title> Concurrent operations on B fl -trees with overtaking. </title> <booktitle> In 4th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 28-37. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: Locking protocols for concurrent database access are well-known [10]. In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees [33, 37], AVL trees [15], B-trees <ref> [8, 53] </ref>, priority queues [12, 46, 30] and so on. Shasha and Goodman [54] have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47].
Reference: [54] <author> D. Shasha and N. Goodman. </author> <title> Concurrent search structure algorithms. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 53-90, </pages> <year> 1988. </year>
Reference-contexts: In addition, locking protocols for concurrent access to a wide variety of specialized data structures have been proposed. Examples include binary search trees [33, 37], AVL trees [15], B-trees [8, 53], priority queues [12, 46, 30] and so on. Shasha and Goodman <ref> [54] </ref> have developed a framework for proving the correctness of lock-based concurrent search 1 structure algorithms. The analytical tools needed to study the performance of lock-based data structure algorithms have been established [27, 28, 47].
Reference: [55] <author> J. Stone. </author> <title> A simple and correct shared-queue algorithm using compare-and-swap. </title> <type> Technical Report RC 15675, </type> <institution> IBM TJ Watson Research Center, </institution> <year> 1990. </year>
Reference-contexts: Often, only the modified portions of the object must be copied and replaced. The large-object protocol has the same essential form as the small-object protocol. Herlihy's algorithms serialized access to the shared object. Other researchers propose algorithms that permit concurrent access to a non-blocking object. Stone <ref> [55] </ref> proposes a queue that permits concurrent enqueues and dequeues. An enqueuer that puts a record into an empty queue can block dequeuers, so we categorize the algorithm as lock-free instead of non-blocking. Stone's algorithm has the performance characteristics of a non-blocking algorithm. <p> Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism [24, 17, 34], most of the recently proposed methods <ref> [45, 58, 19, 55, 59, 60, 56, 23] </ref> are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object).
Reference: [56] <author> J.M. Stone, H.S. Stone, P. Heidelberger, and J. Turek. </author> <title> Multiple reservations and the oklahoma update. </title> <journal> IEEE Parallel and Distributed Technology, Systems and Applications, </journal> <volume> 1(4) </volume> <pages> 58-71, </pages> <year> 1993. </year>
Reference-contexts: Otherwise, the operation tries again. The operation typically uses the compare-and-swap [65, 9, 43] atomic read-modify-write instruction to try to commit its modifications (one work uses the load-locked/store-conditional instruction [22], and several special architecture that support lock-free algorithms have been developed <ref> [23, 56] </ref>). While many additional non-blocking and lock-free algorithms have been proposed, most have this essential form. Herlihy has also proposed methods for wait-free concurrent objects, in which every operation is guaranteed of completion within a bounded number of steps. <p> Herlihy has also proposed methods for wait-free concurrent objects, in which every operation is guaranteed of completion within a bounded number of steps. We do not address the performance of wait-free objects in this paper. Considerable research on lock-free concurrent algorithms has been done lately <ref> [25, 22, 58, 2, 23, 56] </ref>. The researchers who work on lock-free algorithms claim that lock-free algorithms can improve the performance of concurrent systems because fast operations execute at the expense of slow operations. <p> Some researchers have investigated hybrid techniques that are primarily locking, but can force processes to release their locks when the process experiences a context switch [2, 11]. These methods use non-locking algorithms to ensure correctness. Several architectures that support lock-free algorithms have been proposed <ref> [56, 23] </ref>. <p> Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism [24, 17, 34], most of the recently proposed methods <ref> [45, 58, 19, 55, 59, 60, 56, 23] </ref> are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object). <p> While taking an atomic composite snapshot requires a more complex algorithm, it reduces the amount of copying needed to perform an operation, which improves performance. In addition, architectures that support lock-free algorithms have been proposed <ref> [23, 56] </ref>. These architectures allow a process to reserve several words of shared memory, and inform the processor if a conflicting write occurs. Code 5, taken from [45], shows a typical protocol to take an atomic snapshot for an algorithm that implements a non-blocking queue.
Reference: [57] <author> Y.C. Tay, R. Suri, and N. Goodman. </author> <title> Locking performance in centralized databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(4) </volume> <pages> 415-462, </pages> <year> 1985. </year> <month> 30 </month>
Reference-contexts: A general analytical model for modeling the performance of lock-based concurrent data structure algorithms has been developed [29, 28]. The performance of locking protocols also has been well studied. Tay, Suri, and Goodman <ref> [57] </ref>, and Ryu and Thomasian [52] have developed analytical models of the performance of Two-phase Locking variants in database systems. Herlihy has proposed general methods for implementing non-blocking concurrent objects (i.e., concurrent data structures) [21]. <p> A class c transaction is assumed to have an execution time of fi (V )b c (x), where fi (V ) is the increase in execution time due to resource contention. Factoring out fi (V ) is an example of a resource contention decomposition approximation <ref> [57, 51, 28] </ref>, which lets us focus on the concurrency control mechanism, and which allows the analysis to be applied to different computer models. We will assume that fi (V ) = 1 in the analysis (i.e., one processor per operation).
Reference: [58] <author> J. Turek, D. Shasha, and S. Prakash. </author> <title> Locking without blocking: Making lock based concurrent data structure algorithms nonblocking. </title> <booktitle> In ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 212-222, </pages> <year> 1992. </year>
Reference-contexts: Herlihy has also proposed methods for wait-free concurrent objects, in which every operation is guaranteed of completion within a bounded number of steps. We do not address the performance of wait-free objects in this paper. Considerable research on lock-free concurrent algorithms has been done lately <ref> [25, 22, 58, 2, 23, 56] </ref>. The researchers who work on lock-free algorithms claim that lock-free algorithms can improve the performance of concurrent systems because fast operations execute at the expense of slow operations. <p> Valois [59] has developed similar non-blocking algorithms for queues, linked lists, and binary search trees. Herlihy and Moss [25] present non-blocking algorithms for garbage collection. Anderson and Woll [3] present wait-free algorithms for the union-find problem. Turek, Shasha, and Prakash <ref> [58] </ref> have techniques for transforming concurrent objects implemented with locks into concurrent non-blocking objects. Every operation keeps its `program' in a publicly available location. Instead of setting a lock on a record, a process attempts to make the `lock' field of the record point to its own program. <p> Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism [24, 17, 34], most of the recently proposed methods <ref> [45, 58, 19, 55, 59, 60, 56, 23] </ref> are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object). <p> This approach is used by Herlihy [21], is a step in Turek's algorithms <ref> [58] </ref> and is an approximation to the algorithms proposed by Prakash et al. [45], Valois [59, 60], and Harathi and Johnson [19]. We want to model both transient and permanent slowdowns. The V/F model accounts for transient and permanent slowdowns, and the V/V model permits transient slowdowns only.
Reference: [59] <author> J.D. Valois. </author> <title> Analysis of a lock-free queue. </title> <note> Submitted for publication, </note> <year> 1992. </year>
Reference-contexts: Valois <ref> [59] </ref> has developed similar non-blocking algorithms for queues, linked lists, and binary search trees. Herlihy and Moss [25] present non-blocking algorithms for garbage collection. Anderson and Woll [3] present wait-free algorithms for the union-find problem. <p> Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism [24, 17, 34], most of the recently proposed methods <ref> [45, 58, 19, 55, 59, 60, 56, 23] </ref> are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object). <p> This approach is used by Herlihy [21], is a step in Turek's algorithms [58] and is an approximation to the algorithms proposed by Prakash et al. [45], Valois <ref> [59, 60] </ref>, and Harathi and Johnson [19]. We want to model both transient and permanent slowdowns. The V/F model accounts for transient and permanent slowdowns, and the V/V model permits transient slowdowns only. We are modeling algorithms in which the snapshot is performed atomically, so the operations execute SS transactions. <p> figures also show that the VF model is too optimistic, and that the VF approx model makes poor predictions of the response times but good predictions of the system utilization. 8.2 Composite Snapshot Several non-blocking algorithms take a snapshot of several variables to determine the state of the data structure <ref> [45, 59, 60, 19, 22] </ref>. While taking an atomic composite snapshot requires a more complex algorithm, it reduces the amount of copying needed to perform an operation, which improves performance. In addition, architectures that support lock-free algorithms have been proposed [23, 56].
Reference: [60] <author> J.D. Valois. </author> <title> Concurrent dictionaries without locks. </title> <note> Submitted for publication, </note> <year> 1992. </year>
Reference-contexts: Our analytical framework can be used to model non-blocking data structure algorithms that have the basic form described in section 2 in Codes 2 and 3. While some non-blocking algorithms use a different mechanism [24, 17, 34], most of the recently proposed methods <ref> [45, 58, 19, 55, 59, 60, 56, 23] </ref> are similar to these techniques. 8.1 Atomic Snapshot We examine first the algorithms similar to Code 2 in which taking the snapshot consists performing one read (i.e., reading the pointer to the object). <p> This approach is used by Herlihy [21], is a step in Turek's algorithms [58] and is an approximation to the algorithms proposed by Prakash et al. [45], Valois <ref> [59, 60] </ref>, and Harathi and Johnson [19]. We want to model both transient and permanent slowdowns. The V/F model accounts for transient and permanent slowdowns, and the V/V model permits transient slowdowns only. We are modeling algorithms in which the snapshot is performed atomically, so the operations execute SS transactions. <p> figures also show that the VF model is too optimistic, and that the VF approx model makes poor predictions of the response times but good predictions of the system utilization. 8.2 Composite Snapshot Several non-blocking algorithms take a snapshot of several variables to determine the state of the data structure <ref> [45, 59, 60, 19, 22] </ref>. While taking an atomic composite snapshot requires a more complex algorithm, it reduces the amount of copying needed to perform an operation, which improves performance. In addition, architectures that support lock-free algorithms have been proposed [23, 56].
Reference: [61] <author> P. J. Woest and J. R. Goodman. </author> <title> An analysis of synchronization mechanisms in shared-memory multiprocessors. </title> <booktitle> In International Symposium on Shared Memory Multiprocessing, </booktitle> <pages> pages 656-659, </pages> <address> Tokyo, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Agrawal and Cherian [1] present simulation results and a simple analytical model to explore the performance of adaptive backoff synchronization schemes. Anderson [4] presents measurement results of the performance of several spin locks, and suggests a new ticket-based spin lock. Woest and Goodman <ref> [61] </ref> present simulation results to compare queue-on-lock-bit synchronization techniques against test-and-set spin locks, and the Mellor-Crummey and Scott lock. Graunke and Thakkar [18] present performance measurements of test-and-set and ticket based locks. Other authors have examined particular aspects of synchronization performance.
Reference: [62] <author> P.S. Yu, D.M. Dias, and S.S. Lavenberg. </author> <title> On modeling database concurrency control. </title> <type> Technical Report RC 15368, </type> <institution> IBM Research Division, </institution> <year> 1990. </year>
Reference-contexts: Ryu and Thomasian [51] extend this model of OCC to permit a wide variety of execution time distributions and a variety of OCC execution models. Yu et al. <ref> [63, 62] </ref> develop approximate models of OCC and locking 8 concurrency control to evaluate their performance in transaction processing systems. Of these models, the approach of Ryu and Thomasian is the best suited for application to analyzing non-locking algorithms. <p> Of these models, the approach of Ryu and Thomasian is the best suited for application to analyzing non-locking algorithms. Previous models of a similar nature [40, 41, 42] are not as general. Other analyses <ref> [63, 62] </ref> focus on issues such as buffering and resource contention, and assume that data conflicts are rare. In contrast, the Ryu and Thomasian abstracts away the operating environment and focuses on analyzing the effects of data conflicts only.
Reference: [63] <author> P.S. Yu, H.U Heiss, </author> <title> and D.M Dias. Modeling and analysis of a time-stamp history based certification protocol for concurrency control. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(4) </volume> <pages> 525-537, </pages> <year> 1991. </year>
Reference-contexts: Ryu and Thomasian [51] extend this model of OCC to permit a wide variety of execution time distributions and a variety of OCC execution models. Yu et al. <ref> [63, 62] </ref> develop approximate models of OCC and locking 8 concurrency control to evaluate their performance in transaction processing systems. Of these models, the approach of Ryu and Thomasian is the best suited for application to analyzing non-locking algorithms. <p> Of these models, the approach of Ryu and Thomasian is the best suited for application to analyzing non-locking algorithms. Previous models of a similar nature [40, 41, 42] are not as general. Other analyses <ref> [63, 62] </ref> focus on issues such as buffering and resource contention, and assume that data conflicts are rare. In contrast, the Ryu and Thomasian abstracts away the operating environment and focuses on analyzing the effects of data conflicts only.
Reference: [64] <author> J. Zahoran, E. D. Lazowska, and D. L. Eager. </author> <title> The effect of scheduling discipline on spin overhead in shared memory parallel systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 2(2) </volume> <pages> 180-198, </pages> <year> 1991. </year>
Reference-contexts: Many researchers have worked on avoiding the problems caused by long slowdowns. One approach is to delay the context switch of a process while the process holds a lock <ref> [5, 38, 64] </ref>. These authors report a large improvement in efficiency in multitasking parallel processors by avoiding large slowdowns. However, this approach has several drawbacks. <p> Glenn, Pryor, Conroy, and Johnson [16] present analytical models which show that a thrashing phenomenon can occur due to contention for a synchronization variable. Anderson, Lazowska, and Levy [6] present some simple queuing models of critical section access to study thread management schemes. Zahoran, Lazowska, and Eager <ref> [64] </ref> present a variety on analytical and simulation models to study the interaction of synchronization and scheduling policies in a multitasking parallel processor. Previous analytic studies of multiprocessor synchronization do not address the effects of slowdowns on the performance of shared objects (the work of Zahoran, Lazowska, and Eager [64] uses <p> Eager <ref> [64] </ref> present a variety on analytical and simulation models to study the interaction of synchronization and scheduling policies in a multitasking parallel processor. Previous analytic studies of multiprocessor synchronization do not address the effects of slowdowns on the performance of shared objects (the work of Zahoran, Lazowska, and Eager [64] uses simulation to study the 7 effect of scheduling policies). Furthermore, most spin lock algorithms are of an essentially different nature than lock-free algorithms.
Reference: [65] <author> C.-Q Zhu and P.-C. Yew. </author> <title> A synchronization scheme and its applications for large multiprocessor systems. </title> <booktitle> In Proceedings of the 4th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 486-493, </pages> <year> 1984. </year> <pages> 32 33 34 35 </pages>
Reference-contexts: A typical non-blocking algorithm reads the state of the object, computes its modifications, then attempts to commit its modification. If no conflicting operation has modified the object, the commit is successful, and the operation is finished. Otherwise, the operation tries again. The operation typically uses the compare-and-swap <ref> [65, 9, 43] </ref> atomic read-modify-write instruction to try to commit its modifications (one work uses the load-locked/store-conditional instruction [22], and several special architecture that support lock-free algorithms have been developed [23, 56]). While many additional non-blocking and lock-free algorithms have been proposed, most have this essential form.
References-found: 65

