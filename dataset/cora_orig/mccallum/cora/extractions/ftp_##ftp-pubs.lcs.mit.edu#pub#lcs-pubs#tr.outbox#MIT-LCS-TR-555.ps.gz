URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-555.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr500.html
Root-URL: 
Title: Compiler-Directed Storage Reclamation Using Object Lifetime Analysis  
Author: James E. Hicks, Jr. 
Date: October 1992  
Pubnum: MIT/LCS/TR-555  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alexander Aiken and Brian R. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Conference Record of the 18th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 279-290, </pages> <address> New York, NY, </address> <month> January </month> <year> 1991. </year> <title> Association for Computing Machinery, </title> <publisher> ACM Press. </publisher>
Reference-contexts: In addition to these graph-based approaches, there have been a number of abstract interpretation- based analysis frameworks that are interesting because they also do not assume a sequential interpreter. The work by Young and O'Keefe [45] and the work by Aiken and Murphy <ref> [1] </ref> fall into this category. Young and O'Keefe developed a type evaluator for a lazy dialect of Scheme. This evaluator computes an approximation to the set of possible values to which each expression in a program could evaluate. 24 CHAPTER 1.
Reference: [2] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 275-279, </pages> <year> 1987. </year>
Reference-contexts: Appel <ref> [2] </ref> makes an argument that 26 CHAPTER 1. INTRODUCTION garbage collection can be faster than explicit storage management; he claims that it can even be faster than stack allocation.
Reference: [3] <author> Zena M. Ariola and Arvind. </author> <title> Compilation of Id-: a subset of Id. Computation Structures Group Memo 315-1, </title> <institution> Massachusetts Institute of Technology Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: The second algorithm inserts safe deallocation commands into programs automatically. This second algorithm allows the programmer to write programs in which storage is implicitly reclaimed. For the remainder of this thesis, we talk about the language KID <ref> [3] </ref>, a specific parallel, non-strict, single-assignment language with higher-order functions. KID, or Kernel Id, is an intermediate language developed by Ariola and Arvind to express the semantics of Id [35, 33, 34] and to express the compilation of Id programs.
Reference: [4] <author> Henry G. Baker. </author> <title> Unify and conquer (garbage, updating, aliasing, </title> : : : ) <booktitle> in functional languages. In 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 218-226, </pages> <address> New York, NY, </address> <month> June </month> <year> 1990. </year> <title> Association for Computing Machinery, </title> <publisher> ACM Press. </publisher>
Reference-contexts: It is unclear from the paper whether there is an efficient or decidable algorithm for deducing types and effects with regions for FX programs. Baker <ref> [4] </ref> describes states that the structure-sharing unification algorithm for Milner-style type inference already produce a certain amount of sharing information for functional languages. Each node that represents the type of an expression in a program corresponds to a set of run-time objects.
Reference: [5] <author> Jeffrey M. Barth. </author> <title> Shifting garbage collection overhead to compile time. </title> <journal> Communications of the ACM, </journal> <volume> 20(7) </volume> <pages> 513-518, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: The benefit from using a garbage collected system is that the user does not have to worry about not deallocating enough storage or about deallocating storage too early. 1.2.1 Lifetime Analysis Lifetime analysis was first suggested by Barth <ref> [5] </ref> as an optimization to shift some of the run-time overhead of garbage collection to compile-time.
Reference: [6] <author> Paul S. Barth. </author> <title> Atomic Data Structures for an Implicitly Parallel Language. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: PERFORMANCE ANALYSIS The procedure make k matrices takes the dimensions b of the matrix and the loop bound k and returns an M-vector <ref> [7, 6] </ref> containing k empty matrices each with dimensions b. Each iteration, the (i mod k)th element of the vector of empty matrices is taken and used as the value of next M. <p> Explicit deallocation commands can be used to deallocate storage. Whatever storage is not deallocated explicitly will eventually be deallocated by the garbage collector. 11.1.6 M-Structures Full-fledged Id and KID both have M-structures <ref> [7, 6] </ref>, which are useful when writing programs that compute histograms, implement graph algorithms, or implement run-time system code. M- structures are mutable structures that allow mutually exclusive access to each word. We would like to see our instrumented and abstract interpreters augmented to handle programs using M-structures.
Reference: [7] <author> Paul S. Barth, Rishiyur S. Nikhil, and Arvind. M-structures: </author> <title> Extending a parallel, non-strict, functional language with state. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 538-568, </pages> <address> Berlin, </address> <month> August </month> <year> 1991. </year> <institution> Association for Computing Machinery, SpringerVerlag. </institution>
Reference-contexts: KID, or Kernel Id, is an intermediate language developed by Ariola and Arvind to express the semantics of Id [35, 33, 34] and to express the compilation of Id programs. In this thesis, we consider KID to be KID without higher-order functions and M-structures <ref> [7] </ref> (structures with per-element mutual exclusion). In Chapter 2 we present the syntax and standard semantics of KID and we discuss the unusual evaluation strategy used by the KID interpreter. <p> PERFORMANCE ANALYSIS The procedure make k matrices takes the dimensions b of the matrix and the loop bound k and returns an M-vector <ref> [7, 6] </ref> containing k empty matrices each with dimensions b. Each iteration, the (i mod k)th element of the vector of empty matrices is taken and used as the value of next M. <p> Explicit deallocation commands can be used to deallocate storage. Whatever storage is not deallocated explicitly will eventually be deallocated by the garbage collector. 11.1.6 M-Structures Full-fledged Id and KID both have M-structures <ref> [7, 6] </ref>, which are useful when writing programs that compute histograms, implement graph algorithms, or implement run-time system code. M- structures are mutable structures that allow mutually exclusive access to each word. We would like to see our instrumented and abstract interpreters augmented to handle programs using M-structures.
Reference: [8] <author> Patrick J. Burns, Mark Christon, Roland Schweitzer, Olaf M. Lubeck, Harvey J. Wasserman, Margaret L. Simmons, and Daniel V. Pryor. </author> <title> Vectorization of Monte Carlo particle transport: An architectural study using the LANL benchmark "Gamteb". </title> <booktitle> In Proceedings Supercomputing '89, </booktitle> <pages> pages 10-20, </pages> <address> New York, NY, </address> <month> November </month> <year> 1989. </year> <journal> IEEE Computer Society and ACM SIGARCH, </journal> <note> ACM Press. </note>
Reference-contexts: This condition is very conservative; it means that the control region containing the producer and all the control regions containing consumers of the structure have terminated before the deallocation statement executes. Figures 1.4 and 1.5 show procedures from the Gamteb <ref> [8] </ref> photon transport simulation benchmark. The procedure compton, shown in Figure 1.4, contains a Dealloc command that satisfies Condi- tion 1.5. <p> Each of the three versions containing deallocation commands reclaims all of the storage allocated during each iteration. The only difference in the amount of storage that they use is in how much of the storage allocated for initial data structures is eventually reclaimed. 10.2.3 Gamteb Gamteb <ref> [8] </ref>, a Monte Carlo simulation of photon transport in a graphite rod, is another scientific program on which this system should have good success. The Id version has a slightly more complex structure than the original Fortran: the Id version uses a recursive procedure to simulate particle transport.
Reference: [9] <author> David C. Cann. </author> <title> Compilation Techniques for High Performance Applicative Computation. </title> <type> PhD thesis, </type> <institution> Colorado State University, </institution> <month> May </month> <year> 1989. </year> <note> (Technical Report CS-89-108). </note>
Reference-contexts: Ranelletti's method is very efficient | it takes O (n) compile- time, where n is the size of the program being analyzed. Unfortunately, extending it to handle interprocedural analysis will make it much less efficient | it will take O (2 n ) compile-time. Cann <ref> [9] </ref> describes an analysis technique on SISAL dataflow graphs that allows arrays or array dope- vectors to be updated in place whenever it can be shown that the updater is the only consumer of the array. This method is also based on parallel programs.
Reference: [10] <author> David R. Chase, Mark Wegmen, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <address> New York, NY, </address> <month> June </month> <year> 1990. </year> <journal> SIGPLAN, Association for Computing Machinery. </journal> <volume> 179 180 BIBLIOGRAPHY </volume>
Reference-contexts: The interference analysis Hendren and Nicolau developed can be recast as a lifetime analysis by determining all the statements from which a given structure is reachable | the control region bounded by those statements bounds the lifetime of the structure. Chase, Wegman and Zadeck <ref> [10] </ref> attempt to improve the method by which information about data structures is summarized. Their method takes programs in static single assignment form [14] and constructs a storage shape graph (SSG) that represents the interconnectedness of structures in the heap.
Reference: [11] <author> Douglas W.. Clark. </author> <title> An empirical study of list structure in Lisp. </title> <journal> Communications of the ACM, </journal> <volume> 20(2) </volume> <pages> 78-86, </pages> <month> February </month> <year> 1977. </year>
Reference-contexts: Although his method only inserts deallocation code if it determines that there is exactly one reference to a structure, he claims that this optimization is powerful enough to reclaim a significant amount of temporary storage in Lisp programs, because studies by Clark <ref> [11] </ref> show that most structures in Lisp programs are referred to exactly once. 1.2.2 Dataflow Analysis Barth's method was limited because the analysis could not follow pointers or procedure calls. There have been several approaches that attempt to solve these problems.
Reference: [12] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the 4th ACM Symposium on the Principles of Programming Languages. Association for Computing Machinery, </booktitle> <year> 1977. </year>
Reference-contexts: Storage shape graphs are augmented with heap reference counting to determine the lifetime of a structure and to determine if a structure is acyclic. 1.2.3 Analyses Based on Abstract Interpretation These techniques all consist of a set of ad hoc rules for analyzing programs. Cousot and Cousot <ref> [12] </ref> developed abstract interpretation, a method for simulating the execution of a program in order to determine the behavior of a program. The use of abstract interpretation allows the derivation of an analysis framework from the operational semantics of a programming language.
Reference: [13] <author> W. P. Crowley, C. P. Hendrickson, and T. E. Rudy. </author> <title> The SIMPLE code. </title> <type> UCID 17715, </type> <institution> Lawrence Livermore Laboratory, </institution> <month> February </month> <year> 1978. </year>
Reference-contexts: We discuss this problem in more detail in Section 10.4. 10.2.2 Simple Simple, a hydrodynamics benchmark program <ref> [13] </ref>, is a scientific program with very simple control structure. If compiler-directed storage reclamation is going to have any success, it should be able to reclaim every intermediate structure allocated in this program.
Reference: [14] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> An efficient method of computing static single assignment form. </title> <booktitle> Conference Record of the 16th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 25-35, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Chase, Wegman and Zadeck [10] attempt to improve the method by which information about data structures is summarized. Their method takes programs in static single assignment form <ref> [14] </ref> and constructs a storage shape graph (SSG) that represents the interconnectedness of structures in the heap. Each node in the graph represents a structure allocated by a different allocation statement.
Reference: [15] <author> Alain Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higherorder functional specifications. </title> <booktitle> In Conference Record of the 17th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 157-168. </pages> <publisher> ACM SIGACT-SIGPLAN, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: They show that their analysis is correct for all implementations of the underlying operational semantics. The framework of Horwitz et al does not do interprocedural analysis. One enhancement to this framework is the ability to handle higher-order functions. Deutsch <ref> [15] </ref> develops a static analysis method for determining the aliasing and lifetimes of objects in a strict, higher-order functional language with first class continuations. His work is also based on that of Jones and Muchnik.
Reference: [16] <author> McGraw et al. </author> <title> SISAL: Streams and iteration in a single-assignment language. </title> <type> Report M146, Rev. 1, </type> <institution> University of California, Lawrence Livermore National Laboratory, Livermore, California, </institution> <month> March </month> <year> 1985. </year>
Reference-contexts: The intermediate code is imperative and contains explicit code to construct and evaluate closures. The parallelism in the source language is simulated by interleaving execution of subexpressions in the intermediate code. Ranelletti [38] describes an analysis method on dataflow graphs representing parallel programs written in SISAL <ref> [16] </ref>. These dataflow graphs only give a partial order on the execution order of expressions in a program. This method allows the compiler to transform graphs so that storage is preallocated for arrays that are incrementally defined by a program.
Reference: [17] <author> David K. Gifford, Pierre Jouvelot, John M. Lucassen, and Mark A. Sheldon. </author> <title> FX-87 Reference Manual. </title> <type> LCS-TR 407, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: Lucassen and Gifford [31] define a type and effects system for the FX language <ref> [17] </ref> that can be used to determine the lifetimes of objects. FX-87, based on the second-order lambda-calculus, has a kind system consisting of type and effect annotations. The effect annotations describe which regions are allocated into, written to, or read from during the execution of an expression.
Reference: [18] <author> David K. Gifford, Pierre Jouvelot, and Mark A. Sheldon. </author> <booktitle> Report on the FX-90 program-ming language. Programming systems research group, </booktitle> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> August </month> <year> 1990. </year> <note> Draft. </note>
Reference-contexts: Use of this approach would also allow the compiler to check the safety of explicit storage management in some cases. In later 1.3. STORAGE MANAGEMENT ASSUMPTIONS 25 work Gifford et al. <ref> [18] </ref> extend the FX compiler to perform type and effect deduction, but in this effect system they dropped the information about storage regions. It is unclear from the paper whether there is an efficient or decidable algorithm for deducing types and effects with regions for FX programs.
Reference: [19] <author> Williams Ludwell Harrison, III. </author> <title> The interprocedural analysis and automatic parallelization of scheme programs. </title> <journal> Lisp and Symbolic Computation, </journal> 2(3/4):179-396, 1989. 
Reference-contexts: He uses complete program states to label objects uniquely in the standard semantics and uses an abstraction of program states to label objects in the abstract semantics. Rather than presenting a low-level operational semantics, Harrison <ref> [19] </ref> presents an analysis in terms of a high-level operational semantics for Scheme. Harrison develops an analysis that could be used to make storage management and parallelization decisions about Scheme programs with 1.2. BACKGROUND 23 first class continuations, side effects and higher-order functions. <p> Activation Labels We will call the dynamic portion of object labels their activation labels. Activation labels are drawn from the domain AL, whose structure will be described below. Our scheme for labeling activations is similar to that of Harrison. In <ref> [19] </ref>, Harrison uses a pair consisting of a variable name and a procedure string to uniquely name variable instances. In his system, every function expression (lambda abstraction) is uniquely named statically, e.g., ff 0 . <p> This information would be useful because the compiler can generate more efficient code to reclaim trees and lists than to reclaim graphs and cyclic structures. Hendren [20] and Harrison <ref> [19] </ref> both can determine whether objects are acyclic using information about the allocation time of the nodes of a recursively typed object. They used this information to determine when statements or subexpressions could be executed in parallel.
Reference: [20] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data struc-tures. </title> <journal> IEEE Transactions on Parallel and Distributed Computing, </journal> <volume> 1(1), </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: They show how to use standard dataflow techniques to compute their alias graphs . They also show that precise computation of alias relations in a single function is NP-complete. Hendren and Nicolau <ref> [20] </ref> take a different approach to solving the finite representation problem. They define an analysis framework that uses path matrices to do interference analysis for par- allelization. These path matrices show the paths of possible interference between two successive program points. <p> This information would be useful because the compiler can generate more efficient code to reclaim trees and lists than to reclaim graphs and cyclic structures. Hendren <ref> [20] </ref> and Harrison [19] both can determine whether objects are acyclic using information about the allocation time of the nodes of a recursively typed object. They used this information to determine when statements or subexpressions could be executed in parallel.
Reference: [21] <author> Harry S. Hochheiser. </author> <title> A Schezoid Compiler for P-RISC. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Nested functions are not allowed in this language. For a treatment of how to transform a set of nested function definitions to a flat set of function definitions, see [25] for a description of lambda lifting . Also, no currying, or partial application, of functions is supported. Hochheiser <ref> [21] </ref> describes the compilation of a language with currying into a KID-like intermediate form with no currying. Higher-order functions and closures will be discussed in Section 9.1. Because KID is a first-order language, identifiers are separated into function identifiers F and value identifiers X. <p> We are not supporting currying directly with these primitives. The compiler can generate a sequence of intermediate functions that use MakeClosure and Apply to implement currying. This is described fully in Hochheiser <ref> [21] </ref>. The primitive MakeClosure is subscripted with the name f i of the function being closed, and takes n values over which f i is being closed.
Reference: [22] <author> Susan Horwitz, Phil Pfeiffer, and Thomas Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <address> New York, NY, June 1989. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Tokens can be more specific, e.g., whole states, in which case the analysis will be more precise but computationally intractable, or more general, e.g., node labels, in which case the analysis will converge faster but give less precise information. Horwitz, Pfeiffer, and Reps <ref> [22] </ref> use the Jones and Muchnik framework to compute an abstraction of memory where each location is labeled by the program points that modify its contents. They show that their analysis is correct for all implementations of the underlying operational semantics.
Reference: [23] <author> Paul Hudak. </author> <title> A semantic model of reference counting and its abstraction. </title> <editor> In Samson Abramsky and Chris Hankin, editors, </editor> <title> Abstract Interpretation of Declarative Languages, </title> <journal> Computers and Their Applications, </journal> <volume> chapter 3, </volume> <pages> pages 45-62. </pages> <publisher> Ellis Horwood Limited, </publisher> <address> Chichester, West Sussex, England, </address> <year> 1987. </year>
Reference-contexts: Even so, most of the work on lifetime analysis of functional languages has been done with respect to a sequential implementation. There have been a few approaches that do not assume a sequential implementation, which we will describe below. Hudak <ref> [23] </ref> describes an analysis based on abstract interpretation of a reference counting interpreter for a strict, functional language operating on arrays of numbers. Even though the language is functional, the denotational semantics he presents is sequential, because it performs side effects in the form of reference counting operations.
Reference: [24] <author> Paul Hudak and Jonathan Young. </author> <title> A collecting interpretation of expressions (without powerdomains). </title> <booktitle> Conference Record of the 15th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 107-118, </pages> <month> January </month> <year> 1988. </year> <note> (Full version accepted to TOPLAS). BIBLIOGRAPHY 181 </note>
Reference-contexts: This process may be equivalent to taking the least upper bound of all possible inputs to a function that arise in the abstract interpretation described above, and analyzing the function when applied to this least upper bound. This process is similar to the behavior of collecting interpreters <ref> [24, 44] </ref>. It seems that it is better to use the most general function value that could ever be passed as input to a procedure during the analysis of that procedure than to construct representative closure values.
Reference: [25] <author> Thomas Johnsson. </author> <title> Lambda lifting: Transforming programs to recursive equations. </title> <booktitle> In Functional Programming Languages and Computer Architecture (Lecture Notes in Computer Science; 201), </booktitle> <pages> pages 199-203. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: SYNTAX OF KID 37 program. Interpretation of a program begins by invoking this function. Nested functions are not allowed in this language. For a treatment of how to transform a set of nested function definitions to a flat set of function definitions, see <ref> [25] </ref> for a description of lambda lifting . Also, no currying, or partial application, of functions is supported. Hochheiser [21] describes the compilation of a language with currying into a KID-like intermediate form with no currying. Higher-order functions and closures will be discussed in Section 9.1.
Reference: [26] <author> Thomas Johnsson. </author> <title> Analysing heap contents in a graph reduction intermediate language. </title> <booktitle> In Proceedings of the 1990 Glasgow Workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Even though the language is functional, the denotational semantics he presents is sequential, because it performs side effects in the form of reference counting operations. Thomas Johnsson <ref> [26] </ref> developed an analysis method for modeling heap contents based on the framework of Jones and Muchnik. His analysis is to be used in optimizing graph reduction intermediate code that resulted from compiling a lazy, functional language.
Reference: [27] <author> Neil D. Jones and Steven S. Muchnik. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structure. </title> <booktitle> In Conference Record of the 9th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <address> New York, NY, </address> <year> 1982. </year> <title> Association for Computing Machinery, </title> <publisher> ACM Press. </publisher>
Reference-contexts: Cousot and Cousot [12] developed abstract interpretation, a method for simulating the execution of a program in order to determine the behavior of a program. The use of abstract interpretation allows the derivation of an analysis framework from the operational semantics of a programming language. Jones and Muchnik <ref> [27] </ref> used abstract interpretation to develop a general framework for interpro- cedural dataflow analysis of programs with recursive data structures. They extend the Cousots' work on dataflow analysis of flowcharts to work with recursive data structures. They use tokens to provide local representations of lists.
Reference: [28] <author> Simon B. Jones and Daniel Le Metayer. </author> <title> Compile-time garbage collection by sharing analysis. </title> <booktitle> In FPCA Conference Proceedings Fourth International Conference, </booktitle> <pages> pages 54-74, </pages> <address> New York, NY, 1989. </address> <publisher> ACM IFIP, ACM Press. </publisher>
Reference-contexts: Their framework computes an approximation of how much of a nested list value passed to a function escapes as part of the result of that function. They did not precisely define the standard semantics that they were abstracting. Jones and Le Metayer <ref> [28] </ref> developed three analyses framed as abstract interpretations of programs: sharing, transmission, and necessity analysis. These analyses are defined for an expression-oriented language with lists as the only data structure.
Reference: [29] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 2134, </pages> <address> New York, NY, </address> <month> July </month> <year> 1988. </year> <institution> SIGPLAN, Association for Computing Machinery. </institution>
Reference-contexts: Recursively typed objects have a potentially infinite number of subvariables; so Ruggieri and Murtagh introduce an operator that summarizes an infinite graph of subvariables by one in which the longest path is bounded by n, where n is a parameter of the analysis. Larus and Hilfinger <ref> [29] </ref> developed an analysis similar to Ruggieri's which computes the possible aliases between structure accesses. They show how to use standard dataflow techniques to compute their alias graphs . They also show that precise computation of alias relations in a single function is NP-complete.
Reference: [30] <author> Arthur Lent. </author> <title> Compile-time analysis of list sharing using abstract interpretation. </title> <type> 6.847 term paper, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: If we proceed to unfold every recursive call once during abstract interpretation, then abstract interpretation will not terminate. Every iteration of the computation of the function environment will yield one more input value to which the recursive function must be applied. Lent <ref> [30] </ref> explored the selective unfolding of recursive procedure calls to determine acyclicity of lists. He proposed a special mechanism for unfolding function calls one extra time using renamed labels and then collapsing the renamed values back into the original domain.
Reference: [31] <author> John M. Lucassen and David K. Gifford. </author> <title> Polymorphic effect systems. </title> <booktitle> In Conference Record of the 15th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 47-57. </pages> <booktitle> SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: Lucassen and Gifford <ref> [31] </ref> define a type and effects system for the FX language [17] that can be used to determine the lifetimes of objects. FX-87, based on the second-order lambda-calculus, has a kind system consisting of type and effect annotations.
Reference: [32] <author> David A. Moon. </author> <title> Garbage collection in a large lisp system. </title> <booktitle> In 1984 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 235-246, </pages> <address> New York, NY, </address> <month> August </month> <year> 1984. </year> <title> Association for Computing Machinery, </title> <publisher> ACM Press. </publisher>
Reference-contexts: For this reason, we will consider some approaches to reusing storage directly or allocating objects in procedure activation frames. Appel does not consider the effect of locality on program execution time. Moon <ref> [32] </ref> states that the most important responsibility of a garbage collector in a system using virtual-memory is to keep data structures local; actually reclaiming storage is a secondary responsibility in this case.
Reference: [33] <author> R. S. Nikhil. </author> <title> Id Nouveau Reference Manual Part I: Syntax. </title> <type> Technical report, </type> <institution> Computation Structures Group, MIT, 545 Technology Square, Cambridge, Massachusetts, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: Introduction Many modern programming languages are oriented towards dynamic storage management. Lisp- like languages and functional languages such as Id <ref> [35, 33, 34] </ref> are heap-oriented languages. In these languages the storage for arrays and other aggregate objects is not necessarily associated with the invocation of the particular procedure that allocated the object. <p> For the remainder of this thesis, we talk about the language KID [3], a specific parallel, non-strict, single-assignment language with higher-order functions. KID, or Kernel Id, is an intermediate language developed by Ariola and Arvind to express the semantics of Id <ref> [35, 33, 34] </ref> and to express the compilation of Id programs. In this thesis, we consider KID to be KID without higher-order functions and M-structures [7] (structures with per-element mutual exclusion).
Reference: [34] <author> R. S. Nikhil, K. Pingali, and Arvind. </author> <title> Id Nouveau. Computation Structures Group Memo 265, </title> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> July </month> <year> 1986. </year>
Reference-contexts: Introduction Many modern programming languages are oriented towards dynamic storage management. Lisp- like languages and functional languages such as Id <ref> [35, 33, 34] </ref> are heap-oriented languages. In these languages the storage for arrays and other aggregate objects is not necessarily associated with the invocation of the particular procedure that allocated the object. <p> For the remainder of this thesis, we talk about the language KID [3], a specific parallel, non-strict, single-assignment language with higher-order functions. KID, or Kernel Id, is an intermediate language developed by Ariola and Arvind to express the semantics of Id <ref> [35, 33, 34] </ref> and to express the compilation of Id programs. In this thesis, we consider KID to be KID without higher-order functions and M-structures [7] (structures with per-element mutual exclusion).
Reference: [35] <author> Rishiyur S. Nikhil. </author> <title> Id 90 reference manual. Computation Structures Group Memo 284-1, </title> <institution> Massachusetts Institute of Technology Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Introduction Many modern programming languages are oriented towards dynamic storage management. Lisp- like languages and functional languages such as Id <ref> [35, 33, 34] </ref> are heap-oriented languages. In these languages the storage for arrays and other aggregate objects is not necessarily associated with the invocation of the particular procedure that allocated the object. <p> For the remainder of this thesis, we talk about the language KID [3], a specific parallel, non-strict, single-assignment language with higher-order functions. KID, or Kernel Id, is an intermediate language developed by Ariola and Arvind to express the semantics of Id <ref> [35, 33, 34] </ref> and to express the compilation of Id programs. In this thesis, we consider KID to be KID without higher-order functions and M-structures [7] (structures with per-element mutual exclusion).
Reference: [36] <author> Gregory M. Papadopoulos. </author> <title> Implementation of a General Purpose Dataflow Multiprocessor. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Chapter 10 Performance Analysis This chapter discusses the performance of an implementation of the analysis and transformations described in this thesis. The first section discusses our implementation of the verification and insertion algorithms, and Monsoon <ref> [36] </ref>, the machine on which we ran our benchmarks. The second section presents the experiments themselves. The third section presents an optimization that generates code to allocate structures in procedure activation frames whenever possible and discusses how this affects the run-time performance of programs. <p> Nevertheless, this module is fairly effective at converting general allocation and deallocation code into frame-based allocation and deallocation code. The restriction that the sizes of frame-allocated objects must be known at compile-time is imposed by the Id Run Time System (Id-RTS) [41] on the Monsoon dataflow machine <ref> [36] </ref> which 10.1. IMPLEMENTATION DETAILS 163 must know the complete size of an activation frame before a procedure is called. We discuss the effectiveness of this optimization in Section 10.3. 10.1.2 Monsoon Monsoon [36] is a dataflow machine with an explicit token store. <p> at compile-time is imposed by the Id Run Time System (Id-RTS) [41] on the Monsoon dataflow machine <ref> [36] </ref> which 10.1. IMPLEMENTATION DETAILS 163 must know the complete size of an activation frame before a procedure is called. We discuss the effectiveness of this optimization in Section 10.3. 10.1.2 Monsoon Monsoon [36] is a dataflow machine with an explicit token store. Instead of using a hashing function to match the token pairs associated with instruction instances, each instruction has an explicit address (relative to an activation or frame pointer) where operand matching occurs.
Reference: [37] <author> Young Gil Park and Benjamin Goldberg. </author> <title> Escape analysis on lists: Optimizing storage alloca-tion and reclamation in higher order functional languages. Extended Abstract, </title> <year> 1990. </year>
Reference-contexts: In the case of recursive functions, heuristics must be used to choose which rewrite rule to apply, because more than one rewrite rule may be applicable to a given instance of a recursive function. Park and Goldberg <ref> [37] </ref> developed an analysis framework based on abstract interpretation of a higher-order functional language. Their framework computes an approximation of how much of a nested list value passed to a function escapes as part of the result of that function.
Reference: [38] <author> John E. Ranelletti. </author> <title> Graph Transformation Algorithms for Array Memory Optimization in Applicative Languages. </title> <type> PhD thesis, </type> <institution> University of California, Davis, Livermore, California, </institution> <month> 94550, November </month> <year> 1987. </year> <type> (Technical Report UCRL-53832). 182 BIBLIOGRAPHY </type>
Reference-contexts: Although the language being compiled is not sequential, the interpreter of the intermediate code is sequential. The intermediate code is imperative and contains explicit code to construct and evaluate closures. The parallelism in the source language is simulated by interleaving execution of subexpressions in the intermediate code. Ranelletti <ref> [38] </ref> describes an analysis method on dataflow graphs representing parallel programs written in SISAL [16]. These dataflow graphs only give a partial order on the execution order of expressions in a program.
Reference: [39] <author> Cristina Ruggieri and Thomas P. Murtagh. </author> <title> Lifetime analysis of dynamically allocated ob-jects. </title> <booktitle> In Conference Record of the 15th ACM Symposium on the Principles of Programming Languages. ACM SIGACT-SIGPLAN, </booktitle> <month> January </month> <year> 1988. </year>
Reference-contexts: There have been several approaches that attempt to solve these problems. Ruggieri and Murtagh <ref> [39] </ref> developed an interprocedural lifetime analysis framework for a statically typed, monomorphic language. Their algorithm computes the set of object sources which may be bound to each variable before each statement in the program is executed.
Reference: [40] <author> Kenneth R. Traub. </author> <title> A compiler for the MIT Tagged-Token Dataflow Architecture. </title> <type> Technical Report TR-370, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: We have found our implementation of these methods to be quite effective in determining the lifetimes of objects in real Id programs. We have implemented this work as part of the Id compiler <ref> [40] </ref> and applied it to several programs of 100 to 1000 lines. The implementation is structured to support separate compilation | a program can be compiled in bottom up fashion and each procedure is verified/transformed individually. <p> The deallocation command verification and insertion tools are implemented as two new modules in the Id Compiler <ref> [40] </ref>. Both modules operate on program graphs, which are basically a dataflow graph representation of KID . The first module computes the function environment for the whole 161 162 CHAPTER 10. PERFORMANCE ANALYSIS program and verifies and annotates each function definition.
Reference: [41] <author> Kenneth R. Traub, Michael J. Beckerle, James E. Hicks, Gregory M. Papadopoulos, Andrew Shaw, and Jonathan Young. </author> <title> Monsoon Software Interface Specifications. </title> <note> Technical Report MCRC-TR-1 and CSG Memo 296, </note> <institution> Motorola Cambridge Research Center and Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Nevertheless, this module is fairly effective at converting general allocation and deallocation code into frame-based allocation and deallocation code. The restriction that the sizes of frame-allocated objects must be known at compile-time is imposed by the Id Run Time System (Id-RTS) <ref> [41] </ref> on the Monsoon dataflow machine [36] which 10.1. IMPLEMENTATION DETAILS 163 must know the complete size of an activation frame before a procedure is called. We discuss the effectiveness of this optimization in Section 10.3. 10.1.2 Monsoon Monsoon [36] is a dataflow machine with an explicit token store.
Reference: [42] <author> Phil Wadler. </author> <title> Strictness analysis on non-flat domains (by abstract interpretation over finite domains). </title> <editor> In Samson Abramsky and Chris Hankin, editors, </editor> <title> Abstract Interpretation of Declarative Languages, </title> <journal> Computers and Their Applications, </journal> <volume> chapter 12, </volume> <pages> pages 266-275. </pages> <publisher> Ellis Horwood Limited, </publisher> <address> Chichester, West Sussex, England, </address> <year> 1987. </year>
Reference-contexts: For instance, Wadler compresses the abstract list domain into the following four elements for strictness analysis <ref> [42] </ref>: &gt;* | any finite list, no member of which is ? j ?* | any finite list, some member of which is ? j 1 | any infinite list or approximation to one, except ? j This list domain ensures that the abstract interpretation terminates in a finite amount of
Reference: [43] <author> C. B. Weinstock and W. A. Wulf. </author> <title> Quick Fit: An Efficient Algorithm for Heap Storage Allocation. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(10) </volume> <pages> 141-148, </pages> <year> 1988. </year>
Reference-contexts: The frame manager uses a single free list to manage unused activation frames, and so it only allocates one size of activation frame. The run-time system is initialized so that this frame size is large enough for all procedures. The heap manager uses the quick-fit algorithm <ref> [43] </ref> to manage deallocated storage. This algorithm incurs one word of overhead for all objects that are allocated. This overhead is insignificant for large objects, but is significant for small objects such as cons cells. Under this management strategy, cons cells take three words apiece.
Reference: [44] <author> Jonathan Young. </author> <title> The Theory and Practice of Semantic Program Analysis for Higher-Order Functional Programming Languages. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: This process may be equivalent to taking the least upper bound of all possible inputs to a function that arise in the abstract interpretation described above, and analyzing the function when applied to this least upper bound. This process is similar to the behavior of collecting interpreters <ref> [24, 44] </ref>. It seems that it is better to use the most general function value that could ever be passed as input to a procedure during the analysis of that procedure than to construct representative closure values.

References-found: 44

