URL: http://www.cs.utexas.edu/users/lin/cs386l/chiba-oopsla95.ps
Refering-URL: http://www.cs.utexas.edu/users/lin/cs386l/
Root-URL: 
Email: chiba@parc.xerox.com chiba@is.s.u-tokyo.ac.jp  
Title: A Metaobject Protocol for C++  
Author: Shigeru Chiba 
Address: Tokyo  
Affiliation: Xerox PARC University of  
Abstract: This paper presents a metaobject protocol (MOP) for C++. This MOP was designed to bring the power of meta-programming to C++ programmers. It avoids penalties on runtime performance by adopting a new meta-architecture in which the metaobjects control the compilation of programs instead of being active during program execution. This allows the MOP to be used to implement libraries of efficient, transparent language extensions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Angus, I. G., </author> <title> "Applications Demand Class Specific Optimizations: The C++ Compiler Can Do More," </title> <journal> Scientific Programming, </journal> <volume> vol. 2, no. 4, </volume> <pages> pp. 123-131, </pages> <year> 1993. </year>
Reference-contexts: Expecting the C++ compiler to automatically detect all such kinds of optimization is not realistic <ref> [1] </ref>. Our MOP enables the programmer to write a library of such customized optimizations. It allows the library implementor to provide the class Matrix with a metaclass for the inlining by using knowledge of implementation details of the class Matrix.
Reference: [2] <author> Buschmann, F., K. Kiefer, F. Paulisch, and M. Stal, </author> <title> "The Meta-Information-Protocol: Run-Time Type Information for C++," </title> <booktitle> in Proc. of the Int'l Workshop on Reflection and Meta-Level Architecture (A. </booktitle> <editor> Yonezawa and B. C. Smith, </editor> <booktitle> eds.), </booktitle> <pages> pp. 82-87, </pages> <year> 1992. </year>
Reference-contexts: of ideas in this field: we took our basic protocol structure from the CLOS MOP [11], we took the basic structure of a compile-time MOP from Anibus and Intrigue [18, 13], and we took some ideas for the basic structure of a MOP for C++ from the meta-information protocol (MIP) <ref> [2] </ref> and our previous work on Open C++ Version 1 [4]. This paper is a status report on the development of OpenC++ Version 2. Our MOP has been pro-totyped in Scheme and a number of examples are running using the prototype. <p> Suppose we want to specialize class metaobjects to implement a mechanism for getting class information such as data member names at runtime. In essence, the idea is to implement a subset of the functionality of the Meta-Information Protocol <ref> [2] </ref>. At runtime, for every class, this mechanism will automatically and transparently make available a record that contains the class information. Any C++ customization implemented as a MOP-based library is usually divided into two parts: compile-time code and runtime code.
Reference: [3] <author> Chiba, S., </author> <title> "Open C++ Programmer's Guide," </title> <type> Technical Report 93-3, </type> <institution> Dept. of Information Science, Univ. of Tokyo, </institution> <address> Tokyo, Japan, </address> <year> 1993. </year>
Reference-contexts: The answer is simple. Class is directly compiled by the C++ compiler because the compilation specialized by Class is equivalent to the compilation done by the C++ compiler. 6 Related Work In previous work, we have proposed another MOP for C++, called OpenC++ Version 1 <ref> [3] </ref>. That MOP had the ability to transparently implement language extensions for distributed computing as libraries on top of ordinary C++. But, because that MOP was based on a meta-architecture in which the metaobjects exist at runtime, it implied runtime overheads.
Reference: [4] <author> Chiba, S. and T. Masuda, </author> <title> "Designing an Ex tensible Distributed Language with a Meta-Level Architecture," </title> <booktitle> in Proc. of the 7th Eu-ropean Conference on Object-Oriented Programming, </booktitle> <volume> LNCS 707, </volume> <pages> pp. 482-501, </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: structure from the CLOS MOP [11], we took the basic structure of a compile-time MOP from Anibus and Intrigue [18, 13], and we took some ideas for the basic structure of a MOP for C++ from the meta-information protocol (MIP) [2] and our previous work on Open C++ Version 1 <ref> [4] </ref>. This paper is a status report on the development of OpenC++ Version 2. Our MOP has been pro-totyped in Scheme and a number of examples are running using the prototype. For simplicity, however, we use C++ notation in this paper.
Reference: [5] <author> Danforth, S. and I. R. Forman, </author> <title> "Reflections on Metaclass Programming in SOM," </title> <booktitle> in Proc. of ACM Conf. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pp. 440-452, </pages> <year> 1994. </year>
Reference-contexts: In the case where a class has more than one base class and the class metaobjects for them give different metaclasses, we simply raise a compilation error. Other researchers have proposed automatic derivation of a mixed-in metaclass in this case <ref> [5] </ref>, but applying that idea to the OpenC++ MOP is not straightforward because combining the same member function of two metaclasses is not always possible. Syntax extension The OpenC++ MOP provides limited ability to extend the language syntax.
Reference: [6] <author> Goldberg, A. and D. Robson, </author> <title> Smalltalk 80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The usefulness of this kind of customizability has been argued elsewhere [11, 9, 10], and interesting MOPs have been included in languages such as Lisp [20], ABCL [21], and, to a lesser degree, Smalltalk <ref> [6] </ref>. The goal of our work is to bring the power of meta-programming to the more mainstream language C++, while respecting their performance concerns in that community. This paper proposes a new MOP for C++, called OpenC++ Version 2.
Reference: [7] <author> Honda, Y. and M. Tokoro, </author> <title> "Soft Real-Time Programming through Reflection," </title> <booktitle> in Proc. of the Int'l Workshop on Reflection and MetaLevel Architecture (A. </booktitle> <editor> Yonezawa and B. C. Smith, </editor> <booktitle> eds.), </booktitle> <pages> pp. 12-23, </pages> <year> 1992. </year>
Reference-contexts: The idea of a meta-interface of the early-stage of compilation was also proposed in MPC++[8]. Like the CLOS MOP and OpenC++ Version 1, a number of systems <ref> [15, 7, 17, 22] </ref> adopt runtime metaobjects, which represent underlying mechanisms such as the language interpreter and the OS kernel, and are responsible for runtime behavior of the system.
Reference: [8] <author> Ishikawa, Y., </author> <title> "Meta-Level Architecture for Extendable C++," </title> <type> Technical Report 94024, </type> <institution> Real World Computing Partnership, </institution> <address> Japan, </address> <year> 1994. </year>
Reference: [9] <author> Kiczales, G., </author> <title> "Towards a New Model of Ab straction in Software Engineering," </title> <booktitle> in Proc. of the Int'l Workshop on Reflection and MetaLevel Architecture (A. </booktitle> <editor> Yonezawa and B. C. Smith, </editor> <booktitle> eds.), </booktitle> <pages> pp. 1-11, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction A metaobject protocol (MOP) is an object-oriented interface for programmers to customize the behavior and implementation of programming languages and other system software. The usefulness of this kind of customizability has been argued elsewhere <ref> [11, 9, 10] </ref>, and interesting MOPs have been included in languages such as Lisp [20], ABCL [21], and, to a lesser degree, Smalltalk [6]. The goal of our work is to bring the power of meta-programming to the more mainstream language C++, while respecting their performance concerns in that community.
Reference: [10] <author> G. Kiczales, ed., </author> <note> Workshop on Open Imple mentation'94, internet publication (http: //www.parc.xerox.com/PARC/spl/eca/oi/ workshop-94), </note> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: 1 Introduction A metaobject protocol (MOP) is an object-oriented interface for programmers to customize the behavior and implementation of programming languages and other system software. The usefulness of this kind of customizability has been argued elsewhere <ref> [11, 9, 10] </ref>, and interesting MOPs have been included in languages such as Lisp [20], ABCL [21], and, to a lesser degree, Smalltalk [6]. The goal of our work is to bring the power of meta-programming to the more mainstream language C++, while respecting their performance concerns in that community.
Reference: [11] <author> Kiczales, G., J. des Rivieres, and D. G. Bo brow, </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction A metaobject protocol (MOP) is an object-oriented interface for programmers to customize the behavior and implementation of programming languages and other system software. The usefulness of this kind of customizability has been argued elsewhere <ref> [11, 9, 10] </ref>, and interesting MOPs have been included in languages such as Lisp [20], ABCL [21], and, to a lesser degree, Smalltalk [6]. The goal of our work is to bring the power of meta-programming to the more mainstream language C++, while respecting their performance concerns in that community. <p> Our MOP has been developed by a synthesis and re-engineering of a number of ideas in this field: we took our basic protocol structure from the CLOS MOP <ref> [11] </ref>, we took the basic structure of a compile-time MOP from Anibus and Intrigue [18, 13], and we took some ideas for the basic structure of a MOP for C++ from the meta-information protocol (MIP) [2] and our previous work on Open C++ Version 1 [4]. <p> These are compile-time MOPs for controlling a Scheme compiler. In those MOPs, the metaobjects are not just language entities, but also represent global information such as the results of flow analysis. Our basic protocol architecture is due to the CLOS MOP <ref> [11] </ref>. The major difference is that the CLOS MOP's metaobjects are runtime ones and thus the CLOS MOP requires relatively large runtime environment if it is directly applied to C++. The idea of a meta-interface of the early-stage of compilation was also proposed in MPC++[8].
Reference: [12] <author> Kiczales, G. J. and L. H. Rodriguez Jr., </author> <title> "Ef ficient Method Dispatch in PCL," </title> <booktitle> in Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 99-105, </pages> <year> 1990. </year>
Reference-contexts: Since the runtime metaobjects allow users to change various decision policies of the system, such as scheduling and migration, the users can tune the system performance to fit their needs. A drawback of the runtime metaobjects is runtime overhead. A few ideas have been proposed on this problem <ref> [12, 16, 19] </ref>. For example, inlining and partial evaluation are effective techniques to reduce the overhead. It is difficult to recover the whole overhead of a runtime meta architecture, however. 7 Current Status We are in the process of developing OpenC++ Version 2.
Reference: [13] <author> Lamping, J., G. Kiczales, L. Rodriguez, and E. Ruf, </author> <title> "An Architecture for an Open Compiler," </title> <booktitle> in Proc. of the Int'l Workshop on Reflection and Meta-Level Architecture (A. </booktitle> <editor> Yonezawa and B. C. Smith, </editor> <booktitle> eds.), </booktitle> <pages> pp. 95-106, </pages> <year> 1992. </year>
Reference-contexts: Our MOP has been developed by a synthesis and re-engineering of a number of ideas in this field: we took our basic protocol structure from the CLOS MOP [11], we took the basic structure of a compile-time MOP from Anibus and Intrigue <ref> [18, 13] </ref>, and we took some ideas for the basic structure of a MOP for C++ from the meta-information protocol (MIP) [2] and our previous work on Open C++ Version 1 [4]. This paper is a status report on the development of OpenC++ Version 2. <p> The degree of transparency of libraries written with that MOP was not enough for real-world programming. A number of ideas for the OpenC++ MOP came from previous work. The idea of a compile-time MOP is due to Anibus and Intrigue <ref> [18, 13] </ref>. These are compile-time MOPs for controlling a Scheme compiler. In those MOPs, the metaobjects are not just language entities, but also represent global information such as the results of flow analysis. Our basic protocol architecture is due to the CLOS MOP [11].
Reference: [14] <author> Lortz, V. B. and K. G. Shin, </author> <title> "Combining Con tracts and Exemplar-Based Programming for Class Hiding and Customization," </title> <booktitle> in Proc. of ACM Conf. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pp. 453-467, </pages> <year> 1994. </year>
Reference-contexts: But in the typical implementation scheme, selecting the appropriate concrete class happens at runtime, thereby incurring a performance overhead. The mechanism we show below is similar to that in <ref> [14] </ref>, but it automatically selects the most appropriate subclass at compile time. The user just annotates requirements for each instantiation of a class, then the compiler selects a subclass to mostly satisfy the requirements.
Reference: [15] <author> Maes, P., </author> <title> "Concepts and Experiments in Computational Reflection," </title> <booktitle> in Proc. of ACM Conf. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pp. 147-155, </pages> <year> 1987. </year>
Reference-contexts: The idea of a meta-interface of the early-stage of compilation was also proposed in MPC++[8]. Like the CLOS MOP and OpenC++ Version 1, a number of systems <ref> [15, 7, 17, 22] </ref> adopt runtime metaobjects, which represent underlying mechanisms such as the language interpreter and the OS kernel, and are responsible for runtime behavior of the system.
Reference: [16] <author> Masuhara, H., S. Matsuoka, T. Watanabe, and A. Yonezawa, </author> <title> "Object-Oriented Concurrent Reflective Languages can be Implemented Efficiently," </title> <booktitle> in Proc. of ACM Conf. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pp. 127-144, </pages> <year> 1992. </year>
Reference-contexts: Since the runtime metaobjects allow users to change various decision policies of the system, such as scheduling and migration, the users can tune the system performance to fit their needs. A drawback of the runtime metaobjects is runtime overhead. A few ideas have been proposed on this problem <ref> [12, 16, 19] </ref>. For example, inlining and partial evaluation are effective techniques to reduce the overhead. It is difficult to recover the whole overhead of a runtime meta architecture, however. 7 Current Status We are in the process of developing OpenC++ Version 2.
Reference: [17] <author> Okamura, H., Y. Ishikawa, and M. Tokoro, "AL-1/D: </author> <title> A Distributed Programming System with Multi-Model Reflection Framework," </title> <booktitle> in Proc. of the Int'l Workshop on Reflection and Meta-Level Architecture (A. </booktitle> <editor> Yonezawa and B. C. Smith, </editor> <booktitle> eds.), </booktitle> <pages> pp. 36-47, </pages> <year> 1992. </year>
Reference-contexts: The idea of a meta-interface of the early-stage of compilation was also proposed in MPC++[8]. Like the CLOS MOP and OpenC++ Version 1, a number of systems <ref> [15, 7, 17, 22] </ref> adopt runtime metaobjects, which represent underlying mechanisms such as the language interpreter and the OS kernel, and are responsible for runtime behavior of the system.
Reference: [18] <author> Rodriguez Jr., L. H., </author> <title> "Coarse-Grained Paral lelism Using Metaobject Protocols," </title> <note> Techincal Report SSL-91-61, XEROX PARC, </note> <institution> Palo Alto, </institution> <address> CA, </address> <year> 1991. </year>
Reference-contexts: Our MOP has been developed by a synthesis and re-engineering of a number of ideas in this field: we took our basic protocol structure from the CLOS MOP [11], we took the basic structure of a compile-time MOP from Anibus and Intrigue <ref> [18, 13] </ref>, and we took some ideas for the basic structure of a MOP for C++ from the meta-information protocol (MIP) [2] and our previous work on Open C++ Version 1 [4]. This paper is a status report on the development of OpenC++ Version 2. <p> The degree of transparency of libraries written with that MOP was not enough for real-world programming. A number of ideas for the OpenC++ MOP came from previous work. The idea of a compile-time MOP is due to Anibus and Intrigue <ref> [18, 13] </ref>. These are compile-time MOPs for controlling a Scheme compiler. In those MOPs, the metaobjects are not just language entities, but also represent global information such as the results of flow analysis. Our basic protocol architecture is due to the CLOS MOP [11].
Reference: [19] <author> Ruf, E., </author> <title> "Partial Evaluation in Reflective Sys tem Implementation," </title> <booktitle> in Proc. of OOPSLA'93 Workshop on Reflection and Metalevel Architectures, </booktitle> <year> 1993. </year>
Reference-contexts: Since the runtime metaobjects allow users to change various decision policies of the system, such as scheduling and migration, the users can tune the system performance to fit their needs. A drawback of the runtime metaobjects is runtime overhead. A few ideas have been proposed on this problem <ref> [12, 16, 19] </ref>. For example, inlining and partial evaluation are effective techniques to reduce the overhead. It is difficult to recover the whole overhead of a runtime meta architecture, however. 7 Current Status We are in the process of developing OpenC++ Version 2.
Reference: [20] <author> Steele, G., </author> <title> Common Lisp: The Language. </title> <publisher> Dig ital Press, </publisher> <editor> 2nd ed., </editor> <year> 1990. </year>
Reference-contexts: 1 Introduction A metaobject protocol (MOP) is an object-oriented interface for programmers to customize the behavior and implementation of programming languages and other system software. The usefulness of this kind of customizability has been argued elsewhere [11, 9, 10], and interesting MOPs have been included in languages such as Lisp <ref> [20] </ref>, ABCL [21], and, to a lesser degree, Smalltalk [6]. The goal of our work is to bring the power of meta-programming to the more mainstream language C++, while respecting their performance concerns in that community. This paper proposes a new MOP for C++, called OpenC++ Version 2.
Reference: [21] <author> Watanabe, T. and A. Yonezawa, </author> <title> "Reflection in an Object-Oriented Concurrent Language," </title> <booktitle> in Proc. of ACM Conf. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pp. 306-315, </pages> <year> 1988. </year>
Reference-contexts: The usefulness of this kind of customizability has been argued elsewhere [11, 9, 10], and interesting MOPs have been included in languages such as Lisp [20], ABCL <ref> [21] </ref>, and, to a lesser degree, Smalltalk [6]. The goal of our work is to bring the power of meta-programming to the more mainstream language C++, while respecting their performance concerns in that community. This paper proposes a new MOP for C++, called OpenC++ Version 2.
Reference: [22] <author> Yokote, Y., </author> <title> "The Apertos Reflective Operat ing System: The Concept and Its Implementation," </title> <booktitle> in Proc. of ACM Conf. on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pp. 414-434, </pages> <year> 1992. </year>
Reference-contexts: The idea of a meta-interface of the early-stage of compilation was also proposed in MPC++[8]. Like the CLOS MOP and OpenC++ Version 1, a number of systems <ref> [15, 7, 17, 22] </ref> adopt runtime metaobjects, which represent underlying mechanisms such as the language interpreter and the OS kernel, and are responsible for runtime behavior of the system.
References-found: 22

