URL: http://www.cs.washington.edu/homes/levy/opal/hicss.ps
Refering-URL: http://www.cs.washington.edu/homes/levy/opal/opalpapers.html
Root-URL: 
Title: Shared Memory Support for Object-based RPC hardware-based protection domains to protect a server's objects; clients
Author: Rene W. Schmidt Jeffrey S. Chase and Henry M. Levy 
Note: use  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: This paper describes object-based runtime support for efficient access to protected objects, i.e., objects belonging to server programs that export protected services to untrusted clients. Modern operating systems We show how to provide safe and efficient access to server data by client read-sharing of some server objects and methods. Local client calls to read-only methods execute directly in shared memory, without the cost of protection crossing. We introduce a version-based mechanism to synchronize the readers with write-methods executing in the server domain. Object-based proxies hide the use of shared memory from client programs. Measurements of a simple application demonstrate that our techniques can deliver performance close to an unprotected implementation, but with the modularity and server protection of traditional RPC. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew D. Birrell and Bruce Jay Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: 1 Introduction The client/server model is commonly used to provide data sharing and protection in software systems. Client applications access the data through a fixed procedural interface defined by the server. Calls to the server utilize a protected procedure call mechanism, typically Remote Procedure Calls <ref> [1] </ref>, to execute code within the server's domain. fl Current address is Department of Computer Science, University of Aarhus, DK-8000 Aarhus C, Denmark. y Current address is Department of Computer Science, Duke University, Durham NC 27708-0129 In an object-based environment, the client/server model is implemented using object invocation mechanisms, which are <p> Herlihy [16] has provided a basic methodology for implementing non-blocking synchronization and mutual exclusion; he uses two counters (check [0] and check <ref> [1] </ref>) to ensure that an object is not copied while it is in an inconsistent state. The two version numbers in version-based synchronization serve a similar purpose, but only read-only methods are implemented lock-free in version-based synchronization. <p> The Mutex and Version variables are shared among all methods for a particular object. W1: . non-critical section / W2: Mutex.lock (); W3: Version [0] Version [0] + 1; W4: . critical section / W5: Version <ref> [1] </ref> Version [1] + 1; W6: Mutex.unlock (); W7: . non-critical section / tion. R1: . non-critical section / R2: do R3: v 1 Version [1]; R4: . critical section / R5: v 0 Version [0]; R6: while (v 0 6= v 1 ); R7: . non-critical section / Write-methods synchronize <p> The Mutex and Version variables are shared among all methods for a particular object. W1: . non-critical section / W2: Mutex.lock (); W3: Version [0] Version [0] + 1; W4: . critical section / W5: Version <ref> [1] </ref> Version [1] + 1; W6: Mutex.unlock (); W7: . non-critical section / tion. R1: . non-critical section / R2: do R3: v 1 Version [1]; R4: . critical section / R5: v 0 Version [0]; R6: while (v 0 6= v 1 ); R7: . non-critical section / Write-methods synchronize among themselfs <p> W1: . non-critical section / W2: Mutex.lock (); W3: Version [0] Version [0] + 1; W4: . critical section / W5: Version <ref> [1] </ref> Version [1] + 1; W6: Mutex.unlock (); W7: . non-critical section / tion. R1: . non-critical section / R2: do R3: v 1 Version [1]; R4: . critical section / R5: v 0 Version [0]; R6: while (v 0 6= v 1 ); R7: . non-critical section / Write-methods synchronize among themselfs using a mutex lock. Furthermore, they update the version-numbers. The version-numbers are used by the r-methods to detect concurrent access. <p> Furthermore, they update the version-numbers. The version-numbers are used by the r-methods to detect concurrent access. Version [0] counts the number of times an update has begun on an object, and Version <ref> [1] </ref> counts the number of times an update has completed. If the two numbers are equal the object will be in a consistent state, otherwise a w-method is executing. <p> On the server side, the RPC call is handled by a guard object, which unmarshalls and validates the parameters and executes a local object invocation. Proxies and guards correspond to client and server stubs, respectively, in a standard RPC system <ref> [1] </ref>. A pointer to a protected object is passed as a capability [18] between the clients and servers. A capability is an unforgeable name for a protected object. We use password capabilities [19], which are probabilistically rather than absolutely impossible to forge.
Reference: [2] <author> Marc Shapiro. </author> <title> Structure and encapsulation in distributed systems: The proxy principle. </title> <booktitle> In Proceedings of the Sixth International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: In this case, each call specifies a particular instance of an abstraction supported by the server. Proxies <ref> [2] </ref> are typically used to implement the server invocations in this case. The protected server objects (i.e., objects that exist inside the server's domain) are represented by a local proxy object in the client. The proxy contains methods (RPC stubs) that forward invocations to the server.
Reference: [3] <author> B. Bershad, T. Anderson, E. Lazowska, and H. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1), </volume> <month> Febru-ary </month> <year> 1990. </year>
Reference-contexts: For this reason, many programs execute in a single protection domain rather than in several domains, at a loss of protection and security. Bershad et. al. have shown that the performance of same-machine cross-domain communication can be considerably improved by using shared memory <ref> [3] </ref>; Lightweight Remote Procedure Call (LRPC) uses a shared stack to avoid copying parameters and return values between protection domains, and reduces scheduling overhead by running the client thread in the server's domain. However, even with LRPC, cross-address space communication is substantially more expensive than a local procedure call.
Reference: [4] <author> Ellis E. Chang and Randy H. Katz. </author> <title> Exploiting inheritance and structure semantics for effective clustering and buffering in an object-oriented DBMS. </title> <booktitle> In ACM International Conference on Management of Data, </booktitle> <year> 1989. </year>
Reference-contexts: For example, CAD applications have been shown to exhibit such behaviour <ref> [4] </ref>. A Dexter-based hyper-text system [5] also needs mostly read-only access to the applications that contain the data for each node in the hyper-text document.
Reference: [5] <author> K. Grtnbk and R.H. Trigg. </author> <title> Design Issues for a Dexter-based Hypermedia System. </title> <journal> Communications of the ACM, </journal> <volume> 37(2):40 - 49, </volume> <month> February </month> <year> 1994. </year>
Reference-contexts: For example, CAD applications have been shown to exhibit such behaviour [4]. A Dexter-based hyper-text system <ref> [5] </ref> also needs mostly read-only access to the applications that contain the data for each node in the hyper-text document. Using our techniques, a server maps its data seg ment read-only into a client's address spaces, thereby allowing the client domain to access (read) the server's data directly.
Reference: [6] <author> Jeffrey S. Chase, Henry M. Levy, Edward D. La-zowska, and Miche Baker-Harvey. </author> <title> Lightweight shared objects in a 64-bit operating system. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Such calls would obviously negate the value of using read-only methods. To solve this problem, we have developed a hybrid locking scheme, called version-based synchronization, that permits read-only methods to synchronize without executing any store instructions. We have constructed a prototype implementation of these techniques for the Opal system <ref> [6, 7] </ref>, a single virtual address-space operating system. Our im plementation shows how read-only sharing of memory between client and server can be incorporated into an object-based RPC toolkit, so that its use is transparent to the user.
Reference: [7] <author> Jeffrey S. Chase, Henry M. Levy, Michael J. Fee-ley, and Edward D. Lazowska. </author> <title> Sharing and protection in a single address space operating system. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 12(4), </volume> <month> November </month> <year> 1994. </year>
Reference-contexts: Such calls would obviously negate the value of using read-only methods. To solve this problem, we have developed a hybrid locking scheme, called version-based synchronization, that permits read-only methods to synchronize without executing any store instructions. We have constructed a prototype implementation of these techniques for the Opal system <ref> [6, 7] </ref>, a single virtual address-space operating system. Our im plementation shows how read-only sharing of memory between client and server can be incorporated into an object-based RPC toolkit, so that its use is transparent to the user. <p> In Choices proxies are allocated in read-only memory by the kernel to assure authentication of proxies and to be able to change the implementation of proxies without having to re-compile client programs. Proxies are not shared between clients. Several experimental operating systems, such as Opal <ref> [7] </ref> and Monads [15], provide a single shared address space for all applications. Protection and addressing are decoupled in these systems which makes it possible for applications to easily coordinate sharing of data at runtime.
Reference: [8] <author> Eric Jul, Henry Levy, Norman Hutchinson, and Andrew Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: It is thus related to a number of previous research efforts that support object-based programming and those that support fine-grained synchronization. In the following we describe some of those projects and how our work relates to theirs. The Emerald system <ref> [8] </ref> was a distributed object system supporting fine-grain object mobility and efficient local performance. To achieve high performance, 2 all objects on a local machine were located in the same protection domain, so access to local objects could be done directly with load and store operations.
Reference: [9] <author> Guy T. Almes, Andrew P. Black, Edward D. La-zowska, and Jerre D. Noe. </author> <title> The Eden system: A technical review. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):43-59, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: In our work, we do not require a safe language; instead, we use read-only methods to provide access to server data located on the same machine, while requiring cross-domain calls for methods that modify server data. Systems such as Eden <ref> [9] </ref>, Clouds [10], Choices [11] and Spring [12] integrated object-based RPC support in the operating system kernel. High performance of cross address-space calls is crucial for such systems.
Reference: [10] <author> J.E. Allchin and M.S. McKendry. </author> <title> Synchronization and recovery of actions. </title> <booktitle> In Proceedings of the 2nd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 31-44, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: In our work, we do not require a safe language; instead, we use read-only methods to provide access to server data located on the same machine, while requiring cross-domain calls for methods that modify server data. Systems such as Eden [9], Clouds <ref> [10] </ref>, Choices [11] and Spring [12] integrated object-based RPC support in the operating system kernel. High performance of cross address-space calls is crucial for such systems. Object-based RPC libraries have been built for a wide variety of programming languages as well, including Modula-3 [13], BETA [14], and C ++ .
Reference: [11] <author> Amitabh Dave, Mohlalefi Sefika, and Roy H. Campbell. </author> <title> Proxies, application interfaces, </title> <booktitle> and distributed systems. In Proceedings of the Second International Workshop on Object Orientation in Operating Systems, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: In our work, we do not require a safe language; instead, we use read-only methods to provide access to server data located on the same machine, while requiring cross-domain calls for methods that modify server data. Systems such as Eden [9], Clouds [10], Choices <ref> [11] </ref> and Spring [12] integrated object-based RPC support in the operating system kernel. High performance of cross address-space calls is crucial for such systems. Object-based RPC libraries have been built for a wide variety of programming languages as well, including Modula-3 [13], BETA [14], and C ++ . <p> Our optimizations are at the runtime level, but we belive that they are general and apply equally well to operating systems. The proxy implementation in Choices <ref> [11] </ref> is simi lar to our shared proxies, but the rationale behind the design is different. In Choices proxies are allocated in read-only memory by the kernel to assure authentication of proxies and to be able to change the implementation of proxies without having to re-compile client programs.
Reference: [12] <author> G. Hamilton and P. Kougiouris. </author> <title> The Spring nucleus: A microkernel for objects. </title> <booktitle> In Proceedings of the 1993 Summer Usenix conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: In our work, we do not require a safe language; instead, we use read-only methods to provide access to server data located on the same machine, while requiring cross-domain calls for methods that modify server data. Systems such as Eden [9], Clouds [10], Choices [11] and Spring <ref> [12] </ref> integrated object-based RPC support in the operating system kernel. High performance of cross address-space calls is crucial for such systems. Object-based RPC libraries have been built for a wide variety of programming languages as well, including Modula-3 [13], BETA [14], and C ++ .
Reference: [13] <author> Andrew Birrell, Greg Nelson, Susan Owicki, and Edward Wobber. </author> <title> Network Objects. </title> <booktitle> In Proceedings of the 14th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 217-230, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Systems such as Eden [9], Clouds [10], Choices [11] and Spring [12] integrated object-based RPC support in the operating system kernel. High performance of cross address-space calls is crucial for such systems. Object-based RPC libraries have been built for a wide variety of programming languages as well, including Modula-3 <ref> [13] </ref>, BETA [14], and C ++ . Our optimizations are at the runtime level, but we belive that they are general and apply equally well to operating systems. The proxy implementation in Choices [11] is simi lar to our shared proxies, but the rationale behind the design is different.
Reference: [14] <author> S. Brandt and O.L. Madsen. </author> <title> Object-Oriented Distributed Programming in BETA. </title> <editor> In R. Guer-raoui, O.M. Nierstrasz, and M. Riveill, editors, </editor> <booktitle> Lecture Notes in Computer Science 791, </booktitle> <pages> pages 185 - 212. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: High performance of cross address-space calls is crucial for such systems. Object-based RPC libraries have been built for a wide variety of programming languages as well, including Modula-3 [13], BETA <ref> [14] </ref>, and C ++ . Our optimizations are at the runtime level, but we belive that they are general and apply equally well to operating systems. The proxy implementation in Choices [11] is simi lar to our shared proxies, but the rationale behind the design is different.
Reference: [15] <author> John Rosenberg. </author> <title> Architectural and operating system support for orthogonal persistence. </title> <journal> Computing Systems, </journal> <volume> 5(3), </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: In Choices proxies are allocated in read-only memory by the kernel to assure authentication of proxies and to be able to change the implementation of proxies without having to re-compile client programs. Proxies are not shared between clients. Several experimental operating systems, such as Opal [7] and Monads <ref> [15] </ref>, provide a single shared address space for all applications. Protection and addressing are decoupled in these systems which makes it possible for applications to easily coordinate sharing of data at runtime.
Reference: [16] <author> Maurice Herlihy. </author> <title> A methodology for implementing highly concurrent data objects. </title> <type> Technical Report CRL 91/10, </type> <institution> DEC Cambridge Research Laboratory, </institution> <year> 1991. </year>
Reference-contexts: Our techniques can easily be utilized on top of such systems (and, in fact, were prototyped on Opal), however they are independent of such single address space support. Herlihy <ref> [16] </ref> has provided a basic methodology for implementing non-blocking synchronization and mutual exclusion; he uses two counters (check [0] and check [1]) to ensure that an object is not copied while it is in an inconsistent state. <p> If the data pointer was changed since the copy was made, the commit fails and the update has to execute again. Lock-free synchronization is considerably more complex to use than interlocking. However, several authors have shown that lock-free <ref> [16, 17] </ref> synchronization is both practical and efficient. Version-based synchronization exploits the asymmetry in the multiple-readers/single-writer synchronization protocol.
Reference: [17] <author> Henry Massalin and Calton Pu. </author> <title> A lock-free multiprocessor OS kernel. </title> <type> Technical Report 92-03-02, </type> <institution> Columbia University, Department of Computer Science, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: If the data pointer was changed since the copy was made, the commit fails and the update has to execute again. Lock-free synchronization is considerably more complex to use than interlocking. However, several authors have shown that lock-free <ref> [16, 17] </ref> synchronization is both practical and efficient. Version-based synchronization exploits the asymmetry in the multiple-readers/single-writer synchronization protocol.
Reference: [18] <author> Jack B. Dennis and Earl C. Van Horn. </author> <title> Programming semantics for multiprogrammed computations. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 143-155, </pages> <month> March </month> <year> 1966. </year>
Reference-contexts: Proxies and guards correspond to client and server stubs, respectively, in a standard RPC system [1]. A pointer to a protected object is passed as a capability <ref> [18] </ref> between the clients and servers. A capability is an unforgeable name for a protected object. We use password capabilities [19], which are probabilistically rather than absolutely impossible to forge. The capability for an protected object is both stored in the proxy and in the guard.
Reference: [19] <author> M. Anderson, R. D. Pose, and C. S. Wallace. </author> <title> The password-capability system. </title> <journal> The Computer Journal, </journal> <volume> 29(1) </volume> <pages> 1-8, </pages> <month> February </month> <year> 1986. </year> <month> 9 </month>
Reference-contexts: Proxies and guards correspond to client and server stubs, respectively, in a standard RPC system [1]. A pointer to a protected object is passed as a capability [18] between the clients and servers. A capability is an unforgeable name for a protected object. We use password capabilities <ref> [19] </ref>, which are probabilistically rather than absolutely impossible to forge. The capability for an protected object is both stored in the proxy and in the guard. On the client side, a capability is translated into a proxy pointer by looking it up in a hashtable that maps capabilities to proxies.
References-found: 19

