URL: http://react-ilp.cs.nyu.edu/publications/timeC.ps
Refering-URL: http://react-ilp.cs.nyu.edu/publications/index.html
Root-URL: http://www.cs.nyu.edu
Email: 1 leunga@cs.nyu.edu  palem@cs.nyu.edu  amir@wisdom.weizmann.ac.il  
Title: TimeC: A Time Constraint Language for ILP Processor Compilation  
Author: Allen Leung Krishna V. Palem Amir Pnueli 
Keyword: instruction scheduling, compiler optimizations, embedded systems, real-time systems, timing constraints.  
Note: Supported in part by an award from Hewlett-Packard Corporation, IBM corporation, Panasonic AVC Labs, DARPA contract no. DABT63-96-C-0049, and an NYU Research Challenge Grant.  
Address: 2  3  
Affiliation: Courant Institute of Mathematical Sciences  Courant Institute of Mathematical Sciences  The Weizmann Institute of Science  
Abstract: Enabled by RISC technologies, low-cost commodity microprocessors are performing at ever increasing levels, significantly via instruction level parallelism (ILP). This in turn increases the opportunities for their use in a variety of day-to-day applications ranging from the simple control of appliances such as microwave ovens, to sophisticated systems for cabin control in modern aircraft. Indeed, "embedded" applications such as these represent segments in the computer industry with great potential for growth. However, this growth is currently impeded by the lack of robust optimizing compiler technologies that support the assured, rapid and inexpensive prototyping of real-time software in the context of microprocessors with ILP. In this paper we describe a novel notation, TimeC, for specifying timing constraints in programs, independent of the base language being used to develop the embedded application; TimeC specifications are language independent and can be instrumented into imperative and object-oriented languages non-intrusively. As we will show, the program synthesis problem that arise out of Time tract specifications, a subset of TimeC, are always "tractable". In contrast, a range of specification mechanisms proposed earlier yield substantially intractable synthesis questions, thereby limiting their potential utility. We will compare the tractability and related expressive power issues between TimeC and some of the extant mechanisms for specifying properties of timed programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Sethi A. Aho and J. Ullman. </author> <title> Compiler Construction. </title> <address> Addison-Wessley, </address> <year> 1984. </year>
Reference-contexts: In this section we will describe the syntax and informal semantics of TimeC. The formal semantics of TimeC is described in section 3. We will start our discussion with an example. For convenience, we will first present the notions in the context of basic-blocks <ref> [1] </ref>, [27]. 2.1 An Example Embedded Program Consider a program that controls a typical Cardiac Arrythmia monitor in a modern ICU [25]. <p> Data is sampled every 30 msec (two consecutive sampling points are never more than 30 msec apart), and 2. Whenever an abnormality (arrythmia) is detected, software sounds an alarm within 500 msec. Throughout this paper, we will assume that all our formal specifications refer to structured programs <ref> [1] </ref>, and that all times are expressed in milliseconds. 2.2 Syntax of TimeC for basic-blocks Continuing with the example, let us consider the basic-block enclosed by markers M 5 and M 6 . <p> First, because of branching, we must also be sensitive to the program's control-flow in addition to data-dependence. In particular, moving instructions out of their initial basic-blocks past program branch and merge points <ref> [1] </ref>, [27] in the CFG lead to "side-effects" which require special attention and add to the complexities. A significant issue that arises in the context of moving instructions globally is the effects of speculation and replication.
Reference: [2] <author> A. Aiken and A. Nicolau. </author> <title> Loop quantization; an analysis and algorithm. </title> <type> Technical Report 87-821, </type> <institution> Cornell University, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: The last column of figure 15 shows such a feasible schedule after scheduling. As is standard in conventional global scheduling (<ref> [2] </ref>, [9], [11], [28]), we treat loop scheduling [28], [22] and acyclic scheduling [2], [9], [11] separately. This division of tasks is traditionally used since combining both in the same scheduling framework leads to high degree of complexity in engineering and analysis.
Reference: [3] <author> R. Alur and D. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 183-235, </pages> <year> 1994. </year>
Reference-contexts: Local clock variables can be introduced in order to keep track of start time of statement. However, the convention is that only the global clock RT is continuously incremented. This protocol is similar to the convention of clock variables in timed-automata <ref> [3] </ref>. In order to deal with periodic behavior in loops such as while B do S end while, it is often necessary to make references to the iteration counts of loops.
Reference: [4] <author> R. Alur and T. Henzinger. </author> <title> Logics and models of real time: A survey. </title> <editor> In J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings of the REX Workshop "Real-Time: Theory in Practice", volume 600 of Lect. Notes in Comp. Sci., </booktitle> <pages> pages 74-106. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We refer the readers to the excellent survey <ref> [4] </ref> where many of these logics are described and compared. <p> Additional logics and their comparative power are surveyed in <ref> [4] </ref>. In many respects, the comments made while comparing RTL to TimeC also apply to the comparison of any of the timed temporal logics described below with TimeC. Namely, all of these logics are strictly more expressive than TimeC.
Reference: [5] <author> R. Alur and T.A. Henzinger. </author> <title> A really temporal logic. </title> <booktitle> In Proc. 30th IEEE Symp. Found. of Comp. Sci., </booktitle> <pages> pages 164-169, </pages> <year> 1989. </year>
Reference-contexts: The use of bounded temporal operators has been advocated by Koymans, Vytopil, and de Roever ([21], [20], [19]), although an early proposal by Bernstein and Harter can be viewed as a precursor [8]. 7.5.2 The Timed Logic TPTL The logic TPTL (timed temporal logic) <ref> [5] </ref> extends conventional TL by adding special variables that can be viewed as recording the value of an assumed master clock at given instances. These are often described as freeze variables since they freeze the current value of the master clock for future comparison. <p> Lower Bound: 2 x: This formula states that, every occurrence of p at time x and a following occurrence of q at time y must satisfy y x + 3, guaranteeing a time separation of at least 3 time units. As has been shown in <ref> [5] </ref>, when we consider the discrete time domain, TPTL and MTL have the same expressive power. However, when we move to dense time domains, TPTL becomes more expressive than MTL.
Reference: [6] <author> R. Alur and T.A. Henzinger. </author> <title> Real-time logics: Complexity and expressiveness. </title> <booktitle> In Proc. 5th IEEE Symp. Logic in Comp. Sci., </booktitle> <pages> pages 390-401, </pages> <year> 1990. </year>
Reference-contexts: This property can be expressed within TimeC by the following constraint time (q) time (p) 3 For simplicity, we assume that p and q can occur at most once in every computation. 7.5.1 The Timed Logic MTL The logic MTL (metric temporal logic) <ref> [6] </ref> extends conventional temporal logic (TL) [24] by introducing a bounded version of the temporal operators which subscripts a temporal operator such as 2 or by an interval [l; u]. The meaning of such an annotation is that the scope of the subscribed operator is limited to this interval.
Reference: [7] <institution> Intel and Hewlett Packard Corporations. </institution> <note> Press releases on Intel's IA-64. http://www.intel.com/pressroom/kits/events/mpf1097.htm, 1997. </note>
Reference-contexts: These microprocessors are increasingly allowing the compiler to control how these instructions are issued|notable examples included the explicitly parallel instruction computers (EPIC) that have been announced via a joint effort by the Hewlett Packard and Intel corporations <ref> [7] </ref>. In such processors, the instruction scheduling optimization rearranges the source program so that * As many parallel instructions as possible are executed on each and every cycle * while preserving the programs data- and control dependences. Now, given timing constraints, instruction scheduling must also enforce them.
Reference: [8] <author> A. Bernstein and P. K. Harter. </author> <title> Proving real time properties of programs with temporal logic. </title> <booktitle> In Proceedings of the Eighth Symposium on Operating Systems Principles, </booktitle> <pages> pages 1-11. </pages> <publisher> ACM, </publisher> <year> 1981. </year>
Reference-contexts: This formula states that, no q can occur within 3 time units from an occurrence of p. The use of bounded temporal operators has been advocated by Koymans, Vytopil, and de Roever ([21], [20], [19]), although an early proposal by Bernstein and Harter can be viewed as a precursor <ref> [8] </ref>. 7.5.2 The Timed Logic TPTL The logic TPTL (timed temporal logic) [5] extends conventional TL by adding special variables that can be viewed as recording the value of an assumed master clock at given instances.
Reference: [9] <author> D. Bernstein and M. Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> Proceedings of SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <year> 1991. </year>
Reference-contexts: The last column of figure 15 shows such a feasible schedule after scheduling. As is standard in conventional global scheduling ([2], <ref> [9] </ref>, [11], [28]), we treat loop scheduling [28], [22] and acyclic scheduling [2], [9], [11] separately. This division of tasks is traditionally used since combining both in the same scheduling framework leads to high degree of complexity in engineering and analysis. <p> The last column of figure 15 shows such a feasible schedule after scheduling. As is standard in conventional global scheduling ([2], <ref> [9] </ref>, [11], [28]), we treat loop scheduling [28], [22] and acyclic scheduling [2], [9], [11] separately. This division of tasks is traditionally used since combining both in the same scheduling framework leads to high degree of complexity in engineering and analysis. Furthermore, the two approaches are traditionally analyzed separately, and efficient and effective heuristics have been discovered that work on each domain individually.
Reference: [10] <author> B.W.Kernigan and D.M.Richie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> 2 edition, </address> <year> 1988. </year>
Reference-contexts: For example, statements in the C language <ref> [10] </ref> are executed sequentially as required by its semantics. The control points in the C language are simply the locations in front of each statement. For completeness, we also introduce a control point at the end of the program.
Reference: [11] <author> J. Fisher. </author> <title> Trace scheduling: A general technique for global microcode compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(7):478-490, </volume> <year> 1981. </year>
Reference-contexts: The last column of figure 15 shows such a feasible schedule after scheduling. As is standard in conventional global scheduling ([2], [9], <ref> [11] </ref>, [28]), we treat loop scheduling [28], [22] and acyclic scheduling [2], [9], [11] separately. This division of tasks is traditionally used since combining both in the same scheduling framework leads to high degree of complexity in engineering and analysis. <p> The last column of figure 15 shows such a feasible schedule after scheduling. As is standard in conventional global scheduling ([2], [9], <ref> [11] </ref>, [28]), we treat loop scheduling [28], [22] and acyclic scheduling [2], [9], [11] separately. This division of tasks is traditionally used since combining both in the same scheduling framework leads to high degree of complexity in engineering and analysis. Furthermore, the two approaches are traditionally analyzed separately, and efficient and effective heuristics have been discovered that work on each domain individually.
Reference: [12] <author> Joseph Fisher. </author> <title> Global code generation for instruction-level parallelism:trace scheduling-2. </title> <type> Technical report, </type> <institution> HP Labs, </institution> <year> 1991. </year>
Reference-contexts: In contrast, branches (and merges) are treated differently since the corresponding overheads can be prohibitive <ref> [12] </ref>. Consequently, scheduling technology frequently limits the relative reordering of these instructions completely. We will retain this restriction in our subsequent discussion. 5.1.2 Feasible global acyclic schedule Let us now make precise the notion of a global acyclic schedule.
Reference: [13] <author> E. Harel, O. Lichtenstein, and A. Pnueli. </author> <title> Explicit clock temporal logic. </title> <booktitle> In Proc. 5th IEEE Symp. Logic in Comp. Sci., </booktitle> <pages> pages 402-413, </pages> <year> 1990. </year>
Reference-contexts: A simpler version of this logic which does not allow quantification but allows arbitrary addition between time recording variables has been introduced in <ref> [13] </ref> under the name XCTL (explicit clock temporal logic). It is based on the observation that a formula is valid iff its universal closure is.
Reference: [14] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communication of the ACM, </journal> <volume> 12 </volume> <pages> 576-580, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: This work takes the approach of extending Hoare logic <ref> [14] </ref> with the ability to reason with time by introducing global clock variables that are updated after the execution of every statement. Like our approach, the extend timed Hoare logic introduced is also base language independent.
Reference: [15] <author> S. Hong and R. Gerber. </author> <title> Compiling real-time programs with timing constraint refinement and structural code motion. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21, </volume> <month> May </month> <year> 1995. </year>
Reference-contexts: Consequently, these formalisms are typically very expressive which makes the goal of automatic synthesis according to a given specification highly intractable. Currently, the only language notations that seriously consider the synthesize problem are TCEL <ref> [15] </ref> and CRL [31]. However, in contrast to TimeC, both are new programming languages in their own right, and the programmer can only utilize the full power of the timing constraints within these new languages. <p> first class (specification and analysis only) are typically more powerful and expressive than the languages developed for the more ambitious class which also aims to synthesize satisfactory implementations. 7.1 TCEL A notation for specifying time called TCEL and a framework for scheduling programs derived from TCEL specifications were introduced in <ref> [15] </ref>. Contrasting with our approach and results here, TCEL is a programming language wherein timing constraints are explicitly specified as part of the control-flow of the application program; in this sense, the programmer must write TCEL programs.
Reference: [16] <author> F. Jahnaian and A. K. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Soaftware Engineering, </journal> <volume> SE-12(9):890-904, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: Most of the previous work on timing constraint formalisms, such as RTL <ref> [16] </ref> and Hoare Logic with time [29], concentrated on the tasks of specification and verification of real-time systems. Consequently, these formalisms are typically very expressive which makes the goal of automatic synthesis according to a given specification highly intractable.
Reference: [17] <author> F. Jahnaian and A. K. Mok. </author> <title> A graph-theoretic approach for timing analysis and its implementation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C36(8), </volume> <year> 1987. </year>
Reference: [18] <author> J.R.Allen, K.Kennedy, C. Porterfield, and J. Warren. </author> <title> Conversion of contgrol dependence to data dependence. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-189, </pages> <year> 1983. </year>
Reference: [19] <author> R. Koymans. </author> <title> Specifying real-time properties with metric temporal logic. </title> <booktitle> Real-time Systems, </booktitle> <volume> 2(4) </volume> <pages> 255-299, </pages> <year> 1990. </year>
Reference-contexts: Lower Bound: p =) 2 [0;3] :q. This formula states that, no q can occur within 3 time units from an occurrence of p. The use of bounded temporal operators has been advocated by Koymans, Vytopil, and de Roever ([21], [20], <ref> [19] </ref>), although an early proposal by Bernstein and Harter can be viewed as a precursor [8]. 7.5.2 The Timed Logic TPTL The logic TPTL (timed temporal logic) [5] extends conventional TL by adding special variables that can be viewed as recording the value of an assumed master clock at given instances.
Reference: [20] <author> R. Koymans and W.-P. de Roever. </author> <title> Examples of a real-time temporal logic specifications. In B.D. </title> <editor> Denvir, W.T. Harwood, M.I. Jackson, and M.J. Wray, editors, </editor> <booktitle> The Analysis of Concurrent Systems, volume 207 of Lect. Notes in Comp. Sci., </booktitle> <pages> pages 231-252. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Lower Bound: p =) 2 [0;3] :q. This formula states that, no q can occur within 3 time units from an occurrence of p. The use of bounded temporal operators has been advocated by Koymans, Vytopil, and de Roever ([21], <ref> [20] </ref>, [19]), although an early proposal by Bernstein and Harter can be viewed as a precursor [8]. 7.5.2 The Timed Logic TPTL The logic TPTL (timed temporal logic) [5] extends conventional TL by adding special variables that can be viewed as recording the value of an assumed master clock at given
Reference: [21] <author> R. Koymans, J. Vytopyl, and W.-P. de Roever. </author> <title> Real-time programming and asynchronous message passing. </title> <booktitle> In Proc. 2nd ACM Symp. Princ. of Dist. Comp., </booktitle> <pages> pages 187-197, </pages> <year> 1983. </year>
Reference: [22] <author> M. Lam. </author> <title> Software pipelining: An effective scheduling technique for vliw machines. </title> <booktitle> Proceedings SIG-PLAN'88 Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 318-328, </pages> <year> 1988. </year>
Reference-contexts: The last column of figure 15 shows such a feasible schedule after scheduling. As is standard in conventional global scheduling ([2], [9], [11], [28]), we treat loop scheduling [28], <ref> [22] </ref> and acyclic scheduling [2], [9], [11] separately. This division of tasks is traditionally used since combining both in the same scheduling framework leads to high degree of complexity in engineering and analysis. <p> Together these conditions imply that the scheduled program P 0 preserves the functional semantics of program P and satisfies the timing-constraints imposed by TimeC. 5.1.3 Instruction scheduling for loops Software pipelining [28], <ref> [22] </ref> is a common technique for exploiting instruction-level parallelism in loops by overlapping instructions multiple iterations together to hide the long latencies within an iteration. <p> To deal with nested loops, we schedule loops in the order of nesting. Scheduled loops are then reduced to a single atomic operator in subsequent acyclic scheduling phases. 2. To deal with loops with internal branching, we can utilize techniques such as (i) hierarchical reduction <ref> [22] </ref>, which collapses conditional constructs into atomic operators in an innermost to outermost order; and (ii) if-conversion [18]/reverse-if-conversion [33], which transform control dependences into data dependences and vice-versa. 6 Complexity of TimeC and Time tract Constraints 6.1 Complexity of TimeC TimeC constraints are undecidable since the halting problem can be trivially
Reference: [23] <author> A. Leung, K. Palem, and A. Pnueli. </author> <title> Scheduling instructions with real-time constraints on modern microprocessors. </title> <type> Unpublished, </type> <year> 1998. </year>
Reference-contexts: Time tract has the useful property that the complexity of instruction scheduling programs with these constraints is no greater than those of conventional instruction scheduling optimizations without timing constraints; we will show this in Section 6. In a companion paper <ref> [23] </ref>, we describe algorithms for instruction scheduling enhanced by timing constraints.
Reference: [24] <author> Z. Manna and A. Pnueli. </author> <title> Verification of concurrent programs: The temporal framework. In R.S. </title> <editor> Boyer and J.S. Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <pages> pages 215-273. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: This property can be expressed within TimeC by the following constraint time (q) time (p) 3 For simplicity, we assume that p and q can occur at most once in every computation. 7.5.1 The Timed Logic MTL The logic MTL (metric temporal logic) [6] extends conventional temporal logic (TL) <ref> [24] </ref> by introducing a bounded version of the temporal operators which subscripts a temporal operator such as 2 or by an interval [l; u]. The meaning of such an annotation is that the scope of the subscribed operator is limited to this interval.
Reference: [25] <author> N. Nachiappan. </author> <title> Personal communications and memorandum of support, </title> <year> 1995. </year>
Reference-contexts: We will start our discussion with an example. For convenience, we will first present the notions in the context of basic-blocks [1], [27]. 2.1 An Example Embedded Program Consider a program that controls a typical Cardiac Arrythmia monitor in a modern ICU <ref> [25] </ref>. In this case, we have a program P specified in an imperative or object-oriented language such as C or C++, as shown in figure 2 (a) at the granularity of functional basic-blocks.
Reference: [26] <author> J.S. Ostroff. </author> <title> Temporal Logic of Real-Time Systems. </title> <booktitle> Advanced Software Development Series. </booktitle> <publisher> Research Studies Press (John Wiley & Sons), </publisher> <address> Taunton, England, </address> <year> 1990. </year>
Reference-contexts: It is shown that this property cannot be expressed by any MTL formula over dense time domains. 7.5.3 The Logics RTTL and XCTL The logic RTTL (real-time temporal logic) <ref> [26] </ref> uses a special variable T to represent the current value of the master clock, and allows arbitrary first-order quantification over rigid variables that record previous readings of the clock.
Reference: [27] <author> K. Palem and V. Sarkar. </author> <title> Code Optimization in Modern Compilers. </title> <institution> Western Institute of Computer Science, Stanford University, </institution> <address> CA, </address> <year> 1995. </year>
Reference-contexts: In this section we will describe the syntax and informal semantics of TimeC. The formal semantics of TimeC is described in section 3. We will start our discussion with an example. For convenience, we will first present the notions in the context of basic-blocks [1], <ref> [27] </ref>. 2.1 An Example Embedded Program Consider a program that controls a typical Cardiac Arrythmia monitor in a modern ICU [25]. <p> First, because of branching, we must also be sensitive to the program's control-flow in addition to data-dependence. In particular, moving instructions out of their initial basic-blocks past program branch and merge points [1], <ref> [27] </ref> in the CFG lead to "side-effects" which require special attention and add to the complexities. A significant issue that arises in the context of moving instructions globally is the effects of speculation and replication.
Reference: [28] <author> B. Rau. </author> <title> Iterative modulo scheduling: An algorithm for software pipelining loops. </title> <booktitle> Proceedings of the 27th Annual Symposium on Microarchitecture, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: The last column of figure 15 shows such a feasible schedule after scheduling. As is standard in conventional global scheduling ([2], [9], [11], <ref> [28] </ref>), we treat loop scheduling [28], [22] and acyclic scheduling [2], [9], [11] separately. This division of tasks is traditionally used since combining both in the same scheduling framework leads to high degree of complexity in engineering and analysis. <p> The last column of figure 15 shows such a feasible schedule after scheduling. As is standard in conventional global scheduling ([2], [9], [11], <ref> [28] </ref>), we treat loop scheduling [28], [22] and acyclic scheduling [2], [9], [11] separately. This division of tasks is traditionally used since combining both in the same scheduling framework leads to high degree of complexity in engineering and analysis. <p> Together these conditions imply that the scheduled program P 0 preserves the functional semantics of program P and satisfies the timing-constraints imposed by TimeC. 5.1.3 Instruction scheduling for loops Software pipelining <ref> [28] </ref>, [22] is a common technique for exploiting instruction-level parallelism in loops by overlapping instructions multiple iterations together to hide the long latencies within an iteration.
Reference: [29] <author> Alan Shaw. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <year> 1989. </year>
Reference-contexts: Most of the previous work on timing constraint formalisms, such as RTL [16] and Hoare Logic with time <ref> [29] </ref>, concentrated on the tasks of specification and verification of real-time systems. Consequently, these formalisms are typically very expressive which makes the goal of automatic synthesis according to a given specification highly intractable. Currently, the only language notations that seriously consider the synthesize problem are TCEL [15] and CRL [31]. <p> All these assertions are used by the program transformation process to extract additional information to help satisfy the timing constraints. 28 7.4 Extending Hoare logic with time The work of Shaw <ref> [29] </ref> is concerned with reasoning timing constraints and execution times of high level programming languages. This work takes the approach of extending Hoare logic [14] with the ability to reason with time by introducing global clock variables that are updated after the execution of every statement.
Reference: [30] <author> Alexander D. stoyenko, Thomas J. Marlowe, and Phillip A. Laplante. </author> <title> A description language for engineering of complex real-time systems. </title> <type> Technical Report cis9522, </type> <institution> New Jersey Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: CRL uses CaRT-Spec <ref> [30] </ref> as an underlying specification language. System specifications are first presented in CaRT-Spec; CRL program stubs are generated from the specification by a translator tool. CRL programs are mapped into C++ through a program transformation/optimization process. Timing constraints CRL are specified in terms of labels annotated within CRL programs.
Reference: [31] <author> Alexander D. stoyenko, Thomas J. Marlowe, and Mohamed F. Younis. </author> <title> A language for complex real-time systems. </title> <type> Technical Report cis9521, </type> <institution> New Jersey Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: Consequently, these formalisms are typically very expressive which makes the goal of automatic synthesis according to a given specification highly intractable. Currently, the only language notations that seriously consider the synthesize problem are TCEL [15] and CRL <ref> [31] </ref>. However, in contrast to TimeC, both are new programming languages in their own right, and the programmer can only utilize the full power of the timing constraints within these new languages.
Reference: [32] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> 2 edition, </address> <year> 1990. </year>
Reference: [33] <author> Nancy Water, Scott Mahlke, Wen mei Hwu, and B. Rau. </author> <title> Reverse If-conversion. </title> <booktitle> In ACM SIGPLAN PLDI, </booktitle> <pages> pages 290-299, </pages> <year> 1993. </year> <month> 34 </month>
Reference-contexts: To deal with loops with internal branching, we can utilize techniques such as (i) hierarchical reduction [22], which collapses conditional constructs into atomic operators in an innermost to outermost order; and (ii) if-conversion [18]/reverse-if-conversion <ref> [33] </ref>, which transform control dependences into data dependences and vice-versa. 6 Complexity of TimeC and Time tract Constraints 6.1 Complexity of TimeC TimeC constraints are undecidable since the halting problem can be trivially encoded as TimeC constraints.
References-found: 33

